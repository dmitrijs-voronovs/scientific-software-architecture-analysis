quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Deployability,"//====process old versions before automatic schema evolution; //unfortunately we forgot to increment the TView3D version number; //when the class was upgraded to double precision in version 2.25.; //we are forced to use the file version number to recognize old files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TView3D.cxx:150,upgrade,upgraded,150,graf3d/g3d/src/TView3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TView3D.cxx,1,['upgrade'],['upgraded']
Deployability,"//A logical to toggle whether the final, global pruning step to simplify the tree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/inc/TMVA/MethodC50.h:15,toggle,toggle,15,tmva/rmva/inc/TMVA/MethodC50.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/inc/TMVA/MethodC50.h,1,['toggle'],['toggle']
Deployability,"//A logical toggle to evaluate possible advanced splits of the data. See Quinlan (1993) for details and examples.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/inc/TMVA/MethodC50.h:12,toggle,toggle,12,tmva/rmva/inc/TMVA/MethodC50.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/inc/TMVA/MethodC50.h,1,['toggle'],['toggle']
Deployability,"//Alternatively: pointer to an integer value to be Toggled instead of TObjectl",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/gui/inc/TToggle.h:51,Toggle,Toggled,51,core/gui/inc/TToggle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/gui/inc/TToggle.h,1,['Toggle'],['Toggled']
Deployability,"//Both press/release events.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/cocoa/inc/X11Events.h:13,release,release,13,graf2d/cocoa/inc/X11Events.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/cocoa/inc/X11Events.h,2,['release'],['release']
Deployability,"//BuildCXXNew depends on the SLoc to be; //valid!; // TODO: Propose a patch in clang",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp:70,patch,patch,70,interpreter/cling/lib/Interpreter/DynamicLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp,1,['patch'],['patch']
Deployability,"//Change in logZ updates only bin heights.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLH2PolyPainter.h:17,update,updates,17,graf3d/gl/inc/TGLH2PolyPainter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLH2PolyPainter.h,1,['update'],['updates']
Deployability,"//During rotation, usual TCanvas/TPad machinery (CopyPixmap/Flush/UpdateWindow/etc.); //is skipped - I use ""bit blasting"" functions to copy picture directly onto window.; //gGLManager->MarkForDirectCopy(glContext, kTRUE);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLHistPainter.cxx:66,Update,UpdateWindow,66,graf3d/gl/src/TGLHistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLHistPainter.cxx,1,['Update'],['UpdateWindow']
Deployability,"//Even if both reference the same NSObject, it's ok to do release.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/macosx/inc/CocoaUtils.h:58,release,release,58,core/macosx/inc/CocoaUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/macosx/inc/CocoaUtils.h,1,['release'],['release']
Deployability,"//FIXME I forgot to update the slider over the entries; // (nentries and firstentry might have changed after applying the selection)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TParallelCoordEditor.cxx:20,update,update,20,tree/treeviewer/src/TParallelCoordEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TParallelCoordEditor.cxx,1,['update'],['update']
Deployability,"//GL-view does not own GL-context, different GL contexts can be attached to the same view; //(though ROOT never does this). View has to know about GL-context only to notify it about; //geometry changes (calls -update method) and to clear drawable in a -dealloc method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/cocoa/inc/ROOTOpenGLView.h:210,update,update,210,graf2d/cocoa/inc/ROOTOpenGLView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/cocoa/inc/ROOTOpenGLView.h,1,['update'],['update']
Deployability,"//Generating Infer function definition for Edge update function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/src/RModel_GraphIndependent.cxx:48,update,update,48,tmva/sofie/src/RModel_GraphIndependent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/src/RModel_GraphIndependent.cxx,1,['update'],['update']
Deployability,"//In case directory was updated by another process, read new; //position for the keys",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx:24,update,updated,24,io/io/src/TDirectoryFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx,1,['update'],['updated']
Deployability,"//Installing the readline callbacks for completion in the; //method Interactive",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/src/TRInterface.cxx:2,Install,Installing,2,bindings/r/src/TRInterface.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/src/TRInterface.cxx,1,['Install'],['Installing']
Deployability,"//Lines with AA can be quite different; //from what we always had with X11.; //Now this is a switch in our configuration file (system.rootrc),; //so it can be disabled. This flag affects _only_ pad's graphics,; //GUI graphics is special and different. AA for fill area has a special; // switch because it is better to have it off by default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/cocoa/inc/TGQuartz.h:107,configurat,configuration,107,graf2d/cocoa/inc/TGQuartz.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/cocoa/inc/TGQuartz.h,1,['configurat'],['configuration']
Deployability,"//MakeTitle(""Update behaviour"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGL5DDataSetEditor.cxx:13,Update,Update,13,graf3d/gl/src/TGL5DDataSetEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGL5DDataSetEditor.cxx,1,['Update'],['Update']
Deployability,"//Not used yet: bitmask used when option is a toggle group",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TDataMember.h:46,toggle,toggle,46,core/meta/inc/TDataMember.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TDataMember.h,1,['toggle'],['toggle']
Deployability,"//Numerical integration poor for narrow peaks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooJohnson.cxx:12,integrat,integration,12,roofit/roofit/test/testRooJohnson.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooJohnson.cxx,1,['integrat'],['integration']
Deployability,"//ROOT::Math::Integrator ig(func, 0.001, 0.01, 100 );",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testGSLIntegration.cxx:14,Integrat,Integrator,14,math/mathmore/test/testGSLIntegration.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testGSLIntegration.cxx,1,['Integrat'],['Integrator']
Deployability,"//ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(""Gauss"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressMathCore.cxx:14,Integrat,IntegratorOneDimOptions,14,test/stressMathCore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressMathCore.cxx,1,['Integrat'],['IntegratorOneDimOptions']
Deployability,"//See if there is a writer, if there is we need to release; // our reader count so that the writer can proceed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TIsAProxy.cxx:51,release,release,51,core/meta/src/TIsAProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TIsAProxy.cxx,1,['release'],['release']
Deployability,"//SysWarning(""Setup"", ""failed to set keepalive option on input socket"");; // Install SigPipe handler to handle kKeepAlive failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:77,Install,Install,77,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,1,['Install'],['Install']
Deployability,"//TODO update Idexes; // compute fI_low, fB_low",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVWorkingSet.cxx:7,update,update,7,tmva/tmva/src/SVWorkingSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVWorkingSet.cxx,1,['update'],['update']
Deployability,"//TODO: Pull these inside TGLPhysicalShape; // Update clip box center",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLClip.cxx:47,Update,Update,47,graf3d/gl/src/TGLClip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLClip.cxx,1,['Update'],['Update']
Deployability,"//The object this Toggle belongs to",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/gui/inc/TToggle.h:18,Toggle,Toggle,18,core/gui/inc/TToggle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/gui/inc/TToggle.h,1,['Toggle'],['Toggle']
Deployability,"//This point is never updated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPadPainter.cxx:22,update,updated,22,graf2d/gpad/src/TPadPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPadPainter.cxx,1,['update'],['updated']
Deployability,"//This was the code with the old color table; // TCanvas *m = new TCanvas(""colors"",""Color Table"");; // TPad::DrawColorTable();; // m->Update();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootCanvas.cxx:134,Update,Update,134,gui/gui/src/TRootCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootCanvas.cxx,1,['Update'],['Update']
Deployability,"//True if either SetToggledObject or SetToggledVariable called - enables Toggle() method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/gui/inc/TToggle.h:73,Toggle,Toggle,73,core/gui/inc/TToggle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/gui/inc/TToggle.h,1,['Toggle'],['Toggle']
Deployability,"//Update branch only for the first 10 baskets",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:2,Update,Update,2,tree/tree/src/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx,1,['Update'],['Update']
Deployability,"//Update matrices in the hierarchy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TGeometry.cxx:2,Update,Update,2,graf3d/g3d/src/TGeometry.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TGeometry.cxx,2,['Update'],['Update']
Deployability,"//Update other tabs and change controls' states.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGL5DDataSetEditor.cxx:2,Update,Update,2,graf3d/gl/src/TGL5DDataSetEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGL5DDataSetEditor.cxx,2,['Update'],['Update']
Deployability,"//Update stress.root",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stress.cxx:2,Update,Update,2,test/stress.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stress.cxx,1,['Update'],['Update']
Deployability,"//Update the remote authentication table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSecContext.h:2,Update,Update,2,net/net/inc/TSecContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSecContext.h,1,['Update'],['Update']
Deployability,"//Update z coordinate in all patches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLH2PolyPainter.cxx:2,Update,Update,2,graf3d/gl/src/TGLH2PolyPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLH2PolyPainter.cxx,2,"['Update', 'patch']","['Update', 'patches']"
Deployability,"//Update();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEdit.cxx:2,Update,Update,2,gui/gui/src/TGTextEdit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEdit.cxx,1,['Update'],['Update']
Deployability,"//View's geometry is updated by ROOT's GUI, but view; //can be hidden at the moment (for example, tab with GL-view is not active; //at the moment). If so, when view is visible again, context must; //be notified about changes in a drawable's geometry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/cocoa/inc/ROOTOpenGLView.h:21,update,updated,21,graf2d/cocoa/inc/ROOTOpenGLView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/cocoa/inc/ROOTOpenGLView.h,1,['update'],['updated']
Deployability,"//Wrapper class for multi dimensional continuous distribution",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/inc/TUnuranMultiContDist.h:38,continuous,continuous,38,math/unuran/inc/TUnuranMultiContDist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/inc/TUnuranMultiContDist.h,1,['continuous'],['continuous']
Deployability,"//Wrapper class for one dimensional continuous distribution",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/inc/TUnuranContDist.h:36,continuous,continuous,36,math/unuran/inc/TUnuranContDist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/inc/TUnuranContDist.h,1,['continuous'],['continuous']
Deployability,"//[fNfixed] array of fixed/released params",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/inc/TLinearFitter.h:27,release,released,27,math/minuit/inc/TLinearFitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/inc/TLinearFitter.h,1,['release'],['released']
Deployability,"//\brief Release the lock by setting the false to false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Threading.h:9,Release,Release,9,interpreter/cling/lib/Interpreter/Threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Threading.h,1,['Release'],['Release']
Deployability,"//__________________________________________________________________; // Posterior Function class; // 1-Dim function as function of the poi; // and it integrated all the nuisance parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:151,integrat,integrated,151,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['integrat'],['integrated']
Deployability,//___________________________________________________________________; /**; Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/VirtualIntegrator.h:109,integrat,integration,109,math/mathcore/inc/Math/VirtualIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/VirtualIntegrator.h,7,"['Integrat', 'integrat']","['Integration', 'IntegratorMultiDim', 'IntegratorOneDim', 'integration', 'integrator']"
Deployability,//___________________________________________________________________; /**; Interface (abstract) class for 1D numerical integration; It must be implemented by the concrete Integrator classes like; ROOT::Math::GSLIntegrator.; Plug-in's exist in ROOT to be able to instantiate the derived classes via the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim. @ingroup Integration. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/VirtualIntegrator.h:120,integrat,integration,120,math/mathcore/inc/Math/VirtualIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/VirtualIntegrator.h,4,"['Integrat', 'integrat']","['Integration', 'Integrator', 'IntegratorOneDim', 'integration']"
Deployability,//___________________________________________________________________; /**; Interface (abstract) class for multi numerical integration; It must be implemented by the concrete Integrator classes like; ROOT::Math::GSLMCIntegrator.; Plug-in's exist in ROOT to be able to instantiate the derived classes via the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorMultiDim. @ingroup Integration. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/VirtualIntegrator.h:123,integrat,integration,123,math/mathcore/inc/Math/VirtualIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/VirtualIntegrator.h,4,"['Integrat', 'integrat']","['Integration', 'Integrator', 'IntegratorMultiDim', 'integration']"
Deployability,"//_________________________________________________________________________; /**. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommended to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h:113,integrat,integration,113,math/mathmore/inc/Math/GSLIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h,15,"['Integrat', 'integrat']","['Integration', 'integration']"
Deployability,"//____________________________________________________________________________; /**; class for the individual Minuit Parameter with Name and number;; contains the input numbers for the minimization or the output result; from minimization;; possible interactions: Fix/release, set/remove limits, set Value/error;. From version 5.20: use string to store the name to avoid limitation of; name length of 20 characters; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MinuitParameter.h:267,release,release,267,math/minuit2/inc/Minuit2/MinuitParameter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MinuitParameter.h,1,['release'],['release']
Deployability,"//______________________________________________________________________________; // Python callback dispatcher; // ==========================; //; // The TPyDispatcher class acts as a functor that can be used for TFn's and GUIs; // to install callbacks from CINT.; //- constructors/destructor --------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/TPyDispatcher.cxx:236,install,install,236,bindings/pyroot/pythonizations/src/TPyDispatcher.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/TPyDispatcher.cxx,1,['install'],['install']
Deployability,"//______________________________________________________________________________; // void TTreeSQL::LoadNumberEntries(); // {; // R__ASSERT(0);; // fResult = fServer->Query(fQuery.Data());; // fEntries=0;; // while(fResult->Next()){; // fEntries++;; // }; // fResult = fServer->Query(fQuery.Data());; // }; ////////////////////////////////////////////////////////////////////////////////; /// Refresh contents of this Tree and its branches from the current; /// Tree status in the database; /// One can call this function in case the Tree on its file is being; /// updated by another process",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeSQL.cxx:565,update,updated,565,tree/tree/src/TTreeSQL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeSQL.cxx,1,['update'],['updated']
Deployability,"//______________________________________________________________________________; //; // Command RELEASE; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:97,RELEASE,RELEASE,97,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['RELEASE'],['RELEASE']
Deployability,//_______________________________________________________________________________; /**; Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorOptions.h:113,integrat,integration,113,math/mathcore/inc/Math/IntegratorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorOptions.h,2,"['Integrat', 'integrat']","['Integration', 'integration']"
Deployability,//_______________________________________________________________________________; /**; Generic interface for defining configuration options of a numerical algorithm. @ingroup NumAlgo; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IOptions.h:119,configurat,configuration,119,math/mathcore/inc/Math/IOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IOptions.h,1,['configurat'],['configuration']
Deployability,//_______________________________________________________________________________; /**; Numerical multi dimensional integration options. @ingroup Integration; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorOptions.h:116,integrat,integration,116,math/mathcore/inc/Math/IntegratorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorOptions.h,2,"['Integrat', 'integrat']","['Integration', 'integration']"
Deployability,//_______________________________________________________________________________; /**; Numerical one dimensional integration options. @ingroup Integration; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorOptions.h:114,integrat,integration,114,math/mathcore/inc/Math/IntegratorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorOptions.h,2,"['Integrat', 'integrat']","['Integration', 'integration']"
Deployability,"//___________________________________________________________________________________; /**; Class describing the configuration of the fit, options and parameter settings; using the ROOT::Fit::ParameterSettings class. @ingroup FitMain; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitConfig.h:113,configurat,configuration,113,math/mathcore/inc/Fit/FitConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitConfig.h,1,['configurat'],['configuration']
Deployability,"//_____________________________________________________________________________________; /**; GSLSimAnMinimizer class for minimization using simulated annealing; using the algorithm from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Simulated-Annealing.html"">; GSL</A>.; It implements the ROOT::Minimizer interface and; a plug-in (name ""GSLSimAn"") exists to instantiate this class via the plug-in manager; Configuration (Setting/getting) the options is done through the methods defined in the; ROOT::Math::Minimizer class.; The user needs to call the base class method ROOT::Math::Minimizer::SetOptions to set the; corresponding options.; Here is some code example for increasing n_tries from 200 (default) to 1000; ```; ROOT::Math::GenAlgoOptions simanOpt;; simanOpt.SetValue(""n_tries"", 1000);; ROOT::Math::MinimizerOptions opt;; opt.SetExtraOptions(simanOpt);; minimizer->SetOptions(opt);; ```. @ingroup MultiMin; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLSimAnMinimizer.h:419,Configurat,Configuration,419,math/mathmore/inc/Math/GSLSimAnMinimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLSimAnMinimizer.h,1,['Configurat'],['Configuration']
Deployability,"//___________________________________________________________________________________________; /**; User class for calculating the derivatives of a function. It can calculate first (method Derivative1),; second (method Derivative2) and third (method Derivative3) of a function. It uses the Richardson extrapolation method for function derivation in a given interval.; The method use 2 derivative estimates (one computed with step h and one computed with step h/2); to compute a third, more accurate estimation. It is equivalent to the; <a href = http://en.wikipedia.org/wiki/Five-point_stencil>5-point method</a>,; which can be obtained with a Taylor expansion.; A step size should be given, depending on x and f(x).; An optimal step size value minimizes the truncation error of the expansion and the rounding; error in evaluating x+h and f(x+h). A too small h will yield a too large rounding error while a too large; h will give a large truncation error in the derivative approximation.; A good discussion can be found in discussed in; <a href=http://www.nrbook.com/a/bookcpdf/c5-7.pdf>Chapter 5.7</a> of Numerical Recipes in C.; By default a value of 0.001 is uses, acceptable in many cases. This class is implemented using code previously in TF1::Derivate{,2,3}(). Now TF1 uses this class. @ingroup Deriv. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/RichardsonDerivator.h:1067,a/b,a/bookcpdf,1067,math/mathcore/inc/Math/RichardsonDerivator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/RichardsonDerivator.h,1,['a/b'],['a/bookcpdf']
Deployability,//___________________________________________________________________________________________; /**; User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GaussIntegrator.h:135,integrat,integration,135,math/mathcore/inc/Math/GaussIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GaussIntegrator.h,3,"['Integrat', 'integrat']","['Integration', 'integration']"
Deployability,//___________________________________________________________________________________________; /**; User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GaussLegendreIntegrator.h:135,integrat,integration,135,math/mathcore/inc/Math/GaussLegendreIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GaussLegendreIntegrator.h,3,"['Integrat', 'integrat']","['Integration', 'integration']"
Deployability,//___________________________________________________________________________________________; /**; User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorMultiDim.h:143,integrat,integration,143,math/mathcore/inc/Math/IntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorMultiDim.h,4,"['Integrat', 'integrat']","['Integration', 'integration']"
Deployability,"//____________________________________________________________________________________________; /**. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophisticated type. When performances are; important, it is then recommended to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h:137,integrat,integration,137,math/mathcore/inc/Math/Integrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h,14,"['Integrat', 'integrat']","['Integration', 'integration']"
Deployability,"//_toleranceCompareLogs{2.E-14};; // make the integrator slightly more precise (1e-6 -> 1e-7) to reduce inaccuracy in fitting",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/vectorisedPDFs/testBukin.cxx:46,integrat,integrator,46,roofit/roofit/test/vectorisedPDFs/testBukin.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/vectorisedPDFs/testBukin.cxx,1,['integrat'],['integrator']
Deployability,"//bitmap_pad should be 8, 16 or 32 https://www.x.org/releases/X11R7.5/doc/man/man3/XPutPixel.3.html",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11ttf/src/TGX11TTF.cxx:53,release,releases,53,graf2d/x11ttf/src/TGX11TTF.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11ttf/src/TGX11TTF.cxx,1,['release'],['releases']
Deployability,"//c[ic]->Update();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/likelihoodrefs.cxx:9,Update,Update,9,tmva/tmvagui/src/likelihoodrefs.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/likelihoodrefs.cxx,1,['Update'],['Update']
Deployability,"//call UpdateTargets before next tree is grown",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx:7,Update,UpdateTargets,7,tmva/tmva/src/MethodBDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx,1,['Update'],['UpdateTargets']
Deployability,//cl_khr_fp16; /**; * Error function encountered in integrating the; * normal distribution.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:52,integrat,integrating,52,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h,1,['integrat'],['integrating']
Deployability,//cl_khr_fp16; /**; * Wait for events that identify the; * async_work_group_copy operations to; * complete. The event objects specified in; * event_list will be released after the wait is; * performed.; * This function must be encountered by all workitems; * in a work-group executing the kernel with; * the same num_events and event objects specified; * in event_list; otherwise the results are undefined.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:161,release,released,161,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h,1,['release'],['released']
Deployability,"//compare analytical integration with numerical one",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testAnalyticalIntegrals.cxx:21,integrat,integration,21,math/mathcore/test/testAnalyticalIntegrals.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testAnalyticalIntegrals.cxx,1,['integrat'],['integration']
Deployability,"//cout << ""NUMINT intDepList = "" << intDepList << std::endl ;; // Loop again over function servers to add remaining numeric integrations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:124,integrat,integrations,124,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['integrat'],['integrations']
Deployability,"//cout << ""ROP::aIWN updateCoefCache with rangeName = "" << (rangeName?rangeName:""<null>"") << std::endl ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:21,update,updateCoefCache,21,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,1,['update'],['updateCoefCache']
Deployability,"//cout << ""RooNumGenFactory::storeSampler() ERROR: integrator '"" << name << ""' already registered"" << endl ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumGenFactory.cxx:51,integrat,integrator,51,roofit/roofitcore/src/RooNumGenFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumGenFactory.cxx,1,['integrat'],['integrator']
Deployability,"//cout << ""RooNumIntFactory::storeIntegrator() ERROR: integrator '"" << name << ""' already registered"" << std::endl ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumIntFactory.cxx:54,integrat,integrator,54,roofit/roofitcore/src/RooNumIntFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumIntFactory.cxx,1,['integrat'],['integrator']
Deployability,"//defined(__opencl_c_named_address_space_builtins); // OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; /**; * All work-items in a work-group executing the kernel; * on a processor must execute this function before any; * are allowed to continue execution beyond the barrier.; * This function must be encountered by all work-items in; * a work-group executing the kernel.; * If barrier is inside a conditional statement, then all; * work-items must enter the conditional if any work-item; * enters the conditional statement and executes the; * barrier.; * If barrer is inside a loop, all work-items must execute; * the barrier for each iteration of the loop before any are; * allowed to continue execution beyond the barrier.; * The barrier function also queues a memory fence; * (reads and writes) to ensure correct ordering of; * memory operations to local or global memory.; * The flags argument specifies the memory address space; * and can be set to a combination of the following literal; * values.; * CLK_LOCAL_MEM_FENCE - The barrier function; * will either flush any variables stored in local memory; * or queue a memory fence to ensure correct ordering of; * memory operations to local memory.; * CLK_GLOBAL_MEM_FENCE - The barrier function; * will queue a memory fence to ensure correct ordering; * of memory operations to global memory. This can be; * useful when work-items, for example, write to buffer or; * image objects and then want to read the updated data.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1491,update,updated,1491,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h,1,['update'],['updated']
Deployability,"//do not update if big zoom and points moved",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:9,update,update,9,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,2,['update'],['update']
Deployability,"//fBuilder->Update();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx:12,Update,Update,12,gui/guibuilder/src/TGuiBldDragManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx,7,['Update'],['Update']
Deployability,"//fNoChi2->Connect(""Toggled(Bool_t)"",""TFitEditor"",this,""DoNoChi2()"");; // draw options",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:20,Toggle,Toggled,20,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['Toggle'],['Toggled']
Deployability,"//fNoChi2->Disconnect(""Toggled(Bool_t)"");; // draw options",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:23,Toggle,Toggled,23,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['Toggle'],['Toggled']
Deployability,"//fNormAdd -> Connect(""Toggled(Bool_t)"", ""TFitEditor"", this, ""DoNormAddition(Bool_t)"");; //fConv -> Connect(""Toggled(Bool_t)"", ""TFitEditor"", this, ""DoConvolution(Bool_t)"");; // fit options",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:23,Toggle,Toggled,23,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,2,['Toggle'],['Toggled']
Deployability,"//flag toggle method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/gui/inc/TClassMenuItem.h:7,toggle,toggle,7,core/gui/inc/TClassMenuItem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/gui/inc/TClassMenuItem.h,1,['toggle'],['toggle']
Deployability,"//for multi-dim integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AllIntegrationTypes.h:16,integrat,integration,16,math/mathcore/inc/Math/AllIntegrationTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AllIntegrationTypes.h,1,['integrat'],['integration']
Deployability,"//for versions 2.26 (never released)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:27,release,released,27,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['release'],['released']
Deployability,"//gPad->Update();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:8,Update,Update,8,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,3,['Update'],['Update']
Deployability,"//gVirtualX->Update(kFALSE);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlDraw.cxx:13,Update,Update,13,gui/guihtml/src/TGHtmlDraw.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlDraw.cxx,1,['Update'],['Update']
Deployability,"//gVirtualX->UpdateWindow(1); // cause problems with OpenGL in pad...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:13,Update,UpdateWindow,13,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,1,['Update'],['UpdateWindow']
Deployability,"//if (!show) gPad->GetCanvas()->ToggleEventStatus();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFileDrawMap.cxx:32,Toggle,ToggleEventStatus,32,tree/treeplayer/src/TFileDrawMap.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFileDrawMap.cxx,1,['Toggle'],['ToggleEventStatus']
Deployability,"//if (ifail) Warning(""TF1Helper::IntegralError"",""n-dim integration failed code=%d I = %g, relerr =%g, ncall = %d, maxpts = %d, epsrel = %g, epsabs = %g, "",ifail,integral,relerr,nfnevl,maxpts,epsrel,epsabs);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx:55,integrat,integration,55,hist/hist/src/TF1Helper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx,1,['integrat'],['integration']
Deployability,"//if (ncall <= 0) ncall = IntegratorOneDimOptions::DefaultNCalls();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Integrator.cxx:26,Integrat,IntegratorOneDimOptions,26,math/mathcore/src/Integrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Integrator.cxx,1,['Integrat'],['IntegratorOneDimOptions']
Deployability,"//if GSL is available load (and register GSL integrator)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumIntFactory.cxx:45,integrat,integrator,45,roofit/roofitcore/src/RooNumIntFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumIntFactory.cxx,1,['integrat'],['integrator']
Deployability,"//integration limits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testIntegrationMultiDim.cxx:2,integrat,integration,2,math/mathcore/test/testIntegrationMultiDim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testIntegrationMultiDim.cxx,2,['integrat'],['integration']
Deployability,"//loop on all branches and update them",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:27,update,update,27,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['update'],['update']
Deployability,"//method to compute the range(number total of operations for every bit configuration)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/VariableImportance.h:71,configurat,configuration,71,tmva/tmva/inc/TMVA/VariableImportance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/VariableImportance.h,1,['configurat'],['configuration']
Deployability,"//methodcall for state getter in case this is a *TOGGLE method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TMethod.h:49,TOGGLE,TOGGLE,49,core/meta/inc/TMethod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TMethod.h,1,['TOGGLE'],['TOGGLE']
Deployability,"//methodcall for state setter in case this is a *TOGGLE method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TMethod.h:49,TOGGLE,TOGGLE,49,core/meta/inc/TMethod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TMethod.h,1,['TOGGLE'],['TOGGLE']
Deployability,"//multidim function to integrate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testIntegrationMultiDim.cxx:23,integrat,integrate,23,math/mathcore/test/testIntegrationMultiDim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testIntegrationMultiDim.cxx,2,['integrat'],['integrate']
Deployability,"//no need to update the index if no new classes added to the file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TParallelMergingFile.cxx:13,update,update,13,net/net/src/TParallelMergingFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TParallelMergingFile.cxx,1,['update'],['update']
Deployability,"//otherwise the current directory in the file view; //window is not always updated when a picture is saved",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/canvsave.cxx:75,update,updated,75,test/histviewer/canvsave.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/canvsave.cxx,1,['update'],['updated']
Deployability,"//otherwise the current directory is; //not always updated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/histaction.cxx:51,update,updated,51,test/histviewer/histaction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/histaction.cxx,1,['update'],['updated']
Deployability,"//set the number of entries to be the same as the original histo; // do ""function like"" integration = sum of (bin_width*bin_content):",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/KDEKernel.cxx:88,integrat,integration,88,tmva/tmva/src/KDEKernel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/KDEKernel.cxx,1,['integrat'],['integration']
Deployability,"//state getter in case this is a *TOGGLE method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TMethod.h:34,TOGGLE,TOGGLE,34,core/meta/inc/TMethod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TMethod.h,1,['TOGGLE'],['TOGGLE']
Deployability,"//suppress messages for num integration of Roofit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx:28,integrat,integration,28,roofit/roostats/src/ToyMCSampler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx,2,['integrat'],['integration']
Deployability,"//the parameters for the update function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/inc/TMVA/MethodRSNNS.h:25,update,update,25,tmva/rmva/inc/TMVA/MethodRSNNS.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/inc/TMVA/MethodRSNNS.h,1,['update'],['update']
Deployability,"//the update function to use",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/inc/TMVA/MethodRSNNS.h:6,update,update,6,tmva/rmva/inc/TMVA/MethodRSNNS.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/inc/TMVA/MethodRSNNS.h,1,['update'],['update']
Deployability,"//to be updated // ref time on pcbrun4",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressMathMore.cxx:8,update,updated,8,test/stressMathMore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressMathMore.cxx,1,['update'],['updated']
Deployability,"//to update layout of list boxes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/histaction.cxx:5,update,update,5,test/histviewer/histaction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/histaction.cxx,1,['update'],['update']
Deployability,"//to update the geometry frame after drag resize",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx:5,update,update,5,gui/guibuilder/src/TGuiBldDragManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx,1,['update'],['update']
Deployability,"//type of integration method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMCIntegrator.h:10,integrat,integration,10,math/mathmore/inc/Math/GSLMCIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMCIntegrator.h,1,['integrat'],['integration']
Deployability,"//update Li & Lj if change is significant (??)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVWorkingSet.cxx:2,update,update,2,tmva/tmva/src/SVWorkingSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVWorkingSet.cxx,1,['update'],['update']
Deployability,"//update a, b, v, w and x",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/BrentMethods.cxx:2,update,update,2,math/mathcore/src/BrentMethods.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/BrentMethods.cxx,1,['update'],['update']
Deployability,"//update all histograms in the pad",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:2,update,update,2,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,1,['update'],['update']
Deployability,"//update alphai alphaj_p",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVWorkingSet.cxx:2,update,update,2,tmva/tmva/src/SVWorkingSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVWorkingSet.cxx,1,['update'],['update']
Deployability,"//update alphai_p alphaj",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVWorkingSet.cxx:2,update,update,2,tmva/tmva/src/SVWorkingSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVWorkingSet.cxx,1,['update'],['update']
Deployability,"//update editors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx:2,update,update,2,gui/guibuilder/src/TGuiBldDragManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx,3,['update'],['update']
Deployability,"//update error cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVWorkingSet.cxx:2,update,update,2,tmva/tmva/src/SVWorkingSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVWorkingSet.cxx,1,['update'],['update']
Deployability,"//update list of leaves in all TTreeFormula of the TTreePlayer (if any)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2,update,update,2,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['update'],['update']
Deployability,"//update object owning this axis",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:2,update,update,2,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,1,['update'],['update']
Deployability,"//update the number of processed entries",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TMPWorkerTree.h:2,update,update,2,tree/treeplayer/inc/TMPWorkerTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TMPWorkerTree.h,1,['update'],['update']
Deployability,"//virtual void UpdateBinContent(Int_t bin, Double_t content);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TProfile.h:15,Update,UpdateBinContent,15,hist/hist/inc/TProfile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TProfile.h,3,['Update'],['UpdateBinContent']
Deployability,"//walkCanvas->Update();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/MCMCIntervalPlot.cxx:14,Update,Update,14,roofit/roostats/src/MCMCIntervalPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/MCMCIntervalPlot.cxx,1,['Update'],['Update']
Deployability,"//we must update the class pointers pointing to 'this' in all TStreamerElements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:10,update,update,10,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['update'],['update']
Deployability,//~~; //===--------------------- DomTree Batch Updater --------------------------===; //~~,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:47,Update,Updater,47,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,1,['Update'],['Updater']
Deployability,"/license.txt) *; *****************************************************************************/; /**; \file RooNumConvolution.cxx; \class RooNumConvolution; \ingroup Roofitcore. Numeric 1-dimensional convolution operator PDF. This class can convolve any PDF; with any other PDF; This class should not be used blindly as numeric convolution is computing; intensive and prone to stability fitting problems. If an analytic convolution; can be calculated, you should use that or implement it if not available.; RooNumConvolution implements reasonable defaults that should convolve most; functions reasonably well, but results strongly depend on the shape of your; input PDFS so always check your result. The default integration engine for the numeric convolution is the; adaptive Gauss-Kronrod method, which empirically seems the most robust; for this task. You can override the convolution integration settings via; the RooNumIntConfig object reference returned by the convIntConfig() member; function; By default the numeric convolution is integrated from -infinity to; +infinity through a <pre>x -> 1/x</pre> coordinate transformation of the; tails. For convolution with a very small bandwidth it may be; advantageous (for both CPU consumption and stability) if the; integration domain is limited to a finite range. The function; setConvolutionWindow(mean,width,scale) allows to set a sliding; window around the x value to be calculated taking a RooAbsReal; expression for an offset and a width to be taken around the x; value. These input expression can be RooFormulaVars or other; function objects although the 3d 'scale' argument 'scale'; multiplies the width RooAbsReal expression given in the 2nd; argument, allowing for an appropriate window definition for most; cases without need for a RooFormulaVar object: e.g. a Gaussian; resolution PDF do setConvolutionWindow(gaussMean,gaussSigma,5); Note that for a 'wide' Gaussian the -inf to +inf integration; may converge more quickly than that over a ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx:1485,integrat,integration,1485,roofit/roofitcore/src/RooNumConvolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx,2,['integrat'],"['integrated', 'integration']"
Deployability,"/overflows and not just one single number. The parameter mode can be any combination of the letters `kKsSiourRmMen`; ~~~ {.cpp}; k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed; ~~~. For example, to print only name of histogram and number of entries do:; ~~~ {.cpp}; gStyle->SetOptStat(""ne"");; ~~~. To print only the name of the histogram do:; ~~~ {.cpp}; gStyle->SetOptStat(""n"");; ~~~. The default value is:; ~~~ {.cpp}; gStyle->SetOptStat(""nemr"");; ~~~. When a histogram is painted, a `TPaveStats` object is created and added; to the list of functions of the histogram. If a `TPaveStats` object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters. Once a histogram is painted, the statistics box can be accessed using; `h->FindObject(""stats"")`. In the command line it is enough to do:; ~~~ {.cpp}; Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); ~~~. because after `h->Draw()` the histogram is automatically painted. But; in a script file the painting should be forced using `gPad->Update()`; in order to make sure the statistics box is created:; ~~~ {.cpp}; h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");; ~~~. Without `gPad->Update()` the line `h->FindObject(""stats"")`; returns a null pointer. When a histogram is drawn with the option ""`SAME`"", the statistics box; is not drawn. To force the statistics box drawing with the option; ""`SAME`"", the option ""`SAMES`"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""`h`"" being the",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TPaveStats.cxx:2849,update,updated,2849,graf2d/graf/src/TPaveStats.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TPaveStats.cxx,1,['update'],['updated']
Deployability,"::RVecD{pt*0.9, pt*1.1}"",; {""down"", ""up""}); .Vary(""eta"",; [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; {""eta""},; 2);. auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; auto all_hs = VariationsFor(nom_h);; all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; ~~~. Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1). \note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; programming model will be streamlined in future versions. \note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases. See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis. \anchor rnode; ### RDataFrame objects as function arguments and return values; RDataFrame variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into); functions and to return them from functions. However, in general each dataframe node will have a different C++ type,; which includes all available compile-time information about what that node does. One way to cope with this complication; is to use template functions and/or C++14 auto return types:; ~~~{.cpp}; template <typename RDF>; auto ApplySomeFilters(RDF df); {; return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; }; ~~~. A possibly simpler, C++11-compatible alternative is to take advantage of the fact that ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:59893,release,releases,59893,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['release'],['releases']
Deployability,"::SetMethod), the expression is; executed via the interpreter when the button 1 is released. if no method has been set, and an object is referenced (TSlider::SetObject; has been called), while the slider is being moved/resized,; the object ExecuteEvent function is called. ### Example 1 using TSlider::SetMethod. #### macro xyslider.C. ~~~ {.cpp}; void xyslider(); {; // Example of macro featuring two sliders; TFile *f = new TFile(""hsimple.root"");; TH2F *hpxpy = (TH2F*)f->Get(""hpxpy"");; TCanvas *c1 = new TCanvas(""c1"");; TPad *pad = new TPad(""pad"",""Color plot pad"",0.1,0.1,0.98,0.98);; pad->Draw();; pad->cd();; hpxpy->Draw(""COLZ"");; c1->cd();. // Create two sliders in main canvas. When button1 will be released; // the macro action.C will be called.; TSlider *xslider = new TSlider(""xslider"",""x"",0.1,0.02,0.98,0.08);; xslider->SetMethod("".x action.C"");; TSlider *yslider = new TSlider(""yslider"",""y"",0.02,0.1,0.06,0.98);; yslider->SetMethod("".x action.C"");; }; ~~~. #### macro action.C. ~~~ {.cpp}; void action(); {; Int_t nx = hpxpy->GetXaxis()->GetNbins();; Int_t ny = hpxpy->GetYaxis()->GetNbins();; Int_t binxmin = nx*xslider->GetMinimum();; Int_t binxmax = nx*xslider->GetMaximum();; hpxpy->GetXaxis()->SetRange(binxmin,binxmax);; Int_t binymin = ny*yslider->GetMinimum();; Int_t binymax = ny*yslider->GetMaximum();; hpxpy->GetYaxis()->SetRange(binymin,binymax);; pad->cd();; hpxpy->Draw(""COLZ"");; c1->Update();; }; ~~~. The canvas and the sliders created in the above macro are shown in the picture; below. \image html gpad_slider.png. ### Example 2 using TSlider::SetObject macro xyslider.C. Same example as above. Instead of TSlider::SetMethod:; ~~~ {.cpp}; Myclass *obj = new Myclass(); // Myclass derived from TObject; xslider->SetObject(obj);; yslider->SetObject(obj);; ~~~. When the slider will be changed, MyClass::ExecuteEvent will be called with px=0; and py = 0; */; ////////////////////////////////////////////////////////////////////////////////; /// slider default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TSlider.cxx:1857,Update,Update,1857,graf2d/gpad/src/TSlider.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TSlider.cxx,1,['Update'],['Update']
Deployability,"; }; End_Macro. The following example shows a 2D histogram plotted with the option; `CONT4`. The option `CONT4` draws a contour plot using surface; colors to distinguish contours (`SURF` option at theta = 0). Combined; with the option `CONT` (or `CONT0`), the option `Z`; allows to display the color palette defined by `gStyle->SetPalette()`. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcont4->Fill(px-1,5*py);; hcont4->Fill(2+0.5*px,2*py-10.,0.1);; }; hcont4->Draw(""CONT4Z"");; }; End_Macro. The default number of contour levels is 20 equidistant levels and can be changed; with `TH1::SetContour()` or `TStyle::SetNumberContours()`. \anchor HP16a; #### The LIST option. When option `LIST` is specified together with option; `CONT`, the points used to draw the contours are saved in; `TGraph` objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in `TGraph` objects once the pad is painted.; Therefore to use this functionality in a macro, `gPad->Update()`; should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where `i` is a contour number, and list contains a list of; `TGraph` objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example (ContourList.C) shows how to use this functionality. Begin_Macro(source); ../../../tutorials/hist/ContourList.C; End_Macro. \anchor HP16b; #### The AITOFF, MERCATOR, SINUSOIDAL and PARABOLIC options. The following optio",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:67552,Update,Update,67552,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['Update'],['Update']
Deployability,"<tt>%CLASS%</tt> will be replaced by the current class's name,; <tt>%SRCFILE%</tt> and <tt>%INCFILE%</tt> by the name of the source and header file, resp.; (as given by <a href=""http://root.cern.ch/root/html/TClass.html#TClass:GetImplFileLine"">TClass::GetImplFileName()</a>,; <a href=""http://root.cern.ch/root/html/TClass.html#TClass:GetImplFileLine"">TClass::GetDeclFileName()</a>).; If the header is not generated for a class, they will be replaced by """".</p>. <p>Root's footer starts with the tag &lt;!--SIGNATURE--&gt;. It includes the; author(s), last update, copyright, the links to the Root home page, to the; user home page, to the index file (ClassIndex.html), to the top of the page; and <tt>this page is automatically generated</tt> information. It ends with the; tags <tt>&lt;/body&gt;&lt;/html&gt;</tt>. If you want to replace it,; <a href=""http://root.cern.ch/root/html/THtml.html"">THtml</a> will search for some; tags in your footer: Occurrences of the strings <tt>%AUTHOR%</tt>, <tt>%UPDATE%</tt>, and; <tt>%COPYRIGHT%</tt> are replaced by their; corresponding values before writing the html file. The <tt>%AUTHOR%</tt> tag will be; replaced by the exact string that follows Root.Html.Author, no link; generation will occur.</p>. <h4><a name=""conf:search"">II.7 Links to searches, home page, ViewVC</a></h4>. <p>Additional parameters can be set by Root.Html.Homepage (address of the; user's home page), Root.Html.SearchEngine (search engine for the class; documentation), Root.Html.Search (search URL, where %u is replaced by the; referer and %s by the escaped search expression), and a ViewVC base URL; Root.Html.ViewCVS. For the latter, the file name is appended or, if; the URL contains %f, %f is replaced by the file name.; All values default to """".</p>. <p>Examples:</p><pre>; Root.Html.Homepage: http://www.enricos-home.it; Root.Html.SearchEngine: http://root.cern.ch/root/Search.phtml; Root.Html.Search: http://www.google.com/search?q=%s+site%3A%u</pre>. <h4><a name=""conf:charset",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx:11248,UPDATE,UPDATE,11248,html/src/THtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx,1,['UPDATE'],['UPDATE']
Deployability,"Authors: Kyle Cranmer 17/06/2009; /*************************************************************************; * Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class RooStats::MCMCInterval; \ingroup Roostats. MCMCInterval is a concrete implementation of the RooStats::ConfInterval; interface. It takes as input Markov Chain of data points in the parameter; space generated by Monte Carlo using the Metropolis algorithm. From the Markov; Chain, the confidence interval can be determined in two ways:. #### Using a Kernel-Estimated PDF: (not the default method). A RooNDKeysPdf is constructed from the data set using adaptive kernel width.; With this RooNDKeysPdf F, we then integrate over the most likely domain in the; parameter space (tallest points in the posterior RooNDKeysPdf) until the target; confidence level is reached within an acceptable neighborhood as defined by; SetEpsilon(). More specifically: we calculate the following for different; cutoff values C until we reach the target confidence level: \f$\int_{ F >= C } F; d{normset} \f$.; Important note: this is not the default method because of a bug in constructing; the RooNDKeysPdf from a weighted data set. Configure to use this method by; calling SetUseKeys(true), and the data set will be interpreted without weights. #### Using a binned data set: (the default method). This is the binned analog of the continuous integrative method that uses the; kernel-estimated PDF. The points in the Markov Chain are put into a binned; data set and the interval is then calculated by adding the heights of the bins; in decreasing order until the desired level of confidence has been reached.; Note that this means the actual confidence level is >= the confidence level; prescribed by the client (unless the",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/MCMCInterval.cxx:978,integrat,integrate,978,roofit/roostats/src/MCMCInterval.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/MCMCInterval.cxx,1,['integrat'],['integrate']
Deployability,"CreateHistogramOfMigrations(). Bug fix with NaN in GetGlobalBinNumber(); // Version 17.5, in parallel to changes in TUnfold; // Version 17.4, bug fix with error handling; // Version 17.3, bug fix with underflow/overflow bins; // Version 17.2, with XML support, bug fix with bin map creation,; // isPeriodic option for neighbour bins; // Version 17.1, in parallel to changes in TUnfold; // Version 17.0, initial version, numbered in parallel to TUnfold; /** \class TUnfoldBinning; Binning schemes for use with the unfolding algorithm TUnfoldDensity. Binning schemes are used to map analysis bins on a single histogram; axis and back. The analysis bins may include unconnected bins (e.g; nuisances for background normalisation) or various multidimensional; histograms (signal bins, differential background normalisation bins, etc).; <br/>; If you use this software, please consider the following citation; <br/>; <b>S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]</b>; <br/>; Detailed documentation and updates are available on; http://www.desy.de/~sschmitt. <h3>Functionality</h3>. The TUnfoldBinning objects are connected by a tree-like structure.; The structure does not hold any data, but is only responsible for; arranging the analysis bins in the proper order.; Each node of the tree is responsible for a group of bins. That group; may consist of; <ul>; <li> several unconnected bins, each with a dedicated name.</li>; <li> bins organized in a multidimensional distribution, defined by a; set of axes. The axes are defined by a number of bins N and by (N+1); bin borders. In addition to the N bins inside there may be an underflow and an; overflow bin</li>; </ul>; Each bin has a ""global"" bin number, which can be found using the; GetGlobalBinNumber() methods. The global bin number 0 is reserved and; corresponds to the case where no bin is found in the; TUnfoldBinning tree. <h3>Use in the analysis</h3>; Booking histograms:; <ul>; <li>Define binning schemes on detector level and on truth l",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldBinning.cxx:1301,update,updates,1301,hist/unfold/src/TUnfoldBinning.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldBinning.cxx,1,['update'],['updates']
Deployability,"Data Files or Software without prior; * written authorization of the copyright holder.; */; /* ---------------------------------------------------------------------. Conversions between UTF32, UTF-16, and UTF-8. Header file. Several funtions are included here, forming a complete set of; conversions between the three formats. UTF-7 is not included; here, but is handled in a separate source file. Each of these routines takes pointers to input buffers and output; buffers. The input buffers are const. Each routine converts the text between *sourceStart and sourceEnd,; putting the result into the buffer between *targetStart and; targetEnd. Note: the end pointers are *after* the last item: e.g.; *(sourceEnd - 1) is the last item. The return result indicates whether the conversion was successful,; and if not, whether the problem was in the source or target buffers.; (Only the first encountered problem is indicated.). After the conversion, *sourceStart and *targetStart are both; updated to point to the end of last text successfully converted in; the respective buffers. Input parameters:; sourceStart - pointer to a pointer to the source buffer.; The contents of this are modified on return so that; it points at the next thing to be converted.; targetStart - similarly, pointer to pointer to the target buffer.; sourceEnd, targetEnd - respectively pointers to the ends of the; two buffers, for overflow checking only. These conversion functions take a ConversionFlags argument. When this; flag is set to strict, both irregular sequences and isolated surrogates; will cause an error. When the flag is set to lenient, both irregular; sequences and isolated surrogates are converted. Whether the flag is strict or lenient, all illegal sequences will cause; an error return. This includes sequences such as: <F4 90 80 80>, <C0 80>,; or <A0> in UTF-8, and values above 0x10FFFF in UTF-32. Conformant code; must check for illegal sequences. When the flag is set to lenient, characters over 0x10FFF",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h:3271,update,updated,3271,interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h,1,['update'],['updated']
Deployability,"Description; * <tr><td> **none** - *default* <td> No offsetting.; * <tr><td> **initial** <td> Offset likelihood by initial value (so that starting value of FCN in minuit is zero).; * This can improve numeric stability in simultaneous fits with components with large likelihood values.; * <tr><td> **bin** <td> Offset likelihood bin-by-bin with a template histogram model based on the obersved data.; * This results in per-bin values that are all in the same order of magnitude, which reduces precision loss in the sum,; * which can drastically improve numeric stability.; * Furthermore, \f$2\cdot \text{NLL}\f$ defined like this is approximately chi-square distributed, allowing for goodness-of-fit tests.; * </table>; * <tr><td> `IntegrateBins(double precision)` <td> In binned fits, integrate the PDF over the bins instead of using the probability density at the bin centre.; * This can reduce the bias observed when fitting functions with high curvature to binned data.; * - precision > 0: Activate bin integration everywhere. Use precision between 0.01 and 1.E-6, depending on binning.; * Note that a low precision such as 0.01 might yield identical results to 1.E-4, since the integrator might reach 1.E-4 already in its first; * integration step. If lower precision is desired (more speed), a RooBinSamplingPdf has to be created manually, and its integrator; * has to be manipulated directly.; * - precision = 0: Activate bin integration only for continuous PDFs fit to a RooDataHist.; * - precision < 0: Deactivate.; * \see RooBinSamplingPdf; * <tr><td> `ModularL(bool flag)` <td> Enable or disable modular likelihoods, which will become the default in a future release.; * This does not change any user-facing code, but only enables a different likelihood class in the back-end. Note that this; * should be set to true for parallel minimization of likelihoods!; * Note that it is currently not recommended to use Modular likelihoods without any parallelization enabled in the minimization, sin",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:9306,integrat,integration,9306,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['integrat'],['integration']
Deployability,"E P I X G L O B A L B E N C H M A R K; // ===============================================================; //; // HEPiX-HEPNT is an organization comprised of UNIX and Windows support staff; // in the High Energy Physics community.; // One of the HEPIX activities is to gather knowledge about new hardware; // and software and to recommend common solutions (eg Scientific Linux); // see: http://wwwhepix.web.cern.ch/wwwhepix/; //; // This benchmark suite has been implemented following several requests; // from HEPIX members interested by a collection of benchmarks representative; // of typical applications.; //; // stressHepix is a single benchmark inclusing several standard ROOT benchmarks; // with a mixture of CPU intensive tests and I/O tests.; // The output of stressHepix is one single number (the ROOTMARK).; // A Pentium IV 2.8GHz running Linux SLC3 and gcc3.2.3 runs this benchmark; // with a reference at 800 ROOTMARKs.; // To build the executable for this benchmark, do; // cd $ROOTSYS/test; // make; //; // The default configuration of ROOT is enough.; // The output of this benchmark looks like:; //; /// stressHepix; ///; ///; ///Starting stressHepix benchmark (details will be in stressHepix.log); ///Takes 442 CP seconds on a 500 rootmarks machine (IBM Thinkpad centrino 1.4GHz VC++7.1); ///Takes 278 CP seconds on a 800 rootmarks reference machine (P IV 2.8 GHz, SLC3 gcc3.2.3); ///Takes 239 CP seconds on a 924 rootmarks machine (MacBook 2.0GHz gcc4.0.1); ///Takes 209 CP seconds on a 1056 rootmarks machine (MacBook 2.0GHz icc9.1); ///Takes 147 CP seconds on a 1512 rootmarks machine (MacPro 3.0GHz gcc4.0.1); ///Takes 142 CP seconds on a 1550 rootmarks machine (AMD64/280, FC5 gcc4.1); ///Takes 121 CP seconds on a 1828 rootmarks machine (MacPro 3.0GHz icc9.1); ///; ///Running : stressFit Minuit 2000, (takes 11 RT seconds on the ref machine); ///Running : stressLinear, (takes 26 RT seconds on the ref machine); ///Running : stressGeometry, (takes 77 RT seconds on the ref m",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHepix.cxx:1201,configurat,configuration,1201,test/stressHepix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHepix.cxx,1,['configurat'],['configuration']
Deployability,"GetEntryWithIndex(majornumber, minornumber); /// ~~~; /// Example:; /// ~~~{.cpp}; /// tree.BuildIndex(""Run"",""Event""); //creates an index using leaves Run and Event; /// tree.GetEntryWithIndex(1234,56789); // reads entry corresponding to; /// // Run=1234 and Event=56789; /// ~~~; /// Note that majorname and minorname may be expressions using original; /// Tree variables eg: ""run-90000"", ""event +3*xx"". However the result; /// must be integer.; ///; /// In case an expression is specified, the equivalent expression must be computed; /// when calling GetEntryWithIndex.; ///; /// To build an index with only majorname, specify minorname=""0"" (default); ///; /// ## TreeIndex and Friend Trees; ///; /// Assuming a parent Tree T and a friend Tree TF, the following cases are supported:; /// - CASE 1: T->GetEntry(entry) is called; /// In this case, the serial number entry is used to retrieve; /// the data in both Trees.; /// - CASE 2: T->GetEntry(entry) is called, TF has a TreeIndex; /// the expressions given in major/minorname of TF are used; /// to compute the value pair major,minor with the data in T.; /// TF->GetEntryWithIndex(major,minor) is then called (tricky case!); /// - CASE 3: T->GetEntryWithIndex(major,minor) is called.; /// It is assumed that both T and TF have a TreeIndex built using; /// the same major and minor name.; ///; /// ## Saving the TreeIndex; ///; /// Once the index is built, it can be saved with the TTree object; /// with tree.Write(); (if the file has been open in ""update"" mode).; ///; /// The most convenient place to create the index is at the end of; /// the filling process just before saving the Tree header.; /// If a previous index was computed, it is redefined by this new call.; ///; /// Note that this function can also be applied to a TChain.; ///; /// The return value is the number of entries in the Index (< 0 indicates failure); ///; /// It is possible to play with different TreeIndex in the same Tree.; /// see comments in TTree::SetTreeIndex.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeIndex.cxx:2266,update,update,2266,tree/treeplayer/src/TTreeIndex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeIndex.cxx,1,['update'],['update']
Deployability,"H H III A Welcome to the Lund Monte Carlo! | |; | | P P Y Y T H H I A A This is PYTHIA version 8.100 | |; | | PPP Y T HHHHH I AAAAA Last date of change: 20 Oct 2007 | |; | | P Y T H H I A A | |; | | P Y T H H III A A Now is 27 Oct 2007 at 18:26:53 | |; | | | |; | | Main author: Torbjorn Sjostrand; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Department of Theoretical Physics, Lund University, Lund, Sweden; | |; | | phone: + 41 - 22 - 767 82 27; e-mail: torbjorn@thep.lu.se | |; | | Author: Stephen Mrenna; Computing Division, Simulations Group, | |; | | Fermi National Accelerator Laboratory, MS 234, Batavia, IL 60510, USA; | |; | | phone: + 1 - 630 - 840 - 2556; e-mail: mrenna@fnal.gov | |; | | Author: Peter Skands; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Theoretical Physics Department, | |; | | Fermi National Accelerator Laboratory, MS 106, Batavia, IL 60510, USA; | |; | | phone: + 41 - 22 - 767 24 59; e-mail: skands@fnal.gov | |; | | | |; | | The main program reference is the 'Brief Introduction to PYTHIA 8.1', | |; | | T. Sjostrand, S. Mrenna and P. Skands, arXiv:0710.3820 | |; | | | |; | | The main physics reference is the 'PYTHIA 6.4 Physics and Manual', | |; | | T. Sjostrand, S. Mrenna and P. Skands, JHEP05 (2006) 026 [hep-ph/0603175]. | |; | | | |; | | An archive of program versions and documentation is found on the web: | |; | | http://www.thep.lu.se/~torbjorn/Pythia.html | |; | | | |; | | This program is released under the GNU General Public Licence version 2. | |; | | Please respect the MCnet Guidelines for Event Generator Authors and Users. | |; | | | |; | | Disclaimer: this program comes without any guarantees. | |; | | Beware of errors and use common sense when interpreting results. | |; | | | |; | | Copyright (C) 2007 Torbjorn Sjostrand | |; | | | |; | | | |; | *------------------------------------------------------------------------------* |; | |; *------------------------------------------------------------------------------------*; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/pythia8/inc/TPythia8.h:1980,release,released,1980,montecarlo/pythia8/inc/TPythia8.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/pythia8/inc/TPythia8.h,1,['release'],['released']
Deployability,"I. Usage</a></h3>; These are typical things people do with THtml:; <pre>; root[] <a href=""http://root.cern.ch/root/html/THtml.html"">THtml</a> html; // create a <a href=""http://root.cern.ch/root/html/THtml.html"">THtml</a> object; root[] html.LoadAllLibs(); // Load all rootmap'ed libraries; root[] html.MakeAll(); // generate documentation for all changed classes; </pre>; or to run on just a few classes:; <pre>; root[] <a href=""http://root.cern.ch/root/html/THtml.html"">THtml</a> html; // create a <a href=""http://root.cern.ch/root/html/THtml.html"">THtml</a> object; root[] html.MakeIndex(); // create auxiliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only; </pre>; To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:; <pre>; root[] html.Convert( ""hsimple.C"", ""Histogram example"" ); </pre>. <h3><a name=""conf"">II. Configuration</a></h3>; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc. <h4><a name=""conf:input"">II.1 Input files</a></h4>. <p>In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: <a href=""http://root.cern.ch/root/html/TEnv.html"">TEnv</a>); of the classes you want to document, or call THtml::SetInputDir()</p>. <p>Example:</p><pre>; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html</pre>. <h4><a name=""conf:output"">II.2 Output directory</a></h4>. <p>The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist <a href=""http://root.cern.ch/root/html/THtml.html"">THtml</a>; will create it.</p>. <p>Example:</p><pre>; Root.Html.OutputDir: htmldoc</pre>. <h4><a name=""conf:liblink"">II.3 Linking other documentation</a></h4>. <p>When trying to document a class, THtml searches for a source file in; the directories set via S",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx:3725,Configurat,Configuration,3725,html/src/THtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx,2,"['Configurat', 'configurat']","['Configuration', 'configuration']"
Deployability,"Implementations *; * *; * Authors (alphabetical): *; * Tancredi Carli - CERN, Switzerland *; * Dominik Dannheim - CERN, Switzerland *; * S. Jadach - Institute of Nuclear Physics, Cracow, Poland *; * Alexander Voigt - TU Dresden, Germany *; * Peter Speckmayer - CERN, Switzerland *; * *; * Copyright (c) 2008, 2010: *; * CERN, Switzerland *; * MPI-K Heidelberg, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; /*! \class TMVA::PDEFoam; \ingroup TMVA. Implementation of PDEFoam. The PDEFoam method is an extension of the PDERS method, which uses; self-adapting binning to divide the multi-dimensional phase space; in a finite number of hyper-rectangles (boxes). For a given number of boxes, the binning algorithm adjusts the size; and position of the boxes inside the multidimensional phase space,; minimizing the variance of the signal and background densities inside; the boxes. The binned density information is stored in binary trees,; allowing for a very fast and memory-efficient classification of; events. The implementation of the PDEFoam is based on the monte-carlo; integration package TFoam included in the analysis package ROOT. The class TMVA::PDEFoam defines the default interface for the; PDEFoam variants:. - PDEFoamEvent; - PDEFoamDiscriminant; - PDEFoamTarget; - PDEFoamMultiTarget; - PDEFoamDecisionTree. Per default PDEFoam stores in the cells the number of events (event; weights) and therefore acts as an event density estimator.; However, the above listed derived classes override this behaviour; to implement certain PDEFoam variations. In order to use PDEFoam the user has to set the density estimator; of the type TMVA::PDEFoamDensityBase, which is used to during the foam; build-up. The default PDEFoam should be used with; PDEFoamEventDensity.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoam.cxx:1630,integrat,integration,1630,tmva/tmva/src/PDEFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoam.cxx,1,['integrat'],['integration']
Deployability,"LTO prelink,; // every call edge originated from the callee B will be transferred to; // the caller A. If any transferred edge (say A->C) is indirect, the; // original profiled indirect edge B->C, even if considered, would not; // enforce a top-down order from the caller A to the potential indirect; // call target C in LTO postlink since the inlined callee B is gone from; // the static call graph.; // 4. #3 can happen even for direct call targets, due to functions defined; // in header files. A header function (say A), when included into source; // files, is defined multiple times but only one definition survives due; // to ODR. Therefore, the LTO prelink inlining done on those dropped; // definitions can be useless based on a local file scope. More; // importantly, the inlinee (say B), once fully inlined to a; // to-be-dropped A, will have no profile to consume when its outlined; // version is compiled. This can lead to a profile-less prelink; // compilation for the outlined version of B which may be called from; // external modules. while this isn't easy to fix, we rely on the; // postlink AutoFDO pipeline to optimize B. Since the survived copy of; // the A can be inlined in its local scope in prelink, it may not exist; // in the merged IR in postlink, and we'll need the profiled call edges; // to enforce a top-down order for the rest of the functions.; //; // Considering those cases, a profiled call graph completely independent of; // the static call graph is constructed based on profile data, where; // function objects are not even needed to handle case #3 and case 4.; //; // Note that static callgraph edges are completely ignored since they; // can be conflicting with profiled edges for cyclic SCCs and may result in; // an SCC order incompatible with profile-defined one. Using strictly; // profile order ensures a maximum inlining experience. On the other hand,; // static call edges are not so important when they don't correspond to a; // context in the profile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:2082,pipeline,pipeline,2082,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['pipeline'],['pipeline']
Deployability,"OT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; /// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; /// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; /// The current defaults are (""Minuit"",""Migrad"").; /// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; /// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:4901,Configurat,Configuration,4901,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['Configurat'],['Configuration']
Deployability,"Polar labels are drawn orthogonally to the polargram radius. |; | ""P"" | Polymarker are drawn at each point position. |; | ""E"" | Draw error bars. |; | ""F"" | Draw fill area (closed polygon). |; | ""A"" | Force axis redrawing even if a polargram already exists. |; | ""N"" | Disable the display of the polar labels. |. Begin_Macro(source); {; auto c46 = new TCanvas(""c46"",""c46"",500,500);; auto grP1 = new TGraphPolar();; grP1->SetTitle(""TGraphPolar example"");. grP1->SetPoint(0, (1*TMath::Pi())/4., 0.05);; grP1->SetPoint(1, (2*TMath::Pi())/4., 0.10);; grP1->SetPoint(2, (3*TMath::Pi())/4., 0.15);; grP1->SetPoint(3, (4*TMath::Pi())/4., 0.20);; grP1->SetPoint(4, (5*TMath::Pi())/4., 0.25);; grP1->SetPoint(5, (6*TMath::Pi())/4., 0.30);; grP1->SetPoint(6, (7*TMath::Pi())/4., 0.35);; grP1->SetPoint(7, (8*TMath::Pi())/4., 0.40);. grP1->SetMarkerStyle(20);; grP1->SetMarkerSize(1.);; grP1->SetMarkerColor(4);; grP1->SetLineColor(4);; grP1->Draw(""ALP"");. // Update, otherwise GetPolargram returns 0; c46->Update();; grP1->GetPolargram()->SetToRadian();; }; End_Macro. \anchor GrP5; ### Colors automatically picked in palette. \since **ROOT version 6.09/01**. When several graphs are painted in the same canvas or when a multi-graph is drawn,; it might be useful to have an easy and automatic way to choose; their color. The simplest way is to pick colors in the current active color; palette. Palette coloring for histogram is activated thanks to the options `PFC`; (Palette Fill Color), `PLC` (Palette Line Color) and `PMC` (Palette Marker Color).; When one of these options is given to `TGraph::Draw` the graph get its color; from the current color palette defined by `gStyle->SetPalette(...)`. The color; is determined according to the number of objects having palette coloring in; the current pad. Begin_Macro(source); ../../../tutorials/graphs/graphpalettecolor.C; End_Macro. Begin_Macro(source); ../../../tutorials/graphs/multigraphpalettecolor.C; End_Macro. \anchor GrP6; ### Reverse graphs' axis. \since",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:16585,Update,Update,16585,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,2,['Update'],['Update']
Deployability,"R""(.*/(v\d)-(\d\d)-00-patches)""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:22,patch,patches,22,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['patch'],['patches']
Deployability,"R""(; /*; UNICODE, INC. LICENSE AGREEMENT - DATA FILES AND SOFTWARE. See Terms of Use <https://www.unicode.org/copyright.html>; for definitions of Unicode Inc.’s Data Files and Software. NOTICE TO USER: Carefully read the following legal agreement.; BY DOWNLOADING, INSTALLING, COPYING OR OTHERWISE USING UNICODE INC.'S; DATA FILES (""DATA FILES""), AND/OR SOFTWARE (""SOFTWARE""),; YOU UNEQUIVOCALLY ACCEPT, AND AGREE TO BE BOUND BY, ALL OF THE; TERMS AND CONDITIONS OF THIS AGREEMENT.; IF YOU DO NOT AGREE, DO NOT DOWNLOAD, INSTALL, COPY, DISTRIBUTE OR USE; THE DATA FILES OR SOFTWARE. COPYRIGHT AND PERMISSION NOTICE. Copyright © 1991-2022 Unicode, Inc. All rights reserved.; Distributed under the Terms of Use in https://www.unicode.org/copyright.html. Permission is hereby granted, free of charge, to any person obtaining; a copy of the Unicode data files and any associated documentation; (the ""Data Files"") or Unicode software and any associated documentation; (the ""Software"") to deal in the Data Files or Software; without restriction, including without limitation the rights to use,; copy, modify, merge, publish, distribute, and/or sell copies of; the Data Files or Software, and to permit persons to whom the Data Files; or Software are furnished to do so, provided that either; (a) this copyright and permission notice appear with all copies; of the Data Files or Software, or; (b) this copyright and permission notice appear in associated; Documentation. THE DATA FILES AND SOFTWARE ARE PROVIDED ""AS IS"", WITHOUT WARRANTY OF; ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE; WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; NONINFRINGEMENT OF THIRD PARTY RIGHTS.; IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS; NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL; DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,; DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER; TORTIOUS ACTION",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UnicodeData/UnicodeNameMappingGenerator.cpp:265,INSTALL,INSTALLING,265,interpreter/llvm-project/llvm/utils/UnicodeData/UnicodeNameMappingGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UnicodeData/UnicodeNameMappingGenerator.cpp,2,['INSTALL'],"['INSTALL', 'INSTALLING']"
Deployability,"R""(; <!--; Please specify also how you obtained ROOT, such as `dnf install` / binary download / you built it yourself.; -->. ### Additional context; <!--; Add any other context about the problem here.; -->)""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:67,install,install,67,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['install'],['install']
Deployability,"R""(; OVERVIEW: Clang Static Analyzer -analyzer-config Option List. The following list of configurations are meant for development purposes only, as; some of the variables they define are set to result in the most optimal; analysis. Setting them to other values may drastically change how the analyzer; behaves, and may even result in instabilities, crashes!. USAGE: -analyzer-config <OPTION1=VALUE,OPTION2=VALUE,...>; -analyzer-config OPTION1=VALUE, -analyzer-config OPTION2=VALUE, ...; OPTIONS:; )""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:89,configurat,configurations,89,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,1,['configurat'],['configurations']
Deployability,"R""(; int CLASS_NAME::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char */*rangeName*/) const; {; // Support also using the imaginary unit; using namespace std::complex_literals;; // To be able to also comile C code, we define a variable that behaves like the ""I"" macro from C.; constexpr auto I = 1i;. // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED,; // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS. THE EXAMPLE; // BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X YOU CAN ALSO; // IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs; // EXPRESSION MULTIPLE TIMES.; )""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx:371,INTEGRAT,INTEGRATION,371,roofit/roofitcore/src/RooClassFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx,2,['INTEGRAT'],['INTEGRATION']
Deployability,"R""(; int CLASS_NAME::getGenerator(const RooArgSet &directVars, RooArgSet &generateVars, bool /*staticInitOK*/) const; {; // LIST HERE OVER WHICH VARIABLES INTERNAL GENERATION IS SUPPORTED, ASSIGN A; // NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS. THE EXAMPLE BELOW; // ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X. YOU CAN ALSO IMPLEMENT; // MORE THAN ONE GENERATOR CONFIGURATION BY REPEATING THE matchArgs; // EXPRESSION MULTIPLE TIMES. IF THE FLAG staticInitOK IS TRUE, THEN IT IS; // SAFE TO PRECALCULATE INTERMEDIATE QUANTITIES IN initGenerator(), IF IT IS; // NOT SET THEN YOU SHOULD NOT ADVERTISE ANY GENERATOR METHOD THAT RELIES ON; // PRECALCULATIONS IN initGenerator(). // if (matchArgs(directVars,generateVars,x)) return 1;; return 0;; }. void CLASS_NAME::generateEvent(int code); {; // GENERATE SET OF OBSERVABLES DEFINED BY RETURN CODE ASSIGNED BY; // getGenerator(). RETURN THE GENERATED VALUES BY ASSIGNING THEM TO THE; // PROXY DATA MEMBERS THAT REPRESENT THE CHOSEN OBSERVABLES. // assert(code==1);; // x = 0;; return;; }; )""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx:295,INTEGRAT,INTEGRATION,295,roofit/roofitcore/src/RooClassFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx,2,"['CONFIGURAT', 'INTEGRAT']","['CONFIGURATION', 'INTEGRATION']"
Deployability,"R""(OPTIONS:; --format - archive format to create; =default - default; =gnu - gnu; =darwin - darwin; =bsd - bsd; =bigarchive - big archive (AIX OS); --plugin=<string> - ignored for compatibility; -h --help - display this help and exit; --output - the directory to extract archive members to; --rsp-quoting - quoting style for response files; =posix - posix; =windows - windows; --thin - create a thin archive; --version - print the version and exit; -X{32|64|32_64|any} - object mode (only for AIX OS); @<file> - read options from <file>. OPERATIONS:; d - delete [files] from the archive; m - move [files] in the archive; p - print contents of [files] found in the archive; q - quick append [files] to the archive; r - replace or insert [files] into the archive; s - act as ranlib; t - display list of files in archive; x - extract [files] from the archive. MODIFIERS:; [a] - put [files] after [relpos]; [b] - put [files] before [relpos] (same as [i]); [c] - do not warn if archive had to be created; [D] - use zero for timestamps and uids/gids (default); [h] - display this help and exit; [i] - put [files] before [relpos] (same as [b]); [l] - ignored for compatibility; [L] - add archive's contents; [N] - use instance [count] of name; [o] - preserve original dates; [O] - display member offsets; [P] - use full names when matching (implied for thin archives); [s] - create an archive index (cf. ranlib); [S] - do not build a symbol table; [T] - deprecated, use --thin instead; [u] - update only [files] newer than archive contents; [U] - use actual timestamps and uids/gids; [v] - be verbose about actions taken; [V] - display the version and exit; )""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:1485,update,update,1485,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,1,['update'],['update']
Deployability,"R""(double CLASS_NAME::analyticalIntegral(int code, const char *rangeName) const; {; // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY; // getAnalyticalIntegral(). THE MEMBER FUNCTION x.min(rangeName) AND; // x.max(rangeName) WILL RETURN THE INTEGRATION BOUNDARIES FOR EACH; // OBSERVABLE x.; )""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx:256,INTEGRAT,INTEGRATION,256,roofit/roofitcore/src/RooClassFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx,1,['INTEGRAT'],['INTEGRATION']
Deployability,"R""<<<(; </div>; <div id='tooltiphint' hidden=""true"">; <p>Keyboard shortcuts: </p>; <ul>; <li>Use 'j/k' keys for keyboard navigation</li>; <li>Use 'Shift+S' to show/hide relevant lines</li>; <li>Use '?' to toggle this window</li>; </ul>; <a href=""#"" onclick=""toggleHelp(); return false;"">Close</a>; </div>; )<<<""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:205,toggle,toggle,205,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,2,['toggle'],"['toggle', 'toggleHelp']"
Deployability,"R""<<<(; </table>; <!-- REPORTSUMMARYEXTRA -->; <h3>Annotated Source Code</h3>; <p>Press <a href=""#"" onclick=""toggleHelp(); return false;"">'?'</a>; to see keyboard shortcuts</p>; <input type=""checkbox"" class=""spoilerhider"" id=""showinvocation"" />; <label for=""showinvocation"" >Show analyzer invocation</label>; <div class=""spoiler"">clang -cc1 )<<<""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:109,toggle,toggleHelp,109,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,1,['toggle'],['toggleHelp']
Deployability,"R""<<<(; <script type='text/javascript'>. var toggleHelp = function() {; var hint = document.querySelector(""#tooltiphint"");; var attributeName = ""hidden"";; if (hint.hasAttribute(attributeName)) {; hint.removeAttribute(attributeName);; } else {; hint.setAttribute(""hidden"", ""true"");; }; };; window.addEventListener(""keydown"", function (event) {; if (event.defaultPrevented) {; return;; }; if (event.key == ""?"") {; toggleHelp();; } else {; return;; }; event.preventDefault();; });; </script>; )<<<""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:45,toggle,toggleHelp,45,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,2,['toggle'],['toggleHelp']
Deployability,"RT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a function failed; // or succeeded. In those cases we use the state MaybeAllocated.; // Thus, the diagram above captures the intent, not implementation details.; //; // Due to the fact that the number of handle related syscalls in Fuchsia; // is large, we adopt the annotation attributes to descript syscalls'; // operations(acquire/release/use) on handles instead of hardcoding; // everything in the checker.; //; // We use following annotation attributes for handle related syscalls or; // functions:; // 1. __attribute__((acquire_handle(""Fuchsia""))) |handle will be acquired; // 2. __attribute__((release_handle(""Fuchsia""))) |handle will be released; // 3. __attribute__((use_handle(""Fuchsia""))) |handle will not transit to; // escaped state, it also needs to be open.; //; // For example, an annotated syscall:; // zx_status_t zx_channel_c",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:2336,Release,Released,2336,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,1,['Release'],['Released']
Deployability,"Removing these edges may break cycles that form this RefSCC and; /// thus this operation may change the RefSCC graph significantly. In; /// particular, this operation will re-form new RefSCCs based on the; /// remaining connectivity of the graph. The following invariants are; /// guaranteed to hold after calling this method:; ///; /// 1) If a ref-cycle remains after removal, it leaves this RefSCC intact; /// and in the graph. No new RefSCCs are built.; /// 2) Otherwise, this RefSCC will be dead after this call and no longer in; /// the graph or the postorder traversal of the call graph. Any iterator; /// pointing at this RefSCC will become invalid.; /// 3) All newly formed RefSCCs will be returned and the order of the; /// RefSCCs returned will be a valid postorder traversal of the new; /// RefSCCs.; /// 4) No RefSCC other than this RefSCC has its member set changed (this is; /// inherent in the definition of removing such an edge).; ///; /// These invariants are very important to ensure that we can build; /// optimization pipelines on top of the CGSCC pass manager which; /// intelligently update the RefSCC graph without invalidating other parts; /// of the RefSCC graph.; ///; /// Note that we provide no routine to remove a *call* edge. Instead, you; /// must first switch it to a ref edge using \c switchInternalEdgeToRef.; /// This split API is intentional as each of these two steps can invalidate; /// a different aspect of the graph structure and needs to have the; /// invalidation handled independently.; ///; /// The runtime complexity of this method is, in the worst case, O(V+E); /// where V is the number of nodes in this RefSCC and E is the number of; /// edges leaving the nodes in this RefSCC. Note that E includes both edges; /// within this RefSCC and edges from this RefSCC to child RefSCCs. Some; /// effort has been made to minimize the overhead of common cases such as; /// self-edges and edge removals which result in a spanning tree with no; /// more cycles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1199,pipeline,pipelines,1199,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,2,"['pipeline', 'update']","['pipelines', 'update']"
Deployability,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:586,configurat,configuration,586,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,1,['configurat'],['configuration']
Deployability,"See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements mapping the name of a unicode code point to its value.; //; // This file was generated using ./bin/UnicodeNameMappingGenerator.; // Do not edit manually.; //; //===----------------------------------------------------------------------===//; /*; UNICODE, INC. LICENSE AGREEMENT - DATA FILES AND SOFTWARE. See Terms of Use <https://www.unicode.org/copyright.html>; for definitions of Unicode Inc.’s Data Files and Software. NOTICE TO USER: Carefully read the following legal agreement.; BY DOWNLOADING, INSTALLING, COPYING OR OTHERWISE USING UNICODE INC.'S; DATA FILES (""DATA FILES""), AND/OR SOFTWARE (""SOFTWARE""),; YOU UNEQUIVOCALLY ACCEPT, AND AGREE TO BE BOUND BY, ALL OF THE; TERMS AND CONDITIONS OF THIS AGREEMENT.; IF YOU DO NOT AGREE, DO NOT DOWNLOAD, INSTALL, COPY, DISTRIBUTE OR USE; THE DATA FILES OR SOFTWARE. COPYRIGHT AND PERMISSION NOTICE. Copyright © 1991-2022 Unicode, Inc. All rights reserved.; Distributed under the Terms of Use in https://www.unicode.org/copyright.html. Permission is hereby granted, free of charge, to any person obtaining; a copy of the Unicode data files and any associated documentation; (the ""Data Files"") or Unicode software and any associated documentation; (the ""Software"") to deal in the Data Files or Software; without restriction, including without limitation the rights to use,; copy, modify, merge, publish, distribute, and/or sell copies of; the Data Files or Software, and to permit persons to whom the Data Files; or Software are furnished to do so, provided that either; (a) this copyright and permission notice appear with all copies; of the Data Files or Software, or; (b) this copyright and permission notice appear in associated; Documentation. THE DATA FILES AND SOFTWARE ARE PROVIDED ""AS IS"", WITHOUT WARRANTY O",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/UnicodeNameToCodepointGenerated.cpp:1157,INSTALL,INSTALL,1157,interpreter/llvm-project/llvm/lib/Support/UnicodeNameToCodepointGenerated.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/UnicodeNameToCodepointGenerated.cpp,1,['INSTALL'],['INSTALL']
Deployability,"Team; CERN and Fermilab; Packager: Anirudha Bose <ani07nov@gmail.com>. BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root. %description; Cling is a new and interactive C++11 standard compliant interpreter built; on the top of Clang and LLVM compiler infrastructure. Its advantages over; the standard interpreters are that it has command line prompt and uses; Just In Time (JIT) compiler for compilation. Many of the developers; (e.g. Mono in their project called CSharpRepl) of such kind of software; applications name them interactive compilers. One of Cling's main goals is to provide contemporary, high-performance; alternative of the current C++ interpreter in the ROOT project - CINT. Cling; serves as a core component of the ROOT system for storing and analyzing the; data of the Large Hadron Collider (LHC) experiments. The; backward-compatibility with CINT is major priority during the development. %prep; %setup; mkdir -p $RPM_BUILD_DIR/%{name}-%{version}/usr/share/doc; mv $RPM_BUILD_DIR/%{name}-%{version}/bin/ $RPM_BUILD_DIR/%{name}-%{version}/usr; mv $RPM_BUILD_DIR/%{name}-%{version}/docs/* $RPM_BUILD_DIR/%{name}-%{version}/usr/share/doc/; mv $RPM_BUILD_DIR/%{name}-%{version}/lib/ $RPM_BUILD_DIR/%{name}-%{version}/usr; mv $RPM_BUILD_DIR/%{name}-%{version}/include/ $RPM_BUILD_DIR/%{name}-%{version}/usr; mv $RPM_BUILD_DIR/%{name}-%{version}/share/* $RPM_BUILD_DIR/%{name}-%{version}/usr/share. rm -Rf $RPM_BUILD_DIR/%{name}-%{version}/docs; rm -Rf $RPM_BUILD_DIR/%{name}-%{version}/share. if [ ${RPM_ARCH} = 'x86_64' ]; then; mv $RPM_BUILD_DIR/%{name}-%{version}/usr/lib $RPM_BUILD_DIR/%{name}-%{version}/usr/lib64; fi. %build; # Empty section. %install; rm -rf %{buildroot}; mkdir -p %{buildroot}. # in builddir; cp -a * %{buildroot}. %clean; rm -rf %{buildroot}. %files; %defattr(-,root,root,-); %{_bindir}/*; %{_includedir}/*; %{_libdir}/*; %{_datadir}/*. %changelog; * Sun Apr 13 2014 Anirudha Bose <ani07nov@gmail.com>; - Initial SPEC file of Cling for RPM packaging; '''",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/cpt.py:1837,install,install,1837,interpreter/cling/tools/packaging/cpt.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/cpt.py,1,['install'],['install']
Deployability,"X) is processed, the; // DbgValueSinkCandidates and InstrMap will be populated and the RegisterMap; // entry for %2 will be populated as well. DbgValueSinkCandidates = {A -> X},; // RegisterMap = {2 -> {X}, 3 -> {}}, InstrMap {X -> 2}; // DBG_VALUE %2, A, .... # X; // -> DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the DBG_VALUE Y is processed, the DbgValueSinkCandidates is updated; // to now hold Y for A and the RegisterMap is also updated to remove X from; // %2, this is because both X and Y describe the same debug variable A. X is; // also updated to have a $noreg as the first operand.; // DbgValueSinkCandidates = {A -> {Y}}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap = {X-> 2}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // -> DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After DBG_VALUE Z is processed, the DbgValueSinkCandidates is updated to; // hold Z fr A, the RegisterMap is updated to hold Z for %3, and the InstrMap; // is updated to have Z mapped to %3. This is again because Z describes the; // debug variable A, Y is not updated to have $noreg as first operand because; // its first operand is an immediate, not a register.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // -> %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // Nothing happens here since the RegisterMap for %2 contains no value.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // -> %3 = ld ...; // %4 = ld ...; // Since the RegisterMap contains Z as a value for %3, the MachineInstr; // pointer Z is copied to come after the load for %3 and the old Z's first; // op",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3352,update,updated,3352,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,3,['update'],['updated']
Deployability,"[1,2,3]D; - HistoND; - Max; - Mean; - Min; - Profile[1,2,3]D; - Redefine; - Snapshot; - Stats; - StdDev; - Sum; - Systematic variations: Vary and [VariationsFor](\ref ROOT::RDF::Experimental::VariationsFor).; - Parallel submission of distributed graphs: [RunGraphs](\ref ROOT::RDF::RunGraphs).; - Information about the dataframe: GetColumnNames. with support for more operations coming in the future. Data sources other than TTree and TChain (e.g. CSV, RNTuple) are; currently not supported. \note The distributed RDataFrame module requires at least Python version 3.8. ### Connecting to a Spark cluster. In order to distribute the RDataFrame workload, you can connect to a Spark cluster you have access to through the; official [Spark API](https://spark.apache.org/docs/latest/rdd-programming-guide.html#initializing-spark), then hook the; connection instance to the distributed `RDataFrame` object like so:. ~~~{.py}; import pyspark; import ROOT. # Create a SparkContext object with the right configuration for your Spark cluster; conf = SparkConf().setAppName(appName).setMaster(master); sc = SparkContext(conf=conf). # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame. # The Spark RDataFrame constructor accepts an optional ""sparkcontext"" parameter; # and it will distribute the application to the connected cluster; df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); ~~~. If an instance of [SparkContext](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkContext.html); is not provided, the default behaviour is to create one in the background for you. ### Connecting to a Dask cluster. Similarly, you can connect to a Dask cluster by creating your own connection object which internally operates with one; of the cluster schedulers supported by Dask (more information in the; [Dask distributed docs](http://distributed.dask.org/en/stable/)):. ~~~{.py}; import ROOT; from dask.distributed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:38460,configurat,configuration,38460,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['configurat'],['configuration']
Deployability,"____________________; // void TGTable::InsertRowAfter(UInt_t row, UInt_t nrows); // {; // }; // //______________________________________________________________________________; // void TGTable::InsertRowAfter(TGString label, UInt_t nrows); // {; // }; // //______________________________________________________________________________; // void TGTable::InsertRowAt(UInt_t row, UInt_t nrows); // {; // }; // //______________________________________________________________________________; // void TGTable::InsertRowAt(TGString label, UInt_t nrows); // {; // }; // //______________________________________________________________________________; // void TGTable::InsertColumnBefore(UInt_t column, UInt_t ncolumns); // {; // }; // //______________________________________________________________________________; // void TGTable::InsertColumnBefore(TGString label, UInt_t ncolumns); // {; // }; // //______________________________________________________________________________; // void TGTable::InsertColumnAfter(UInt_t column, UInt_t ncolumns); // {; // }; // //______________________________________________________________________________; // void TGTable::InsertColumnAfter(TGString label, UInt_t ncolumns); // {; // }; // //______________________________________________________________________________; // void TGTable::InsertColumnAt(UInt_t column, UInt_t ncolumns); // {; // }; // //______________________________________________________________________________; // void TGTable::InsertColumnAt(TGString label, UInt_t ncolumns); // {; // }; // //______________________________________________________________________________; // void TGTable::RemoveRows(UInt_t row, UInt_t nrows); // {; // }; // //______________________________________________________________________________; // void TGTable::RemoveColumns(UInt_t column, UInt_t ncolumns); // {; // }; ////////////////////////////////////////////////////////////////////////////////; /// Update and layout the visible part of the TGTable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTable.cxx:2332,Update,Update,2332,gui/gui/src/TGTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTable.cxx,1,['Update'],['Update']
Deployability,"`; * When a PDF is wrapped with a RooBinSamplingPDF, just use the bin sampling PDF instead of the original one for fits; * or plotting etc.; * \note The binning will be taken from the observable. Make sure that this binning is the same as the one of the dataset that should be fit.; * Use RooRealVar::setBinning() to adapt it.; * - Instruct test statistics to carry out this wrapping automatically:; * ```; * pdf.fitTo(data, IntegrateBins(<precision>));; * ```; * This method is especially useful when used with a simultaneous PDF, since each component will automatically be wrapped,; * depending on the value of `precision`:; * - `precision < 0.`: None of the PDFs are touched, bin sampling is off.; * - `precision = 0.`: Continuous PDFs that are fit to a RooDataHist are wrapped into a RooBinSamplingPdf. The target precision; * forwarded to the integrator is 1.E-4 (the default argument of the constructor).; * - `precision > 0.`: All continuous PDFs are automatically wrapped into a RooBinSamplingPdf, regardless of what data they are; * fit to (see next paragraph). The same `'precision'` is used for all integrators.; *; * ### Simulating a binned fit using RooDataSet; * Some frameworks use unbinned data (RooDataSet) to simulate binned datasets. By adding one entry for each bin centre with the; * appropriate weight, one can achieve the same result as fitting with RooDataHist. In this case, however, RooFit cannot; * auto-detect that a binned fit is running, and that an integration over the bin is desired (note that there are no bins to; * integrate over in this kind of dataset).; *; * In this case, `IntegrateBins(>0.)` needs to be used, and the desired binning needs to be assigned to the observable; * of the dataset:; * ```; * RooRealVar x(""x"", ""x"", 0., 5.);; * x.setBins(10);; *; * // <create dataset and model>; *; * model.fitTo(data, IntegrateBins(>0.));; * ```; *; * \see RooAbsPdf::fitTo(); * \see IntegrateBins(); *; * \note This feature is currently limited to one-dimensional P",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:2896,continuous,continuous,2896,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,1,['continuous'],['continuous']
Deployability,"a copy of the GNU Library General Public; * License along with the GNU LIBICONV Library; see the file COPYING.LIB.; * If not, write to the Free Software Foundation, Inc., 51 Franklin Street,; * Fifth Floor, Boston, MA 02110-1301, USA.; */; /*; * ISO-IR-165; */; /*; * ISO-IR-165 is an extension of GB 2312, consisting of:; * 1. GB 6345.1-86 corrections:; * Two corrections to GB 2312, at 0x2367 and 0x6F71.; * 2. GB 6345.1-86 additions:; * - 6 new full-width pinyin characters in row 0x28.; * - ISO646-CN in row 0x2A.; * - 32 half-width pinyin characters in row 0x2B.; * 3. GB 8565.2-88 additions:; * - 50 characters in row 0x2D.; * - 92 characters in row 0x2E.; * - 93 characters in row 0x2F.; * - 470 characters in rows 0x7A-0x7E.; * 4. ISO-IR-165 additions:; * - 22 characters in row 0x26.; * - 94 characters in row 0x2C.; * - 44 new characters in row 0x2D.; * - 1 new character in row 0x2F.; *; * The conversion table was created from the following sources:; * Ad 1. The 0x2367 correction is already integrated in the unicode.org; * GB2312.TXT table. The 0x6F71 mapping is the same in the unicode.org; * GB2312.TXT and UNIHAN.TXT table and in Koichi Yasuoka's Uni2GB table,; * so we assume it's correct.; * The unicode.org UNIHAN.TXT table about GB 8565 is not usable: it has; * extraneous code points at rows 0x28, 0x2C, 0x2D. Note also that it does; * not list the 69 non-hanzi in row 0x2F. Moreover, it has the characters; * 0x2F7A-0x2F7D shifted down by one to 0x2F79-0x2F7C.; * Therefore we take the GB8565 and ISO-IR-165 data from Koichi Yasuoka's; * Uni2GB table.; * Ad 1. Yasuoka maps 0x2367 to U+0261 (small script g) and 0x2840 to U+FF47; * (full-width small normal g). While coherent with ISO-IR's 165.pdf,; * this disagrees with Ken Lunde's book: He says that ISO-IR-165; * includes the GB6345 correction, i.e. maps 0x2367 to U+FF47 or U+0067; * and _not_ to U+0261 (small script g).; * To overcome the confusion, we just map both 0x2367 and 0x2840 to; * U+FF47.; * Ad 2. Row 0x28: Ad",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/isoir165.h:1695,integrat,integrated,1695,graf2d/win32gdk/gdk/src/iconv/isoir165.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/isoir165.h,1,['integrat'],['integrated']
Deployability,"acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a function failed; // or succeeded. In those cases we use the state MaybeAllocated.; // Thus, the diagram above captures the intent, not implementation details.; //; // Due to the fact that the number of handle related syscalls in Fuchsia; // is large, we adopt the annotation attributes to descript syscalls'; // operations(acquire/release/use) on handles instead of hardcoding; // everything in the checker.; //; // We use following annotation attributes for handle related syscalls or; // functions:; // 1. __attribute__((acquire_handle(""Fuchsia""))) |handle will be acquired; // 2. __attribute__((release_handle(""Fuchsia""))) |handle will be released; // 3. __attribute",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:2202,release,release,2202,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,1,['release'],['release']
Deployability,"ain; /// constant and not be used for event generation.; /// \param[in] arg1,arg2,arg3,arg4,arg5,arg6 Optional RooCmdArg() to change behaviour of generate().; /// \return RooDataSet *, owned by caller.; ///; /// Any variables of this PDF that are not in whatVars will use their; /// current values and be treated as fixed parameters. Returns zero; /// in case of an error.; ///; /// <table>; /// <tr><th> Type of CmdArg <th> Effect on generate; /// <tr><td> `Name(const char* name)` <td> Name of the output dataset; /// <tr><td> `Verbose(bool flag)` <td> Print informational messages during event generation; /// <tr><td> `NumEvents(int nevt)` <td> Generate specified number of events; /// <tr><td> `Extended()` <td> If no number of events to be generated is given,; /// use expected number of events from extended likelihood term.; /// This evidently only works for extended PDFs.; /// <tr><td> `GenBinned(const char* tag)` <td> Use binned generation for all component pdfs that have 'setAttribute(tag)' set; /// <tr><td> `AutoBinned(bool flag)` <td> Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of; /// RooHistPdfs etc); /// \note Datasets that are generated in binned mode are returned as weighted unbinned datasets. This means that; /// for each bin, there will be one event in the dataset with a weight corresponding to the (possibly randomised) bin content.; ///; ///; /// <tr><td> `AllBinned()` <td> As above, but for all components.; /// \note The notion of components is only meaningful for simultaneous PDFs; /// as binned generation is always executed at the top-level node for a regular; /// PDF, so for those it only mattes that the top-level node is tagged.; ///; /// <tr><td> ProtoData(const RooDataSet& data, bool randOrder); /// <td> Use specified dataset as prototype dataset. If randOrder in ProtoData() is set to true,; /// the order of the events in the dataset will be read in a random order if the requested; /// number of",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:1441,deploy,deploy,1441,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['deploy'],['deploy']
Deployability,"ally, if you control the compression process, you can also ignore all buffer size rules,; as long as the encoder and decoder progress in ""lock-step"",; aka use exactly the same buffer sizes, break contiguity at the same place, etc. Once buffers are setup, start decompression, with ZSTD_decompressBegin().; If decompression requires a dictionary, use ZSTD_decompressBegin_usingDict() or ZSTD_decompressBegin_usingDDict(). Then use ZSTD_nextSrcSizeToDecompress() and ZSTD_decompressContinue() alternatively.; ZSTD_nextSrcSizeToDecompress() tells how many bytes to provide as 'srcSize' to ZSTD_decompressContinue().; ZSTD_decompressContinue() requires this _exact_ amount of bytes, or it will fail. @result of ZSTD_decompressContinue() is the number of bytes regenerated within 'dst' (necessarily <= dstCapacity).; It can be zero : it just means ZSTD_decompressContinue() has decoded some metadata item.; It can also be an error code, which can be tested with ZSTD_isError(). A frame is fully decoded when ZSTD_nextSrcSizeToDecompress() returns zero.; Context can then be reset to start a new decompression. Note : it's possible to know if next input to present is a header or a block, using ZSTD_nextInputType().; This information is not required to properly decode a frame. == Special case : skippable frames ==. Skippable frames allow integration of user-defined data into a flow of concatenated frames.; Skippable frames will be ignored (skipped) by decompressor.; The format of skippable frames is as follows :; a) Skippable frame ID - 4 Bytes, Little endian format, any value from 0x184D2A50 to 0x184D2A5F; b) Frame Size - 4 Bytes, Little endian format, unsigned 32-bits; c) Frame Content - any content (User Data) of length equal to Frame Size; For skippable frames ZSTD_getFrameHeader() returns zfhPtr->frameType==ZSTD_skippableFrame.; For skippable frames ZSTD_decompressContinue() always returns 0 : it only skips the content.; */; /*===== Buffer-less streaming decompression functions =====*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:4081,integrat,integration,4081,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['integrat'],['integration']
Deployability,"als with the current style settings. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New... or the toolbar.; A clone of the selected style will be used as a base of the new; style. All its values can be modified via the style editor later.; The dialog that appears will ask for the name and description of the; new style. Import a style (from a macro):; A style macro can be imported at any time. The new imported style in; the ROOT session will become the selected one. Import a style (from a canvas):; You can do that selecting the Style menu/Import from.../Canvas or; the corresponding Tool bar button. A new style will be created in the; ROOT session and will become the selected one. This style is a clone; of the gStyle with modified values as they are set in the currently; selected canvas. You can import a style from any canvas and apply it; later on some objects. Exp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx:1900,update,updates,1900,gui/ged/src/TStyleManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx,1,['update'],['updates']
Deployability,"ame of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a `TPaveStats` object is created and added; to the list of functions of the histogram. If a `TPaveStats` object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters. Once a histogram is painted, the statistics box can be accessed using; `h->FindObject(""stats"")`. In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after `h->Draw()` the histogram is automatically painted. But; in a script file the painting should be forced using `gPad->Update()`; in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without `gPad->Update()` the line `h->FindObject(""stats"")` returns a null pointer. When a histogram is drawn with the option `SAME`, the statistics box; is not drawn. To force the statistics box drawing with the option; `SAME`, the option `SAMES` must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (`h` being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; `TPaveStats` one should do:. st->SetOptStat(mode);. Where `mode` has the same meaning than when calling `gStyle->SetOptStat(mode)`; (see above). One can delete the statistics box for a histogram `TH1* h` with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Labels used in the statistics box (""Mean"", ""Std Dev"", ...) can be changed from; `$ROOTSYS/etc/system.rootrc` or `.rootrc` (lo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:23983,Update,Update,23983,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['Update'],['Update']
Deployability,"ameters can be constrained through. fit->Constrain(parameter #, lower bound, upper bound);. Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function. fit->Unconstrain(parameter #). is also provided to simplify this. ## Setting parameter values; The function. ROOT::Fit::Fitter* fitter = fit->GetFitter();. is provided for direct access to the ROOT::Fit::Fitter object. This allows to; set and fix parameter values, limits and set step sizes directly via. fitter->Config().ParSettings(parameter #).Set(const std::string &name, double value, double step, double lower, double upper);. ## Restricting the fit range; The fit range can be restricted through. fit->SetRangeX(first bin #, last bin #);; and freed using. fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using. fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also. fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through. fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding. fit->IncludeBin(bin #);. ## Weights histograms; Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through. fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. ## Obtaining fit results; The fit is carried out through. Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through. fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by. TH1* result = fit->GetPlot();; ##",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:3802,Release,ReleaseRangeZ,3802,hist/hist/src/TFractionFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx,1,['Release'],['ReleaseRangeZ']
Deployability,"an see an example <a href=""http://root.cern.ch/root/html/HIST_Index.html"">here</a>;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.</p>. <h3><a name=""aux"">VI. Auxiliary files: style sheet, JavaScript, help page</a></h3>. <p>The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running <a href=""#THtml:MakeAll"">MakeAll()</a>;; they can be generated on; demand by calling <a href=""#THtml:CreateAuxiliaryFiles"">CreateAuxiliaryFiles()</a>.</p>. <h3><a name=""charts"">VII. Class Charts</a></h3>; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged on-top of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies. These graphs are generated using the <a href=""http://www.graphviz.org/"">Graphviz</a>; package. You can install it from <a href=""http://www.graphviz.org"">http://www.graphviz.org</a>.; You can either put it into your $PATH, or tell THtml where to find it by calling; <a href=""#THtml:SetDotDir"">SetDotDir()</a>. <h3><a name=""confvar"">VIII. Configuration variables</a></h3>. <p>Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; <a href=""http://root.cern.ch/root/html/TEnv.html"">TEnv</a>.</p>. <pre>; Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx:20690,install,install,20690,html/src/THtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx,1,['install'],['install']
Deployability,"analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi update chain.; //; // 3) Outline common code with createAddRecFromPHI to avoid duplication.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2367,update,update,2367,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,3,['update'],['update']
Deployability,"aphical representations for a class, which; are displayed as a tabbed set of imaged on-top of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies. These graphs are generated using the <a href=""http://www.graphviz.org/"">Graphviz</a>; package. You can install it from <a href=""http://www.graphviz.org"">http://www.graphviz.org</a>.; You can either put it into your $PATH, or tell THtml where to find it by calling; <a href=""#THtml:SetDotDir"">SetDotDir()</a>. <h3><a name=""confvar"">VIII. Configuration variables</a></h3>. <p>Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; <a href=""http://root.cern.ch/root/html/TEnv.html"">TEnv</a>.</p>. <pre>; Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; Root.Html.Root (default: ) - URL of Root's class documentation; Root.Html.SearchEngine (default: ) - link to the search engine; Root.Html.Search (default: ) - link to search by replacing ""%s"" with user input; Root.Html.ViewCVS (default: ) - URL of ViewCVS base; Root.Html.XWho (default: http://consult.cern.ch/xwho/people?) - URL of CERN's xWho; Root.Html.Charset (default: ISO-8859-1) - HTML character set; </pre>. <h3><a name=""how"">IX. Behind the scene</a></h3>. <p>Internally, THtml is just an API class that sets up the list of known; classes, and forwards API invocations to the ""work horses"".; <a href=""http:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx:21362,update,update,21362,html/src/THtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx,1,['update'],['update']
Deployability,"ar : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new double[np];; /// double *w=new double[np];; /// g->CalcGaussLegendreSamplingPoints(np,x,w,1e-15);; /// double r3 = g->IntegralFast(np,x,w,0,5);; /// double r4 = g->IntegralFast(np,x,w,0,1000);; /// double r5 = g->IntegralFast(np,x,w,0,10000);; /// double r6 = g->IntegralFast(np,x,w,0,100000);; /// printf(""g->Integral(0,5) = %g\n"",r1);; /// printf(""g->Integral(0,1000) = %g\n"",r2);; /// printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; /// printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; /// printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; /// printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; /// delete [] x;; /// delete [] w;; /// }; /// ~~~; ///; /// This example produces the following results:; ///; /// ~~~ {.cpp}; /// g->Integral(0,5) = 1.25331; /// g->Integral(0,1000) = 1.25319; /// g->IntegralFast(n,x,w,0,5) = 1.25331; /// g->IntegralFast(n,x,w,0,1000) = 1.25331; /// g->IntegralFast(n,x,w,0,10000) = 1.25331; /// g->IntegralFast(n,x,w,0,100000)= 1.253; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1745,integrat,integration,1745,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,2,['integrat'],"['integrate', 'integration']"
Deployability,"ard.; * The following table summarizes matters since version 0.89c, which was; * the first widely used release:; *; * source png.h png.h shared-lib; * version string int version; * ------- ------ ----- ----------; * 0.89c ""1.0 beta 3"" 0.89 89 1.0.89; * 0.90 ""1.0 beta 4"" 0.90 90 0.90 [should have been 2.0.90]; * 0.95 ""1.0 beta 5"" 0.95 95 0.95 [should have been 2.0.95]; * 0.96 ""1.0 beta 6"" 0.96 96 0.96 [should have been 2.0.96]; * 0.97b ""1.00.97 beta 7"" 1.00.97 97 1.0.1 [should have been 2.0.97]; * 0.97c 0.97 97 2.0.97; * 0.98 0.98 98 2.0.98; * 0.99 0.99 98 2.0.99; * 0.99a-m 0.99 99 2.0.99; * 1.00 1.00 100 2.1.0 [100 should be 10000]; * 1.0.0 (from here on, the 100 2.1.0 [100 should be 10000]; * 1.0.1 png.h string is 10001 2.1.0; * 1.0.1a-e identical to the 10002 from here on, the shared library; * 1.0.2 source version) 10002 is 2.V where V is the source code; * 1.0.2a-b 10003 version, except as noted.; * 1.0.3 10003; * 1.0.3a-d 10004; * 1.0.4 10004; * 1.0.4a-f 10005; * 1.0.5 (+ 2 patches) 10005; * 1.0.5a-d 10006; * 1.0.5e-r 10100 (not source compatible); * 1.0.5s-v 10006 (not binary compatible); * 1.0.6 (+ 3 patches) 10006 (still binary incompatible); * 1.0.6d-f 10007 (still binary incompatible); * 1.0.6g 10007; * 1.0.6h 10007 10.6h (testing xy.z so-numbering); * 1.0.6i 10007 10.6i; * 1.0.6j 10007 2.1.0.6j (incompatible with 1.0.0); * 1.0.7beta11-14 DLLNUM 10007 2.1.0.7beta11-14 (binary compatible); * 1.0.7beta15-18 1 10007 2.1.0.7beta15-18 (binary compatible); * 1.0.7rc1-2 1 10007 2.1.0.7rc1-2 (binary compatible); * 1.0.7 1 10007 (still compatible); * ...; * 1.0.69 10 10069 10.so.0.69[.0]; * ...; * 1.2.59 13 10259 12.so.0.59[.0]; * ...; * 1.4.20 14 10420 14.so.0.20[.0]; * ...; * 1.5.30 15 10530 15.so.15.30[.0]; * ...; * 1.6.40 16 10640 16.so.16.40[.0]; *; * Henceforth the source version will match the shared-library major and; * minor numbers; the shared-library major version number will be used for; * changes in backward compatibility, as it is intended.; * The PNG_",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:8546,patch,patches,8546,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['patch'],['patches']
Deployability,"ase larger margins are not necessary; and Type=1 or 2 can be used.; - 3 : Encapsulated PostScript. This Type permits the generation of files; which can be included in other documents, for example in LaTeX files. ## Making several pictures in the same Postscript file: case 1. The following macro is an example illustrating how to open a Postscript; file and draw several pictures. The generation of a new Postscript page; is automatic when `TCanvas::Clear` is called by `object->Draw()`. ~~~ {.cpp}; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. // select postscript output type; // type = 111 portrait ps; // type = 112 landscape ps; // type = 113 eps; Int_t type = 111;. // create a postscript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page. // draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a macro; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }; ~~~. ## Making several pictures in the same Postscript file: case 2. This example shows 2 pages. The canvas is divided.; `TPostScript::NewPage` must be called before starting a new; picture.`object->Draw` does not clear the canvas in this case; because we clear only the pads and not the main canvas.; Note that `c1->Update` must be called at the end of the first picture. ~~~ {.cpp}; {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; TPostScript *ps = new TPostScript(""file.ps"",112);; c1->Divide(2,1);; // picture 1; ps->NewPage();; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();; c1->Update();. // picture 2; ps->NewPage();; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Update();; ps->Close();. // invoke Postscript viewer; gSystem->Exec(""gs file.ps"");; }; ~~~. ## Making several pictures in the same Postscript file: case 3; This is the recommended way. If the Postscript file name finishes with; ""("", the file remains opene",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TPostScript.cxx:4493,Update,Update,4493,graf2d/postscript/src/TPostScript.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TPostScript.cxx,1,['Update'],['Update']
Deployability,"at callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that participate in the link.; // The pass computes a resolution for each virtual call and stores it in the; // type identifier summary.; // - Import phase: this is run during the thin backends over the individual; // modules. The pass applies the resolutions previously computed during the; // import phase to each eligible virtual call.; //; // During ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over the index which; // contains a summary of all vtables with !type metadata that participate in; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1633,pipeline,pipelines,1633,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['pipeline'],['pipelines']
Deployability,"ations-number of iterations in deconvolution operation; /// - markov-logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow-averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method); ///; /// ### Peaks searching; ///; /// Goal: to identify automatically the peaks in spectrum with the presence of; /// the continuous background, one- and two-fold coincidences (ridges) and statistical; /// fluctuations - noise.; ///; /// The common problems connected; /// with correct peak identification in three-dimensional coincidence spectra are; ///; /// - non-sensitivity to noise, i.e.,; /// only statistically relevant peaks should be identified; /// - non-sensitivity of the; /// algorithm to continuous background; /// - non-sensitivity to one-fold coincidences; /// (coincidences peak - peak - background in all dimensions) and their; /// crossings; /// - non-sensitivity to two-fold; /// coincidences (coincidences peak - background - background in all; /// dimensions) and their crossings; /// - ability to identify peaks close; /// to the edges of the spectrum region; /// - resolution, decomposition of; /// doublets and multiplets. The algorithm should be able to recognise close; /// positioned peaks.; ///; /// #### References:; ///; /// [1] M.A. Mariscotti: A method for; /// identification of peaks in the presence of background and its application to; /// spectrum analysis. NIM 50 (1967), 309-320.; ///; /// [2] M.Morhac, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.:Identification; /// of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); /// 108-125.; ///; /// [3] Z.K. Silagadze, A new algorithm for automatic photo-peak searches. NIM A 376 (1996), 451.; ///; /// ### Example of peak searching method; ///; /// SearchHighRes function provides users with the possibility; /// to vary the input parameters and with the a",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum3.cxx:1888,continuous,continuous,1888,hist/spectrum/src/TSpectrum3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum3.cxx,1,['continuous'],['continuous']
Deployability,"awn, the `Draw()` method can be invoked with an option. For instance; to draw a 2D histogram as a lego plot it is enough to do:. h->Draw(""lego"");. `THistPainter` offers many options to paint 1D, 2D and 3D histograms. When the `Draw()` method of a histogram is called for the first time; (`TH1::Draw`), it creates a `THistPainter` object and saves a; pointer to this ""painter"" as a data member of the histogram. The; `THistPainter` class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram having its own; painter (rather than a central singleton painter painting all histograms), allows; two histograms to be drawn in two threads without overwriting the painter's; values. When a displayed histogram is filled again, there is no need to call the; `Draw()` method again; the image will be refreshed the next time the; pad will be updated. A pad is updated after one of these three actions:. 1. a carriage control on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. By default a call to `TH1::Draw()` clears the pad of all objects; before drawing the new image of the histogram. One can use the `SAME`; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads. When a displayed histogram is deleted, its image is automatically removed; from the pad. To create a copy of the histogram when drawing it, one can use; `TH1::DrawClone()`. This will clone the histogram and allow to change; and delete the original one without affecting the clone. \anchor HP01; ### Histograms' plotting options. Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with `TH1::SetOption` and retrieve; usi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:4488,update,updated,4488,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['update'],['updated']
Deployability,"b) this copyright and permission notice appear in associated; * documentation, and; * (c) there is clear notice in each modified Data File or in the Software; * as well as in the documentation associated with the Data File(s) or; * Software that the data or software has been modified.; *; * THE DATA FILES AND SOFTWARE ARE PROVIDED ""AS IS"", WITHOUT WARRANTY OF; * ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE; * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT OF THIRD PARTY RIGHTS.; * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS; * NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL; * DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,; * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER; * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR; * PERFORMANCE OF THE DATA FILES OR SOFTWARE.; *; * Except as contained in this notice, the name of a copyright holder; * shall not be used in advertising or otherwise to promote the sale,; * use or other dealings in these Data Files or Software without prior; * written authorization of the copyright holder.; */; /* ---------------------------------------------------------------------. Conversions between UTF32, UTF-16, and UTF-8. Source code file.; Author: Mark E. Davis, 1994.; Rev History: Rick McGowan, fixes & updates May 2001.; Sept 2001: fixed const & error conditions per; mods suggested by S. Parent & A. Lillich.; June 2002: Tim Dodd added detection and handling of incomplete; source sequences, enhanced error detection, added casts; to eliminate compiler warnings.; July 2003: slight mods to back out aggressive FFFE detection.; Jan 2004: updated switches in from-UTF8 conversions.; Oct 2004: updated to use UNI_MAX_LEGAL_UTF32 in UTF-32 conversions. See the header file ""ConvertUTF.h"" for complete documentation. ------------------------------------------------------------------------ */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp:2581,update,updates,2581,interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp,3,['update'],"['updated', 'updates']"
Deployability,"bda >= 0) {; auto& logstream = coutF(Integration) << ""When the PDF "" << GetName(); << "" was constructed, beta,zeta were 0, lambda<0 and all three were constant.\n""; << ""This allowed for analytic integration, but now, numeric integration would be required.\n""; << ""These parameters must either be kept constant, or be floating from the beginning. ""; << "" Terminating fit ...""; << std::endl;; RooArgSet vars;; vars.add(_beta.arg());; vars.add(_zeta.arg());; vars.add(_lambda.arg());; vars.printStream(logstream, vars.defaultPrintContents(nullptr), RooPrintable::kVerbose);; throw std::runtime_error(""RooHypatia2 cannot be integrated analytically since parameters changed."");; }. // The formulae to follow still use beta and zeta to facilitate comparisons with the; // evaluate function. Since beta and zeta are zero, all relevant terms will be disabled; // by defining these two constexpr:; constexpr double beta = 0.;; constexpr double cons1 = 1.;. if (code != 1) {; throw std::logic_error(""Trying to compute analytic integral with unknown configuration."");; }. const double asigma = _a * _sigma;; const double a2sigma = _a2 * _sigma;; const double d0 = _x.min(rangeName) - _mu;; const double d1 = _x.max(rangeName) - _mu;. double delta;; if (_lambda <= -1.0) {; delta = _sigma * sqrt(-2. + -2.*_lambda);; }; else {; delta = _sigma;; }; const double deltaSq = delta*delta;. if ((d0 > -asigma) && (d1 < a2sigma)) {; return stIntegral(d1, delta, _lambda) - stIntegral(d0, delta, _lambda);; }. if (d0 > a2sigma) {; const double phi = 1. + a2sigma*a2sigma/deltaSq;; const double k1 = cons1*std::pow(phi,_lambda-0.5);; const double k2 = beta*k1+ cons1*(_lambda-0.5)*std::pow(phi,_lambda-1.5)*2.*a2sigma/deltaSq;; const double B = -a2sigma - _n2*k1/k2;; const double A = k1*std::pow(B+a2sigma,_n2);; return A*(std::pow(B+d1,1-_n2)/(1-_n2) -std::pow(B+d0,1-_n2)/(1-_n2) ) ;. }. if (d1 < -asigma) {; const double phi = 1. + asigma*asigma/deltaSq;; const double k1 = cons1*std::pow(phi,_lambda-0.5);; const dou",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooHypatia2.cxx:1479,configurat,configuration,1479,roofit/roofitmore/src/RooHypatia2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooHypatia2.cxx,1,['configurat'],['configuration']
Deployability,"bottom;. // ...and ending also at the bottom right corner, but of the end token.; posEnd.x = endRect.right - 1;; posEnd.y = endRect.bottom + 1;. // Utility object with x and y offsets for handles.; var curvature = {; x: Math.min((posStart.x - posEnd.x) / 3, 15),; y: 5; }. // Curving to the left...; startHandle.x = posStart.x - curvature.x;; // ... and downwards from the start node.; startHandle.y = posStart.y + curvature.y;. // And to the right...; endHandle.x = posEnd.x + curvature.x;; // ... and downwards from the end node.; endHandle.y = posEnd.y + curvature.y;; }. // Put it all together into a path.; // More information on the format:; // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths; var pathStr = ""M"" + posStart.x + "","" + posStart.y + "" "" +; ""C"" + startHandle.x + "","" + startHandle.y + "" "" +; endHandle.x + "","" + endHandle.y + "" "" +; posEnd.x + "","" + posEnd.y;. arrow.setAttribute(""d"", pathStr);; };. var drawArrows = function() {; const numOfArrows = document.querySelectorAll(""path[id^=arrow]"").length;; for (var i = 0; i < numOfArrows; ++i) {; drawArrow(i);; }; }. var toggleArrows = function(event) {; const arrows = document.querySelector(""#arrows"");; if (event.target.checked) {; arrows.setAttribute(""visibility"", ""visible"");; } else {; arrows.setAttribute(""visibility"", ""hidden"");; }; }. window.addEventListener(""resize"", drawArrows);; document.addEventListener(""DOMContentLoaded"", function() {; // Whenever we show invocation, locations change, i.e. we; // need to redraw arrows.; document; .querySelector('input[id=""showinvocation""]'); .addEventListener(""click"", drawArrows);; // Hiding irrelevant lines also should cause arrow rerender.; document; .querySelector('input[name=""showCounterexample""]'); .addEventListener(""change"", drawArrows);; document; .querySelector('input[name=""showArrows""]'); .addEventListener(""change"", toggleArrows);; drawArrows();; // Default highlighting for the last event.; highlightArrowsForSelectedEvent();; });; </script>; )<<<""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:6435,toggle,toggleArrows,6435,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,2,['toggle'],['toggleArrows']
Deployability,"br />; * @param {string} [options.unit=mm] Measurement unit (base unit) to be used when coordinates are specified.<br />; * Possible values are ""pt"" (points), ""mm"", ""cm"", ""in"", ""px"", ""pc"", ""em"" or ""ex"". Note that in order to get the correct scaling for ""px""; * units, you need to enable the hotfix ""px_scaling"" by setting options.hotfixes = [""px_scaling""].; * @param {string/Array} [options.format=a4] The format of the first page. Can be:<ul><li>a0 - a10</li><li>b0 - b10</li><li>c0 - c10</li><li>dl</li><li>letter</li><li>government-letter</li><li>legal</li><li>junior-legal</li><li>ledger</li><li>tabloid</li><li>credit-card</li></ul><br />; * Default is ""a4"". If you want to use your own format just pass instead of one of the above predefined formats the size as an number-array, e.g. [595.28, 841.89]; * @param {boolean} [options.putOnlyUsedFonts=false] Only put fonts into the PDF, which were used.; * @param {boolean} [options.compress=false] Compress the generated PDF.; * @param {number} [options.precision=16] Precision of the element-positions.; * @param {number} [options.userUnit=1.0] Not to be confused with the base unit. Please inform yourself before you use it.; * @param {string[]} [options.hotfixes] An array of strings to enable hotfixes such as correct pixel scaling.; * @param {Object} [options.encryption]; * @param {string} [options.encryption.userPassword] Password for the user bound by the given permissions list.; * @param {string} [options.encryption.ownerPassword] Both userPassword and ownerPassword should be set for proper authentication.; * @param {string[]} [options.encryption.userPermissions] Array of permissions ""print"", ""modify"", ""copy"", ""annot-forms"", accessible by the user.; * @param {number|""smart""} [options.floatPrecision=16]; * @returns {jsPDF} jsPDF-instance; * @description; * ```; * {; * orientation: 'p',; * unit: 'mm',; * format: 'a4',; * putOnlyUsedFonts:true,; * floatPrecision: 16 // or ""smart"", default is 16; * }; * ```; *; * @constructor; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:1528,hotfix,hotfixes,1528,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['hotfix'],['hotfixes']
Deployability,"bug-info is marked out by ""-"" characters and a few; other special characters (+:=) where I want to highlight what's going on. Dest; |; this-block: A----A----A ====A----A----A----A---A---A; Src-block ++++B---B---B---B:::C; | |; First Last. The splice method is going to take all the instructions from First up to; (but not including) Last and insert them in _front_ of Dest, forming one; long list. All the DPValues attached to instructions _between_ First and; Last need no maintenence. However, we have to do special things with the; DPValues marked with the +:= characters. We only have three positions:; should the ""+"" DPValues be transferred, and if so to where? Do we move the; "":"" DPValues? Would they go in front of the ""="" DPValues, or should the ""=""; DPValues go before ""+"" DPValues?. We're told which way it should be by the bits carried in the iterators. The; ""Head"" bit indicates whether the specified position is supposed to be at the; front of the attached DPValues (true) or not (false). The Tail bit is true; on the other end of a range: is the range intended to include DPValues up to; the end (false) or not (true). FIXME: the tail bit doesn't need to be distinct from the head bit, we could; combine them. Here are some examples of different configurations:. Dest.Head = true, First.Head = true, Last.Tail = false. this-block: A----A----A++++B---B---B---B:::====A----A----A----A---A---A; | |; First Dest. Wheras if we didn't want to read from the Src list,. Dest.Head = true, First.Head = false, Last.Tail = false. this-block: A----A----AB---B---B---B:::====A----A----A----A---A---A; | |; First Dest. Or if we didn't want to insert at the head of Dest:. Dest.Head = false, First.Head = false, Last.Tail = false. this-block: A----A----A====B---B---B---B:::A----A----A----A---A---A; | |; First Dest. Tests for these various configurations can be found in the unit test file; BasicBlockDbgInfoTest.cpp. */; // Detach the marker at Dest -- this lets us move the ""===="" DPValues around.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:1443,configurat,configurations,1443,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,2,['configurat'],['configurations']
Deployability,"by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try to compete on that. A clear and flexible Object; Oriented implementation has been chosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. ### The MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. \image html mlp.png. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with <I>f</I> being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. 1. A linear combination of sigmoids can approximate any; continuous function.; 2. Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. ### Learning methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, divided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especially the; derivative of compound functions, one can write:. - for a neuron: product of the local derivative with the; weighted sum on the outputs of the derivatives.; - for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented. #### St",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx:3567,continuous,continuous,3567,math/mlp/src/TMultiLayerPerceptron.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx,1,['continuous'],['continuous']
Deployability,"by omitting observables listed; /// in set from the projection, i.e. by not integrating over these.; /// Slicing is usually only sensible in discrete observables, by e.g. creating a slice; /// of the PDF at the current value of the category observable.; /// <tr><td> `Slice(RooCategory& cat, const char* label)` <td> Override default projection behaviour by omitting the specified category; /// observable from the projection, i.e., by not integrating over all states of this category.; /// The slice is positioned at the given label value. Multiple Slice() commands can be given to specify slices; /// in multiple observables, e.g.; /// ```{.cpp}; /// pdf.plotOn(frame, Slice(tagCategory, ""2tag""), Slice(jetCategory, ""3jet""));; /// ```; /// <tr><td> `Project(const RooArgSet& set)` <td> Override default projection behaviour by projecting; /// over observables given in set, completely ignoring the default projection behavior. Advanced use only.; /// <tr><td> `ProjWData(const RooAbsData& d)` <td> Override default projection _technique_ (integration). For observables; /// present in given dataset projection of PDF is achieved by constructing an average over all observable; /// values in given set. Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; /// <tr><td> `ProjWData(const RooArgSet& s, const RooAbsData& d)` <td> As above but only consider subset 's' of; /// observables in dataset 'd' for projection through data averaging; /// <tr><td> `ProjectionRange(const char* rn)` <td> When projecting the PDF onto the plot axis, it is usually integrated; /// over the full range of the invisible variables. The ProjectionRange overrides this.; /// This is useful if the PDF was fitted in a limited range in y, but it is now projected onto x. If; /// `ProjectionRange(""<name of fit range>"")` is passed, the projection is normalised correctly.; ///; /// <tr><th> Type of argument <th> Plotting control; /// <tr><td> `LineStyle(Int_t style)` <td> Select lin",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:4662,integrat,integration,4662,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['integrat'],['integration']
Deployability,"can be changed using RooRealVar::setBins(N).; /// For good results, N should be large (>=1000). Additional interpolation; /// between the bins may improve the result if coarse binnings are chosen. These can be; /// activated in the constructor or by calling `setInterpolationOrder()`.; /// For N >> 1000, interpolation will not substantially improve the accuracy.; ///; /// Additionial information on caching can be displayed by monitoring; /// the message stream with topic ""Caching"" at the INFO level, *i.e.*; /// by calling `RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching""))`; /// to see these message on stdout.; ///; /// Multi-dimensional convolutions are not supported at the moment.; ///; /// ---; ///; /// Installing an external version of FFTW on Linux and compiling ROOT to use it; /// -------; ///; /// You have two options:; /// * **Recommended**: ROOT can automatically install FFTW for itself, see `builtin_fftw3` at https://root.cern/building-root; /// * Install FFTW and let ROOT discover it. `fftw3` is on by default (see https://root.cern/building-root); ///; /// 1) Go to www.fftw.org and download the latest stable version (a .tar.gz file); ///; /// If you have root access to your machine and want to make a system installation of FFTW; ///; /// 2) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; /// and type './configure' followed by 'make install'.; /// This will install fftw in /usr/local/bin,lib etc...; ///; /// 3) Start from a source installation of ROOT. ROOT should discover it. See https://root.cern/building-root; ///; ///; /// If you do not have root access and want to make a private installation of FFTW; ///; /// 2) Make a private install area for FFTW, e.g. /home/myself/fftw; ///; /// 3) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; /// and type './configure --prefix=/home/myself/fftw' followed by 'make install'.; /// Substitute /home/myself/fftw with a directory of your choice. This; /// procedure wi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:4497,Install,Install,4497,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['Install'],['Install']
Deployability,"ce and binary forms,; * with or without modification, are permitted according to the terms; * listed in LICENSE (http://roofit.sourceforge.net/license.txt); */; /** \class RooStats::ModelConfig; \ingroup Roostats. ModelConfig is a simple class that holds configuration information specifying how a model; should be used in the context of various RooStats tools. A single model can be used; in different ways, and this class should carry all that is needed to specify how it should be used.; ModelConfig requires a workspace to be set. A ModelConfig holds sets of parameters of the likelihood function that have different interpretations:; - **Parameter of interest** Parameters that are measured (*i.e.* fitted).; - **Nuisance parameters** Parameters that are fitted, but their post-fit value is not interesting. Often,; they might be constrained because external knowledge about them exists, *e.g.* from external measurements.; - **Constraint parameters** No direct use in RooFit/RooStats. Can be used by the user for bookkeeping.; - **Observables** Parameters that have been measured externally, *i.e.* they exist in a dataset. These are not fitted,; but read during fitting from the entries of a dataset.; - **Conditional observables** Observables that are not integrated when the normalisation of the PDF is calculated.; See *e.g.* `rf306_condpereventerrors` in the RooFit tutorials.; - **Global observables** Observables that to the fit look like ""constant"" values, *i.e.* they are not being; fitted and they are not loaded from a dataset, but some knowledge exists that allows to set them to a; specific value. Examples:; -- A signal efficiency measured in a Monte Carlo study.; -- When constraining a parameter \f$ b \f$, the target value (\f$ b_0 \f$) that this parameter is constrained to:; \f[; \mathrm{Constraint}_b = \mathrm{Gauss}(b_0 \, | \, b, 0.2); \f]; - **External constraints** Include given external constraints to likelihood by multiplying them with the original; likelihood.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/ModelConfig.cxx:1455,integrat,integrated,1455,roofit/roofitcore/src/ModelConfig.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/ModelConfig.cxx,1,['integrat'],['integrated']
Deployability,"ce. ### A Minimal PDF Implementation. A minimal implementation of a PDF class derived from RooAbsPdf; should override the `evaluate()` function. This function should; return the PDF's value (which does not need to be normalised). #### Normalization/Integration. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex composite PDF; if any of its variables are functions instead of variables. In; such cases, the normalization of the composite PDF may not simply be; integral over the dependents of the top-level PDF: these are; functions with potentially non-trivial Jacobian terms themselves.; \note Therefore, no explicit attempt should be made to normalize the; function output in evaluate(). In particular, normalisation constants; can be omitted to speed up the function evaluations, and included later; in the integration of the PDF (see below), which is rarely called in; comparison to the `evaluate()` function. In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters, and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead, the choice of normalization is always specified each time a; normalized value is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; the help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform an entirely numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e., no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; common,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:2147,integrat,integration,2147,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['integrat'],['integration']
Deployability,"ce; # interval for any particular dataset by finding the intersection; # of the observed test statistic and the confidence belt. First; # this is done on the observed data to get an observed 1-sided upper limt.; #; # Finally, there expected limit and bands (from background-only) are; # formed by generating background-only data and finding the upper limit.; # The background-only is defined as such that the nuisance parameters are; # fixed to their best fit value based on the data with the signal rate fixed to 0.; # The bands are done by hand for now, will later be part of the RooStats tools.; #; # On a technical note, this technique IS the generalization of Feldman-Cousins; # with nuisance parameters.; #; # Building the confidence belt can be computationally expensive.; # Once it is built, one could save it to a file and use it in a separate step.; #; # We can use PROOF to speed things along in parallel, however,; # the test statistic has to be installed on the workers; # so either turn off PROOF or include the modified test statistic; # in your $ROOTSYS/roofit/roostats/inc directory,; # add the additional line to the LinkDef.h file,; # and recompile root.; #; # Note, if you have a boundary on the parameter of interest (eg. cross-section); # the threshold on the two-sided test statistic starts off at moderate values and plateaus.; #; # [#0] PROGRESS:Generation -- generated toys: 500 / 999; # NeymanConstruction: Prog: 12/50 total MC = 39 this test stat = 0; # SigXsecOverSM=0.69 alpha_syst1=0.136515 alpha_syst3=0.425415 beta_syst2=1.08496 [-1e+30, 0.011215] in interval = 1; #; # this tells you the values of the parameters being used to generate the pseudo-experiments; # and the threshold in this case is 0.011215. One would expect for 95% that the threshold; # would be ~1.35 once the cross-section is far enough away from 0 that it is essentially; # unaffected by the boundary. As one reaches the last points in the scan, the; # threshold starts to get artificially high. Th",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/TwoSidedFrequentistUpperLimitWithBands.py:2839,install,installed,2839,tutorials/roostats/TwoSidedFrequentistUpperLimitWithBands.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/TwoSidedFrequentistUpperLimitWithBands.py,1,['install'],['installed']
Deployability,"cense-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the RefCountedBase, ThreadSafeRefCountedBase, and; /// IntrusiveRefCntPtr classes.; ///; /// IntrusiveRefCntPtr is a smart pointer to an object which maintains a; /// reference count. (ThreadSafe)RefCountedBase is a mixin class that adds a; /// refcount member variable and methods for updating the refcount. An object; /// that inherits from (ThreadSafe)RefCountedBase deletes itself when its; /// refcount hits zero.; ///; /// For example:; ///; /// ```; /// class MyClass : public RefCountedBase<MyClass> {};; ///; /// void foo() {; /// // Constructing an IntrusiveRefCntPtr increases the pointee's refcount; /// // by 1 (from 0 in this case).; /// IntrusiveRefCntPtr<MyClass> Ptr1(new MyClass());; ///; /// // Copying an IntrusiveRefCntPtr increases the pointee's refcount by 1.; /// IntrusiveRefCntPtr<MyClass> Ptr2(Ptr1);; ///; /// // Constructing an IntrusiveRefCntPtr has no effect on the object's; /// // refcount. After a move, the moved-from pointer is null.; /// IntrusiveRefCntPtr<MyClass> Ptr3(std::move(Ptr1));; /// assert(Ptr1 == nullptr);; ///; /// // Clearing an IntrusiveRefCntPtr decreases the pointee's refcount by 1.; /// Ptr2.reset();; ///; /// // The object deletes itself when we return from the function, because; /// // Ptr3's destructor decrements its refcount to 0.; /// }; /// ```; ///; /// You can use IntrusiveRefCntPtr with isa<T>(), dyn_cast<T>(), etc.:; ///; /// ```; /// IntrusiveRefCntPtr<MyClass> Ptr(new MyClass());; /// OtherClass *Other = dyn_cast<OtherClass>(Ptr); // Ptr.get() not required; /// ```; ///; /// IntrusiveRefCntPtr works with any class that; ///; /// - inherits from (ThreadSafe)RefCountedBase,; /// - has Retain() and Release() methods, or; /// - specializes IntrusiveRefCntPtrInfo.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:2089,Release,Release,2089,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,1,['Release'],['Release']
Deployability,"challa makes no; representations about the suitability of this software for any purpose.; It is provided ""as is"" without express or implied warranty. Mark Spychalla disclaims all warranties with regard to this software,; including all implied warranties of merchantability and fitness, in no; event shall Mark Spychalla be liable for any special, indirect or; consequential damages or any damages whatsoever resulting from loss of use,; data or profits, whether in an action of contract, negligence or other; tortious action, arising out of or in connection with the use or performance; of this software.; */; /*. NOTE ON X3D CODING STYLE:. Don't think I usually code in the gerberized fashion that X3D demonstrates.; X3D was written for speed at any cost. My goal was to write the fastest 3D; object viewer that I could, period. Regular programs ought to be written; with different goals in mind such as:. 1) A program has excellent documentation that ANYONE can read.; 2) A program when released has no strange ""features"" or bugs.; 3) A program is robust and handles ALL extreme and unusual cases.; 4) A program is written in phases and modules with hard tests for each one.; 5) A program is written for any user who doesn't need special knowledge; to use the program.; 6) A program has well defined user requirements and functional specifications.; 7) A program is written with regard to future expansion and integreation; with other systems (portability). When programming following these additional principles make programs easier; to maintain. A) Choose variable names that accurately describes what the variable does/is.; B) Write comments to inform someone faced with the task of modifying your code.; C) Avoid excessive comments. Write the code so that it says what it does.; D) Follow a strict one-in, one-out flow of control structues except in the; case of fatal error conditions.; E) Avoid using global variables.; F) Do not cause side effects to variables that were not parameters to a; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c:1553,release,released,1553,graf3d/x3d/src/x3d.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c,1,['release'],['released']
Deployability,"chine cycles. The physical; /// machine will have pipeline stages that delay execution. The scheduler does; /// not model those delays because they are irrelevant as long as they are; /// consistent. Inaccuracies arise when instructions have different execution; /// delays relative to each other, in addition to their intrinsic latency. Those; /// special cases can be handled by TableGen constructs such as, ReadAdvance,; /// which reduces latency when reading data, and ReleaseAtCycles, which consumes; /// a processor resource when writing data for a number of abstract; /// cycles.; ///; /// TODO: One tool currently missing is the ability to add a delay to; /// ReleaseAtCycles. That would be easy to add and would likely cover all cases; /// currently handled by the legacy itinerary tables.; ///; /// A note on out-of-order execution and, more generally, instruction; /// buffers. Part of the CPU pipeline is always in-order. The issue point, which; /// is the point of reference for counting cycles, only makes sense as an; /// in-order part of the pipeline. Other parts of the pipeline are sometimes; /// falling behind and sometimes catching up. It's only interesting to model; /// those other, decoupled parts of the pipeline if they may be predictably; /// resource constrained in a way that the scheduler can exploit.; ///; /// The LLVM machine model distinguishes between in-order constraints and; /// out-of-order constraints so that the target's scheduling strategy can apply; /// appropriate heuristics. For a well-balanced CPU pipeline, out-of-order; /// resources would not typically be treated as a hard scheduling; /// constraint. For example, in the GenericScheduler, a delay caused by limited; /// out-of-order resources is not directly reflected in the number of cycles; /// that the scheduler sees between issuing an instruction and its dependent; /// instructions. In other words, out-of-order resources don't directly increase; /// the latency between pairs of instruction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:2455,pipeline,pipeline,2455,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['pipeline'],['pipeline']
Deployability,"ck. If flush is set to Z_BLOCK, a deflate block is completed and emitted, as; for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to; seven bits of the current block are held to be written as the next byte after; the next deflate block is completed. In this case, the decompressor may not; be provided enough bits at this point in order to complete decompression of; the data provided so far to the compressor. It may need to wait for the next; block to be emitted. This is for advanced applications that need to control; the emission of deflate blocks. If flush is set to Z_FULL_FLUSH, all output is flushed as with; Z_SYNC_FLUSH, and the compression state is reset so that decompression can; restart from this point if previous compressed data has been damaged or if; random access is desired. Using Z_FULL_FLUSH too often can seriously degrade; compression. If deflate returns with avail_out == 0, this function must be called again; with the same value of the flush parameter and more output space (updated; avail_out), until the flush is complete (deflate returns with non-zero; avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that; avail_out is greater than six to avoid repeated flush markers due to; avail_out == 0 on return. If the parameter flush is set to Z_FINISH, pending input is processed,; pending output is flushed and deflate returns with Z_STREAM_END if there was; enough output space; if deflate returns with Z_OK, this function must be; called again with Z_FINISH and more output space (updated avail_out) but no; more input data, until it returns with Z_STREAM_END or an error. After; deflate has returned Z_STREAM_END, the only possible operations on the stream; are deflateReset or deflateEnd. Z_FINISH can be used immediately after deflateInit if all the compression; is to be done in a single step. In this case, avail_out must be at least the; value returned by deflateBound (see below). Then deflate is guaranteed to; return Z_ST",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:3824,update,updated,3824,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['update'],['updated']
Deployability,"claim ""common-law trademark protection"" in any; * jurisdiction where common-law trademark is recognized.; */; /*; * A ""png_get_copyright"" function is available, for convenient use in ""about""; * boxes and the like:; *; * printf(""%s"", png_get_copyright(NULL));; *; * Also, the PNG logo (in PNG format, of course) is supplied in the; * files ""pngbar.png"" and ""pngbar.jpg (88x31) and ""pngnow.png"" (98x31).; */; /*; * The contributing authors would like to thank all those who helped; * with testing, bug fixes, and patience. This wouldn't have been; * possible without all of you.; *; * Thanks to Frank J. T. Wojcik for helping with the documentation.; */; /* Note about libpng version numbers:; *; * Due to various miscommunications, unforeseen code incompatibilities; * and occasional factors outside the authors' control, version numbering; * on the library has not always been consistent and straightforward.; * The following table summarizes matters since version 0.89c, which was; * the first widely used release:; *; * source png.h png.h shared-lib; * version string int version; * ------- ------ ----- ----------; * 0.89c ""1.0 beta 3"" 0.89 89 1.0.89; * 0.90 ""1.0 beta 4"" 0.90 90 0.90 [should have been 2.0.90]; * 0.95 ""1.0 beta 5"" 0.95 95 0.95 [should have been 2.0.95]; * 0.96 ""1.0 beta 6"" 0.96 96 0.96 [should have been 2.0.96]; * 0.97b ""1.00.97 beta 7"" 1.00.97 97 1.0.1 [should have been 2.0.97]; * 0.97c 0.97 97 2.0.97; * 0.98 0.98 98 2.0.98; * 0.99 0.99 98 2.0.99; * 0.99a-m 0.99 99 2.0.99; * 1.00 1.00 100 2.1.0 [100 should be 10000]; * 1.0.0 (from here on, the 100 2.1.0 [100 should be 10000]; * 1.0.1 png.h string is 10001 2.1.0; * 1.0.1a-e identical to the 10002 from here on, the shared library; * 1.0.2 source version) 10002 is 2.V where V is the source code; * 1.0.2a-b 10003 version, except as noted.; * 1.0.3 10003; * 1.0.3a-d 10004; * 1.0.4 10004; * 1.0.4a-f 10005; * 1.0.5 (+ 2 patches) 10005; * 1.0.5a-d 10006; * 1.0.5e-r 10100 (not source compatible); * 1.0.5s-v 10006 (not bina",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:7655,release,release,7655,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['release'],['release']
Deployability,"class can convolve any PDF; with any other PDF; This class should not be used blindly as numeric convolution is computing; intensive and prone to stability fitting problems. If an analytic convolution; can be calculated, you should use that or implement it if not available.; RooNumConvolution implements reasonable defaults that should convolve most; functions reasonably well, but results strongly depend on the shape of your; input PDFS so always check your result. The default integration engine for the numeric convolution is the; adaptive Gauss-Kronrod method, which empirically seems the most robust; for this task. You can override the convolution integration settings via; the RooNumIntConfig object reference returned by the convIntConfig() member; function; By default the numeric convolution is integrated from -infinity to; +infinity through a <pre>x -> 1/x</pre> coordinate transformation of the; tails. For convolution with a very small bandwidth it may be; advantageous (for both CPU consumption and stability) if the; integration domain is limited to a finite range. The function; setConvolutionWindow(mean,width,scale) allows to set a sliding; window around the x value to be calculated taking a RooAbsReal; expression for an offset and a width to be taken around the x; value. These input expression can be RooFormulaVars or other; function objects although the 3d 'scale' argument 'scale'; multiplies the width RooAbsReal expression given in the 2nd; argument, allowing for an appropriate window definition for most; cases without need for a RooFormulaVar object: e.g. a Gaussian; resolution PDF do setConvolutionWindow(gaussMean,gaussSigma,5); Note that for a 'wide' Gaussian the -inf to +inf integration; may converge more quickly than that over a finite range!; The default numeric precision is 1e-7, i.e. the global default for; numeric integration but you should experiment with this value to; see if it is sufficient for example by studying the number of function; calls tha",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx:1864,integrat,integration,1864,roofit/roofitcore/src/RooNumConvolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx,1,['integrat'],['integration']
Deployability,"class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; <tt>Root.Html.LibName</tt>, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().</p>. <p>Example:<br/>; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains</p><pre>; Root.Html.MyLib: ../mylib/</pre>; <p>THtml will create a link to ""../mylib/MyClass.html"".</p>. <p>The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is</p>; <pre> $ rlibmap -f -r rootmap -l mylib/libMyLib.so -d libCore.so -c MyLinkdef.h</pre>; <p>Here, <tt>-r</tt> specifies that the entries for libMyLib should be updated,; <tt>-l</tt> specifies the library we're dealing with, <tt>-d</tt> its; dependencies, and <tt>-c</tt> its linkdef. The rootmap file must be within; one of the <tt>LD_LIBRARY_PATH</tt> (or <tt>PATH</tt> for Windows) directories; when ROOT is started, otherwise ROOT will not use it.</p>. <h4><a name=""conf:classdoc"">II.4 Recognizing class documentation</a></h4>. <p>The class documentation has to appear in the header file containing the; class, right in front of its declaration. It is introduced by a string; defined by Root.Html.Description or SetClassDocTag(). See the section on; <a href=""#syntax"">documentation syntax</a> for further details.</p>. <p>Example:</p><pre>; Root.Html.Description: //____________________</pre>. <p>The class documentation will show which include statement is to be used; and which library needs to be linked to access it.; The include file name is determined via; <a href=""http://root.cern.ch/root/html/TClass.html#TClass:GetDeclFileName"">; TClass::GetDeclFileName()</a>;; leading",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx:5701,update,updated,5701,html/src/THtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx,1,['update'],['updated']
Deployability,"crete implementation of the NeymanConstruction; interface that, as the name suggests, performs a NeymanConstruction. It produces; a RooStats::PointSetInterval, which is a concrete implementation of the; ConfInterval interface. The Neyman Construction is not a uniquely defined statistical technique, it; requires that one specify an ordering rule or ordering principle, which is; usually incoded by choosing a specific test statistic and limits of integration; (corresponding to upper/lower/central limits). As a result, this class must be; configured with the corresponding information before it can produce an interval.; Common configurations, such as the Feldman-Cousins approach, can be enforced by; other light weight classes. The Neyman Construction considers every point in the parameter space; independently, no assumptions are made that the interval is connected or of a; particular shape. As a result, the PointSetInterval class is used to represent; the result. The user indicate which points in the parameter space to perform; the construction by providing a PointSetInterval instance with the desired points. This class is fairly light weight, because the choice of parameter points to be; considered is factorized and so is the creation of the sampling distribution of; the test statistic (which is done by a concrete class implementing the; DistributionCreator interface). As a result, this class basically just drives the; construction by:. - using a DistributionCreator to create the SamplingDistribution of a user-; defined test statistic for each parameter point of interest,; - defining the acceptance region in the data by finding the thresholds on the; test statistic such that the integral of the sampling distribution is of the; appropriate size and consistent with the limits of integration; (eg. upper/lower/central limits),; - and finally updating the PointSetInterval based on whether the value of the; test statistic evaluated on the data are in the acceptance region. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/NeymanConstruction.cxx:2314,integrat,integration,2314,roofit/roostats/src/NeymanConstruction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/NeymanConstruction.cxx,1,['integrat'],['integration']
Deployability,"cript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page. // draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a macro; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }; ~~~. ## Making several pictures in the same Postscript file: case 2. This example shows 2 pages. The canvas is divided.; `TPostScript::NewPage` must be called before starting a new; picture.`object->Draw` does not clear the canvas in this case; because we clear only the pads and not the main canvas.; Note that `c1->Update` must be called at the end of the first picture. ~~~ {.cpp}; {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; TPostScript *ps = new TPostScript(""file.ps"",112);; c1->Divide(2,1);; // picture 1; ps->NewPage();; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();; c1->Update();. // picture 2; ps->NewPage();; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Update();; ps->Close();. // invoke Postscript viewer; gSystem->Exec(""gs file.ps"");; }; ~~~. ## Making several pictures in the same Postscript file: case 3; This is the recommended way. If the Postscript file name finishes with; ""("", the file remains opened (it is not closed). If the Postscript file name; finishes with "")"" and the file has been opened with ""("", the file is closed. Example:; ~~~ {.cpp}; {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); // canvas is added to ""c1.ps"" and ps file is closed; }; ~~~; The `TCanvas::Print(""file.ps("")` mechanism is very useful, but it can; be a little inconvenient to have the action of opening/closing a file being; atomic with printing a page. Particularly if pages are being generated in some; loop one needs to detect the special cases of first and last page and then; mun",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TPostScript.cxx:5245,Update,Update,5245,graf2d/postscript/src/TPostScript.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TPostScript.cxx,1,['Update'],['Update']
Deployability,"cted for this ASImage all or part of; * the scanline will be RLE encoded.; *********/; /****f* libAfterImage/asimage/asimage_add_line_mono(); * NAME; * asimage_add_line_mono(); * SYNOPSIS; * size_t asimage_add_line_mono ( ASImage * im, ColorPart color,; * CARD8 value, unsigned int y);; * INPUTS; * im				- pointer to valid ASImage structure; * color			- color channel's number; * value			- value for the channel; * y 				- image row starting with 0; * RETURN VALUE; * asimage_add_line_mono() return size of the encoded channel scanline; * in bytes. On failure it will return 0.; * DESCRIPTION; * encodes ASImage channel scanline to have same color components; * value in every pixel. Useful for vertical gradients for example.; *********/; /****f* libAfterImage/asimage/get_asimage_chanmask(); * NAME; * get_asimage_chanmask(); * SYNOPSIS; * ASFlagType get_asimage_chanmask( ASImage *im);; * INPUTS; * im - valid ASImage object.; * DESCRIPTION; * goes throu all the scanlines of the ASImage and toggles bits ; * representing those components that have at least some data.; *********/; /****f* libAfterImage/asimage/move_asimage_channel(); * NAME; * move_asimage_channel(); * SYNOPSIS; * void move_asimage_channel( ASImage *dst, int channel_dst,; * ASImage *src, int channel_src );; * INPUTS; * dst - ASImage which will have its channel substituted;; * channel_dst - what channel to move data to;; * src - ASImage which will donate its channel to dst;; * channel_src - what source image channel to move data from.; * DESCRIPTION; * MOves channel data from one ASImage to another, while discarding; * what was already in destination's channel.; * NOTES; * Source image (donor) will loose its channel data, as it will be; * moved to destination ASImage. Also there is a condition that both; * images must be of the same width - otherwise function returns; * without doing anything. If height is different - the minimum of; * two will be used.; *********/; /****f* libAfterImage/asimage/copy_asimage_chan",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:1634,toggle,toggles,1634,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,1,['toggle'],['toggles']
Deployability,"d and for every file; /// found, an event is synthesized as if the file was added.; ///; /// This is not a general purpose directory monitoring tool - list of; /// limitations follows.; ///; /// Only flat directories with no subdirectories are supported. In case; /// subdirectories are present the behavior is unspecified - events *might* be; /// passed to Receiver on macOS (due to FSEvents being used) while they; /// *probably* won't be passed on Linux (due to inotify being used).; ///; /// Known potential inconsistencies; /// - For files that are deleted befor the initial scan processed them, clients; /// might receive Removed notification without any prior Added notification.; /// - Multiple notifications might be produced when a file is added to the; /// watched directory during the initial scan. We are choosing the lesser evil; /// here as the only known alternative strategy would be to invalidate the; /// watcher instance and force user to create a new one whenever filesystem; /// event occurs during the initial scan but that would introduce continuous; /// restarting failure mode (watched directory is not always ""owned"" by the same; /// process that is consuming it). Since existing clients can handle duplicate; /// events well, we decided for simplicity.; ///; /// Notifications are provided only for changes done through local user-space; /// filesystem interface. Specifically, it's unspecified if notification would; /// be provided in case of a:; /// - a file mmap-ed and changed; /// - a file changed via remote (NFS) or virtual (/proc) FS access to monitored; /// directory; /// - another filesystem mounted to the watched directory; ///; /// No support for LLVM VFS.; ///; /// It is unspecified whether notifications for files being deleted are sent in; /// case the whole watched directory is sent.; ///; /// Directories containing ""too many"" files and/or receiving events ""too; /// frequently"" are not supported - if the initial scan can't be finished before; /// th",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/DirectoryWatcher/DirectoryWatcher.h:1264,continuous,continuous,1264,interpreter/llvm-project/clang/include/clang/DirectoryWatcher/DirectoryWatcher.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/DirectoryWatcher/DirectoryWatcher.h,1,['continuous'],['continuous']
Deployability,"d draw several pictures. The generation of a new Postscript page; is automatic when `TCanvas::Clear` is called by `object->Draw()`. ~~~ {.cpp}; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. // select postscript output type; // type = 111 portrait ps; // type = 112 landscape ps; // type = 113 eps; Int_t type = 111;. // create a postscript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page. // draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a macro; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }; ~~~. ## Making several pictures in the same Postscript file: case 2. This example shows 2 pages. The canvas is divided.; `TPostScript::NewPage` must be called before starting a new; picture.`object->Draw` does not clear the canvas in this case; because we clear only the pads and not the main canvas.; Note that `c1->Update` must be called at the end of the first picture. ~~~ {.cpp}; {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; TPostScript *ps = new TPostScript(""file.ps"",112);; c1->Divide(2,1);; // picture 1; ps->NewPage();; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();; c1->Update();. // picture 2; ps->NewPage();; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Update();; ps->Close();. // invoke Postscript viewer; gSystem->Exec(""gs file.ps"");; }; ~~~. ## Making several pictures in the same Postscript file: case 3; This is the recommended way. If the Postscript file name finishes with; ""("", the file remains opened (it is not closed). If the Postscript file name; finishes with "")"" and the file has been opened with ""("", the file is closed. Example:; ~~~ {.cpp}; {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); // canvas is ad",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TPostScript.cxx:4837,Update,Update,4837,graf2d/postscript/src/TPostScript.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TPostScript.cxx,1,['Update'],['Update']
Deployability,"d location, is; not reconsidered when that location is binned later. If there are two overlapping bins, the first one in the list will be incremented; by `Fill()`. The histogram may automatically extends its limits if a bin outside the; histogram limits is added. This is done when the default constructor (with no; arguments) is used. It generates a histogram with no limits along the X and Y; axis. Adding bins to it will extend it up to a proper size. `TH2Poly` implements a partitioning algorithm to speed up bins' filling; (see the ""Partitioning Algorithm"" section for details).; The partitioning algorithm divides the histogram into regions called cells.; The bins that each cell intersects are recorded in an array of `TList`s.; When a coordinate in the histogram is to be filled; the method (quickly) finds; which cell the coordinate belongs. It then only loops over the bins; intersecting that cell to find the bin the input coordinate corresponds to.; The partitioning of the histogram is updated continuously as each bin is added.; The default number of cells on each axis is 25. This number could be set to; another value in the constructor or adjusted later by calling the; `ChangePartition(Int_t, Int_t)` method. The partitioning algorithm is; considerably faster than the brute force algorithm (i.e. checking if each bin; contains the input coordinates), especially if the histogram is to be filled; many times. The following very simple macro shows how to build and fill a `TH2Poly`:; ~~~ {.cpp}; {; auto h2p = new TH2Poly();. Double_t x1[] = {0, 5, 6};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, 3};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 3.7, 2.5};. h2p->AddBin(3, x1, y1);; h2p->AddBin(4, x2, y2);; h2p->AddBin(5, x3, y3);. h2p->Fill(0.1, 0.01, 3);; h2p->Fill(-0.5, -0.5, 7);; h2p->Fill(-0.7, -0.5, 1);; h2p->Fill(1, 3, 1.5);; }; ~~~. More examples can be found in th2polyBoxes.C, th2polyEurope.C, th2polyHoney",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:2031,update,updated,2031,hist/hist/src/TH2Poly.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx,2,"['continuous', 'update']","['continuously', 'updated']"
Deployability,"d reservation table describing each cycle of instruction; /// execution. Subtargets may define any or all of the above categories of data; /// depending on the type of CPU and selected scheduler.; ///; /// The machine independent properties defined here are used by the scheduler as; /// an abstract machine model. A real micro-architecture has a number of; /// buffers, queues, and stages. Declaring that a given machine-independent; /// abstract property corresponds to a specific physical property across all; /// subtargets can't be done. Nonetheless, the abstract model is; /// useful. Futhermore, subtargets typically extend this model with processor; /// specific resources to model any hardware features that can be exploited by; /// scheduling heuristics and aren't sufficiently represented in the abstract.; ///; /// The abstract pipeline is built around the notion of an ""issue point"". This; /// is merely a reference point for counting machine cycles. The physical; /// machine will have pipeline stages that delay execution. The scheduler does; /// not model those delays because they are irrelevant as long as they are; /// consistent. Inaccuracies arise when instructions have different execution; /// delays relative to each other, in addition to their intrinsic latency. Those; /// special cases can be handled by TableGen constructs such as, ReadAdvance,; /// which reduces latency when reading data, and ReleaseAtCycles, which consumes; /// a processor resource when writing data for a number of abstract; /// cycles.; ///; /// TODO: One tool currently missing is the ability to add a delay to; /// ReleaseAtCycles. That would be easy to add and would likely cover all cases; /// currently handled by the legacy itinerary tables.; ///; /// A note on out-of-order execution and, more generally, instruction; /// buffers. Part of the CPU pipeline is always in-order. The issue point, which; /// is the point of reference for counting cycles, only makes sense as an; /// in-order part",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:1447,pipeline,pipeline,1447,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['pipeline'],['pipeline']
Deployability,"d> Follow strategy 0 for all RooSimultaneous components, except those with less than; * 30 dataset entries, for which strategy 2 is followed.; * </table>; * <tr><td> `EvalBackend(std::string const&)` <td> Choose a likelihood evaluation backend:; * <table>; * <tr><th> Backend <th> Description; * <tr><td> **cpu** - *default* <td> New vectorized evaluation mode, using faster math functions and auto-vectorisation.; * Since ROOT 6.23, this is the default if `EvalBackend()` is not passed, succeeding the **legacy** backend.; * If all RooAbsArg objects in the model support vectorized evaluation,; * likelihood computations are 2 to 10 times faster than with the **legacy** backend; * - unless your dataset is so small that the vectorization is not worth it.; * The relative difference of the single log-likelihoods with respect to the legacy mode is usually better than \f$10^{-12}\f$,; * and for fit parameters it's usually better than \f$10^{-6}\f$. In past ROOT releases, this backend could be activated with the now deprecated `BatchMode()` option.; * <tr><td> **cuda** <td> Evaluate the likelihood on a GPU that supports CUDA.; * This backend re-uses code from the **cpu** backend, but compiled in CUDA kernels.; * Hence, the results are expected to be identical, modulo some numerical differences that can arise from the different order in which the GPU is summing the log probabilities.; * This backend can drastically speed up the fit if all RooAbsArg object in the model support it.; * <tr><td> **legacy** <td> The original likelihood evaluation method.; * Evaluates the PDF for each single data entry at a time before summing the negative log probabilities.; * <tr><td> **codegen** <td> **Experimental** - Generates and compiles minimal C++ code for the NLL on-the-fly and wraps it in the returned RooAbsReal.; * Also generates and compiles the code for the gradient using Automatic Differentiation (AD) with [Clad](https://github.com/vgvassilev/clad).; * This analytic gradient is passed to ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:4087,release,releases,4087,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['release'],['releases']
Deployability,"dach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. ### What is FOAM for?. - Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own method. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; - FOAM generates random points with weight one or with variable weight.; - FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.). ### How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. \image html foam_MapCamel1000.png width=400. FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:; See [full version of FOAM](http://jadach.home.cern.ch/jadach/Foam/Index.html). ### Simple example of the use of FOAM:. Begin_Macro(source); ../../../tutorials/foam/foam_kanwa.C; End_Macro. ### Canonical nine steering parameters of FOAM. | Name | default | Description |; |----------|----------|--------------------------------------------------------|; | kDim | 0 | Dimension of the integration space. Must be redefined! |; | nCells | 1000 | No of allocated number of cells, |; | nSampl | 200 | No. of MC events in the cell MC exploration |; | nBin | 8 | No. of bins in edge-histogram in cell exploration |; | OptRej | 1 | OptRej = 0, weighted; OptRej=1, wt=1 MC events |; | OptDrive | 2 | Maximum weight reduction, =1 for variance reduction |; | EvPerBin | 25 | Maximum number of the effective wt=1 events/bin, |; | | |",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:1290,integrat,integrated,1290,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,1,['integrat'],['integrated']
Deployability,"ded to display the various kind of; graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`. To draw a graph `graph` it's enough to do:. graph->Draw(""AL"");. The option `AL` in the `Draw()` method means:. 1. The axis should be drawn (option `A`),; 2. The graph should be drawn as a simple line (option `L`). By default a graph is drawn in the current pad in the current coordinate system.; To define a suitable coordinate system and draw the axis the option; `A` must be specified. `TGraphPainter` offers many options to paint the various kind of graphs. It is separated from the graph classes so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is no need to call `Draw()` again; the; image will be refreshed the next time the pad will be updated. A pad is updated; after one of these three actions:. 1. a carriage return on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. \anchor GrP1; ### Graphs' plotting options; Graphs can be drawn with the following options:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""A"" | Produce a new plot with Axis around the graph |; | ""I"" | Combine with option 'A' it draws invisible axis |; | ""L"" | A simple polyline is drawn |; | ""F"" | A fill area is drawn ('CF' draw a smoothed fill area) |; | ""C"" | A smooth Curve is drawn |; | ""*"" | A Star is plotted at each point |; | ""P"" | The current marker is plotted at each point |; | ""B"" | A Bar chart is drawn |; | ""1"" | When a graph is drawn as a bar chart, this option makes the bars start from the bottom of the pad. By default they start at 0. |; | ""X+"" | The X-axis is drawn on the top side of the plot. |; | ""Y+"" | The Y-axis is drawn on the right side of the plot. |; | ""PFC"" | Palette Fill Color: graph's fill color is taken in the current palette. |; | ""PLC"" | Palette Line Color: graph's line color is ta",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:1823,Update,Update,1823,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,1,['Update'],['Update']
Deployability,"different weights in your case, you; should either merge or combine them to get the overall efficiency. \anchor EFF051; ### V.1 When should I use merging?; If the weights are artificial and do not represent real alternative hypotheses,; you should merge the different TEfficiency objects. That means especially for; the Bayesian case that the prior probability should be the same for all merged; TEfficiency objects. The merging can be done by invoking one of the following; operations:; - eff1.Add(eff2); - eff1 += eff2; - eff1 = eff1 + eff2. The result of the merging is stored in the TEfficiency object which is marked; bold above. The contents of the internal histograms of both TEfficiency; objects are added and a new weight is assigned. The statistic options are not; changed. \f[; \frac{1}{w_{new}} = \frac{1}{w_{1}} + \frac{1}{w_{2}}; \f]. \anchor EFF05b; ### Example:; If you use two samples with different numbers of generated events for the same; process and you want to normalise both to the same integrated luminosity and; trigger efficiency, the different weights then arise just from the fact that; you have different numbers of events. The TEfficiency objects should be merged; because the samples do not represent true alternatives. You expect the same; result as if you would have a big sample with all events in it. \f[; w_{1} = \frac{\sigma L}{\epsilon N_{1}}, w_{2} = \frac{\sigma L}{\epsilon N_{2}} \Rightarrow w_{new} = \frac{\sigma L}{\epsilon (N_{1} + N_{2})} = \frac{1}{\frac{1}{w_{1}} + \frac{1}{w_{2}}}; \f]. \anchor EFF052; ### V.2 When should I use combining?; You should combine TEfficiency objects whenever the weights represent; alternatives processes for the efficiency. As the combination of two TEfficiency; objects is not always consistent with the representation by two internal; histograms, the result is not stored in a TEfficiency object but a TGraphAsymmErrors; is returned which shows the estimated combined efficiency and its uncertainty; for each bin.; A",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:17822,integrat,integrated,17822,hist/hist/src/TEfficiency.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx,1,['integrat'],['integrated']
Deployability,"e TTree and the TEventLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCut. The learning method is defined using the TMultiLayerPerceptron::SetLearningMethod() .; Learning methods are :. - TMultiLayerPerceptron::kStochastic,; - TMultiLayerPerceptron::kBatch,; - TMultiLayerPerceptron::kSteepestDescent,; - TMultiLayerPerceptron::kRibierePolak,; - TMultiLayerPerceptron::kFletcherReeves,; - TMultiLayerPerceptron::kBFGS. A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account. Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. Example:; ~~~ {.cpp}; net.Train(100,""text, graph, update=10"");; ~~~. When the neural net is trained, it can be used; directly ( TMultiLayerPerceptron::Evaluate() ) or exported to a; standalone C++ code ( TMultiLayerPerceptron::Export() ). Finally, note that even if this implementation is inspired from the mlpfit code,; the feature lists are not exactly matching:. - mlpfit hybrid learning method is not implemented; - output neurons can be normalized, this is not the case for mlpfit; - the neural net is exported in C++, FORTRAN or PYTHON; - the drawResult() method allows a fast check of the learning procedure. In addition, the paw version of mlpfit had additional limitations on the number of; neurons, hidden layers and inputs/outputs that does not apply to TMultiLayerPerceptron.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx:8415,update,update,8415,math/mlp/src/TMultiLayerPerceptron.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx,3,['update'],['update']
Deployability,"e getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; the help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform an entirely numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e., no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; common, etc). #### Implementing analytical integrals; To implement analytical integrals, two functions must be implemented. First,. ```; Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet); ```; should return the analytical integrals that are supported. `integSet`; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to `anaIntSet`, and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. ```; double analyticalIntegral(Int_t code); ```. implements the actual analytical integral(s) advertised by; `getAnalyticalIntegral()`. This function will only be called with; codes returned by `getAnalyticalIntegral()`, except code zero. The integration range for each dependent to be integrated can; be obtained from the dependent's proxy functions `min()` and; `max()`. Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g., in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. ### Direct generation of observables. Distributions for any PDF can be generated with the accept/reject method,; but for certain PDFs, more efficient methods may be implemented. To; i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:3555,integrat,integrate,3555,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,3,"['configurat', 'integrat']","['configuration', 'integrate', 'integration']"
Deployability,"e may be copyrighted by their authors; and need not follow the licensing terms described here, provided that; the new terms are clearly indicated on the first page of each file where; they apply. IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY; FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES; ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY; DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE; POSSIBILITY OF SUCH DAMAGE. THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,; INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT. THIS SOFTWARE; IS PROVIDED ON AN ""AS IS"" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE; NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR; MODIFICATIONS. GOVERNMENT USE: If you are acquiring this software on behalf of the; U.S. government, the Government shall have only ""Restricted Rights""; in the software and related documentation as defined in the Federal ; Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2). If you; are acquiring the software on behalf of the Department of Defense, the; software shall be classified as ""Commercial Computer Software"" and the; Government shall have only ""Restricted Rights"" as defined in Clause; 252.227-7013 (c) (1) of DFARs. Notwithstanding the foregoing, the; authors grant the U.S. Government and others acting in its behalf; permission to use and distribute the software in accordance with the; terms specified in this license.; */; /*; *----------------------------------------------------------------------; *; * XAllocColor --; *; *	Find the closest available color to the specified XColor.; *; * Results:; *	Updates the color argument and returns 1 on success. Otherwise; *	returns 0.; *; * Side effects:; *	Allocates a new color in the palette.; *; *----------------------------------------------------------------------; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c:2656,Update,Updates,2656,graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c,1,['Update'],['Updates']
Deployability,"e next; block to be emitted. This is for advanced applications that need to control; the emission of deflate blocks. If flush is set to Z_FULL_FLUSH, all output is flushed as with; Z_SYNC_FLUSH, and the compression state is reset so that decompression can; restart from this point if previous compressed data has been damaged or if; random access is desired. Using Z_FULL_FLUSH too often can seriously degrade; compression. If deflate returns with avail_out == 0, this function must be called again; with the same value of the flush parameter and more output space (updated; avail_out), until the flush is complete (deflate returns with non-zero; avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that; avail_out is greater than six to avoid repeated flush markers due to; avail_out == 0 on return. If the parameter flush is set to Z_FINISH, pending input is processed,; pending output is flushed and deflate returns with Z_STREAM_END if there was; enough output space; if deflate returns with Z_OK, this function must be; called again with Z_FINISH and more output space (updated avail_out) but no; more input data, until it returns with Z_STREAM_END or an error. After; deflate has returned Z_STREAM_END, the only possible operations on the stream; are deflateReset or deflateEnd. Z_FINISH can be used immediately after deflateInit if all the compression; is to be done in a single step. In this case, avail_out must be at least the; value returned by deflateBound (see below). Then deflate is guaranteed to; return Z_STREAM_END. If not enough output space is provided, deflate will; not return Z_STREAM_END, and it must be called again as described above. deflate() sets strm->adler to the adler32 checksum of all input read; so far (that is, total_in bytes). deflate() may update strm->data_type if it can make a good guess about; the input data type (Z_BINARY or Z_TEXT). In doubt, the data is considered; binary. This field is only for information purposes and does not affec",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:4350,update,updated,4350,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['update'],['updated']
Deployability,"e original one for fits; * or plotting etc.; * \note The binning will be taken from the observable. Make sure that this binning is the same as the one of the dataset that should be fit.; * Use RooRealVar::setBinning() to adapt it.; * - Instruct test statistics to carry out this wrapping automatically:; * ```; * pdf.fitTo(data, IntegrateBins(<precision>));; * ```; * This method is especially useful when used with a simultaneous PDF, since each component will automatically be wrapped,; * depending on the value of `precision`:; * - `precision < 0.`: None of the PDFs are touched, bin sampling is off.; * - `precision = 0.`: Continuous PDFs that are fit to a RooDataHist are wrapped into a RooBinSamplingPdf. The target precision; * forwarded to the integrator is 1.E-4 (the default argument of the constructor).; * - `precision > 0.`: All continuous PDFs are automatically wrapped into a RooBinSamplingPdf, regardless of what data they are; * fit to (see next paragraph). The same `'precision'` is used for all integrators.; *; * ### Simulating a binned fit using RooDataSet; * Some frameworks use unbinned data (RooDataSet) to simulate binned datasets. By adding one entry for each bin centre with the; * appropriate weight, one can achieve the same result as fitting with RooDataHist. In this case, however, RooFit cannot; * auto-detect that a binned fit is running, and that an integration over the bin is desired (note that there are no bins to; * integrate over in this kind of dataset).; *; * In this case, `IntegrateBins(>0.)` needs to be used, and the desired binning needs to be assigned to the observable; * of the dataset:; * ```; * RooRealVar x(""x"", ""x"", 0., 5.);; * x.setBins(10);; *; * // <create dataset and model>; *; * model.fitTo(data, IntegrateBins(>0.));; * ```; *; * \see RooAbsPdf::fitTo(); * \see IntegrateBins(); *; * \note This feature is currently limited to one-dimensional PDFs.; *; *; * \htmlonly <style>div.image img[src=""RooBinSamplingPdf_OFF.png""]{width:12cm;}</sty",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:3068,integrat,integrators,3068,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,1,['integrat'],['integrators']
Deployability,"e will be updated, *i.e.*, a new FFT runs.; ///; /// The sampling density of the FFT is controlled by the binning of the; /// the convolution observable, which can be changed using RooRealVar::setBins(N).; /// For good results, N should be large (>=1000). Additional interpolation; /// between the bins may improve the result if coarse binnings are chosen. These can be; /// activated in the constructor or by calling `setInterpolationOrder()`.; /// For N >> 1000, interpolation will not substantially improve the accuracy.; ///; /// Additionial information on caching can be displayed by monitoring; /// the message stream with topic ""Caching"" at the INFO level, *i.e.*; /// by calling `RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching""))`; /// to see these message on stdout.; ///; /// Multi-dimensional convolutions are not supported at the moment.; ///; /// ---; ///; /// Installing an external version of FFTW on Linux and compiling ROOT to use it; /// -------; ///; /// You have two options:; /// * **Recommended**: ROOT can automatically install FFTW for itself, see `builtin_fftw3` at https://root.cern/building-root; /// * Install FFTW and let ROOT discover it. `fftw3` is on by default (see https://root.cern/building-root); ///; /// 1) Go to www.fftw.org and download the latest stable version (a .tar.gz file); ///; /// If you have root access to your machine and want to make a system installation of FFTW; ///; /// 2) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; /// and type './configure' followed by 'make install'.; /// This will install fftw in /usr/local/bin,lib etc...; ///; /// 3) Start from a source installation of ROOT. ROOT should discover it. See https://root.cern/building-root; ///; ///; /// If you do not have root access and want to make a private installation of FFTW; ///; /// 2) Make a private install area for FFTW, e.g. /home/myself/fftw; ///; /// 3) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; /// and type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:4241,Install,Installing,4241,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,2,"['Install', 'install']","['Installing', 'install']"
Deployability,"e | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a function failed; // or succeeded. In those cases we use the state MaybeAllocated.; // Thus, the diagram above captures the intent, not implementation details.; //; // Due to the fact that the number of handle related syscalls in Fuchsia; // is large, we adopt the annotation attributes to descript syscalls'; // operations(acquire/release/use) on handles instead of hardcoding; // everything in the checker.; //; // We use following annotation attributes for handle related syscalls or; // functions:; // 1. __attribute__((acquire_handle(""Fuchsia""))) |handle will be acquired; // 2. __attribute__((release_handle(""Fuchsia""))) |handle will be released; // 3. __attribute__((use_handle(""Fuchsia""))) |handle will not transit to; // escaped state, it also needs to be open.; //; // For example, an annotated syscall:; // zx_status_t zx_channel_create(; // uint32_t options,; // zx_handle_t* out0 __attribute__((acquire_handle(""Fuchsia""))) ,; // zx_handle_t* out1 __attribute__((acquire_handle(""Fuchsia""))));; // denotes a syscall which will acquire two handles and save them to 'out0' and; // 'out1' when succeeded.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:2841,release,release,2841,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,2,['release'],"['release', 'released']"
Deployability,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDivergence() is true;; // on other targets, it is a nop.; //; // This lets you include this pass unconditionally in the IR pass pipeline, but; // only enable it for relevant targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h:2123,pipeline,pipeline,2123,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h,2,['pipeline'],['pipeline']
Deployability,"e.; ///; /// <tr><td> `Slice(RooCategory& cat, const char* label)` <td> Override default projection behaviour by omitting the specified category; /// observable from the projection, i.e., by not integrating over all states of this category.; /// The slice is positioned at the given label value. To pass multiple Slice() commands, please use the; /// Slice(std::map<RooCategory*, std::string> const&) argument explained below.; ///; /// <tr><td> `Slice(std::map<RooCategory*, std::string> const&)` <td> Omits multiple categories from the projection, as explianed above.; /// Can be used with initializer lists for convenience, e.g.; /// ```{.cpp}; /// pdf.plotOn(frame, Slice({{&tagCategory, ""2tag""}, {&jetCategory, ""3jet""}});; /// ```; ///; /// <tr><td> `Project(const RooArgSet& set)` <td> Override default projection behaviour by projecting over observables; /// given in the set, ignoring the default projection behavior. Advanced use only.; ///; /// <tr><td> `ProjWData(const RooAbsData& d)` <td> Override default projection _technique_ (integration). For observables present in given dataset; /// projection of PDF is achieved by constructing an average over all observable values in given set.; /// Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ///; /// <tr><td> `ProjWData(const RooArgSet& s, const RooAbsData& d)` <td> As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; ///; /// <tr><td> `ProjectionRange(const char* rn)` <td> Override default range of projection integrals to a different range specified by given range name.; /// This technique allows you to project a finite width slice in a real-valued observable; ///; /// <tr><td> `NumCPU(Int_t ncpu)` <td> Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData); ///; ///; /// <tr><th><th> Misc content control; /// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control numbe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:2346,integrat,integration,2346,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['integrat'],['integration']
Deployability,"e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is introduced:; // uint32_t __builtin_preserve_field_info(member_access, info_kind); // In IR, a chain with two (or more) intrinsic calls will be generated:; // ...; // addr = preserve_struct_access_index(base, 1, 1) !struct s; // uint32_t result = bpf_preserve_field_info(addr, info_kind); //; // Suppose the info_kind is FIELD_SIGNEDNESS,; // The above two IR intrinsics will be replaced with; // a relocatable insn:; // signness = /* signness of member_access */; // and signness can be changed by bpf loader based on the; // types on the host.; //; // User can also test whether a field exists or not with; // uint32_t result = bpf_preserve_field_info(member_access, FIELD_EXISTENCE); // The field will be always available (result = 1) during initial; // compilation, but bpf loader can patch with the correct value; // on the target host where the member_access may or may not be available; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:2788,patch,patch,2788,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,1,['patch'],['patch']
Deployability,"e; * implementation of 'receive_task_result_on_master', one will get the whole; * message, but the 'Job' ID part will already have been identified in the; * 'JobManager', so one needn't worry about it further inside; * 'Job::receive_task_result_on_master' (it is already routed to the correct; * 'Job'). The same goes for the receiving end of 'update_state', except that; * update_state is routed from the 'worker_loop', not the 'JobManager'.; *; * A second rule applies to 'update_state' messages: the second part must be; * a state identifier. This identifier will also be sent along with tasks to; * the queue. When a worker then takes a task from the queue, it can check; * whether it has already updated its state to what is expected to be there; * for the task at hand. If not, it should wait for the new state to arrive; * over the state subscription socket. Note: it is the implementer's task to; * actually update 'Job::state_id_' inside 'Job::update_state()'!; *; * ## Implementers notes; *; * The type of result from each task is strongly dependent on the Job at hand; * and so Job does not provide a default results member. It is up to the; * inheriting class to implement this in the above functions. We would have; * liked a template parameter task_result_t, so that we could also provide a; * default ""boilerplate"" calculate function to show a typical Job use-case of; * all the above infrastructure. This is not trivial, because the JobManager; * has to keep a list of Job pointers, so if there would be different template; * instantiations of Jobs, this would complicate this list.; *; * A typical Job implementation will have an evaluation function that is; * called from the master process, like RooAbsArg::getVal calls evaluate().; * This function will have three purposes: 1. send updated parameter values; * to the workers (possibly through update_state() or in a dedicated; * function), 2. queue tasks and 3. wait for the results to be retrieved.; * 'Job::gather_worker_results",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Job.cxx:2399,update,update,2399,roofit/multiprocess/src/Job.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Job.cxx,1,['update'],['update']
Deployability,"e; colors to distinguish contours (`SURF` option at theta = 0). Combined; with the option `CONT` (or `CONT0`), the option `Z`; allows to display the color palette defined by `gStyle->SetPalette()`. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcont4->Fill(px-1,5*py);; hcont4->Fill(2+0.5*px,2*py-10.,0.1);; }; hcont4->Draw(""CONT4Z"");; }; End_Macro. The default number of contour levels is 20 equidistant levels and can be changed; with `TH1::SetContour()` or `TStyle::SetNumberContours()`. \anchor HP16a; #### The LIST option. When option `LIST` is specified together with option; `CONT`, the points used to draw the contours are saved in; `TGraph` objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in `TGraph` objects once the pad is painted.; Therefore to use this functionality in a macro, `gPad->Update()`; should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where `i` is a contour number, and list contains a list of; `TGraph` objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example (ContourList.C) shows how to use this functionality. Begin_Macro(source); ../../../tutorials/hist/ContourList.C; End_Macro. \anchor HP16b; #### The AITOFF, MERCATOR, SINUSOIDAL and PARABOLIC options. The following options select the `CONT4` option and are useful for; sky maps or exposure maps (earth.C). | Option | Description |; |--------------|-----------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:67686,Update,Update,67686,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['Update'],['Update']
Deployability,"e; the Clone() function. This makes an identical copy of the original; histogram including all associated errors and functions, e.g.:; ~~~ {.cpp}; TH1F *hnew = (TH1F*)h->Clone(""hnew"");; ~~~. \anchor normalizing; ### Normalizing histograms. One can scale a histogram such that the bins integral is equal to; the normalization parameter via TH1::Scale(Double_t norm), where norm; is the desired normalization divided by the integral of the histogram. \anchor drawing-histograms; ## Drawing histograms. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; Many drawing options are supported.; See THistPainter::Paint() for more details. The same histogram can be drawn with different options in different pads.; When a histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If a histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of a histogram in a pad, one can use; ~~~ {.cpp}; h->DrawCopy();; ~~~; This makes a clone (see Clone below) of the histogram. Once the clone; is drawn, the original histogram may be modified or deleted without; affecting the aspect of the clone. One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular; value for the maximum or the minimum scale on the plot. (For 1-D; histograms this means the y-axis, while for 2-D histograms these; functions affect the z-axis). TH1::UseCurrentStyle() can be used to change all histogram graphics; attributes to correspond to the current selected style.; This function must be called for each histogram.; In case one reads and draws many histograms from a file, one can force; the histograms to inherit automatically the current graphics style; by calling before gROOT->ForceStyle(). \anchor con",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:17536,update,updated,17536,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['update'],['updated']
Deployability,"eates a local ROOT file.; ///; /// \param[in] fname1 The name of the file; /// \param[in] option Specifies the mode in which the file is opened; /// \param[in] ftitle The title of the file; /// \param[in] compress Specifies the compression algorithm and level; ///; /// It is recommended to specify fname1 as ""<file>.root"". The suffix "".root""; /// will be used by object browsers to automatically identify the file as; /// a ROOT file. If the constructor fails in any way IsZombie() will; /// return true. Use IsOpen() to check if the file is (still) open.; /// To open non-local files use the static TFile::Open() method, that; /// will take care of opening the files using the correct remote file; /// access plugin.; ///; /// Option | Description; /// -------|------------; /// NEW or CREATE | Create a new file and open it for writing, if the file already exists the file is not opened.; /// RECREATE | Create a new file, if the file already exists it will be overwritten.; /// UPDATE | Open an existing file for writing. If no file exists, it is created.; /// READ | Open an existing file for reading (default).; /// NET | Used by derived remote file access classes, not a user callable option.; /// WEB | Used by derived remote http access class, not a user callable option.; /// READ_WITHOUT_GLOBALREGISTRATION | Used by TTreeProcessorMT, not a user callable option.; ///; /// If option = """" (default), READ is assumed.; /// The file can be specified as a URL of the form:; ///; /// file:///user/rdm/bla.root or file:/user/rdm/bla.root; ///; /// The file can also be a member of an archive, in which case it is; /// specified as:; ///; /// multi.zip#file.root or multi.zip#0; ///; /// which will open file.root which is a member of the file multi.zip; /// archive or member 1 from the archive. For more on archive file; /// support see the TArchiveFile class.; /// TFile and its remote access plugins can also be used to open any; /// file, i.e. also non ROOT files, using:; ///; /// file.tar?f",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:1079,UPDATE,UPDATE,1079,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['UPDATE'],['UPDATE']
Deployability,"ect id |; | *:rawdata | raw data, column contains id of raw data from _streamer_ table |; | *:Int_t | column with integer value |. Use TSQLFile::SetUseSuffixes(kFALSE) to disable suffixes usage.; This and several other options can be changed only when; TSQLFile created with options ""CREATE"" or ""RECREATE"" and only before; first write operation. These options are:; | Name | Description |; |------|-------------|; | SetUseSuffixes() | suffix usage in column names (default - on) |; | SetArrayLimit() | defines maximum array size, which can has column for each element (default 21) |; | SetTablesType() | table type name in MySQL database (default ""InnoDB"") |; | SetUseIndexes() | usage of indexes in database (default kIndexesBasic) |. Normally these functions should be called immediately after TSQLFile constructor.; When objects data written to database, by default START TRANSACTION/COMMIT; SQL commands are used before and after data storage. If TSQLFile detects; any problems, ROLLBACK command will be used to restore; previous state of data base. If transactions not supported by SQL server,; they can be disabled by SetUseTransactions(kTransactionsOff). Or user; can take responsibility to use transactions function himself.; By default only indexes for basic tables are created.; In most cases usage of indexes increase performance to data reading,; but it also can increase time of writing data to database.; There are several modes of index usage available in SetUseIndexes() method; There is MakeSelectQuery(TClass*) method, which; produces SELECT statement to get objects data of specified class.; Difference from simple statement like:; mysql> SELECT * FROM TH1I_ver1; that not only data for that class, but also data from parent classes; will be extracted from other tables and combined in single result table.; Such select query can be useful for external access to objects data. Up to now MySQL 4.1 and Oracle 9i were tested.; Some extra work is required for other SQL databases.; Ho",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/sql/src/TSQLFile.cxx:4835,ROLLBACK,ROLLBACK,4835,io/sql/src/TSQLFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/sql/src/TSQLFile.cxx,1,['ROLLBACK'],['ROLLBACK']
Deployability,"ects in collections. ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:. ~~~{.cpp}; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; ~~~. \anchor callbacks; ### Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; drawing a partially-filled histogram every time a certain number of new entries is processed, or; displaying a progress bar while the event loop runs. For example one can draw an up-to-date version of a result histogram every 100 entries like this:; ~~~{.cpp}; auto h = df.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; // event loop runs here, this final `Draw` is executed after the event loop is finished; h->Draw();; ~~~. Callbacks are registered to a ROOT::RDF::RResultPtr and must be callables that takes a reference to the result type as argument; and return nothing. RDataFrame will invoke registered callbacks passing partial action results as arguments to them; (e.g. a histogram filled with a part of the selected events). Read more on ROOT::RDF::RResultPtr::OnPartialResult() and ROOT::RDF::RResultPtr::OnPartialResultSlot(). \anchor default-branches; ### Default column lists; When constructing an RDataFrame object, it is possible to specify a **default column list** for your analysis, in the; usual form of a list of strings representing branch/column names. The default column list will be used as a fallback; whenever a list specific to the transformation/action is not present. RDataFrame will take as many of these columns as; needed, ignoring trailing extra names if present.; ~~~{.cpp}; // use ""b1"" and ""b2"" as default columns; RDataFrame d1(""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:62527,Update,Update,62527,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['Update'],['Update']
Deployability,"ecution of the program. In that respect, congruency is a; /// compile-time approximation of equivalence of values at runtime.; /// The algorithm implemented here uses a sparse formulation and it's based; /// on the ideas described in the paper:; /// ""A Sparse Algorithm for Predicated Global Value Numbering"" from; /// Karthik Gargi.; ///; /// A brief overview of the algorithm: The algorithm is essentially the same as; /// the standard RPO value numbering algorithm (a good reference is the paper; /// ""SCC based value numbering"" by L. Taylor Simpson) with one major difference:; /// The RPO algorithm proceeds, on every iteration, to process every reachable; /// block and every instruction in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algori",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:1691,update,updated,1691,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['update'],['updated']
Deployability,"ed in AP. */; /* Unchanged on exit. */; /* N - INTEGER. */; /* On entry, N specifies the order of the matrix A. */; /* N must be at least zero. */; /* Unchanged on exit. */; /* ALPHA - DOUBLE PRECISION. */; /* On entry, ALPHA specifies the scalar alpha. */; /* Unchanged on exit. */; /* X - DOUBLE PRECISION array of dimension at least */; /* ( 1 + ( n - 1 )*abs( INCX ) ). */; /* Before entry, the incremented array X must contain the n */; /* element vector x. */; /* Unchanged on exit. */; /* INCX - INTEGER. */; /* On entry, INCX specifies the increment for the Elements of */; /* X. INCX must not be zero. */; /* Unchanged on exit. */; /* AP - DOUBLE PRECISION array of DIMENSION at least */; /* ( ( n*( n + 1 ) )/2 ). */; /* Before entry with UPLO = 'U' or 'u', the array AP must */; /* contain the Upper triangular part of the symmetric matrix */; /* packed sequentially, column by column, so that AP( 1 ) */; /* contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) */; /* and a( 2, 2 ) respectively, and so on. On exit, the array */; /* AP is overwritten by the Upper triangular part of the */; /* updated matrix. */; /* Before entry with UPLO = 'L' or 'l', the array AP must */; /* contain the Lower triangular part of the symmetric matrix */; /* packed sequentially, column by column, so that AP( 1 ) */; /* contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) */; /* and a( 3, 1 ) respectively, and so on. On exit, the array */; /* AP is overwritten by the Lower triangular part of the */; /* updated matrix. */; /* Level 2 Blas routine. */; /* -- Written on 22-October-1986. */; /* Jack Dongarra, Argonne National Lab. */; /* Jeremy Du Croz, Nag Central Office. */; /* Sven Hammarling, Nag Central Office. */; /* Richard Hanson, Sandia National Labs. */; /* .. Parameters .. */; /* .. Local Scalars .. */; /* .. External Functions .. */; /* .. External Subroutines .. */; /* .. */; /* .. Executable Statements .. */; /* Test the input parameters. */; /* Parameter adjustments */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/mndspr.cxx:1786,update,updated,1786,math/minuit2/src/mndspr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/mndspr.cxx,2,['update'],['updated']
Deployability,"ed range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. ~~~; {; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5);. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01;; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }; ~~~. It is also possible to visualise data from a tree. A simple macro; showing the use of a TTreeTableInterface follows. ~~~; {; // Open a root file.; TFile *file = new TFile(""$ROOTSYS/tutorials/hsimple.root"");; // Load a tree from the file; TNtuple *ntuple = (TNtuple *)file->Get(""ntuple"");. // Create an interface; TTreeTableInterface *iface = new TTreeTableInterface(ntuple);. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface, 10, 6);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. // Set a sele",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTable.cxx:1979,Update,Update,1979,gui/gui/src/TGTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTable.cxx,1,['Update'],['Update']
Deployability,"ed. Works only with MySQL ODBC, probably with PostrSQL; /// ODBC.; /// 2. Form ""odbcd://DRIVER={MyODBC};SERVER=pcroot.cern.ch;DATABASE=test;USER=user;PASSWORD=pass;OPTION=3;PORT=3306;""; /// This is a form, which is accepted by SQLDriverConnect function of ODBC.; /// Here some other arguments can be specified, which are not included; /// in standard URL format.; /// 3. Form ""odbcn://MySpecialConfig"", where MySpecialConfig is entry,; /// defined in user DSN (user data source). Here uid and pw should be; /// always specified.; ///; /// Configuring unixODBC under Linux: http://www.unixodbc.org/odbcinst.html; /// Remarks: for variants 1 & 2 it is enough to create/configure; /// odbcinst.ini file. For variant 3 file odbc.ini should be created.; /// Path to this files can be specified in environmental variables like; /// export ODBCINI=/home/my/unixODBC/etc/odbc.ini; /// export ODBCSYSINI=/home/my/unixODBC/etc; ///; /// Configuring MySQL ODBC under Windows.; /// Installing ODBC driver for MySQL is enough to use it under Windows.; /// Afer odbcd:// variant can be used with DRIVER={MySQL ODBC 3.51 Driver};; /// To configure User DSN, go into Start menu -> Settings ->; /// Control panel -> Administrative tools-> Data Sources (ODBC).; ///; /// To install Oracle ODBC driver for Windows, one should download; /// and install either complete Oracle client (~500 MB), or so-called; /// Instant Client Basic and Instant Client ODBC (~20 MB together).; /// Some remark about Instant Client:; /// 1) Two additional DLLs are required: mfc71.dll & msver71.dll; /// They can be found either in MS VC++ 7.1 Free Toolkit or; /// download from other Internet sites; /// 2) ORACLE_HOME environment variable should be specified and point to; /// location, where Instant Client files are extracted; /// 3) Run odbc_install.exe from account with administrative rights; /// 3) In $ORACLE_HOME/network/admin/ directory appropriate *.ora files; /// like ldap.ora, sqlnet.ora, tnsnames.ora should be installed.; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/odbc/src/TODBCServer.cxx:1560,Install,Installing,1560,sql/odbc/src/TODBCServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/odbc/src/TODBCServer.cxx,1,['Install'],['Installing']
Deployability,"ee $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /// \defgroup fitsio FITS file; /// \brief Interface to FITS file.; /// \ingroup Graphics2D; ///; /// TFITS is an interface that lets you reading Flexible Image Transport System; /// (FITS) files, which are generally used in astronomy. This file format; /// was standardized 1981 and today is still widely used among professional; /// and amateur astronomers. FITS is not only an image file, but also; /// it can contain spectrums, data tables, histograms, and multidimensional; /// data. Furthermore, FITS data can be described itself by containing; /// human-readable information that let us to interpret the data within; /// the FITS file. For example, a FITS could contain a 3D data cube,; /// but an additional description would tell us that we must read it, for; /// example, as a 3-layer image.; ///; /// TFITS requires CFITSIO library to be installed on your system. It; /// is currently maintained by NASA/GSFC and can be downloaded from; /// [NASA/GSFC web site](http://fits.gsfc.nasa.gov), as well as documentation.; ///; /// Using this interface is easy and straightforward. There is only 1 class; /// called ""TFITSHDU"" which has several methods to extract data from a; /// FITS file, more specifically, from an HDU within the file. An HDU, or; /// Header Data Unit, is a chunk of data with a header containing several; /// ""keyword = value"" tokens. The header describes the structure of data; /// within the HDU. An HDU can be of two types: an ""image HDU"" or a ""table; /// HDU"". The former can be any kind of multidimensional array of real numbers,; /// by which the name ""image"" may be confusing: you can store an image, but; /// you can also store a N-dimensional data cube. On the other hand, table; /// HDUs are sets of several rows and columns (a.k.a fields) which contain; /// generic data, as strings, real or complex ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/fitsio/src/TFITS.cxx:1276,install,installed,1276,graf2d/fitsio/src/TFITS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/fitsio/src/TFITS.cxx,1,['install'],['installed']
Deployability,"eful. Futhermore, subtargets typically extend this model with processor; /// specific resources to model any hardware features that can be exploited by; /// scheduling heuristics and aren't sufficiently represented in the abstract.; ///; /// The abstract pipeline is built around the notion of an ""issue point"". This; /// is merely a reference point for counting machine cycles. The physical; /// machine will have pipeline stages that delay execution. The scheduler does; /// not model those delays because they are irrelevant as long as they are; /// consistent. Inaccuracies arise when instructions have different execution; /// delays relative to each other, in addition to their intrinsic latency. Those; /// special cases can be handled by TableGen constructs such as, ReadAdvance,; /// which reduces latency when reading data, and ReleaseAtCycles, which consumes; /// a processor resource when writing data for a number of abstract; /// cycles.; ///; /// TODO: One tool currently missing is the ability to add a delay to; /// ReleaseAtCycles. That would be easy to add and would likely cover all cases; /// currently handled by the legacy itinerary tables.; ///; /// A note on out-of-order execution and, more generally, instruction; /// buffers. Part of the CPU pipeline is always in-order. The issue point, which; /// is the point of reference for counting cycles, only makes sense as an; /// in-order part of the pipeline. Other parts of the pipeline are sometimes; /// falling behind and sometimes catching up. It's only interesting to model; /// those other, decoupled parts of the pipeline if they may be predictably; /// resource constrained in a way that the scheduler can exploit.; ///; /// The LLVM machine model distinguishes between in-order constraints and; /// out-of-order constraints so that the target's scheduling strategy can apply; /// appropriate heuristics. For a well-balanced CPU pipeline, out-of-order; /// resources would not typically be treated as a hard scheduling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:2065,Release,ReleaseAtCycles,2065,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['Release'],['ReleaseAtCycles']
Deployability,"el to changes in TUnfold; //; // History:; // Version 17.8, relaxed DTD definition; // Version 17.7, in parallel to changes in TUnfold; // Version 17.6, with updated doxygen comments; // Version 17.5, in parallel to changes in TUnfold; // Version 17.4, in parallel to changes in TUnfoldBinning; // Version 17.3, support for the ""repeat"" attribute for element Bin; // Version 17.2, initial version, numbered in parallel to TUnfold; /** \class TUnfoldBinningXML; XML interfate to binning schemes, for use with the unfolding algorithm; TUnfoldDensity. Binning schemes are used to map analysis bins on a single histogram; axis and back. The analysis bins may include unconnected bins (e.g; nuisances for background normalisation) or various multidimensional; histograms (signal bins, differential background normalisation bins, etc).; <br/>; If you use this software, please consider the following citation; <br/>; <b>S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]</b>; <br/>; Detailed documentation and updates are available on; http://www.desy.de/~sschmitt. Please consult the documentation of the class TUnfoldBinning about how to use; binning schemes. This class provides methods to read and write binning; schemes in the XML language. There is also a method which writes out; a dtd file for validation.; <h3>Example XML code</h3>; The example below encodes two binning schemes, <em>detector</em> and; <em>generator</em>. The detecor scheme consists of a single,; three-dimensional distribution (pt,eta,discriminator). The generator; scheme consists of two two-dimensional distributions, signal and background.; <pre>; <?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>; <!DOCTYPE TUnfoldBinning SYSTEM ""tunfoldbinning.dtd"">; <TUnfoldBinning>; <BinningNode name=""detector"" firstbin=""1"" factor=""1"">; <BinningNode name=""detectordistribution"" firstbin=""1"" factor=""1"">; <Axis name=""pt"" lowEdge=""3.5"">; <Bin repeat=""3"" width=""0.5"" />; <Bin repeat=""3"" width=""1"" />; <Bin width=""2"" />; <Bin width=""3",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldBinningXML.cxx:1073,update,updates,1073,hist/unfold/src/TUnfoldBinningXML.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldBinningXML.cxx,1,['update'],['updates']
Deployability,"elected peaks, peaks with; /// amplitude less than threshold*highest_peak/100; /// are ignored, see manual.; /// - backgroundRemove: logical variable, set if the removal of; /// background before deconvolution is desired.; /// - deconIterations-number of iterations in deconvolution operation.; /// - markov: logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow: averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method).; ///; /// ### Peaks searching:; ///; /// The goal of this function is to identify automatically the peaks in spectrum; /// with the presence of the continuous background and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification are:; ///; /// - non-sensitivity to noise, i.e., only statistically; /// relevant peaks should be identified.; /// - non-sensitivity of the algorithm to continuous; /// background.; /// - ability to identify peaks close to the edges of the; /// spectrum region. Usually peak finders fail to detect them.; /// - resolution, decomposition of Double_tts and multiplets.; /// The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma.; ///; /// \image html TSpectrum_Searching1.jpg Fig. 27 An example of one-dimensional synthetic spectrum with found peaks denoted by markers.; ///; /// #### References:; ///; /// 1. M.A. Mariscotti: A method for identification of peaks in the presence of; /// background and its application to spectrum analysis. NIM 50 (1967),; /// 309-320.; /// 2. M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky,; /// I. Turzo.:Identification of peaks in; /// multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; /// 3. Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM; /// A 376 (1996), 451.; ///; /// Examples of peak sear",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:1994,continuous,continuous,1994,hist/spectrum/src/TSpectrum.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx,1,['continuous'],['continuous']
Deployability,"en machine-independent; /// abstract property corresponds to a specific physical property across all; /// subtargets can't be done. Nonetheless, the abstract model is; /// useful. Futhermore, subtargets typically extend this model with processor; /// specific resources to model any hardware features that can be exploited by; /// scheduling heuristics and aren't sufficiently represented in the abstract.; ///; /// The abstract pipeline is built around the notion of an ""issue point"". This; /// is merely a reference point for counting machine cycles. The physical; /// machine will have pipeline stages that delay execution. The scheduler does; /// not model those delays because they are irrelevant as long as they are; /// consistent. Inaccuracies arise when instructions have different execution; /// delays relative to each other, in addition to their intrinsic latency. Those; /// special cases can be handled by TableGen constructs such as, ReadAdvance,; /// which reduces latency when reading data, and ReleaseAtCycles, which consumes; /// a processor resource when writing data for a number of abstract; /// cycles.; ///; /// TODO: One tool currently missing is the ability to add a delay to; /// ReleaseAtCycles. That would be easy to add and would likely cover all cases; /// currently handled by the legacy itinerary tables.; ///; /// A note on out-of-order execution and, more generally, instruction; /// buffers. Part of the CPU pipeline is always in-order. The issue point, which; /// is the point of reference for counting cycles, only makes sense as an; /// in-order part of the pipeline. Other parts of the pipeline are sometimes; /// falling behind and sometimes catching up. It's only interesting to model; /// those other, decoupled parts of the pipeline if they may be predictably; /// resource constrained in a way that the scheduler can exploit.; ///; /// The LLVM machine model distinguishes between in-order constraints and; /// out-of-order constraints so that the target's",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:1870,Release,ReleaseAtCycles,1870,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['Release'],['ReleaseAtCycles']
Deployability,"enough bytes to decode the next; code, and no more. Some states loop until they get enough input, making sure that enough; state information is maintained to continue the loop where it left off; if NEEDBITS() returns in the loop. For example, want, need, and keep; would all have to actually be part of the saved state in case NEEDBITS(); returns:. case STATEw:; while (want < need) {; NEEDBITS(n);; keep[want++] = BITS(n);; DROPBITS(n);; }; state = STATEx;; case STATEx:. As shown above, if the next state is also the next case, then the break; is omitted. A state may also return if there is not enough output space available to; complete that state. Those states are copying stored data, writing a; literal byte, and copying a matching string. When returning, a ""goto inf_leave"" is used to update the total counters,; update the check value, and determine whether any progress has been made; during that inflate() call in order to return the proper return code.; Progress is defined as a change in either strm->avail_in or strm->avail_out.; When there is a window, goto inf_leave will update the window with the last; output written. If a goto inf_leave occurs in the middle of decompression; and there is no window currently, goto inf_leave will create one and copy; output to the window for the next call of inflate(). In this implementation, the flush parameter of inflate() only affects the; return code (per zlib.h). inflate() always writes as much as possible to; strm->next_out, given the space available and the provided input--the effect; documented in zlib.h of Z_SYNC_FLUSH. Furthermore, inflate() always defers; the allocation of and copying into a sliding window until necessary, which; provides the effect documented in zlib.h for Z_FINISH when the entire input; stream available. So the only thing the flush parameter actually does is:; when flush is set to Z_FINISH, inflate() cannot return Z_OK. Instead it; will return Z_BUF_ERROR if it has not reached the end of the stream.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c:2578,update,update,2578,builtins/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c,2,['update'],['update']
Deployability,"enu/Import from.../Canvas or; the corresponding Tool bar button. A new style will be created in the; ROOT session and will become the selected one. This style is a clone; of the gStyle with modified values as they are set in the currently; selected canvas. You can import a style from any canvas and apply it; later on some objects. Export a style (in a C++ macro file):; To store a style longer than for the current ROOT session you can; save it in a C++ macro file. This can be done via the menu or the; tool bar button. There is a naming convention for the style macros:; the name must be 'Style_*.C', where * can be replaced by anything; you want. Delete a style:; The selected style can be deleted from the list when you use the; Style menu/Delete or the corresponding tool bar button. The selected; style is removed from the list of all available styles for the; current ROOT session. WARRNING: it will be lost if you didn't saved; it in a C++ macro file before its deletion. Also, you cannot delete; the selected style if it is set to gStyle. A message 'Can not delete; gStyle' will be displayed on the CINT prompt. Editor's buttons:; Open / close the style editor:; The button 'Edit >>' opens the style editor and its label changes to; 'Close <<'. For all details of what can be changed and how please see; the provided Help. Reset a style (to a previously saved state):; When the editor is opened, the 'Reset' button allows you to reset; the values of the selected style for editing. Doing that you cancel; all changes made since the last time you saved that style in a macro.; If the selected style is one of the five ROOT styles (Plain, Bold,; Video, Pub or Default), it will be recreated. Update the preview:; The button 'Update Preview' is available when a preview is shown and; the run time option is not selected. This button allows you to; refresh the preview any time you want to see how the style you edit; looks like. Help button:; Provides a help of the currently selected tab. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx:4267,Update,Update,4267,gui/ged/src/TStyleManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx,2,['Update'],['Update']
Deployability,"eous fits with components with large likelihood values.; * <tr><td> **bin** <td> Offset likelihood bin-by-bin with a template histogram model based on the obersved data.; * This results in per-bin values that are all in the same order of magnitude, which reduces precision loss in the sum,; * which can drastically improve numeric stability.; * Furthermore, \f$2\cdot \text{NLL}\f$ defined like this is approximately chi-square distributed, allowing for goodness-of-fit tests.; * </table>; * <tr><td> `IntegrateBins(double precision)` <td> In binned fits, integrate the PDF over the bins instead of using the probability density at the bin centre.; * This can reduce the bias observed when fitting functions with high curvature to binned data.; * - precision > 0: Activate bin integration everywhere. Use precision between 0.01 and 1.E-6, depending on binning.; * Note that a low precision such as 0.01 might yield identical results to 1.E-4, since the integrator might reach 1.E-4 already in its first; * integration step. If lower precision is desired (more speed), a RooBinSamplingPdf has to be created manually, and its integrator; * has to be manipulated directly.; * - precision = 0: Activate bin integration only for continuous PDFs fit to a RooDataHist.; * - precision < 0: Deactivate.; * \see RooBinSamplingPdf; * <tr><td> `ModularL(bool flag)` <td> Enable or disable modular likelihoods, which will become the default in a future release.; * This does not change any user-facing code, but only enables a different likelihood class in the back-end. Note that this; * should be set to true for parallel minimization of likelihoods!; * Note that it is currently not recommended to use Modular likelihoods without any parallelization enabled in the minimization, since; * some features such as offsetting might not yet work in this case.; * </table>; */; /** @brief Protected implementation of the NLL creation routine.; *; * This virtual function can be overridden in case you want to change th",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:9535,integrat,integration,9535,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['integrat'],['integration']
Deployability,"er-roman;"">; <li><a href=""#usage"">Usage</a></li>; <li><a href=""#conf"">Configuration</a>; <ol><li><a href=""#conf:input"">Input files</a></li>; <li><a href=""#conf:output"">Output directory</a></li>; <li><a href=""#conf:liblink"">Linking other documentation</a></li>; <li><a href=""#conf:classdoc"">Recognizing class documentation</a></li>; <li><a href=""#conf:tags"">Author, copyright, etc.</a></li>; <li><a href=""#conf:header"">Header and footer</a></li>; <li><a href=""#conf:search"">Links to searches, home page, ViewVC</a></li>; <li><a href=""#conf:charset"">HTML Charset</a></li>; </ol></li>; <li><a href=""#syntax"">Documentation syntax</a>; <ol><li><a href=""#syntax:classdesc"">Class description</a></li>; <li><a href=""#syntax:classidx"">Class index</a></li>; <li><a href=""#syntax:meth"">Method documentation</a></li>; <li><a href=""#syntax:datamem"">Data member documentation</a></li>; </ol></li>; <li><a href=""#directive"">Documentation directives</a>; <ol><li><a href=""#directive:html""><tt>BEGIN<!-- -->_HTML</tt> <tt>END<!-- -->_HTML</tt>: include 'raw' HTML</a></li>; <li><a href=""#directive:macro""><tt>BEGIN<!-- -->_MACRO</tt> <tt>END<!-- -->_MACRO</tt>: include a picture generated by a macro</a></li>; <li><a href=""#directive:latex""><tt>BEGIN<!-- -->_LATEX</tt> <tt>END<!-- -->_LATEX</tt>: include a latex picture</a></li>; </ol></li>; <li><a href=""#index"">Product and module index</a></li>; <li><a href=""#aux"">Auxiliary files: style sheet, JavaScript, help page</a></li>; <li><a href=""#charts"">Class Charts</a></li>; <li><a href=""#confvar"">Configuration variables</a></li>; <li><a href=""#how"">Behind the scenes</a></li>; </ol>. <h3><a name=""usage"">I. Usage</a></h3>; These are typical things people do with THtml:; <pre>; root[] <a href=""http://root.cern.ch/root/html/THtml.html"">THtml</a> html; // create a <a href=""http://root.cern.ch/root/html/THtml.html"">THtml</a> object; root[] html.LoadAllLibs(); // Load all rootmap'ed libraries; root[] html.MakeAll(); // generate documentation for all changed clas",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx:2683,Configurat,Configuration,2683,html/src/THtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx,1,['Configurat'],['Configuration']
Deployability,"erprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3126,update,update,3126,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['update'],['update']
Deployability,"ersity. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; //////////////////////////////////////////////////////////////////////////////; /** \class RooAbsPdf; \ingroup Roofitcore; \brief Abstract interface for all probability density functions. ## RooAbsPdf, the base class of all PDFs. RooAbsPdf is the base class for all probability density; functions (PDFs). The class provides hybrid analytical/numerical; normalization for its implementations, error tracing, and a Monte Carlo; generator interface. ### A Minimal PDF Implementation. A minimal implementation of a PDF class derived from RooAbsPdf; should override the `evaluate()` function. This function should; return the PDF's value (which does not need to be normalised). #### Normalization/Integration. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex composite PDF; if any of its variables are functions instead of variables. In; such cases, the normalization of the composite PDF may not simply be; integral over the dependents of the top-level PDF: these are; functions with potentially non-trivial Jacobian terms themselves.; \note Therefore, no explicit attempt should be made to normalize the; function output in evaluate(). In particular, normalisation constants; can be omitted to speed up the function evaluations, and included later; in the integration of the PDF (see below), which is rarely called in; comparison to the `evaluate()` function. In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters, and what variables are dependents (wh",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:1387,Integrat,Integration,1387,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['Integrat'],['Integration']
Deployability,"es are retained in all copies and that this; notice is included verbatim in any distributions. No written agreement,; license, or royalty fee is required for any of the authorized uses.; Modifications to this software may be copyrighted by their authors; and need not follow the licensing terms described here, provided that; the new terms are clearly indicated on the first page of each file where; they apply. IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY; FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES; ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY; DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE; POSSIBILITY OF SUCH DAMAGE. THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,; INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT. THIS SOFTWARE; IS PROVIDED ON AN ""AS IS"" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE; NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR; MODIFICATIONS. GOVERNMENT USE: If you are acquiring this software on behalf of the; U.S. government, the Government shall have only ""Restricted Rights""; in the software and related documentation as defined in the Federal ; Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2). If you; are acquiring the software on behalf of the Department of Defense, the; software shall be classified as ""Commercial Computer Software"" and the; Government shall have only ""Restricted Rights"" as defined in Clause; 252.227-7013 (c) (1) of DFARs. Notwithstanding the foregoing, the; authors grant the U.S. Government and others acting in its behalf; permission to use and distribute the software in accordance with the; terms specified in this license.; */; /*; *----------------------------------------------------------------------; *; * XAllocColor --; *; *	Find the closest available color to the specified XColor.; *; * Results:; *	U",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c:1704,UPDATE,UPDATES,1704,graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c,1,['UPDATE'],['UPDATES']
Deployability,"es.; * ZSTD_CStream objects can be reused multiple times on consecutive compression operations.; * It is recommended to re-use ZSTD_CStream since it will play nicer with system's memory, by re-using already allocated memory.; *; * For parallel execution, use one separate ZSTD_CStream per thread.; *; * note : since v1.3.0, ZSTD_CStream and ZSTD_CCtx are the same thing.; *; * Parameters are sticky : when starting a new compression on the same context,; * it will re-use the same sticky parameters as previous compression session.; * When in doubt, it's recommended to fully initialize the context before usage.; * Use ZSTD_CCtx_reset() to reset the context and ZSTD_CCtx_setParameter(),; * ZSTD_CCtx_setPledgedSrcSize(), or ZSTD_CCtx_loadDictionary() and friends to; * set more specific parameters, the pledged source size, or load a dictionary.; *; * Use ZSTD_compressStream2() with ZSTD_e_continue as many times as necessary to; * consume input stream. The function will automatically update both `pos`; * fields within `input` and `output`.; * Note that the function may not consume the entire input, for example, because; * the output buffer is already full, in which case `input.pos < input.size`.; * The caller must check if input has been entirely consumed.; * If not, the caller must make some room to receive more compressed data,; * and then present again remaining input data.; * note: ZSTD_e_continue is guaranteed to make some forward progress when called,; * but doesn't guarantee maximal forward progress. This is especially relevant; * when compressing with multiple threads. The call won't block if it can; * consume some input, but if it can't it will wait for some, but not all,; * output to be flushed.; * @return : provides a minimum amount of data remaining to be flushed from internal buffers; * or an error code, which can be tested using ZSTD_isError().; *; * At any moment, it's possible to flush whatever data might remain stuck within internal buffer,; * using ZSTD_compr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:1243,update,update,1243,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['update'],['update']
Deployability,"essesMap.; ///; /// The overall linking process looks like this:; ///; /// parrallel_for_each(ObjectFile) {; /// for_each (Compile Unit) {; /// 1. Load Clang modules.; /// }; ///; /// parrallel_for_each(Compile Unit) {; /// 1. Load input DWARF for Compile Unit.; /// 2. Report warnings for Clang modules.; /// 3. Analyze live DIEs and type names(if ODR deduplication is requested).; /// 4. Clone DIEs(Generate output DIEs and resulting DWARF tables).; /// The result is in an OutDebugInfoBytes, which is an ELF file; /// containing DWARF tables corresponding to the current compile unit.; /// 5. Cleanup Input and Output DIEs.; /// }; ///; /// Deallocate loaded Object file.; /// }; ///; /// if (ODR deduplication is requested); /// Generate an artificial compilation unit (""Type Table"": used to partially; /// generate DIEs at the clone stage).; ///; /// for_each (ObjectFile) {; /// for_each (Compile Unit) {; /// 1. Set offsets to Compile Units DWARF tables.; /// 2. Sort offsets/attributes/patches to have a predictable result.; /// 3. Patch size/offsets fields.; /// 4. Generate index tables.; /// 5. Move DWARF tables of compile units into the resulting file.; /// }; /// }; ///; /// Every compile unit is processed separately, visited only once; /// (except case inter-CU references exist), and used data is freed; /// after the compile unit is processed. The resulting file is glued together; /// from the generated debug tables which correspond to separate compile units.; ///; /// Handling inter-CU references: inter-CU references are hard to process; /// using only one pass. f.e. if CU1 references CU100 and CU100 references; /// CU1, we could not finish handling of CU1 until we finished CU100.; /// Thus we either need to load all CUs into the memory, either load CUs several; /// times. This implementation loads inter-connected CU into memory at the first; /// pass and processes them at the second pass.; ///; /// ODR deduplication: Artificial compilation unit will be constructed to",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h:1804,patch,patches,1804,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h,1,['patch'],['patches']
Deployability,"et limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); /// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:4357,configurat,configuration,4357,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,2,"['Configurat', 'configurat']","['Configuration', 'configuration']"
Deployability,"eter - the name of undo method; Since redo,undo methods are the same, undo name can be omitted, e.g.; ~~~ {.cpp}; TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");; ~~~; For objects derived from TObject class name can be omitted, e.g.; ~~~ {.cpp}; TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");; ~~~. 2. Setting undo, redo parameters.; ~~~ {.cpp}; Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);; ~~~; 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values; Since the number of undo,redo parameters is the same one can use; ~~~ {.cpp}; com->SetArgs(1, new_color, old_color);; ~~~. 3. Undo, redo method execution; ~~~ {.cpp}; com->Redo(); // execute redo method; com->Undo(); // execute undo method; ~~~. 4. Merged commands; It possible to group several commands together so an end user; can undo and redo them with one command.; ~~~ {.cpp}; TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);; ~~~. 5. Macro commands; ""Merging"" allows to create macro commands, e.g.; ~~~ {.cpp}; TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);; ...; ~~~; During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager.; TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used.; ~~~ {.cpp}; TQUndoManager *history = new TQUndoManager();; history->Add(com);; ~~~; TQUndoManager::Add automatically invokes execution of command's Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQCommand.cxx:2467,update,update,2467,core/base/src/TQCommand.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQCommand.cxx,2,['update'],['update']
Deployability,"every histogram cell. Unfortunately,; * it needs a work array to hold the best-distance-so-far for each histogram; * cell (because the inner loop has to be over cells, not colormap entries).; * The work array elements have to be INT32s, so the work array would need; * 256Kb at our recommended precision. This is not feasible in DOS machines.; *; * To get around these problems, we apply Thomas' method to compute the; * nearest colors for only the cells within a small subbox of the histogram.; * The work array need be only as big as the subbox, so the memory usage; * problem is solved. Furthermore, we need not fill subboxes that are never; * referenced in pass2; many images use only part of the color gamut, so a; * fair amount of work is saved. An additional advantage of this; * approach is that we can apply Heckbert's locality criterion to quickly; * eliminate colormap entries that are far away from the subbox; typically; * three-fourths of the colormap entries are rejected by Heckbert's criterion,; * and we need not compute their distances to individual cells in the subbox.; * The speed of this approach is heavily influenced by the subbox size: too; * small means too much overhead, too big loses because Heckbert's criterion; * can't eliminate as many colormap entries. Empirically the best subbox; * size seems to be about 1/512th of the histogram (1/8th in each direction).; *; * Thomas' article also describes a refined method which is asymptotically; * faster than the brute-force method, but it is also far more complex and; * cannot efficiently be applied to small subboxes. It is therefore not; * useful for programs intended to be portable to DOS machines. On machines; * with plenty of memory, filling the whole histogram in one shot with Thomas'; * refined method might be faster than the present code --- but then again,; * it might not be any faster, and it's certainly more complicated.; */; /* log2(histogram cells in update box) for each axis; this can be adjusted */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:3478,update,update,3478,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['update'],['update']
Deployability,"f the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates under only make the traversal order remain valid.; ///; /// The entire analysis must be re-computed if full interprocedural; /// optimizations run at any point. For example, globalopt completely; /// invalidates the information in this analysis.; ///; /// FIXME: This class is named LazyCallGraph in a lame attempt to distinguish; /// it from the existing CallGraph. At some point, it is expected that this; /// will be the only call graph and it will be renamed accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:2205,update,updates,2205,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['update'],['updates']
Deployability,"ffrey95.gif ""Bayesian with Jeffrey Prior"". The average (over all possible true efficiencies) coverage probability for; different number of total events is shown in the next picture. \image html av_cov.png ""Average Coverage"". \anchor EFF05; ## V. Merging and combining TEfficiency objects; In many applications, the efficiency should be calculated for an inhomogeneous; sample in the sense that it contains events with different weights. In order; to be able to determine the correct overall efficiency, it is necessary to; use for each subsample (= all events with the same weight) a different; TEfficiency object. After finishing your analysis you can then construct the; overall efficiency with its uncertainty. This procedure has the advantage that you can change the weight of one; subsample easily without rerunning the whole analysis. On the other hand, more; effort is needed to handle several TEfficiency objects instead of one; histogram. In the case of many different or even continuously distributed; weights, this approach becomes cumbersome. One possibility to overcome this; problem is the usage of binned weights. \anchor EFF05a; ### Example; In particle physics weights arises from the fact that you want to; normalise your results to a certain reference value. A very common formula for; calculating weights is. \f{eqnarray*}{; w &=& \frac{\sigma L}{N_{gen} \epsilon_{trig}} \\; &-& \sigma ...\ cross\ section \\; &-& L ...\ luminosity \\; &-& N_{gen}\ ... number\ of\ generated\ events \\; &-& \epsilon_{trig}\ ...\ (known)\ trigger\ efficiency \\; \f}. The reason for different weights can therefore be:; - different processes; - other integrated luminosity; - varying trigger efficiency; - different sample sizes; - ...; - or even combination of them. Depending on the actual meaning of different weights in your case, you; should either merge or combine them to get the overall efficiency. \anchor EFF051; ### V.1 When should I use merging?; If the weights are artificial and do n",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:15991,continuous,continuously,15991,hist/hist/src/TEfficiency.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx,1,['continuous'],['continuously']
Deployability,"ficient(power) and plot the data,; the known function and the fitted function.; \code{.cpp}. TCanvas *c1 = new TCanvas(""c1"",""Curve Fit"",700,500);; c1->SetGrid();. // draw a frame for multiples graphs; TMultiGraph *mg = new TMultiGraph();. // create the first graph (points with gaussian noise); const Int_t n = 24;; Double_t x[n] ;; Double_t y[n] ;; //Generate points along a X^3 with noise; TRandom rg;; rg.SetSeed(520);; for (Int_t i = 0; i < n; i++) {; x[i] = rg.Uniform(0, 1);; y[i] = TMath::Power(x[i], 3) + rg.Gaus() * 0.06;; }. TGraph *gr1 = new TGraph(n,x,y);; gr1->SetMarkerColor(kBlue);; gr1->SetMarkerStyle(8);; gr1->SetMarkerSize(1);; mg->Add(gr1);. // create second graph; TF1 *f_known=new TF1(""f_known"",""pow(x,3)"",0,1);; TGraph *gr2 = new TGraph(f_known);; gr2->SetMarkerColor(kRed);; gr2->SetMarkerStyle(8);; gr2->SetMarkerSize(1);; mg->Add(gr2);. //passing x and y values to R for fitting; ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; r[""x""]<<TVectorD(n, x);; r[""y""]<<TVectorD(n, y);; //creating a R data frame; r<<""ds<-data.frame(x=x,y=y)"";; //fitting x and y to X^power using Nonlinear Least Squares; r<<""m <- nls(y ~ I(x^power),data = ds, start = list(power = 1),trace = T)"";; //getting the fitted value (power); Double_t power;; r[""summary(m)$coefficients[1]""]>>power;. TF1 *f_fitted=new TF1(""f_fitted"",""pow(x,[0])"",0,1);; f_fitted->SetParameter(0,power);; //plotting the fitted function; TGraph *gr3 = new TGraph(f_fitted);; gr3->SetMarkerColor(kGreen);; gr3->SetMarkerStyle(8);; gr3->SetMarkerSize(1);. mg->Add(gr3);; mg->Draw(""ap"");. //displaying basic results; TPaveText *pt = new TPaveText(0.1,0.6,0.5,0.9,""brNDC"");; pt->SetFillColor(18);; pt->SetTextAlign(12);; pt->AddText(""Fitting x^power "");; pt->AddText("" \""Blue\"" Points with gaussian noise to be fitted"");; pt->AddText("" \""Red\"" Known function x^3"");; TString fmsg;; fmsg.Form("" \""Green\"" Fitted function with power=%.4lf"",power);; pt->AddText(fmsg);; pt->Draw();; c1->Update();; \endcode; @ingroup R; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/inc/TRInterface.h:3278,Update,Update,3278,bindings/r/inc/TRInterface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/inc/TRInterface.h,1,['Update'],['Update']
Deployability,"fix with GetProbabilityMatrix; // Version 17.1, bug fixes in GetFoldedOutput, GetOutput; // Version 17.0, option to specify an error matrix with SetInput(), new ScanRho() method; // Version 16.2, in parallel to bug-fix in TUnfoldSys; // Version 16.1, fix bug with error matrix in case kEConstraintArea is used; // Version 16.0, fix calculation of global correlations, improved error messages; // Version 15, simplified L-curve scan, new tau definition, new error calc., area preservation; // Version 14, with changes in TUnfoldSys.cxx; // Version 13, new methods for derived classes and small bug fix; // Version 12, report singular matrices; // Version 11, reduce the amount of printout; // Version 10, more correct definition of the L curve, update references; // Version 9, faster matrix inversion and skip edge points for L-curve scan; // Version 8, replace all TMatrixSparse matrix operations by private code; // Version 7, fix problem with TMatrixDSparse,TMatrixD multiplication; // Version 6, replace class XY by std::pair; // Version 5, replace run-time dynamic arrays by new and delete[]; // Version 4, fix new bug from V3 with initial regularisation condition; // Version 3, fix bug with initial regularisation condition; // Version 2, with improved ScanLcurve() algorithm; // Version 1, added ScanLcurve() method; // Version 0, stable version of basic unfolding algorithm; /** \class TUnfold; An algorithm to unfold distributions from detector to truth level. TUnfold is used to decompose a measurement y into several sources x,; given the measurement uncertainties and a matrix of migrations A.; The method can be applied to a large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Beyond such a simple template fit,; TUnfold has an adjustable regularisation term and also supports an; optional constraint on the total number of events. <b>For most applications, it is better to use the derived class; TUnfoldDensity instead ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx:1360,update,update,1360,hist/unfold/src/TUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx,1,['update'],['update']
Deployability,"follow:; /// ~~~ {.cpp}; /// [if (cutfilename())] htemp->Fill(macrofilename());; /// ~~~; /// ""option"" can be used select some of the optional features during; /// the code generation. The possible options are:; ///; /// - nohist : indicates that the generated ProcessFill should not fill the histogram.; ///; /// 'maxUnrolling' controls how deep in the class hierarchy does the; /// system 'unroll' classes that are not split. Unrolling a class; /// allows direct access to its data members (this emulates the behavior; /// of TTreeFormula).; ///; /// The main features of this skeleton are:; ///; /// * on-demand loading of branches; /// * ability to use the 'branchname' as if it was a data member; /// * protection against array out-of-bounds errors; /// * ability to use the branch data as an object (when the user code is available); ///; /// For example with Event.root, if; /// ~~~ {.cpp}; /// Double_t somePx = fTracks.fPx[2];; /// ~~~; /// is executed by one of the method of the skeleton,; /// somePx will updated with the current value of fPx of the 3rd track.; ///; /// Both macrofilename and the optional cutfilename are expected to be; /// the name of source files which contain at least a free standing; /// function with the signature:; /// ~~~ {.cpp}; /// x_t macrofilename(); // i.e function with the same name as the file; /// ~~~; /// and; /// ~~~ {.cpp}; /// y_t cutfilename(); // i.e function with the same name as the file; /// ~~~; /// x_t and y_t needs to be types that can convert respectively to a double; /// and a bool (because the skeleton uses:; ///; /// if (cutfilename()) htemp->Fill(macrofilename());; ///; /// These two functions are run in a context such that the branch names are; /// available as local variables of the correct (read-only) type.; ///; /// Note that if you use the same 'variable' twice, it is more efficient; /// to 'cache' the value. For example:; /// ~~~ {.cpp}; /// Int_t n = fEventNumber; // Read fEventNumber; /// if (n<10 || n>10) { ... }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1920,update,updated,1920,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['update'],['updated']
Deployability,"follow:; /// ~~~{.cpp}; /// [if (cutfilename())] htemp->Fill(macrofilename());; /// ~~~; /// ""option"" can be used select some of the optional features during; /// the code generation. The possible options are:; /// - nohist : indicates that the generated ProcessFill should not; /// fill the histogram.; ///; /// 'maxUnrolling' controls how deep in the class hierarchy does the; /// system 'unroll' class that are not split. 'unrolling' a class; /// will allow direct access to its data members a class (this; /// emulates the behavior of TTreeFormula).; ///; /// The main features of this skeleton are:; ///; /// * on-demand loading of branches; /// * ability to use the 'branchname' as if it was a data member; /// * protection against array out-of-bound; /// * ability to use the branch data as object (when the user code is available); ///; /// For example with Event.root, if; /// ~~~{.cpp}; /// Double_t somepx = fTracks.fPx[2];; /// ~~~; /// is executed by one of the method of the skeleton,; /// somepx will be updated with the current value of fPx of the 3rd track.; ///; /// Both macrofilename and the optional cutfilename are expected to be; /// the name of source files which contain at least a free standing; /// function with the signature:; /// ~~~{.cpp}; /// x_t macrofilename(); // i.e function with the same name as the file; /// ~~~; /// and; /// ~~~{.cpp}; /// y_t cutfilename(); // i.e function with the same name as the file; /// ~~~; /// x_t and y_t needs to be types that can convert respectively to a double; /// and a bool (because the skeleton uses:; /// ~~~{.cpp}; /// if (cutfilename()) htemp->Fill(macrofilename());; /// ~~~; /// This 2 functions are run in a context such that the branch names are; /// available as local variables of the correct (read-only) type.; ///; /// Note that if you use the same 'variable' twice, it is more efficient; /// to 'cache' the value. For example; /// ~~~{.cpp}; /// Int_t n = fEventNumber; // Read fEventNumber; /// if (n<10 || n>10)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:2096,update,updated,2096,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,1,['update'],['updated']
Deployability,"for the subclasses but also to structure their; /// implementation and simplify the use of other abstract attributes in-flight.; ///; /// To allow easy creation of new attributes, most methods have default; /// implementations. The ones that do not are generally straight forward, except; /// `AbstractAttribute::updateImpl` which is the location of most reasoning; /// associated with the abstract attribute. The update is invoked by the; /// Attributor in case the situation used to justify the current optimistic; /// state might have changed. The Attributor determines this automatically; /// by monitoring the `Attributor::getAAFor` calls made by abstract attributes.; ///; /// The `updateImpl` method should inspect the IR and other abstract attributes; /// in-flight to justify the best possible (=optimistic) state. The actual; /// implementation is, similar to the underlying abstract state encoding, not; /// exposed. In the most common case, the `updateImpl` will go through a list of; /// reasons why its optimistic state is valid given the current information. If; /// any combination of them holds and is sufficient to justify the current; /// optimistic state, the method shall return UNCHAGED. If not, the optimistic; /// state is adjusted to the situation and the method shall return CHANGED.; ///; /// If the manifestation of the ""concrete attribute"" deduced by the subclass; /// differs from the ""default"" behavior, which is a (set of) LLVM-IR; /// attribute(s) for an argument, call site argument, function return value, or; /// function, the `AbstractAttribute::manifest` method should be overloaded.; ///; /// NOTE: If the state obtained via getState() is INVALID, thus if; /// AbstractAttribute::getState().isValidState() returns false, no; /// information provided by the methods of this class should be used.; /// NOTE: The Attributor currently has certain limitations to what we can do.; /// As a general rule of thumb, ""concrete"" abstract attributes should *for; /// now* o",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:1214,update,updateImpl,1214,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['update'],['updateImpl']
Deployability,"ford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooNumConvolution.cxx; \class RooNumConvolution; \ingroup Roofitcore. Numeric 1-dimensional convolution operator PDF. This class can convolve any PDF; with any other PDF; This class should not be used blindly as numeric convolution is computing; intensive and prone to stability fitting problems. If an analytic convolution; can be calculated, you should use that or implement it if not available.; RooNumConvolution implements reasonable defaults that should convolve most; functions reasonably well, but results strongly depend on the shape of your; input PDFS so always check your result. The default integration engine for the numeric convolution is the; adaptive Gauss-Kronrod method, which empirically seems the most robust; for this task. You can override the convolution integration settings via; the RooNumIntConfig object reference returned by the convIntConfig() member; function; By default the numeric convolution is integrated from -infinity to; +infinity through a <pre>x -> 1/x</pre> coordinate transformation of the; tails. For convolution with a very small bandwidth it may be; advantageous (for both CPU consumption and stability) if the; integration domain is limited to a finite range. The function; setConvolutionWindow(mean,width,scale) allows to set a sliding; window around the x value to be calculated taking a RooAbsReal; expression for an offset and a width to be taken around the x; value. These input expression can be RooFormulaVars or other; function objects although the 3d 'scale' argument 'scale'; multiplies the width RooAbsReal expression given in the 2nd; argument, allowing for an appropriate window definition for most; cases wi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx:1310,integrat,integration,1310,roofit/roofitcore/src/RooNumConvolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx,1,['integrat'],['integration']
Deployability,"formance, accuracy, and effort is; * with the user.; *; * Some files in the ""contrib"" directory and some configure-generated; * files that are distributed with libpng have other copyright owners, and; * are released under other open source licenses.; *; * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are; * Copyright (c) 1998-2000 Glenn Randers-Pehrson, are derived from; * libpng-0.96, and are distributed according to the same disclaimer and; * license as libpng-0.96, with the following individuals added to the; * list of Contributing Authors:; *; * Tom Lane; * Glenn Randers-Pehrson; * Willem van Schaik; *; * libpng versions 0.89, June 1996, through 0.96, May 1997, are; * Copyright (c) 1996-1997 Andreas Dilger, are derived from libpng-0.88,; * and are distributed according to the same disclaimer and license as; * libpng-0.88, with the following individuals added to the list of; * Contributing Authors:; *; * John Bowler; * Kevin Bracey; * Sam Bushell; * Magnus Holmgren; * Greg Roelofs; * Tom Tanner; *; * Some files in the ""scripts"" directory have other copyright owners,; * but are released under this license.; *; * libpng versions 0.5, May 1995, through 0.88, January 1996, are; * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.; *; * For the purposes of this copyright and license, ""Contributing Authors""; * is defined as the following set of individuals:; *; * Andreas Dilger; * Dave Martindale; * Guy Eric Schalnat; * Paul Schmidt; * Tim Wegner; *; * The PNG Reference Library is supplied ""AS IS"". The Contributing; * Authors and Group 42, Inc. disclaim all warranties, expressed or; * implied, including, without limitation, the warranties of; * merchantability and of fitness for any purpose. The Contributing; * Authors and Group 42, Inc. assume no liability for direct, indirect,; * incidental, special, exemplary, or consequential damages, which may; * result from the use of the PNG Reference Library, even if advised of; * the possibility of s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:4638,release,released,4638,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['release'],['released']
Deployability,"g (e.g. 1000 or 10000) bins without incurring a; corresponding CPU penalty. Note on numeric stability of the algorithm. Since the algorithm relies; on a numeric inversion of cumulative distributions functions, some precision; may be lost at the 'edges' of the same (i.e. at regions in x where the; c.d.f. value is close to zero or one). The general sampling strategy is; to start with 64 equally spaces samples in the range y=(0.01-0.99).; Then the y ranges are pushed outward by reducing y (or the distance of y to 1.0); by a factor of sqrt(10) iteratively up to the point where the corresponding; x value no longer changes significantly. For p.d.f.s with very flat tails; such as Gaussians some part of the tail may be lost due to limitations; in numeric precision in the CDF inversion step. An effect related to the above limitation in numeric precision should; be anticipated when floating the alpha parameter in a fit. If a p.d.f; with such flat tails is fitted, it is likely that the dataset contains; events in the flat tail region. If the alpha parameter is varied, the; likelihood contribution from such events may exhibit discontinuities; in alpha, causing discontinuities in the summed likelihood as well; that will cause convergence problems in MINUIT. To mitigate this effect; one can use the setCacheAlpha() method to instruct RooIntegralMorph; to construct a two-dimensional cache for its output values in both; x and alpha. If linear interpolation is requested on the resulting; output histogram, the resulting interpolation of the p.d.f in the; alpha dimension will smooth out the discontinuities in the tail regions; result in a continuous likelihood distribution that can be fitted.; An added advantage of the cacheAlpha option is that if parameters; p,q of f1,f2 are fixed, the cached values in RooIntegralMorph are; valid for the entire fit session and do not need to be recalculated; for each change in alpha, which may result an considerable increase; in calculation speed. **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx:4052,continuous,continuous,4052,roofit/roofit/src/RooIntegralMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx,1,['continuous'],['continuous']
Deployability,"g operand for certain; // PHIs in structurized CFG. This pass only works on IR that has gone through; // StructurizedCFG pass, and this pass has some additional limitation that make; // it can only run after SIAnnotateControlFlow.; //; // To achieve optimal code generation for AMDGPU, we assume that uniformity; // analysis reports the PHI in join block of divergent branch as uniform if; // it has one unique uniform value plus additional undefined/poisoned incoming; // value. That is to say the later compiler pipeline will ensure such PHI always; // return uniform value and ensure it work correctly. Let's take a look at two; // typical patterns in structured CFG that need to be taken care: (In both; // patterns, block %if terminate with divergent branch.); //; // Pattern A: Block with undefined incoming value dominates defined predecessor; // %if; // | \; // | %then; // | /; // %endif: %phi = phi [%undef, %if], [%uniform, %then]; //; // Pattern B: Block with defined incoming value dominates undefined predecessor; // %if; // | \; // | %then; // | /; // %endif: %phi = phi [%uniform, %if], [%undef, %then]; //; // For pattern A, by reporting %phi as uniform, the later pipeline need to make; // sure it be handled correctly. The backend usually allocates a scalar register; // and if any thread in a wave takes %then path, the scalar register will get; // the %uniform value.; //; // For pattern B, we will replace the undef operand with the other defined value; // in this pass. So the scalar register allocated for such PHI will get correct; // liveness. Without this transformation, the scalar register may be overwritten; // in the %then block.; //; // Limitation note:; // If the join block of divergent threads is a loop header, the pass cannot; // handle it correctly right now. For below case, the undef in %phi should also; // be rewritten. Currently we depend on SIAnnotateControlFlow to split %header; // block to get a separate join block, then we can rewrite the undef corre",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURewriteUndefForPHI.cpp:1615,pipeline,pipeline,1615,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURewriteUndefForPHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURewriteUndefForPHI.cpp,1,['pipeline'],['pipeline']
Deployability,"g);; double gvg = similarity(dg, v0);. // std::cout<<""delgam= ""<<delgam<<"" gvg= ""<<gvg<<std::endl;; MnAlgebraicVector vg = v0*dg;; // MnAlgebraicSymMatrix vUpd(v0.Nrow());. // MnAlgebraicSymMatrix dd = ( 1./delgam )*outer_product(dx);; // dd *= ( 1./delgam );; // MnAlgebraicSymMatrix VggV = ( 1./gvg )*outer_product(vg);; // VggV *= ( 1./gvg );; // vUpd = dd - VggV;; // MnAlgebraicSymMatrix vUpd = ( 1./delgam )*outer_product(dx) - ( 1./gvg )*outer_product(vg);; MnAlgebraicSymMatrix vUpd = Outer_product(dx)/delgam - Outer_product(vg)/gvg;. if(delgam > gvg) {; // dx *= ( 1./delgam );; // vg *= ( 1./gvg );; // MnAlgebraicVector flnu = dx - vg;; // MnAlgebraicSymMatrix tmp = Outer_product(flnu);; // tmp *= gvg;; // vUpd = vUpd + tmp;; vUpd += gvg*outer_product(dx/delgam - vg/gvg);; }. //; // MnAlgebraicSymMatrix dd = Outer_product(dx);; // dd *= ( 1./delgam );; // MnAlgebraicSymMatrix VggV = Outer_product(vg);; // VggV *= ( 1./gvg );; // vUpd = dd - VggV;; //; //; // double phi = delgam/(delgam - gvg);. // MnAlgebraicSymMatrix vUpd(v0.Nrow());; // if(phi < 0) {; // // rank-2 Update; // MnAlgebraicSymMatrix dd = Outer_product(dx);; // dd *= ( 1./delgam );; // MnAlgebraicSymMatrix VggV = Outer_product(vg);; // VggV *= ( 1./gvg );; // vUpd = dd - VggV;; // }; // if(phi > 1) {; // // rank-1 Update; // MnAlgebraicVector tmp = dx - vg;; // vUpd = Outer_product(tmp);; // vUpd *= ( 1./(delgam - gvg) );; // }; //. //; // if(delgam > gvg) {; // // rank-1 Update; // MnAlgebraicVector tmp = dx - vg;; // vUpd = Outer_product(tmp);; // vUpd *= ( 1./(delgam - gvg) );; // } else {; // // rank-2 Update; // MnAlgebraicSymMatrix dd = Outer_product(dx);; // dd *= ( 1./delgam );; // MnAlgebraicSymMatrix VggV = Outer_productn(vg);; // VggV *= ( 1./gvg );; // vUpd = dd - VggV;; // }; //. double sum_upd = sum_of_elements(vUpd);; vUpd += v0;. // MnAlgebraicSymMatrix V1 = v0 + vUpd;. double dcov =; 0.5*(s0.Error().Dcovar() + sum_upd/sum_of_elements(vUpd));. return MinimumError(vUpd, dcov);; }; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/DavidonErrorUpdator.cxx:1419,Update,Update,1419,math/minuit2/src/DavidonErrorUpdator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/DavidonErrorUpdator.cxx,4,['Update'],['Update']
Deployability,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3038,pipeline,pipeline,3038,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,2,['pipeline'],['pipeline']
Deployability,"gisterMap = {2 -> {X}, 3 -> {}}, InstrMap {X -> 2}; // DBG_VALUE %2, A, .... # X; // -> DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the DBG_VALUE Y is processed, the DbgValueSinkCandidates is updated; // to now hold Y for A and the RegisterMap is also updated to remove X from; // %2, this is because both X and Y describe the same debug variable A. X is; // also updated to have a $noreg as the first operand.; // DbgValueSinkCandidates = {A -> {Y}}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap = {X-> 2}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // -> DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After DBG_VALUE Z is processed, the DbgValueSinkCandidates is updated to; // hold Z fr A, the RegisterMap is updated to hold Z for %3, and the InstrMap; // is updated to have Z mapped to %3. This is again because Z describes the; // debug variable A, Y is not updated to have $noreg as first operand because; // its first operand is an immediate, not a register.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // -> %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // Nothing happens here since the RegisterMap for %2 contains no value.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // -> %3 = ld ...; // %4 = ld ...; // Since the RegisterMap contains Z as a value for %3, the MachineInstr; // pointer Z is copied to come after the load for %3 and the old Z's first; // operand is changed to $noreg the Basic Block iterator is moved to after the; // DBG_VALUE Z's new position.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3550,update,updated,3550,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['update'],['updated']
Deployability,"h to do:. h->Draw(""lego"");. `THistPainter` offers many options to paint 1D, 2D and 3D histograms. When the `Draw()` method of a histogram is called for the first time; (`TH1::Draw`), it creates a `THistPainter` object and saves a; pointer to this ""painter"" as a data member of the histogram. The; `THistPainter` class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram having its own; painter (rather than a central singleton painter painting all histograms), allows; two histograms to be drawn in two threads without overwriting the painter's; values. When a displayed histogram is filled again, there is no need to call the; `Draw()` method again; the image will be refreshed the next time the; pad will be updated. A pad is updated after one of these three actions:. 1. a carriage control on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. By default a call to `TH1::Draw()` clears the pad of all objects; before drawing the new image of the histogram. One can use the `SAME`; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads. When a displayed histogram is deleted, its image is automatically removed; from the pad. To create a copy of the histogram when drawing it, one can use; `TH1::DrawClone()`. This will clone the histogram and allow to change; and delete the original one without affecting the clone. \anchor HP01; ### Histograms' plotting options. Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with `TH1::SetOption` and retrieve; using `TH1::GetOption`:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:4628,Update,Update,4628,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['Update'],['Update']
Deployability,"he code to The Lean Mean C++ Option Parser.; * The ""Software"" does NOT refer to any other files which you; * may have received alongside this file (e.g. as part of a larger project that; * incorporates The Lean Mean C++ Option Parser).; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software, to deal in the Software without restriction, including; * without limitation the rights to use, copy, modify, merge, publish,; * distribute, sublicense, and/or sell copies of the Software, and to permit; * persons to whom the Software is furnished to do so, subject to the following; * conditions:; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; * SOFTWARE.; */; /*; * NOTE: It is recommended that you read the processed HTML doxygen documentation; * rather than this source. If you don't know doxygen, it's like javadoc for C++.; * If you don't want to install doxygen you can find a copy of the processed; * documentation at; *; * http://optionparser.sourceforge.net/; *; */; /*; Danio Piparo - Since we import this parser from tan external source, we keep; track of the changes:. New Features 6-7-12:; o Added FullArg class from the examples in the header. Bugs Fixed 8-7-12:; o Cov: Add initialisation of screenlen variable in LinePartIterator; o Cov: LineWrapper databuf, lenbuf and wrote_something are now initialised; o Cov: Option::operator= now returns Option& (return *this;) and not void; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h:1622,install,install,1622,core/dictgen/res/OptionParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h,1,['install'],['install']
Deployability,"he current context isn't native for either of the instructions, then; /// the higher-priority context wins (that is, the one that is more specific).; /// That hierarchy is determined by outranks() (X86DisassemblerTables.cpp); /// - If the current context is native for both instructions, then the table; /// emitter reports a conflict and dies.; ///; /// *** RESOLUTION FOR ""Primary decode conflict""S; ///; /// If two instructions collide, typically the solution is (in order of; /// likelihood):; ///; /// (1) to filter out one of the instructions by editing filter(); /// (X86RecognizableInstr.cpp). This is the most common resolution, but; /// check the Intel manuals first to make sure that (2) and (3) are not the; /// problem.; /// (2) to fix the tables (X86.td and its subsidiaries) so the opcodes are; /// accurate. Sometimes they are not.; /// (3) to fix the tables to reflect the actual context (for example, required; /// prefixes), and possibly to add a new context by editing; /// include/llvm/Support/X86DisassemblerDecoderCommon.h. This is unlikely; /// to be the cause.; ///; /// DisassemblerEmitter.cpp contains the implementation for the emitter,; /// which simply pulls out instructions from the CodeGenTarget and pushes them; /// into X86DisassemblerTables.; /// X86DisassemblerTables.h contains the interface for the instruction tables,; /// which manage and emit the structures discussed above.; /// X86DisassemblerTables.cpp contains the implementation for the instruction; /// tables.; /// X86ModRMFilters.h contains filters that can be used to determine which; /// ModR/M values are valid for a particular instruction. These are used to; /// populate ModRMDecisions.; /// X86RecognizableInstr.h contains the interface for a single instruction,; /// which knows how to translate itself from a CodeGenInstruction and provide; /// the information necessary for integration into the tables.; /// X86RecognizableInstr.cpp contains the implementation for a single; /// instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DisassemblerEmitter.cpp:4040,integrat,integration,4040,interpreter/llvm-project/llvm/utils/TableGen/DisassemblerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DisassemblerEmitter.cpp,1,['integrat'],['integration']
Deployability,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:2741,Patch,Patches,2741,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,2,['Patch'],['Patches']
Deployability,"he status corresponding to the last AutoSave.; ///; /// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; /// This allows another process to analyze the Tree while the Tree is being filled.; ///; /// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; /// the current basket are closed-out and written to disk individually.; ///; /// By default the previous header is deleted after having written the new header.; /// if option contains ""Overwrite"", the previous Tree header is deleted; /// before written the new header. This option is slightly faster, but; /// the default option is safer in case of a problem (disk quota exceeded); /// when writing the new header.; ///; /// The function returns the number of bytes written to the file.; /// if the number of bytes is null, an error has occurred while writing; /// the header to the file.; ///; /// ## How to write a Tree in one process and view it from another process; ///; /// The following two scripts illustrate how to do this.; /// The script treew.C is executed by process1, treer.C by process2; ///; /// script treew.C:; /// ~~~ {.cpp}; /// void treew() {; /// TFile f(""test.root"",""recreate"");; /// TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; /// Float_t px, py, pz;; /// for ( Int_t i=0; i<10000000; i++) {; /// gRandom->Rannor(px,py);; /// pz = px*px + py*py;; /// Float_t random = gRandom->Rndm(1);; /// ntuple->Fill(px,py,pz,random,i);; /// if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; /// }; /// }; /// ~~~; /// script treer.C:; /// ~~~ {.cpp}; /// void treer() {; /// TFile f(""test.root"");; /// TTree *ntuple = (TTree*)f.Get(""ntuple"");; /// TCanvas c1;; /// Int_t first = 0;; /// while(1) {; /// if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; /// else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; /// first = (Int_t)ntuple->GetEntries();; /// c1.Update();; /// gSystem->Sleep(1000); //sleep 1 second; /// ntuple->Refresh();; /// }; /// }; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:3203,Update,Update,3203,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['Update'],['Update']
Deployability,"hen construct the; overall efficiency with its uncertainty. This procedure has the advantage that you can change the weight of one; subsample easily without rerunning the whole analysis. On the other hand, more; effort is needed to handle several TEfficiency objects instead of one; histogram. In the case of many different or even continuously distributed; weights, this approach becomes cumbersome. One possibility to overcome this; problem is the usage of binned weights. \anchor EFF05a; ### Example; In particle physics weights arises from the fact that you want to; normalise your results to a certain reference value. A very common formula for; calculating weights is. \f{eqnarray*}{; w &=& \frac{\sigma L}{N_{gen} \epsilon_{trig}} \\; &-& \sigma ...\ cross\ section \\; &-& L ...\ luminosity \\; &-& N_{gen}\ ... number\ of\ generated\ events \\; &-& \epsilon_{trig}\ ...\ (known)\ trigger\ efficiency \\; \f}. The reason for different weights can therefore be:; - different processes; - other integrated luminosity; - varying trigger efficiency; - different sample sizes; - ...; - or even combination of them. Depending on the actual meaning of different weights in your case, you; should either merge or combine them to get the overall efficiency. \anchor EFF051; ### V.1 When should I use merging?; If the weights are artificial and do not represent real alternative hypotheses,; you should merge the different TEfficiency objects. That means especially for; the Bayesian case that the prior probability should be the same for all merged; TEfficiency objects. The merging can be done by invoking one of the following; operations:; - eff1.Add(eff2); - eff1 += eff2; - eff1 = eff1 + eff2. The result of the merging is stored in the TEfficiency object which is marked; bold above. The contents of the internal histograms of both TEfficiency; objects are added and a new weight is assigned. The statistic options are not; changed. \f[; \frac{1}{w_{new}} = \frac{1}{w_{1}} + \frac{1}{w_{2}}; \f]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:16660,integrat,integrated,16660,hist/hist/src/TEfficiency.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx,1,['integrat'],['integrated']
Deployability,"hen, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShift) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. ### CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. ### WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions.; */; ////////////////////////////////////////////////////////////////////////////////; /// Formula default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:2340,update,updated,2340,hist/hist/src/TFormula_v5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx,1,['update'],['updated']
Deployability,"hese variants may be valid, and checks are made; // to rule out inapplicable variants.; //; // As an additional optimization, before either of the two steps above is; // executed, the pass attempts to coalesce the target register with one of; // the source registers, e.g. given an instruction; // %3 = C2_mux %0, %1, %2; // %3 will be coalesced with either %1 or %2. If this succeeds,; // the instruction would then be (for example); // %3 = C2_mux %0, %3, %2; // and, under certain circumstances, this could result in only one predicated; // instruction:; // %3 = A2_tfrf %0, %2; //; // Splitting a definition of a register into two predicated transfers; // creates a complication in liveness tracking. Live interval computation; // will see both instructions as actual definitions, and will mark the; // first one as dead. The definition is not actually dead, and this; // situation will need to be fixed. For example:; // dead %1 = A2_tfrt ... ; marked as dead; // %1 = A2_tfrf ...; //; // Since any of the individual predicated transfers may end up getting; // removed (in case it is an identity copy), some pre-existing def may; // be marked as dead after live interval recomputation:; // dead %1 = ... ; marked as dead; // ...; // %1 = A2_tfrf ... ; if A2_tfrt is removed; // This case happens if %1 was used as a source in A2_tfrt, which means; // that is it actually live at the A2_tfrf, and so the now dead definition; // of %1 will need to be updated to non-dead at some point.; //; // This issue could be remedied by adding implicit uses to the predicated; // transfers, but this will create a problem with subsequent predication,; // since the transfers will no longer be possible to reorder. To avoid; // that, the initial splitting will not add any implicit uses. These; // implicit uses will be added later, after predication. The extra price,; // however, is that finding the locations where the implicit uses need; // to be added, and updating the live ranges will be more involved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:3429,update,updated,3429,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['update'],['updated']
Deployability,"hould ""block out"" those gaps by e.g.; /// just creating a single fixed-offset field that represents the; /// entire ""header"".; ///; /// - The size of a field is not required to be a multiple of, or even; /// greater than, the field's required alignment. The only constraint; /// on fields is that they must not be zero-sized.; ///; /// To simplify the implementation, any fixed-offset fields in the; /// layout must appear at the start of the field array, and they must; /// be ordered by increasing offset.; ///; /// The algorithm will produce a guaranteed-minimal layout with no; /// interior padding in the following ""C-style"" case:; ///; /// - every field's size is a multiple of its required alignment and; /// - either no fields have initially fixed offsets, or the fixed-offset; /// fields have no interior padding and end at an offset that is at; /// least as aligned as all the flexible-offset fields.; ///; /// Otherwise, while the algorithm will make a best-effort attempt to; /// avoid padding, it cannot guarantee a minimal layout, as there is; /// no known efficient algorithm for doing so.; ///; /// The layout produced by this algorithm may not be stable across LLVM; /// releases. Do not use this anywhere where ABI stability is required.; ///; /// Flexible-offset fields with the same size and alignment will be ordered; /// the same way they were in the initial array. Otherwise the current; /// algorithm makes no effort to preserve the initial order of; /// flexible-offset fields.; ///; /// On return, all fields will have been assigned a fixed offset, and the; /// array will be sorted in order of ascending offsets. Note that this; /// means that the fixed-offset fields may no longer form a strict prefix; /// if there's any padding before they end.; ///; /// The return value is the total size of the struct and its required; /// alignment. Note that the total size is not rounded up to a multiple; /// of the required alignment; clients which require this can do so easily.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OptimizedStructLayout.h:1710,release,releases,1710,interpreter/llvm-project/llvm/include/llvm/Support/OptimizedStructLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OptimizedStructLayout.h,1,['release'],['releases']
Deployability,"hr(token,' ');; if (blank) {; *blank = 0;; if (!gROOT->GetType(token)) {; Error(""SetStreamerInfo"",""Illegal type: %s in %s"",token,info);; return;; }; while (blank) {; strlcat(final,token,1000);; strlcat(final,"" "",1000);; comma = strchr(blank+1,','); if (comma) *comma=0;; strlcat(final,blank+1,1000);; strlcat(final,"";"",1000);; blank = comma;; }. } else {; if (TClass::GetClass(token,update)) {; //a class name; strlcat(final,token,1000); strlcat(final,"";"",1000);; } else {; //a data member name; dm = (TDataMember*)GetListOfDataMembers()->FindObject(token);; if (dm) {; strlcat(final,dm->GetFullTypeName(),1000);; strlcat(final,"" "",1000);; strlcat(final,token,1000); strlcat(final,"";"",1000);; } else {; Error(""SetStreamerInfo"",""Illegal name: %s in %s"",token,info);; return;; }; }; update = kFALSE;; }; temp = colon+1;; if (*temp == 0) break;; }; //// fStreamerInfo = final;; delete [] final;; delete [] save;; return;; }. //info is empty. Let's build the default Streamer descriptor. char *temp = new char[10000];; temp[0] = 0;; char local[100];. //add list of base classes; TIter nextb(GetListOfBases());; TBaseClass *base;; while ((base = (TBaseClass*) nextb())) {; snprintf(local,100,""%s;"",base->GetName());; strlcat(temp,local,10000);; }. //add list of data members and types; TIter nextd(GetListOfDataMembers());; while ((dm = (TDataMember *) nextd())) {; if (dm->IsEnum()) continue;; if (!dm->IsPersistent()) continue;; Long_t property = dm->Property();; if (property & kIsStatic) continue;; TClass *acl = TClass::GetClass(dm->GetTypeName(),update);; update = kFALSE;; if (acl) {; if (acl->GetClassVersion() == 0) continue;; }. // dm->GetArrayIndex() returns an empty string if it does not; // applies; const char * index = dm->GetArrayIndex();; if (strlen(index)==0); snprintf(local,100,""%s %s;"",dm->GetFullTypeName(),dm->GetName());; else; snprintf(local,100,""%s %s[%s];"",dm->GetFullTypeName(),dm->GetName(),index);; strlcat(temp,local,10000);; }; //fStreamerInfo = temp;; delete [] temp;; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:2655,update,update,2655,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,2,['update'],['update']
Deployability,"i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5);. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01;; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }; ~~~. It is also possible to visualise data from a tree. A simple macro; showing the use of a TTreeTableInterface follows. ~~~; {; // Open a root file.; TFile *file = new TFile(""$ROOTSYS/tutorials/hsimple.root"");; // Load a tree from the file; TNtuple *ntuple = (TNtuple *)file->Get(""ntuple"");. // Create an interface; TTreeTableInterface *iface = new TTreeTableInterface(ntuple);. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface, 10, 6);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. // Set a selection; iface->SetSelection(""px > 0."");; // Add a column; iface->AddColumn(""(px+py)/(px-py)"", 0);; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }; ~~~; */; ////////////////////////////////////////////////////////////////////////////////; /// TGTable constuctor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTable.cxx:3092,update,update,3092,gui/gui/src/TGTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTable.cxx,2,"['Update', 'update']","['Update', 'update']"
Deployability,"ib; * version string int version; * ------- ------ ----- ----------; * 0.89c ""1.0 beta 3"" 0.89 89 1.0.89; * 0.90 ""1.0 beta 4"" 0.90 90 0.90 [should have been 2.0.90]; * 0.95 ""1.0 beta 5"" 0.95 95 0.95 [should have been 2.0.95]; * 0.96 ""1.0 beta 6"" 0.96 96 0.96 [should have been 2.0.96]; * 0.97b ""1.00.97 beta 7"" 1.00.97 97 1.0.1 [should have been 2.0.97]; * 0.97c 0.97 97 2.0.97; * 0.98 0.98 98 2.0.98; * 0.99 0.99 98 2.0.99; * 0.99a-m 0.99 99 2.0.99; * 1.00 1.00 100 2.1.0 [100 should be 10000]; * 1.0.0 (from here on, the 100 2.1.0 [100 should be 10000]; * 1.0.1 png.h string is 10001 2.1.0; * 1.0.1a-e identical to the 10002 from here on, the shared library; * 1.0.2 source version) 10002 is 2.V where V is the source code; * 1.0.2a-b 10003 version, except as noted.; * 1.0.3 10003; * 1.0.3a-d 10004; * 1.0.4 10004; * 1.0.4a-f 10005; * 1.0.5 (+ 2 patches) 10005; * 1.0.5a-d 10006; * 1.0.5e-r 10100 (not source compatible); * 1.0.5s-v 10006 (not binary compatible); * 1.0.6 (+ 3 patches) 10006 (still binary incompatible); * 1.0.6d-f 10007 (still binary incompatible); * 1.0.6g 10007; * 1.0.6h 10007 10.6h (testing xy.z so-numbering); * 1.0.6i 10007 10.6i; * 1.0.6j 10007 2.1.0.6j (incompatible with 1.0.0); * 1.0.7beta11-14 DLLNUM 10007 2.1.0.7beta11-14 (binary compatible); * 1.0.7beta15-18 1 10007 2.1.0.7beta15-18 (binary compatible); * 1.0.7rc1-2 1 10007 2.1.0.7rc1-2 (binary compatible); * 1.0.7 1 10007 (still compatible); * ...; * 1.0.69 10 10069 10.so.0.69[.0]; * ...; * 1.2.59 13 10259 12.so.0.59[.0]; * ...; * 1.4.20 14 10420 14.so.0.20[.0]; * ...; * 1.5.30 15 10530 15.so.15.30[.0]; * ...; * 1.6.40 16 10640 16.so.16.40[.0]; *; * Henceforth the source version will match the shared-library major and; * minor numbers; the shared-library major version number will be used for; * changes in backward compatibility, as it is intended.; * The PNG_LIBPNG_VER macro, which is not used within libpng but is; * available for applications, is an unsigned integer of the form XYYZZ; * corresponding",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:8677,patch,patches,8677,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['patch'],['patches']
Deployability,"ic convolution calculated; this way is computationally intensive and prone to stability fitting problems.; <b>The preferred way to compute numeric convolutions is RooFFTConvPdf</b>,; which calculates convolutions using Fourier Transforms (requires external free; FFTW3 package); RooNumConvPdf implements reasonable defaults that should convolve most; functions reasonably well, but results strongly depend on the shape of your; input PDFS so always check your result.; The default integration engine for the numeric convolution is the; adaptive Gauss-Kronrod method, which empirically seems the most robust; for this task. You can override the convolution integration settings via; the RooNumIntConfig object reference returned by the convIntConfig() member; function; By default the numeric convolution is integrated from -infinity to; +infinity through a <pre>x -> 1/x</pre> coordinate transformation of the; tails. For convolution with a very small bandwidth it may be; advantageous (for both CPU consumption and stability) if the; integration domain is limited to a finite range. The function; setConvolutionWindow(mean,width,scale) allows to set a sliding; window around the x value to be calculated taking a RooAbsReal; expression for an offset and a width to be taken around the x; value. These input expression can be RooFormulaVars or other; function objects although the 3d 'scale' argument 'scale'; multiplies the width RooAbsReal expression given in the 2nd; argument, allowing for an appropriate window definition for most; cases without need for a RooFormulaVar object: e.g. a Gaussian; resolution PDF do setConvolutionWindow(gaussMean,gaussSigma,5); Note that for a 'wide' Gaussian the -inf to +inf integration; may converge more quickly than that over a finite range!; The default numeric precision is 1e-7, i.e. the global default for; numeric integration but you should experiment with this value to; see if it is sufficient for example by studying the number of function; calls tha",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvPdf.cxx:2026,integrat,integration,2026,roofit/roofitcore/src/RooNumConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvPdf.cxx,1,['integrat'],['integration']
Deployability,"icense-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file define class ResourcePressureView.; /// Class ResourcePressureView observes hardware events generated by; /// the Pipeline object and collects statistics related to resource usage at; /// instruction granularity.; /// Resource pressure information is then printed out to a stream in the; /// form of a table like the one from the example below:; ///; /// Resources:; /// [0] - JALU0; /// [1] - JALU1; /// [2] - JDiv; /// [3] - JFPM; /// [4] - JFPU0; /// [5] - JFPU1; /// [6] - JLAGU; /// [7] - JSAGU; /// [8] - JSTC; /// [9] - JVIMUL; ///; /// Resource pressure per iteration:; /// [0] [1] [2] [3] [4] [5] [6] [7] [8] [9]; /// 0.00 0.00 0.00 0.00 2.00 2.00 0.00 0.00 0.00 0.00; ///; /// Resource pressure by instruction:; /// [0] [1] [2] [3] [4] [5] [6] [7] [8] [9] Instructions:; /// - - - - - 1.00 - - - - vpermilpd $1, %xmm0,; /// %xmm1; /// - - - - 1.00 - - - - - vaddps %xmm0, %xmm1,; /// %xmm2; /// - - - - - 1.00 - - - - vmovshdup %xmm2, %xmm3; /// - - - - 1.00 - - - - - vaddss %xmm2, %xmm3,; /// %xmm4; ///; /// In this example, we have AVX code executed on AMD Jaguar (btver2).; /// Both shuffles and vector floating point add operations on XMM registers have; /// a reciprocal throughput of 1cy.; /// Each add is issued to pipeline JFPU0, while each shuffle is issued to; /// pipeline JFPU1. The overall pressure per iteration is reported by two; /// tables: the first smaller table is the resource pressure per iteration;; /// the second table reports resource pressure per instruction. Values are the; /// average resource cycles consumed by an instruction.; /// Every vector add from the example uses resource JFPU0 for an average of 1cy; /// per iteration. Consequently, the resource pressure on JFPU0 is of 2cy per; /// iteration.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h:1640,pipeline,pipeline,1640,interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h,2,['pipeline'],['pipeline']
Deployability,"if } \frac{x-\mu}{\sigma} < -a_l \\; * \left( (x-\mu)^2 + A^2_\lambda(\zeta)\sigma^2 \right)^{\frac{1}{2}\lambda-\frac{1}{4}} e^{\beta(x-\mu)} K_{\lambda-\frac{1}{2}}; * \left( \zeta \sqrt{1+\left( \frac{x-\mu}{A_\lambda(\zeta)\sigma} \right)^2 } \right) \equiv G(x, \mu, \ldots); * & \text{otherwise} \\; * \frac{ G(\mu + a_r \sigma, \mu, \sigma, \lambda, \zeta, \beta) }; * { \left( 1 - \frac{x}{-n_r G(\ldots)/G'(\ldots) - a_r\sigma } \right)^{n_r} }; * & \text{if } \frac{x-\mu}{\sigma} > a_r \\; * \end{cases}; * \f]; * Here, \f$ K_\lambda \f$ are the modified Bessel functions of the second kind; * (""irregular modified cylindrical Bessel functions"" from the gsl,; * ""special Bessel functions of the third kind""),; * and \f$ A^2_\lambda(\zeta) \f$ is a ratio of these:; * \f[; * A_\lambda^{2}(\zeta) = \frac{\zeta K_\lambda(\zeta)}{K_{\lambda+1}(\zeta)}; * \f]; *; * \if false; * TODO Enable once analytic integrals work.; * ### Analytical Integration; * The Hypatia distribution can be integrated analytically if \f$ \beta = \zeta = 0 \f$ and; * \f$ \lambda < 0 \f$. An analytic integral will only be used, though, if the parameters are **constant**; * at zero, and if \f$ \lambda < 0 \f$. This can be ensured as follows:; * ```; * RooRealVar beta(""beta"", ""beta"", 0.); // NOT beta(""beta"", ""beta"", 0., -1., 1.) This would allow it to float.; * RooRealVar zeta(""zeta"", ""zeta"", 0.);; * RooRealVar lambda(""lambda"", ""lambda"", -1., -10., -0.00001);; * ```; * In all other cases, slower / less accurate numeric integration will be used.; * Note that including `0.` in the value range of lambda excludes using analytic integrals.; * \endif; *; * ### Concavity; * Note that unless the parameters \f$ a_l,\ a_r \f$ are very large, the function has non-hyperbolic tails. This requires; * \f$ G \f$ to be strictly concave, *i.e.*, peaked, as otherwise the tails would yield imaginary numbers. Choosing \f$ \lambda,; * \beta, \zeta \f$ inappropriately will therefore lead to evaluation errors.; *; * Furthe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooHypatia2.cxx:2249,Integrat,Integration,2249,roofit/roofitmore/src/RooHypatia2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooHypatia2.cxx,2,"['Integrat', 'integrat']","['Integration', 'integrated']"
Deployability,"igma and deconvolution is carried out.; ///; /// Function parameters:; /// - source-pointer to the matrix of source spectrum; /// - dest-pointer to the matrix of resulting deconvolved spectrum; /// - ssizex-x length of source spectrum; /// - ssizey-y length of source spectrum; /// - sigma-sigma of searched peaks, for details we refer to manual; /// - threshold-threshold value in % for selected peaks, peaks with; /// amplitude less than threshold*highest_peak/100; /// are ignored, see manual; /// - backgroundRemove-logical variable, set if the removal of; /// background before deconvolution is desired; /// - deconIterations-number of iterations in deconvolution operation; /// - markov-logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow-averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method); ///; /// ### Peaks searching; ///; /// Goal: to identify automatically the peaks in spectrum with the presence of the; /// continuous background, one-fold coincidences (ridges) and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification in two-dimensional coincidence spectra are; ///; /// - non-sensitivity to noise, i.e., only statistically relevant peaks should be identified; /// - non-sensitivity of the algorithm to continuous background; /// - non-sensitivity to one-fold coincidences (coincidences peak - background in both dimensions) and their crossings; /// - ability to identify peaks close to the edges of the spectrum region. Usually peak finders fail to detect them; /// - resolution, decomposition of doublets and multiplets. The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma; ///; /// #### References:; ///; /// [1] M.A. Mariscotti: A method for identification of peaks in the presence of; /// background",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:1426,continuous,continuous,1426,hist/spectrum/src/TSpectrum2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx,1,['continuous'],['continuous']
Deployability,"il the flush is complete (deflate returns with non-zero; avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that; avail_out is greater than six to avoid repeated flush markers due to; avail_out == 0 on return. If the parameter flush is set to Z_FINISH, pending input is processed,; pending output is flushed and deflate returns with Z_STREAM_END if there was; enough output space; if deflate returns with Z_OK, this function must be; called again with Z_FINISH and more output space (updated avail_out) but no; more input data, until it returns with Z_STREAM_END or an error. After; deflate has returned Z_STREAM_END, the only possible operations on the stream; are deflateReset or deflateEnd. Z_FINISH can be used immediately after deflateInit if all the compression; is to be done in a single step. In this case, avail_out must be at least the; value returned by deflateBound (see below). Then deflate is guaranteed to; return Z_STREAM_END. If not enough output space is provided, deflate will; not return Z_STREAM_END, and it must be called again as described above. deflate() sets strm->adler to the adler32 checksum of all input read; so far (that is, total_in bytes). deflate() may update strm->data_type if it can make a good guess about; the input data type (Z_BINARY or Z_TEXT). In doubt, the data is considered; binary. This field is only for information purposes and does not affect the; compression algorithm in any manner. deflate() returns Z_OK if some progress has been made (more input; processed or more output produced), Z_STREAM_END if all input has been; consumed and all output has been produced (only when flush is set to; Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example; if next_in or next_out was Z_NULL), Z_BUF_ERROR if no progress is possible; (for example avail_in or avail_out was zero). Note that Z_BUF_ERROR is not; fatal, and deflate() can be called again with more input and more output; space to continue compressing.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:5054,update,update,5054,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['update'],['update']
Deployability,"ill not; // revisit all instructions/blocks/functions in the module but only query; // an update from a subset of the abstract attributes.; //; // The update method `AbstractAttribute::updateImpl` is implemented by the; // specific ""abstract attribute"" subclasses. The method is invoked whenever the; // currently assumed state (see the AbstractState class) might not be valid; // anymore. This can, for example, happen if the state was dependent on another; // abstract attribute that changed. In every invocation, the update method has; // to adjust the internal state of an abstract attribute to a point that is; // justifiable by the underlying IR and the current state of abstract attributes; // in-flight. Since the IR is given and assumed to be valid, the information; // derived from it can be assumed to hold. However, information derived from; // other abstract attributes is conditional on various things. If the justifying; // state changed, the `updateImpl` has to revisit the situation and potentially; // find another justification or limit the optimistic assumes made.; //; // Change is the key in this framework. Until a state of no-change, thus a; // fixpoint, is reached, the Attributor will query the abstract attributes; // in-flight to re-evaluate their state. If the (current) state is too; // optimistic, hence it cannot be justified anymore through other abstract; // attributes or the state of the IR, the state of the abstract attribute will; // have to change. Generally, we assume abstract attribute state to be a finite; // height lattice and the update function to be monotone. However, these; // conditions are not enforced because the iteration limit will guarantee; // termination. If an optimistic fixpoint is reached, or a pessimistic fix; // point is enforced after a timeout, the abstract attributes are tasked to; // manifest their result in the IR for passes to come.; //; // Attribute manifestation is not mandatory. If desired, there is support to; // genera",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:2938,update,updateImpl,2938,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['update'],['updateImpl']
Deployability,"ing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. ### The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the; last command issued and SCAN enables redirecting of TTree::Scan command in; an ASCII file (see -Scanning expressions-);; - a button bar in the lower part with : buttons DRAW/STOP that issue histogram; drawing and stop the current command respectively, two text widgets where; input and output event lists can be specified, a message box and a RESET; button on the right that clear edited expression content (see Editing...); - a tree-type list on the main left panel where you can select among trees or; branches. The tree/branch will be detailed in the right panel.; Mapped trees are provided with context menus, activated by right-clicking;; - a view-type list on the right panel. The first column contain X, Y and; Z expression items, an optional cut and ten optional editable expressions.; Expressions and leaf-type items can be dragged or deleted. A right click on; the list-box or item activates context menus. ### Opening a new tree and saving a session :. To open a new tree in the viewer use `<File/Open tree file>` menu; The content of the file (keys) will be listed. Use `<SetTreeName>` function; from the context menu of the right panel, entering a tree name among ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx:2094,toggle,toggles,2094,tree/treeviewer/src/TTreeViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx,1,['toggle'],['toggles']
Deployability,"internally observes backend pressure increase events in order to; /// identify problematic data dependencies and processor resource interferences.; ///; /// Example of bottleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; /// +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; /// |; /// | < loop carried > ; /// |; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; ///; ///; /// The algorithm that computes the critical sequence is very similar to a; /// critical path analysis.; /// ; /// A dependency graph is used internally to track de",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:1535,pipeline,pipelines,1535,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,1,['pipeline'],['pipelines']
Deployability,"is isn't always possible because i24 has storage size of 32 bit; /// and if it is possible to use that extra byte of padding we must use; /// [i8 x 3] instead of i24. The function clipTailPadding does this.; /// C++ examples that require clipping:; /// struct { int a : 24; char b; }; // a must be clipped, b goes at offset 3; /// struct A { int a : 24; }; // a must be clipped because a struct like B; // could exist: struct B : A { char b; }; // b goes at offset 3; /// * Clang ignores 0 sized bitfields and 0 sized bases but *not* zero sized; /// fields. The existing asserts suggest that LLVM assumes that *every* field; /// has an underlying storage type. Therefore empty structures containing; /// zero sized subobjects such as empty records or zero sized arrays still get; /// a zero sized (empty struct) storage type.; /// * Clang reads the complete type rather than the base type when generating; /// code to access fields. Bitfields in tail position with tail padding may; /// be clipped in the base class but not the complete class (we may discover; /// that the tail padding is not used in the complete class.) However,; /// because LLVM reads from the complete type it can generate incorrect code; /// if we do not clip the tail padding off of the bitfield in the complete; /// layout. This introduces a somewhat awkward extra unnecessary clip stage.; /// The location of the clip is stored internally as a sentinel of type; /// SCISSOR. If LLVM were updated to read base types (which it probably; /// should because locations of things such as VBases are bogus in the llvm; /// type anyway) then we could eliminate the SCISSOR.; /// * Itanium allows nearly empty primary virtual bases. These bases don't get; /// get their own storage because they're laid out as part of another base; /// or at the beginning of the structure. Determining if a VBase actually; /// gets storage awkwardly involves a walk of all bases.; /// * VFPtrs and VBPtrs do *not* make a record NotZeroInitializable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp:2344,update,updated,2344,interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,1,['update'],['updated']
Deployability,"istogram get its color; from the current color palette defined by `gStyle->SetPalette(...)`. The color; is determined according to the number of objects having palette coloring in; the current pad. Begin_Macro(source); ../../../tutorials/hist/histpalettecolor.C; End_Macro. Begin_Macro(source); ../../../tutorials/hist/thstackpalettecolor.C; End_Macro. Begin_Macro(source); ../../../tutorials/hist/thstack2palettecolor.C; End_Macro. \anchor HP06; ### Superimposing two histograms with different scales in the same pad. The following example creates two histograms, the second histogram is the bins; integral of the first one. It shows a procedure to draw the two histograms in; the same pad and it draws the scale of the second histogram using a new vertical; axis on the right side. See also the tutorial `transpad.C` for a variant; of this example. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; // create/fill draw h1; gStyle->SetOptStat(kFALSE);; auto h1 = new TH1F(""h1"",""Superimposing two histograms with different scales"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) h1->Fill(gRandom->Gaus(0,1));; h1->Draw();; c1->Update();. // create hint1 filled with the bins integral of h1; auto hint1 = new TH1F(""hint1"",""h1 bins integral"",100,-3,3);; float sum = 0.f;; for (i=1;i<=100;i++) {; sum += h1->GetBinContent(i);; hint1->SetBinContent(i,sum);; }. // scale hint1 to the pad coordinates; float rightmax = 1.1*hint1->GetMaximum();; float scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");. // draw an axis on the right side; auto axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetTextColor(kRed);; axis->Draw();; }; End_Macro. \anchor HP07; ### Statistics Display. The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The `mode` has up to nine digits that can be set",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:20169,Update,Update,20169,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['Update'],['Update']
Deployability,"istogram model based on the obersved data.; * This results in per-bin values that are all in the same order of magnitude, which reduces precision loss in the sum,; * which can drastically improve numeric stability.; * Furthermore, \f$2\cdot \text{NLL}\f$ defined like this is approximately chi-square distributed, allowing for goodness-of-fit tests.; * </table>; * <tr><td> `IntegrateBins(double precision)` <td> In binned fits, integrate the PDF over the bins instead of using the probability density at the bin centre.; * This can reduce the bias observed when fitting functions with high curvature to binned data.; * - precision > 0: Activate bin integration everywhere. Use precision between 0.01 and 1.E-6, depending on binning.; * Note that a low precision such as 0.01 might yield identical results to 1.E-4, since the integrator might reach 1.E-4 already in its first; * integration step. If lower precision is desired (more speed), a RooBinSamplingPdf has to be created manually, and its integrator; * has to be manipulated directly.; * - precision = 0: Activate bin integration only for continuous PDFs fit to a RooDataHist.; * - precision < 0: Deactivate.; * \see RooBinSamplingPdf; * <tr><td> `ModularL(bool flag)` <td> Enable or disable modular likelihoods, which will become the default in a future release.; * This does not change any user-facing code, but only enables a different likelihood class in the back-end. Note that this; * should be set to true for parallel minimization of likelihoods!; * Note that it is currently not recommended to use Modular likelihoods without any parallelization enabled in the minimization, since; * some features such as offsetting might not yet work in this case.; * </table>; */; /** @brief Protected implementation of the NLL creation routine.; *; * This virtual function can be overridden in case you want to change the NLL creation logic for custom PDFs.; *; * \note Never call this function directly. Instead, call RooAbsPdf::createNLL().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:9732,integrat,integration,9732,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,3,"['continuous', 'integrat', 'release']","['continuous', 'integration', 'release']"
Deployability,"istribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). ## Applying constraints; Fit parameters can be constrained through. fit->Constrain(parameter #, lower bound, upper bound);. Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function. fit->Unconstrain(parameter #). is also provided to simplify this. ## Setting parameter values; The function. ROOT::Fit::Fitter* fitter = fit->GetFitter();. is provided for direct access to the ROOT::Fit::Fitter object. This allows to; set and fix parameter values, limits and set step sizes directly via. fitter->Config().ParSettings(parameter #).Set(const std::string &name, double value, double step, double lower, double upper);. ## Restricting the fit range; The fit range can be restricted through. fit->SetRangeX(first bin #, last bin #);; and freed using. fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using. fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also. fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through. fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding. fit->IncludeBin(bin #);. ## Weights histograms; Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through. fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. ## Obtaining fit results; The fit is carried out through. Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through. fit->GetResult(parameter #, value, error);; and the",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:3579,Release,ReleaseRangeX,3579,hist/hist/src/TFractionFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx,1,['Release'],['ReleaseRangeX']
Deployability,"itcore. Numeric 1-dimensional convolution operator PDF. This class can convolve any PDF; with any other PDF using a straightforward numeric calculation of the; convolution integral; This class should be used as last resort as numeric convolution calculated; this way is computationally intensive and prone to stability fitting problems.; <b>The preferred way to compute numeric convolutions is RooFFTConvPdf</b>,; which calculates convolutions using Fourier Transforms (requires external free; FFTW3 package); RooNumConvPdf implements reasonable defaults that should convolve most; functions reasonably well, but results strongly depend on the shape of your; input PDFS so always check your result.; The default integration engine for the numeric convolution is the; adaptive Gauss-Kronrod method, which empirically seems the most robust; for this task. You can override the convolution integration settings via; the RooNumIntConfig object reference returned by the convIntConfig() member; function; By default the numeric convolution is integrated from -infinity to; +infinity through a <pre>x -> 1/x</pre> coordinate transformation of the; tails. For convolution with a very small bandwidth it may be; advantageous (for both CPU consumption and stability) if the; integration domain is limited to a finite range. The function; setConvolutionWindow(mean,width,scale) allows to set a sliding; window around the x value to be calculated taking a RooAbsReal; expression for an offset and a width to be taken around the x; value. These input expression can be RooFormulaVars or other; function objects although the 3d 'scale' argument 'scale'; multiplies the width RooAbsReal expression given in the 2nd; argument, allowing for an appropriate window definition for most; cases without need for a RooFormulaVar object: e.g. a Gaussian; resolution PDF do setConvolutionWindow(gaussMean,gaussSigma,5); Note that for a 'wide' Gaussian the -inf to +inf integration; may converge more quickly than that over a ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvPdf.cxx:1647,integrat,integration,1647,roofit/roofitcore/src/RooNumConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvPdf.cxx,2,['integrat'],"['integrated', 'integration']"
Deployability,"ithout modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; //////////////////////////////////////////////////////////////////////////////; /// \class RooFFTConvPdf; /// \ingroup Roofitcore; ///; /// This class implements a generic one-dimensional numeric convolution of two PDFs,; /// and can convolve any two RooAbsPdfs. The class exploits the convolution theorem; /// \f[; /// f(x) * g(x) \rightarrow F(k_i) \cdot G(k_i); /// \f]; /// to calculate the convolution by calculating a Real->Complex FFT of both input PDFs,; /// multiplying the complex coefficients and performing the reverse Complex->Real FFT; /// to get the result in the input space. This class uses the ROOT FFT interface to; /// the (free) FFTW3 package (www.fftw.org), and requires that your ROOT installation is; /// compiled with the `fftw3=ON` (default). Instructions for manually installing fftw below.; ///; /// Note that the performance in terms of speed and stability of RooFFTConvPdf is; /// vastly superior to that of RooNumConvPdf.; ///; /// An important feature of FFT convolutions is that the observable is assumed to be; /// cyclical. This is correct for cyclical observables such as angles,; /// but does not hold in general. For non-cyclical variables, wrap-around artifacts may be; /// encountered, *e.g.* if the PDF is zero at xMin and non-zero at xMax. A rising tail may appear at xMin.; /// This is inevitable when using FFTs. A distribution with 3 bins therefore looks like:; /// ```; /// ... 0 1 2 0 1 2 0 1 2 ...; /// ```; ///; /// Therefore, if bins 0 and 2 are not equal, the FFT sees a cyclical function with a step at the 2|0 boundary, which causes; /// artifacts in Fourier space.; ///; /// The spillover or discontinuity can be reduced or eliminated by; /// introducing a buffer zone in the FFT calculation. If this feature is activated (on by default),;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:1302,install,installing,1302,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['install'],['installing']
Deployability,"its ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert a phi:; //; // loop:; // x' = phi(x); // x = I0; // I1 x'; //; // This is a simple example; the rules for how to generate correct code given; // an arbitrary schedule containing loop-carried values are complex.; //; // Note that these examples only mention the steady-state kernel of the; // generated loop; prologs and epilogs must be generated also that prime and; // flush the pipeline. Doing so is nontrivial.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:1565,pipeline,pipeline,1565,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,2,['pipeline'],['pipeline']
Deployability,"ject, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform an entirely numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e., no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; common, etc). #### Implementing analytical integrals; To implement analytical integrals, two functions must be implemented. First,. ```; Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet); ```; should return the analytical integrals that are supported. `integSet`; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to `anaIntSet`, and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. ```; double analyticalIntegral(Int_t code); ```. implements the actual analytical integral(s) advertised by; `getAnalyticalIntegral()`. This function will only be called with; codes returned by `getAnalyticalIntegral()`, except code zero. The integration range for each dependent to be integrated can; be obtained from the dependent's proxy functions `min()` and; `max()`. Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g., in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. ### Direct generation of observables. Distributions for any PDF can be generated with the accept/reject method,; but for certain PDFs, more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for ana",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:3664,integrat,integration,3664,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['integrat'],['integration']
Deployability,"kes no prediction on the expected number of events will result in error messages,; /// and the chi2 will fall back to the total data weight to scale the normalized pdf.; /// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; /// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; /// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; /// printed and you'll most likely get garbage results.; /// <tr><td> `Range(const char* name)` <td> Fit only data inside range with given name; /// <tr><td> `Range(double lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; /// Multiple comma separated range names can be specified.; /// <tr><td> `NumCPU(int num)` <td> Parallelize NLL calculation on num CPUs; /// <tr><td> `Optimize(bool flag)` <td> Activate constant term optimization (on by default); /// <tr><td> `IntegrateBins()` <td> Integrate PDF within each bin. This sets the desired precision.; ///; /// <tr><th> <th> Options to control flow of fit procedure; /// <tr><td> `InitialHesse(bool flag)` <td> Flag controls if HESSE before MIGRAD as well, off by default; /// <tr><td> `Hesse(bool flag)` <td> Flag controls if HESSE is run after MIGRAD, on by default; /// <tr><td> `Minos(bool flag)` <td> Flag controls if MINOS is run after HESSE, on by default; /// <tr><td> `Minos(const RooArgSet& set)` <td> Only run MINOS on given subset of arguments; /// <tr><td> `Save(bool flag)` <td> Flag controls if RooFitResult object is produced and returned, off by default; /// <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 through 2, default is 1); ///; /// <tr><th> <th> Options to control informational output; /// <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output is printed (NLL, parameter changes during fit; /// ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:1985,Integrat,IntegrateBins,1985,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,2,['Integrat'],"['Integrate', 'IntegrateBins']"
Deployability,"ks every N events](\ref callbacks); - [Default column lists](\ref default-branches); - [Special helper columns: `rdfentry_` and `rdfslot_`](\ref helper-cols); - [Just-in-time compilation: column type inference and explicit declaration of column types](\ref jitting); - [User-defined custom actions](\ref generic-actions); - [Dataset joins with friend trees](\ref friends); - [Reading data formats other than ROOT trees](\ref other-file-formats); - [Computation graphs (storing and reusing sets of transformations)](\ref callgraphs); - [Visualizing the computation graph](\ref representgraph); - [Activating RDataFrame execution logs](\ref rdf-logging); - [Creating an RDataFrame from a dataset specification file](\ref rdf-from-spec); - [Adding a progress bar](\ref progressbar); - [Working with missing values in the dataset](\ref missing-values); - [Efficient analysis in Python](\ref python); - <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>. \anchor cheatsheet; ## Cheat sheet; These are the operations which can be performed with RDataFrame. ### Transformations; Transformations are a way to manipulate the data. | **Transformation** | **Description** |; |------------------|--------------------|; | Alias() | Introduce an alias for a particular column name. |; | DefaultValueFor() | If the value of the input column is missing, provide a default value instead. |; | Define() | Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the `pt`s of ""good"" muons). |; | DefinePerSample() | Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. |; | DefineSlot() | Same as Define(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a differen",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:3035,toggle,toggleInherit,3035,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['toggle'],['toggleInherit']
Deployability,"ks.; ///; /// #### Parameters:; ///; /// - source: pointer to the vector of source spectrum.; /// - destVector: pointer to the vector of resulting deconvolved spectrum.; /// - ssize: length of source spectrum.; /// - sigma: sigma of searched peaks, for details we refer to manual.; /// - threshold: threshold value in % for selected peaks, peaks with; /// amplitude less than threshold*highest_peak/100; /// are ignored, see manual.; /// - backgroundRemove: logical variable, set if the removal of; /// background before deconvolution is desired.; /// - deconIterations-number of iterations in deconvolution operation.; /// - markov: logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow: averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method).; ///; /// ### Peaks searching:; ///; /// The goal of this function is to identify automatically the peaks in spectrum; /// with the presence of the continuous background and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification are:; ///; /// - non-sensitivity to noise, i.e., only statistically; /// relevant peaks should be identified.; /// - non-sensitivity of the algorithm to continuous; /// background.; /// - ability to identify peaks close to the edges of the; /// spectrum region. Usually peak finders fail to detect them.; /// - resolution, decomposition of Double_tts and multiplets.; /// The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma.; ///; /// \image html TSpectrum_Searching1.jpg Fig. 27 An example of one-dimensional synthetic spectrum with found peaks denoted by markers.; ///; /// #### References:; ///; /// 1. M.A. Mariscotti: A method for identification of peaks in the presence of; /// background and its application to spectrum analysis. NIM 50 (1967),;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:1703,continuous,continuous,1703,hist/spectrum/src/TSpectrum.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx,1,['continuous'],['continuous']
Deployability,"le RooTrace.cxx; \class RooTrace; \ingroup Roofitcore. Controls the memory tracing hooks in all RooFit; objects. When tracing is active, a table of live RooFit objects; is kept that can be queried at any time. In verbose mode, messages; are printed in addition at the construction and destruction of; each object. Usage example:; \code{.cpp}; void exampleRooTrace(); {; using namespace RooFit;. // Activate RooFit memory tracing; RooTrace::active(true);; ; // Construct gauss(x,m,s); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 1, -10, 10);; RooGaussian gauss(""g"", ""g"", x, m, s);; ; // Show dump of all RooFit object in memory; RooTrace::dump();; ; // Activate verbose mode; RooTrace::verbose(true);; ; // Construct poly(x,p0); RooRealVar p0(""p0"", ""p0"", 0.01, 0., 1.);; RooPolynomial poly(""p"", ""p"", x, p0);; ; // Put marker in trace list for future reference; RooTrace::mark();; ; // Construct model = f*gauss(x) + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; // Show object added to memory since marker; RooTrace::printObjectCounts();; ; // Since verbose mode is still on, you will see messages; // pertaining to destructor calls of all RooFit objects; // made in this macro; //; // A call to RooTrace::dump() at the end of this macro; // should show that there a no RooFit object left in memory; }; \endcode. \note In the ROOT releases, the RooTrace is disabled at compile time and the; example above will not print any objects. If you are an advanced developer who; wants to use the RooTrace, you need to recompile ROOT after changing the; `TRACE_CREATE` and `TRACE_DESTROY` macros in RooTrace.h to call the RooTrace; functions:. \code{.cpp}; #define TRACE_CREATE RooTrace::create(this);; #define TRACE_DESTROY RooTrace::destroy(this);; \endcode. However, as ROOT is not build with this by default, the RooTrace is not tested; and there is no guarantee that this works.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTrace.cxx:2155,release,releases,2155,roofit/roofitcore/src/RooTrace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTrace.cxx,1,['release'],['releases']
Deployability,"lity fitting problems.; <b>The preferred way to compute numeric convolutions is RooFFTConvPdf</b>,; which calculates convolutions using Fourier Transforms (requires external free; FFTW3 package); RooNumConvPdf implements reasonable defaults that should convolve most; functions reasonably well, but results strongly depend on the shape of your; input PDFS so always check your result.; The default integration engine for the numeric convolution is the; adaptive Gauss-Kronrod method, which empirically seems the most robust; for this task. You can override the convolution integration settings via; the RooNumIntConfig object reference returned by the convIntConfig() member; function; By default the numeric convolution is integrated from -infinity to; +infinity through a <pre>x -> 1/x</pre> coordinate transformation of the; tails. For convolution with a very small bandwidth it may be; advantageous (for both CPU consumption and stability) if the; integration domain is limited to a finite range. The function; setConvolutionWindow(mean,width,scale) allows to set a sliding; window around the x value to be calculated taking a RooAbsReal; expression for an offset and a width to be taken around the x; value. These input expression can be RooFormulaVars or other; function objects although the 3d 'scale' argument 'scale'; multiplies the width RooAbsReal expression given in the 2nd; argument, allowing for an appropriate window definition for most; cases without need for a RooFormulaVar object: e.g. a Gaussian; resolution PDF do setConvolutionWindow(gaussMean,gaussSigma,5); Note that for a 'wide' Gaussian the -inf to +inf integration; may converge more quickly than that over a finite range!; The default numeric precision is 1e-7, i.e. the global default for; numeric integration but you should experiment with this value to; see if it is sufficient for example by studying the number of function; calls that MINUIT needs to fit your function as function of the; convolution precision.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvPdf.cxx:2705,integrat,integration,2705,roofit/roofitcore/src/RooNumConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvPdf.cxx,2,['integrat'],['integration']
Deployability,"ll also be sent along with tasks to; * the queue. When a worker then takes a task from the queue, it can check; * whether it has already updated its state to what is expected to be there; * for the task at hand. If not, it should wait for the new state to arrive; * over the state subscription socket. Note: it is the implementer's task to; * actually update 'Job::state_id_' inside 'Job::update_state()'!; *; * ## Implementers notes; *; * The type of result from each task is strongly dependent on the Job at hand; * and so Job does not provide a default results member. It is up to the; * inheriting class to implement this in the above functions. We would have; * liked a template parameter task_result_t, so that we could also provide a; * default ""boilerplate"" calculate function to show a typical Job use-case of; * all the above infrastructure. This is not trivial, because the JobManager; * has to keep a list of Job pointers, so if there would be different template; * instantiations of Jobs, this would complicate this list.; *; * A typical Job implementation will have an evaluation function that is; * called from the master process, like RooAbsArg::getVal calls evaluate().; * This function will have three purposes: 1. send updated parameter values; * to the workers (possibly through update_state() or in a dedicated; * function), 2. queue tasks and 3. wait for the results to be retrieved.; * 'Job::gather_worker_results()' is provided for convenience to wait for; * all tasks to be retrieved for the current Job. Implementers can also; * choose to have the master process perform other tasks in between any of; * these three steps, or even skip steps completely.; *; * Child classes should refrain from direct access to the JobManager instance; * (through JobManager::instance), but rather use the here provided; * Job::get_manager(). This function starts the worker_loop on the worker when; * first called, meaning that the workers will not be running before they; * are needed.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Job.cxx:3285,update,updated,3285,roofit/multiprocess/src/Job.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Job.cxx,1,['update'],['updated']
Deployability,"ll.) Flushing may degrade compression for some compression; algorithms and so it should be used only when necessary. If flush is set to Z_FULL_FLUSH, all output is flushed as with; Z_SYNC_FLUSH, and the compression state is reset so that decompression can; restart from this point if previous compressed data has been damaged or if; random access is desired. Using Z_FULL_FLUSH too often can seriously degrade; compression. If deflate returns with avail_out == 0, this function must be called again; with the same value of the flush parameter and more output space (updated; avail_out), until the flush is complete (deflate returns with non-zero; avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that; avail_out is greater than six to avoid repeated flush markers due to; avail_out == 0 on return. If the parameter flush is set to Z_FINISH, pending input is processed,; pending output is flushed and deflate returns with Z_STREAM_END if there; was enough output space; if deflate returns with Z_OK, this function must be; called again with Z_FINISH and more output space (updated avail_out) but no; more input data, until it returns with Z_STREAM_END or an error. After; deflate has returned Z_STREAM_END, the only possible operations on the; stream are deflateReset or deflateEnd. Z_FINISH can be used immediately after deflateInit if all the compression; is to be done in a single step. In this case, avail_out must be at least; the value returned by deflateBound (see below). If deflate does not return; Z_STREAM_END, then it must be called again as described above. deflate() sets strm->adler to the adler32 checksum of all input read; so far (that is, total_in bytes). deflate() may update strm->data_type if it can make a good guess about; the input data type (Z_BINARY or Z_TEXT). In doubt, the data is considered; binary. This field is only for information purposes and does not affect; the compression algorithm in any manner. deflate() returns Z_OK if some progress has ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:3129,update,updated,3129,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['update'],['updated']
Deployability,"ls provided with the; * distribution.; *; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR; * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; *; * You can contact the author at:; * - xxHash homepage: https://www.xxhash.com; * - xxHash source repository: https://github.com/Cyan4973/xxHash; */; /* TODO: update */; /* Notice extracted from xxHash homepage:. xxHash is an extremely fast hash algorithm, running at RAM speed limits.; It also successfully passes all tests from the SMHasher suite. Comparison (single thread, Windows Seven 32 bits, using SMHasher on a Core 2 Duo @3GHz). Name Speed Q.Score Author; xxHash 5.4 GB/s 10; CrapWow 3.2 GB/s 2 Andrew; MumurHash 3a 2.7 GB/s 10 Austin Appleby; SpookyHash 2.0 GB/s 10 Bob Jenkins; SBox 1.4 GB/s 9 Bret Mulvey; Lookup3 1.2 GB/s 9 Bob Jenkins; SuperFastHash 1.2 GB/s 1 Paul Hsieh; CityHash64 1.05 GB/s 10 Pike & Alakuijala; FNV 0.55 GB/s 5 Fowler, Noll, Vo; CRC32 0.43 GB/s 9; MD5-32 0.33 GB/s 10 Ronald L. Rivest; SHA1-32 0.28 GB/s 10. Q.Score is a measure of quality of the hash function.; It depends on successfully passing SMHasher test set.; 10 is a perfect score. Note: SMHasher's CRC32 implementation is not the fastest one.; Other speed-oriented implementations can be faster,; especially in combination with PCLMUL instruction:; https://fastcompression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:1641,update,update,1641,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['update'],['update']
Deployability,"ly as numeric convolution is computing; intensive and prone to stability fitting problems. If an analytic convolution; can be calculated, you should use that or implement it if not available.; RooNumConvolution implements reasonable defaults that should convolve most; functions reasonably well, but results strongly depend on the shape of your; input PDFS so always check your result. The default integration engine for the numeric convolution is the; adaptive Gauss-Kronrod method, which empirically seems the most robust; for this task. You can override the convolution integration settings via; the RooNumIntConfig object reference returned by the convIntConfig() member; function; By default the numeric convolution is integrated from -infinity to; +infinity through a <pre>x -> 1/x</pre> coordinate transformation of the; tails. For convolution with a very small bandwidth it may be; advantageous (for both CPU consumption and stability) if the; integration domain is limited to a finite range. The function; setConvolutionWindow(mean,width,scale) allows to set a sliding; window around the x value to be calculated taking a RooAbsReal; expression for an offset and a width to be taken around the x; value. These input expression can be RooFormulaVars or other; function objects although the 3d 'scale' argument 'scale'; multiplies the width RooAbsReal expression given in the 2nd; argument, allowing for an appropriate window definition for most; cases without need for a RooFormulaVar object: e.g. a Gaussian; resolution PDF do setConvolutionWindow(gaussMean,gaussSigma,5); Note that for a 'wide' Gaussian the -inf to +inf integration; may converge more quickly than that over a finite range!; The default numeric precision is 1e-7, i.e. the global default for; numeric integration but you should experiment with this value to; see if it is sufficient for example by studying the number of function; calls that MINUIT needs to fit your function as function of the; convolution precision.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx:2543,integrat,integration,2543,roofit/roofitcore/src/RooNumConvolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx,2,['integrat'],['integration']
Deployability,"manual; /// - backgroundRemove-logical variable, set if the removal of; /// background before deconvolution is desired; /// - deconIterations-number of iterations in deconvolution operation; /// - markov-logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow-averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method); ///; /// ### Peaks searching; ///; /// Goal: to identify automatically the peaks in spectrum with the presence of the; /// continuous background, one-fold coincidences (ridges) and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification in two-dimensional coincidence spectra are; ///; /// - non-sensitivity to noise, i.e., only statistically relevant peaks should be identified; /// - non-sensitivity of the algorithm to continuous background; /// - non-sensitivity to one-fold coincidences (coincidences peak - background in both dimensions) and their crossings; /// - ability to identify peaks close to the edges of the spectrum region. Usually peak finders fail to detect them; /// - resolution, decomposition of doublets and multiplets. The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma; ///; /// #### References:; ///; /// [1] M.A. Mariscotti: A method for identification of peaks in the presence of; /// background and its application to spectrum analysis. NIM 50 (1967), 309-320.; ///; /// [2] M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.:Identification; /// of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); /// 108-125.; ///; /// [3] Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; /// (1996), 451.; ///; /// ### Examples of peak searching method; ///; /// SearchHighRes function provides users with the possibility; /// to vary t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:1781,continuous,continuous,1781,hist/spectrum/src/TSpectrum2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx,1,['continuous'],['continuous']
Deployability,"mentation pages share a common set of javascript and CSS files. They; are generated automatically when running <a href=""#THtml:MakeAll"">MakeAll()</a>;; they can be generated on; demand by calling <a href=""#THtml:CreateAuxiliaryFiles"">CreateAuxiliaryFiles()</a>.</p>. <h3><a name=""charts"">VII. Class Charts</a></h3>; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged on-top of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies. These graphs are generated using the <a href=""http://www.graphviz.org/"">Graphviz</a>; package. You can install it from <a href=""http://www.graphviz.org"">http://www.graphviz.org</a>.; You can either put it into your $PATH, or tell THtml where to find it by calling; <a href=""#THtml:SetDotDir"">SetDotDir()</a>. <h3><a name=""confvar"">VIII. Configuration variables</a></h3>. <p>Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; <a href=""http://root.cern.ch/root/html/TEnv.html"">TEnv</a>.</p>. <pre>; Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; Root.Html.Root (default: ) - URL of Root's class documentation; Root.Html.SearchEngine (default: ) - link to the search engine; Root.Html.Search (default: ) - link to search by replacing ""%s"" with user input; Root.Html.ViewCVS (default: ) - URL of ViewCVS base; Roo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx:20983,configurat,configuration,20983,html/src/THtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx,1,['configurat'],['configuration']
Deployability,"more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes within the CGSCC walk,; /// and there we provide automatic update of the call graph including of the; /// pass manager to reflect call graph changes that fall out naturally as part; /// of scalar transformations.; ///; /// The patterns used to ensure the goals of post-order visitation of the fully; /// refined graph:; ///; /// 1) Sink toward the ""bottom"" as the graph is refined. This means that any; /// iteration continues in some valid post-order sequence after the mutation; /// has altered the structure.; ///; /// 2) Enqueue in post-order, including the current entity. If the current; /// entity's shape changes, it and everything after it in post-order needs; /// to be visited to observe that shape.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3994,update,update,3994,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,2,['update'],['update']
Deployability,"more general, ultimately unrelated to LLVM-IR; // attributes. The latter is useful when an abstract attributes provides; // information to other abstract attributes in-flight but we might not want to; // manifest the information. The Attributor allows to query in-flight abstract; // attributes through the `Attributor::getAAFor` method (see the method; // description for an example). If the method is used by an abstract attribute; // P, and it results in an abstract attribute Q, the Attributor will; // automatically capture a potential dependence from Q to P. This dependence; // will cause P to be reevaluated whenever Q changes in the future.; //; // The Attributor will only reevaluate abstract attributes that might have; // changed since the last iteration. That means that the Attribute will not; // revisit all instructions/blocks/functions in the module but only query; // an update from a subset of the abstract attributes.; //; // The update method `AbstractAttribute::updateImpl` is implemented by the; // specific ""abstract attribute"" subclasses. The method is invoked whenever the; // currently assumed state (see the AbstractState class) might not be valid; // anymore. This can, for example, happen if the state was dependent on another; // abstract attribute that changed. In every invocation, the update method has; // to adjust the internal state of an abstract attribute to a point that is; // justifiable by the underlying IR and the current state of abstract attributes; // in-flight. Since the IR is given and assumed to be valid, the information; // derived from it can be assumed to hold. However, information derived from; // other abstract attributes is conditional on various things. If the justifying; // state changed, the `updateImpl` has to revisit the situation and potentially; // find another justification or limit the optimistic assumes made.; //; // Change is the key in this framework. Until a state of no-change, thus a; // fixpoint, is reached, the Attrib",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:2130,update,update,2130,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,2,['update'],"['update', 'updateImpl']"
Deployability,"mplete //; // the name of a global object. (it is supported when trying to //; // complete a member of a global object) //; // //; // 7. the list of #pragma's is hardcoded //; // (ie not obtained from the interpreter at runtime) //; // ==> user-defined #pragma's will not be recognized //; // //; // 8. the system include directories are also hardcoded //; // because i don't know how to get them from the interpreter. //; // fons, maybe they should be #ifdef'd for the different sytems? //; // //; // 9. the TabCom.FileIgnore resource is always applied, even if you //; // are not trying to complete a filename. //; // //; // 10. anything in quotes is assumed to be a filename //; // so (among other things) you can't complete a quoted class name: //; // eg, TClass class1( ""TDict[TAB] //; // this won't work... looks for a file in pwd starting with TDict //; // //; // 11. the prototypes tend to omit the word ""const"" a lot. //; // this is a problem with ROOT or CINT. //; // //; // 12. when listing ambiguous matches, only one column is used, //; // even if there are many completions. //; // //; // 13. anonymous objects are not currently identified //; // so, for example, //; // //; // root> printf( TString([TAB //; // //; // gives an error message instead of listing TString's constructors. //; // (this could be fixed) //; // //; // 14. the routine that adds the ""appendage"" isn't smart enough to know //; // if it's already there: //; // //; // root> TCanvas::Update() //; // press [TAB] here ^ //; // root> TCanvas::Update()() //; // (this could be fixed) //; // //; // 15. the appendage is only applied if there is exactly 1 match. //; // eg, this //; // //; // root> G__at[TAB] //; // root> G__ateval //; // //; // happens instead of this //; // //; // root> G__at[TAB] //; // root> G__ateval( //; // //; // because there are several overloaded versions of G__ateval(). //; // (this could be fixed) //; // //; ////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TTabCom.cxx:3764,Update,Update,3764,core/rint/src/TTabCom.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TTabCom.cxx,2,['Update'],['Update']
Deployability,"n LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; * \class RooBinSamplingPdf; * The RooBinSamplingPdf is supposed to be used as an adapter between a continuous PDF; * and a binned distribution.; * When RooFit is used to fit binned data, and the PDF is continuous, it takes the probability density; * at the bin centre as a proxy for the probability averaged (integrated) over the entire bin. This is; * correct only if the second derivative of the function vanishes, though. This is shown in the plots; * below.; *; * For PDFs that have larger curvatures, the RooBinSamplingPdf can be used. It integrates the PDF in each; * bin using an adaptive integrator. This usually requires 21 times more function evaluations, but significantly; * reduces biases due to better sampling of the PDF. The integrator can be accessed from the outside; * using integrator(). This can be used to change the integration rules, so less/more function evaluations are; * performed. The target precision of the integrator can be set in the constructor.; *; *; * ### How to use it; * There are two ways to use this class:; * - Manually wrap a PDF:; * ```; * RooBinSamplingPdf binSampler(""<name>"", ""title"", <binned observable of PDF>, <original PDF> [, <precision for integrator>]);; * binSampler.fitTo(data);; * ```; * When a PDF is wrapped with a RooBinSamplingPDF, just use the bin sampling PDF instead of the original one for fits; * or plotting etc.; * \note The binning will be taken from the observable. Make sure that this binning is the same as the one of the dataset that should be fit.; * Use RooRealVar::setBinning() to adapt it.; * - Instruct test statistics to carry out this wrapping automatically:; * ```; * pdf.fitTo(data, IntegrateBins(<precision>));; * ```; * This method is especially useful when used with a simultaneous PDF, since each component will automatically be wrapped,; * depending on the value of `prec",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:1557,integrat,integration,1557,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,1,['integrat'],['integration']
Deployability,"n the tree/graph is written to the output buffer to avoid circular; dependencies. However if the object event is split into several files or into several; branches of one or more Trees, normal C++ pointers cannot be used because; each I/O operation will write the referenced objects. When a TRef is used to point to a TObject *robj, for example in a class with; ~~~ {.cpp}; TRef fRef;; ~~~; one can do:; ~~~ {.cpp}; fRef = robj; //to set the pointer; ~~~; This TRef and robj can be written with two different I/O calls; in the same or different files, in the same or different branches of a Tree. If the TRef is read and the referenced object has not yet been read,; the TRef will return a null pointer. As soon as the referenced object; will be read, the TRef will point to it. If the referenced object is; contained in a TTree it can be auto-loaded using the TBranchRef mechanism,; which is set up by simply calling TTree::BranchRef(). TRef also supports the complex situation where a TFile is updated; multiple times on the same machine or a different machine. ## How does it work. A TRef is itself a TObject with an additional transient pointer fPID.; When the statement fRef = robj is executed, the following actions happen:. - The pointer fPID is set to the current TProcessID.; - The current ObjectNumber (see below) is incremented by one.; - robj::fUniqueID is set to ObjectNumber.; - In the fPID object, the element fObjects[ObjectNumber] is set to robj; - ref::fUniqueID is also set to ObjectNumber. After having set fRef, one can immediately return the value of robj; using fRef.GetObject(). This function returns directly fObjects[fUniqueID]; from the fPID object. When the TRef is written, the process id number pidf of fPID is written; in addition to the TObject part of TRef (fBits,fUniqueID). When the TRef is read, its pointer fPID is set to the value; stored in the TObjArray of TFile::fProcessIDs (fProcessIDs[pidf]).; The pidf is stored as a UShort_t limiting a file to 65535 dist",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TRef.cxx:1909,update,updated,1909,core/base/src/TRef.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TRef.cxx,1,['update'],['updated']
Deployability,"n).; Instead, the choice of normalization is always specified each time a; normalized value is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; the help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform an entirely numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e., no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; common, etc). #### Implementing analytical integrals; To implement analytical integrals, two functions must be implemented. First,. ```; Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet); ```; should return the analytical integrals that are supported. `integSet`; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to `anaIntSet`, and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. ```; double analyticalIntegral(Int_t code); ```. implements the actual analytical integral(s) advertised by; `getAnalyticalIntegral()`. This function will only be called with; codes returned by `getAnalyticalIntegral()`, except code zero. The integration range for each dependent to be integrated can; be obtained from the dependent's proxy functions `min()` and; `max()`. Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g., in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. ### Direct generation of observables. Distributions for any",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:3457,integrat,integration,3457,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['integrat'],['integration']
Deployability,"name of the input function, the variables; /// it integrates and the range integrates over. The default strategy to calculate the running integrals is; ///; /// - If the integrand (this object) supports analytical integration, construct an integral object; /// that calculate the running integrals value by calculating the analytical integral each; /// time the running integral object is evaluated; ///; /// - If the integrand (this object) requires numeric integration to construct the running integral; /// create an object of class RooNumRunningInt which first samples the entire function and integrates; /// the sampled function numerically. This method has superior performance as there is no need to; /// perform a full (numeric) integration for each evaluation of the running integral object, but; /// only when one of its parameters has changed.; ///; /// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; /// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); /// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; /// granularity for the scanning technique can be controlled with the ScanParameters technique; /// which allows to specify the number of samples to be taken, and to which order the resulting; /// running integral should be interpolated. The default values are 1000 samples and 2nd order; /// interpolation.; ///; /// The following named arguments are accepted; /// | | Effect on integral creation; /// |-|-------------------------------; /// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in addition_ to the integration observables; /// | `ScanParameters(Int_t nbins, Int_t intOrder)` | Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf; /// | `ScanNum()` | Apply scanning technique if cdf integral involves numeric integration; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:1540,integrat,integrate,1540,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['integrat'],['integrate']
Deployability,"ndard deviation error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a `TPaveStats` object is created and added; to the list of functions of the histogram. If a `TPaveStats` object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters. Once a histogram is painted, the statistics box can be accessed using; `h->FindObject(""stats"")`. In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after `h->Draw()` the histogram is automatically painted. But; in a script file the painting should be forced using `gPad->Update()`; in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without `gPad->Update()` the line `h->FindObject(""stats"")` returns a null pointer. When a histogram is drawn with the option `SAME`, the statistics box; is not drawn. To force the statistics box drawing with the option; `SAME`, the option `SAMES` must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (`h` being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; `TPaveStats` one should do:. st->SetOptStat(mode);. Where `mode` has the same meaning than when calling `gStyle->SetOptStat(mode)`; (see above). One can delete the statistics box for a histogram `TH1* h` wi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:23819,Update,Update,23819,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['Update'],['Update']
Deployability,"ndianness> &HBuilder,; /// const SimpleStruct &Value) {; /// HBuilder.add(Value.c);; /// HBuilder.add(Value.i);; /// }; /// ```; ///; /// To avoid endianness issues, specializations of `addHash` should; /// generally rely on exising `add`, `addRange`, and `addRangeElements`; /// functions. If directly using `update`, an implementation must correctly; /// handle endianness.; ///; /// ```; /// struct __attribute__ ((packed)) StructWithFastHash {; /// int I;; /// char C;; ///; /// // If possible, we want to hash both `I` and `C` in a single; /// // `update` call for performance concerns.; /// template <typename HasherT, llvm::endianness Endianness>; /// friend void addHash(HashBuilder<HasherT, Endianness> &HBuilder,; /// const StructWithFastHash &Value) {; /// if (Endianness == llvm::endianness::native) {; /// HBuilder.update(ArrayRef(; /// reinterpret_cast<const uint8_t *>(&Value), sizeof(Value)));; /// } else {; /// // Rely on existing `add` methods to handle endianness.; /// HBuilder.add(Value.I);; /// HBuilder.add(Value.C);; /// }; /// }; /// };; /// ```; ///; /// To avoid collisions, specialization of `addHash` for variable-size; /// types must take the size into account.; ///; /// For example:; /// ```; /// struct CustomContainer {; /// private:; /// size_t Size;; /// int Elements[100];; ///; /// public:; /// CustomContainer(size_t Size) : Size(Size) {; /// for (size_t I = 0; I != Size; ++I); /// Elements[I] = I;; /// }; /// template <typename HasherT, llvm::endianness Endianness>; /// friend void addHash(HashBuilder<HasherT, Endianness> &HBuilder,; /// const CustomContainer &Value) {; /// if (Endianness == llvm::endianness::native) {; /// HBuilder.update(ArrayRef(; /// reinterpret_cast<const uint8_t *>(&Value.Size),; /// sizeof(Value.Size) + Value.Size * sizeof(Value.Elements[0])));; /// } else {; /// // `addRange` will take care of encoding the size.; /// HBuilder.addRange(&Value.Elements[0], &Value.Elements[0] +; /// Value.Size);; /// }; /// }; /// };; /// ```",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h:2244,update,update,2244,interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,1,['update'],['update']
Deployability,"ne that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. ```; // vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. // create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. // create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. // map all buttons; bg->Show();; ```. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. - Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; - Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; - Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. \class TGHButtonGroup; \ingroup guiwidgets. Organizes TGButton widgets in a group with one horizontal row. TGHButtonGroup is a; convenience class that offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. \class TGVButtonGroup; \ingroup guiwidgets. Organizes TGButton widgets in a group with one vertical column. TGVButtonGroup is a; convenience class that offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGButtonGroup.cxx:2281,Release,Released,2281,gui/gui/src/TGButtonGroup.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGButtonGroup.cxx,2,"['Release', 'release']","['Released', 'released']"
Deployability,"nfoldSys has an adjustable regularisation term and also supports an; optional constraint on the total number of events.; Background sources can be specified, with a normalisation constant and; normalisation uncertainty. In addition, variants of the response; matrix may be specified, these are taken to determine systematic; uncertainties. <b>For most applications, it is better to use the derived class; TUnfoldDensity instead of TUnfoldSys. TUnfoldDensity adds; features to TUnfoldSys, related to possible complex multidimensional; arrangements of bins. For innocent; users, the most notable improvement of TUnfoldDensity over TUnfoldSys are; the getter functions. For TUnfoldSys, histograms have to be booked by the; user and the getter functions fill the histogram bins. TUnfoldDensity; simply returns a new, already filled histogram.</b>. If you use this software, please consider the following citation. <b>S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]</b>. Detailed documentation and updates are available on; http://www.desy.de/~sschmitt. Brief recipy to use TUnfoldSys:; <ul>; <li>a matrix (truth,reconstructed) is given as a two-dimensional histogram; as argument to the constructor of TUnfold</li>; <li>a vector of measurements is given as one-dimensional histogram using; the SetInput() method</li>; <li>repeated calls to SubtractBackground() to specify background; sources</li>; <li>repeated calls to AddSysError() to specify systematic uncertainties; <li>The unfolding is performed; <ul>; <li>either once with a fixed parameter tau, method DoUnfold(tau)</li>; <li>or multiple times in a scan to determine the best chouce of tau,; method ScanLCurve()</li>; </ul>; <li>Unfolding results are retrieved using various GetXXX() methods; </ul>. Description of (systematic) uncertainties available in; TUnfoldSys. There are covariance matrix contributions and there are; systematic shifts. Systematic shifts correspond to the variation of a; (buicance) parameter, for example a background n",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx:2434,update,updates,2434,hist/unfold/src/TUnfoldSys.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx,1,['update'],['updates']
Deployability,"ng of OpenMP clause 'private', 'firstprivate', 'lastprivate',; /// 'shared', 'copyin', 'copyprivate', 'flush', 'reduction', 'task_reduction',; /// 'in_reduction', 'nontemporal', 'exclusive' or 'inclusive'.; ///; /// private-clause:; /// 'private' '(' list ')'; /// firstprivate-clause:; /// 'firstprivate' '(' list ')'; /// lastprivate-clause:; /// 'lastprivate' '(' list ')'; /// shared-clause:; /// 'shared' '(' list ')'; /// linear-clause:; /// 'linear' '(' linear-list [ ':' linear-step ] ')'; /// aligned-clause:; /// 'aligned' '(' list [ ':' alignment ] ')'; /// reduction-clause:; /// 'reduction' '(' [ modifier ',' ] reduction-identifier ':' list ')'; /// task_reduction-clause:; /// 'task_reduction' '(' reduction-identifier ':' list ')'; /// in_reduction-clause:; /// 'in_reduction' '(' reduction-identifier ':' list ')'; /// copyprivate-clause:; /// 'copyprivate' '(' list ')'; /// flush-clause:; /// 'flush' '(' list ')'; /// depend-clause:; /// 'depend' '(' in | out | inout : list | source ')'; /// map-clause:; /// 'map' '(' [ [ always [,] ] [ close [,] ]; /// [ mapper '(' mapper-identifier ')' [,] ]; /// to | from | tofrom | alloc | release | delete ':' ] list ')';; /// to-clause:; /// 'to' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// from-clause:; /// 'from' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// use_device_ptr-clause:; /// 'use_device_ptr' '(' list ')'; /// use_device_addr-clause:; /// 'use_device_addr' '(' list ')'; /// is_device_ptr-clause:; /// 'is_device_ptr' '(' list ')'; /// has_device_addr-clause:; /// 'has_device_addr' '(' list ')'; /// allocate-clause:; /// 'allocate' '(' [ allocator ':' ] list ')'; /// nontemporal-clause:; /// 'nontemporal' '(' list ')'; /// inclusive-clause:; /// 'inclusive' '(' list ')'; /// exclusive-clause:; /// 'exclusive' '(' list ')'; ///; /// For 'linear' clause linear-list may have the following forms:; /// list; /// modifier(list); /// where modifier is 'val' (C) or 'ref', 'val' or 'uval'(C++).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1160,release,release,1160,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,1,['release'],['release']
Deployability,"ng the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; /// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; /// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; /// The current defaults are (""Minuit"",""Migrad"").; /// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; /// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; /// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; /// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; ///; /// Other options are possible depending on the Minimizer used, see the co",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:5087,configurat,configuration,5087,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['configurat'],['configuration']
Deployability,"nk, blank+1);; while ((blank = strstr(temp,"", ""))) strcpy(blank+1,blank+2);; while ((blank = strstr(temp,"" ,""))) strcpy(blank, blank+1);; while ((blank = strstr(temp,"" ""))) strcpy(blank, blank+1);; //loop on tokens separated by ;; char *final = new char[1000];; char token[100];; while ((colon=strchr(temp,';'))) {; *colon = 0;; strlcpy(token,temp,100);; blank = strchr(token,' ');; if (blank) {; *blank = 0;; if (!gROOT->GetType(token)) {; Error(""SetStreamerInfo"",""Illegal type: %s in %s"",token,info);; return;; }; while (blank) {; strlcat(final,token,1000);; strlcat(final,"" "",1000);; comma = strchr(blank+1,','); if (comma) *comma=0;; strlcat(final,blank+1,1000);; strlcat(final,"";"",1000);; blank = comma;; }. } else {; if (TClass::GetClass(token,update)) {; //a class name; strlcat(final,token,1000); strlcat(final,"";"",1000);; } else {; //a data member name; dm = (TDataMember*)GetListOfDataMembers()->FindObject(token);; if (dm) {; strlcat(final,dm->GetFullTypeName(),1000);; strlcat(final,"" "",1000);; strlcat(final,token,1000); strlcat(final,"";"",1000);; } else {; Error(""SetStreamerInfo"",""Illegal name: %s in %s"",token,info);; return;; }; }; update = kFALSE;; }; temp = colon+1;; if (*temp == 0) break;; }; //// fStreamerInfo = final;; delete [] final;; delete [] save;; return;; }. //info is empty. Let's build the default Streamer descriptor. char *temp = new char[10000];; temp[0] = 0;; char local[100];. //add list of base classes; TIter nextb(GetListOfBases());; TBaseClass *base;; while ((base = (TBaseClass*) nextb())) {; snprintf(local,100,""%s;"",base->GetName());; strlcat(temp,local,10000);; }. //add list of data members and types; TIter nextd(GetListOfDataMembers());; while ((dm = (TDataMember *) nextd())) {; if (dm->IsEnum()) continue;; if (!dm->IsPersistent()) continue;; Long_t property = dm->Property();; if (property & kIsStatic) continue;; TClass *acl = TClass::GetClass(dm->GetTypeName(),update);; update = kFALSE;; if (acl) {; if (acl->GetClassVersion() == 0) continue;; }.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:1491,update,update,1491,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,2,['update'],['update']
Deployability,"note pixel coverage; * of the color or luminance channels and is returned as an associated alpha; * channel: the color/gray channels are scaled (pre-multiplied) by the alpha; * value.; *; * The samples are either contained directly in the image data, between 1 and 8; * bytes per pixel according to the encoding, or are held in a color-map indexed; * by bytes in the image data. In the case of a color-map the color-map entries; * are individual samples, encoded as above, and the image data has one byte per; * pixel to select the relevant sample from the color-map.; */; /* PNG_FORMAT_*; *; * #defines to be used in png_image::format. Each #define identifies a; * particular layout of sample data and, if present, alpha values. There are; * separate defines for each of the two component encodings.; *; * A format is built up using single bit flag values. All combinations are; * valid. Formats can be built up from the flag values or you can use one of; * the predefined values below. When testing formats always use the FORMAT_FLAG; * macros to test for individual features - future versions of the library may; * add new flags.; *; * When reading or writing color-mapped images the format should be set to the; * format of the entries in the color-map then png_image_{read,write}_colormap; * called to read or write the color-map and set the format correctly for the; * image data. Do not set the PNG_FORMAT_FLAG_COLORMAP bit directly!; *; * NOTE: libpng can be built with particular features disabled. If you see; * compiler errors because the definition of one of the following flags has been; * compiled out it is because libpng does not have the required support. It is; * possible, however, for the libpng configuration to enable the format on just; * read or just write; in that case you may see an error at run time. You can; * guard against this by checking for the definition of the appropriate; * ""_SUPPORTED"" macro, one of:; *; * PNG_SIMPLIFIED_{READ,WRITE}_{BGR,AFIRST}_SUPPORTED; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:3226,configurat,configuration,3226,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['configurat'],['configuration']
Deployability,"nsing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class RooStats::BayesianCalculator; \ingroup Roostats. BayesianCalculator is a concrete implementation of IntervalCalculator, providing the computation; of a credible interval using a Bayesian method.; The class works only for one single parameter of interest and it integrates the likelihood function with the given prior; probability density function to compute the posterior probability. The result of the class is a one dimensional interval; (class SimpleInterval ), which is obtained from inverting the cumulative posterior distribution.; This calculator works then only for model with a single parameter of interest.; The model can instead have several nuisance parameters which are integrated (marginalized) in the computation of the posterior function.; The integration and normalization of the posterior is computed using numerical integration methods provided by ROOT.; See the MCMCCalculator for model with multiple parameters of interest. The interface allows one to construct the class by passing the data set, probability density function for the model, the prior; functions and then the parameter of interest to scan. The nuisance parameters can also be passed to be marginalized when; computing the posterior. Alternatively, the class can be constructed by passing the data and the ModelConfig containing; all the needed information (model pdf, prior pdf, parameter of interest, nuisance parameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extreme of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by; scanning the posterior function in the given number of points. The first method is in",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:1230,integrat,integration,1230,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,2,['integrat'],['integration']
Deployability,"nt as long as they are; /// consistent. Inaccuracies arise when instructions have different execution; /// delays relative to each other, in addition to their intrinsic latency. Those; /// special cases can be handled by TableGen constructs such as, ReadAdvance,; /// which reduces latency when reading data, and ReleaseAtCycles, which consumes; /// a processor resource when writing data for a number of abstract; /// cycles.; ///; /// TODO: One tool currently missing is the ability to add a delay to; /// ReleaseAtCycles. That would be easy to add and would likely cover all cases; /// currently handled by the legacy itinerary tables.; ///; /// A note on out-of-order execution and, more generally, instruction; /// buffers. Part of the CPU pipeline is always in-order. The issue point, which; /// is the point of reference for counting cycles, only makes sense as an; /// in-order part of the pipeline. Other parts of the pipeline are sometimes; /// falling behind and sometimes catching up. It's only interesting to model; /// those other, decoupled parts of the pipeline if they may be predictably; /// resource constrained in a way that the scheduler can exploit.; ///; /// The LLVM machine model distinguishes between in-order constraints and; /// out-of-order constraints so that the target's scheduling strategy can apply; /// appropriate heuristics. For a well-balanced CPU pipeline, out-of-order; /// resources would not typically be treated as a hard scheduling; /// constraint. For example, in the GenericScheduler, a delay caused by limited; /// out-of-order resources is not directly reflected in the number of cycles; /// that the scheduler sees between issuing an instruction and its dependent; /// instructions. In other words, out-of-order resources don't directly increase; /// the latency between pairs of instructions. However, they can still be used; /// to detect potential bottlenecks across a sequence of instructions and bias; /// the scheduling heuristics appropriately.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:2626,pipeline,pipeline,2626,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,2,['pipeline'],['pipeline']
Deployability,"ntry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; /// cycles were spent in the scheduler's queue due to data dependencies.; ///; /// In this example, instruction 5 spent an average of ~6 cycles in the; /// scheduler's queue. As soon as operands became ready, the instruction; /// was immediately issued to the pipeline(s).; /// That is expected because instruction 5 cannot transition to the ""ready""; /// state until %xmm4 is written by instruction 4.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:4295,pipeline,pipeline,4295,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,1,['pipeline'],['pipeline']
Deployability,"number of input data).; /// \param[in] xout an optional set of values specifying where interpolation is to; /// take place.; /// \param[in] yleft the value to be returned when input x values less than min(x).; /// The default is defined by the value of rule given below.; /// \param[in] yright the value to be returned when input x values greater than max(x).; /// The default is defined by the value of rule given below.; /// \param[in] rule an integer describing how interpolation is to take place outside; /// the interval [min(x), max(x)]. If rule is 0 then the given yleft; /// and yright values are returned, if it is 1 then 0 is returned; /// for such points and if it is 2, the value at the closest data; /// extreme is used.; /// \param[in] f For method=""constant"" a number between 0 and 1 inclusive,; /// indicating a compromise between left- and right-continuous step; /// functions. If y0 and y1 are the values to the left and right of; /// the point then the value is y0*f+y1*(1-f) so that f=0 is; /// right-continuous and f=1 is left-continuous; /// \param[in] ties Handling of tied x values. An integer describing a function with; /// a single vector argument returning a single number result:; /// - ties = ""ordered"" (iTies = 0): input x are ""ordered""; /// - ties = ""mean"" (iTies = 1): function ""mean""; /// - ties = ""min"" (iTies = 2): function ""min""; /// - ties = ""max"" (iTies = 3): function ""max""; ///; /// Details:; ///; /// At least two complete (x, y) pairs are required.; /// If there are duplicated (tied) x values and ties is a function it is; /// applied to the y values for each distinct x value. Useful functions in; /// this context include mean, min, and max.; /// If ties=""ordered"" the x values are assumed to be already ordered. The; /// first y value will be used for interpolation to the left and the last; /// one for interpolation to the right.; ///; /// Value:; ///; /// approx returns a graph with components x and y, containing n coordinates; /// which interpolat",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:1588,continuous,continuous,1588,hist/hist/src/TGraphSmooth.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx,2,['continuous'],['continuous']
Deployability,"oRealVar zeta(""zeta"", ""zeta"", 0.);; * RooRealVar lambda(""lambda"", ""lambda"", -1., -10., -0.00001);; * ```; * In all other cases, slower / less accurate numeric integration will be used.; * Note that including `0.` in the value range of lambda excludes using analytic integrals.; * \endif; *; * ### Concavity; * Note that unless the parameters \f$ a_l,\ a_r \f$ are very large, the function has non-hyperbolic tails. This requires; * \f$ G \f$ to be strictly concave, *i.e.*, peaked, as otherwise the tails would yield imaginary numbers. Choosing \f$ \lambda,; * \beta, \zeta \f$ inappropriately will therefore lead to evaluation errors.; *; * Further, the original paper establishes that to keep the tails from rising,; * \f[; * \begin{split}; * \beta^2 &< \alpha^2 \\; * \Leftrightarrow \beta^2 &< \frac{\zeta^2}{\delta^2} = \frac{\zeta^2}{\sigma^2 A_{\lambda}^2(\zeta)}; * \end{split}; * \f]; * needs to be satisfied, unless the fit range is very restricted, because otherwise, the function rises in the tails.; *; *; * In case of evaluation errors, it is advisable to choose very large values for \f$ a_l,\ a_r \f$, tweak the parameters of the core region to; * make it concave, and re-enable the tails. Especially \f$ \beta \f$ needs to be close to zero.; *; * ## Relation to RooIpatia2; * This implementation is largely based on RooIpatia2, https://gitlab.cern.ch/lhcb/Urania/-/blob/master/PhysFit/B2DXFitters/src/RooIpatia2.cxx,; * but there are differences:; * - At construction time, the Hypatia implementation checks if the range of parameters extends into regions where; * the function might be undefined.; * - Hypatia supports I/O to ROOT files.; * - Hypatia will support faster batched function evaluations.; * - Hypatia might support analytical integration for the case \f$ \zeta = \beta = 0, \lambda < 1 \f$.; *; * Because of these differences, and to avoid name clashes for setups where RooFit is used in an environment that also has; * RooIpatia2, class names need to be different.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooHypatia2.cxx:4412,integrat,integration,4412,roofit/roofitmore/src/RooHypatia2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooHypatia2.cxx,1,['integrat'],['integration']
Deployability,"od bin-by-bin with a template histogram model based on the obersved data.; * This results in per-bin values that are all in the same order of magnitude, which reduces precision loss in the sum,; * which can drastically improve numeric stability.; * Furthermore, \f$2\cdot \text{NLL}\f$ defined like this is approximately chi-square distributed, allowing for goodness-of-fit tests.; * </table>; * <tr><td> `IntegrateBins(double precision)` <td> In binned fits, integrate the PDF over the bins instead of using the probability density at the bin centre.; * This can reduce the bias observed when fitting functions with high curvature to binned data.; * - precision > 0: Activate bin integration everywhere. Use precision between 0.01 and 1.E-6, depending on binning.; * Note that a low precision such as 0.01 might yield identical results to 1.E-4, since the integrator might reach 1.E-4 already in its first; * integration step. If lower precision is desired (more speed), a RooBinSamplingPdf has to be created manually, and its integrator; * has to be manipulated directly.; * - precision = 0: Activate bin integration only for continuous PDFs fit to a RooDataHist.; * - precision < 0: Deactivate.; * \see RooBinSamplingPdf; * <tr><td> `ModularL(bool flag)` <td> Enable or disable modular likelihoods, which will become the default in a future release.; * This does not change any user-facing code, but only enables a different likelihood class in the back-end. Note that this; * should be set to true for parallel minimization of likelihoods!; * Note that it is currently not recommended to use Modular likelihoods without any parallelization enabled in the minimization, since; * some features such as offsetting might not yet work in this case.; * </table>; */; /** @brief Protected implementation of the NLL creation routine.; *; * This virtual function can be overridden in case you want to change the NLL creation logic for custom PDFs.; *; * \note Never call this function directly. Instead, c",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:9653,integrat,integrator,9653,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['integrat'],['integrator']
Deployability,"of the A4 area; in this case larger margins are not necessary; and Type=1 or 2 can be used.; - 3 : Encapsulated PostScript. This Type permits the generation of files; which can be included in other documents, for example in LaTeX files. ## Making several pictures in the same Postscript file: case 1. The following macro is an example illustrating how to open a Postscript; file and draw several pictures. The generation of a new Postscript page; is automatic when `TCanvas::Clear` is called by `object->Draw()`. ~~~ {.cpp}; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. // select postscript output type; // type = 111 portrait ps; // type = 112 landscape ps; // type = 113 eps; Int_t type = 111;. // create a postscript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page. // draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a macro; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }; ~~~. ## Making several pictures in the same Postscript file: case 2. This example shows 2 pages. The canvas is divided.; `TPostScript::NewPage` must be called before starting a new; picture.`object->Draw` does not clear the canvas in this case; because we clear only the pads and not the main canvas.; Note that `c1->Update` must be called at the end of the first picture. ~~~ {.cpp}; {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; TPostScript *ps = new TPostScript(""file.ps"",112);; c1->Divide(2,1);; // picture 1; ps->NewPage();; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();; c1->Update();. // picture 2; ps->NewPage();; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Update();; ps->Close();. // invoke Postscript viewer; gSystem->Exec(""gs file.ps"");; }; ~~~. ## Making several pictures in the same Postscript file: case 3; This is the recommended way. If the Postscript file name finishes with; ""(""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TPostScript.cxx:4458,Update,Update,4458,graf2d/postscript/src/TPostScript.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TPostScript.cxx,1,['Update'],['Update']
Deployability,"ome to the Lund Monte Carlo! | |; | | P P Y Y T H H I A A This is PYTHIA version 8.100 | |; | | PPP Y T HHHHH I AAAAA Last date of change: 20 Oct 2007 | |; | | P Y T H H I A A | |; | | P Y T H H III A A Now is 27 Oct 2007 at 18:26:53 | |; | | | |; | | Main author: Torbjorn Sjostrand; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Department of Theoretical Physics, Lund University, Lund, Sweden; | |; | | phone: + 41 - 22 - 767 82 27; e-mail: torbjorn@thep.lu.se | |; | | Author: Stephen Mrenna; Computing Division, Simulations Group, | |; | | Fermi National Accelerator Laboratory, MS 234, Batavia, IL 60510, USA; | |; | | phone: + 1 - 630 - 840 - 2556; e-mail: mrenna@fnal.gov | |; | | Author: Peter Skands; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Theoretical Physics Department, | |; | | Fermi National Accelerator Laboratory, MS 106, Batavia, IL 60510, USA; | |; | | phone: + 41 - 22 - 767 24 59; e-mail: skands@fnal.gov | |; | | | |; | | The main program reference is the 'Brief Introduction to PYTHIA 8.1', | |; | | T. Sjostrand, S. Mrenna and P. Skands, arXiv:0710.3820 | |; | | | |; | | The main physics reference is the 'PYTHIA 6.4 Physics and Manual', | |; | | T. Sjostrand, S. Mrenna and P. Skands, JHEP05 (2006) 026 [hep-ph/0603175]. | |; | | | |; | | An archive of program versions and documentation is found on the web: | |; | | http://www.thep.lu.se/~torbjorn/Pythia.html | |; | | | |; | | This program is released under the GNU General Public Licence version 2. | |; | | Please respect the MCnet Guidelines for Event Generator Authors and Users. | |; | | | |; | | Disclaimer: this program comes without any guarantees. | |; | | Beware of errors and use common sense when interpreting results. | |; | | | |; | | Copyright (C) 2007 Torbjorn Sjostrand | |; | | | |; | | | |; | *------------------------------------------------------------------------------* |; | |; *------------------------------------------------------------------------------------*; \endverbatim; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/pythia8/src/TPythia8.cxx:2680,release,released,2680,montecarlo/pythia8/src/TPythia8.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/pythia8/src/TPythia8.cxx,1,['release'],['released']
Deployability,"onding to N events; # and the extended term is Pois(N|S+B); #; # - fractional form: non-extended PDF of some discriminating variable m:; # eg: P(m) ~ s*fs(m) + (1-s)*fb(m), where s is a signal fraction; # in this case the dataset has N rows corresponding to N events; # and there is no extended term; #; # - number counting form: in which there is no discriminating variable; # and the counts are modeled directly (see HybridInstructional); # eg: P(N) = Pois(N|S+B); # in this case the dataset has 1 row corresponding to N events; # and the extended term is the PDF itself.; #; # Here we convert the number counting form into the standard form by; # introducing a dummy discriminating variable m with a uniform distribution.; #; # This example:; # - demonstrates the usage of the HybridCalcultor (Part 4-6); # - demonstrates the numerical integration of RooFit (Part 2); # - validates the RooStats against an example with a known analytic answer; # - demonstrates usage of different test statistics; # - explains subtle choices in the prior used for hybrid methods; # - demonstrates usage of different priors for the nuisance parameters; # - demonstrates usage of PROOF; #; # The basic setup here is that a main measurement has observed x events with an; # expectation of s+b. One can choose an ad hoc prior for the uncertainty on b,; # or try to base it on an auxiliary measurement. In this case, the auxiliary; # measurement (aka control measurement, sideband) is another counting experiment; # with measurement y and expectation tau*b. With an 'original prior' on b,; # called \f$ \eta(b) \f$ then one can obtain a posterior from the auxiliary measurement; # \f$ \pi(b) = \eta(b) * Pois(y|tau*b) \f$. This is a principled choice for a prior; # on b in the main measurement of x, which can then be treated in a hybrid; # Bayesian/Frequentist way. Additionally, one can try to treat the two; # measurements simultaneously, which is detailed in Part 6 of the tutorial.; #; # This tutorial is related ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/HybridStandardForm.py:1493,integrat,integration,1493,tutorials/roostats/HybridStandardForm.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/HybridStandardForm.py,1,['integrat'],['integration']
Deployability,"ontinuous PDF; * and a binned distribution.; * When RooFit is used to fit binned data, and the PDF is continuous, it takes the probability density; * at the bin centre as a proxy for the probability averaged (integrated) over the entire bin. This is; * correct only if the second derivative of the function vanishes, though. This is shown in the plots; * below.; *; * For PDFs that have larger curvatures, the RooBinSamplingPdf can be used. It integrates the PDF in each; * bin using an adaptive integrator. This usually requires 21 times more function evaluations, but significantly; * reduces biases due to better sampling of the PDF. The integrator can be accessed from the outside; * using integrator(). This can be used to change the integration rules, so less/more function evaluations are; * performed. The target precision of the integrator can be set in the constructor.; *; *; * ### How to use it; * There are two ways to use this class:; * - Manually wrap a PDF:; * ```; * RooBinSamplingPdf binSampler(""<name>"", ""title"", <binned observable of PDF>, <original PDF> [, <precision for integrator>]);; * binSampler.fitTo(data);; * ```; * When a PDF is wrapped with a RooBinSamplingPDF, just use the bin sampling PDF instead of the original one for fits; * or plotting etc.; * \note The binning will be taken from the observable. Make sure that this binning is the same as the one of the dataset that should be fit.; * Use RooRealVar::setBinning() to adapt it.; * - Instruct test statistics to carry out this wrapping automatically:; * ```; * pdf.fitTo(data, IntegrateBins(<precision>));; * ```; * This method is especially useful when used with a simultaneous PDF, since each component will automatically be wrapped,; * depending on the value of `precision`:; * - `precision < 0.`: None of the PDFs are touched, bin sampling is off.; * - `precision = 0.`: Continuous PDFs that are fit to a RooDataHist are wrapped into a RooBinSamplingPdf. The target precision; * forwarded to the integrator is",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:1911,integrat,integrator,1911,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,1,['integrat'],['integrator']
Deployability,"ort ROOT; RDataFrame = ROOT.RDF.Experimental.Distributed.[BACKEND].RDataFrame. if __name__ == ""__main__"":; df = RDataFrame(""mytree"",""myfile.root"").Define(""x"",""someoperation""); # The model can be passed either as a tuple with the arguments in the correct order; df.Histo1D((""name"", ""title"", 10, 0, 10), ""x""); # Or by creating the specific struct; model = ROOT.RDF.TH1DModel(""name"", ""title"", 10, 0, 10); df.Histo1D(model, ""x""); ~~~. Without this, two partial histograms resulting from two distributed tasks would have incompatible binning, thus leading; to errors when merging them. Failing to pass a histogram model will raise an error on the client side, before starting; the distributed execution. ### Live visualization in distributed mode with dask. The live visualization feature allows real-time data representation of plots generated during the execution ; of a distributed RDataFrame application. ; It enables visualizing intermediate results as they are computed across multiple nodes of a Dask cluster; by creating a canvas and continuously updating it as partial results become available. . The LiveVisualize() function can be imported from the Python package **ROOT.RDF.Experimental.Distributed**:. ~~~{.py}; import ROOT. LiveVisualize = ROOT.RDF.Experimental.Distributed.LiveVisualize; ~~~. The function takes drawable objects (e.g. histograms) and optional callback functions as argument, it accepts 4 different input formats:. - Passing a list or tuple of drawables: ; You can pass a list or tuple containing the plots you want to visualize. For example:. ~~~{.py}; LiveVisualize([h_gaus, h_exp, h_random]); ~~~. - Passing a list or tuple of drawables with a global callback function: ; You can also include a global callback function that will be applied to all plots. For example:. ~~~{.py}; def set_fill_color(hist):; hist.SetFillColor(ROOT.kBlue). LiveVisualize([h_gaus, h_exp, h_random], set_fill_color); ~~~. - Passing a Dictionary of drawables and callback functions: ; For more c",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:45348,continuous,continuously,45348,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['continuous'],['continuously']
Deployability,"ort warnings for Clang modules.; /// 3. Analyze live DIEs and type names(if ODR deduplication is requested).; /// 4. Clone DIEs(Generate output DIEs and resulting DWARF tables).; /// The result is in an OutDebugInfoBytes, which is an ELF file; /// containing DWARF tables corresponding to the current compile unit.; /// 5. Cleanup Input and Output DIEs.; /// }; ///; /// Deallocate loaded Object file.; /// }; ///; /// if (ODR deduplication is requested); /// Generate an artificial compilation unit (""Type Table"": used to partially; /// generate DIEs at the clone stage).; ///; /// for_each (ObjectFile) {; /// for_each (Compile Unit) {; /// 1. Set offsets to Compile Units DWARF tables.; /// 2. Sort offsets/attributes/patches to have a predictable result.; /// 3. Patch size/offsets fields.; /// 4. Generate index tables.; /// 5. Move DWARF tables of compile units into the resulting file.; /// }; /// }; ///; /// Every compile unit is processed separately, visited only once; /// (except case inter-CU references exist), and used data is freed; /// after the compile unit is processed. The resulting file is glued together; /// from the generated debug tables which correspond to separate compile units.; ///; /// Handling inter-CU references: inter-CU references are hard to process; /// using only one pass. f.e. if CU1 references CU100 and CU100 references; /// CU1, we could not finish handling of CU1 until we finished CU100.; /// Thus we either need to load all CUs into the memory, either load CUs several; /// times. This implementation loads inter-connected CU into memory at the first; /// pass and processes them at the second pass.; ///; /// ODR deduplication: Artificial compilation unit will be constructed to keep; /// type dies. All types are moved into that compilation unit. Type's references; /// are patched so that they point to the corresponding types from artificial; /// compilation unit. All partial type definitions would be merged into single; /// type definition.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h:2907,patch,patched,2907,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h,1,['patch'],['patched']
Deployability,"osen state that evaluates; /// to \f$ 1 - \sum_i(a_i) \f$ where \f$ a_i \f$ are all other specializations. For example,; /// given a category \f$ c \f$ with the states `""A"",""B"",""C"",""D""`, the specification; /// ```; /// SplitParamConstrained(""m"",""c"",""D""); /// ```; /// will create the parameters \f$ m_A,m_B,m_C \f$ and a formula expression \f$ m_D \f$; /// that evaluates to \f$ (1-(m_A+m_B+m_C)) \f$. Constrained splits can also be; /// specified in the product of categories. In that case, the name of the; /// remainder state follows the syntax `""{State1;State2}""`, where `State1` and; /// `State2` are the state names of the two spitting categories.; ///; /// ## Splitting multiple PDFs; /// The examples so far deal with a single prototype PDF. It is also; /// possible to build with multiple prototype PDFs by specifying a; /// mapping between the prototype to use and the names of states of; /// a ""master"" splitting category. To specify these configurations,; /// an intermediate `MultiBuildConfig` must be composed with all; /// the necessary specifications. This, for example,; /// ```; /// RooSimWSTool::MultiBuildConfig mbc(""mc"");; /// mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c""));; /// mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d""));; /// ```; /// configures a build with two prototype PDFs \f$ G \f$ and \f$ F \f$.; /// Prototype \f$ G \f$ is used for state `""I""` of the master split category; /// `mc` and prototype \f$ F \f$ is used for states `""II""` and `""III""` of the; /// master split category `mc`. Furthermore, the parameters \f$ m,s \f$ of; /// prototype \f$ G \f$ are split; /// in category \f$ c \f$ while the parameter \f$ a \f$ of prototype \f$ F \f$ is split in; /// the product of the categories \f$ c \f$ and \f$ d \f$. The actual build is then; /// performed by passing the build configuration to RooSimWSTool, *e.g.*,; /// ```; /// wst.build(""MASTER"", mbc);; /// ```; /// By default, a specialisation is built for each permutation of; /// states of the splitting categorie",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimWSTool.cxx:3381,configurat,configurations,3381,roofit/roofitcore/src/RooSimWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimWSTool.cxx,1,['configurat'],['configurations']
Deployability,"ound the notion of an ""issue point"". This; /// is merely a reference point for counting machine cycles. The physical; /// machine will have pipeline stages that delay execution. The scheduler does; /// not model those delays because they are irrelevant as long as they are; /// consistent. Inaccuracies arise when instructions have different execution; /// delays relative to each other, in addition to their intrinsic latency. Those; /// special cases can be handled by TableGen constructs such as, ReadAdvance,; /// which reduces latency when reading data, and ReleaseAtCycles, which consumes; /// a processor resource when writing data for a number of abstract; /// cycles.; ///; /// TODO: One tool currently missing is the ability to add a delay to; /// ReleaseAtCycles. That would be easy to add and would likely cover all cases; /// currently handled by the legacy itinerary tables.; ///; /// A note on out-of-order execution and, more generally, instruction; /// buffers. Part of the CPU pipeline is always in-order. The issue point, which; /// is the point of reference for counting cycles, only makes sense as an; /// in-order part of the pipeline. Other parts of the pipeline are sometimes; /// falling behind and sometimes catching up. It's only interesting to model; /// those other, decoupled parts of the pipeline if they may be predictably; /// resource constrained in a way that the scheduler can exploit.; ///; /// The LLVM machine model distinguishes between in-order constraints and; /// out-of-order constraints so that the target's scheduling strategy can apply; /// appropriate heuristics. For a well-balanced CPU pipeline, out-of-order; /// resources would not typically be treated as a hard scheduling; /// constraint. For example, in the GenericScheduler, a delay caused by limited; /// out-of-order resources is not directly reflected in the number of cycles; /// that the scheduler sees between issuing an instruction and its dependent; /// instructions. In other words, out",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:2302,pipeline,pipeline,2302,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['pipeline'],['pipeline']
Deployability,"plate <typename HasherT, llvm::endianness Endianness>; /// void addHash(HashBuilder<HasherT, Endianness> &HBuilder,; /// const SimpleStruct &Value) {; /// HBuilder.add(Value.c);; /// HBuilder.add(Value.i);; /// }; /// ```; ///; /// To avoid endianness issues, specializations of `addHash` should; /// generally rely on exising `add`, `addRange`, and `addRangeElements`; /// functions. If directly using `update`, an implementation must correctly; /// handle endianness.; ///; /// ```; /// struct __attribute__ ((packed)) StructWithFastHash {; /// int I;; /// char C;; ///; /// // If possible, we want to hash both `I` and `C` in a single; /// // `update` call for performance concerns.; /// template <typename HasherT, llvm::endianness Endianness>; /// friend void addHash(HashBuilder<HasherT, Endianness> &HBuilder,; /// const StructWithFastHash &Value) {; /// if (Endianness == llvm::endianness::native) {; /// HBuilder.update(ArrayRef(; /// reinterpret_cast<const uint8_t *>(&Value), sizeof(Value)));; /// } else {; /// // Rely on existing `add` methods to handle endianness.; /// HBuilder.add(Value.I);; /// HBuilder.add(Value.C);; /// }; /// }; /// };; /// ```; ///; /// To avoid collisions, specialization of `addHash` for variable-size; /// types must take the size into account.; ///; /// For example:; /// ```; /// struct CustomContainer {; /// private:; /// size_t Size;; /// int Elements[100];; ///; /// public:; /// CustomContainer(size_t Size) : Size(Size) {; /// for (size_t I = 0; I != Size; ++I); /// Elements[I] = I;; /// }; /// template <typename HasherT, llvm::endianness Endianness>; /// friend void addHash(HashBuilder<HasherT, Endianness> &HBuilder,; /// const CustomContainer &Value) {; /// if (Endianness == llvm::endianness::native) {; /// HBuilder.update(ArrayRef(; /// reinterpret_cast<const uint8_t *>(&Value.Size),; /// sizeof(Value.Size) + Value.Size * sizeof(Value.Elements[0])));; /// } else {; /// // `addRange` will take care of encoding the size.; /// HBuilder.addR",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h:1392,update,update,1392,interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,1,['update'],['update']
Deployability,"plementing analytical integrals; To implement analytical integrals, two functions must be implemented. First,. ```; Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet); ```; should return the analytical integrals that are supported. `integSet`; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to `anaIntSet`, and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. ```; double analyticalIntegral(Int_t code); ```. implements the actual analytical integral(s) advertised by; `getAnalyticalIntegral()`. This function will only be called with; codes returned by `getAnalyticalIntegral()`, except code zero. The integration range for each dependent to be integrated can; be obtained from the dependent's proxy functions `min()` and; `max()`. Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g., in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. ### Direct generation of observables. Distributions for any PDF can be generated with the accept/reject method,; but for certain PDFs, more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. ```; Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars); ```; and; ```; void generateEvent(Int_t code); ```. The first function advertises observables, for which distributions can be generated,; similar to the way analytical integrals are advertised. The second; function implements the actual generator for the advertised observables. The generated dependent values should be stored in the proxy; objects. For this, the ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:4186,integrat,integration,4186,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['integrat'],['integration']
Deployability,"r DBG_VALUE_LIST), and the DBG_VALUE inst that; /// specifies the location. Each VarLoc is indexed in the (function-scope) \p; /// VarLocMap, giving each VarLoc a set of unique indexes, each of which; /// corresponds to one of the VarLoc's machine-locations and can be used to; /// lookup the VarLoc in the VarLocMap. Rather than operate directly on machine; /// locations, the dataflow analysis in this pass identifies locations by their; /// indices in the VarLocMap, meaning all the variable locations in a block can; /// be described by a sparse vector of VarLocMap indicies.; ///; /// All the storage for the dataflow analysis is local to the ExtendRanges; /// method and passed down to helper methods. ""OutLocs"" and ""InLocs"" record the; /// in and out lattice values for each block. ""OpenRanges"" maintains a list of; /// variable locations and, with the ""process"" method, evaluates the transfer; /// function of each block. ""flushPendingLocs"" installs debug value instructions; /// for each live-in location at the start of blocks, while ""Transfers"" records; /// transfers of values between machine-locations.; ///; /// We avoid explicitly representing the ""Unknown"" (\top) lattice value in the; /// implementation. Instead, unvisited blocks implicitly have all lattice; /// values set as ""Unknown"". After being visited, there will be path back to; /// the entry block where the lattice value is ""False"", and as the transfer; /// function cannot make new ""Unknown"" locations, there are no scenarios where; /// a block can have an ""Unknown"" location after being visited. Similarly, we; /// don't enumerate all possible variable locations before exploring the; /// function: when a new location is discovered, all blocks previously explored; /// were implicitly ""False"" but unrecorded, and become explicitly ""False"" when; /// a new VarLoc is created with its bit not set in predecessor InLocs or; /// OutLocs.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:5504,install,installs,5504,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,1,['install'],['installs']
Deployability,"r GrP0; ### Introduction. Graphs are drawn via the painter `TGraphPainter` class. This class; implements techniques needed to display the various kind of; graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`. To draw a graph `graph` it's enough to do:. graph->Draw(""AL"");. The option `AL` in the `Draw()` method means:. 1. The axis should be drawn (option `A`),; 2. The graph should be drawn as a simple line (option `L`). By default a graph is drawn in the current pad in the current coordinate system.; To define a suitable coordinate system and draw the axis the option; `A` must be specified. `TGraphPainter` offers many options to paint the various kind of graphs. It is separated from the graph classes so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is no need to call `Draw()` again; the; image will be refreshed the next time the pad will be updated. A pad is updated; after one of these three actions:. 1. a carriage return on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. \anchor GrP1; ### Graphs' plotting options; Graphs can be drawn with the following options:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""A"" | Produce a new plot with Axis around the graph |; | ""I"" | Combine with option 'A' it draws invisible axis |; | ""L"" | A simple polyline is drawn |; | ""F"" | A fill area is drawn ('CF' draw a smoothed fill area) |; | ""C"" | A smooth Curve is drawn |; | ""*"" | A Star is plotted at each point |; | ""P"" | The current marker is plotted at each point |; | ""B"" | A Bar chart is drawn |; | ""1"" | When a graph is drawn as a bar chart, this option makes the bars start from the bottom of the pad. By default they start at 0. |; | ""X+"" | The X-axis is drawn on the top side of the plot. |; | ""Y+"" | The Y-axis is drawn on the right side of the plot. |; | ""PFC"" | Palette Fil",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:1683,update,updated,1683,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,1,['update'],['updated']
Deployability,"r the FFT calculation is extended in both directions,; /// and padded with the lowest/highest bin.; /// Example:; /// ```; /// original: -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5; /// add buffer zones: U U -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5 O O; /// rotate: 0 +1 +2 +3 +4 +5 O O U U -5 -4 -3 -2 -1; /// ```; /// The buffer bins are stripped away when the FFT output values; /// are transferred back to the p.d.f cache. The default buffer size is 10% of the; /// observable domain size, and can be changed with the `setBufferFraction()` member function.; ///; /// The RooFFTConvPdf uses caching inherited from a RooAbsCachedPdf. If it is; /// evaluated for a particular value of x, the FFT and convolution is calculated; /// for all bins in the observable space for the given choice of parameters,; /// which are also stored in the cache. Subsequent evaluations for different values of the convolution observable and; /// identical parameters will be retrieved from the cache. If one or more; /// of the parameters change, the cache will be updated, *i.e.*, a new FFT runs.; ///; /// The sampling density of the FFT is controlled by the binning of the; /// the convolution observable, which can be changed using RooRealVar::setBins(N).; /// For good results, N should be large (>=1000). Additional interpolation; /// between the bins may improve the result if coarse binnings are chosen. These can be; /// activated in the constructor or by calling `setInterpolationOrder()`.; /// For N >> 1000, interpolation will not substantially improve the accuracy.; ///; /// Additionial information on caching can be displayed by monitoring; /// the message stream with topic ""Caching"" at the INFO level, *i.e.*; /// by calling `RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching""))`; /// to see these message on stdout.; ///; /// Multi-dimensional convolutions are not supported at the moment.; ///; /// ---; ///; /// Installing an external version of FFTW on Linux and compiling ROOT to use it; /// ----",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:3353,update,updated,3353,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['update'],['updated']
Deployability,"r-defined maximum (0 means ""default""). The result of FSE_normalizeCount() will be saved into a table,; called 'normalizedCounter', which is a table of signed short.; 'normalizedCounter' must be already allocated, and have at least 'maxSymbolValue+1' cells.; The return value is tableLog if everything proceeded as expected.; It is 0 if there is a single symbol within distribution.; If there is an error (ex: invalid tableLog value), the function will return an ErrorCode (which can be tested using FSE_isError()). 'normalizedCounter' can be saved in a compact manner to a memory area using FSE_writeNCount().; 'buffer' must be already allocated.; For guaranteed success, buffer size must be at least FSE_headerBound().; The result of the function is the number of bytes written into 'buffer'.; If there is an error, the function will return an ErrorCode (which can be tested using FSE_isError(); ex : buffer size too small). 'normalizedCounter' can then be used to create the compression table 'CTable'.; The space required by 'CTable' must be already allocated, using FSE_createCTable().; You can then use FSE_buildCTable() to fill 'CTable'.; If there is an error, both functions will return an ErrorCode (which can be tested using FSE_isError()). 'CTable' can then be used to compress 'src', with FSE_compress_usingCTable().; Similar to FSE_count(), the convention is that 'src' is assumed to be a table of char of size 'srcSize'; The function returns the size of compressed data (without header), necessarily <= `dstCapacity`.; If it returns '0', compressed data could not fit into 'dst'.; If there is an error, the function will return an ErrorCode (which can be tested using FSE_isError()).; */; /* *** DECOMPRESSION *** */; /*! FSE_readNCount():; Read compactly saved 'normalizedCounter' from 'rBuffer'.; @return : size read from 'rBuffer',; or an errorCode, which can be tested using FSE_isError().; maxSymbolValuePtr[0] and tableLogPtr[0] will also be updated with their respective values */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:3128,update,updated,3128,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['update'],['updated']
Deployability,"r; /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; ///; /// The callback must be a callable (lambda, function, functor class...) that takes a reference to the result type as; /// argument and returns nothing. RDataFrame will invoke registered callbacks passing partial action results as; /// arguments to them (e.g. a histogram filled with a part of the selected events, a counter incremented only up to a; /// certain point, a mean over a subset of the events and so forth).; ///; /// Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running. For; /// example one can draw an up-to-date version of a result histogram every 100 entries like this:; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// TCanvas c(""c"",""x hist"");; /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; /// \endcode; ///; /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; /// be executed sequentially. Callbacks are executed in the order they were registered.; /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// // h.kOnce is 0; /// // decltype(h)::Value_t is TH1D; /// \endcode; ///; /// When implicit multi-threading is enabled, the callback:; /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; /// - will always be executed ""everyNEvents"": p",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:1235,Update,Update,1235,tree/dataframe/inc/ROOT/RResultPtr.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx,1,['Update'],['Update']
Deployability,"rary.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memory. Propagation of origins is basically a bunch of; /// ""select"" instructions that pick the origin of a dirty argument, if an; /// instruction has one.; ///; /// Every 4 aligned, consecutive bytes of application memory have one origin; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3641,update,update,3641,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['update'],['update']
Deployability,"rbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooMsgService.cxx; \class RooMsgService; \ingroup Roofitcore. Singleton class that organizes messages generated in RooFit.; Each message has a message level RooFit::MsgLevel (DEBUG,INFO,PROGRESS,WARNING,ERROR or FATAL),; an source object, and a RooFit::MsgTopic.; RooMsgService allows to filter and redirect messages into streams; according to message level, topic, (base) class of originating object, name of originating; object and based on attribute labels attached to individual objects.; The current default configuration creates streams for all messages at WARNING level; or higher (e.g. ERROR and FATAL) and for all INFO message on topics Generation,Plotting,; Integration and Minimization and redirects them to stdout. Users can create additional streams; for logging of e.g. DEBUG messages on particular topics or objects and/or redirect streams to; C++ streams or files. The singleton instance is accessible through RooMsgService::instance(). ### Temporarily change the message level; There is a helper, RooHelpers::LocalChangeMsgLevel, that overrides the default message levels as; long as it is alive. To suppress everything below WARNING:; ~~~{.cpp}; RooHelpers::LocalChangeMessageLevel changeMsgLvl(RooFit::WARNING);; [ statements that normally generate a lot of output ]; ~~~. #### Temporarily capture a message stream; RooHelpers::HijackMessageStream allows to fully capture a message stream in a std::stringstream. With this,; RooFit messages can be evaluated or suppressed.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMsgService.cxx:1219,configurat,configuration,1219,roofit/roofitcore/src/RooMsgService.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMsgService.cxx,2,"['Integrat', 'configurat']","['Integration', 'configuration']"
Deployability,"rce tables model the latency and cost for each; /// instruction type. Itinerary tables are an independent mechanism that; /// provides a detailed reservation table describing each cycle of instruction; /// execution. Subtargets may define any or all of the above categories of data; /// depending on the type of CPU and selected scheduler.; ///; /// The machine independent properties defined here are used by the scheduler as; /// an abstract machine model. A real micro-architecture has a number of; /// buffers, queues, and stages. Declaring that a given machine-independent; /// abstract property corresponds to a specific physical property across all; /// subtargets can't be done. Nonetheless, the abstract model is; /// useful. Futhermore, subtargets typically extend this model with processor; /// specific resources to model any hardware features that can be exploited by; /// scheduling heuristics and aren't sufficiently represented in the abstract.; ///; /// The abstract pipeline is built around the notion of an ""issue point"". This; /// is merely a reference point for counting machine cycles. The physical; /// machine will have pipeline stages that delay execution. The scheduler does; /// not model those delays because they are irrelevant as long as they are; /// consistent. Inaccuracies arise when instructions have different execution; /// delays relative to each other, in addition to their intrinsic latency. Those; /// special cases can be handled by TableGen constructs such as, ReadAdvance,; /// which reduces latency when reading data, and ReleaseAtCycles, which consumes; /// a processor resource when writing data for a number of abstract; /// cycles.; ///; /// TODO: One tool currently missing is the ability to add a delay to; /// ReleaseAtCycles. That would be easy to add and would likely cover all cases; /// currently handled by the legacy itinerary tables.; ///; /// A note on out-of-order execution and, more generally, instruction; /// buffers. Part of the CPU p",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:1287,pipeline,pipeline,1287,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['pipeline'],['pipeline']
Deployability,"reen; * related stuff.; *; * 2. Scanline handling facility via ASScanline. ASScanline is the most; * widely used structure since image handling is implemented on; * per-scanline basis.; *; * 3. Image storage, trasformation and rendering via ASImage. ASImage; * provides for generic container used for any image or text; * manipulation. It incorporates such a robust facilities as in-memory; * RLE compression, separate channel storage of 4 channels ( Alpha, Red,; * Green, and Blue ) with 8 bit per channel.; *; * 4. Simplified font handling facility via ASFont and ASFointManager.; * All the font handling is done using ASFont structure, no matter what; * type of font is used. Any font supported by X11 and FreeType can be; * used.; *; * 5. Transparent image file reading for many different formats. Included; * built-in XPM reading code and XCF ( GIMP's native format ).; * Overall supported:; * via external libraries :; * XPM, JPEG, PNG, TIFF, GIF; * via built in code :; * XPM, XCF, PNM, PPM, BMP, ICO, CUR; * Note that XPM can be supported both via built-in code or via libXpm,; * depending on compilation configuration.; * Actuall image file format is autodetected from the file contents -; * file name extention is not used and can be anything at all.; *; * 6. Image export into many popular file formats. Currently implemented :; * XPM, JPEG, PNG, GIF. Work is underway to implement support for TIFF,; * XCF, BMP, ICO.; *; * 7. Image quantization to arbitrary size colormap.; *; * 8. libAfterImage could be used without X window system, which is; * coninient for such thing as web development. XML Image manipulation; * tool, that could be used in such activity is included (see ascompose.c); *; * 9. Image reference counting; *; * USES; * libAfterBase - AfterStep basic functionality library. That Includes; * Hash tables, file search methods, message output, generic types.; * However effort has been made to allow for standalone configuration as; * well. If libAfterBase is not found at ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterimage.h:4491,configurat,configuration,4491,graf2d/asimage/src/libAfterImage/afterimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterimage.h,1,['configurat'],['configuration']
Deployability,"rkby@uci.edu *; * *; * Copyright (c) 2000-2020, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; * \class RooBinSamplingPdf; * The RooBinSamplingPdf is supposed to be used as an adapter between a continuous PDF; * and a binned distribution.; * When RooFit is used to fit binned data, and the PDF is continuous, it takes the probability density; * at the bin centre as a proxy for the probability averaged (integrated) over the entire bin. This is; * correct only if the second derivative of the function vanishes, though. This is shown in the plots; * below.; *; * For PDFs that have larger curvatures, the RooBinSamplingPdf can be used. It integrates the PDF in each; * bin using an adaptive integrator. This usually requires 21 times more function evaluations, but significantly; * reduces biases due to better sampling of the PDF. The integrator can be accessed from the outside; * using integrator(). This can be used to change the integration rules, so less/more function evaluations are; * performed. The target precision of the integrator can be set in the constructor.; *; *; * ### How to use it; * There are two ways to use this class:; * - Manually wrap a PDF:; * ```; * RooBinSamplingPdf binSampler(""<name>"", ""title"", <binned observable of PDF>, <original PDF> [, <precision for integrator>]);; * binSampler.fitTo(data);; * ```; * When a PDF is wrapped with a RooBinSamplingPDF, just use the bin sampling PDF instead of the original one for fits; * or plotting etc.; * \note The binning will be taken from the observable. Make sure that this binning is the same as the one of the dataset that should be fit.; * Use RooRealVar::setBinning() to adapt it.; * - In",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:1262,integrat,integrates,1262,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,2,['integrat'],"['integrates', 'integrator']"
Deployability,"rom the AbstractAttribute class, actually; // describe properties of the code. They can correspond to actual LLVM-IR; // attributes, or they can be more general, ultimately unrelated to LLVM-IR; // attributes. The latter is useful when an abstract attributes provides; // information to other abstract attributes in-flight but we might not want to; // manifest the information. The Attributor allows to query in-flight abstract; // attributes through the `Attributor::getAAFor` method (see the method; // description for an example). If the method is used by an abstract attribute; // P, and it results in an abstract attribute Q, the Attributor will; // automatically capture a potential dependence from Q to P. This dependence; // will cause P to be reevaluated whenever Q changes in the future.; //; // The Attributor will only reevaluate abstract attributes that might have; // changed since the last iteration. That means that the Attribute will not; // revisit all instructions/blocks/functions in the module but only query; // an update from a subset of the abstract attributes.; //; // The update method `AbstractAttribute::updateImpl` is implemented by the; // specific ""abstract attribute"" subclasses. The method is invoked whenever the; // currently assumed state (see the AbstractState class) might not be valid; // anymore. This can, for example, happen if the state was dependent on another; // abstract attribute that changed. In every invocation, the update method has; // to adjust the internal state of an abstract attribute to a point that is; // justifiable by the underlying IR and the current state of abstract attributes; // in-flight. Since the IR is given and assumed to be valid, the information; // derived from it can be assumed to hold. However, information derived from; // other abstract attributes is conditional on various things. If the justifying; // state changed, the `updateImpl` has to revisit the situation and potentially; // find another justification or lim",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:2069,update,update,2069,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['update'],['update']
Deployability,"rom the outside; * using integrator(). This can be used to change the integration rules, so less/more function evaluations are; * performed. The target precision of the integrator can be set in the constructor.; *; *; * ### How to use it; * There are two ways to use this class:; * - Manually wrap a PDF:; * ```; * RooBinSamplingPdf binSampler(""<name>"", ""title"", <binned observable of PDF>, <original PDF> [, <precision for integrator>]);; * binSampler.fitTo(data);; * ```; * When a PDF is wrapped with a RooBinSamplingPDF, just use the bin sampling PDF instead of the original one for fits; * or plotting etc.; * \note The binning will be taken from the observable. Make sure that this binning is the same as the one of the dataset that should be fit.; * Use RooRealVar::setBinning() to adapt it.; * - Instruct test statistics to carry out this wrapping automatically:; * ```; * pdf.fitTo(data, IntegrateBins(<precision>));; * ```; * This method is especially useful when used with a simultaneous PDF, since each component will automatically be wrapped,; * depending on the value of `precision`:; * - `precision < 0.`: None of the PDFs are touched, bin sampling is off.; * - `precision = 0.`: Continuous PDFs that are fit to a RooDataHist are wrapped into a RooBinSamplingPdf. The target precision; * forwarded to the integrator is 1.E-4 (the default argument of the constructor).; * - `precision > 0.`: All continuous PDFs are automatically wrapped into a RooBinSamplingPdf, regardless of what data they are; * fit to (see next paragraph). The same `'precision'` is used for all integrators.; *; * ### Simulating a binned fit using RooDataSet; * Some frameworks use unbinned data (RooDataSet) to simulate binned datasets. By adding one entry for each bin centre with the; * appropriate weight, one can achieve the same result as fitting with RooDataHist. In this case, however, RooFit cannot; * auto-detect that a binned fit is running, and that an integration over the bin is desired (note that the",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:2383,Integrat,IntegrateBins,2383,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,1,['Integrat'],['IntegrateBins']
Deployability,"rror values printed; e : number of entries printed; n : name of histogram is printed; ~~~. For example, to print only name of histogram and number of entries do:; ~~~ {.cpp}; gStyle->SetOptStat(""ne"");; ~~~. To print only the name of the histogram do:; ~~~ {.cpp}; gStyle->SetOptStat(""n"");; ~~~. The default value is:; ~~~ {.cpp}; gStyle->SetOptStat(""nemr"");; ~~~. When a histogram is painted, a `TPaveStats` object is created and added; to the list of functions of the histogram. If a `TPaveStats` object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters. Once a histogram is painted, the statistics box can be accessed using; `h->FindObject(""stats"")`. In the command line it is enough to do:; ~~~ {.cpp}; Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); ~~~. because after `h->Draw()` the histogram is automatically painted. But; in a script file the painting should be forced using `gPad->Update()`; in order to make sure the statistics box is created:; ~~~ {.cpp}; h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");; ~~~. Without `gPad->Update()` the line `h->FindObject(""stats"")`; returns a null pointer. When a histogram is drawn with the option ""`SAME`"", the statistics box; is not drawn. To force the statistics box drawing with the option; ""`SAME`"", the option ""`SAMES`"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""`h`"" being the pointer to the histogram):; ~~~ {.cpp}; Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position; ~~~. To remove the border or shadow of the TPaveStats, use the function TPave::SetBorderSize. To change the type of information for an histogram with an existing; `TPaveStats` one should do:; ~~~ {.cpp}; st->SetOptStat(mode);; ~~~; Where ""`m",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TPaveStats.cxx:3261,Update,Update,3261,graf2d/graf/src/TPaveStats.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TPaveStats.cxx,1,['Update'],['Update']
Deployability,"rst analysis, etc.; // These files contain a visualization that allows inspecting the CFG and the; // state of the analysis at each point.; // Static assets (HTMLLogger.js, HTMLLogger.css) and SVG graphs etc are embedded; // so each output file is self-contained.; //; // VIEWS; //; // The timeline and function view are always shown. These allow selecting basic; // blocks, statements within them, and processing iterations (BBs are visited; // multiple times when e.g. loops are involved).; // These are written directly into the HTML body.; //; // There are also listings of particular basic blocks, and dumps of the state; // at particular analysis points (i.e. BB2 iteration 3 statement 2).; // These are only shown when the relevant BB/analysis point is *selected*.; //; // DATA AND TEMPLATES; //; // The HTML proper is mostly static.; // The analysis data is in a JSON object HTMLLoggerData which is embedded as; // a <script> in the <head>.; // This gets rendered into DOM by a simple template processor which substitutes; // the data into <template> tags embedded in the HTML. (see inflate() in JS).; //; // SELECTION; //; // This is the only real interactive mechanism.; //; // At any given time, there are several named selections, e.g.:; // bb: B2 (basic block 0 is selected); // elt: B2.4 (statement 4 is selected); // iter: B2:1 (iteration 1 of the basic block is selected); // hover: B3 (hovering over basic block 3); //; // The selection is updated by mouse events: hover by moving the mouse and; // others by clicking. Elements that are click targets generally have attributes; // (id or data-foo) that define what they should select.; // See watchSelection() in JS for the exact logic.; //; // When the ""bb"" selection is set to ""B2"":; // - sections <section data-selection=""bb""> get shown; // - templates under such sections get re-rendered; // - elements with class/id ""B2"" get class ""bb-select""; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp:1936,update,updated,1936,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp,1,['update'],['updated']
Deployability,"rt and; targetEnd. Note: the end pointers are *after* the last item: e.g.; *(sourceEnd - 1) is the last item. The return result indicates whether the conversion was successful,; and if not, whether the problem was in the source or target buffers.; (Only the first encountered problem is indicated.). After the conversion, *sourceStart and *targetStart are both; updated to point to the end of last text successfully converted in; the respective buffers. Input parameters:; sourceStart - pointer to a pointer to the source buffer.; The contents of this are modified on return so that; it points at the next thing to be converted.; targetStart - similarly, pointer to pointer to the target buffer.; sourceEnd, targetEnd - respectively pointers to the ends of the; two buffers, for overflow checking only. These conversion functions take a ConversionFlags argument. When this; flag is set to strict, both irregular sequences and isolated surrogates; will cause an error. When the flag is set to lenient, both irregular; sequences and isolated surrogates are converted. Whether the flag is strict or lenient, all illegal sequences will cause; an error return. This includes sequences such as: <F4 90 80 80>, <C0 80>,; or <A0> in UTF-8, and values above 0x10FFFF in UTF-32. Conformant code; must check for illegal sequences. When the flag is set to lenient, characters over 0x10FFFF are converted; to the replacement character; otherwise (when the flag is set to strict); they constitute an error. Output parameters:; The value ""sourceIllegal"" is returned from some routines if the input; sequence is malformed. When ""sourceIllegal"" is returned, the source; value will point to the illegal value that caused the problem. E.g.,; in UTF-8 when a sequence is malformed, it points to the start of the; malformed sequence. Author: Mark E. Davis, 1994.; Rev History: Rick McGowan, fixes & updates May 2001.; Fixes & updates, Sept 2001. ------------------------------------------------------------------------ */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h:4787,update,updates,4787,interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h,2,['update'],['updates']
Deployability,"ry number of images. To facilitate this ASImageLayer structure; * has been created in order to specify parameters of each image; * participating in overlaying operation. Images need not to be exact; * same size. For each image its position on destination is specified; * via dst_x and dst_y data members. Each image maybe tiled and clipped; * to fit into rectangle specified by clip_x, clip_y, clip_width,; * clip_height ( in image coordinates - not destination ). If image is; * missing, then area specified by dst_x, dst_y, clip_width, clip_height; * will be filled with solid_color.; * Entire image will be tinted using tint parameter prior to overlaying.; * Bevel specified by bevel member will be drawn over image prior to; * overlaying. Specific overlay method has to be specified.; * merge_scanlines method is pointer to a function,; * that accepts 2 ASScanlines as arguments and performs overlaying of; * first one with the second one.; * There are 15 different merge_scanline methods implemented in; * libAfterImage, including alpha-blending, tinting, averaging,; * HSV and HSL colorspace operations, etc.; * NOTES; * ASImageLayer s could be organized into chains using next pointers.; * Since there could be a need to rearrange layers and maybe bypass some; * layers - we need to provide for flexibility, while at the same time; * allowing for simplicity of arrays. As the result next pointers could; * be used to link together continuous arrays of layer, like so :; * array1: [layer1(next==NULL)][layer2(next!=NULL)]; * ____________________________|; * V; * array2: [layer3(next==NULL)][layer4(next==NULL)][layer5(next!=NULL)]; * ________________________________________________|; * V; * array3: [layer6(next==NULL)][layer7(next==layer7)]; * ^______|; *; * While iterating throught such a list we check for two conditions -; * exceeding count of layers and layer pointing to self. When any of; * that is met - we stopping iteration.; * SEE ALSO; * merge_layers(); * blender.h; * SOURCE; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:1671,continuous,continuous,1671,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,1,['continuous'],['continuous']
Deployability,"s integer. At the end,; // TSQLStatement::Process() should be called. Here a small example:; //; // // first, create statement; // TSQLStatement* stmt = serv->Statement(""INSERT INTO TESTTABLE (ID1, ID2, FFIELD, FVALUE) VALUES (?, ?, ?, ?)"", 100);; //; // for (int n=0;n<357;n++); // if (stmt->NextIteration()) {; // stmt->SetInt(0, 123);; // stmt->SetUInt(1, n+10);; // stmt->SetString(2, Form(""name %d"",n), 200);; // stmt->SetString(3, Form(""value %d"", n+10), 200);; // }; //; // stmt->Process();; // delete stmt;; //; // The second argument in the TSQLServer::Statement() method specifies the depth of; // of buffers which are used to keep parameter values (100 in the example). It is not; // a limitation of the number of rows which can be inserted with the statement.; // When buffers are filled, they will be submitted to database and can be; // reused again. This happens transparent to the user in the NextIteration(); // method.; //; // Oracle and some ODBC drivers support buffering of parameter values and,; // as a result, bulk insert (update) operation. MySQL (native driver and; // MyODBC 3) does not support such a mode of operation, therefore adding; // new rows will result in communication loop to database.; //; // Local databases (SQLite3) do not use any buffering at all in the TSQLStatement; // implementation (but inside the library). They still profit from the; // usage of prepared statements. When inserting many rows into a SQLite3 database,; // consider using a transaction via the methods StartTransaction() and Commit(); // of the TSQLServer, as autocommit is active by default and causes a sync to disk; // after each single insert.; //; // One should also mention differences between Oracle and ODBC SQL syntax for; // parameters. ODBC (and MySQL) use question marks to specify the position; // where parameters should be inserted (as shown in the example). Oracle uses; // :1, :2 and so on as marks to specify the position of parameter 0, 1, and so on.; // Therefore, s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSQLStatement.cxx:4669,update,update,4669,net/net/src/TSQLStatement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSQLStatement.cxx,1,['update'],['update']
Deployability,"s like this:; ///; /// parrallel_for_each(ObjectFile) {; /// for_each (Compile Unit) {; /// 1. Load Clang modules.; /// }; ///; /// parrallel_for_each(Compile Unit) {; /// 1. Load input DWARF for Compile Unit.; /// 2. Report warnings for Clang modules.; /// 3. Analyze live DIEs and type names(if ODR deduplication is requested).; /// 4. Clone DIEs(Generate output DIEs and resulting DWARF tables).; /// The result is in an OutDebugInfoBytes, which is an ELF file; /// containing DWARF tables corresponding to the current compile unit.; /// 5. Cleanup Input and Output DIEs.; /// }; ///; /// Deallocate loaded Object file.; /// }; ///; /// if (ODR deduplication is requested); /// Generate an artificial compilation unit (""Type Table"": used to partially; /// generate DIEs at the clone stage).; ///; /// for_each (ObjectFile) {; /// for_each (Compile Unit) {; /// 1. Set offsets to Compile Units DWARF tables.; /// 2. Sort offsets/attributes/patches to have a predictable result.; /// 3. Patch size/offsets fields.; /// 4. Generate index tables.; /// 5. Move DWARF tables of compile units into the resulting file.; /// }; /// }; ///; /// Every compile unit is processed separately, visited only once; /// (except case inter-CU references exist), and used data is freed; /// after the compile unit is processed. The resulting file is glued together; /// from the generated debug tables which correspond to separate compile units.; ///; /// Handling inter-CU references: inter-CU references are hard to process; /// using only one pass. f.e. if CU1 references CU100 and CU100 references; /// CU1, we could not finish handling of CU1 until we finished CU100.; /// Thus we either need to load all CUs into the memory, either load CUs several; /// times. This implementation loads inter-connected CU into memory at the first; /// pass and processes them at the second pass.; ///; /// ODR deduplication: Artificial compilation unit will be constructed to keep; /// type dies. All types are moved into that c",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h:1850,Patch,Patch,1850,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h,1,['Patch'],['Patch']
Deployability,"s may only be called; /// for LI.hasSubrange()==true. Subregister ranges are split or created; /// until \p LaneMask can be matched exactly. \p Mod is executed on the; /// matching subranges.; ///; /// Example:; /// Given an interval with subranges with lanemasks L0F00, L00F0 and; /// L000F, refining for mask L0018. Will split the L00F0 lane into; /// L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod; /// function will be applied to the L0010 and L0008 subranges.; ///; /// \p Indexes and \p TRI are required to clean up the VNIs that; /// don't define the related lane masks after they get shrunk. E.g.,; /// when L000F gets split into L0007 and L0008 maybe only a subset; /// of the VNIs that defined L000F defines L0007.; ///; /// The clean up of the VNIs need to look at the actual instructions; /// to decide what is or is not live at a definition point. If the; /// update of the subranges occurs while the IR does not reflect these; /// changes, \p ComposeSubRegIdx can be used to specify how the; /// definition are going to be rewritten.; /// E.g., let say we want to merge:; /// V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>; /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>; /// overlap, i.e., by choosing a class where we can find ""offset + 1 == 3"".; /// Put differently we align V2's sub3 with V1's sub1:; /// V2: sub0 sub1 sub2 sub3; /// V1: <offset> sub0 sub1; ///; /// This offset will look like a composed subregidx in the class:; /// V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; /// => V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; ///; /// Now if we didn't rewrite the uses and def of V1, all the checks for V1; /// need to account for this offset.; /// This happens during coalescing where we update the live-ranges while; /// still having the old IR around because updating the IR on-the-fly; /// would actually clobber some information on how the live-ranges that; /// are being updated look like.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:1847,update,update,1847,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,2,['update'],"['update', 'updated']"
Deployability,"s model that can be analytically convolved with a resolution model.; ///; /// To achieve factorization between the physics model and the resolution; /// model, each physics model must be able to be written in the form; /// \f[; /// \mathrm{Phys}(x, \bar{a}, \bar{b}) = \sum_k \mathrm{coef}_k(\bar{a}) * \mathrm{basis}_k(x,\bar{b}); /// \f]; ///; /// where \f$ \mathrm{basis}_k \f$ are a limited number of functions in terms of the variable; /// to be convoluted, and \f$ \mathrm{coef}_k \f$ are coefficients independent of the convolution; /// variable.; ///; /// Classes derived from RooResolutionModel implement; /// \f[; /// R_k(x,\bar{b},\bar{c}) = \int \mathrm{basis}_k(x', \bar{b}) \cdot \mathrm{resModel}(x-x',\bar{c}) \; \mathrm{d}x',; /// \f]; ///; /// which RooAbsAnaConvPdf uses to construct the pdf for [ Phys (x) R ] :; /// \f[; /// \mathrm{PDF}(x,\bar{a},\bar{b},\bar{c}) = \sum_k \mathrm{coef}_k(\bar{a}) * R_k(x,\bar{b},\bar{c}); /// \f]; ///; /// A minimal implementation of a RooAbsAnaConvPdf physics model consists of; ///; /// - A constructor that declares the required basis functions using the declareBasis() method.; /// The declareBasis() function assigns a unique identifier code to each declare basis; ///; /// - An implementation of `coefficient(Int_t code)` returning the coefficient value for each; /// declared basis function; ///; /// Optionally, analytical integrals can be provided for the coefficient functions. The; /// interface for this is quite similar to that for integrals of regular PDFs. Two functions,; /// \code{.cpp}; /// Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName) const; /// double coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName) const; /// \endcode; ///; /// advertise the coefficient integration capabilities and implement them respectively.; /// Please see RooAbsPdf for additional details. Advertised analytical integrals must be; /// valid for all coefficients.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsAnaConvPdf.cxx:2705,integrat,integration,2705,roofit/roofitcore/src/RooAbsAnaConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsAnaConvPdf.cxx,1,['integrat'],['integration']
Deployability,"s of the derivative, especially the; derivative of compound functions, one can write:. - for a neuron: product of the local derivative with the; weighted sum on the outputs of the derivatives.; - for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented. #### Stochastic minimization:. is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; \f$w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)\f$. with. \f$\Delta w_{ij}(t) = - \eta(d e_p / d w_{ij} + \delta) + \epsilon \Delta w_{ij}(t-1)\f$. The parameters for this method are Eta, EtaDecay, Delta and; Epsilon. #### Steepest descent with fixed step size (batch learning):. It is the same as the stochastic; minimization, but the weights are updated after considering all the; examples, with the total derivative dEdw. The parameters for this; method are Eta, EtaDecay, Delta and Epsilon. #### Steepest descent algorithm:. Weights are set to the minimum along the line defined by the gradient. The; only parameter for this method is Tau. Lower tau = higher precision =; slower search. A value Tau = 3 seems reasonable. #### Conjugate gradients with the Polak-Ribiere updating formula:. Weights are set to the minimum along the line defined by the conjugate gradient.; Parameters are Tau and Reset, which defines the epochs where the direction is; reset to the steepest descent. #### Conjugate gradients with the Fletcher-Reeves updating formula:. Weights are set to the minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepest descent. #### Broyden, Fletcher, Goldfarb, Shanno (BFGS) method:. Implies the computation of a NxN matrix; computati",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx:5115,update,updated,5115,math/mlp/src/TMultiLayerPerceptron.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx,1,['update'],['updated']
Deployability,"s to be visualized. \image html geom_frame1.jpg. #### opt=2; only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method. #### opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method. The current view can be exploded in cartesian, cylindrical or spherical; coordinates :; TGeoManager::SetExplodedView(Int_t opt). Options may be :; - 0 - default (no bombing); - 1 - cartesian coordinates. The bomb factor on each axis can be set with; TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; - 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; are considered; \image html geom_frameexp.jpg. - 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(). Volumes themselves support different visualization settings :; - TGeoVolume::SetVisibility() : set volume visibility.; - TGeoVolume::VisibleDaughters() : set daughters visibility.; All these actions automatically updates the current view if any. ### Checking the geometry. Several checking methods are accessible from the volume context menu. They; generally apply only to the visible parts of the drawn geometry in order to; ease geometry checking, and their implementation is in the TGeoChecker class; from the painting package. #### Checking a given point.; Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z).; This method is drawing the daughters of the volume containing the point one; level down, printing the path to the deepest physical node holding this point.; It also computes the closest distance to any boundary. The point will be drawn; in red, as well as a sphere having this closest distance as radius. In case a; non-zero distance is given by the user as fifth argument of CheckPoint, this; distance will be used as radius of the safety sphere. \image html geom_checkpoint.jpg. #### Shooting random points.; Can be called from TGeoVolume::RandomPoints() (context menu",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:10257,update,updates,10257,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,1,['update'],['updates']
Deployability,"s to support \p LaneMask. This may only be called; /// for LI.hasSubrange()==true. Subregister ranges are split or created; /// until \p LaneMask can be matched exactly. \p Mod is executed on the; /// matching subranges.; ///; /// Example:; /// Given an interval with subranges with lanemasks L0F00, L00F0 and; /// L000F, refining for mask L0018. Will split the L00F0 lane into; /// L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod; /// function will be applied to the L0010 and L0008 subranges.; ///; /// \p Indexes and \p TRI are required to clean up the VNIs that; /// don't define the related lane masks after they get shrunk. E.g.,; /// when L000F gets split into L0007 and L0008 maybe only a subset; /// of the VNIs that defined L000F defines L0007.; ///; /// The clean up of the VNIs need to look at the actual instructions; /// to decide what is or is not live at a definition point. If the; /// update of the subranges occurs while the IR does not reflect these; /// changes, \p ComposeSubRegIdx can be used to specify how the; /// definition are going to be rewritten.; /// E.g., let say we want to merge:; /// V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>; /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>; /// overlap, i.e., by choosing a class where we can find ""offset + 1 == 3"".; /// Put differently we align V2's sub3 with V1's sub1:; /// V2: sub0 sub1 sub2 sub3; /// V1: <offset> sub0 sub1; ///; /// This offset will look like a composed subregidx in the class:; /// V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; /// => V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; ///; /// Now if we didn't rewrite the uses and def of V1, all the checks for V1; /// need to account for this offset.; /// This happens during coalescing where we update the live-ranges while; /// still having the old IR around because updating the IR on-the-fly; /// would actually clobber some information on how the live-ranges that; /// ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:944,update,update,944,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,1,['update'],['update']
Deployability,"s used by an abstract attribute; // P, and it results in an abstract attribute Q, the Attributor will; // automatically capture a potential dependence from Q to P. This dependence; // will cause P to be reevaluated whenever Q changes in the future.; //; // The Attributor will only reevaluate abstract attributes that might have; // changed since the last iteration. That means that the Attribute will not; // revisit all instructions/blocks/functions in the module but only query; // an update from a subset of the abstract attributes.; //; // The update method `AbstractAttribute::updateImpl` is implemented by the; // specific ""abstract attribute"" subclasses. The method is invoked whenever the; // currently assumed state (see the AbstractState class) might not be valid; // anymore. This can, for example, happen if the state was dependent on another; // abstract attribute that changed. In every invocation, the update method has; // to adjust the internal state of an abstract attribute to a point that is; // justifiable by the underlying IR and the current state of abstract attributes; // in-flight. Since the IR is given and assumed to be valid, the information; // derived from it can be assumed to hold. However, information derived from; // other abstract attributes is conditional on various things. If the justifying; // state changed, the `updateImpl` has to revisit the situation and potentially; // find another justification or limit the optimistic assumes made.; //; // Change is the key in this framework. Until a state of no-change, thus a; // fixpoint, is reached, the Attributor will query the abstract attributes; // in-flight to re-evaluate their state. If the (current) state is too; // optimistic, hence it cannot be justified anymore through other abstract; // attributes or the state of the IR, the state of the abstract attribute will; // have to change. Generally, we assume abstract attribute state to be a finite; // height lattice and the update function to be mono",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:2499,update,update,2499,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['update'],['update']
Deployability,"s which reach an; /// SCC between the source and the target, and add them to the set of; /// connected SCCs, then recurse through them. Once a complete set of the; /// SCCs the target connects to is known, hoist the remaining SCCs between; /// the source and the target to be above the target. Note that there is no; /// need to process the source SCC, it is already known to connect.; /// 4) At this point, all of the SCCs in the closed range between the source; /// SCC and the target SCC in the postorder sequence are connected,; /// including the target SCC and the source SCC. Inserting the edge from; /// the source SCC to the target SCC will form a cycle out of precisely; /// these SCCs. Thus we can merge all of the SCCs in this closed range into; /// a single SCC.; ///; /// This process has various important properties:; /// - Only mutates the SCCs when adding the edge actually changes the SCC; /// structure.; /// - Never mutates SCCs which are unaffected by the change.; /// - Updates the postorder sequence to correctly satisfy the postorder; /// constraint after the edge is inserted.; /// - Only reorders SCCs in the closed postorder sequence from the source to; /// the target, so easy to bound how much has changed even in the ordering.; /// - Big-O is the number of edges in the closed postorder range of SCCs from; /// source to target.; ///; /// This helper routine, in addition to updating the postorder sequence itself; /// will also update a map from SCCs to indices within that sequence.; ///; /// The sequence and the map must operate on pointers to the SCC type.; ///; /// Two callbacks must be provided. The first computes the subset of SCCs in; /// the postorder closed range from the source to the target which connect to; /// the source SCC via some (transitive) set of edges. The second computes the; /// subset of the same range which the target SCC connects to via some; /// (transitive) set of edges. Both callbacks should populate the set argument; /// provided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:2626,Update,Updates,2626,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,2,"['Update', 'update']","['Updates', 'update']"
Deployability,"s. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, divided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especially the; derivative of compound functions, one can write:. - for a neuron: product of the local derivative with the; weighted sum on the outputs of the derivatives.; - for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented. #### Stochastic minimization:. is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; \f$w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)\f$. with. \f$\Delta w_{ij}(t) = - \eta(d e_p / d w_{ij} + \delta) + \epsilon \Delta w_{ij}(t-1)\f$. The parameters for this method are Eta, EtaDecay, Delta and; Epsilon. #### Steepest descent with fixed step size (batch learning):. It is the same as the stochastic; minimization, but the weights are updated after considering all the; examples, with the total derivative dEdw. The parameters for this; method are Eta, EtaDecay, Delta and Epsilon. #### Steepest descent algorithm:. Weights are set to the minimum along the line defined by the gradient. The; only parameter for this method is Tau. Lower tau = higher precision =; slower search. A value Tau = 3 seems reasonable. #### Conjugate gradients with the Polak-Ribiere updating formula:. Weights are set to the minimum along the line defined by the conjugate gradient.; Parameters are Tau and Reset, which defines the epochs where the direction is; reset to the steepest descent. #### Co",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx:4715,update,updated,4715,math/mlp/src/TMultiLayerPerceptron.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx,1,['update'],['updated']
Deployability,"s.; ///; /// Any user-define `struct` can participate in hashing via `HashBuilder` by; /// providing a `addHash` templated function.; ///; /// ```; /// template <typename HasherT, llvm::endianness Endianness>; /// void addHash(HashBuilder<HasherT, Endianness> &HBuilder,; /// const UserDefinedStruct &Value);; /// ```; ///; /// For example:; /// ```; /// struct SimpleStruct {; /// char c;; /// int i;; /// };; ///; /// template <typename HasherT, llvm::endianness Endianness>; /// void addHash(HashBuilder<HasherT, Endianness> &HBuilder,; /// const SimpleStruct &Value) {; /// HBuilder.add(Value.c);; /// HBuilder.add(Value.i);; /// }; /// ```; ///; /// To avoid endianness issues, specializations of `addHash` should; /// generally rely on exising `add`, `addRange`, and `addRangeElements`; /// functions. If directly using `update`, an implementation must correctly; /// handle endianness.; ///; /// ```; /// struct __attribute__ ((packed)) StructWithFastHash {; /// int I;; /// char C;; ///; /// // If possible, we want to hash both `I` and `C` in a single; /// // `update` call for performance concerns.; /// template <typename HasherT, llvm::endianness Endianness>; /// friend void addHash(HashBuilder<HasherT, Endianness> &HBuilder,; /// const StructWithFastHash &Value) {; /// if (Endianness == llvm::endianness::native) {; /// HBuilder.update(ArrayRef(; /// reinterpret_cast<const uint8_t *>(&Value), sizeof(Value)));; /// } else {; /// // Rely on existing `add` methods to handle endianness.; /// HBuilder.add(Value.I);; /// HBuilder.add(Value.C);; /// }; /// }; /// };; /// ```; ///; /// To avoid collisions, specialization of `addHash` for variable-size; /// types must take the size into account.; ///; /// For example:; /// ```; /// struct CustomContainer {; /// private:; /// size_t Size;; /// int Elements[100];; ///; /// public:; /// CustomContainer(size_t Size) : Size(Size) {; /// for (size_t I = 0; I != Size; ++I); /// Elements[I] = I;; /// }; /// template <typename HasherT, llv",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h:1117,update,update,1117,interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,1,['update'],['update']
Deployability,"safe to activate the AutoSave; /// procedure. Some branches may have buffers holding many entries.; /// If fAutoSave is negative, AutoSave is automatically called by; /// TTree::Fill when the number of bytes generated since the previous; /// AutoSave is greater than -fAutoSave bytes.; /// If fAutoSave is positive, AutoSave is automatically called by; /// TTree::Fill every N entries.; /// This function may also be invoked by the user.; /// Each AutoSave generates a new key on the file.; /// Once the key with the tree header has been written, the previous cycle; /// (if any) is deleted.; ///; /// Note that calling TTree::AutoSave too frequently (or similarly calling; /// TTree::SetAutoSave with a small value) is an expensive operation.; /// You should make tests for your own application to find a compromise; /// between speed and the quantity of information you may loose in case of; /// a job crash.; ///; /// In case your program crashes before closing the file holding this tree,; /// the file will be automatically recovered when you will connect the file; /// in UPDATE mode.; /// The Tree will be recovered at the status corresponding to the last AutoSave.; ///; /// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; /// This allows another process to analyze the Tree while the Tree is being filled.; ///; /// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; /// the current basket are closed-out and written to disk individually.; ///; /// By default the previous header is deleted after having written the new header.; /// if option contains ""Overwrite"", the previous Tree header is deleted; /// before written the new header. This option is slightly faster, but; /// the default option is safer in case of a problem (disk quota exceeded); /// when writing the new header.; ///; /// The function returns the number of bytes written to the file.; /// if the number of bytes is null, an error has occurred while writing; /// the header to the",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1255,UPDATE,UPDATE,1255,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['UPDATE'],['UPDATE']
Deployability,"sh is set to Z_NO_FLUSH, which allows deflate to; decide how much data to accumualte before producing output, in order to; maximize compression. If the parameter flush is set to Z_SYNC_FLUSH, all pending output is; flushed to the output buffer and the output is aligned on a byte boundary, so; that the decompressor can get all input data available so far. (In particular; avail_in is zero after the call if enough output space has been provided; before the call.) Flushing may degrade compression for some compression; algorithms and so it should be used only when necessary. If flush is set to Z_FULL_FLUSH, all output is flushed as with; Z_SYNC_FLUSH, and the compression state is reset so that decompression can; restart from this point if previous compressed data has been damaged or if; random access is desired. Using Z_FULL_FLUSH too often can seriously degrade; compression. If deflate returns with avail_out == 0, this function must be called again; with the same value of the flush parameter and more output space (updated; avail_out), until the flush is complete (deflate returns with non-zero; avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that; avail_out is greater than six to avoid repeated flush markers due to; avail_out == 0 on return. If the parameter flush is set to Z_FINISH, pending input is processed,; pending output is flushed and deflate returns with Z_STREAM_END if there; was enough output space; if deflate returns with Z_OK, this function must be; called again with Z_FINISH and more output space (updated avail_out) but no; more input data, until it returns with Z_STREAM_END or an error. After; deflate has returned Z_STREAM_END, the only possible operations on the; stream are deflateReset or deflateEnd. Z_FINISH can be used immediately after deflateInit if all the compression; is to be done in a single step. In this case, avail_out must be at least; the value returned by deflateBound (see below). If deflate does not return; Z_STREAM_END, ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:2603,update,updated,2603,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['update'],['updated']
Deployability,"sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only; </pre>; To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:; <pre>; root[] html.Convert( ""hsimple.C"", ""Histogram example"" ); </pre>. <h3><a name=""conf"">II. Configuration</a></h3>; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc. <h4><a name=""conf:input"">II.1 Input files</a></h4>. <p>In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: <a href=""http://root.cern.ch/root/html/TEnv.html"">TEnv</a>); of the classes you want to document, or call THtml::SetInputDir()</p>. <p>Example:</p><pre>; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html</pre>. <h4><a name=""conf:output"">II.2 Output directory</a></h4>. <p>The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist <a href=""http://root.cern.ch/root/html/THtml.html"">THtml</a>; will create it.</p>. <p>Example:</p><pre>; Root.Html.OutputDir: htmldoc</pre>. <h4><a name=""conf:liblink"">II.3 Linking other documentation</a></h4>. <p>When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; <tt>Root.Html.LibName</tt>, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().</p>. <p>Example:<br/>; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains</p><pre>; Root.Html.MyLib: ../mylib/</pre>; <p>THtml will create a link to ""../mylib/MyClass.html"".</p>. <p>The library name association can be set up using the rootmap facility.; For the library in the example a",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx:4398,configurat,configuration,4398,html/src/THtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx,1,['configurat'],['configuration']
Deployability,"sing the Metropolis algorithm. From the Markov; Chain, the confidence interval can be determined in two ways:. #### Using a Kernel-Estimated PDF: (not the default method). A RooNDKeysPdf is constructed from the data set using adaptive kernel width.; With this RooNDKeysPdf F, we then integrate over the most likely domain in the; parameter space (tallest points in the posterior RooNDKeysPdf) until the target; confidence level is reached within an acceptable neighborhood as defined by; SetEpsilon(). More specifically: we calculate the following for different; cutoff values C until we reach the target confidence level: \f$\int_{ F >= C } F; d{normset} \f$.; Important note: this is not the default method because of a bug in constructing; the RooNDKeysPdf from a weighted data set. Configure to use this method by; calling SetUseKeys(true), and the data set will be interpreted without weights. #### Using a binned data set: (the default method). This is the binned analog of the continuous integrative method that uses the; kernel-estimated PDF. The points in the Markov Chain are put into a binned; data set and the interval is then calculated by adding the heights of the bins; in decreasing order until the desired level of confidence has been reached.; Note that this means the actual confidence level is >= the confidence level; prescribed by the client (unless the user calls SetHistStrict(false)). This; method is the default but may not remain as such in future releases, so you may; wish to explicitly configure to use this method by calling SetUseKeys(false). These are not the only ways for the confidence interval to be determined, and; other possibilities are being considered being added, especially for the; 1-dimensional case. One can ask an MCMCInterval for the lower and upper limits on a specific; parameter of interest in the interval. Note that this works better for some; distributions (ones with exactly one local maximum) than others, and sometimes; has little value.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/MCMCInterval.cxx:1678,continuous,continuous,1678,roofit/roostats/src/MCMCInterval.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/MCMCInterval.cxx,3,"['continuous', 'integrat', 'release']","['continuous', 'integrative', 'releases']"
Deployability,"single number. The parameter mode can be any combination of the letters `kKsSiIourRmMen`. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : standard deviation printed; R : standard deviation and standard deviation error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a `TPaveStats` object is created and added; to the list of functions of the histogram. If a `TPaveStats` object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters. Once a histogram is painted, the statistics box can be accessed using; `h->FindObject(""stats"")`. In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after `h->Draw()` the histogram is automatically painted. But; in a script file the painting should be forced using `gPad->Update()`; in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without `gPad->Update()` the line `h->FindObject(""stats"")` returns a null pointer. When a histogram is drawn with the option `SAME`, the statistics box; is not drawn. To force the statistics box drawing with the option; `SAME`, the option `SAMES` must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (`h` being the pointer to the histogram):. Root > TPaveSt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:23424,update,updated,23424,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['update'],['updated']
Deployability,"skerRange(double) the whisker definition w=1; will be overwritten. E.g. using a whisker-range of 0.95 and w=1 will redefine the area of; the lower whisker to the upper whisker in order to cover 95% of the distribution inside; that candle. The static function will affect all candle-charts in the running program.; Default is 1. If the distribution is large enough and gaussian shaped, the maximum length of; the whisker will be located at \f$ \pm 2.698 \sigma \f$ (when using the; 1.5*iqr-definition (w=2), where \f$ \sigma \f$ is the standard deviation; (see picture above). In that case 99.3% of the total distribution will be covered; by the box and the whiskers, whereas 0.7% are represented by the outliers. ##### The Anchors; The anchors have no special meaning in terms of statistical calculation. They mark; the end of the whiskers and they have the width of the box. Both representation; with and without anchors are common. ##### The Points; Depending on the configuration the points can have different meanings:; - If p=1 the points represent the outliers. If they are shown, it means; some parts of the underlying distribution are not covered by the whiskers.; This can only occur when the whiskers are set to option w=2. Here the whiskers; can have a maximum length of \f$ 1.5 \times iqr \f$. So any points outside the; whiskers will be drawn as outliers. The outliers will be represented by crosses.; - If p=2 all points in the distribution will be painted as crosses. This is; useful for small datasets only (up to 10 or 20 points per candle).; The outliers are shown along the candle. Because the underlying distribution; is binned, is frequently occurs that a bin contains more than one value.; Because of this the points will be randomly scattered within their bin along; the candle axis. If the bin content for a bin is exactly 1 (usually; this happens for the outliers) if will be drawn in the middle of the bin along; the candle axis. As the maximum number of points per candle i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:52889,configurat,configuration,52889,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['configurat'],['configuration']
Deployability,"small; * strings is inspired from that of Rabin & Karp. A brute force approach; * is used to find longer strings when a small match has been found.; * A similar algorithm is used in comic (by Jan-Mark Wams) and freeze; * (by Leonid Broukhis).; * A previous version of this file used a more sophisticated algorithm; * (by Fiala and Greene) which is guaranteed to run in linear amortized; * time, but has a larger average cost, uses more memory and is patented.; * However the F&G algorithm may be faster for some highly redundant; * files if the parameter max_chain_length (described below) is too large.; *; * ACKNOWLEDGEMENTS; *; * The idea of lazy evaluation of matches is due to Jan-Mark Wams, and; * I found it in 'freeze' written by Leonid Broukhis.; * Thanks to many info-zippers for bug reports and testing.; *; * REFERENCES; *; * APPNOTE.TXT documentation file in PKZIP 1.93a distribution.; *; * A description of the Rabin and Karp algorithm is given in the book; * ""Algorithms"" by R. Sedgewick, Addison-Wesley, p252.; *; * Fiala,E.R., and Greene,D.H.; * Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595; *; * INTERFACE; *; * void lm_init (int pack_level, ush *flags); * Initialize the ""longest match"" routines for a new file; *; * ulg deflate (void); * Processes a new input file and return its compressed length. Sets; * the compressed length, crc, deflate flags and internal file; * attributes.; */; /* #include ""zip.h"" */; /* #include ""ZIP.h"" */; /* ===========================================================================; * Configuration parameters; */; /* Compile with MEDIUM_MEM to reduce the memory requirements or; * with SMALL_MEM to use as little memory as possible. Use BIG_MEM if the; * entire input file can be held in memory (not possible on 16 bit systems).; * Warning: defining these symbols affects HASH_BITS (see below) and thus; * affects the compression ratio. The compressed output; * is still correct, and might even be smaller in some cases.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c:2530,Configurat,Configuration,2530,core/zip/src/ZDeflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c,1,['Configurat'],['Configuration']
Deployability,"start chrome in batch, used for image production, like ""$prog --headless --disable-gpu $geometry $url""; /// WebGui.ChromeHeadless: command to start chrome in headless mode, like ""fork: --headless --disable-gpu $geometry $url""; /// WebGui.ChromeInteractive: command to start chrome in interactive mode, like ""$prog $geometry --app=\'$url\' &""; /// WebGui.Firefox: full path to Mozilla Firefox executable; /// WebGui.FirefoxHeadless: command to start Firefox in headless mode, like ""fork:--headless --private-window --no-remote $profile $url""; /// WebGui.FirefoxInteractive: command to start Firefox in interactive mode, like ""$prog --private-window \'$url\' &""; /// WebGui.FirefoxProfile: name of Firefox profile to use; /// WebGui.FirefoxProfilePath: file path to Firefox profile; /// WebGui.FirefoxRandomProfile: usage of random Firefox profile -1 never, 0 - only for headless mode (dflt), 1 - always; /// WebGui.LaunchTmout: time required to start process in seconds (default 30 s); /// WebGui.OperationTmout: time required to perform WebWindow operation like execute command or update drawings; /// WebGui.RecordData: if specified enables data recording for each web window 0 - off, 1 - on; /// WebGui.JsonComp: compression factor for JSON conversion, if not specified - each widget uses own default values; /// WebGui.ForceHttp: 0 - off (default), 1 - always create real http server to run web window; /// WebGui.Console: -1 - output only console.error(), 0 - add console.warn(), 1 - add console.log() output; /// WebGui.ConnCredits: 10 - number of packets which can be send by server or client without acknowledge from receiving side; /// WebGui.openui5src: alternative location for openui5 like https://openui5.hana.ondemand.com/1.128.0/; /// WebGui.openui5libs: list of pre-loaded ui5 libs like sap.m, sap.ui.layout, sap.ui.unified; /// WebGui.openui5theme: openui5 theme like sap_belize (default) or sap_fiori_3; ///; /// THttpServer-related parameters documented in \ref CreateServer method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx:2313,update,update,2313,gui/webdisplay/src/RWebWindowsManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx,1,['update'],['update']
Deployability,"stead of plotting it directly, add it to an existing curve with given name (and relative weight factors).; /// <tr><td> `Components(const char* names)` <td> When plotting sums of PDFs, plot only the named components (*e.g.* only; /// the signal of a signal+background model).; /// <tr><td> `Components(const RooArgSet& compSet)` <td> As above, but pass a RooArgSet of the components themselves.; ///; /// <tr><th> Type of argument <th> Projection control; /// <tr><td> `Slice(const RooArgSet& set)` <td> Override default projection behaviour by omitting observables listed; /// in set from the projection, i.e. by not integrating over these.; /// Slicing is usually only sensible in discrete observables, by e.g. creating a slice; /// of the PDF at the current value of the category observable.; /// <tr><td> `Slice(RooCategory& cat, const char* label)` <td> Override default projection behaviour by omitting the specified category; /// observable from the projection, i.e., by not integrating over all states of this category.; /// The slice is positioned at the given label value. Multiple Slice() commands can be given to specify slices; /// in multiple observables, e.g.; /// ```{.cpp}; /// pdf.plotOn(frame, Slice(tagCategory, ""2tag""), Slice(jetCategory, ""3jet""));; /// ```; /// <tr><td> `Project(const RooArgSet& set)` <td> Override default projection behaviour by projecting; /// over observables given in set, completely ignoring the default projection behavior. Advanced use only.; /// <tr><td> `ProjWData(const RooAbsData& d)` <td> Override default projection _technique_ (integration). For observables; /// present in given dataset projection of PDF is achieved by constructing an average over all observable; /// values in given set. Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; /// <tr><td> `ProjWData(const RooArgSet& s, const RooAbsData& d)` <td> As above but only consider subset 's' of; /// observables in dataset 'd' for projection th",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:4061,integrat,integrating,4061,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['integrat'],['integrating']
Deployability,"stract base class for binned and unbinned; datasets. The abstract interface defines plotting and tabulating entry; points for its contents and provides an iterator over its elements; (bins for binned data sets, data points for unbinned datasets). ### Storing global observables in RooFit datasets. RooFit groups model variables into *observables* and *parameters*, depending on; if their values are stored in the dataset. For fits with parameter; constraints, there is a third kind of variables, called *global observables*.; These represent the results of auxiliary measurements that constrain the; nuisance parameters. In the RooFit implementation, a likelihood is generally; the sum of two terms:; - the likelihood of the data given the parameters, where the normalization set; is the set of observables (implemented by RooNLLVar); - the constraint term, where the normalization set is the set of *global; observables* (implemented by RooConstraintSum). Before this release, the global observable values were always taken from the; model/pdf. With this release, a mechanism is added to store a snapshot of; global observables in any RooDataSet or RooDataHist. For toy studies where the; global observables assume a different values for each toy, the bookkeeping of; the set of global observables and in particular their values is much easier; with this change. Usage example for a model with global observables `g1` and `g2`:; ```; using namespace RooFit;. std::unique_ptr<RooAbsData> data{model.generate(x, 1000)}; // data has only the single observables x; data->setGlobalObservables(g1, g2); // now, data also stores a snapshot of g1 and g2. // If you fit the model to the data, the global observables and their values; // are taken from the dataset:; model.fitTo(*data);. // You can still define the set of global observables yourself, but the values; // will be takes from the dataset if available:; model.fitTo(*data, GlobalObservables(g1, g2));. // To force `fitTo` to take the global observ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:1733,release,release,1733,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['release'],['release']
Deployability,"t included; /// in standard URL format.; /// 3. Form ""odbcn://MySpecialConfig"", where MySpecialConfig is entry,; /// defined in user DSN (user data source). Here uid and pw should be; /// always specified.; ///; /// Configuring unixODBC under Linux: http://www.unixodbc.org/odbcinst.html; /// Remarks: for variants 1 & 2 it is enough to create/configure; /// odbcinst.ini file. For variant 3 file odbc.ini should be created.; /// Path to this files can be specified in environmental variables like; /// export ODBCINI=/home/my/unixODBC/etc/odbc.ini; /// export ODBCSYSINI=/home/my/unixODBC/etc; ///; /// Configuring MySQL ODBC under Windows.; /// Installing ODBC driver for MySQL is enough to use it under Windows.; /// Afer odbcd:// variant can be used with DRIVER={MySQL ODBC 3.51 Driver};; /// To configure User DSN, go into Start menu -> Settings ->; /// Control panel -> Administrative tools-> Data Sources (ODBC).; ///; /// To install Oracle ODBC driver for Windows, one should download; /// and install either complete Oracle client (~500 MB), or so-called; /// Instant Client Basic and Instant Client ODBC (~20 MB together).; /// Some remark about Instant Client:; /// 1) Two additional DLLs are required: mfc71.dll & msver71.dll; /// They can be found either in MS VC++ 7.1 Free Toolkit or; /// download from other Internet sites; /// 2) ORACLE_HOME environment variable should be specified and point to; /// location, where Instant Client files are extracted; /// 3) Run odbc_install.exe from account with administrative rights; /// 3) In $ORACLE_HOME/network/admin/ directory appropriate *.ora files; /// like ldap.ora, sqlnet.ora, tnsnames.ora should be installed.; /// Contact your Oracle administrator to get these files.; /// After Oracle ODBC driver is installed, appropriate entry in ODBC drivers; /// list like ""Oracle in instantclient10_2"" should appear. Connection; /// string example:; /// ""odbcd://DRIVER={Oracle in instantclient10_2};DBQ=db-test;UID=user_name;PWD=user_pass;"";",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/odbc/src/TODBCServer.cxx:1846,install,install,1846,sql/odbc/src/TODBCServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/odbc/src/TODBCServer.cxx,4,['install'],"['install', 'installed']"
Deployability,"t is enough to do:. h->Draw();. `h` can be of any kind: 1D, 2D or 3D. To choose how the histogram will; be drawn, the `Draw()` method can be invoked with an option. For instance; to draw a 2D histogram as a lego plot it is enough to do:. h->Draw(""lego"");. `THistPainter` offers many options to paint 1D, 2D and 3D histograms. When the `Draw()` method of a histogram is called for the first time; (`TH1::Draw`), it creates a `THistPainter` object and saves a; pointer to this ""painter"" as a data member of the histogram. The; `THistPainter` class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram having its own; painter (rather than a central singleton painter painting all histograms), allows; two histograms to be drawn in two threads without overwriting the painter's; values. When a displayed histogram is filled again, there is no need to call the; `Draw()` method again; the image will be refreshed the next time the; pad will be updated. A pad is updated after one of these three actions:. 1. a carriage control on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. By default a call to `TH1::Draw()` clears the pad of all objects; before drawing the new image of the histogram. One can use the `SAME`; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads. When a displayed histogram is deleted, its image is automatically removed; from the pad. To create a copy of the histogram when drawing it, one can use; `TH1::DrawClone()`. This will clone the histogram and allow to change; and delete the original one without affecting the clone. \anchor HP01; ### Histograms' plotting options. Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case se",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:4470,update,updated,4470,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['update'],['updated']
Deployability,"t strategy to calculate the running integrals is; ///; /// - If the integrand (this object) supports analytical integration, construct an integral object; /// that calculate the running integrals value by calculating the analytical integral each; /// time the running integral object is evaluated; ///; /// - If the integrand (this object) requires numeric integration to construct the running integral; /// create an object of class RooNumRunningInt which first samples the entire function and integrates; /// the sampled function numerically. This method has superior performance as there is no need to; /// perform a full (numeric) integration for each evaluation of the running integral object, but; /// only when one of its parameters has changed.; ///; /// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; /// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); /// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; /// granularity for the scanning technique can be controlled with the ScanParameters technique; /// which allows to specify the number of samples to be taken, and to which order the resulting; /// running integral should be interpolated. The default values are 1000 samples and 2nd order; /// interpolation.; ///; /// The following named arguments are accepted; /// | | Effect on integral creation; /// |-|-------------------------------; /// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in addition_ to the integration observables; /// | `ScanParameters(Int_t nbins, Int_t intOrder)` | Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf; /// | `ScanNum()` | Apply scanning technique if cdf integral involves numeric integration; /// | `ScanAll()` | Always apply scanning technique; /// | `ScanNone()` | Never apply scanning technique",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:2153,integrat,integration,2153,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,2,['integrat'],['integration']
Deployability,"t::DataError(Int_t); /// <td> Select the type of error drawn:; /// - `Auto(default)` results in Poisson for unweighted data and SumW2 for weighted data; /// - `Poisson` draws asymmetric Poisson confidence intervals.; /// - `SumW2` draws symmetric sum-of-weights error ( \f$ \left( \sum w \right)^2 / \sum\left(w^2\right) \f$ ); /// - `None` draws no error bars; /// <tr><td> RooFit::Binning(int nbins, double xlo, double xhi); /// <td> Use specified binning to draw dataset; /// <tr><td> RooFit::Binning(const RooAbsBinning&); /// <td> Use specified binning to draw dataset; /// <tr><td> RooFit::Binning(const char* name); /// <td> Use binning with specified name to draw dataset; /// <tr><td> RooFit::RefreshNorm(); /// <td> Force refreshing for PDF normalization information in frame.; /// If set, any subsequent PDF will normalize to this dataset, even if it is; /// not the first one added to the frame. By default only the 1st dataset; /// added to a frame will update the normalization information; /// <tr><td> RooFit::Rescale(double f); /// <td> Rescale drawn histogram by given factor.; /// <tr><td> RooFit::Cut(const char*); /// <td> Only plot entries that pass the given cut.; /// Apart from cutting in continuous variables `Cut(""x>5"")`, this can also be used to plot a specific; /// category state. Use something like `Cut(""myCategory == myCategory::stateA"")`, where; /// `myCategory` resolves to the state number for a given entry and; /// `myCategory::stateA` resolves to the state number of the state named ""stateA"".; ///; /// <tr><td> RooFit::CutRange(const char*); /// <td> Only plot data from given range. Separate multiple ranges with "","".; /// \note This often requires passing the normalisation when plotting the PDF because RooFit does not save; /// how many events were being plotted (it will only work for cutting slices out of uniformly distributed; /// variables).; /// ```; /// data->plotOn(frame01, CutRange(""SB1""));; /// const double nData = data->sumEntries("""", ""SB1"");; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:1944,update,update,1944,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['update'],['update']
Deployability,"te of input, or to return; if there is no input available. The decoding of variable length codes uses; PULLBYTE() directly in order to pull just enough bytes to decode the next; code, and no more. Some states loop until they get enough input, making sure that enough; state information is maintained to continue the loop where it left off; if NEEDBITS() returns in the loop. For example, want, need, and keep; would all have to actually be part of the saved state in case NEEDBITS(); returns:. case STATEw:; while (want < need) {; NEEDBITS(n);; keep[want++] = BITS(n);; DROPBITS(n);; }; state = STATEx;; case STATEx:. As shown above, if the next state is also the next case, then the break; is omitted. A state may also return if there is not enough output space available to; complete that state. Those states are copying stored data, writing a; literal byte, and copying a matching string. When returning, a ""goto inf_leave"" is used to update the total counters,; update the check value, and determine whether any progress has been made; during that inflate() call in order to return the proper return code.; Progress is defined as a change in either strm->avail_in or strm->avail_out.; When there is a window, goto inf_leave will update the window with the last; output written. If a goto inf_leave occurs in the middle of decompression; and there is no window currently, goto inf_leave will create one and copy; output to the window for the next call of inflate(). In this implementation, the flush parameter of inflate() only affects the; return code (per zlib.h). inflate() always writes as much as possible to; strm->next_out, given the space available and the provided input--the effect; documented in zlib.h of Z_SYNC_FLUSH. Furthermore, inflate() always defers; the allocation of and copying into a sliding window until necessary, which; provides the effect documented in zlib.h for Z_FINISH when the entire input; stream available. So the only thing the flush parameter actually does is:; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c:2283,update,update,2283,builtins/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c,4,['update'],['update']
Deployability,"tector to truth level. TUnfoldDensity is used to decompose a measurement y into several sources x,; given the measurement uncertainties, background b and a matrix of migrations A.; The method can be applied to a large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Beyond such a simple template fit,; TUnfoldDensity has an adjustable regularisation term and also supports an; optional constraint on the total number of events.; Background sources can be specified, with a normalisation constant and; normalisation uncertainty. In addition, variants of the response; matrix may be specified, these are taken to determine systematic; uncertainties. Complex, multidimensional arrangements of signal and; background bins are managed with the help of the class TUnfoldBinning. If you use this software, please consider the following citation; <br/>; <b>S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]</b>; <br/>; Detailed documentation and updates are available on; http://www.desy.de/~sschmitt. <h3>Brief recipy to use TUnfoldSys:</h3>; <ul>; <li>Set up binning schemes for the truth and measured; distributions. The binning schemes may be coded in the XML language,; for reading use TUnfoldBinningXML.</li>; <li>A matrix (truth,reconstructed) is given as a two-dimensional histogram; as argument to the constructor of TUnfold</li>; <li>A vector of measurements is given as one-dimensional histogram using; the SetInput() method</li>; <li>Repeated calls to SubtractBackground() to specify background; sources</li>; <li>Repeated calls to AddSysError() to specify systematic uncertainties; <li>The unfolding is performed; <ul>; <li>either once with a fixed parameter tau, method DoUnfold(tau)</li>; <li>or multiple times in a scan to determine the best chouce of tau,; method ScanLCurve()</li>; <li>or multiple times in a scan to determine the best chouce of tau,; method ScanTau()</li>; </ul>; <li>Unfolding results are retrieved using ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldDensity.cxx:1826,update,updates,1826,hist/unfold/src/TUnfoldDensity.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldDensity.cxx,1,['update'],['updates']
Deployability,"ted, it will; /// show a projected curve integrated over all variables that were present in the shown; /// dataset except for the one on the x-axis. The normalization of the curve will also; /// be adjusted to the event count of the plotted dataset. An informational message; /// will be printed for each projection step that is performed.; ///; /// This function takes the following named arguments; /// <table>; /// <tr><th><th> Projection control; /// <tr><td> `Slice(const RooArgSet& set)` <td> Override default projection behaviour by omitting observables listed; /// in set from the projection, i.e. by not integrating over these.; /// Slicing is usually only sensible in discrete observables, by e.g. creating a slice; /// of the PDF at the current value of the category observable.; ///; /// <tr><td> `Slice(RooCategory& cat, const char* label)` <td> Override default projection behaviour by omitting the specified category; /// observable from the projection, i.e., by not integrating over all states of this category.; /// The slice is positioned at the given label value. To pass multiple Slice() commands, please use the; /// Slice(std::map<RooCategory*, std::string> const&) argument explained below.; ///; /// <tr><td> `Slice(std::map<RooCategory*, std::string> const&)` <td> Omits multiple categories from the projection, as explianed above.; /// Can be used with initializer lists for convenience, e.g.; /// ```{.cpp}; /// pdf.plotOn(frame, Slice({{&tagCategory, ""2tag""}, {&jetCategory, ""3jet""}});; /// ```; ///; /// <tr><td> `Project(const RooArgSet& set)` <td> Override default projection behaviour by projecting over observables; /// given in the set, ignoring the default projection behavior. Advanced use only.; ///; /// <tr><td> `ProjWData(const RooAbsData& d)` <td> Override default projection _technique_ (integration). For observables present in given dataset; /// projection of PDF is achieved by constructing an average over all observable values in given set.; /// Consult",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:1498,integrat,integrating,1498,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['integrat'],['integrating']
Deployability,"th the virtual; // registers %2, and %3, the DbgValueSinkCandidates and the InstrMap will be; // empty. DbgValueSinkCandidates = {}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap {}; // -> DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the first DBG_VALUE (denoted with an X) is processed, the; // DbgValueSinkCandidates and InstrMap will be populated and the RegisterMap; // entry for %2 will be populated as well. DbgValueSinkCandidates = {A -> X},; // RegisterMap = {2 -> {X}, 3 -> {}}, InstrMap {X -> 2}; // DBG_VALUE %2, A, .... # X; // -> DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the DBG_VALUE Y is processed, the DbgValueSinkCandidates is updated; // to now hold Y for A and the RegisterMap is also updated to remove X from; // %2, this is because both X and Y describe the same debug variable A. X is; // also updated to have a $noreg as the first operand.; // DbgValueSinkCandidates = {A -> {Y}}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap = {X-> 2}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // -> DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After DBG_VALUE Z is processed, the DbgValueSinkCandidates is updated to; // hold Z fr A, the RegisterMap is updated to hold Z for %3, and the InstrMap; // is updated to have Z mapped to %3. This is again because Z describes the; // debug variable A, Y is not updated to have $noreg as first operand because; // its first operand is an immediate, not a register.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // -> %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // Nothing happens here since the RegisterMap for %2 contains no value.; // DbgValueSinkCandidates = {A -> {Z",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:2998,update,updated,2998,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['update'],['updated']
Deployability,"the possibility to change the slider; starting and ending positions or only one of them. The current slider position can be retrieved via the functions; TSlider::GetMinimum and TSlider::GetMaximum; These two functions return numbers in the range [0,1]. If a method has been set (via TSlider::SetMethod), the expression is; executed via the interpreter when the button 1 is released. if no method has been set, and an object is referenced (TSlider::SetObject; has been called), while the slider is being moved/resized,; the object ExecuteEvent function is called. ### Example 1 using TSlider::SetMethod. #### macro xyslider.C. ~~~ {.cpp}; void xyslider(); {; // Example of macro featuring two sliders; TFile *f = new TFile(""hsimple.root"");; TH2F *hpxpy = (TH2F*)f->Get(""hpxpy"");; TCanvas *c1 = new TCanvas(""c1"");; TPad *pad = new TPad(""pad"",""Color plot pad"",0.1,0.1,0.98,0.98);; pad->Draw();; pad->cd();; hpxpy->Draw(""COLZ"");; c1->cd();. // Create two sliders in main canvas. When button1 will be released; // the macro action.C will be called.; TSlider *xslider = new TSlider(""xslider"",""x"",0.1,0.02,0.98,0.08);; xslider->SetMethod("".x action.C"");; TSlider *yslider = new TSlider(""yslider"",""y"",0.02,0.1,0.06,0.98);; yslider->SetMethod("".x action.C"");; }; ~~~. #### macro action.C. ~~~ {.cpp}; void action(); {; Int_t nx = hpxpy->GetXaxis()->GetNbins();; Int_t ny = hpxpy->GetYaxis()->GetNbins();; Int_t binxmin = nx*xslider->GetMinimum();; Int_t binxmax = nx*xslider->GetMaximum();; hpxpy->GetXaxis()->SetRange(binxmin,binxmax);; Int_t binymin = ny*yslider->GetMinimum();; Int_t binymax = ny*yslider->GetMaximum();; hpxpy->GetYaxis()->SetRange(binymin,binymax);; pad->cd();; hpxpy->Draw(""COLZ"");; c1->Update();; }; ~~~. The canvas and the sliders created in the above macro are shown in the picture; below. \image html gpad_slider.png. ### Example 2 using TSlider::SetObject macro xyslider.C. Same example as above. Instead of TSlider::SetMethod:; ~~~ {.cpp}; Myclass *obj = new Myclass(); // Myclass ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TSlider.cxx:1153,release,released,1153,graf2d/gpad/src/TSlider.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TSlider.cxx,1,['release'],['released']
Deployability,"the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooNumConvPdf.cxx; \class RooNumConvPdf; \ingroup Roofitcore. Numeric 1-dimensional convolution operator PDF. This class can convolve any PDF; with any other PDF using a straightforward numeric calculation of the; convolution integral; This class should be used as last resort as numeric convolution calculated; this way is computationally intensive and prone to stability fitting problems.; <b>The preferred way to compute numeric convolutions is RooFFTConvPdf</b>,; which calculates convolutions using Fourier Transforms (requires external free; FFTW3 package); RooNumConvPdf implements reasonable defaults that should convolve most; functions reasonably well, but results strongly depend on the shape of your; input PDFS so always check your result.; The default integration engine for the numeric convolution is the; adaptive Gauss-Kronrod method, which empirically seems the most robust; for this task. You can override the convolution integration settings via; the RooNumIntConfig object reference returned by the convIntConfig() member; function; By default the numeric convolution is integrated from -infinity to; +infinity through a <pre>x -> 1/x</pre> coordinate transformation of the; tails. For convolution with a very small bandwidth it may be; advantageous (for both CPU consumption and stability) if the; integration domain is limited to a finite range. The function; setConvolutionWindow(mean,width,scale) allows to set a sliding; window around the x value to be calculated taking a RooAbsReal; expression for an offset and a width to be taken around the x; value. These input expression can be RooFormulaVars or other; function objects although the 3d 'scale' argument 'scale'; multiplies the width RooAbsReal expression given in the 2nd; argument, allowing for an appropriate window definition for most; cases wi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvPdf.cxx:1472,integrat,integration,1472,roofit/roofitcore/src/RooNumConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvPdf.cxx,1,['integrat'],['integration']
Deployability,"tial for making results easy to understand and; interpret. Factors like colorblindness and converting colors to grayscale for publications; can impact accessibility. Furthermore, results should be aesthetically pleasing. The following; three color schemes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); under the MIT License, meet these criteria. These three color schemes are available as color sets with 6, 8, and 10 colors, named; `kP[6, 8, 10]ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; (`P` for Petroff or Preferred). Begin_Macro; ../../../tutorials/graphics/accessiblecolorschemes.C; End_Macro. The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; It also demonstrates that they are effective in grayscale. \anchor C04; ## Grayscale view of of canvas with colors; One can toggle between a grayscale preview and the regular colored mode using; `TCanvas::SetGrayscale()`. Note that in grayscale mode, access via RGB; will return grayscale values according to ITU standards (and close to b&w; printer gray-scales), while access via HLS returns de-saturated gray-scales. The; image below shows the ROOT color wheel in grayscale mode. Begin_Macro(source); {; auto w = new TColorWheel();; auto cw = new TCanvas(""cw"",""cw"",0,0,400,400);; cw->GetCanvas()->SetGrayscale();; w->SetCanvas(cw);; w->Draw();; }; End_Macro. \anchor C05; ## Color palettes; It is often very useful to represent a variable with a color map. The concept; of ""color palette"" allows to do that. One color palette is active at any time.; This ""current palette"" is set using:. ~~~ {.cpp}; gStyle->SetPalette(...);; ~~~. This function has two parameters: the number of colors in the palette and an; array of containing the indices of colors in the palette. The following small; example demonstrates how to define and use the col",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx:5405,toggle,toggle,5405,core/base/src/TColor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx,1,['toggle'],['toggle']
Deployability,"ting entry; points for its contents and provides an iterator over its elements; (bins for binned data sets, data points for unbinned datasets). ### Storing global observables in RooFit datasets. RooFit groups model variables into *observables* and *parameters*, depending on; if their values are stored in the dataset. For fits with parameter; constraints, there is a third kind of variables, called *global observables*.; These represent the results of auxiliary measurements that constrain the; nuisance parameters. In the RooFit implementation, a likelihood is generally; the sum of two terms:; - the likelihood of the data given the parameters, where the normalization set; is the set of observables (implemented by RooNLLVar); - the constraint term, where the normalization set is the set of *global; observables* (implemented by RooConstraintSum). Before this release, the global observable values were always taken from the; model/pdf. With this release, a mechanism is added to store a snapshot of; global observables in any RooDataSet or RooDataHist. For toy studies where the; global observables assume a different values for each toy, the bookkeeping of; the set of global observables and in particular their values is much easier; with this change. Usage example for a model with global observables `g1` and `g2`:; ```; using namespace RooFit;. std::unique_ptr<RooAbsData> data{model.generate(x, 1000)}; // data has only the single observables x; data->setGlobalObservables(g1, g2); // now, data also stores a snapshot of g1 and g2. // If you fit the model to the data, the global observables and their values; // are taken from the dataset:; model.fitTo(*data);. // You can still define the set of global observables yourself, but the values; // will be takes from the dataset if available:; model.fitTo(*data, GlobalObservables(g1, g2));. // To force `fitTo` to take the global observable values from the model even; // though they are in the dataset, you can use the new `GlobalObservab",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:1820,release,release,1820,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['release'],['release']
Deployability,"ting. Int_t RooHypatia2::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char*) const; {; if (matchArgs(allVars, analVars, _x); && _beta == 0. && _beta.arg().isConstant(); && _zeta == 0. && _zeta.arg().isConstant(); && _lambda.max() < 0.) return 1;; return 0 ;; }. double RooHypatia2::analyticalIntegral(Int_t code, const char* rangeName) const; {; if (_beta != 0. || _zeta != 0. || _lambda >= 0) {; auto& logstream = coutF(Integration) << ""When the PDF "" << GetName(); << "" was constructed, beta,zeta were 0, lambda<0 and all three were constant.\n""; << ""This allowed for analytic integration, but now, numeric integration would be required.\n""; << ""These parameters must either be kept constant, or be floating from the beginning. ""; << "" Terminating fit ...""; << std::endl;; RooArgSet vars;; vars.add(_beta.arg());; vars.add(_zeta.arg());; vars.add(_lambda.arg());; vars.printStream(logstream, vars.defaultPrintContents(nullptr), RooPrintable::kVerbose);; throw std::runtime_error(""RooHypatia2 cannot be integrated analytically since parameters changed."");; }. // The formulae to follow still use beta and zeta to facilitate comparisons with the; // evaluate function. Since beta and zeta are zero, all relevant terms will be disabled; // by defining these two constexpr:; constexpr double beta = 0.;; constexpr double cons1 = 1.;. if (code != 1) {; throw std::logic_error(""Trying to compute analytic integral with unknown configuration."");; }. const double asigma = _a * _sigma;; const double a2sigma = _a2 * _sigma;; const double d0 = _x.min(rangeName) - _mu;; const double d1 = _x.max(rangeName) - _mu;. double delta;; if (_lambda <= -1.0) {; delta = _sigma * sqrt(-2. + -2.*_lambda);; }; else {; delta = _sigma;; }; const double deltaSq = delta*delta;. if ((d0 > -asigma) && (d1 < a2sigma)) {; return stIntegral(d1, delta, _lambda) - stIntegral(d0, delta, _lambda);; }. if (d0 > a2sigma) {; const double phi = 1. + a2sigma*a2sigma/deltaSq;; const double k1 = cons1*std::po",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooHypatia2.cxx:1060,integrat,integrated,1060,roofit/roofitmore/src/RooHypatia2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooHypatia2.cxx,1,['integrat'],['integrated']
Deployability,"tion of the posterior function.; The integration and normalization of the posterior is computed using numerical integration methods provided by ROOT.; See the MCMCCalculator for model with multiple parameters of interest. The interface allows one to construct the class by passing the data set, probability density function for the model, the prior; functions and then the parameter of interest to scan. The nuisance parameters can also be passed to be marginalized when; computing the posterior. Alternatively, the class can be constructed by passing the data and the ModelConfig containing; all the needed information (model pdf, prior pdf, parameter of interest, nuisance parameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extreme of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by; scanning the posterior function in the given number of points. The first method is in general faster but it requires an; integration one extra dimension ( in the poi in addition to the nuisance parameters), therefore in some case it can be; less robust. The class can also return the posterior function (method GetPosteriorFunction) or if needed the normalized; posterior function (the posterior pdf) (method GetPosteriorPdf). A posterior plot is also obtained using; the GetPosteriorPlot method. The class allows to use different integration methods for integrating in (marginalizing) the nuisances and in the poi. All the numerical; integration methods of ROOT can be used via the method SetIntegrationType (see more in the documentation of; this method). Calculator estimating a credible interval using the Bayesian procedure.; The calculator computes given the model the posterior distribution and estimates the; credible interval from the given function.; */; // include other header files",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:2319,integrat,integration,2319,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,4,['integrat'],"['integrating', 'integration']"
Deployability,"tion. There are two predefined violin-plot representations:; - ""VIOLINX1"": Standard violin (histogram, mean, whisker over full distribution,; zero indicator line); - ""VIOLINX2"": Line VIOLINX1 both with better whisker definition + outliers. A solid fill style is recommended for this plot (as opposed to a hollow or; hashed style). Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; Int_t nx(6), ny(40);; double xmin(0.0), xmax(+6.0), ymin(0.0), ymax(+4.0);; auto hviolin = new TH2F(""hviolin"", ""Option VIOLIN example"", nx, xmin, xmax, ny, ymin, ymax);; TF1 f1(""f1"", ""gaus"", +0,0 +4.0);; double x,y;; for (Int_t iBin=1; iBin<hviolin->GetNbinsX(); ++iBin) {; double xc = hviolin->GetXaxis()->GetBinCenter(iBin);; f1.SetParameters(1, 2.0+TMath::Sin(1.0+xc), 0.2+0.1*(xc-xmin)/xmax);; for(Int_t i=0; i<10000; ++i){; x = xc;; y = f1.GetRandom();; hviolin->Fill(x, y);; }; }; hviolin->SetFillColor(kGray);; hviolin->SetMarkerStyle(20);; hviolin->SetMarkerSize(0.5);; hviolin->Draw(""VIOLIN"");; c1->Update();; }; End_Macro. The next example illustrates a time development of a certain value:. Begin_Macro(source); ../../../tutorials/hist/candledecay.C; End_Macro. \anchor HP15; ### The TEXT and TEXTnn Option. For each bin the content is printed. The text attributes are:. - text font = current TStyle font (`gStyle->SetTextFont()`).; - text size = 0.02*padheight*markersize (if `h` is the histogram drawn; with the option `TEXT` the marker size can be changed with; `h->SetMarkerSize(markersize)`).; - text color = marker color. By default the format `g` is used. This format can be redefined; by calling `gStyle->SetPaintTextFormat()`. It is also possible to use `TEXTnn` in order to draw the text with; the angle `nn` (`0 < nn <= 90`). For 2D histograms the text is plotted in the center of each non empty cells.; It is possible to plot empty cells by calling `gStyle->SetHistMinimumZero()`; or providing MIN0 draw option. For 1D histogram the text is plotted at a y; position equal to the b",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:60230,Update,Update,60230,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['Update'],['Update']
Deployability,"tional: List of Objective-C classes; # with EH; objc-ivars: [] # Optional: List of Objective C Instance; # Variables; weak-def-symbols: [] # Optional: List of weak defined symbols; thread-local-symbols: [] # Optional: List of thread local symbols. Each undefineds section is defined as following:; - archs: [ arm64 ] # the list of architecture slices; symbols: [ _sym ] # Optional: List of symbols; objc-classes: [] # Optional: List of Objective-C classes; objc-eh-types: [] # Optional: List of Objective-C classes; # with EH; objc-ivars: [] # Optional: List of Objective C Instance Variables; weak-ref-symbols: [] # Optional: List of weak defined symbols; */; /*. YAML Format specification. --- !tapi-tbd; tbd-version: 4 # The tbd version for format; targets: [ armv7-ios, x86_64-maccatalyst ] # The list of applicable tapi supported target triples; uuids: # Optional: List of target and UUID pairs.; - target: armv7-ios; value: ...; - target: x86_64-maccatalyst; value: ...; flags: [] # Optional:; install-name: /u/l/libfoo.dylib #; current-version: 1.2.3 # Optional: defaults to 1.0; compatibility-version: 1.0 # Optional: defaults to 1.0; swift-abi-version: 0 # Optional: defaults to 0; parent-umbrella: # Optional:; allowable-clients:; - targets: [ armv7-ios ] # Optional:; clients: [ clientA ]; exports: # List of export sections; ...; re-exports: # List of reexport sections; ...; undefineds: # List of undefineds sections; ... Each export and reexport section is defined as following:. - targets: [ arm64-macos ] # The list of target triples associated with symbols; symbols: [ _symA ] # Optional: List of symbols; objc-classes: [] # Optional: List of Objective-C classes; objc-eh-types: [] # Optional: List of Objective-C classes; # with EH; objc-ivars: [] # Optional: List of Objective C Instance; # Variables; weak-symbols: [] # Optional: List of weak defined symbols; thread-local-symbols: [] # Optional: List of thread local symbols; - targets: [ arm64-macos, x86_64-maccatalyst ] # Optio",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TextAPI/TextStub.cpp:4763,install,install-name,4763,interpreter/llvm-project/llvm/lib/TextAPI/TextStub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TextAPI/TextStub.cpp,1,['install'],['install-name']
Deployability,"to a large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Beyond such a simple template fit,; TUnfold has an adjustable regularisation term and also supports an; optional constraint on the total number of events. <b>For most applications, it is better to use the derived class; TUnfoldDensity instead of TUnfold. TUnfoldDensity adds various; features to TUnfold, such as:; background subtraction, propagation of systematic uncertainties,; complex multidimensional arrangements of the bins. For innocent; users, the most notable improvement of TUnfoldDensity over TUnfold are; the getter functions. For TUnfold, histograms have to be booked by the; user and the getter functions fill the histogram bins. TUnfoldDensity; simply returns a new, already filled histogram.</b>. If you use this software, please consider the following citation; <br/>; <b>S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]</b>; <br/>; Detailed documentation and updates are available on; http://www.desy.de/~sschmitt. Brief recipy to use TUnfold:; <ul>; <li>a matrix (truth,reconstructed) is given as a two-dimensional histogram; as argument to the constructor of TUnfold</li>; <li>a vector of measurements is given as one-dimensional histogram using; the SetInput() method</li>; <li>The unfolding is performed; <ul>; <li>either once with a fixed parameter tau, method DoUnfold(tau)</li>; <li>or multiple times in a scan to determine the best chouce of tau,; method ScanLCurve()</li>; </ul>; <li>Unfolding results are retrieved using various GetXXX() methods; </ul>. Basic formulae:<br/>; &chi;<sup>2</sup><sub>A</sub>=(Ax-y)<sup>T</sup>V<sub>yy</sub><sup>-1</sup>(Ax-y)<br/>; &chi;<sup>2</sup><sub>L</sub>=(x-f*x<sub>0</sub>)<sup>T</sup>L<sup>T</sup>L(x-f*x<sub>0</sub>)<br/>; &chi;<sup>2</sup><sub>unf</sub>=&chi;<sup>2</sup><sub>A</sub>+&tau;<sup>2</sup>&chi;<sup>2</sup><sub>L</sub>+&lambda;&Sigma;<sub>i</sub>(Ax-y)<sub>i</sub><br/>; x:result, A:probabi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx:3254,update,updates,3254,hist/unfold/src/TUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx,1,['update'],['updates']
Deployability,"to be normalised). #### Normalization/Integration. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex composite PDF; if any of its variables are functions instead of variables. In; such cases, the normalization of the composite PDF may not simply be; integral over the dependents of the top-level PDF: these are; functions with potentially non-trivial Jacobian terms themselves.; \note Therefore, no explicit attempt should be made to normalize the; function output in evaluate(). In particular, normalisation constants; can be omitted to speed up the function evaluations, and included later; in the integration of the PDF (see below), which is rarely called in; comparison to the `evaluate()` function. In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters, and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead, the choice of normalization is always specified each time a; normalized value is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; the help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform an entirely numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e., no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; common, etc). #### Implementing analytical integrals; To implement analytical integrals, two functions must be implemented. First,. ```; Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet); ```",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:2399,integrat,integrated,2399,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['integrat'],['integrated']
Deployability,"to store some meta information about which operands are ""normal"" operands,; /// and which ones belong to some operand bundle.; ///; /// The layout of an operand bundle user is; ///; /// +-----------uint32_t End-------------------------------------+; /// | |; /// | +--------uint32_t Begin--------------------+ |; /// | | | |; /// ^ ^ v v; /// |------|------|----|----|----|----|----|---------|----|---------|----|-----; /// | BOI0 | BOI1 | .. | DU | U0 | U1 | .. | BOI0_U0 | .. | BOI1_U0 | .. | Un; /// |------|------|----|----|----|----|----|---------|----|---------|----|-----; /// v v ^ ^; /// | | | |; /// | +--------uint32_t Begin------------+ |; /// | |; /// +-----------uint32_t End-----------------------------+; ///; ///; /// BOI0, BOI1 ... are descriptions of operand bundles in this User's use; /// list. These descriptions are installed and managed by this class, and; /// they're all instances of OperandBundleUser<T>::BundleOpInfo.; ///; /// DU is an additional descriptor installed by User's 'operator new' to keep; /// track of the 'BOI0 ... BOIN' co-allocation. OperandBundleUser does not; /// access or modify DU in any way, it's an implementation detail private to; /// User.; ///; /// The regular Use& vector for the User starts at U0. The operand bundle; /// uses are part of the Use& vector, just like normal uses. In the diagram; /// above, the operand bundle uses start at BOI0_U0. Each instance of; /// BundleOpInfo has information about a contiguous set of uses constituting; /// an operand bundle, and the total set of operand bundle uses themselves; /// form a contiguous set of uses (i.e. there are no gaps between uses; /// corresponding to individual operand bundles).; ///; /// This class does not know the location of the set of operand bundle uses; /// within the use list -- that is decided by the User using this class via; /// the BeginIdx argument in populateBundleOperandInfos.; ///; /// Currently operand bundle users with hung-off operands are not supported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:1181,install,installed,1181,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['install'],['installed']
Deployability,"ue, Minuit will pass ""internal""; /// values to Gradient. These cannot be synced with this function's RooFit parameters using; /// SetPdfParamVal, unless a manual transformation step is performed in advance. However, they do need to be passed; /// on to the gradient calculator, since indeed we expect values there to be in ""internal"" space. However, this is; /// calculator dependent. Note that in the current MinuitFcnGrad implementation we do not actually allow for; /// calculators in ""external"" (i.e. regular RooFit parameter space) values, since; /// MinuitFcnGrad::returnsInMinuit2ParameterSpace is hardcoded to true. This should in a future version be changed so; /// that the calculator (the wrapper) is queried for this information.; /// Because some gradient calculators may also use the regular RooFit parameters (e.g. for calculating the likelihood's; /// value itself), this information is also passed on to the gradient wrapper. Vice versa, when updated ""internal""; /// parameters are passed to Gradient, the likelihood may be affected as well. Even though a; /// transformation from internal to ""external"" may be necessary before the values can be used, the likelihood can at; /// least log that its parameter values are possibly no longer in sync with those of the gradient.; ///; /// The second twist is that the Minuit external parameters may still be different from the ones used in RooFit. This; /// happens when Minuit tries out values that lay outside the RooFit parameter's range(s). RooFit's setVal (called; /// inside SetPdfParamVal) then clips the RooAbsArg's value to one of the range limits, instead of setting it to the; /// value Minuit intended. When this happens, i.e. syncParameterValuesFromMinuitCalls is called with; /// minuit_internal = false and the values do not match the previous values stored in _minuitInternalX *but* the; /// values after SetPdfParamVal did not get set to the intended value, the _minuitInternalRooFitXMismatch flag is; /// set. This infor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/MinuitFcnGrad.cxx:2558,update,updated,2558,roofit/roofitcore/src/TestStatistics/MinuitFcnGrad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/MinuitFcnGrad.cxx,1,['update'],['updated']
Deployability,"uly 1, 2000, through 1.6.35, July 15, 2018 are; * Copyright (c) 2000-2002, 2004, 2006-2018 Glenn Randers-Pehrson, are; * derived from libpng-1.0.6, and are distributed according to the same; * disclaimer and license as libpng-1.0.6 with the following individuals; * added to the list of Contributing Authors:; *; * Simon-Pierre Cadieux; * Eric S. Raymond; * Mans Rullgard; * Cosmin Truta; * Gilles Vollant; * James Yu; * Mandar Sahastrabuddhe; * Google Inc.; * Vadim Barkov; *; * and with the following additions to the disclaimer:; *; * There is no warranty against interference with your enjoyment of; * the library or against infringement. There is no warranty that our; * efforts or the library will fulfill any of your particular purposes; * or needs. This library is provided with all faults, and the entire; * risk of satisfactory quality, performance, accuracy, and effort is; * with the user.; *; * Some files in the ""contrib"" directory and some configure-generated; * files that are distributed with libpng have other copyright owners, and; * are released under other open source licenses.; *; * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are; * Copyright (c) 1998-2000 Glenn Randers-Pehrson, are derived from; * libpng-0.96, and are distributed according to the same disclaimer and; * license as libpng-0.96, with the following individuals added to the; * list of Contributing Authors:; *; * Tom Lane; * Glenn Randers-Pehrson; * Willem van Schaik; *; * libpng versions 0.89, June 1996, through 0.96, May 1997, are; * Copyright (c) 1996-1997 Andreas Dilger, are derived from libpng-0.88,; * and are distributed according to the same disclaimer and license as; * libpng-0.88, with the following individuals added to the list of; * Contributing Authors:; *; * John Bowler; * Kevin Bracey; * Sam Bushell; * Magnus Holmgren; * Greg Roelofs; * Tom Tanner; *; * Some files in the ""scripts"" directory have other copyright owners,; * but are released under this license.; *;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:3727,release,released,3727,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['release'],['released']
Deployability,"um-of-weights error ( \f$ \left( \sum w \right)^2 / \sum\left(w^2\right) \f$ ); /// - `None` draws no error bars; /// <tr><td> RooFit::Binning(int nbins, double xlo, double xhi); /// <td> Use specified binning to draw dataset; /// <tr><td> RooFit::Binning(const RooAbsBinning&); /// <td> Use specified binning to draw dataset; /// <tr><td> RooFit::Binning(const char* name); /// <td> Use binning with specified name to draw dataset; /// <tr><td> RooFit::RefreshNorm(); /// <td> Force refreshing for PDF normalization information in frame.; /// If set, any subsequent PDF will normalize to this dataset, even if it is; /// not the first one added to the frame. By default only the 1st dataset; /// added to a frame will update the normalization information; /// <tr><td> RooFit::Rescale(double f); /// <td> Rescale drawn histogram by given factor.; /// <tr><td> RooFit::Cut(const char*); /// <td> Only plot entries that pass the given cut.; /// Apart from cutting in continuous variables `Cut(""x>5"")`, this can also be used to plot a specific; /// category state. Use something like `Cut(""myCategory == myCategory::stateA"")`, where; /// `myCategory` resolves to the state number for a given entry and; /// `myCategory::stateA` resolves to the state number of the state named ""stateA"".; ///; /// <tr><td> RooFit::CutRange(const char*); /// <td> Only plot data from given range. Separate multiple ranges with "","".; /// \note This often requires passing the normalisation when plotting the PDF because RooFit does not save; /// how many events were being plotted (it will only work for cutting slices out of uniformly distributed; /// variables).; /// ```; /// data->plotOn(frame01, CutRange(""SB1""));; /// const double nData = data->sumEntries("""", ""SB1"");; /// // Make clear that the target normalisation is nData. The enumerator NumEvent; /// // is needed to switch between relative and absolute scaling.; /// model.plotOn(frame01, Normalization(nData, RooAbsReal::NumEvent),; /// ProjectionRange(""SB1"")",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:2191,continuous,continuous,2191,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['continuous'],['continuous']
Deployability,"urce in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resources is the value (ReleaseAtCycle - AcquireAtCycle).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1884,Release,ReleaseAtCycle,1884,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['Release'],['ReleaseAtCycle']
Deployability,"ust the internal state of an abstract attribute to a point that is; // justifiable by the underlying IR and the current state of abstract attributes; // in-flight. Since the IR is given and assumed to be valid, the information; // derived from it can be assumed to hold. However, information derived from; // other abstract attributes is conditional on various things. If the justifying; // state changed, the `updateImpl` has to revisit the situation and potentially; // find another justification or limit the optimistic assumes made.; //; // Change is the key in this framework. Until a state of no-change, thus a; // fixpoint, is reached, the Attributor will query the abstract attributes; // in-flight to re-evaluate their state. If the (current) state is too; // optimistic, hence it cannot be justified anymore through other abstract; // attributes or the state of the IR, the state of the abstract attribute will; // have to change. Generally, we assume abstract attribute state to be a finite; // height lattice and the update function to be monotone. However, these; // conditions are not enforced because the iteration limit will guarantee; // termination. If an optimistic fixpoint is reached, or a pessimistic fix; // point is enforced after a timeout, the abstract attributes are tasked to; // manifest their result in the IR for passes to come.; //; // Attribute manifestation is not mandatory. If desired, there is support to; // generate a single or multiple LLVM-IR attributes already in the helper struct; // IRAttribute. In the simplest case, a subclass inherits from IRAttribute with; // a proper Attribute::AttrKind as template parameter. The Attributor; // manifestation framework will then create and place a new attribute if it is; // allowed to do so (based on the abstract state). Other use cases can be; // achieved by overloading AbstractAttribute or IRAttribute methods.; //; //; // The ""mechanics"" of adding a new ""abstract attribute"":; // - Define a class (transitivel",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:3556,update,update,3556,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['update'],['update']
Deployability,"vas(""cw"",""cw"",0,0,400,400);; cw->GetCanvas()->SetGrayscale();; w->SetCanvas(cw);; w->Draw();; }; End_Macro. \anchor C05; ## Color palettes; It is often very useful to represent a variable with a color map. The concept; of ""color palette"" allows to do that. One color palette is active at any time.; This ""current palette"" is set using:. ~~~ {.cpp}; gStyle->SetPalette(...);; ~~~. This function has two parameters: the number of colors in the palette and an; array of containing the indices of colors in the palette. The following small; example demonstrates how to define and use the color palette:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",0,0,600,400);; TF2 *f1 = new TF2(""f1"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; Int_t palette[5];; palette[0] = 15;; palette[1] = 20;; palette[2] = 23;; palette[3] = 30;; palette[4] = 32;; gStyle->SetPalette(5,palette);; f1->Draw(""colz"");; return c1;; }; End_Macro. To define more a complex palette with a continuous gradient of color, one; should use the static function `TColor::CreateGradientColorTable()`.; The following example demonstrates how to proceed:. Begin_Macro(source); {; auto c2 = new TCanvas(""c2"",""c2"",0,0,600,400);; auto f2 = new TF2(""f2"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; const Int_t Number = 3;; Double_t Red[Number] = { 1.00, 0.00, 0.00};; Double_t Green[Number] = { 0.00, 1.00, 0.00};; Double_t Blue[Number] = { 1.00, 0.00, 1.00};; Double_t Length[Number] = { 0.00, 0.50, 1.00 };; Int_t nb=50;; TColor::CreateGradientColorTable(Number,Length,Red,Green,Blue,nb);; f2->SetContour(nb);; f2->SetLineWidth(1);; f2->SetLineColor(kBlack);; f2->Draw(""surf1z"");; return c2;; }; End_Macro. The function `TColor::CreateGradientColorTable()` automatically; calls `gStyle->SetPalette()`, so there is not need to add one. After a call to `TColor::CreateGradientColorTable()` it is sometimes; useful to store the newly create palette for further use. In particular, it is; recommended to do if one wants to switch b",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx:6803,continuous,continuous,6803,core/base/src/TColor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx,1,['continuous'],['continuous']
Deployability,"w; - sqrt, cbrt; - sin, cos, tan, asin, acos, atan, atan2, hypot; - sinh, cosh, tanh, asinh, acosh; - erf, erfc; - lgamma, tgamma. If the VDT library is available, the following functions can be invoked. Internally the calculations; are vectorized:; - fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; - fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan. \anchor owningandadoptingmemory; ## Owning and adopting memory; RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case,; it can be constructed with the address of the memory associated to it and its length. For example:; ~~~{.cpp}; std::vector<int> myStlVec {1,2,3};; RVec<int> myRVec(myStlVec.data(), myStlVec.size());; ~~~; In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"".; If any method which implies a re-allocation is called, e.g. *emplace_back* or *resize*, the adopted; memory is released and new one is allocated. The previous content is copied in the new memory and; preserved. \anchor sorting; ## Sorting and manipulation of indices. ### Sorting; RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms; can be used, for example sorting:; ~~~{.cpp}; RVec<double> v{6., 4., 5.};; std::sort(v.begin(), v.end());; ~~~. For convenience, helpers are provided too:; ~~~{.cpp}; auto sorted_v = Sort(v);; auto reversed_v = Reverse(v);; ~~~. ### Manipulation of indices. It is also possible to manipulated the RVecs acting on their indices. For example,; the following syntax; ~~~{.cpp}; RVecD v0 {9., 7., 8.};; auto v1 = Take(v0, {1, 2, 0});; ~~~; will yield a new RVec<double> the content of which is the first, second and zeroth element of; v0, i.e. `{7., 8., 9.}`. The `Argsort` and `StableArgsort` helper extracts the indices which order the content of a `RVec`.; For example, this snippet accomplishes in a more expressive way wh",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:5055,release,released,5055,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['release'],['released']
Deployability,"with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This pass lowers the pseudo control flow instructions to real; /// machine instructions.; ///; /// All control flow is handled using predicated instructions and; /// a predicate stack. Each Scalar ALU controls the operations of 64 Vector; /// ALUs. The Scalar ALU can update the predicate for any of the Vector ALUs; /// by writing to the 64-bit EXEC register (each bit corresponds to a; /// single vector ALU). Typically, for predicates, a vector ALU will write; /// to its bit of the VCC register (like EXEC VCC is 64-bits, one for each; /// Vector ALU) and then the ScalarALU will AND the VCC register with the; /// EXEC to update the predicates.; ///; /// For example:; /// %vcc = V_CMP_GT_F32 %vgpr1, %vgpr2; /// %sgpr0 = SI_IF %vcc; /// %vgpr0 = V_ADD_F32 %vgpr0, %vgpr0; /// %sgpr0 = SI_ELSE %sgpr0; /// %vgpr0 = V_SUB_F32 %vgpr0, %vgpr0; /// SI_END_CF %sgpr0; ///; /// becomes:; ///; /// %sgpr0 = S_AND_SAVEEXEC_B64 %vcc // Save and update the exec mask; /// %sgpr0 = S_XOR_B64 %sgpr0, %exec // Clear live bits from saved exec mask; /// S_CBRANCH_EXECZ label0 // This instruction is an optional; /// // optimization which allows us to; /// // branch if all the bits of; /// // EXEC are zero.; /// %vgpr0 = V_ADD_F32 %vgpr0, %vgpr0 // Do the IF block of the branch; ///; /// label0:; /// %sgpr0 = S_OR_SAVEEXEC_B64 %sgpr0 // Restore the exec mask for the Then; /// // block; /// %exec = S_XOR_B64 %sgpr0, %exec // Update the exec mask; /// S_BRANCH_EXECZ label1 // Use our branch optimization; /// // instruction again.; /// %vgpr0 = V_SUB_F32 %vgpr0, %vgpr // Do the THEN block; /// label1:; /// %exec = S_OR_B64 %exec, %sgpr0 // Re-enable saved exec mask bits; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp:1336,update,update,1336,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,2,"['Update', 'update']","['Update', 'update']"
Deployability,"with the same value of the flush parameter and more output space (updated; avail_out), until the flush is complete (deflate returns with non-zero; avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that; avail_out is greater than six to avoid repeated flush markers due to; avail_out == 0 on return. If the parameter flush is set to Z_FINISH, pending input is processed,; pending output is flushed and deflate returns with Z_STREAM_END if there; was enough output space; if deflate returns with Z_OK, this function must be; called again with Z_FINISH and more output space (updated avail_out) but no; more input data, until it returns with Z_STREAM_END or an error. After; deflate has returned Z_STREAM_END, the only possible operations on the; stream are deflateReset or deflateEnd. Z_FINISH can be used immediately after deflateInit if all the compression; is to be done in a single step. In this case, avail_out must be at least; the value returned by deflateBound (see below). If deflate does not return; Z_STREAM_END, then it must be called again as described above. deflate() sets strm->adler to the adler32 checksum of all input read; so far (that is, total_in bytes). deflate() may update strm->data_type if it can make a good guess about; the input data type (Z_BINARY or Z_TEXT). In doubt, the data is considered; binary. This field is only for information purposes and does not affect; the compression algorithm in any manner. deflate() returns Z_OK if some progress has been made (more input; processed or more output produced), Z_STREAM_END if all input has been; consumed and all output has been produced (only when flush is set to; Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example; if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible; (for example avail_in or avail_out was zero). Note that Z_BUF_ERROR is not; fatal, and deflate() can be called again with more input and more output; space to continue compressing.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:3745,update,update,3745,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['update'],['update']
Deployability,"x;; /// x = x == e ? d : x;; /// x = e == x ? d : x; (this one is not in the spec); /// cond-update-stmt:; /// if (x ordop expr) { x = expr; }; /// if (expr ordop x) { x = expr; }; /// if (x == e) { x = d; }; /// if (e == x) { x = d; } (this one is not in the spec); /// conditional-update-capture-atomic:; /// v = x; cond-update-stmt; (IsPostfixUpdate=true, IsFailOnly=false); /// cond-update-stmt; v = x; (IsPostfixUpdate=false, IsFailOnly=false); /// if (x == e) { x = d; } else { v = x; } (IsPostfixUpdate=false,; /// IsFailOnly=true); /// r = x == e; if (r) { x = d; } (IsPostfixUpdate=false, IsFailOnly=false); /// r = x == e; if (r) { x = d; } else { v = x; } (IsPostfixUpdate=false,; /// IsFailOnly=true); ///; /// \param Loc The insert and source location description.; /// \param X The target atomic pointer to be updated.; /// \param V Memory address where to store captured value (for; /// compare capture only).; /// \param R Memory address where to store comparison result; /// (for compare capture with '==' only).; /// \param E The expected value ('e') for forms that use an; /// equality comparison or an expression ('expr') for; /// forms that use 'ordop' (logically an atomic maximum or; /// minimum).; /// \param D The desired value for forms that use an equality; /// comparison. If forms that use 'ordop', it should be; /// \p nullptr.; /// \param AO Atomic ordering of the generated atomic instructions.; /// \param Op Atomic compare operation. It can only be ==, <, or >.; /// \param IsXBinopExpr True if the conditional statement is in the form where; /// x is on LHS. It only matters for < or >.; /// \param IsPostfixUpdate True if original value of 'x' must be stored in; /// 'v', not an updated one (for compare capture; /// only).; /// \param IsFailOnly True if the original value of 'x' is stored to 'v'; /// only when the comparison fails. This is only valid for; /// the case the comparison is '=='.; ///; /// \return Insertion point after generated atomic capture IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:1868,update,updated,1868,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['update'],['updated']
Deployability,"y name of histogram and number of entries do:; ~~~ {.cpp}; gStyle->SetOptStat(""ne"");; ~~~. To print only the name of the histogram do:; ~~~ {.cpp}; gStyle->SetOptStat(""n"");; ~~~. The default value is:; ~~~ {.cpp}; gStyle->SetOptStat(""nemr"");; ~~~. When a histogram is painted, a `TPaveStats` object is created and added; to the list of functions of the histogram. If a `TPaveStats` object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters. Once a histogram is painted, the statistics box can be accessed using; `h->FindObject(""stats"")`. In the command line it is enough to do:; ~~~ {.cpp}; Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); ~~~. because after `h->Draw()` the histogram is automatically painted. But; in a script file the painting should be forced using `gPad->Update()`; in order to make sure the statistics box is created:; ~~~ {.cpp}; h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");; ~~~. Without `gPad->Update()` the line `h->FindObject(""stats"")`; returns a null pointer. When a histogram is drawn with the option ""`SAME`"", the statistics box; is not drawn. To force the statistics box drawing with the option; ""`SAME`"", the option ""`SAMES`"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""`h`"" being the pointer to the histogram):; ~~~ {.cpp}; Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position; ~~~. To remove the border or shadow of the TPaveStats, use the function TPave::SetBorderSize. To change the type of information for an histogram with an existing; `TPaveStats` one should do:; ~~~ {.cpp}; st->SetOptStat(mode);; ~~~; Where ""`mode`"" has the same meaning than when calling; `gStyle->SetOptStat(mode)` (see above). One can delete the statistics",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TPaveStats.cxx:3356,Update,Update,3356,graf2d/graf/src/TPaveStats.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TPaveStats.cxx,1,['Update'],['Update']
Deployability,"y not be the last use of a register). This means it can be used to; // change the code in ways that affect the values in registers, for example; // by the register scavenger.; // When this property is cleared at a very late time, liveness is no longer; // reliable.; // NoVRegs: The machine function does not use any virtual registers.; // Legalized: In GlobalISel: the MachineLegalizer ran and all pre-isel generic; // instructions have been legalized; i.e., all instructions are now one of:; // - generic and always legal (e.g., COPY); // - target-specific; // - legal pre-isel generic instructions.; // RegBankSelected: In GlobalISel: the RegBankSelect pass ran and all generic; // virtual registers have been assigned to a register bank.; // Selected: In GlobalISel: the InstructionSelect pass ran and all pre-isel; // generic instructions have been eliminated; i.e., all instructions are now; // target-specific or non-pre-isel generic instructions (e.g., COPY).; // Since only pre-isel generic instructions can have generic virtual register; // operands, this also means that all generic virtual registers have been; // constrained to virtual registers (assigned to register classes) and that; // all sizes attached to them have been eliminated.; // TiedOpsRewritten: The twoaddressinstruction pass will set this flag, it; // means that tied-def have been rewritten to meet the RegConstraint.; // FailsVerification: Means that the function is not expected to pass machine; // verification. This can be set by passes that introduce known problems that; // have not been fixed yet.; // TracksDebugUserValues: Without this property enabled, debug instructions; // such as DBG_VALUE are allowed to reference virtual registers even if those; // registers do not have a definition. With the property enabled virtual; // registers must only be used if they have a definition. This property; // allows earlier passes in the pipeline to skip updates of `DBG_VALUE`; // instructions to save compile time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:2635,pipeline,pipeline,2635,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,2,"['pipeline', 'update']","['pipeline', 'updates']"
Deployability,"yImpl.h -----------------------*- C++ -*------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This template implementation resides in a separate file so that it; // does not get injected into every .cpp file that includes the; // generic header.; //; // DO NOT INCLUDE THIS FILE WHEN MERELY USING UNIFORMITYINFO.; //; // This file should only be included by files that implement a; // specialization of the relvant templates. Currently these are:; // - UniformityAnalysis.cpp; //; // Note: The DEBUG_TYPE macro should be defined before using this; // file so that any use of LLVM_DEBUG is associated with the; // including file rather than this file.; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// \brief Implementation of uniformity analysis.; ///; /// The algorithm is a fixed point iteration that starts with the assumption; /// that all control flow and all values are uniform. Starting from sources of; /// divergence (whose discovery must be implemented by a CFG- or even; /// target-specific derived class), divergence of values is propagated from; /// definition to uses in a straight-forward way. The main complexity lies in; /// the propagation of the impact of divergent control flow on the divergence of; /// values (sync dependencies).; ///; /// NOTE: In general, no interface exists for a transform to update; /// (Machine)UniformityInfo. Additionally, (Machine)CycleAnalysis is a; /// transitive dependence, but it also does not provide an interface for; /// updating itself. Given that, transforms should not preserve uniformity in; /// their getAnalysisUsage() callback.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:1665,update,update,1665,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,1,['update'],['update']
Deployability,"yle sheet, JavaScript, help page</a></h3>. <p>The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running <a href=""#THtml:MakeAll"">MakeAll()</a>;; they can be generated on; demand by calling <a href=""#THtml:CreateAuxiliaryFiles"">CreateAuxiliaryFiles()</a>.</p>. <h3><a name=""charts"">VII. Class Charts</a></h3>; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged on-top of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies. These graphs are generated using the <a href=""http://www.graphviz.org/"">Graphviz</a>; package. You can install it from <a href=""http://www.graphviz.org"">http://www.graphviz.org</a>.; You can either put it into your $PATH, or tell THtml where to find it by calling; <a href=""#THtml:SetDotDir"">SetDotDir()</a>. <h3><a name=""confvar"">VIII. Configuration variables</a></h3>. <p>Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; <a href=""http://root.cern.ch/root/html/TEnv.html"">TEnv</a>.</p>. <pre>; Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; Root.Html.Root (default: ) - URL of Root's class documentation; Root.Html.SearchEngine (default: ) - link to the search engine; Root.Html.Search (default: ) - link to search by replacing ""%s"" with user input; Ro",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx:20924,Configurat,Configuration,20924,html/src/THtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx,1,['Configurat'],['Configuration']
Deployability,"ystem (Cartesian, ..; Spheric) see THistPainter::Paint; 'Error' : see 2D plot; 'Bar' : change the bar attributes; 'W' : change Bar Width; 'O' : change Bar Offset; 'Percentage': specifies the percentage of the bar which is drawn; brighter and darker (10% == BAR1 drawoption); 'Horizontal Bar': draw a horizontal bar chart. 'Marker' : change the Marker attributes (color, appearance,; thickness) see TAttMarkerEditor. This Tab has two different layouts. One is for a histogram which; is not drawn from an ntuple. The other one is available for a; histogram which is drawn from an ntuple. In this case the rebin; algorithm can create a rebinned histogram from the original data; i.e. the ntuple.; To see te differences do:; TFile f(""hsimple.root"");; hpx->Draw(""BAR1""); // non ntuple histogram; ntuple->Draw(""px""); // ntuple histogram; Non ntuple histogram:; 'Rebin': with the Slider the number of bins (shown in the field; below the Slider) can be changed to any number which; divides the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; replace it by the rebinned one on the screen; Pushing 'Ignore' the origin histogram will be restored; Histogram drawn from an ntuple:; 'Rebin' with the slider the number of bins can be enlarged by; a factor of 2,3,4,5 (moving to the right) or reduced; by a factor of 1/2, 1/3, 1/4, 1/5; 'BinOffset': with the BinOffset slider the origin of the; histogram can be changed within one binwidth; Using this slider the effect of binning the data into; bins can be made visible => statistical fluctuations; 'Axis Range': with the DoubleSlider it is possible to zoom into; the specified axis range. It is also possible to set; the upper and lower limit in fields below the slider; 'Delayed drawing': all the Binning sliders can set to delay; draw mode. Then the changes on the histogram are only; updated, when the Slider is released. This should be; activated if the redrawing of the histogram is too; time consuming. //. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TH1Editor.cxx:3919,update,updated,3919,gui/ged/src/TH1Editor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TH1Editor.cxx,2,"['release', 'update']","['released', 'updated']"
Deployability,"{p-1}(i_1, i_2, i_3)\f$; ///; /// \image html spectrum3_background_image003.gif; /// \f[; /// \nu_p(i_1, i_2, i_3) = min (a,b); /// \f]; ///; /// where p = 1, 2, ..., number_of_iterations.; ///; /// #### References:; ///; /// [1] C. G Ryan et al.: SNIP, a; /// statistics-sensitive background treatment for the quantitative analysis of PIXE; /// spectra in geoscience applications. NIM, B34 (1988), 396-402./; ///; /// [2] M.Morhac, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.: Background; /// elimination methods for multidimensional gamma-ray spectra. NIM, A401 (1997); /// 113-132.; ///; /// Example 1- script Back3.c :; ///; /// \image html spectrum3_background_image005.jpg Fig. 1 Original three-dimensional gamma-gamma-gamma-ray spectrum; /// \image html spectrum3_background_image006.jpg Fig. 2 Background estimated from data from Fig. 1 using decreasing clipping window with widths 5, 5, 5 and algorithm based on successive comparisons. The estimate includes not only continuously changing background but also one- and two-dimensional ridges.; /// \image html spectrum3_background_image007.jpg Fig. 3 Resulting peaks after subtraction of the estimated background (Fig. 2) from original three-dimensional gamma-gamma-gamma-ray spectrum (Fig. 1).; ///; /// #### Script:; ///; /// Example to illustrate the background estimator (class TSpectrum3).; /// To execute this example, do:; ///; /// `root > .x Back3.C`; ///; /// ~~~ {.cpp}; /// void Back3() {; /// Int_t i, j, k;; /// Int_t nbinsx = 64;; /// Int_t nbinsy = 64;; /// Int_t nbinsz = 64;; /// Int_t xmin = 0;; /// Int_t xmax = nbinsx;; /// Int_t ymin = 0;; /// Int_t ymax = nbinsy;; /// Int_t zmin = 0;; /// Int_t zmax = nbinsz;; /// Double_t*** source = new Double_t**[nbinsx];; /// Double_t*** dest = new Double_t**[nbinsx];; /// for(i=0;i<nbinsx;i++){; /// source[i]=new Double_t*[nbinsy];; /// for(j=0;j<nbinsy;j++); /// source[i][j]=new Double_t[nbinsz];; /// }; /// for(i=0;i<nbinsx;i++){; /// dest[i]=new Double_t*[nbinsy];; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum3.cxx:2609,continuous,continuously,2609,hist/spectrum/src/TSpectrum3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum3.cxx,1,['continuous'],['continuously']
Deployability,"| ""PLC"" | Palette Line Color: graph's line color is taken in the current palette. |; | ""PMC"" | Palette Marker Color: graph's marker color is taken in the current palette. |; | ""RX"" | Reverse the X axis. |; | ""RY"" | Reverse the Y axis. |. Drawing options can be combined. In the following example the graph; is drawn as a smooth curve (option ""C"") with markers (option ""P"") and; with axes (option ""A""). Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",200,10,600,400);. c1->SetFillColor(42);; c1->SetGrid();. const Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; auto gr = new TGraph(n,x,y);; gr->SetLineColor(2);; gr->SetLineWidth(4);; gr->SetMarkerColor(4);; gr->SetMarkerSize(1.5);; gr->SetMarkerStyle(21);; gr->SetTitle(""Option ACP example"");; gr->GetXaxis()->SetTitle(""X title"");; gr->GetYaxis()->SetTitle(""Y title"");; gr->Draw(""ACP"");. // TCanvas::Update() draws the frame, after which one can change it; c1->Update();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; c1->Modified();; }; End_Macro. The following macro shows the option ""B"" usage. It can be combined with the; option ""1"". The bar width is equal to:. bar_width = 0.5*delta*gStyle->GetBarWidth();. Where `delta` is equal to the X maximal value minus the X minimal value divided by the; number of points in the graph. Begin_Macro(source); {; auto c47 = new TCanvas(""c47"",""c47"",200,10,600,400);; c47->Divide(1,2);; const Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2)-6;; }; auto gr = new TGraph(n,x,y);; gr->SetFillColor(38);; gr->SetTitle("" "");; c47->cd(1); gr->Draw(""AB"");; c47->cd(2); gr->Draw(""AB1"");; }; End_Macro. \anchor GrP2; ### Exclusion graphs. When a graph is painted with the option `C` or `L` it is; possible to draw a filled area on one side of the line. This is useful to show; exclusion zones. This drawing mode is activated when the absolute value of the graph line; w",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:3684,Update,Update,3684,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,2,['Update'],['Update']
Deployability,"} > a_r \\; * \end{cases}; * \f]; * Here, \f$ K_\lambda \f$ are the modified Bessel functions of the second kind; * (""irregular modified cylindrical Bessel functions"" from the gsl,; * ""special Bessel functions of the third kind""),; * and \f$ A^2_\lambda(\zeta) \f$ is a ratio of these:; * \f[; * A_\lambda^{2}(\zeta) = \frac{\zeta K_\lambda(\zeta)}{K_{\lambda+1}(\zeta)}; * \f]; *; * \if false; * TODO Enable once analytic integrals work.; * ### Analytical Integration; * The Hypatia distribution can be integrated analytically if \f$ \beta = \zeta = 0 \f$ and; * \f$ \lambda < 0 \f$. An analytic integral will only be used, though, if the parameters are **constant**; * at zero, and if \f$ \lambda < 0 \f$. This can be ensured as follows:; * ```; * RooRealVar beta(""beta"", ""beta"", 0.); // NOT beta(""beta"", ""beta"", 0., -1., 1.) This would allow it to float.; * RooRealVar zeta(""zeta"", ""zeta"", 0.);; * RooRealVar lambda(""lambda"", ""lambda"", -1., -10., -0.00001);; * ```; * In all other cases, slower / less accurate numeric integration will be used.; * Note that including `0.` in the value range of lambda excludes using analytic integrals.; * \endif; *; * ### Concavity; * Note that unless the parameters \f$ a_l,\ a_r \f$ are very large, the function has non-hyperbolic tails. This requires; * \f$ G \f$ to be strictly concave, *i.e.*, peaked, as otherwise the tails would yield imaginary numbers. Choosing \f$ \lambda,; * \beta, \zeta \f$ inappropriately will therefore lead to evaluation errors.; *; * Further, the original paper establishes that to keep the tails from rising,; * \f[; * \begin{split}; * \beta^2 &< \alpha^2 \\; * \Leftrightarrow \beta^2 &< \frac{\zeta^2}{\delta^2} = \frac{\zeta^2}{\sigma^2 A_{\lambda}^2(\zeta)}; * \end{split}; * \f]; * needs to be satisfied, unless the fit range is very restricted, because otherwise, the function rises in the tails.; *; *; * In case of evaluation errors, it is advisable to choose very large values for \f$ a_l,\ a_r \f$, tweak the parameter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooHypatia2.cxx:2814,integrat,integration,2814,roofit/roofitmore/src/RooHypatia2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooHypatia2.cxx,1,['integrat'],['integration']
Deployability,"}w_{1}}{N_{1}w_{1} + N_{2}w_{2}}\\; p_{2} = \frac{\sigma_{2}}{\sigma_{1} + \sigma_{2}} = \frac{N_{2}w_{2}}{N_{1}w_{1} + N_{2}w_{2}}; \f]. \anchor EFF06; ## VI. Further operations. \anchor EFF061; ### VI.1 Information about the internal histograms; The methods TEfficiency::GetPassedHistogram and TEfficiency::GetTotalHistogram; return a constant pointer to the internal histograms. They can be used to; obtain information about the internal histograms (e.g., the binning, number of passed / total events in a bin, mean values...).; One can obtain a clone of the internal histograms by calling TEfficiency::GetCopyPassedHisto or TEfficiency::GetCopyTotalHisto.; The returned histograms are completely independent from the current; TEfficiency object. By default, they are not attached to a directory to; avoid the duplication of data and the user is responsible for deleting them. ~~~~~~~~~~~~~~~{.cpp}; //open a root file which contains a TEfficiency object; TFile* pFile = new TFile(""myfile.root"",""update"");. //get TEfficiency object with name ""my_eff""; TEfficiency* pEff = (TEfficiency*)pFile->Get(""my_eff"");. //get clone of total histogram; TH1* clone = pEff->GetCopyTotalHisto();. //change clone...; //save changes of clone directly; clone->Write();; //or append it to the current directory and write the file; //clone->SetDirectory(gDirectory);; //pFile->Write();. //delete histogram object; delete clone;; clone = 0;; ~~~~~~~~~~~~~~~. It is also possible to set the internal total or passed histogram by using the; methods TEfficiency::SetPassedHistogram or TEfficiency::SetTotalHistogram. In order to ensure the validity of the TEfficiency object, the consistency of the; new histogram and the stored histogram is checked. It might be; impossible sometimes to change the histograms in a consistent way. Therefore one can force; the replacement by passing the ""f"" option. Then the user has to ensure that the; other internal histogram is replaced as well and that the TEfficiency object is; in a",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:21724,update,update,21724,hist/hist/src/TEfficiency.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx,1,['update'],['update']
Energy Efficiency," (within a; * sliding window trailing behind the input currently being processed).; *; * The most straightforward technique turns out to be the fastest for; * most input files: try all possible matches and select the longest.; * The key feature of this algorithm is that insertions into the string; * dictionary are very simple and thus fast, and deletions are avoided; * completely. Insertions are performed at each input character, whereas; * string matches are performed only when the previous match ends. So it; * is preferable to spend more time in matches to allow very fast string; * insertions and avoid deletions. The matching algorithm for small; * strings is inspired from that of Rabin & Karp. A brute force approach; * is used to find longer strings when a small match has been found.; * A similar algorithm is used in comic (by Jan-Mark Wams) and freeze; * (by Leonid Broukhis).; * A previous version of this file used a more sophisticated algorithm; * (by Fiala and Greene) which is guaranteed to run in linear amortized; * time, but has a larger average cost, uses more memory and is patented.; * However the F&G algorithm may be faster for some highly redundant; * files if the parameter max_chain_length (described below) is too large.; *; * ACKNOWLEDGEMENTS; *; * The idea of lazy evaluation of matches is due to Jan-Mark Wams, and; * I found it in 'freeze' written by Leonid Broukhis.; * Thanks to many info-zippers for bug reports and testing.; *; * REFERENCES; *; * APPNOTE.TXT documentation file in PKZIP 1.93a distribution.; *; * A description of the Rabin and Karp algorithm is given in the book; * ""Algorithms"" by R. Sedgewick, Addison-Wesley, p252.; *; * Fiala,E.R., and Greene,D.H.; * Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595; *; * INTERFACE; *; * void lm_init (int pack_level, ush *flags); * Initialize the ""longest match"" routines for a new file; *; * ulg deflate (void); * Processes a new input file and return its compressed length. Sets; * t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c:1301,Green,Greene,1301,core/zip/src/ZDeflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c,1,['Green'],['Greene']
Energy Efficiency," * write to, error); *; * @param pipes set of pipes to check; * @param timeout timeout in milliseconds; * @returns positive number: number of pipes which have; * status changes, 0: timeout, or no pipes with; * status changed, -1 on error; *; * Timeout can be zero (check for specified events, and return), finite; * (wait at most timeout milliseconds before returning), or -1; * (infinite). The poll method returns when the timeout has elapsed,; * or if an event occurs on one of the pipes being polled, whichever; * happens earlier.; *; * Pipes is a vector of one or more PollEntries, which each list a pipe; * and events to poll for. If events is left empty (zero), all; * conditions are polled for, otherwise only the indicated ones. On; * return, the revents fields contain the events that occurred for each; * pipe; error Error, EndOfFile or Invalid events are always set,; * regardless of whether they were in the set of requested events.; *; * poll may block slightly longer than specified by timeout due to OS; * timer granularity and OS scheduling. Due to its implementation, the; * poll call can also return early if the remote end of the page sends; * a free page while polling (which is put on that pipe's freelist),; * while that pipe is polled for e.g Reading. The status of the pipe is; * indicated correctly in revents, and the caller can simply poll; * again. (The reason this is done this way is because it helps to; * replenish the pool of free pages and queue busy pages without; * blocking.); *; * Here's a piece of example code waiting on two pipes; if they become; * readable they are read:; * @code; * #include <unistd.h>; * #include <cstdlib>; * #include <string>; * #include <sstream>; * #include <iostream>; *; * #include ""BidirMMapPipe.h""; *; * // what to execute in the child; * int randomchild(BidirMMapPipe& pipe); * {; * ::srand48(::getpid());; * for (int i = 0; i < 5; ++i) {; * // sleep a random time between 0 and .9 seconds; * ::usleep(int(1e6 * ::drand48()));; * s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:1118,schedul,scheduling,1118,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,1,['schedul'],['scheduling']
Energy Efficiency," /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:2933,efficient,efficient,2933,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['efficient'],['efficient']
Energy Efficiency," 1, %else ]; //; // Suppose %tid holds the thread ID. Although %a is not data dependent on %tid; // because %tid is not on its use-def chains, %a is sync dependent on %tid; // because the branch ""br i1 %cond"" depends on %tid and affects which value %a; // is assigned to.; //; //; // -- Reduction to SSA construction --; // There are two disjoint paths from A to X, if a certain variant of SSA; // construction places a phi node in X under the following set-up scheme.; //; // This variant of SSA construction ignores incoming undef values.; // That is paths from the entry without a definition do not result in; // phi nodes.; //; // entry; // / \; // A \; // / \ Y; // B C /; // \ / \ /; // D E; // \ /; // F; //; // Assume that A contains a divergent branch. We are interested; // in the set of all blocks where each block is reachable from A; // via two disjoint paths. This would be the set {D, F} in this; // case.; // To generally reduce this query to SSA construction we introduce; // a virtual variable x and assign to x different values in each; // successor block of A.; //; // entry; // / \; // A \; // / \ Y; // x = 0 x = 1 /; // \ / \ /; // D E; // \ /; // F; //; // Our flavor of SSA construction for x will construct the following; //; // entry; // / \; // A \; // / \ Y; // x0 = 0 x1 = 1 /; // \ / \ /; // x2 = phi E; // \ /; // x3 = phi; //; // The blocks D and F contain phi nodes and are thus each reachable; // by two disjoins paths from A.; //; // -- Remarks --; // * In case of cycle exits we need to check for temporal divergence.; // To this end, we check whether the definition of x differs between the; // cycle exit and the cycle header (_after_ SSA construction).; //; // * In the presence of irreducible control flow, the fixed point is; // reached only after multiple iterations. This is because labels; // reaching the header of a cycle must be repropagated through the; // cycle. This is true even in a reducible cycle, since the labels; // may have been produced by ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:2237,reduce,reduce,2237,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,1,['reduce'],['reduce']
Energy Efficiency," 32 (1957) 920]. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class Vavilov,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::Mean(kappa, beta2); and sqrt(Vavilov::Variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. Two subclasses are provided:; - VavilovFast uses the algorithm by; A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution,; <A HREF=""http://dx.doi.org/10.1016/0168-583X(90)90749-K"">Nucl. Instr. and Meth. B47 (1990) 215-224</A>,; which has been implemented in; <A HREF=""https://cern-tex.web.cern.ch/cern-tex/shortwrupsdir/g115/top.html"">; CERNLIB (G1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Vavilov.h:1299,charge,charged,1299,math/mathmore/inc/Math/Vavilov.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Vavilov.h,1,['charge'],['charged']
Energy Efficiency," <td> Select fill style, default is not filled. If a filled style is selected,; /// also use VLines() to add vertical downward lines at end of curve to ensure proper closure; /// <tr><td> `FillColor(Int_t color)` <td> Select fill color by ROOT color code; /// <tr><td> `Range(const char* name)` <td> Only draw curve in range defined by given name. Multiple comma-separated ranges can be given.; /// An empty string """" or `nullptr` means to use the default range of the variable.; /// <tr><td> `Range(double lo, double hi)` <td> Only draw curve in specified range; /// <tr><td> `VLines()` <td> Add vertical lines to y=0 at end points of curve; /// <tr><td> `Precision(double eps)` <td> Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. A higher precision will; /// result in more and more densely spaced curve points. A negative precision value will disable; /// adaptive point spacing and restrict sampling to the grid point of points defined by the binning; /// of the plotted observable (recommended for expensive functions such as profile likelihoods); /// <tr><td> `Invisible(bool flag)` <td> Add curve to frame, but do not display. Useful in combination AddTo(); /// <tr><td> `VisualizeError(const RooFitResult& fitres, double Z=1, bool linearMethod=true)`; /// <td> Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma.; /// The linear method is fast but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made.; /// Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate; /// \note To include the uncertainty from the expected number of events,; /// the Normalization() argument with `ScaleType` `RooAbsReal::RelativeExpected` has to be passed, e.g.; /// ```{.cpp}; /// pdf.plotOn(frame, VisualizeError(fitResult), Normalization(1.0, RooAbsReal::RelativeExpected));; /// ``",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:6779,adapt,adaptive,6779,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['adapt'],['adaptive']
Energy Efficiency," Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; ///; /// \file; /// This file supports working with JSON data.; ///; /// It comprises:; ///; /// - classes which hold dynamically-typed parsed JSON structures; /// These are value types that can be composed, inspected, and modified.; /// See json::Value, and the related types json::Object and json::Array.; ///; /// - functions to parse JSON text into Values, and to serialize Values to text.; /// See parse(), operator<<, and format_provider.; ///; /// - a convention and helpers for mapping between json::Value and user-defined; /// types. See fromJSON(), ObjectMapper, and the class comment on Value.; ///; /// - an output API json::OStream which can emit JSON without materializing; /// all structures as json::Value.; ///; /// Typically, JSON data would be read from an external source, parsed into; /// a Value, and then converted into some native data structure before doing; /// real work on it. (And vice versa when writing).; ///; /// Other serialization mechanisms you may consider:; ///; /// - YAML is also text-based, and more human-readable than JSON. It's a more; /// complex format and data model, and YAML parsers aren't ubiquitous.; /// YAMLParser.h is a streaming parser suitable for parsing large documents; /// (including JSON, as YAML is a superset). It can be awkward to use; /// directly. YAML I/O (YAMLTraits.h) provides data mapping that is more; /// declarative than the toJSON/fromJSON conventions here.; ///; /// - LLVM bitstream is a space- and CPU- efficient binary format. Typically it; /// encodes LLVM IR (""bitcode""), but it can be a container for other data.; /// Low-level reader/writer libraries are in Bitstream/Bitstream*.h; ///; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:1855,efficient,efficient,1855,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['efficient'],['efficient']
Energy Efficiency," DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // ScheduleDAGMI *DAG = createGenericSchedLive(C);; // DAG->addMutation(new CustomDAGMutation(...));; // return DAG;; // }; //; // A target that supports alternative schedulers can use the; // MachineSchedRegistry to allow command line selection. This can be done by; // implementing the following boilerplate:; //; // static ScheduleDAGInstrs *createCustomMachineSched(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; // static MachineSchedRegistry; // SchedCustomRegistry(""custom"", ""Run my target's custom scheduler"",; // createCustomMachineSched);; //; //; // Finally, subtargets that don't need to implement custom heuristics but would; // like to configure the GenericScheduler's policy for a given scheduler region,; // including scheduling direction and register pressure tracking policy, can do; // this:; //; // void <SubTarget>Subtarget::; // overrideSchedPolicy(MachineSchedPolicy &Policy,; // unsigned NumRegionInstrs) const {; // Policy.<Flag> = true;; // }; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:2160,schedul,schedulers,2160,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,5,"['Schedul', 'schedul']","['ScheduleDAGInstrs', 'scheduler', 'schedulers', 'scheduling']"
Energy Efficiency," FOR A PARTICULAR PURPOSE; ** ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE ; ** LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR ; ** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF ; ** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS; ** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN; ** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE); ** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF; ** THE POSSIBILITY OF SUCH DAMAGE.; */; /*; * Mesa 3-D graphics library; * Version: 7.0; *; * Copyright (C) 1999-2007 Brian Paul All Rights Reserved.; *; * Permission is hereby granted, free of charge, to any person obtaining a; * copy of this software and associated documentation files (the ""Software""),; * to deal in the Software without restriction, including without limitation; * the rights to use, copy, modify, merge, publish, distribute, sublicense,; * and/or sell copies of the Software, and to permit persons to whom the; * Software is furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included; * in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS; * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL; * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN; * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN; * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.; */; /*; ** Copyright (c) 2007 The Khronos Group Inc.; ** ; ** Permission is hereby granted, free of charge, to any person obtaining a; ** copy of this software and/or associated documentation files (the; ** ""Materials""), to deal in the Materia",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/inc/GL/eglew.h:1951,charge,charge,1951,builtins/glew/inc/GL/eglew.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/inc/GL/eglew.h,3,['charge'],['charge']
Energy Efficiency," For example with Event.root, if; /// ~~~{.cpp}; /// Double_t somepx = fTracks.fPx[2];; /// ~~~; /// is executed by one of the method of the skeleton,; /// somepx will be updated with the current value of fPx of the 3rd track.; ///; /// Both macrofilename and the optional cutfilename are expected to be; /// the name of source files which contain at least a free standing; /// function with the signature:; /// ~~~{.cpp}; /// x_t macrofilename(); // i.e function with the same name as the file; /// ~~~; /// and; /// ~~~{.cpp}; /// y_t cutfilename(); // i.e function with the same name as the file; /// ~~~; /// x_t and y_t needs to be types that can convert respectively to a double; /// and a bool (because the skeleton uses:; /// ~~~{.cpp}; /// if (cutfilename()) htemp->Fill(macrofilename());; /// ~~~; /// This 2 functions are run in a context such that the branch names are; /// available as local variables of the correct (read-only) type.; ///; /// Note that if you use the same 'variable' twice, it is more efficient; /// to 'cache' the value. For example; /// ~~~{.cpp}; /// Int_t n = fEventNumber; // Read fEventNumber; /// if (n<10 || n>10) { ... }; /// ~~~; /// is more efficient than; /// ~~~{.cpp}; /// if (fEventNumber<10 || fEventNumber>10); /// ~~~; /// Access to TClonesArray.; ///; /// If a branch (or member) is a TClonesArray (let's say fTracks), you; /// can access the TClonesArray itself by using ->:; /// ~~~{.cpp}; /// fTracks->GetLast();; /// ~~~; /// However this will load the full TClonesArray object and its content.; /// To quickly read the size of the TClonesArray use (note the dot):; /// ~~~{.cpp}; /// fTracks.GetEntries();; /// ~~~; /// This will read only the size from disk if the TClonesArray has been; /// split.; /// To access the content of the TClonesArray, use the [] operator:; /// ~~~; /// float px = fTracks[i].fPx; // fPx of the i-th track; /// ~~~; /// Warning:; ///; /// The variable actually use for access are 'wrapper' around the; /// real data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:2942,efficient,efficient,2942,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,1,['efficient'],['efficient']
Energy Efficiency," LDS variables are expanded to instructions. This; // may need amending when implementing non-undef initialisers.; //; // Lowering is split between this IR pass and the back end. This pass chooses; // where given variables should be allocated and marks them with metadata,; // MD_absolute_symbol. The backend places the variables in coincidentally the; // same location and raises a fatal error if something has gone awry. This works; // in practice because the only pass between this one and the backend that; // changes LDS is PromoteAlloca and the changes it makes do not conflict.; //; // Addresses are written to constant global arrays based on the same metadata.; //; // The backend lowers LDS variables in the order of traversal of the function.; // This is at odds with the deterministic layout required. The workaround is to; // allocate the fixed-address variables immediately upon starting the function; // where they can be placed as intended. This requires a means of mapping from; // the function to the variables that it allocates. For the module scope lds,; // this is via metadata indicating whether the variable is not required. If a; // pass deletes that metadata, a fatal error on disagreement with the absolute; // symbol metadata will occur. For kernel scope and dynamic, this is by _name_; // correspondence between the function and the variable. It requires the; // kernel to have a name (which is only a limitation for tests in practice) and; // for nothing to rename the corresponding symbols. This is a hazard if the pass; // is run multiple times during debugging. Alternative schemes considered all; // involve bespoke metadata.; //; // If the name correspondence can be replaced, multiple distinct kernels that; // have the same memory layout can map to the same kernel id (as the address; // itself is handled by the absolute symbol metadata) and that will allow more; // uses of the ""kernel"" style faster lowering and reduce the size of the lookup; // tables.; //; // T",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:8551,allocate,allocates,8551,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['allocate'],['allocates']
Energy Efficiency," NColors: Total number of colors in the table. Must be at least 1.; /// - alpha: the opacity factor, between 0 and 1. Default is no transparency (1).; /// - setPalette: activate the newly created palette (true by default). If false,; /// the caller is in charge of calling TColor::SetPalette using the; /// return value of the function (first palette color index) and; /// reconstructing the Int_t palette[NColors+1] array.; ///; /// Returns a positive value (the index of the first color of the palette) on; /// success and -1 on error.; ///; /// The table is constructed by tracing lines between the given points in; /// RGB space. Each color value may have a value between 0 and 1. The; /// difference between consecutive ""Stops"" values gives the fraction of; /// space in the whole table that should be used for the interval between; /// the corresponding color values.; ///; /// Normally the first element of Stops should be 0 and the last should be 1.; /// If this is not true, fewer than NColors will be used in proportion with; /// the total interval between the first and last elements of Stops.; ///; /// This definition is similar to the povray-definition of gradient; /// color tables.; ///; /// For instance:; /// ~~~ {.cpp}; /// UInt_t Number = 3;; /// Double_t Red[3] = { 0.0, 1.0, 1.0 };; /// Double_t Green[3] = { 0.0, 0.0, 1.0 };; /// Double_t Blue[3] = { 1.0, 0.0, 1.0 };; /// Double_t Stops[3] = { 0.0, 0.4, 1.0 };; /// ~~~; /// This defines a table in which there are three color end points:; /// RGB = {0, 0, 1}, {1, 0, 0}, and {1, 1, 1} = blue, red, white; /// The first 40% of the table is used to go linearly from blue to red.; /// The remaining 60% of the table is used to go linearly from red to white.; ///; /// If you define a very short interval such that less than one color fits; /// in it, no colors at all will be allocated. If this occurs for all; /// intervals, ROOT will revert to the default palette.; ///; /// Original code by Andreas Zoglauer (zog@mpe.mpg.de)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx:1847,Green,Green,1847,core/base/src/TColor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx,2,"['Green', 'allocate']","['Green', 'allocated']"
Energy Efficiency," Partitioning Algorithm; The partitioning algorithm forms an essential part of the `TH2Poly`; class. It is implemented to speed up the filling of bins. With the brute force approach, the filling is done in the following way: An; iterator loops over all bins in the `TH2Poly` and invokes the; method `IsInside()` for each of them.; This method checks if the input location is in that bin. If the filling; coordinate is inside, the bin is filled. Looping over all the bin is; very slow. The alternative is to divide the histogram into virtual rectangular regions; called ""cells"". Each cell stores the pointers of the bins intersecting it.; When a coordinate is to be filled, the method finds which cell the coordinate; falls into. Since the cells are rectangular, this can be done very quickly.; It then only loops over the bins associated with that cell and calls `IsInside()`; only on that bins. This reduces considerably the number of bins on which `IsInside()`; is called and therefore speed up by a huge factor the filling compare to the brute force; approach where `IsInside()` is called for all bins. The addition of bins to the appropriate cells is done when the bin is added; to the histogram. To do this, `AddBin()` calls the; `AddBinToPartition()` method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the `ChangePartition()` method.; `ChangePartition()` deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times `Fill()` will be called. Although",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:3962,reduce,reduces,3962,hist/hist/src/TH2Poly.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx,1,['reduce'],['reduces']
Energy Efficiency," The tutorial sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. ## Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call. THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);. ## Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:3507,allocate,allocated,3507,hist/hist/src/THnSparse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx,1,['allocate'],['allocated']
Energy Efficiency," a function that transfers; /// reduced variables across warps. It tunnels, through CUDA; /// shared memory, the thread-private data of type 'ReduceData'; /// from lane 0 of each warp to a lane in the first warp.; /// 4. Call the OpenMP runtime on the GPU to reduce across teams.; /// The last team writes the global reduced value to memory.; ///; /// ret = __kmpc_nvptx_teams_reduce_nowait(...,; /// reduceData, shuffleReduceFn, interWarpCpyFn,; /// scratchpadCopyFn, loadAndReduceFn); ///; /// 'scratchpadCopyFn' is a helper that stores reduced; /// data from the team master to a scratchpad array in; /// global memory.; ///; /// 'loadAndReduceFn' is a helper that loads data from; /// the scratchpad array and reduces it with the input; /// operand.; ///; /// These compiler generated functions hide address; /// calculation and alignment information from the runtime.; /// 5. if ret == 1:; /// The team master of the last team stores the reduced; /// result to the globals in memory.; /// foo += reduceData.foo; bar *= reduceData.bar; ///; ///; /// Warp Reduction Algorithms; ///; /// On the warp level, we have three algorithms implemented in the; /// OpenMP runtime depending on the number of active lanes:; ///; /// Full Warp Reduction; ///; /// The reduce algorithm within a warp where all lanes are active; /// is implemented in the runtime as follows:; ///; /// full_warp_reduce(void *reduce_data,; /// kmp_ShuffleReductFctPtr ShuffleReduceFn) {; /// for (int offset = WARPSIZE/2; offset > 0; offset /= 2); /// ShuffleReduceFn(reduce_data, 0, offset, 0);; /// }; ///; /// The algorithm completes in log(2, WARPSIZE) steps.; ///; /// 'ShuffleReduceFn' is used here with lane_id set to 0 because it is; /// not used therefore we save instructions by not retrieving lane_id; /// from the corresponding special registers. The 4th parameter, which; /// represents the version of the algorithm being used, is set to 0 to; /// signify full warp reduction.; ///; /// In this version, 'ShuffleReduc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:4517,reduce,reduceData,4517,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['reduce'],['reduceData']
Energy Efficiency," along axis 2:; //; // No regular bins on the Some of them on the No regular bins again; // UF plane of axis 2 regular planes of ax.2 on the OF plane of ax.2; //; // -1 -2 -3 -4 -17 -18 -19 -20 -29 -30 -31 -32; // -5 -6 -7 -8 -21 1 2 -22 -33 -34 -35 -36; // -9 -10 -11 -12 -23 3 4 -24 -37 -37 -39 -40; // -13 -14 -15 -16 -25 -26 -27 -28 -41 -42 -43 -44; //; // We can generalize this to N dimensions by saying that as we slide along; // the last axis of an N-d histogram, we see an hyperplane full of overflow; // bins, then some hyperplanes with regular bins in the ""middle"" surrounded; // by overflow bins, then a last hyperplane full of overflow bins.; //; // From this, we can devise a recursive algorithm to recover the number of; // regular bins before the overflow bin we're currently looking at:; //; // - Start by processing the last histogram axis.; // - Ignore the first and last hyperplane on this axis, which only contain; // underflow and overflow bins respectively.; // - Count how many complete hyperplanes of regular bins lie before us on; // this axis, which we can do indirectly in our overflow bin based; // reasoning by computing the perimeter of the regular region and dividing; // our ""regular"" overflow bin count by that amount.; // - Now we counted previous hyperplanes on this last histogram axis, but; // we need to process the hyperplane that our bin is located in, if any.; // * For this, we reduce our overflow bin count to a count of; // _unaccounted_ overflow bins in the current hyperplane...; // * ...which allows us to recursively continue the computation by; // processing the next (well, previous) histogram axis in the context; // of this hyperplane, in the same manner as above.; //; // Alright, now that the general plan is sorted out, let's compute some; // quantities that we are going to need, namely the total number of bins per; // hyperplane (overflow and regular) and the number of regular bins per; // hyperplane on the hyperplanes that have them.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:2081,reduce,reduce,2081,hist/histv7/inc/ROOT/RHistImpl.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx,1,['reduce'],['reduce']
Energy Efficiency," are available when `colors == 0`.; The following value of `ncolors` give access to:. if ncolors = 51 and colors=0, a Deep Sea palette is used.; if ncolors = 52 and colors=0, a Grey Scale palette is used.; if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); if ncolors = 55 and colors=0, a Rain Bow palette is used.; if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used. If `ncolors > 0 && colors == 0`, the default palette is used with a maximum of ncolors. The default palette defines:. - index 0 to 9 : shades of grey; - index 10 to 19 : shades of brown; - index 20 to 29 : shades of blue; - index 30 to 39 : shades of red; - index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting; the item `colors` in the `VIEW` menu of the canvas tool bar.; The red, green, and blue components of a color can be changed thanks to; `TColor::SetRGB()`. \since **ROOT version 6.19/01**. As default labels and ticks are drawn by `TGAxis` at equidistant (lin or log); points as controlled by SetNdivisions.; If option ""CJUST"" is given labels and ticks are justified at the; color boundaries defined by the contour levels.; For more details see `TPaletteAxis`. \anchor HP24; ### Drawing a sub-range of a 2D histogram; the [cutg] option. Using a `TCutG` object, it is possible to draw a sub-range of a 2D; histogram. One must create a graphical cut (mouse or C++) and specify the name; of the cut between `[]` in the `Draw()` option.; For example (fit2a.C), with a `TCutG` named `cutg`, one can call:. myhist->Draw(""surf1 [cutg]"");. To invert the cut, it is enough to put a `-` in front of its name:. myhist->Draw(""surf1 [-cutg]"");. It is possible to apply several cuts (`,` means logical AND):. myhist->Draw(""surf1 [cutg1,cutg2]"");. Begin_Macro(source); ../../../tutorials/fit/fit2a.C; End_Macro. \anchor HP25",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:89858,green,green,89858,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['green'],['green']
Energy Efficiency," associated with pdf observables that match the given tagName.; * <tr><td> `Verbose(bool flag)` <td> Controls RooFit informational messages in likelihood construction; * <tr><td> `CloneData(bool flag)` <td> Use clone of dataset in NLL (default is true).; * \warning Deprecated option that is ignored. It is up to the implementation of the NLL creation method if the data is cloned or not.; * <tr><td> `Offset(std::string const& mode)` <td> Likelihood offsetting mode. Can be either:; * <table>; * <tr><th> Mode <th> Description; * <tr><td> **none** - *default* <td> No offsetting.; * <tr><td> **initial** <td> Offset likelihood by initial value (so that starting value of FCN in minuit is zero).; * This can improve numeric stability in simultaneous fits with components with large likelihood values.; * <tr><td> **bin** <td> Offset likelihood bin-by-bin with a template histogram model based on the obersved data.; * This results in per-bin values that are all in the same order of magnitude, which reduces precision loss in the sum,; * which can drastically improve numeric stability.; * Furthermore, \f$2\cdot \text{NLL}\f$ defined like this is approximately chi-square distributed, allowing for goodness-of-fit tests.; * </table>; * <tr><td> `IntegrateBins(double precision)` <td> In binned fits, integrate the PDF over the bins instead of using the probability density at the bin centre.; * This can reduce the bias observed when fitting functions with high curvature to binned data.; * - precision > 0: Activate bin integration everywhere. Use precision between 0.01 and 1.E-6, depending on binning.; * Note that a low precision such as 0.01 might yield identical results to 1.E-4, since the integrator might reach 1.E-4 already in its first; * integration step. If lower precision is desired (more speed), a RooBinSamplingPdf has to be created manually, and its integrator; * has to be manipulated directly.; * - precision = 0: Activate bin integration only for continuous PDFs fit to a RooDat",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:8784,reduce,reduces,8784,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['reduce'],['reduces']
Energy Efficiency," being added to the; ZIP file, since ROOT files are normally already compressed.; Such a ZIP file should be created like:; zip -n root multi file1.root file2.root; which creates a ZIP file multi.zip.; A ZIP archive consists of files compressed with the popular ZLIB; compression algorithm. The archive format is used among others by; PKZip and Info-ZIP. The compression algorithm is also used by; GZIP and the PNG graphics standard. The format of the archives is; explained briefly below. This class provides an interface to read; such archives.; A ZIP archive contains a prefix, series of archive members; (sub-files), and a central directory. In theory the archive could; span multiple disks (or files) with the central directory of the; whole archive on the last disk, but this class does not support; such multi-part archives. The prefix is only used in self-extracting; executable archive files.; The members are stored in the archive sequentially, each with a; local header followed by the (optionally) compressed data; the local; header describes the member, including its file name and compressed; and real sizes. The central directory includes the member details; again, plus allows an extra member comment to be added. The last; member in the central directory is an end marker that can contain; a comment for the whole archive. Both the local header and the; central directory can also carry extra member-specific data; the; data in the local and global parts can be different.; The fact that the archive has a global directory makes it efficient; and allows for only the reading of the desired data, one does not; have to scan through the whole file to find the desired sub-file.; The Zip64 extensions are supported so files larger than 2GB can be; stored in archives larger than 4 GB.; Once the archive has been opened, the client can query the members; and read their contents by asking the archive for an offset where; the sub-file starts. The members can be accessed in any order.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TZIPFile.cxx:2171,efficient,efficient,2171,io/io/src/TZIPFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TZIPFile.cxx,1,['efficient'],['efficient']
Energy Efficiency," can be in 2 formats :; * 8 bit and 24.8 bit. 24.8 bit makes for 32bit value with lower 8 bits; * used as a fraction for better calculation precision.; *; * HSV colorspace: each color is represented as a combination of; * hue, saturation and value. Hue is generally colorizing component where; * value represents brightness.; *; * HLS colorspace: each color is represented as a combination of; * hue, luminance and saturation. It is analogous to HSV with value; * substituted by luminance, except that luminance could be both; * negative and positive.; *; * alpha channel could be added to any of the above colorspaces. alpha; * channel is generally used to define transparentness of the color.; * libAfterImage is using ARGB colorspace as a base colorspace, and; * represents most colors as ARGB32 values or ASScanline scanlines of; * pixels.; ****************/; /****f* libAfterImage/rgb2value(); * NAME; * rgb2value(); * NAME; * rgb2saturation(); * NAME; * rgb2hue(); * NAME; * rgb2luminance(); * SYNOPSIS; * CARD32 rgb2value( CARD32 red, CARD32 green, CARD32 blue );; * CARD32 rgb2saturation( CARD32 red, CARD32 green, CARD32 blue );; * CARD32 rgb2hue( CARD32 red, CARD32 green, CARD32 blue );; * CARD32 rgb2luminance (CARD32 red, CARD32 green, CARD32 blue );; * INPUTS; * red - 32 bit value, 16 lower bits of which represent red channel; * green - 32 bit value, 16 lower bits of which represent green channel; * blue - 32 bit value, 16 lower bits of which represent blue channel; * RETURN VALUE; * 32 bit value, 16 lower bits of which represent value, saturation, hue,; * or luminance respectively.; * DESCRIPTION; * This functions translate RGB color into respective coordinates of; * HSV and HLS colorspaces.; * Returned hue values are in 16bit format. To translate it to and from; * conventional 0-360 degree range, please use :; * degrees2hue16() - converts conventional hue in 0-360 range into hue16; * hue162degree() - converts 16bit hue value into conventional degrees.; ****************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.h:1225,green,green,1225,graf2d/asimage/src/libAfterImage/blender.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.h,6,['green'],['green']
Energy Efficiency," constructor accepts an optional ""sparkcontext"" parameter; # and it will distribute the application to the connected cluster; df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); ~~~. If an instance of [SparkContext](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkContext.html); is not provided, the default behaviour is to create one in the background for you. ### Connecting to a Dask cluster. Similarly, you can connect to a Dask cluster by creating your own connection object which internally operates with one; of the cluster schedulers supported by Dask (more information in the; [Dask distributed docs](http://distributed.dask.org/en/stable/)):. ~~~{.py}; import ROOT; from dask.distributed import Client. # Point RDataFrame calls to the Dask specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame. # In a Python script the Dask client needs to be initalized in a context; # Jupyter notebooks / Python session don't need this; if __name__ == ""__main__"":; # With an already setup cluster that exposes a Dask scheduler endpoint; client = Client(""dask_scheduler.domain.com:8786""). # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); ~~~. If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; using all cores available. ### Choosing the number of distributed tasks. A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; generically tries to infer how many cores are available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:39811,schedul,scheduler,39811,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['schedul'],['scheduler']
Energy Efficiency," copy of the object is shared; memory call Update() also whenever the mapped object(s) change(s); call Update() to put a fresh copy in the shared memory. This extra; step is necessary since it is not possible to share objects with; virtual pointers between processes (the vtbl ptr points to the; originators unique address space and can not be used by the; consumer process(es)). Consumer processes can map the memory region; from this file and access the objects stored in it via the Get(); method (which returns a copy of the object stored in the shared; memory with correct vtbl ptr set). Only objects of classes with a; Streamer() member function defined can be shared. I know the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; -# One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; -# Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; -# A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy). Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3).; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx:1149,allocate,allocate,1149,io/io/src/TMapFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx,1,['allocate'],['allocate']
Energy Efficiency," corresponding original C (X,Y,Z). Thus the; * three chromaticity values (x,y,z) for each end-point obey the; * relationship:; *; * x + y + z = 1; *; * This describes the plane in (X,Y,Z) space that intersects each axis at the; * value 1.0; call this the chromaticity plane. Thus the chromaticity; * calculation has scaled each end-point so that it is on the x+y+z=1 plane; * and chromaticity is the intersection of the vector from the origin to the; * (X,Y,Z) value with the chromaticity plane.; *; * To fully invert the chromaticity calculation we would need the three; * end-point scale factors, (red-scale, green-scale, blue-scale), but these; * were not recorded. Instead we calculated the reference white (X,Y,Z) and; * recorded the chromaticity of this. The reference white (X,Y,Z) would have; * given all three of the scale factors since:; *; * color-C = color-c * color-scale; * white-C = red-C + green-C + blue-C; * = red-c*red-scale + green-c*green-scale + blue-c*blue-scale; *; * But cHRM records only white-x and white-y, so we have lost the white scale; * factor:; *; * white-C = white-c*white-scale; *; * To handle this the inverse transformation makes an arbitrary assumption; * about white-scale:; *; * Assume: white-Y = 1.0; * Hence: white-scale = 1/white-y; * Or: red-Y + green-Y + blue-Y = 1.0; *; * Notice the last statement of the assumption gives an equation in three of; * the nine values we want to calculate. 8 more equations come from the; * above routine as summarised at the top above (the chromaticity; * calculation):; *; * Given: color-x = color-X / (color-X + color-Y + color-Z); * Hence: (color-x - 1)*color-X + color.x*color-Y + color.x*color-Z = 0; *; * This is 9 simultaneous equations in the 9 variables ""color-C"" and can be; * solved by Cramer's rule. Cramer's rule requires calculating 10 9x9 matrix; * determinants, however this is not as bad as it seems because only 28 of; * the total of 90 terms in the various matrices are non-zero. Nevertheless; * Cramer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:1467,green,green-C,1467,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,3,['green'],"['green-C', 'green-c', 'green-scale']"
Energy Efficiency," derived class has always the following methods available:. #### Condition() :; In an iterative scheme the condition number for matrix inversion is; calculated . This number is of interest for estimating the accuracy; of x in the equation Ax=b; For example:; A is a (10x10) Hilbert matrix which looks deceivingly innocent; and simple, A(i,j) = 1/(i+j+1); b(i) = Sum_j A(i,j), so a sum of a row in A. the solution is x(i) = 1. i=0,.,9. However,; ~~~; TMatrixD m....; TVectorD b.....; TDecompLU lu(m); lu.SetTol(1.0e-12); lu.Solve(b); b.Print(); ~~~; gives,. ~~~; {1.000,1.000,1.000,1.000,0.998,1.000,0.993,1.001,0.996,1.000}; ~~~. Looking at the condition number, this is in line with expected the; accuracy . The condition number is 3.957e+12 . As a simple rule of; thumb, a condition number of 1.0e+n means that you lose up to n; digits of accuracy in a solution . Since doubles are stored with 15; digits, we can expect the accuracy to be as small as 3 digits . #### Det(Double_t &d1,Double_t &d2); The determinant is d1*TMath::Power(2.,d2); Expressing the determinant this way makes under/over-flow very; unlikely . #### Decompose(); Here the actually decomposition is performed . One can change the; matrix A after the decomposition constructor has been called; without effecting the decomposition result. #### Solve(TVectorD &b); Solve A x = b . x is supplied through the argument and replaced with; the solution . #### TransSolve(TVectorD &b); Solve A^T x = b . x is supplied through the argument and replaced; with the solution . #### MultiSolve(TMatrixD &B); Solve A X = B . where X and are now matrices . X is supplied through; the argument and replaced with the solution . #### Invert(TMatrixD &inv); This is of course just a call to MultiSolve with as input argument; the unit matrix . Note that for a matrix a(m,n) with m > n a; pseudo-inverse is calculated . ### Tolerances and Scaling. The tolerance parameter (which is a member of this base class) plays; a crucial role in all operation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompBase.cxx:1781,Power,Power,1781,math/matrix/src/TDecompBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompBase.cxx,1,['Power'],['Power']
Energy Efficiency," file. If you are writing the file, fill in the information; * you want to put into the PNG file, using png_set_*() functions, then; * call png_write_info().; *; * The names chosen should be very close to the PNG specification, so; * consult that document for information about the meaning of each field.; *; * With libpng < 0.95, it was only possible to directly set and read the; * the values in the png_info_struct, which meant that the contents and; * order of the values had to remain fixed. With libpng 0.95 and later,; * however, there are now functions that abstract the contents of; * png_info_struct from the application, so this makes it easier to use; * libpng with dynamic libraries, and even makes it possible to use; * libraries that don't have all of the libpng ancillary chunk-handing; * functionality. In libpng-1.5.0 this was moved into a separate private; * file that is not visible to applications.; *; * The following members may have allocated storage attached that should be; * cleaned up before the structure is discarded: palette, trans, text,; * pcal_purpose, pcal_units, pcal_params, hist, iccp_name, iccp_profile,; * splt_palettes, scal_unit, row_pointers, and unknowns. By default, these; * are automatically freed when the info structure is deallocated, if they were; * allocated internally by libpng. This behavior can be changed by means; * of the png_data_freer() function.; *; * More allocation details: all the chunk-reading functions that; * change these members go through the corresponding png_set_*; * functions. A function to clear these members is available: see; * png_free_data(). The png_set_* functions do not depend on being; * able to point info structure members to any of the storage they are; * passed (they make their own copies), EXCEPT that the png_set_text; * functions use the same storage passed to them in the text_ptr or; * itxt_ptr structure argument, and the png_set_rows and png_set_unknowns; * functions do not make their own copies.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pnginfo.h:1589,allocate,allocated,1589,graf2d/asimage/src/libAfterImage/libpng/pnginfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pnginfo.h,2,['allocate'],['allocated']
Energy Efficiency," for tagging the name of the tree in the file are the same as; /// in the format above.; ///; /// <h4>Details of the nentries parameter</h4>; /// Depending on the value of the parameter, the number of entries in the file; /// is retrieved differently:; /// - If <tt>nentries <= 0</tt>, the file is connected and the tree header read; /// in memory to get the number of entries.; /// - If <tt>nentries > 0</tt>, the file is not connected, \p nentries is; /// assumed to be the number of entries in the file. In this case, no check is; /// made that the file exists and that the corresponding tree exists as well.; /// This second mode is interesting in case the number of entries in the file; /// is already stored in a run data base for example.; /// - If <tt>nentries == TTree::kMaxEntries</tt> (default), the file is not; /// connected. The number of entries in each file will be read only when the; /// file will need to be connected to read an entry. This option is the; /// default and very efficient if one processes the chain sequentially. Note; /// that in case TChain::GetEntry(entry) is called and entry refers to an; /// entry in the 3rd file, for example, this forces the tree headers in the; /// first and second file to be read to find the number of entries in these; /// files. Note that calling TChain::GetEntriesFast after having; /// created a chain with this default returns TTree::kMaxEntries ! Using; /// TChain::GetEntries instead will force all the tree headers in the chain to; /// be read to get the number of entries in each tree.; ///; /// <h4>The %TChain data structure</h4>; /// Each element of the chain is a TChainElement object. It has a name equal to; /// the tree name of this chain (or the name of the specific tree in the added; /// file if it was explicitly tagged) and a title equal to the file name. So, to; /// loop over the files that have been added to this chain:; /// ~~~ {.cpp}; /// TObjArray *fileElements=chain->GetListOfFiles();; /// for (TObject *op: ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:4070,efficient,efficient,4070,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['efficient'],['efficient']
Energy Efficiency," has some additional limitation that make; // it can only run after SIAnnotateControlFlow.; //; // To achieve optimal code generation for AMDGPU, we assume that uniformity; // analysis reports the PHI in join block of divergent branch as uniform if; // it has one unique uniform value plus additional undefined/poisoned incoming; // value. That is to say the later compiler pipeline will ensure such PHI always; // return uniform value and ensure it work correctly. Let's take a look at two; // typical patterns in structured CFG that need to be taken care: (In both; // patterns, block %if terminate with divergent branch.); //; // Pattern A: Block with undefined incoming value dominates defined predecessor; // %if; // | \; // | %then; // | /; // %endif: %phi = phi [%undef, %if], [%uniform, %then]; //; // Pattern B: Block with defined incoming value dominates undefined predecessor; // %if; // | \; // | %then; // | /; // %endif: %phi = phi [%uniform, %if], [%undef, %then]; //; // For pattern A, by reporting %phi as uniform, the later pipeline need to make; // sure it be handled correctly. The backend usually allocates a scalar register; // and if any thread in a wave takes %then path, the scalar register will get; // the %uniform value.; //; // For pattern B, we will replace the undef operand with the other defined value; // in this pass. So the scalar register allocated for such PHI will get correct; // liveness. Without this transformation, the scalar register may be overwritten; // in the %then block.; //; // Limitation note:; // If the join block of divergent threads is a loop header, the pass cannot; // handle it correctly right now. For below case, the undef in %phi should also; // be rewritten. Currently we depend on SIAnnotateControlFlow to split %header; // block to get a separate join block, then we can rewrite the undef correctly.; // %if; // | \; // | %then; // | /; // -> %header: %phi = phi [%uniform, %if], [%undef, %then], [%uniform2, %header]; // | |; // \---",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURewriteUndefForPHI.cpp:1691,allocate,allocates,1691,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURewriteUndefForPHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURewriteUndefForPHI.cpp,2,['allocate'],"['allocated', 'allocates']"
Energy Efficiency," height,; * unsigned long plane_mask,; * Bool keep_cache,; * unsigned int compression );; * INPUTS; * asv 		 - pointer to valid ASVisual structure; * rgb 		 - source Pixmap for red, green and blue channels; * a 		 - source Pixmap for the alpha channel; * x, y,; * width, height- rectangle on Pixmap to be encoded into ASImage.; * plane_mask - limits color planes to be copied from Pixmap.; * keep_cache - indicates if we should keep XImage, used to copy; * image data from the X server, and attached it to ; * 				 ximage member of resulting ASImage.; * compression - degree of compression of resulting ASImage.; * RETURN VALUE; * pointer to newly allocated ASImage, containing encoded data, on; * success. NULL on failure.; * DESCRIPTION; * picture2asimage will obtain XImage of the requested area of the; * X Pixmap, If alpha channel pixmap is supplied - it will be used to ; * encode ASImage's alpha channel. Alpha channel pixmap must be either; * 8 or 1 bit deep, and it must have the same dimentions as main Pixmap.; *********/; /****f* libAfterImage/pixmap2asimage(); * NAME; * pixmap2asimage(); * SYNOPSIS; * ASImage *pixmap2asimage ( struct ASVisual *asv, Pixmap p,; * int x, int y,; * unsigned int width,; * unsigned int height,; * unsigned long plane_mask,; * Bool keep_cache,; * unsigned int compression );; * INPUTS; * asv 		 - pointer to valid ASVisual structure; * p 		 - source Pixmap; * x, y,; * width, height- rectangle on Pixmap to be encoded into ASImage.; * plane_mask - limits color planes to be copied from Pixmap.; * keep_cache - indicates if we should keep XImage, used to copy; * image data from the X server, and attached it to ; * ximage member of resulting ASImage.; * compression - degree of compression of resulting ASImage.; * RETURN VALUE; * pointer to newly allocated ASImage, containing encoded data, on; * success. NULL on failure.; * DESCRIPTION; * same as picture2asimage() with alpha pixmap set to None. Supplied for; * compatibility and convinience.; *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ximage.h:5253,allocate,allocated,5253,graf2d/asimage/src/libAfterImage/ximage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ximage.h,1,['allocate'],['allocated']
Energy Efficiency," in new ASImage( see asimage_start(); * for more ).; * RETURN VALUE; * Pointer to newly allocated and initialized ASImage structure on; * Success. NULL in case of any kind of error - that should never happen.; *********/; /****f* libAfterImage/asimage/clone_asimage(); * NAME ; * clone_asimage(); * SYNOPSIS; * ASImage *clone_asimage(ASImage *src, ASFlagType filter );; * INPUTS; * src - original ASImage.; * filter - bitmask of channels to be copied from one image to another.; * RETURN VALUE; * New ASImage, as a copy of original image.; * DESCRIPTION; * Creates exact clone of the original ASImage, with same compression,; * back_color and rest of the attributes. Only ASImage data will be; * carried over. Any attached alternative forms of images (XImages, etc.); * will not be copied. Any channel with unset bit in filter will not be; * copied. Image name, ASImageManager and ref_count will not be copied -; * use store_asimage() afterwards and make sure you use different name,; * to avoid clashes with original image.; *********/; /****f* libAfterImage/asimage/destroy_asimage(); * NAME; * destroy_asimage() frees all the memory allocated for specified ASImage. ; * SYNOPSIS; * void destroy_asimage( ASImage **im );; * INPUTS; * im				- pointer to valid ASImage structure.; * NOTES; * If there was XImage attached to it - it will be deallocated as well.; * EXAMPLE; * asview.c: ASView.5; *********/; /****f* libAfterImage/asimage/asimage_replace(); * NAME; * asimage_replace() will replace ASImage's data using data from ; * another ASImage; * SYNOPSIS; * Bool asimage_replace (ASImage *im, ASImage *from);; * INPUTS; * im				- pointer to valid ASImage structure.; * from				- pointer to ASImage from which to take the data.; * NOTES; * this function updates image without reallocating structure itself, which ; * means that all pointers to it will still be valid. If that function ; * succeeds - [from] ASImage will become unusable and should be deallocated ; * using free() call.; *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:3138,allocate,allocated,3138,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,1,['allocate'],['allocated']
Energy Efficiency," integrates the PDF in each; * bin using an adaptive integrator. This usually requires 21 times more function evaluations, but significantly; * reduces biases due to better sampling of the PDF. The integrator can be accessed from the outside; * using integrator(). This can be used to change the integration rules, so less/more function evaluations are; * performed. The target precision of the integrator can be set in the constructor.; *; *; * ### How to use it; * There are two ways to use this class:; * - Manually wrap a PDF:; * ```; * RooBinSamplingPdf binSampler(""<name>"", ""title"", <binned observable of PDF>, <original PDF> [, <precision for integrator>]);; * binSampler.fitTo(data);; * ```; * When a PDF is wrapped with a RooBinSamplingPDF, just use the bin sampling PDF instead of the original one for fits; * or plotting etc.; * \note The binning will be taken from the observable. Make sure that this binning is the same as the one of the dataset that should be fit.; * Use RooRealVar::setBinning() to adapt it.; * - Instruct test statistics to carry out this wrapping automatically:; * ```; * pdf.fitTo(data, IntegrateBins(<precision>));; * ```; * This method is especially useful when used with a simultaneous PDF, since each component will automatically be wrapped,; * depending on the value of `precision`:; * - `precision < 0.`: None of the PDFs are touched, bin sampling is off.; * - `precision = 0.`: Continuous PDFs that are fit to a RooDataHist are wrapped into a RooBinSamplingPdf. The target precision; * forwarded to the integrator is 1.E-4 (the default argument of the constructor).; * - `precision > 0.`: All continuous PDFs are automatically wrapped into a RooBinSamplingPdf, regardless of what data they are; * fit to (see next paragraph). The same `'precision'` is used for all integrators.; *; * ### Simulating a binned fit using RooDataSet; * Some frameworks use unbinned data (RooDataSet) to simulate binned datasets. By adding one entry for each bin centre with the; *",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:2275,adapt,adapt,2275,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,1,['adapt'],['adapt']
Energy Efficiency," is used.; /// if ncolors = 68 and colors=0, an Avocado palette is used.; /// if ncolors = 69 and colors=0, a Beach palette is used.; /// if ncolors = 70 and colors=0, a Black Body palette is used.; /// if ncolors = 71 and colors=0, a Blue Green Yellow palette is used.; /// if ncolors = 72 and colors=0, a Brown Cyan palette is used.; /// if ncolors = 73 and colors=0, a CMYK palette is used.; /// if ncolors = 74 and colors=0, a Candy palette is used.; /// if ncolors = 75 and colors=0, a Cherry palette is used.; /// if ncolors = 76 and colors=0, a Coffee palette is used.; /// if ncolors = 77 and colors=0, a Dark Rain Bow palette is used.; /// if ncolors = 78 and colors=0, a Dark Terrain palette is used.; /// if ncolors = 79 and colors=0, a Fall palette is used.; /// if ncolors = 80 and colors=0, a Fruit Punch palette is used.; /// if ncolors = 81 and colors=0, a Fuchsia palette is used.; /// if ncolors = 82 and colors=0, a Grey Yellow palette is used.; /// if ncolors = 83 and colors=0, a Green Brown Terrain palette is used.; /// if ncolors = 84 and colors=0, a Green Pink palette is used.; /// if ncolors = 85 and colors=0, an Island palette is used.; /// if ncolors = 86 and colors=0, a Lake palette is used.; /// if ncolors = 87 and colors=0, a Light Temperature palette is used.; /// if ncolors = 88 and colors=0, a Light Terrain palette is used.; /// if ncolors = 89 and colors=0, a Mint palette is used.; /// if ncolors = 90 and colors=0, a Neon palette is used.; /// if ncolors = 91 and colors=0, a Pastel palette is used.; /// if ncolors = 92 and colors=0, a Pearl palette is used.; /// if ncolors = 93 and colors=0, a Pigeon palette is used.; /// if ncolors = 94 and colors=0, a Plum palette is used.; /// if ncolors = 95 and colors=0, a Red Blue palette is used.; /// if ncolors = 96 and colors=0, a Rose palette is used.; /// if ncolors = 97 and colors=0, a Rust palette is used.; /// if ncolors = 98 and colors=0, a Sandy Terrain palette is used.; /// if ncolors = 99 and col",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx:3548,Green,Green,3548,core/base/src/TColor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx,1,['Green'],['Green']
Energy Efficiency," it allocates. For the module scope lds,; // this is via metadata indicating whether the variable is not required. If a; // pass deletes that metadata, a fatal error on disagreement with the absolute; // symbol metadata will occur. For kernel scope and dynamic, this is by _name_; // correspondence between the function and the variable. It requires the; // kernel to have a name (which is only a limitation for tests in practice) and; // for nothing to rename the corresponding symbols. This is a hazard if the pass; // is run multiple times during debugging. Alternative schemes considered all; // involve bespoke metadata.; //; // If the name correspondence can be replaced, multiple distinct kernels that; // have the same memory layout can map to the same kernel id (as the address; // itself is handled by the absolute symbol metadata) and that will allow more; // uses of the ""kernel"" style faster lowering and reduce the size of the lookup; // tables.; //; // There is a test that checks this does not fire for a graphics shader. This; // lowering is expected to work for graphics if the isKernel test is changed.; //; // The current markUsedByKernel is sufficient for PromoteAlloca but is elided; // before codegen. Replacing this with an equivalent intrinsic which lasts until; // shortly after the machine function lowering of LDS would help break the name; // mapping. The other part needed is probably to amend PromoteAlloca to embed; // the LDS variables it creates in the same struct created here. That avoids the; // current hazard where a PromoteAlloca LDS variable might be allocated before; // the kernel scope (and thus error on the address check). Given a new invariant; // that no LDS variables exist outside of the structs managed here, and an; // intrinsic that lasts until after the LDS frame lowering, it should be; // possible to drop the name mapping and fold equivalent memory layouts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:10139,allocate,allocated,10139,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['allocate'],['allocated']
Energy Efficiency," just need to composite the PNG image onto an existing background; * and if you control the code that does this you can use the optimization; * setting. In this case you just copy completely opaque pixels to the; * output. For pixels that are not completely transparent (you just skip; * those) you do the composition math using png_composite or png_composite_16; * below then encode the resultant 8-bit or 16-bit values to match the output; * encoding.; *; * Other cases; * If neither the PNG nor the standard linear encoding work for you because; * of the software or hardware you use then you have a big problem. The PNG; * case will probably result in halos around the image. The linear encoding; * will probably result in a washed out, too bright, image (it's actually too; * contrasty.) Try the ALPHA_OPTIMIZED mode above - this will probably; * substantially reduce the halos. Alternatively try:; *; * png_set_alpha_mode(pp, PNG_ALPHA_BROKEN, PNG_DEFAULT_sRGB);; * This option will also reduce the halos, but there will be slight dark; * halos round the opaque parts of the image where the background is light.; * In the OPTIMIZED mode the halos will be light halos where the background; * is dark. Take your pick - the halos are unavoidable unless you can get; * your hardware/software fixed! (The OPTIMIZED approach is slightly; * faster.); *; * When the default gamma of PNG files doesn't match the output gamma.; * If you have PNG files with no gamma information png_set_alpha_mode allows; * you to provide a default gamma, but it also sets the output gamma to the; * matching value. If you know your PNG files have a gamma that doesn't; * match the output you can take advantage of the fact that; * png_set_alpha_mode always sets the output gamma but only sets the PNG; * default if it is not already set:; *; * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);; * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);; * The first call sets both the default and the output gamma v",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:2804,reduce,reduce,2804,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['reduce'],['reduce']
Energy Efficiency," kernel.; // Handling ConstantExpr during the pass complicated this significantly so now; // all ConstantExpr uses of LDS variables are expanded to instructions. This; // may need amending when implementing non-undef initialisers.; //; // Lowering is split between this IR pass and the back end. This pass chooses; // where given variables should be allocated and marks them with metadata,; // MD_absolute_symbol. The backend places the variables in coincidentally the; // same location and raises a fatal error if something has gone awry. This works; // in practice because the only pass between this one and the backend that; // changes LDS is PromoteAlloca and the changes it makes do not conflict.; //; // Addresses are written to constant global arrays based on the same metadata.; //; // The backend lowers LDS variables in the order of traversal of the function.; // This is at odds with the deterministic layout required. The workaround is to; // allocate the fixed-address variables immediately upon starting the function; // where they can be placed as intended. This requires a means of mapping from; // the function to the variables that it allocates. For the module scope lds,; // this is via metadata indicating whether the variable is not required. If a; // pass deletes that metadata, a fatal error on disagreement with the absolute; // symbol metadata will occur. For kernel scope and dynamic, this is by _name_; // correspondence between the function and the variable. It requires the; // kernel to have a name (which is only a limitation for tests in practice) and; // for nothing to rename the corresponding symbols. This is a hazard if the pass; // is run multiple times during debugging. Alternative schemes considered all; // involve bespoke metadata.; //; // If the name correspondence can be replaced, multiple distinct kernels that; // have the same memory layout can map to the same kernel id (as the address; // itself is handled by the absolute symbol metadata) and that w",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:8353,allocate,allocate,8353,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['allocate'],['allocate']
Energy Efficiency," lane; /// # is present right after the current lane.; /// size = number_of_active_lanes_in_this_warp();; /// logical_lane_id /= 2;; /// ShuffleReduceFn(reduce_data, logical_lane_id,; /// remote_id-1-threadIdx.x, 2);; /// } while (logical_lane_id % 2 == 0 && size > 1);; /// }; ///; /// There is no assumption made about the initial state of the reduction.; /// Any number of lanes (>=1) could be active at any position. The reduction; /// result is returned in the first active lane.; ///; /// In this version, 'ShuffleReduceFn' behaves, per element, as follows:; ///; /// remote_elem = shuffle_down(reduce_elem, offset, WARPSIZE);; /// if (lane_id % 2 == 0 && offset > 0); /// reduce_elem = reduce_elem REDUCE_OP remote_elem; /// else; /// reduce_elem = remote_elem; ///; ///; /// Intra-Team Reduction; ///; /// This function, as implemented in the runtime call; /// '__kmpc_nvptx_parallel_reduce_nowait_v2', aggregates data across OpenMP; /// threads in a team. It first reduces within a warp using the; /// aforementioned algorithms. We then proceed to gather all such; /// reduced values at the first warp.; ///; /// The runtime makes use of the function 'InterWarpCpyFn', which copies; /// data from each of the ""warp master"" (zeroth lane of each warp, where; /// warp-reduced data is held) to the zeroth warp. This step reduces (in; /// a mathematical sense) the problem of reduction across warp masters in; /// a block to the problem of warp reduction.; ///; ///; /// Inter-Team Reduction; ///; /// Once a team has reduced its data to a single value, it is stored in; /// a global scratchpad array. Since each team has a distinct slot, this; /// can be done without locking.; ///; /// The last team to write to the scratchpad array proceeds to reduce the; /// scratchpad array. One or more workers in the last team use the helper; /// 'loadAndReduceDataFn' to load and reduce values from the array, i.e.,; /// the k'th worker reduces every k'th element.; ///; /// Finally, a call is made to '_",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:8635,reduce,reduces,8635,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['reduce'],['reduces']
Energy Efficiency," new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. ### NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. - Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; - TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; - If the objects are added using the placement new then the Clear must; deallocate the memory.; - If the objects are added using TClonesArray::ConstructedAt then the; heap-based memory can stay allocated and reused as the constructor is; not called for already constructed/added object.; - To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx:4124,allocate,allocate,4124,core/cont/src/TClonesArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx,3,"['allocate', 'reduce']","['allocate', 'allocated', 'reduce']"
Energy Efficiency," of entries.; In particular, note that this means that, for multi-thread event loops, there is no; guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; concurrently, RDataFrame guarantees that different threads will employ diffe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:48667,Reduce,Reduce,48667,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['Reduce'],['Reduce']
Energy Efficiency," of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | GraphAsymmErrors() | Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | Histo1D(), Histo2D(), Histo3D() | Fill a one-, two-, three-dimensional histogram with the processed column values. |; | HistoND() | Fill an N-dimensional histogram with the processed column values. |; | Max() | Return the maximum of processed column values. If the type of the column is inferred, the return type is `double`, the type of the column otherwise.|; | Mean() | Return the mean of processed column values.|; | Min() | Return the minimum of processed column values. If the type of the column is inferred, the return type is `double`, the type of the column otherwise.|; | Profile1D(), Profile2D() | Fill a one- or two-dimensional profile with the column values that passed all filters. |; | Reduce() | Reduce (e.g. sum, merge) entries using the function (lambda, functor...) passed as argument. The function must have signature `T(T,T)` where `T` is the type of the column. Return the final result of the reduction operation. An optional parameter allows initialization of the result object to non-default values. |; | Report() | Obtain statistics on how many entries have been accepted and rejected by the filters. See the section on [named filters](#named-filters-and-cutflow-reports) for a more detailed explanation. The method returns a ROOT::RDF::RCutFlowReport instance which can be queried programmatically to get information about the effects of the individual cuts. |; | Stats() | Return a TStatistic object filled with the input columns. |; | StdDev() | Return the unbiased standard deviation of the processed column values. |; | Sum() | Return the sum of the values in the column. If the type of the column is inferred, the return type is `double`, the type of the column otherwise. |; | ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:7984,Reduce,Reduce,7984,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,2,['Reduce'],['Reduce']
Energy Efficiency," or a.Clear(""C""); }; ~~~; To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot.; ~~~ {.cpp}; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear(); // or a.Clear(""C"");; }; ~~~; Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. ### NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClones",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx:2368,allocate,allocated,2368,core/cont/src/TClonesArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx,1,['allocate'],['allocated']
Energy Efficiency," or died) is indicated with the eof(); * method, serious I/O errors set a flags (bad(), fail()), and also throw; * exceptions. For normal read/write operations, they can be suppressed (i.e.; * error reporting only using flags) with a constructor argument.; *; * Technicalities:; * - there is a pool of mmapped pages, half the pages are allocated to the; * parent process, half to the child; * - when one side has accumulated enough data (or a flush forces dirty pages; * out to the other end), it sends these pages to the other end by writing a; * byte containing the page number into the pipe; * - the other end (which has the pages mmapped, too) reads the page number(s); * and puts the corresponding pages on its busy list; * - as the other ends reads, it frees busy pages, and eventually tries to put; * them on the its list; if a page belongs to the other end of the; * connection, it is sent back; * - lists of pages are sent across the pipe, not individual pages, in order; * to minimise the number of read/write operations needed; * - when mmap works properly, only one bytes containing the page number of; * the page list head is sent back and forth; the contents of that page; * allow to access the rest of the page list sent, and page headers on the; * list tell the receiving end if the page is free or has to be added to the; * busy list; * - when mmap does not work, we transfer one byte to indicate the head of the; * page list sent, and for each page on the list of sent pages, the page; * header and the page payload is sent (if the page is free, we only; * transmit the page header, and we never transmit more payload than; * the page actually contains); * - in the child, all open BidirMMapPipes but the current one are closed. this; * is done for two reasons: first, to conserve file descriptors and address; * space. second, if more than one process is meant to use such a; * BidirMMapPipe, synchronisation issues arise which can lead to bugs that; * are hard to find and understa",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:3487,allocate,allocated,3487,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,1,['allocate'],['allocated']
Energy Efficiency," potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via a TPad; repaint at present), and thus collect these objects if the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. ## Physical IDs. TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0). ~~~ {.cpp}; virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); ~~~. If you use the first (simple) case a viewer using logical/physical pairs; will generate IDs for each physical object internally. In the second you; can specify a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical objects no longer of interest as part of scene rebuilds. ## Child Objects. In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. ## Recycling TBuffer3D. Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualViewer3D.cxx:10579,efficient,efficient,10579,core/base/src/TVirtualViewer3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualViewer3D.cxx,1,['efficient'],['efficient']
Energy Efficiency," produce these instructions when speculation hardening; // is enabled. This pass will assert if it does encounter such an instruction.; // - On function call boundaries, the miss-speculation state is transferred from; // the taint register X16 to be encoded in the SP register as value 0.; //; // For the aspect of automatically hardening loads, using the taint register,; // (a.k.a. speculative load hardening, see; // https://llvm.org/docs/SpeculativeLoadHardening.html), the following; // implementation choices are made for AArch64:; // - Many of the optimizations described at; // https://llvm.org/docs/SpeculativeLoadHardening.html to harden fewer; // loads haven't been implemented yet - but for some of them there are; // FIXMEs in the code.; // - loads that load into general purpose (X or W) registers get hardened by; // masking the loaded data. For loads that load into other registers, the; // address loaded from gets hardened. It is expected that hardening the; // loaded data may be more efficient; but masking data in registers other; // than X or W is not easy and may result in being slower than just; // hardening the X address register loaded from.; // - On AArch64, CSDB instructions are inserted between the masking of the; // register and its first use, to ensure there's no non-control-flow; // speculation that might undermine the hardening mechanism.; //; // Future extensions/improvements could be:; // - Implement this functionality using full speculation barriers, akin to the; // x86-slh-lfence option. This may be more useful for the intrinsics-based; // approach than for the SLH approach to masking.; // Note that this pass already inserts the full speculation barriers if the; // function for some niche reason makes use of X16/W16.; // - no indirect branch misprediction gets protected/instrumented; but this; // could be done for some indirect branches, such as switch jump tables.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:4703,efficient,efficient,4703,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,1,['efficient'],['efficient']
Energy Efficiency," readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of \f$ S\f$ are chosen first; (TMultiDimFit::TestFunction). In case \f$ \phi \f$ isn't defined, an alternative method of; performing this second test is used: The \f$L^{\mbox{th}}\f$; function \f$\textbf{f}_L\f$ is accepted if (refer also to equation (13)); \f[; \Delta S_L > \frac{S_{L-1}}{L_{max}-L}; \f]; where \f$ S_{L-1}\f$ is the sum of the \f$ L-1\f$ first residuals from the; \f$ L-1\f$ functions previously accepted; and \f$ L_{max}\f$ is the total number; of functions allowed in the final expression of the fit (defined by; user). From this we see, that by restricting \f$ L_{max}\f$ -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting. The more coefficients we evaluate, the more the sum of squares of; residuals \f$ S\f$ will be reduced. We can evaluate \f$ S\f$ before inverting; \f$\mathsf{B}\f$ as shown below. ## Coefficients and Coefficient Errors; Having found a parameterization, that is the \f$ F_l\f$'s and \f$ L\f$, that; minimizes \f$ S\f$, we still need to determine the coefficients; \f$ c_l\f$. However, it's a feature of how we choose the significant; functions, that the evaluation of the \f$ c_l\f$'s becomes trivial [5]. To derive; \f$\mathbf{c}\f$, we first note that; equation (4) can be written as; \f[; \mathsf{F} = \mathsf{W}\mathsf{B}; \f]; where; \f{eqnarray*}{; b_{ij} = \frac{\mathbf{f}_j \bullet \mathbf{w}_i}{\mathbf{w}_i^2}; & \mbox{if} & i < j\\; 1 & \mbox{if} & i = j\\; 0 & \mbox{if} & i > j; \f}; Consequently, \f$\mathsf{B}\f$ is an upper triangle matrix, which can be; readily inverted. So we now evaluate; \f[; \mathsf{F}\mathsf{B}^{-1} = \mathsf{W}; \f]; The model \f$\mathsf{W}\mathbf{a}\f$ can therefore be written as; \f$(\mathsf{F}\mathsf{B}^{-",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:11959,reduce,reduced,11959,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['reduce'],['reduced']
Energy Efficiency," requested. Must not exceed maxpts.; if minpts < 1 minpts is set to \f$ 2^n +2n(n+1) +1 \f$ where n is the function dimension; - \f$ maxpts \f$: Maximum number of function evaluations to be allowed.; \f$ maxpts >= 2^n +2n(n+1) +1 \f$; if \f$ maxpts<minpts \f$, \f$ maxpts \f$ is set to \f$ 10minpts \f$; - \f$ epstol \f$, \f$ epsrel \f$ : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function in the desired interval:. - an estimation of the relative accuracy of the result.; - number of function evaluations performed.; - status code:; 0. Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1. maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 2. size is too small for the specified number MAXPTS of function evaluations.; 3. n<2 or n>15. ### Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. ### Notes:. 1..Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2..Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. ### References:. 1. A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2. A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h:2266,adapt,adaptive,2266,math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,2,['adapt'],['adaptive']
Energy Efficiency," save LDS. ""Kernel"" is as fast as kernel allocation but only works; // for variables that are known reachable from a single kernel. ""Hybrid"" picks; // between all three. When forced to choose between LDS and cycles we minimise; // LDS use.; // The ""module"" lowering implemented here finds LDS variables which are used by; // non-kernel functions and creates a new struct with a field for each of those; // LDS variables. Variables that are only used from kernels are excluded.; //; // The ""table"" lowering implemented here has three components.; // First kernels are assigned a unique integer identifier which is available in; // functions it calls through the intrinsic amdgcn_lds_kernel_id. The integer; // is passed through a specific SGPR, thus works with indirect calls.; // Second, each kernel allocates LDS variables independent of other kernels and; // writes the addresses it chose for each variable into an array in consistent; // order. If the kernel does not allocate a given variable, it writes undef to; // the corresponding array location. These arrays are written to a constant; // table in the order matching the kernel unique integer identifier.; // Third, uses from non-kernel functions are replaced with a table lookup using; // the intrinsic function to find the address of the variable.; //; // ""Kernel"" lowering is only applicable for variables that are unambiguously; // reachable from exactly one kernel. For those cases, accesses to the variable; // can be lowered to ConstantExpr address of a struct instance specific to that; // one kernel. This is zero cost in space and in compute. It will raise a fatal; // error on any variable that might be reachable from multiple kernels and is; // thus most easily used as part of the hybrid lowering strategy.; //; // Hybrid lowering is a mixture of the above. It uses the zero cost kernel; // lowering where it can. It lowers the variable accessed by the greatest; // number of kernels using the module strategy as that is free fo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:4588,allocate,allocate,4588,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['allocate'],['allocate']
Energy Efficiency," should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a fun",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:1072,Allocate,Allocated,1072,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,2,['Allocate'],['Allocated']
Energy Efficiency," solid #dbdbdb;; border-radius: 3px;; }; table {; border-collapse: collapse;; }; .light-row {; background: #ffffff;; border: 1px solid #dbdbdb;; border-left: none;; border-right: none;; }; .light-row-bold {; background: #ffffff;; border: 1px solid #dbdbdb;; border-left: none;; border-right: none;; font-weight: bold;; }; .column-entry {; text-align: left;; }; .column-entry-bold {; font-weight: bold;; text-align: left;; }; .column-entry-yellow {; text-align: left;; background-color: #ffffd0;; }; .column-entry-yellow:hover, tr:hover .column-entry-yellow {; background-color: #fffff0;; }; .column-entry-red {; text-align: left;; background-color: #ffd0d0;; }; .column-entry-red:hover, tr:hover .column-entry-red {; background-color: #fff0f0;; }; .column-entry-gray {; text-align: left;; background-color: #fbfbfb;; }; .column-entry-gray:hover, tr:hover .column-entry-gray {; background-color: #f0f0f0;; }; .column-entry-green {; text-align: left;; background-color: #d0ffd0;; }; .column-entry-green:hover, tr:hover .column-entry-green {; background-color: #f0fff0;; }; .line-number {; text-align: right;; color: #aaa;; }; .covered-line {; text-align: right;; color: #0080ff;; }; .uncovered-line {; text-align: right;; color: #ff3300;; }; .tooltip {; position: relative;; display: inline;; background-color: #b3e6ff;; text-decoration: none;; }; .tooltip span.tooltip-content {; position: absolute;; width: 100px;; margin-left: -50px;; color: #FFFFFF;; background: #000000;; height: 30px;; line-height: 30px;; text-align: center;; visibility: hidden;; border-radius: 6px;; }; .tooltip span.tooltip-content:after {; content: '';; position: absolute;; top: 100%;; left: 50%;; margin-left: -8px;; width: 0; height: 0;; border-top: 8px solid #000000;; border-right: 8px solid transparent;; border-left: 8px solid transparent;; }; :hover.tooltip span.tooltip-content {; visibility: visible;; opacity: 0.8;; bottom: 30px;; left: 50%;; z-index: 999;; }; th, td {; vertical-align: top;; padding: 2px 8px;; bo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:1590,green,green,1590,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,1,['green'],['green']
Energy Efficiency," speed when inflate_fast() not used; *; * 1.2.beta4 1 Jan 2003; * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings; * - Move a comment on output buffer sizes from inffast.c to inflate.c; * - Add comments in inffast.c to introduce the inflate_fast() routine; * - Rearrange window copies in inflate_fast() for speed and simplification; * - Unroll last copy for window match in inflate_fast(); * - Use local copies of window variables in inflate_fast() for speed; * - Pull out common wnext == 0 case for speed in inflate_fast(); * - Make op and len in inflate_fast() unsigned for consistency; * - Add FAR to lcode and dcode declarations in inflate_fast(); * - Simplified bad distance check in inflate_fast(); * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new; * source file infback.c to provide a call-back interface to inflate for; * programs like gzip and unzip -- uses window as output buffer to avoid; * window copying; *; * 1.2.beta5 1 Jan 2003; * - Improved inflateBack() interface to allow the caller to provide initial; * input in strm.; * - Fixed stored blocks bug in inflateBack(); *; * 1.2.beta6 4 Jan 2003; * - Added comments in inffast.c on effectiveness of POSTINC; * - Typecasting all around to reduce compiler warnings; * - Changed loops from while (1) or do {} while (1) to for (;;), again to; * make compilers happy; * - Changed type of window in inflateBackInit() to unsigned char *; *; * 1.2.beta7 27 Jan 2003; * - Changed many types to unsigned or unsigned short to avoid warnings; * - Added inflateCopy() function; *; * 1.2.0 9 Mar 2003; * - Changed inflateBack() interface to provide separate opaque descriptors; * for the in() and out() functions; * - Changed inflateBack() argument and in_func typedef to swap the length; * and buffer address return values for the input function; * - Check next_in and next_out for Z_NULL on entry to inflate(); *; * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c:3144,reduce,reduce,3144,builtins/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c,1,['reduce'],['reduce']
Energy Efficiency," speed when inflate_fast() not used; *; * 1.2.beta4 1 Jan 2003; * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings; * - Move a comment on output buffer sizes from inffast.c to inflate.c; * - Add comments in inffast.c to introduce the inflate_fast() routine; * - Rearrange window copies in inflate_fast() for speed and simplification; * - Unroll last copy for window match in inflate_fast(); * - Use local copies of window variables in inflate_fast() for speed; * - Pull out common write == 0 case for speed in inflate_fast(); * - Make op and len in inflate_fast() unsigned for consistency; * - Add FAR to lcode and dcode declarations in inflate_fast(); * - Simplified bad distance check in inflate_fast(); * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new; * source file infback.c to provide a call-back interface to inflate for; * programs like gzip and unzip -- uses window as output buffer to avoid; * window copying; *; * 1.2.beta5 1 Jan 2003; * - Improved inflateBack() interface to allow the caller to provide initial; * input in strm.; * - Fixed stored blocks bug in inflateBack(); *; * 1.2.beta6 4 Jan 2003; * - Added comments in inffast.c on effectiveness of POSTINC; * - Typecasting all around to reduce compiler warnings; * - Changed loops from while (1) or do {} while (1) to for (;;), again to; * make compilers happy; * - Changed type of window in inflateBackInit() to unsigned char *; *; * 1.2.beta7 27 Jan 2003; * - Changed many types to unsigned or unsigned short to avoid warnings; * - Added inflateCopy() function; *; * 1.2.0 9 Mar 2003; * - Changed inflateBack() interface to provide separate opaque descriptors; * for the in() and out() functions; * - Changed inflateBack() argument and in_func typedef to swap the length; * and buffer address return values for the input function; * - Check next_in and next_out for Z_NULL on entry to inflate(); *; * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inflate.c:3144,reduce,reduce,3144,graf2d/asimage/src/libAfterImage/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inflate.c,1,['reduce'],['reduce']
Energy Efficiency," the 4th parameter, the two operands; /// element-wise. The result is written to the first operand.; ///; /// Different reduction algorithms are implemented in different; /// runtime functions, all calling 'shuffleReduceFn' to perform; /// the essential reduction step. Therefore, based on the 4th; /// parameter, this function behaves slightly differently to; /// cooperate with the runtime to ensure correctness under; /// different circumstances.; ///; /// 'InterWarpCpyFn' is a pointer to a function that transfers; /// reduced variables across warps. It tunnels, through CUDA; /// shared memory, the thread-private data of type 'ReduceData'; /// from lane 0 of each warp to a lane in the first warp.; /// 4. Call the OpenMP runtime on the GPU to reduce across teams.; /// The last team writes the global reduced value to memory.; ///; /// ret = __kmpc_nvptx_teams_reduce_nowait(...,; /// reduceData, shuffleReduceFn, interWarpCpyFn,; /// scratchpadCopyFn, loadAndReduceFn); ///; /// 'scratchpadCopyFn' is a helper that stores reduced; /// data from the team master to a scratchpad array in; /// global memory.; ///; /// 'loadAndReduceFn' is a helper that loads data from; /// the scratchpad array and reduces it with the input; /// operand.; ///; /// These compiler generated functions hide address; /// calculation and alignment information from the runtime.; /// 5. if ret == 1:; /// The team master of the last team stores the reduced; /// result to the globals in memory.; /// foo += reduceData.foo; bar *= reduceData.bar; ///; ///; /// Warp Reduction Algorithms; ///; /// On the warp level, we have three algorithms implemented in the; /// OpenMP runtime depending on the number of active lanes:; ///; /// Full Warp Reduction; ///; /// The reduce algorithm within a warp where all lanes are active; /// is implemented in the runtime as follows:; ///; /// full_warp_reduce(void *reduce_data,; /// kmp_ShuffleReductFctPtr ShuffleReduceFn) {; /// for (int offset = WARPSIZE/2; offset > 0; offs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:3917,reduce,reduceData,3917,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,2,['reduce'],"['reduceData', 'reduced']"
Energy Efficiency," the TTree, TChain,; TNtuple and TNtupleD classes.; The TTree class represents a columnar dataset. Any C++ type can be stored in the; columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; it is demonstrated to scale and it's battle tested. It has been optimized during the years; to reduce dataset sizes on disk and to deliver excellent runtime performance.; It allows to access only part of the columns of the datasets, too.; The TNtuple and TNtupleD classes are specialisations of the TTree class which can; only hold single precision and double precision floating-point numbers respectively;; The TChain is a collection of TTrees, which can be located also in different files. */; /** \class TTree; \ingroup tree. A TTree represents a columnar dataset. Any C++ type can be stored in its columns. A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; represented by the TBranch class.; Behind each branch, buffers are allocated automatically by ROOT.; Such buffers are automatically written to disk or kept in memory until the size stored in the; attribute fMaxVirtualSize is reached.; Variables of one branch are written to the same buffer. A branch buffer is; automatically compressed if the file compression attribute is set (default).; Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one object into; one single I/O buffer or to make several branches.; Making several branches is particularly interesting in the data analysis phase,; when it is desirable to have a high reading rate and not all columns are equally interesting. \anchor creatingattreetoc; ## Create a TTree to store columnar data; - [Construct a TTree](\ref creatingattree); - [Add a column of Fundamental Types and Arrays thereof](\ref addcolumnoffundamentaltypes); - [Add a column of a STL Collection instances](\ref addingacolumnofstl); - [Add a column holding",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1497,allocate,allocated,1497,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['allocate'],['allocated']
Energy Efficiency," the address table to not require full 64 bit addresses for each address.; /// The resulting GSYM size is smaller and causes fewer pages to be touched; /// during address lookups when the address table is smaller. The size of the; /// address offsets in the address table is specified in the header in; /// Header.AddrOffSize. The first offset in the address table is aligned to; /// Header.AddrOffSize alignment to ensure efficient access when loaded into; /// memory.; ///; /// FUNCTION INFO OFFSETS TABLE; ///; /// The function info offsets table immediately follows the address table and; /// consists of Header.NumAddresses 32 bit file offsets: one for each address; /// in the address table. This data is aligned to a 4 byte boundary. The; /// offsets in this table are the relative offsets from the start offset of the; /// GSYM header and point to the function info data for each address in the; /// address table. Keeping this data separate from the address table helps to; /// reduce the number of pages that are touched when address lookups occur on a; /// GSYM file.; ///; /// FILE TABLE; ///; /// The file table immediately follows the function info offsets table. The; /// encoding of the FileTable is:; ///; /// struct FileTable {; /// uint32_t Count;; /// FileEntry Files[];; /// };; ///; /// The file table starts with a 32 bit count of the number of files that are; /// used in all of the function info, followed by that number of FileEntry; /// structures. The file table is aligned to a 4 byte boundary, Each file in; /// the file table is represented with a FileEntry structure.; /// See ""llvm/DebugInfo/GSYM/FileEntry.h"" for details.; ///; /// STRING TABLE; ///; /// The string table follows the file table in stand alone GSYM files and; /// contains all strings for everything contained in the GSYM file. Any string; /// data should be added to the string table and any references to strings; /// inside GSYM information must be stored as 32 bit string table offsets into; /// ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h:3140,reduce,reduce,3140,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,1,['reduce'],['reduce']
Energy Efficiency," the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging). ### Memory usage. There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage. Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after the other. Possible mitigations include creating and running each RDataFrame event loop in a sub-process, or booking all operations for all different RDataFrame computation graphs before the first event loop is triggered, so that the interpreter is invoked only once for all computation graphs:. ~~~{.cpp}; // assuming df1 and df2 are separate computation graphs, do:; auto h1 = df1.Histo1D(""x"");; auto h2 = df2.Histo1D(""y"");; h1->Draw(); // we just-in-time compile everything needed by df1 and df2 here; h2->Draw(""SAME"");. // do not:; auto h1 = df1.Histo1D(""x"");; h1->Draw(); // we just-in-time compile here; auto h2 = df2.Histo1D(""y"");; h2->Draw(""SAME""); // we just-in-time compile again here, as the second Histo1D call is new; ~~~. \anchor more-features; ## M",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:53686,allocate,allocate,53686,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['allocate'],['allocate']
Energy Efficiency," the inner border of the Bevel outline; * as related to the origin of subimage being decoded.; * width,; * height - widtha and height of the inner border of the bevel outline.; * DESCRIPTION; * For example if you only need to render small part of the button, that ; * is being rendered from transparency image.; * NOTE; * This call modifies bevel_h_addon and bevel_v_addon of; * ASImageDecoder structure.; *******/; /****f* libAfterImage/asimage/set_decoder_shift(); * NAME; * set_decoder_shift() - changes the shift value of decoder - 8 or 0.; * SYNOPSIS; * void set_decoder_shift( ASImageDecoder *imdec, int shift );; * INPUTS; * imdec - pointer to pointer to structure, previously created; * by start_image_decoding.; * shift - new value to be used as the shift while decoding image.; * valid values are 8 and 0.; * DESCRIPTION; * This function should be used instead of directly modifyeing value of; * shift memebr of ASImageDecoder structure.; *******/; /****f* libAfterImage/asimage/set_decoder_back_color(); * NAME; * set_decoder_back_color() - changes the back color to be used while; * decoding the image.; * SYNOPSIS; * void set_decoder_back_color( ASImageDecoder *imdec, ARGB32 back_color );; * INPUTS; * imdec - pointer to pointer to structure, previously created; * by start_image_decoding.; * back_color - ARGB32 color value to be used as the background color to; * fill empty spaces in decoded ASImage.; * DESCRIPTION; * This function should be used instead of directly modifyeing value of; * back_color memebr of ASImageDecoder structure.; *******/; /****f* libAfterImage/asimage/stop_image_decoding(); * NAME; * stop_image_decoding() - finishes decoding, frees all allocated; * memory.; * SYNOPSIS; * void stop_image_decoding( ASImageDecoder **pimdec );; * INPUTS; * pimdec - pointer to pointer to structure, previously created; * 			by start_image_decoding.; * RETURN VALUE; * pimdec	- pointer to ASImageDecoder will be reset to NULL.; * SEE ALSO; * start_image_decoding(); *******/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/imencdec.h:4175,allocate,allocated,4175,graf2d/asimage/src/libAfterImage/imencdec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/imencdec.h,1,['allocate'],['allocated']
Energy Efficiency," the interval used by a resource in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resources is the value (Releas",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1043,schedul,scheduled,1043,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,4,"['SCHEDUL', 'schedul']","['SCHEDULING', 'scheduled', 'scheduling']"
Energy Efficiency," the objects (where possible).; *; * To attempt to manage this buffer, given these constraints, the ZSTD_cwksp; * abstraction was created. It works as follows:; *; * Workspace Layout:; *; * [ ... workspace ... ]; * [objects][tables ... ->] free space [<- ... aligned][<- ... buffers]; *; * The various objects that live in the workspace are divided into the; * following categories, and are allocated separately:; *; * - Static objects: this is optionally the enclosing ZSTD_CCtx or ZSTD_CDict,; * so that literally everything fits in a single buffer. Note: if present,; * this must be the first object in the workspace, since ZSTD_customFree{CCtx,; * CDict}() rely on a pointer comparison to see whether one or two frees are; * required.; *; * - Fixed size objects: these are fixed-size, fixed-count objects that are; * nonetheless ""dynamically"" allocated in the workspace so that we can; * control how they're initialized separately from the broader ZSTD_CCtx.; * Examples:; * - Entropy Workspace; * - 2 x ZSTD_compressedBlockState_t; * - CDict dictionary contents; *; * - Tables: these are any of several different datastructures (hash tables,; * chain tables, binary trees) that all respect a common format: they are; * uint32_t arrays, all of whose values are between 0 and (nextSrc - base).; * Their sizes depend on the cparams.; *; * - Aligned: these buffers are used for various purposes that require 4 byte; * alignment, but don't require any initialization before they're used.; *; * - Buffers: these buffers are used for various purposes that don't require; * any alignment or initialization before they're used. This means they can; * be moved around at no cost for a new compression.; *; * Allocating Memory:; *; * The various types of objects must be allocated in order, so they can be; * correctly packed into the workspace buffer. That order is:; *; * 1. Objects; * 2. Buffers; * 3. Aligned; * 4. Tables; *; * Attempts to reserve objects of different types out of order will fail.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h:3396,allocate,allocated,3396,builtins/zstd/compress/zstd_cwksp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h,1,['allocate'],['allocated']
Energy Efficiency," the purposes of layout. All bases; // with vfptrs are laid out first, followed by all bases without vfptrs.; // * The Itanium equivalent vtable pointers are split into a vfptr (virtual; // function pointer) and a vbptr (virtual base pointer). They can each be; // shared with a, non-virtual bases. These bases need not be the same. vfptrs; // always occur at offset 0. vbptrs can occur at an arbitrary offset and are; // placed after the lexicographically last non-virtual base. This placement; // is always before fields but can be in the middle of the non-virtual bases; // due to the two-pass layout scheme for non-virtual-bases.; // * Virtual bases sometimes require a 'vtordisp' field that is laid out before; // the virtual base and is used in conjunction with virtual overrides during; // construction and destruction. This is always a 4 byte value and is used as; // an alternative to constructor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:1477,allocate,allocated,1477,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['allocate'],['allocated']
Energy Efficiency," the size of the pad; - Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display).; */; /** \class TImagePalette; \ingroup BasicGraphics. A class to define a conversion from pixel values to pixel color. A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predefined palettes:. - gHistImagePalette - palette used in TH2::Draw(""col""); - gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality conversion of images into; 2-D histograms.; - TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then a Rainbow Palette is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::CreateGradientColorTable for more details). if ncolors > 0 and colors = 0, the default palette is used with a maximum of ncolors. The default palette defines:; - index 0->9 : grey colors from light to dark grey; - index 10->19 : ""brown"" colors; - index 20->29 : ""blueish"" colors; - index 30->39 : ""redish"" colors; - index 40->49 : basic colors; */; /** \class TPaletteEditor; \ingroup BasicGraphics. Edit the palette via a GUI. This class provides a way to edit the palette via a GUI.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TAttImage.cxx:2017,monitor,monitors,2017,graf2d/graf/src/TAttImage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TAttImage.cxx,2,['monitor'],['monitors']
Energy Efficiency," trivially; * reused for each compression.; *; * - Various buffers don't need to be initialized at all--they are always; * written into before they're read.; *; * - The matchstate tables have a unique requirement that they don't need; * their memory to be totally cleared, but they do need the memory to have; * some bound, i.e., a guarantee that all values in the memory they've been; * allocated is less than some maximum value (which is the starting value; * for the indices that they will then use for compression). When this; * guarantee is provided to them, they can use the memory without any setup; * work. When it can't, they have to clear the area.; *; * - These buffers also have different alignment requirements.; *; * - We would like to reuse the objects in the workspace for multiple; * compressions without having to perform any expensive reallocation or; * reinitialization work.; *; * - We would like to be able to efficiently reuse the workspace across; * multiple compressions **even when the compression parameters change** and; * we need to resize some of the objects (where possible).; *; * To attempt to manage this buffer, given these constraints, the ZSTD_cwksp; * abstraction was created. It works as follows:; *; * Workspace Layout:; *; * [ ... workspace ... ]; * [objects][tables ... ->] free space [<- ... aligned][<- ... buffers]; *; * The various objects that live in the workspace are divided into the; * following categories, and are allocated separately:; *; * - Static objects: this is optionally the enclosing ZSTD_CCtx or ZSTD_CDict,; * so that literally everything fits in a single buffer. Note: if present,; * this must be the first object in the workspace, since ZSTD_customFree{CCtx,; * CDict}() rely on a pointer comparison to see whether one or two frees are; * required.; *; * - Fixed size objects: these are fixed-size, fixed-count objects that are; * nonetheless ""dynamically"" allocated in the workspace so that we can; * control how they're initialized s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h:1487,efficient,efficiently,1487,builtins/zstd/compress/zstd_cwksp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h,1,['efficient'],['efficiently']
Energy Efficiency," undef vector value to pseudo ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a function pass that initializes undef vector value to; // temporary pseudo instruction and remove it in expandpseudo pass to prevent; // register allocation resulting in a constraint violated result for vector; // instruction. It also rewrites the NoReg tied operand back to an; // IMPLICIT_DEF.; //; // RISC-V vector instruction has register overlapping constraint for certain; // instructions, and will cause illegal instruction trap if violated, we use; // early clobber to model this constraint, but it can't prevent register; // allocator allocated same or overlapped if the input register is undef value,; // so convert IMPLICIT_DEF to temporary pseudo instruction and remove it later; // could prevent that happen, it's not best way to resolve this, and it might; // change the order of program or increase the register pressure, so ideally we; // should model the constraint right, but before we model the constraint right,; // it's the only way to prevent that happen.; //; // When we enable the subregister liveness option, it will also trigger same; // issue due to the partial of register is undef. If we pseudoinit the whole; // register, then it will generate redundant COPY instruction. Currently, it; // will generate INSERT_SUBREG to make sure the whole register is occupied; // when program encounter operation that has early-clobber constraint.; //; //; // See also: https://github.com/llvm/llvm-project/issues/50157; //; // Additionally, this pass rewrites tied operands of vector instructions; // from NoReg to IMPLICIT_DEF. (Not that this is a non-overlapping set of; // operands to the above.) We use NoReg to sid",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:949,allocate,allocated,949,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,1,['allocate'],['allocated']
Energy Efficiency," valid ASVisual structure; * xim 		 - source XImage; * compression - degree of compression of resulting ASImage.; * RETURN VALUE; * pointer to newly allocated ASImage, containing encoded data, on; * success. NULL on failure.; * DESCRIPTION; *********/; /****f* libAfterImage/pixmap2asimage(); * NAME; * pixmap2asimage(); * SYNOPSIS; * ASImage *pixmap2ximage( ASVisual *asv, Pixmap p, int x, int y,; * unsigned int width, unsigned int height,; *						 unsigned long plane_mask,; * unsigned int compression);; * INPUTS; * asv 		 - pointer to valid ASVisual structure; * p 		 - source Pixmap; * x, y,; * width, height- rectangle on Pixmap to be encoded into ASImage.; * plane_mask - limits color planes to be copied from Pixmap.; * keep_cache - indicates if we should keep XImage, used to copy; * image data from the X server, and attached it to ; * 				 ximage member of resulting ASImage.; * compression - degree of compression of resulting ASImage.; * RETURN VALUE; * pointer to newly allocated ASImage, containing data in XImage format, ; * on success. NULL on failure.; * DESCRIPTION; * pixmap2ximage will obtain XImage of the requested area of the; * X Pixmap, and it will attach it to newly created ASImage using ; * alt.ximage member. After that newly created ASImage could be used ; * in any transformations.; *********/; /****f* libAfterImage/picture2asimage(); * NAME; * picture2asimage(); * SYNOPSIS; * ASImage *picture2asimage (struct ASVisual *asv,; * Pixmap rgb, Pixmap a,; * int x, int y,; * unsigned int width,; * unsigned int height,; * unsigned long plane_mask,; * Bool keep_cache,; * unsigned int compression );; * INPUTS; * asv 		 - pointer to valid ASVisual structure; * rgb 		 - source Pixmap for red, green and blue channels; * a 		 - source Pixmap for the alpha channel; * x, y,; * width, height- rectangle on Pixmap to be encoded into ASImage.; * plane_mask - limits color planes to be copied from Pixmap.; * keep_cache - indicates if we should keep XImage, used to copy; * imag",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ximage.h:2907,allocate,allocated,2907,graf2d/asimage/src/libAfterImage/ximage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ximage.h,1,['allocate'],['allocated']
Energy Efficiency," which reduction; /// algorithm to use.; ///; /// 'shuffleReduceFn' retrieves data from the remote lane using; /// efficient GPU shuffle intrinsics and reduces, using the; /// algorithm specified by the 4th parameter, the two operands; /// element-wise. The result is written to the first operand.; ///; /// Different reduction algorithms are implemented in different; /// runtime functions, all calling 'shuffleReduceFn' to perform; /// the essential reduction step. Therefore, based on the 4th; /// parameter, this function behaves slightly differently to; /// cooperate with the runtime to ensure correctness under; /// different circumstances.; ///; /// 'InterWarpCpyFn' is a pointer to a function that transfers; /// reduced variables across warps. It tunnels, through CUDA; /// shared memory, the thread-private data of type 'ReduceData'; /// from lane 0 of each warp to a lane in the first warp.; /// 4. Call the OpenMP runtime on the GPU to reduce across teams.; /// The last team writes the global reduced value to memory.; ///; /// ret = __kmpc_nvptx_teams_reduce_nowait(...,; /// reduceData, shuffleReduceFn, interWarpCpyFn,; /// scratchpadCopyFn, loadAndReduceFn); ///; /// 'scratchpadCopyFn' is a helper that stores reduced; /// data from the team master to a scratchpad array in; /// global memory.; ///; /// 'loadAndReduceFn' is a helper that loads data from; /// the scratchpad array and reduces it with the input; /// operand.; ///; /// These compiler generated functions hide address; /// calculation and alignment information from the runtime.; /// 5. if ret == 1:; /// The team master of the last team stores the reduced; /// result to the globals in memory.; /// foo += reduceData.foo; bar *= reduceData.bar; ///; ///; /// Warp Reduction Algorithms; ///; /// On the warp level, we have three algorithms implemented in the; /// OpenMP runtime depending on the number of active lanes:; ///; /// Full Warp Reduction; ///; /// The reduce algorithm within a warp where all lanes are a",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:3833,reduce,reduced,3833,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['reduce'],['reduced']
Energy Efficiency," write; * out single scanline. Each written scanlines moves internal pointer to; * the next image line, and possibly writes several scanlines at once if; * tiling_step member is not 0.; **********/; /****f* libAfterImage/asimage/set_image_output_back_color(); * NAME; * set_image_output_back_color() - changes background color of output; * SYNOPSIS; * void set_image_output_back_color ( ASImageOutput *imout,; * ARGB32 back_color );; * INPUTS; * imout		- ASImageOutput structure, previously created with; * 			 start_image_output();; * back_color	- new background color value in ARGB format. This color; * 			 will be used to fill empty parts of outgoing scanlines.; *********/; /****f* libAfterImage/asimage/toggle_image_output_direction(); * NAME; * toggle_image_output_direction() - reverses vertical direction of output; * SYNOPSIS; * void toggle_image_output_direction( ASImageOutput *imout );; * INPUTS; * imout		- ASImageOutput structure, previously created with; * 			 start_image_output();; * DESCRIPTION; * reverses vertical direction output. If previously scanlines has; * been written from top to bottom, for example, after this function is; * called they will be written in opposite direction. Current line does; * not change, unless it points to the very first or the very last; * image line. In this last case it will be moved to the opposing end of; * the image.; *********/; /****f* libAfterImage/asimage/stop_image_output(); * NAME; * stop_image_output() - finishes output, frees all the allocated memory.; * SYNOPSIS; * void stop_image_output( ASImageOutput **pimout );; * INPUTS; * pimout		- pointer to pointer to ASImageOutput structure,; * 			 previously created with call to	start_image_output().; * RETURN VALUE; * pimout		- pointer to ASImageOutput will be reset to NULL.; * DESCRIPTION; * Completes image output process. Flushes all the internal buffers.; * Deallocates all the allocated memory. Resets pointer to NULL to; * avoid dereferencing invalid pointers.; *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/imencdec.h:2679,allocate,allocated,2679,graf2d/asimage/src/libAfterImage/imencdec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/imencdec.h,2,['allocate'],['allocated']
Energy Efficiency," ~~~. for convenience there are two more set functions SetPtEtaPhiE(pt,eta,phi,e);; and SetPtEtaPhiM(pt,eta,phi,m);. ### Arithmetic and comparison operators; The TLorentzVector class provides operators to add, subtract or; compare four-vectors:. ~~~ {.cpp}; v3 = -v1;; v1 = v2+v3;; v1+= v3;; v1 = v2 + v3;; v1-= v3;. if (v1 == v2) {...}; if(v1 != v3) {...}; ~~~. ### Magnitude/Invariant mass, beta, gamma, scalar product; The scalar product of two four-vectors is calculated with the (-,-,-,+); metric,. i.e. `s = v1*v2 = t1*t2-x1*x2-y1*y2-z1*z2`; The magnitude squared mag2 of a four-vector is therefore:. ~~~ {.cpp}; mag2 = v*v = t*t-x*x-y*y-z*z; ~~~; It mag2 is negative mag = -Sqrt(-mag*mag). The member; functions are:. ~~~ {.cpp}; Double_t s, s2;; s = v1.Dot(v2); // scalar product; s = v1*v2; // scalar product; s2 = v.Mag2(); or s2 = v.M2();; s = v.Mag(); s = v.M();; ~~~. Since in case of momentum and energy the magnitude has the meaning of; invariant mass TLorentzVector provides the more meaningful aliases; M2() and M();; The member functions Beta() and Gamma() returns; beta and gamma = 1/Sqrt(1-beta*beta).; ### Lorentz boost; A boost in a general direction can be parameterised with three parameters; which can be taken as the components of a three vector b = (bx,by,bz).; With x = (x,y,z) and gamma = 1/Sqrt(1-beta*beta) (beta being the module of vector b),; an arbitrary active Lorentz boost transformation (from the rod frame; to the original frame) can be written as:. ~~~ {.cpp}; x = x' + (gamma-1)/(beta*beta) * (b*x') * b + gamma * t' * b; t = gamma (t'+ b*x').; ~~~. The member function Boost() performs a boost transformation; from the rod frame to the original frame. BoostVector() returns; a TVector3 of the spatial components divided by the time component:. ~~~ {.cpp}; TVector3 b;; v.Boost(bx,by,bz);; v.Boost(b);; b = v.BoostVector(); // b=(x/t,y/t,z/t); ~~~. ### Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. #### ro",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TLorentzVector.cxx:4817,energy,energy,4817,math/physics/src/TLorentzVector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TLorentzVector.cxx,1,['energy'],['energy']
Energy Efficiency,"""""""; A class that can be used to portably generate formatted output to; a terminal. `TerminalController` defines a set of instance variables whose; values are initialized to the control sequence necessary to; perform a given action. These can be simply included in normal; output to the terminal:. >>> term = TerminalController(); >>> print('This is '+term.GREEN+'green'+term.NORMAL). Alternatively, the `render()` method can used, which replaces; '${action}' with the string required to perform 'action':. >>> term = TerminalController(); >>> print(term.render('This is ${GREEN}green${NORMAL}')). If the terminal doesn't support a given action, then the value of; the corresponding instance variable will be set to ''. As a; result, the above code will still work on terminals that do not; support color, except that their output will not be colored.; Also, this means that you can test whether the terminal supports a; given action by simply testing the truth value of the; corresponding instance variable:. >>> term = TerminalController(); >>> if term.CLEAR_SCREEN:; ... print('This terminal supports clearning the screen.'). Finally, if the width and height of the terminal are known, then; they will be stored in the `COLS` and `LINES` attributes.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/ProgressBar.py:357,GREEN,GREEN,357,interpreter/llvm-project/llvm/utils/lit/lit/ProgressBar.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/ProgressBar.py,4,"['GREEN', 'green']","['GREEN', 'green']"
Energy Efficiency,"""""""; A proxy object to an non-action node. It implements acces to attributes; and methods of the proxied node. It is also in charge of the creation of; a new operation node in the graph. The aim is to mimic the functionality of; ROOT::RDF::RNode to provide the same API usage.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Proxy.py:125,charge,charge,125,bindings/experimental/distrdf/python/DistRDF/Proxy.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Proxy.py,1,['charge'],['charge']
Energy Efficiency,"""""""; Add aggregate function to the Graph Initializer. Parameters:; gin: The GNN Initializer to which the Aggregate function will be added; reducer: Specifies the means of aggregate, i.e. sum or mean of supplied values; relation: Specifies the relation of aggregate, i.e. Node-Edge, Global-Edge or Global-Node. """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_gnn.py:139,reduce,reducer,139,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_gnn.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_gnn.py,1,['reduce'],['reducer']
Energy Efficiency,"""""""; CmpRuns - A simple tool for comparing two static analyzer runs to determine; which reports have been added, removed, or changed. This is designed to support automated testing using the static analyzer, from; two perspectives:; 1. To monitor changes in the static analyzer's reports on real code bases,; for regression testing. 2. For use by end users who want to integrate regular static analyzer testing; into a buildbot like environment. Usage:. # Load the results of both runs, to obtain lists of the corresponding; # AnalysisDiagnostic objects.; #; resultsA = load_results_from_single_run(singleRunInfoA, delete_empty); resultsB = load_results_from_single_run(singleRunInfoB, delete_empty). # Generate a relation from diagnostics in run A to diagnostics in run B; # to obtain a list of triples (a, b, confidence).; diff = compare_results(resultsA, resultsB). """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:238,monitor,monitor,238,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,1,['monitor'],['monitor']
Energy Efficiency,"""""""; Copy objects from a file or directory (sourceFile,sourcePathSplit); to an other file or directory (destFile,destPathSplit); - Has the will to be unix-like; - that's a recursive function; - Python adaptation of a root input/output tutorial :; $ROOTSYS/tutorials/io/copyFiles.C; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/main/python/cmdLineUtils.py:201,adapt,adaptation,201,main/python/cmdLineUtils.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/main/python/cmdLineUtils.py,1,['adapt'],['adaptation']
Energy Efficiency,"""""""; Executes an RDataFrame computation graph on a distributed backend. The needed ingredients are:. - A collection of logical ranges in which the dataset is split. Each; range is going to be assigned to a distributed task.; - A representation of the computation graph that the task needs to; execute.; - A way to generate an RDataFrame instance starting from the logical; range of the task.; - Optionally, some setup code to be run at the beginning of each task. These are used as inputs to a generic mapper function. Results from the; various mappers are then reduced and the final results are retrieved in; the local session. These are properly handled to perform extra checks,; depending on the data source. Finally, the local user-facing nodes are; filled with the values that were computed distributedly so that they; can be accessed in the application like with local RDataFrame.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py:562,reduce,reduced,562,bindings/experimental/distrdf/python/DistRDF/HeadNode.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py,1,['reduce'],['reduced']
Energy Efficiency,"""""""; Generates a dictionary holding information about all nodes in the graph.; It is then given to the distributed scheduler.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py:115,schedul,scheduler,115,bindings/experimental/distrdf/python/DistRDF/HeadNode.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py,1,['schedul'],['scheduler']
Energy Efficiency,"""""""; Informs the user that the live visualization feature is not supported for the Spark backend ; and refers to ProcessAndMerge to proceed with the standard map-reduce workflow.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Spark/Backend.py:162,reduce,reduce,162,bindings/experimental/distrdf/python/DistRDF/Backends/Spark/Backend.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Spark/Backend.py,1,['reduce'],['reduce']
Energy Efficiency,"""""""; Performs map-reduce using Dask framework. Args:; ranges (list): A list of ranges to be processed.; mapper (function): A function that runs the computational graph; and returns a list of values. reducer (function): A function that merges two lists that were; returned by the mapper. Returns:; list: A list representing the values of action nodes returned; after computation (Map-Reduce).; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py:18,reduce,reduce,18,bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,3,"['Reduce', 'reduce']","['Reduce', 'reduce', 'reducer']"
Energy Efficiency,"""""""; Performs map-reduce using Spark framework. Args:; mapper (function): A function that runs the computational graph; and returns a list of values. reducer (function): A function that merges two lists that were; returned by the mapper. Returns:; list: A list representing the values of action nodes returned; after computation (Map-Reduce).; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Spark/Backend.py:18,reduce,reduce,18,bindings/experimental/distrdf/python/DistRDF/Backends/Spark/Backend.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Spark/Backend.py,3,"['Reduce', 'reduce']","['Reduce', 'reduce', 'reducer']"
Energy Efficiency,"""""""; Performs real-time map-reduce using Dask framework, retrieving the partial results ; as soon as they are available, allowing real-time data representation. Args:; ranges (list): A list of ranges to be processed. mapper (function): A function that runs the computational graph; and returns a list of values. reducer (function): A function that merges two lists that were; returned by the mapper. drawables_info_dict (dict): A dictionary where keys are plot object IDs ; and values are tuples containing optional callback functions, ; index of the plot object, and operation name. Returns:; merged_results (TaskResult): The merged result of the computation.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py:28,reduce,reduce,28,bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,2,['reduce'],"['reduce', 'reducer']"
Energy Efficiency,"""""""; Process partial results and display plots on the provided canvas. Args:; canvas: The TCanvas object for displaying plots.; 			; drawables_info_dict (dict): A dictionary where keys are plot object IDs ; and values are tuples containing optional callback functions, ; index of the plot object, and operation name.; 			; reducer (function): A function for reducing partial results.; 			; future_tasks: Dask future tasks representing partial results. Returns:; merged_results (TaskResult): The merged result of the computation.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py:323,reduce,reducer,323,bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,1,['reduce'],['reducer']
Energy Efficiency,"""""""; Reduce initial dataset to only events which shall be used for training; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/tmva100_DataPreparation.py:5,Reduce,Reduce,5,tutorials/tmva/tmva100_DataPreparation.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/tmva100_DataPreparation.py,1,['Reduce'],['Reduce']
Energy Efficiency,"""""""; Retrieve the total number of cores known to the Dask scheduler through the; client connection.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py:58,schedul,scheduler,58,bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,1,['schedul'],['scheduler']
Energy Efficiency,"""""""; Run command with arguments. Wait for command to complete and measure; execution time and peak memory consumption.; If the exit code was zero then return, otherwise raise; CalledProcessError. The CalledProcessError object will have the; return code in the returncode attribute. The arguments are the same as for the call and check_call functions. Return a tuple of execution time and peak memory.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestUtils.py:106,consumption,consumption,106,interpreter/llvm-project/clang/utils/analyzer/SATestUtils.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestUtils.py,1,['consumption'],['consumption']
Energy Efficiency,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:1270,adapt,adapt,1270,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,1,['adapt'],['adapt']
Energy Efficiency,"""""""; Subclasses must define how to run map-reduce functions on a given; backend.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Base.py:43,reduce,reduce,43,bindings/experimental/distrdf/python/DistRDF/Backends/Base.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Base.py,1,['reduce'],['reduce']
Energy Efficiency,"""""""; TestCase adaptor for providing a Python 'unittest' compatible interface to 'lit'; tests.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/LitTestCase.py:14,adapt,adaptor,14,interpreter/llvm-project/llvm/utils/lit/lit/LitTestCase.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/LitTestCase.py,1,['adapt'],['adaptor']
Energy Efficiency,"""""""; The functions in this module are meant to run on a separate worker process.; Exception: in single process mode _execute is called directly. For efficiency, we copy all data needed to execute all tests into each worker; and store it in global variables. This reduces the cost of each task.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/worker.py:263,reduce,reduces,263,interpreter/llvm-project/llvm/utils/lit/lit/worker.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/worker.py,1,['reduce'],['reduces']
Energy Efficiency,"""""""; float ComputeTopMass(float lep_pt, float lep_eta, float lep_phi, float lep_e, float jet_pt, float jet_eta, float jet_phi, float jet_e, float met_et, float met_phi); {; const ROOT::Math::PtEtaPhiEVector lep(lep_pt / 1000.0, lep_eta, lep_phi, lep_e / 1000.0);; const ROOT::Math::PtEtaPhiEVector met(met_et / 1000.0, 0, met_phi, met_et / 1000.0);; const ROOT::Math::PtEtaPhiEVector bjet(jet_pt / 1000.0, jet_eta, jet_phi, jet_e / 1000.0);; // Please note that we treat here the missing transverse energy as the neutrino, even though the z component is missing!; return (lep + met + bjet).M();; }; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py:499,energy,energy,499,tutorials/dataframe/df107_SingleTopAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py,1,['energy'],['energy']
Energy Efficiency,"""""""Adapted test for array overloading""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_overloads.py:3,Adapt,Adapted,3,bindings/pyroot/cppyy/cppyy/test/test_overloads.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_overloads.py,1,['Adapt'],['Adapted']
Energy Efficiency,"""""""BLACK BLUE GREEN CYAN RED MAGENTA YELLOW WHITE""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/ProgressBar.py:14,GREEN,GREEN,14,interpreter/llvm-project/llvm/utils/lit/lit/ProgressBar.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/ProgressBar.py,1,['GREEN'],['GREEN']
Energy Efficiency,"""""""Calls C-Reduce to create a minimal reproducer for clang crashes. Output files:; *.reduced.sh -- crash reproducer with minimal arguments; *.reduced.cpp -- the reduced file; *.test.sh -- interestingness test for C-Reduce; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:11,Reduce,Reduce,11,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py,5,"['Reduce', 'reduce']","['Reduce', 'reduced']"
Energy Efficiency,"""""""Minimize the clang arguments after running C-Reduce, to get the smallest; command that reproduces the crash on the reduced file.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:48,Reduce,Reduce,48,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py,2,"['Reduce', 'reduce']","['Reduce', 'reduced']"
Energy Efficiency,"""""""Print list of strings in columns; - blue for directories; - green for trees""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/main/python/cmdLineUtils.py:63,green,green,63,main/python/cmdLineUtils.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/main/python/cmdLineUtils.py,1,['green'],['green']
Energy Efficiency,"""""""Reduce <reducable> to <reduced> type on returns from function calls.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/_pythonization.py:3,Reduce,Reduce,3,bindings/pyroot/cppyy/cppyy/python/cppyy/_pythonization.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/_pythonization.py,2,"['Reduce', 'reduce']","['Reduce', 'reduced']"
Energy Efficiency,"""""""Reduce available overloads to 1""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_doc_features.py:3,Reduce,Reduce,3,bindings/pyroot/cppyy/cppyy/test/test_doc_features.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_doc_features.py,1,['Reduce'],['Reduce']
Energy Efficiency,"""""""Reduces GlobalISel failures. This script is a utility to reduce tests that GlobalISel; fails to compile. It runs llc to get the error message using a regex and creates; a custom command to check that specific error. Then, it runs bugpoint; with the custom command. """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/bugpoint_gisel_reducer.py:3,Reduce,Reduces,3,interpreter/llvm-project/llvm/utils/bugpoint_gisel_reducer.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/bugpoint_gisel_reducer.py,2,"['Reduce', 'reduce']","['Reduces', 'reduce']"
Energy Efficiency,"""""""Script to find missing formal dependencies in a build.ninja file. Suppose you have a header file that's autogenerated by (for example) Tablegen.; If a C++ compilation step needs to include that header, then it must be; executed after the Tablegen build step that generates the header. So the; dependency graph in build.ninja should have the Tablegen build step as an; ancestor of the C++ one. If it does not, then there's a latent build-failure; bug, because depending on the order that ninja chooses to schedule its build; steps, the C++ build step could run first, and fail because the header it needs; does not exist yet. But because that kind of bug can easily be latent or intermittent, you might; not notice, if your local test build happens to succeed. What you'd like is a; way to detect problems of this kind reliably, even if they _didn't_ cause a; failure on your first test. This script tries to do that. It's specific to the 'ninja' build tool, because; ninja has useful auxiliary output modes that produce the necessary data:. - 'ninja -t graph' emits the full DAG of formal dependencies derived from; build.ninja (in Graphviz format). - 'ninja -t deps' dumps the database of dependencies discovered at build time; by finding out which headers each source file actually included. By cross-checking these two sources of data against each other, you can find; true dependencies shown by 'deps' that are not reflected as formal dependencies; in 'graph', i.e. a generated header that is required by a given source file but; not forced to be built first. To run it:. - set up a build directory using ninja as the build tool (cmake -G Ninja). - in that build directory, run ninja to perform an actual build (populating; the dependency database). - then, in the same build directory, run this script. No arguments are needed; (but -C and -f are accepted, and propagated to ninja for convenience). Requirements outside core Python: the 'pygraphviz' module, available via pip or; as the 'pytho",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/check_ninja_deps.py:507,schedul,schedule,507,interpreter/llvm-project/llvm/utils/check_ninja_deps.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/check_ninja_deps.py,1,['schedul'],['schedule']
Energy Efficiency,"""""""Simplify clang arguments before running C-Reduce to reduce the time the; interestingness test takes to run.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:45,Reduce,Reduce,45,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py,2,"['Reduce', 'reduce']","['Reduce', 'reduce']"
Energy Efficiency,"""""""Specify the constraint engine used by the analyzer. Specifying; 'basic' uses a simpler, less powerful constraint model used by; checker-0.160 and earlier.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:96,power,powerful,96,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,1,['power'],['powerful']
Energy Efficiency,"""""""Usage of type reducer with extern template""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_templates.py:17,reduce,reducer,17,bindings/pyroot/cppyy/cppyy/test/test_templates.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_templates.py,1,['reduce'],['reducer']
Energy Efficiency,"""""""Usage of type reducer""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_templates.py:17,reduce,reducer,17,bindings/pyroot/cppyy/cppyy/test/test_templates.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_templates.py,1,['reduce'],['reducer']
Energy Efficiency,"""c2"",0,0,600,400);; auto f2 = new TF2(""f2"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; const Int_t Number = 3;; Double_t Red[Number] = { 1.00, 0.00, 0.00};; Double_t Green[Number] = { 0.00, 1.00, 0.00};; Double_t Blue[Number] = { 1.00, 0.00, 1.00};; Double_t Length[Number] = { 0.00, 0.50, 1.00 };; Int_t nb=50;; TColor::CreateGradientColorTable(Number,Length,Red,Green,Blue,nb);; f2->SetContour(nb);; f2->SetLineWidth(1);; f2->SetLineColor(kBlack);; f2->Draw(""surf1z"");; return c2;; }; End_Macro. The function `TColor::CreateGradientColorTable()` automatically; calls `gStyle->SetPalette()`, so there is not need to add one. After a call to `TColor::CreateGradientColorTable()` it is sometimes; useful to store the newly create palette for further use. In particular, it is; recommended to do if one wants to switch between several user define palettes.; To store a palette in an array it is enough to do:. ~~~ {.cpp}; Int_t MyPalette[100];; Double_t Red[] = {0., 0.0, 1.0, 1.0, 1.0};; Double_t Green[] = {0., 0.0, 0.0, 1.0, 1.0};; Double_t Blue[] = {0., 1.0, 0.0, 0.0, 1.0};; Double_t Length[] = {0., .25, .50, .75, 1.0};; Int_t FI = TColor::CreateGradientColorTable(5, Length, Red, Green, Blue, 100);; for (int i=0;i<100;i++) MyPalette[i] = FI+i;; ~~~. Later on to reuse the palette `MyPalette` it will be enough to do. ~~~ {.cpp}; gStyle->SetPalette(100, MyPalette);; ~~~. As only one palette is active, one need to use `TExec` to be able to; display plots using different palettes on the same pad.; The tutorial multipalette.C illustrates this feature. Begin_Macro(source); ../../../tutorials/graphs/multipalette.C; End_Macro. \since **6.26:**; The function `TColor::CreateColorTableFromFile(""filename.txt"")` allows you to create a color; palette based on an input ASCII file. In contrast to `TColor::CreateGradientColorTable()`, here; the length (spacing) is constant and can not be tuned. There is no gradient being interpolated; between adjacent colors. The palette will contain the exact",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx:8012,Green,Green,8012,core/base/src/TColor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx,1,['Green'],['Green']
Energy Efficiency,"# -------------------------------------------------------; # Now we generate the expected bands and power-constraint; # First: find parameter point for mu=0, with conditional MLEs for nuisance parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/TwoSidedFrequentistUpperLimitWithBands.py:100,power,power-constraint,100,tutorials/roostats/TwoSidedFrequentistUpperLimitWithBands.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/TwoSidedFrequentistUpperLimitWithBands.py,1,['power'],['power-constraint']
Energy Efficiency,"# -------------------------------------------------------; # Setup calculators; # MCMC; # we want to setup an efficient proposal function; # using the covariance matrix from a fit to the data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/MultivariateGaussianTest.py:110,efficient,efficient,110,tutorials/roostats/MultivariateGaussianTest.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/MultivariateGaussianTest.py,1,['efficient'],['efficient']
Energy Efficiency,# Adapt the result to unittest.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/LitTestCase.py:2,Adapt,Adapt,2,interpreter/llvm-project/llvm/utils/lit/lit/LitTestCase.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/LitTestCase.py,1,['Adapt'],['Adapt']
Energy Efficiency,"# Adaptive kernel estimation pdf with increased bandwidth scale factor; # (promotes smoothness over detail preservation)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf707_kernelestimation.py:2,Adapt,Adaptive,2,tutorials/roofit/rf707_kernelestimation.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf707_kernelestimation.py,1,['Adapt'],['Adaptive']
Energy Efficiency,"# An adaptive kernel estimation pdf on the same data without mirroring option; # for comparison",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf707_kernelestimation.py:5,adapt,adaptive,5,tutorials/roofit/rf707_kernelestimation.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf707_kernelestimation.py,1,['adapt'],['adaptive']
Energy Efficiency,"# Because undef (-1) saturates and is indistinguishable when testing the; # correctness of a shuffle, we want to bias our fuzz toward having a decent; # mixture of non-undef lanes in the end. With a deep shuffle tree, the; # probabilies aren't good so we need to bias things. The math here is that if; # we uniformly select between -1 and the other inputs, each element of the; # result will have the following probability of being undef:; #; # 1 - (shuffle_range/(shuffle_range+1))^max_shuffle_height; #; # More generally, for any probability P of selecting a defined element in; # a single shuffle, the end result is:; #; # 1 - P^max_shuffle_height; #; # The power of the shuffle height is the real problem, as we want:; #; # 1 - shuffle_range/(shuffle_range+1); #; # So we bias the selection of undef at any given node based on the tree; # height. Below, let 'A' be 'len(shuffle_range)', 'C' be 'max_shuffle_height',; # and 'B' be the bias we use to compensate for; # C '((A+1)*A^(1/C))/(A*(A+1)^(1/C))':; #; # 1 - (B * A)/(A + 1)^C = 1 - A/(A + 1); #; # So at each node we use:; #; # 1 - (B * A)/(A + 1); # = 1 - ((A + 1) * A * A^(1/C))/(A * (A + 1) * (A + 1)^(1/C)); # = 1 - ((A + 1) * A^((C + 1)/C))/(A * (A + 1)^((C + 1)/C)); #; # This is the formula we use to select undef lanes in the shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/shuffle_fuzz.py:661,power,power,661,interpreter/llvm-project/llvm/utils/shuffle_fuzz.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/shuffle_fuzz.py,1,['power'],['power']
Energy Efficiency,"# Case 2 - 'Barlow Beeston' light (one parameter per bin for all samples); # Construct the histogram shapes, using the same parameters for signal and background; # This requires passing the first histogram to the second, so that their common parameters; # can be re-used.; # The first ParamHistFunc will create one parameter per bin, such as `p_ph_sig2_gamma_bin_0`.; # This allows bin 0 to fluctuate up and down.; # Then, the SAME parameters are connected to the background histogram, so the bins fluctuate; # synchronously. This reduces the number of parameters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf709_BarlowBeeston.py:531,reduce,reduces,531,tutorials/roofit/rf709_BarlowBeeston.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf709_BarlowBeeston.py,1,['reduce'],['reduces']
Energy Efficiency,"# Change global strategy for 1D sampling problems without conditional observable; # (1st kFALSE) and without discrete observable (2nd kFALSE) from ROOT.RooFoamGenerator,; # ( an interface to the ROOT.TFoam MC generator with adaptive subdivisioning strategy ) to ROOT.RooAcceptReject,; # a plain accept/reject sampling algorithm [ ROOT.RooFit default before; # ROOT 5.23/04 ]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf902_numgenconfig.py:224,adapt,adaptive,224,tutorials/roofit/rf902_numgenconfig.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf902_numgenconfig.py,1,['adapt'],['adaptive']
Energy Efficiency,"# Compute transverse mass of the W boson using the lepton and the missing transverse energy and make a histogram",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df105_WBosonAnalysis.py:85,energy,energy,85,tutorials/dataframe/df105_WBosonAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df105_WBosonAnalysis.py,2,['energy'],['energy']
Energy Efficiency,"# Compute transverse mass of the W boson using the missing transverse energy and the good lepton; # Use only events with a transverse mass of the reconstructed W boson larger than 60 GeV",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py:70,energy,energy,70,tutorials/dataframe/df107_SingleTopAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py,1,['energy'],['energy']
Energy Efficiency,"# Create 1D kernel estimation pdf; # ---------------------------------------------------------------; # Create adaptive kernel estimation pdf. In self configuration the input data; # is mirrored over the boundaries to minimize edge effects in distribution; # that do not fall to zero towards the edges",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf707_kernelestimation.py:111,adapt,adaptive,111,tutorials/roofit/rf707_kernelestimation.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf707_kernelestimation.py,1,['adapt'],['adaptive']
Energy Efficiency,"# Create 2D adaptive kernel estimation pdf with mirroring and double; # bandwidth",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf707_kernelestimation.py:12,adapt,adaptive,12,tutorials/roofit/rf707_kernelestimation.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf707_kernelestimation.py,1,['adapt'],['adaptive']
Energy Efficiency,"# Create 2D kernel estimation pdf; # ---------------------------------------------------------------; # Create 2D adaptive kernel estimation pdf with mirroring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf707_kernelestimation.py:114,adapt,adaptive,114,tutorials/roofit/rf707_kernelestimation.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf707_kernelestimation.py,1,['adapt'],['adaptive']
Energy Efficiency,"# Create a temp directory inside the normal temp directory so that we can; # try to avoid temporary test file leaks. The user can avoid this behavior; # by setting LIT_PRESERVES_TMP in the environment, so they can easily use; # their own temp directory to monitor temporary file leaks or handle them at; # the buildbot level.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/main.py:256,monitor,monitor,256,interpreter/llvm-project/llvm/utils/lit/lit/main.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/main.py,1,['monitor'],['monitor']
Energy Efficiency,"# Distance between charges r",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/tf_pycallables.py:19,charge,charges,19,bindings/pyroot/pythonizations/test/tf_pycallables.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/tf_pycallables.py,1,['charge'],['charges']
Energy Efficiency,"# Drain the tasks, `pool_size` at a time, until we have less than; # `pool_size` tasks remaining.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/demangle_tree.py:2,Drain,Drain,2,interpreter/llvm-project/llvm/utils/demangle_tree.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/demangle_tree.py,1,['Drain'],['Drain']
Energy Efficiency,"# Extract only the name, excluding the charge; # Storing the data in the dictionary",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/pdg_table_update.py:39,charge,charge,39,etc/pdg_table_update.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/pdg_table_update.py,1,['charge'],['charge']
Energy Efficiency,"# Extract symbols from libraries in parallel. This is a huge time saver when; # doing a debug build, as there are hundreds of thousands of symbols in each; # library.; # FIXME: On AIX, the default pool size can be too big for a logical; # partition's allocated memory, and can lead to an out of memory; # IO error. We are setting the pool size to 8 to avoid such; # errors at the moment, and will look for a graceful solution later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/extract_symbols.py:251,allocate,allocated,251,interpreter/llvm-project/llvm/utils/extract_symbols.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/extract_symbols.py,1,['allocate'],['allocated']
Energy Efficiency,"# Filled shapes in green color",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf107_plotstyles.py:19,green,green,19,tutorials/roofit/rf107_plotstyles.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf107_plotstyles.py,1,['green'],['green']
Energy Efficiency,"# For simplicity, select only events with exactly two muons and require opposite charge",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df102_NanoAODDimuonAnalysis.py:81,charge,charge,81,tutorials/dataframe/df102_NanoAODDimuonAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df102_NanoAODDimuonAnalysis.py,1,['charge'],['charge']
Energy Efficiency,"# GpuOptions=""allow_growth=True"",; # ) # needed for RTX NVidia card and to avoid TF allocates all GPU memory; ## Train Methods; # Here we train all the previously booked methods.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_Higgs_Classification.py:84,allocate,allocates,84,tutorials/tmva/TMVA_Higgs_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_Higgs_Classification.py,1,['allocate'],['allocates']
Energy Efficiency,# Hack to kill C-Reduce because it jumps into its own pgid,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:17,Reduce,Reduce,17,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py,1,['Reduce'],['Reduce']
Energy Efficiency,"# If we return an RVec, we return via pointer the pointer of the allocated data,; # the size in elements. In addition, we provide the size of the datatype in bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_numbadeclare.py:65,allocate,allocated,65,bindings/pyroot/pythonizations/python/ROOT/_numbadeclare.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_numbadeclare.py,1,['allocate'],['allocated']
Energy Efficiency,"# In some cases the Dask scheduler doesn't know about available workers; # at creation time. Most notably, when using batch systems like HTCondor; # through dask-jobqueue, creating the cluster object doesn't actually; # start the workers. The scheduler will know about available workers in; # the cluster only after cluster.scale has been called and the resource; # manager has granted the requested jobs. So at this point, we can only; # rely on the information that was passed by the user as a specification; # of the cluster object. This comes in the form:; # {'WORKER-NAME-1': {'cls': <class 'dask.WORKERCLASS'>,; # 'options': {'CORES_OR_NTHREADS': N, ...}},; # 'WORKER-NAME-2': {'cls': <class 'dask.WORKERCLASS'>,; # 'options': {'CORES_OR_NTHREADS': N, ...}}}; # This concept can vary between different types of clusters, but in the; # cluster types defined in dask-jobqueue the keys of the dictionary above; # refer to the name of a job submission, which can then involve multiple; # cores of a node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py:25,schedul,scheduler,25,bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,2,['schedul'],['scheduler']
Energy Efficiency,"# It is possible to tell the Dask client to wait until the condor scheduler; # has started the requested jobs and launched the Dask workers.; # The client will wait until 'n_workers' workers have been launched. In this; # example, the client waits for all the jobs requested to start before; # continuing with the application.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/distrdf004_dask_lxbatch.py:66,schedul,scheduler,66,tutorials/dataframe/distrdf004_dask_lxbatch.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/distrdf004_dask_lxbatch.py,1,['schedul'],['scheduler']
Energy Efficiency,"# Kick tau a bit, and run an unbinned fit where the blinded data are missing.; # ----------------------------------------------------------------------------------------------------------; # The fit should be done only in the unblinded regions, otherwise it would try; # to make the model adapt to the empty bins in the blinded region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf212_plottingInRanges_blinding.py:289,adapt,adapt,289,tutorials/roofit/rf212_plottingInRanges_blinding.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf212_plottingInRanges_blinding.py,1,['adapt'],['adapt']
Energy Efficiency,"# Make the m data-points; # Make a variable to hold our data; # Allocate memory for the data point",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/math/principal.py:64,Allocate,Allocate,64,tutorials/math/principal.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/math/principal.py,1,['Allocate'],['Allocate']
Energy Efficiency,"# Map-Reduce using Spark",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Spark/Backend.py:6,Reduce,Reduce,6,bindings/experimental/distrdf/python/DistRDF/Backends/Spark/Backend.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Spark/Backend.py,1,['Reduce'],['Reduce']
Energy Efficiency,"# Now we reduce the fwd declarations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/cmake/unix/rootmapcat.py:9,reduce,reduce,9,cmake/unix/rootmapcat.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/cmake/unix/rootmapcat.py,1,['reduce'],['reduce']
Energy Efficiency,"# Power law example; # -----------------; # Let's not look at another example: a power law \f[x^a\f].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf614_binned_fit_problems.py:2,Power,Power,2,tutorials/roofit/rf614_binned_fit_problems.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf614_binned_fit_problems.py,2,"['Power', 'power']","['Power', 'power']"
Energy Efficiency,"# ROOT uses the numba Python package to create C++ functions from python ones.; # We support as input and return types of the callable fundamental types and; # ROOT::RVec thereof. See the following callable computing the power of the; # elements in an array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/pyroot004_NumbaDeclare.py:221,power,power,221,tutorials/pyroot/pyroot004_NumbaDeclare.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/pyroot004_NumbaDeclare.py,1,['power'],['power']
Energy Efficiency,"# Reconstruct the top mass from the lepton, the missing transverse energy and the b-jet; # Just-in-time compile the function to compute the top mass from the constituents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py:67,energy,energy,67,tutorials/dataframe/df107_SingleTopAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py,1,['energy'],['energy']
Energy Efficiency,"# Redefinition of `RooAbsData.reduce` for keyword arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_roofit/_rooabsdata.py:30,reduce,reduce,30,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_roofit/_rooabsdata.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_roofit/_rooabsdata.py,1,['reduce'],['reduce']
Energy Efficiency,"# Reducing, appending and merging; # -------------------------------------------------------------; # The reduce() function returns a dataset which is a subset of the; # original",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf402_datahandling.py:106,reduce,reduce,106,tutorials/roofit/rf402_datahandling.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf402_datahandling.py,1,['reduce'],['reduce']
Energy Efficiency,"# Right:; # ----------------------------------------------------------------------------------------------------------; # Make the same plot, but normalise each piece with respect to the regions ""left"" AND ""right"". This requires setting; # a ""NormRange"", which tells RooFit over which range the PDF has to be integrated to normalise.; # This means that the normalisation of the blue and green curves is slightly different from the left plot,; # because they get a common scale factor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf212_plottingInRanges_blinding.py:387,green,green,387,tutorials/roofit/rf212_plottingInRanges_blinding.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf212_plottingInRanges_blinding.py,1,['green'],['green']
Energy Efficiency,"# Select events with a muon or electron trigger and with a missing transverse energy larger than 30 GeV",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df105_WBosonAnalysis.py:78,energy,energy,78,tutorials/dataframe/df105_WBosonAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df105_WBosonAnalysis.py,2,['energy'],['energy']
Energy Efficiency,"# Select events with electron or muon trigger and with a missing transverse energy above 30 GeV",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py:76,energy,energy,76,tutorials/dataframe/df107_SingleTopAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py,1,['energy'],['energy']
Energy Efficiency,"# Select events with exactly four good leptons conserving charge and lepton numbers; # Note that all collections are RVecs and good_lep is the mask for the good leptons.; # The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; # irrespective of the charge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df106_HiggsToFourLeptons.py:58,charge,charge,58,tutorials/dataframe/df106_HiggsToFourLeptons.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df106_HiggsToFourLeptons.py,2,['charge'],['charge']
Energy Efficiency,"# Set sigma to 1 and mean to zero of survival function of quantile of normal; # distribution, and set color to green and title to none.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/math/normalDist.py:111,green,green,111,tutorials/math/normalDist.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/math/normalDist.py,1,['green'],['green']
Energy Efficiency,"# Set sigma to 1 and mean to zero, for the survival function of normal; # distribution, and set the color to green and title to none",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/math/normalDist.py:109,green,green,109,tutorials/math/normalDist.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/math/normalDist.py,1,['green'],['green']
Energy Efficiency,"# Since reading out data to memory is expensive, always try to read-out only what; # is needed for your analysis. You can use all RDataFrame features to reduce your; # dataset, e.g., the Filter transformation. Furthermore, you can can pass to the; # AsNumpy method a whitelist of column names with the option `columns` or a blacklist; # with column names with the option `exclude`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df026_AsNumpyArrays.py:153,reduce,reduce,153,tutorials/dataframe/df026_AsNumpyArrays.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df026_AsNumpyArrays.py,1,['reduce'],['reduce']
Energy Efficiency,"# Start with max possible number of columns and reduce until it fits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/main/python/cmdLineUtils.py:48,reduce,reduce,48,main/python/cmdLineUtils.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/main/python/cmdLineUtils.py,1,['reduce'],['reduce']
Energy Efficiency,"# Step #1; # Try to narrow down the failing pass sequence by splitting the pipeline in two; # opt invocations (A and B) starting with invocation A only running the first; # pipeline pass and invocation B the remaining. Keep moving the split point; # forward as long as invocation A exits normally and invocation B fails with; # the expected error. This will accomplish two things first the input IR will be; # further reduced and second, with that IR, the reduced pipeline for invocation; # B will be sufficient to reproduce.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/reduce_pipeline.py:418,reduce,reduced,418,interpreter/llvm-project/llvm/utils/reduce_pipeline.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/reduce_pipeline.py,2,['reduce'],['reduced']
Energy Efficiency,# Step #3; # Now that we have a pipeline that is reduced both front and back we do; # exhaustive sweeps over the remainder trying to remove one pass at a time.; # Repeat as long as reduction is possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/reduce_pipeline.py:49,reduce,reduced,49,interpreter/llvm-project/llvm/utils/reduce_pipeline.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/reduce_pipeline.py,1,['reduce'],['reduced']
Energy Efficiency,"# TODO: This shouldn't be triggered if entries == 1. The current minimum; # amount of partitions is 2. We need a robust reducer that smartly; # becomes no-op if npartitions == 1 to avoid this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py:120,reduce,reducer,120,bindings/experimental/distrdf/python/DistRDF/HeadNode.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py,1,['reduce'],['reducer']
Energy Efficiency,"# The resources described in the specified arguments to this class represent; # the submission of a single job and will spawn a single Dask worker when; # the condor scheduler launches the job. Specifically, this example has Dask; # workers each with 1 core and 2 GB of memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/distrdf004_dask_lxbatch.py:166,schedul,scheduler,166,tutorials/dataframe/distrdf004_dask_lxbatch.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/distrdf004_dask_lxbatch.py,1,['schedul'],['scheduler']
Energy Efficiency,# There is no reason to cache successful tests because we will; # always reduce the changeset when we see one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:73,reduce,reduce,73,interpreter/llvm-project/clang/utils/token-delta.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py,1,['reduce'],['reduce']
Energy Efficiency,"# This code is adapted from the pprint_list function here :; # http://stackoverflow.com/questions/25026556/output-list-like-ls; # Thanks hawkjo !!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/main/python/cmdLineUtils.py:15,adapt,adapted,15,main/python/cmdLineUtils.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/main/python/cmdLineUtils.py,1,['adapt'],['adapted']
Energy Efficiency,"# Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; # ___ -1; # Vred = V22 = V11 - V12 * V22 * V21; #; # Where V11,V12,V21, represent a block decomposition of the covariance matrix into observables that; # are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), V22bar; # is the Shur complement of V22, as shown above; #; # (Note that Vred is _not_ a simple sub-matrix of V); # Propagate partial error due to shape parameters (m,m2) using linear and; # sampling method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf610_visualerror.py:90,reduce,reduced,90,tutorials/roofit/rf610_visualerror.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf610_visualerror.py,1,['reduce'],['reduced']
Energy Efficiency,# We want to retrieve the clang version even if there are no; # reports. Assume that all reports were created using the same; # clang version (this is always true and is more efficient).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:175,efficient,efficient,175,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,1,['efficient'],['efficient']
Energy Efficiency,"# \file; # \ingroup tutorial_dataframe; #; # Configure a Dask connection to a HTCondor cluster hosted by the CERN batch; # service. To reproduce this tutorial, run the following steps:; #; # 1. Login to lxplus; # 2. Source an LCG release (minimum LCG104). See; # https://lcgdocs.web.cern.ch/lcgdocs/lcgreleases/introduction/ for details; # 3. Install the `dask_lxplus` package, which provides the `CernCluster` class; # needed to properly connect to the CERN condor pools. See; # https://batchdocs.web.cern.ch/specialpayload/dask.html for instructions; # 4. Run this tutorial; #; # The tutorial defines resources that each job will request to the condor; # scheduler, then creates a Dask client that can be used by RDataFrame to; # distribute computations.; #; # \macro_code; #; # \date September 2023; # \author Vincenzo Eduardo Padulano CERN",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/distrdf004_dask_lxbatch.py:657,schedul,scheduler,657,tutorials/dataframe/distrdf004_dask_lxbatch.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/distrdf004_dask_lxbatch.py,1,['schedul'],['scheduler']
Energy Efficiency,"# assert(reduce(set.union, sets, set()) == c); # If there is nothing left we can remove, we are done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:9,reduce,reduce,9,interpreter/llvm-project/clang/utils/token-delta.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py,1,['reduce'],['reduce']
Energy Efficiency,"# from keras.callbacks import ReduceLROnPlateau",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_CNN_Classification.py:30,Reduce,ReduceLROnPlateau,30,tutorials/tmva/TMVA_CNN_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_CNN_Classification.py,1,['Reduce'],['ReduceLROnPlateau']
Energy Efficiency,"# from six.py ---; # Copyright (c) 2010-2017 Benjamin Peterson; #; # Permission is hereby granted, free of charge, to any person obtaining a copy; # of this software and associated documentation files (the ""Software""), to deal; # in the Software without restriction, including without limitation the rights; # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; # copies of the Software, and to permit persons to whom the Software is; # furnished to do so, subject to the following conditions:; #; # The above copyright notice and this permission notice shall be included in all; # copies or substantial portions of the Software.; #; # THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; # SOFTWARE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/_typemap.py:107,charge,charge,107,bindings/pyroot/cppyy/cppyy/python/cppyy/_typemap.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/_typemap.py,1,['charge'],['charge']
Energy Efficiency,"# if you want to see a plot of the sampling distribution for a particular scan point:; #; # sampPlot = ROOT.RooStats.SamplingDistPlot(); # indexInScan = 0; # tmpPoint = parameterScan.get(indexInScan).clone(""temp""); # firstPOI.setVal( tmpPoint.getRealValue(firstPOI.GetName()) ); # toymcsampler.SetParametersForTestStat(tmpPOI); # samp = toymcsampler.GetSamplingDistribution(tmpPoint); # sampPlot.AddSamplingDistribution(samp); # sampPlot.Draw(); # Now find bands and power constraint",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/TwoSidedFrequentistUpperLimitWithBands.py:467,power,power,467,tutorials/roostats/TwoSidedFrequentistUpperLimitWithBands.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/TwoSidedFrequentistUpperLimitWithBands.py,1,['power'],['power']
Energy Efficiency,"# lower message level; # plot it, red is averaged model, green is b known exactly, blue is s+b av model",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/HybridInstructional.py:57,green,green,57,tutorials/roostats/HybridInstructional.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/HybridInstructional.py,1,['green'],['green']
Energy Efficiency,"# mapper to reduce template expression trees",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/_pythonization.py:12,reduce,reduce,12,bindings/pyroot/cppyy/cppyy/python/cppyy/_pythonization.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/_pythonization.py,1,['reduce'],['reduce']
Energy Efficiency,"# name for internal binning that is created for the RooDataHist to adapt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_roofit/_roodatahist.py:67,adapt,adapt,67,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_roofit/_roodatahist.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_roofit/_roodatahist.py,1,['adapt'],['adapt']
Energy Efficiency,"# needed for RTX NVidia card and to avoid TF allocates all GPU memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_CNN_Classification.py:45,allocate,allocates,45,tutorials/tmva/TMVA_CNN_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_CNN_Classification.py,1,['allocate'],['allocates']
Energy Efficiency,"# plot the correction term (* norm constant) in dashed green; # should make norm constant just be 1, not depend on binning of data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/rs_bernsteinCorrection.py:55,green,green,55,tutorials/roostats/rs_bernsteinCorrection.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/rs_bernsteinCorrection.py,1,['green'],['green']
Energy Efficiency,"# return weight of last loaded coordinates; # Reduce the 2-dimensional binned dataset to a 1-dimensional binned dataset; #; # All reduce() methods are interfaced in RooAbsData. All reduction techniques; # demonstrated on unbinned datasets can be applied to binned datasets as; # well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf402_datahandling.py:46,Reduce,Reduce,46,tutorials/roofit/rf402_datahandling.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf402_datahandling.py,2,"['Reduce', 'reduce']","['Reduce', 'reduce']"
Energy Efficiency,"# setprecision(15); # Same with custom configuration; # -----------------------------------------------------------; # Construct a custom configuration which uses the adaptive Gauss-Kronrod technique; # for closed 1D integrals",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf901_numintconfig.py:167,adapt,adaptive,167,tutorials/roofit/rf901_numintconfig.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf901_numintconfig.py,1,['adapt'],['adaptive']
Energy Efficiency,"# the following works as a side-effect of a workaround for vector calls and; # it is probably preferable to have it working, so leave the discrepancy for; # now: python's aggressive end-of-life schedule will catch up soon enough",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_datatypes.py:194,schedul,schedule,194,bindings/pyroot/cppyy/cppyy/test/test_datatypes.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_datatypes.py,1,['schedul'],['schedule']
Energy Efficiency,"# use MCMCCalculator (takes about 1 min); # Want an efficient proposal function, so derive it from covariance; # matrix of fit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/FourBinInstructional.py:52,efficient,efficient,52,tutorials/roostats/FourBinInstructional.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/FourBinInstructional.py,1,['efficient'],['efficient']
Energy Efficiency,"# x dataset: 5 pairs of particle charges",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/tf_pycallables.py:33,charge,charges,33,bindings/pyroot/pythonizations/test/tf_pycallables.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/tf_pycallables.py,1,['charge'],['charges']
Energy Efficiency,#!/usr/bin/env python3; # Automatically formatted with yapf (https://github.com/google/yapf); # Fake 'opt' program that can be made to crash on request. For testing; # the 'reduce_pipeline.py' automatic 'opt' NPM pipeline reducer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/reduce_pipeline_test/fake_opt.py:222,reduce,reducer,222,interpreter/llvm-project/llvm/utils/reduce_pipeline_test/fake_opt.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/reduce_pipeline_test/fake_opt.py,1,['reduce'],['reducer']
Energy Efficiency,"## Basic initialization of FOAM invoked by the user. Mandatory!; ///; /// This method starts the process of the cell build-up.; /// User must invoke Initialize with two arguments or Initialize without arguments.; /// This is done BEFORE generating first MC event and AFTER allocating FOAM object; /// and resetting (optionally) its internal parameters/switches.; /// The overall operational scheme of the FOAM is the following:; ///; /// \image html foam_schema2.png width=600; ///; /// ### This method invokes several other methods:; ///; /// InitCells initializes memory storage for cells and begins exploration process; /// from the root cell. The empty cells are allocated/filled using CellFill.; /// The procedure Grow which loops over cells, picks up the cell with the biggest; /// ``driver integral'', see Computer Physics Communications 152 152 (2003) 55 for explanations,; /// with the help of PeekMax procedure. The chosen cell is split using Divide.; /// Subsequently, the procedure Explore called by the Divide; /// (and by InitCells for the root cell) does the most important; /// job in the FOAM object build-up: it performs a small MC run for each; /// newly allocated daughter cell.; /// Explore calculates how profitable the future split of the cell will be; /// and defines the optimal cell division geometry with the help of Carver or Varedu; /// procedures, for maximum weight or variance optimization respectively.; /// All essential results of the exploration are written into; /// the explored cell object. At the very end of the foam build-up,; /// Finally, MakeActiveList is invoked to create a list of pointers to; /// all active cells, for the purpose of the quick access during the MC generation.; /// The procedure Explore employs MakeAlpha to generate random coordinates; /// inside a given cell with the uniform distribution.; /// The above sequence of the procedure calls is depicted in the following figure:; ///; /// \image html foam_Initialize_schema.png width=600",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:1261,allocate,allocated,1261,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,1,['allocate'],['allocated']
Energy Efficiency,"## \file; ## \ingroup tutorial_dataframe; ## \notebook -draw; ## A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame.; ##; ## This tutorial is the analysis of single top production adapted from the ATLAS Open Data release in 2020; ## (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector; ## during 2016 at a center-of-mass energy of 13 TeV. Top quarks with a mass of about 172 GeV are mostly; ## produced in pairs but also appear alone, dominantly from the decays of a W boson in association with a light jet.; ##; ## The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data.; ## By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with; ## the --full-dataset argument and you can also run only on a fraction of the original dataset using the argument --lumi-scale.; ##; ## See the [corresponding spec json file](https://github.com/root-project/root/blob/master/tutorials/dataframe/df107_SingleTopAnalysis.json).; ##; ## \macro_image; ## \macro_code; ## \macro_output; ##; ## \date July 2020; ## \author Stefan Wunsch (KIT, CERN)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py:210,adapt,adapted,210,tutorials/dataframe/df107_SingleTopAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py,3,"['adapt', 'energy', 'reduce']","['adapted', 'energy', 'reduce']"
Energy Efficiency,"## \file; ## \ingroup tutorial_dataframe; ## \notebook -draw; ## The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame.; ##; ## This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020; ## (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector; ## during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson; ## to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads; ## to a narrow invariant mass peak on top a relatively smooth and small background, revealing; ## the Higgs at 125 GeV.; ## Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting.; ## The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; ##; ## See the [corresponding spec json file](https://github.com/root-project/root/blob/master/tutorials/dataframe/df106_HiggsToFourLeptons_spec.json).; ##; ## \macro_image; ## \macro_code; ## \macro_output; ##; ## \date March 2020, August 2022, August 2023; ## \authors Stefan Wunsch (KIT, CERN), Julia Mathe (CERN), Marta Czurylo (CERN)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df106_HiggsToFourLeptons.py:399,energy,energy,399,tutorials/dataframe/df106_HiggsToFourLeptons.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df106_HiggsToFourLeptons.py,1,['energy'],['energy']
Energy Efficiency,"## \file; ## \ingroup tutorial_dataframe; ## \notebook -draw; ## The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame.; ##; ## This tutorial is the Higgs to two photons analysis from the ATLAS Open Data release in 2020; ## (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector; ## during 2016 at a center-of-mass energy of 13 TeV. Although the Higgs to two photons decay is very rare,; ## the contribution of the Higgs can be seen as a narrow peak around 125 GeV because of the excellent; ## reconstruction and identification efficiency of photons at the ATLAS experiment.; ##; ## The analysis is translated to a RDataFrame workflow processing 1.7 GB of simulated events and data.; ##; ## \macro_image; ## \macro_code; ## \macro_output; ##; ## \date February 2020; ## \author Stefan Wunsch (KIT, CERN)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df104_HiggsToTwoPhotons.py:396,energy,energy,396,tutorials/dataframe/df104_HiggsToTwoPhotons.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df104_HiggsToTwoPhotons.py,1,['energy'],['energy']
Energy Efficiency,"## \file; ## \ingroup tutorial_dataframe; ## \notebook -draw; ## The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame.; ##; ## This tutorial is the analysis of the W boson mass taken from the ATLAS Open Data release in 2020; ## (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector; ## during 2016 at a center-of-mass energy of 13 TeV. W bosons are produced frequently at the LHC and; ## are an important background to studies of Standard Model processes, for example the Higgs boson analyses.; ##; ## The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data.; ## By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with; ## the --full-dataset argument and you can also run only on a fraction of the original dataset using the argument --lumi-scale.; ##; ## See the [corresponding spec json file](https://github.com/root-project/root/blob/master/tutorials/dataframe/df105_WBosonAnalysis.json).; ##; ## \macro_image; ## \macro_code; ## \macro_output; ##; ## \date March 2020; ## \author Stefan Wunsch (KIT, CERN)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df105_WBosonAnalysis.py:399,energy,energy,399,tutorials/dataframe/df105_WBosonAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df105_WBosonAnalysis.py,2,"['energy', 'reduce']","['energy', 'reduce']"
Energy Efficiency,"## \file; ## \ingroup tutorial_dataframe; ## \notebook -draw; ## Use RVecs to plot the transverse momentum of selected particles.; ##; ## This tutorial shows how VecOps can be used to slim down the programming; ## model typically adopted in HEP for analysis.; ## In this case we have a dataset containing the kinematic properties of; ## particles stored in individual arrays.; ## We want to plot the transverse momentum of these particles if the energy is; ## greater than 100 MeV.; ## \macro_code; ## \macro_image; ##; ## \date March 2018; ## \authors Danilo Piparo (CERN), Andre Vieira Silva",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df017_vecOpsHEP.py:446,energy,energy,446,tutorials/dataframe/df017_vecOpsHEP.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df017_vecOpsHEP.py,1,['energy'],['energy']
Energy Efficiency,"## \file; ## \ingroup tutorial_pyroot; ## \notebook -nodraw; ## This tutorial illustrates the pretty printing feature of PyROOT, which reveals; ## the content of the object if a string representation is requested, e.g., by; ## Python's print statement. The printing behaves similar to the ROOT prompt; ## powered by the C++ interpreter cling.; ##; ## \macro_code; ## \macro_output; ##; ## \date June 2018; ## \author Stefan Wunsch, Enric Tejedor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/pyroot003_prettyPrinting.py:305,power,powered,305,tutorials/pyroot/pyroot003_prettyPrinting.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/pyroot003_prettyPrinting.py,1,['power'],['powered']
Energy Efficiency,"## \file; ## \ingroup tutorial_pyroot; ## \notebook; ## Example of function called when a mouse event occurs in a pad.; ## When moving the mouse in the canvas, a second canvas shows the; ## projection along X of the bin corresponding to the Y position; ## of the mouse. The resulting histogram is fitted with a gaussian.; ## A ""dynamic"" line shows the current bin position in Y.; ## This more elaborated example can be used as a starting point; ## to develop more powerful interactive applications exploiting CINT; ## as a development engine.; ##; ## Note that a class is used to hold on to the canvas that display; ## the selected slice.; ##; ## \macro_image; ## \macro_code; ##; ## \author Rene Brun, Johann Cohen-Tanugi, Wim Lavrijsen, Enric Tejedor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/DynamicSlice.py:464,power,powerful,464,tutorials/pyroot/DynamicSlice.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/DynamicSlice.py,1,['power'],['powerful']
Energy Efficiency,"## \file; ## \ingroup tutorial_rcanvas; ## The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame.; ##; ## This tutorial is the Higgs to two photons analysis from the ATLAS Open Data release in 2020; ## (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector; ## during 2016 at a center-of-mass energy of 13 TeV. Although the Higgs to two photons decay is very rare,; ## the contribution of the Higgs can be seen as a narrow peak around 125 GeV because of the excellent; ## reconstruction and identification efficiency of photons at the ATLAS experiment.; ##; ## The analysis is translated to a RDataFrame workflow processing 1.7 GB of simulated events and data.; ##; ## This macro is replica of tutorials/dataframe/df104_HiggsToTwoPhotons.py, but with usage of ROOT7 graphics; ## Run macro with python3 -i df104.py command to get interactive canvas; ##; ## \macro_image (df104.png); ## \macro_code; ##; ## \date 2021-06-15; ## \authors Stefan Wunsch (KIT, CERN) Sergey Linev (GSI)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/df104.py:374,energy,energy,374,tutorials/rcanvas/df104.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/df104.py,1,['energy'],['energy']
Energy Efficiency,"## \file; ## \ingroup tutorial_rcanvas; ## The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame.; ##; ## This tutorial is the analysis of the W boson mass taken from the ATLAS Open Data release in 2020; ## (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector; ## during 2016 at a center-of-mass energy of 13 TeV. W bosons are produced frequently at the LHC and; ## are an important background to studies of Standard Model processes, for example the Higgs boson analyses.; ##; ## The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data.; ## By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with; ## the --full-dataset argument and you can also run only on a fraction of the original dataset using the argument --lumi-scale.; ##; ## This macro is replica of tutorials/dataframe/df105_WBosonAnalysis.py, but with usage of ROOT7 graphics; ## Run macro with python3 -i df105.py command to get interactive canvas; ##; ## \macro_image (rcanvas_js); ## \macro_code; ##; ## \date March 2020; ## \authors Stefan Wunsch (KIT, CERN) Sergey Linev (GSI)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/df105.py:377,energy,energy,377,tutorials/rcanvas/df105.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/df105.py,2,"['energy', 'reduce']","['energy', 'reduce']"
Energy Efficiency,"## \file; ## \ingroup tutorial_roofit; ## \notebook -js; ## A tutorial that explains you how to solve problems with binning effects and; ## numerical stability in binned fits.; ##; ## ### Introduction; ##; ## In this tutorial, you will learn three new things:; ##; ## 1. How to reduce the bias in binned fits by changing the definition of the; ## normalization integral; ##; ## 2. How to completely get rid of binning effects by integrating the pdf over each bin; ##; ## 3. How to improve the numeric stability of fits with a greatly different; ## number of events per bin, using a constant per-bin counterterm; ##; ## \macro_code; ## \macro_output; ##; ## \date January 2023; ## \author Jonas Rembser",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf614_binned_fit_problems.py:278,reduce,reduce,278,tutorials/roofit/rf614_binned_fit_problems.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf614_binned_fit_problems.py,1,['reduce'],['reduce']
Energy Efficiency,"## \file; ## \ingroup tutorial_roostats; ## \notebook -nodraw; ## 'Number Counting Utils' RooStats tutorial; ##; ## This tutorial shows an example of the RooStats standalone; ## utilities that calculate the p-value or Z value (eg. significance in; ## 1-sided Gaussian standard deviations) for a number counting experiment.; ## This is a hypothesis test between background only and signal-plus-background.; ## The background estimate has uncertainty derived from an auxiliary or sideband; ## measurement.; ##; ## Documentation for these utilities can be found here:; ## https://root.cern.ch/doc/master/namespaceNumberCountingUtils.html; ##; ##; ## This problem is often called a proto-type problem for high energy physics.; ## In some references it is referred to as the on/off problem.; ##; ## The problem is treated in a fully frequentist fashion by; ## interpreting the relative background uncertainty as; ## being due to an auxiliary or sideband observation; ## that is also Poisson distributed with only background.; ## Finally, one considers the test as a ratio of Poisson means; ## where an interval is well known based on the conditioning on the total; ## number of events and the binomial distribution.; ## For more on this, see; ## - http://arxiv.org/abs/0905.3831; ## - http://arxiv.org/abs/physics/physics/0702156; ## - http://arxiv.org/abs/physics/0511028; ##; ##; ## \macro_image; ## \macro_output; ## \macro_code; ##; ## \date July 2022; ## \authors Artem Busorgin, Kyle Cranmer (C++ version)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/rs_numbercountingutils.py:706,energy,energy,706,tutorials/roostats/rs_numbercountingutils.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/rs_numbercountingutils.py,1,['energy'],['energy']
Energy Efficiency,"## \file; ## \ingroup tutorial_tmva; ## \notebook; ## Classification example of TMVA based on public Higgs UCI dataset; ##; ## The UCI data set is a public HIGGS data set , see http://archive.ics.uci.edu/ml/datasets/HIGGS; ## used in this paper: Baldi, P., P. Sadowski, and D. Whiteson. “Searching for Exotic Particles in High-energy Physics; ## with Deep Learning.” Nature Communications 5 (July 2, 2014).; ##; ## \macro_image; ## \macro_output; ## \macro_code; ##; ## \author Harshal Shende; ## Declare Factory; ## Create the Factory class. Later you can choose the methods; ## whose performance you'd like to investigate.; ## The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to pass; ## - The first argument is the base of the name of all the output; ## weightfiles in the directory weight/ that will be created with the; ## method parameters; ## - The second argument is the output file for the training results; ## - The third argument is a string option defining some general configuration for the TMVA session. For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in the option string",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_Higgs_Classification.py:327,energy,energy,327,tutorials/tmva/TMVA_Higgs_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_Higgs_Classification.py,1,['energy'],['energy']
Energy Efficiency,"## \file; ## \ingroup tutorial_vecops; ## \notebook -nodraw; ## In this tutorial we learn how the RVec class can be used to; ## adopt existing memory or allocate some.; ##; ## \macro_code; ## \macro_output; ##; ## \date May 2018; ## \author Danilo Piparo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/vecops/vo001_AdoptOrOwnMemory.py:153,allocate,allocate,153,tutorials/vecops/vo001_AdoptOrOwnMemory.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/vecops/vo001_AdoptOrOwnMemory.py,1,['allocate'],['allocate']
Energy Efficiency,"' : draw the front box of a cartesian lego plot; 'Back' : draw the back box of a cartesian lego plot; Available for a 3D lego plot:; 'Bar' : change the bar attributes; 'W' : change Bar Width; 'O' : change Bar Offset; Further Editor:; 'Marker' : change the Marker attributes (color, appearance,; thickness) see TAttMarkerEditor. Rebinning Tab:; This Tab has two different layouts. One is for a histogram which; is not drawn from an ntuple. The other one is available for a; histogram which is drawn from an ntuple. In this case the rebin; algorithm can create a rebinned histogram from the original data; i.e. the ntuple.; To see te differences do for example:; TFile f(""hsimple.root"");; hpxpy->Draw(""Lego2""); // non ntuple histogram; ntuple->Draw(""px:py"","""",""Lego2""); // ntuple histogram; Non ntuple histogram:; 'Rebin': with the Sliders (one for the x, one for the y axis); the number of bins (shown in the field below the; Slider) can be changed to any number which divides; the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; replace it by the rebinned one on the screen.; Pushing 'Ignore' the origin histogram will be restored; Histogram drawn from an ntuple:; 'Rebin' with the sliders the number of bins can be enlarged by; a factor of 2,3,4,5 (moving to the right) or reduced; by a factor of 1/2, 1/3, 1/4, 1/5; 'BinOffset': with the BinOffset slider the origin of the; histogram can be changed within one binwidth; Using this slider the effect of binning the data into; bins can be made visible => statistical fluctuations; 'Axis Range': with the DoubleSlider it is possible to zoom into; the specified axis range. It is also possible to set; the upper and lower limit in fields below the slider; 'Delayed drawing': all the Binning sliders can be set to delay; draw mode. Then the changes on the histogram are only; updated, when the Slider is released. This should be; activated if the redrawing of the histogram is too; time consuming. //; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TH2Editor.cxx:3390,reduce,reduced,3390,gui/ged/src/TH2Editor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TH2Editor.cxx,1,['reduce'],['reduced']
Energy Efficiency,"'''; using FourVector = ROOT::Math::XYZTVector;; using FourVectorVec = std::vector<FourVector>;; using CylFourVector = ROOT::Math::RhoEtaPhiVector;. // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *filename, const char *treeName); {; const double M = 0.13957; // set pi+ mass; TRandom3 R(1);. auto genTracks = [&](){; FourVectorVec tracks;; const auto nPart = R.Poisson(15);; tracks.reserve(nPart);; for (int j = 0; j < nPart; ++j) {; const auto px = R.Gaus(0, 10);; const auto py = R.Gaus(0, 10);; const auto pt = sqrt(px * px + py * py);; const auto eta = R.Uniform(-3, 3);; const auto phi = R.Uniform(0.0, 2 * TMath::Pi());; CylFourVector vcyl(pt, eta, phi);; // set energy; auto E = sqrt(vcyl.R() * vcyl.R() + M * M);; // fill track vector; tracks.emplace_back(vcyl.X(), vcyl.Y(), vcyl.Z(), E);; }; return tracks;; };. ROOT::RDataFrame d(64);; d.Define(""tracks"", genTracks).Snapshot<FourVectorVec>(treeName, filename, {""tracks""});; }; '''",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df002_dataModel.py:738,energy,energy,738,tutorials/dataframe/df002_dataModel.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df002_dataModel.py,1,['energy'],['energy']
Energy Efficiency,"()	- convert X11 pixmap into ASImage; * asimage2ximage()	- convert ASImage into XImage; * asimage2mask_ximage() - convert alpha channel of ASImage into XImage; * asimage2pixmap()	- convert ASImage into Pixmap ( possibly using; * 					 precreated XImage ); * asimage2mask() 	- convert alpha channel of ASImage into 1 bit; * 				 	 mask Pixmap.; * SEE ALSO; * Other libAfterImage modules :; * ascmap.h asfont.h asimage.h asvisual.h blender.h export.h; * import.h transform.h ximage.h; * AUTHOR; * Sasha Vasko <sasha at aftercode dot net>; *******/; /****f* libAfterImage/picture_ximage2asimage(); * NAME; * picture_ximage2asimage(); * SYNOPSIS; * ASImage *picture_ximage2asimage ( struct ASVisual *asv,; * XImage * xim, XImage *alpha_xim,; * unsigned int compression );; * INPUTS; * asv - pointer to valid ASVisual structure; * xim - source XImage; * alpha_xim - source XImage for Alpha channel; * compression - degree of compression of resulting ASImage.; * RETURN VALUE; * pointer to newly allocated ASImage, containing encoded data, on; * success. NULL on failure.; * DESCRIPTION; * picture_ximage2asimage will attempt to create new ASImage with the same; * dimensions as supplied XImage. If both XImages are supplied - they must; * have same dimentions. XImage will be decoded based on; * supplied ASVisual, and resulting scanlines will be encoded into; * ASImage.; *********/; /****f* libAfterImage/ximage2asimage(); * NAME; * ximage2asimage() - same as picture_ximage2asimage with alpha_ximage ; * set to NULL. Supplied for compatibility with older versions and for ; * convinience.; * SYNOPSIS; * ASImage *ximage2asimage ( struct ASVisual *asv, XImage * xim,; * unsigned int compression );; * INPUTS; * asv 		 - pointer to valid ASVisual structure; * xim 		 - source XImage; * compression - degree of compression of resulting ASImage.; * RETURN VALUE; * pointer to newly allocated ASImage, containing encoded data, on; * success. NULL on failure.; * DESCRIPTION; *********/; /****f* libAfterImage",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ximage.h:1185,allocate,allocated,1185,graf2d/asimage/src/libAfterImage/ximage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ximage.h,1,['allocate'],['allocated']
Energy Efficiency,"): bin content held by a Float_t,; - THnSparseL (typedef for THnSparseT<ArrayL64>): bin content held by a Long64_t,; - THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; - THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; - THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to. Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparseD hs(""hs"", ""hs"", 2, bins, xmin, xmax);. ## Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram. Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). ## Fast Bin Content Access; When iterating over a THnSparse one should only look at filled bins to save; processing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; After the call, coord will contain the bin coordinate of each axis for the bin; with linear index linidx. A possible call would be. std::cout << hs.GetBinContent(0, coord);; std::cout <<"" is the content of bin [x = "" << coord[0] ""; << "" | y = "" << coord[1] << ""]"" << std::endl;. ## Efficiency; TH1 and TH2 are generally faster than THnSparse for one and two dimensional; distributions. THnSparse becomes competitive for a sparsely filled TH3; with large numbers of bins per dimension. The tutorial sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. U",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:1625,allocate,allocated,1625,hist/hist/src/THnSparse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx,1,['allocate'],['allocated']
Energy Efficiency,"):; /// Number of User SGPR registers: 2. This is 2 SGPRs.; ///; /// For CI/VI:; /// The first SGPR is a 32 bit byte offset from SH_MEM_HIDDEN_PRIVATE_BASE; /// to base of memory for scratch for this dispatch. This is the same offset; /// used in computing the Scratch Segment Buffer base address. The value of; /// Scratch Wave Offset must be added by the kernel code and moved to; /// SGPRn-4 for use as the FLAT SCRATCH BASE in flat memory instructions.; ///; /// The second SGPR is 32 bit byte size of a single work-item's scratch; /// memory usage. This is directly loaded from the dispatch packet Private; /// Segment Byte Size and rounded up to a multiple of DWORD.; ///; /// \todo [Does CP need to round this to >4 byte alignment?]; ///; /// The kernel code must move to SGPRn-3 for use as the FLAT SCRATCH SIZE in; /// flat memory instructions. Having CP load it once avoids loading it at; /// the beginning of every wavefront.; ///; /// For PI:; /// This is the 64 bit base address of the scratch backing memory for; /// allocated by CP for this dispatch.; ///; /// Private Segment Size (enable_sgpr_private_segment_size):; /// Number of User SGPR registers: 1. The 32 bit byte size of a single; /// work-item's scratch memory allocation. This is the value from the dispatch; /// packet. Private Segment Byte Size rounded up by CP to a multiple of DWORD.; ///; /// \todo [Does CP need to round this to >4 byte alignment?]; ///; /// Having CP load it once avoids loading it at the beginning of every; /// wavefront.; ///; /// \todo [This will not be used for CI/VI since it is the same value as; /// the second SGPR of Flat Scratch Init. However, it is need for PI which; /// changes meaning of Flat Scratchg Init..]; ///; /// Grid Work-Group Count X (enable_sgpr_grid_workgroup_count_x):; /// Number of User SGPR registers: 1. 32 bit count of the number of; /// work-groups in the X dimension for the grid being executed. Computed from; /// the fields in the HsaDispatchPacket as; /// ((grid",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:4521,allocate,allocated,4521,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['allocate'],['allocated']
Energy Efficiency,"):; /// This algorithm assumes that only a *contiguous* subset of lanes; /// are active. This happens for the last warp in a parallel region; /// when the user specified num_threads is not an integer multiple of; /// 32. This contiguous subset always starts with the zeroth lane.; /// Partial Warp Reduce (argument value 2):; /// This algorithm gathers data from any number of lanes at any position.; /// All reduced values are stored in the lowest possible lane. The set; /// of problems every algorithm addresses is a super set of those; /// addressable by algorithms with a lower version number. Overhead; /// increases as algorithm version increases.; ///; /// Terminology; /// Reduce element:; /// Reduce element refers to the individual data field with primitive; /// data types to be combined and reduced across threads.; /// Reduce list:; /// Reduce list refers to a collection of local, thread-private; /// reduce elements.; /// Remote Reduce list:; /// Remote Reduce list refers to a collection of remote (relative to; /// the current thread) reduce elements.; ///; /// We distinguish between three states of threads that are important to; /// the implementation of this function.; /// Alive threads:; /// Threads in a warp executing the SIMT instruction, as distinguished from; /// threads that are inactive due to divergent control flow.; /// Active threads:; /// The minimal set of threads that has to be alive upon entry to this; /// function. The computation is correct iff active threads are alive.; /// Some threads are alive but they are not active because they do not; /// contribute to the computation in any useful manner. Turning them off; /// may introduce control flow overheads without any tangible benefits.; /// Effective threads:; /// In order to comply with the argument requirements of the shuffle; /// function, we must keep all lanes holding data alive. But at most; /// half of them perform value aggregation; we refer to this half of; /// threads as effective. The ot",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:1456,Reduce,Reduce,1456,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,3,"['Reduce', 'reduce']","['Reduce', 'reduce']"
Energy Efficiency,"); - Gaus(Double_t mean, Double_t sigma); - Rndm(); - Uniform(Double_t); - Landau(Double_t mean, Double_t sigma); - Poisson(Double_t mean); - Binomial(Int_t ntot, Double_t prob). Random numbers distributed according to 1-d, 2-d or 3-d distributions contained in TF1, TF2 or TF3 objects can also be; generated. For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x) you can do : \code{.cpp} TF1; *f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10); double r = f1->GetRandom(); \endcode or you can use the UNURAN; package. You need in this case to initialize UNURAN to the function you would like to generate. \code{.cpp} TUnuran u;; u.Init(TUnuranDistrCont(f1));; double r = u.Sample();; \endcode. The techniques of using directly a TF1,2 or 3 function is powerful and; can be used to generate numbers in the defined range of the function.; Getting a number from a TF1,2,3 function is also quite fast.; UNURAN is a powerful and flexible tool which contains various methods for; generate random numbers for continuous distributions of one and multi-dimension.; It requires some set-up (initialization) phase and can be very fast when the distribution; parameters are not changed for every call. The following table shows some timings (in nanosecond/call); for basic functions, TF1 functions and using UNURAN obtained running; the tutorial math/testrandom.C; Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; Linux SLC4 64 bit and compiled with gcc 3.4. ~~~~; Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3; Rndm.............. 5.000 105.000 7.000 10.000; RndmArray......... 4.000 104.000 6.000 9.000; Gaus.............. 36.000 180.000 40.000 48.000; Rannor............ 118.000 220.000 120.000 124.000; Landau............ 22.000 123.000 26.000 31.000; Exponential....... 93.000 198.000 98.000 104.000; Binomial(5,0.5)... 30.000 548.000 46.000 65.000; Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; Poisson(3)........ 9",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TRandom.cxx:6850,power,powerful,6850,math/mathcore/src/TRandom.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TRandom.cxx,1,['power'],['powerful']
Energy Efficiency,"); ///; /// For example with Event.root, if; /// ~~~ {.cpp}; /// Double_t somePx = fTracks.fPx[2];; /// ~~~; /// is executed by one of the method of the skeleton,; /// somePx will updated with the current value of fPx of the 3rd track.; ///; /// Both macrofilename and the optional cutfilename are expected to be; /// the name of source files which contain at least a free standing; /// function with the signature:; /// ~~~ {.cpp}; /// x_t macrofilename(); // i.e function with the same name as the file; /// ~~~; /// and; /// ~~~ {.cpp}; /// y_t cutfilename(); // i.e function with the same name as the file; /// ~~~; /// x_t and y_t needs to be types that can convert respectively to a double; /// and a bool (because the skeleton uses:; ///; /// if (cutfilename()) htemp->Fill(macrofilename());; ///; /// These two functions are run in a context such that the branch names are; /// available as local variables of the correct (read-only) type.; ///; /// Note that if you use the same 'variable' twice, it is more efficient; /// to 'cache' the value. For example:; /// ~~~ {.cpp}; /// Int_t n = fEventNumber; // Read fEventNumber; /// if (n<10 || n>10) { ... }; /// ~~~; /// is more efficient than; /// ~~~ {.cpp}; /// if (fEventNumber<10 || fEventNumber>10); /// ~~~; /// Also, optionally, the generated selector will also call methods named; /// macrofilename_methodname in each of 6 main selector methods if the method; /// macrofilename_methodname exist (Where macrofilename is stripped of its; /// extension).; ///; /// Concretely, with the script named h1analysisProxy.C,; ///; /// - The method calls the method (if it exist); /// - Begin -> void h1analysisProxy_Begin(TTree*);; /// - SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; /// - Notify -> bool h1analysisProxy_Notify();; /// - Process -> bool h1analysisProxy_Process(Long64_t);; /// - SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; /// - Terminate -> void h1analysisProxy_Terminate();; ///; /// If a file name ma",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2757,efficient,efficient,2757,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['efficient'],['efficient']
Energy Efficiency,")} = [1,1,...,1]^{T} \f$; /// 2. Set required number of repetitions R and iterations L.; /// 3. Set r = 1.; /// 4. Using Gold deconvolution algorithm for k=1,2,...,L find; /// \f$ x^{(L)} \f$; /// 5. If r = R stop calculation, else; ///; /// 1. Apply boosting operation, i.e., set; /// \f$ x^{(0)}(i) = [x^{(L)}(i)]^{p} \f$; /// i=0,1,...N-1 and p is boosting coefficient >0.; /// 2. r = r + 1; /// 3. continue in 4.; ///; /// #### References:; ///; /// 1. Gold R., ANL-6984, Argonne National Laboratories, Argonne Ill, 1964.; /// 2. Coote G.E., Iterative smoothing and deconvolution of one- and two-dimensional; /// elemental distribution data, NIM B 130 (1997) 118.; /// 3. M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky,; /// I. Turzo: Efficient one- and two-dimensional Gold deconvolution and; /// its application to gamma-ray spectra decomposition. NIM, A401 (1997) 385-408.; /// 4. Morhac; M., Matouoek V., Kliman J., Efficient algorithm of multidimensional; /// deconvolution and its application to nuclear data processing, Digital Signal; /// Processing 13 (2003) 144.; ///; /// ### Example 8 - script Deconvolution.C :; ///; /// response function (usually peak) should be shifted left to the first; /// non-zero channel (bin).; ///; /// \image html TSpectrum_Deconvolution2.jpg Principle how the response matrix is composed inside of the Deconvolution function.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Deconvolution.C; /// End_Macro; ///; /// ### Examples of Gold deconvolution method:; ///; /// First let us study the influence of the number of iterations on the; /// deconvolved spectrum (Fig. 12).; ///; /// \image html TSpectrum_Deconvolution_wide1.jpg Fig. 12 Study of Gold deconvolution algorithm.The original source spectrum is drawn with black color, spectrum after 100 iterations with red color, spectrum after 1000 iterations with blue color, spectrum after 10000 iterations with green color and spectrum after 100000 iterations with magenta color.; ///; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:3950,Efficient,Efficient,3950,hist/spectrum/src/TSpectrum.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx,1,['Efficient'],['Efficient']
Energy Efficiency,"* processes are inner loops and need to be as fast as possible. On most; * machines, particularly CPUs with pipelines or instruction prefetch,; * a (subscript-check-less) C table lookup; *		x = sample_range_limit[x];; * is faster than explicit tests; *		if (x < 0) x = 0;; *		else if (x > MAXJSAMPLE) x = MAXJSAMPLE;; * These processes all use a common table prepared by the routine below.; *; * For most steps we can mathematically guarantee that the initial value; * of x is within MAXJSAMPLE+1 of the legal range, so a table running from; * -(MAXJSAMPLE+1) to 2*MAXJSAMPLE+1 is sufficient. But for the initial; * limiting step (just after the IDCT), a wildly out-of-range value is ; * possible if the input data is corrupt. To avoid any chance of indexing; * off the end of memory and getting a bad-pointer trap, we perform the; * post-IDCT limiting thus:; *		x = range_limit[x & MASK];; * where MASK is 2 bits wider than legal sample data, ie 10 bits for 8-bit; * samples. Under normal circumstances this is more than enough range and; * a correct output will be generated; with bogus input data the mask will; * cause wraparound, and we will safely generate a bogus-but-in-range output.; * For the post-IDCT step, we want to convert the data from signed to unsigned; * representation by adding CENTERJSAMPLE at the same time that we limit it.; * So the post-IDCT limiting table ends up looking like this:; * CENTERJSAMPLE,CENTERJSAMPLE+1,...,MAXJSAMPLE,; * MAXJSAMPLE (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),; * 0 (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),; * 0,1,...,CENTERJSAMPLE-1; * Negative inputs select values from the upper half of the table after; * masking.; *; * We can save some space by overlapping the start of the post-IDCT table; * with the simpler range limiting table. The post-IDCT table begins at; * sample_range_limit + CENTERJSAMPLE.; *; * Note that the table is allocated in near data space on PCs; it's small; * enough and used often enough to justify this.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c:2121,allocate,allocated,2121,graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c,1,['allocate'],['allocated']
Energy Efficiency,"* x, y,; * width, height- rectangle on Pixmap to be encoded into ASImage.; * plane_mask - limits color planes to be copied from Pixmap.; * keep_cache - indicates if we should keep XImage, used to copy; * image data from the X server, and attached it to ; * 				 ximage member of resulting ASImage.; * compression - degree of compression of resulting ASImage.; * RETURN VALUE; * pointer to newly allocated ASImage, containing data in XImage format, ; * on success. NULL on failure.; * DESCRIPTION; * pixmap2ximage will obtain XImage of the requested area of the; * X Pixmap, and it will attach it to newly created ASImage using ; * alt.ximage member. After that newly created ASImage could be used ; * in any transformations.; *********/; /****f* libAfterImage/picture2asimage(); * NAME; * picture2asimage(); * SYNOPSIS; * ASImage *picture2asimage (struct ASVisual *asv,; * Pixmap rgb, Pixmap a,; * int x, int y,; * unsigned int width,; * unsigned int height,; * unsigned long plane_mask,; * Bool keep_cache,; * unsigned int compression );; * INPUTS; * asv 		 - pointer to valid ASVisual structure; * rgb 		 - source Pixmap for red, green and blue channels; * a 		 - source Pixmap for the alpha channel; * x, y,; * width, height- rectangle on Pixmap to be encoded into ASImage.; * plane_mask - limits color planes to be copied from Pixmap.; * keep_cache - indicates if we should keep XImage, used to copy; * image data from the X server, and attached it to ; * 				 ximage member of resulting ASImage.; * compression - degree of compression of resulting ASImage.; * RETURN VALUE; * pointer to newly allocated ASImage, containing encoded data, on; * success. NULL on failure.; * DESCRIPTION; * picture2asimage will obtain XImage of the requested area of the; * X Pixmap, If alpha channel pixmap is supplied - it will be used to ; * encode ASImage's alpha channel. Alpha channel pixmap must be either; * 8 or 1 bit deep, and it must have the same dimentions as main Pixmap.; *********/; /****f* libAfter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ximage.h:3644,green,green,3644,graf2d/asimage/src/libAfterImage/ximage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ximage.h,1,['green'],['green']
Energy Efficiency,"***********************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : MethodDT (DT = Decision Trees) *; * *; * *; * Description: *; * Analysis of Boosted Decision Trees *; * *; * Authors (alphabetical): *; * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * Or Cohen <orcohenor@gmail.com> - Weizmann Inst., Israel *; * *; * Copyright (c) 2005: *; * CERN, Switzerland *; * MPI-K Heidelberg, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; /*! \class TMVA::MethodDT; \ingroup TMVA. Analysis of Boosted Decision Trees. Boosted decision trees have been successfully used in High Energy; Physics analysis for example by the MiniBooNE experiment; (Yang-Roe-Zhu, physics/0508045). In Boosted Decision Trees, the; selection is done on a majority vote on the result of several decision; trees, which are all derived from the same training sample by; supplying different event weights during the training. ### Decision trees:. successive decision nodes are used to categorize the; events out of the sample as either signal or background. Each node; uses only a single discriminating variable to decide if the event is; signal-like (""goes right"") or background-like (""goes left""). This; forms a tree like structure with ""baskets"" at the end (leave nodes),; and an event is classified as either signal or background according to; whether the basket where it ends up has been classified signal or; background during the training. Training of a decision tree is the; process to define the ""cut criteria"" for each node. The training; starts with the root node. Here one takes the full training event; sample a",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDT.cxx:1093,Energy,Energy,1093,tmva/tmva/src/MethodDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDT.cxx,1,['Energy'],['Energy']
Energy Efficiency,"*******************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Classes: PDEFoam *; * *; * *; * Description: *; * Implementations *; * *; * Authors (alphabetical): *; * Tancredi Carli - CERN, Switzerland *; * Dominik Dannheim - CERN, Switzerland *; * S. Jadach - Institute of Nuclear Physics, Cracow, Poland *; * Alexander Voigt - TU Dresden, Germany *; * Peter Speckmayer - CERN, Switzerland *; * *; * Copyright (c) 2008, 2010: *; * CERN, Switzerland *; * MPI-K Heidelberg, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; /*! \class TMVA::PDEFoam; \ingroup TMVA. Implementation of PDEFoam. The PDEFoam method is an extension of the PDERS method, which uses; self-adapting binning to divide the multi-dimensional phase space; in a finite number of hyper-rectangles (boxes). For a given number of boxes, the binning algorithm adjusts the size; and position of the boxes inside the multidimensional phase space,; minimizing the variance of the signal and background densities inside; the boxes. The binned density information is stored in binary trees,; allowing for a very fast and memory-efficient classification of; events. The implementation of the PDEFoam is based on the monte-carlo; integration package TFoam included in the analysis package ROOT. The class TMVA::PDEFoam defines the default interface for the; PDEFoam variants:. - PDEFoamEvent; - PDEFoamDiscriminant; - PDEFoamTarget; - PDEFoamMultiTarget; - PDEFoamDecisionTree. Per default PDEFoam stores in the cells the number of events (event; weights) and therefore acts as an event density estimator.; However, the above listed derived classes override this behaviour; to implement certain PDEFoam variations. In order ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoam.cxx:1106,adapt,adapting,1106,tmva/tmva/src/PDEFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoam.cxx,1,['adapt'],['adapting']
Energy Efficiency,"***********************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TClonesArray; \ingroup Containers; An array of clone (identical) objects. Memory for the objects; stored in the array is allocated only once in the lifetime of the; clones array. All objects must be of the same class. For the rest; this class has the same properties as TObjArray. To reduce the very large number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):; ~~~ {.cpp}; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);; ...; ...; }; ...; a.Delete();; }; ~~~; One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):; ~~~ {.cpp}; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);; ...; ...; }; ...; a.Delete(); // or a.Clear() or a.Clear(""C""); }; ~~~; To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot.; ~~~ {.cpp}; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear(); // or a.Clear(""C"");; }; ~~~; Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Ad",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx:1089,reduce,reduces,1089,core/cont/src/TClonesArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx,1,['reduce'],['reduces']
Energy Efficiency,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1138,Power,Power,1138,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['Power']
Energy Efficiency,"****************; * Project: RooStats; * Package: RooFit/RooStats; * @(#)root/roofit/roostats:$Id$; * Authors:; * Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke, Sven Kreiss; *; *****************************************************************************/; /** \class RooStats::HypoTestResult; \ingroup Roostats. HypoTestResult is a base class for results from hypothesis tests.; Any tool inheriting from HypoTestCalculator can return a HypoTestResult.; As such, it stores a p-value for the null-hypothesis (eg. background-only); and an alternate hypothesis (eg. signal+background).; The p-values can also be transformed into confidence levels; (\f$CL_{b}\f$, \f$CL_{s+b}\f$) in a trivial way.; The ratio of the \f$CL_{s+b}\f$ to \f$CL_{b}\f$ is often called; \f$CL_{s}\f$, and is considered useful, though it is not a probability.; Finally, the p-value of the null can be transformed into a number of; equivalent Gaussian sigma using the Significance method. The p-value of the null for a given test statistic is rigorously defined and; this is the starting point for the following conventions. ### Conventions used in this class. The p-value for the null and alternate are on the **same side** of the; observed value of the test statistic. This is the more standard; convention and avoids confusion when doing inverted tests. For exclusion, we also want the formula \f$CL_{s} = CL_{s+b} / CL_{b}\f$; to hold which therefore defines our conventions for \f$CL_{s+b}\f$ and; \f$CL_{b}\f$. \f$CL_{s}\f$ was specifically invented for exclusion; and therefore all quantities need be related through the assignments; as they are for exclusion: \f$CL_{s+b} = p_{s+b}\f$; \f$CL_{b} = p_{b}\f$. This; is derived by considering the scenarios of a powerful and not powerful; inverted test, where for the not so powerful test, \f$CL_{s}\f$ must be; close to one. For results of Hypothesis tests,; \f$CL_{s}\f$ has no similar direct interpretation as for exclusion and can; be larger than one. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestResult.cxx:2288,power,powerful,2288,roofit/roostats/src/HypoTestResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestResult.cxx,3,['power'],['powerful']
Energy Efficiency,"*; * Usage: options are given through Factory: *; * factory->BookMethod( ""MethodCFMlpANN"", OptionsString ); *; * *; * where: *; * TString OptionsString = ""n_training_cycles:n_hidden_layers"" *; * *; * default is: n_training_cycles = 5000, n_layers = 4 *; * note that the number of hidden layers in the NN is *; * *; * n_hidden_layers = n_layers - 2 *; * *; * since there is one input and one output layer. The number of *; * nodes (neurons) is predefined to be *; * *; * n_nodes[i] = nvars + 1 - i (where i=1..n_layers) *; * *; * with nvars being the number of variables used in the NN. *; * Hence, the default case is: n_neurons(layer 1 (input)) : nvars *; * n_neurons(layer 2 (hidden)): nvars-1 *; * n_neurons(layer 3 (hidden)): nvars-1 *; * n_neurons(layer 4 (out)) : 2 *; * *; * This artificial neural network usually needs a relatively large *; * number of cycles to converge (8000 and more). Overtraining can *; * be efficiently tested by comparing the signal and background *; * output of the NN for the events that were used for training and *; * an independent data sample (with equal properties). If the separation *; * performance is significantly better for the training sample, the *; * NN interprets statistical effects, and is hence overtrained. In *; * this case, the number of cycles should be reduced, or the size *; * of the training sample increased. *; * *; * Authors (alphabetical): *; * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; * Xavier Prudent <prudent@lapp.in2p3.fr> - LAPP, France *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; * *; * Copyright (c) 2005: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * LAPP, Annecy, France *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; * *; ************************",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCFMlpANN.h:1874,efficient,efficiently,1874,tmva/tmva/inc/TMVA/MethodCFMlpANN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCFMlpANN.h,1,['efficient'],['efficiently']
Energy Efficiency,",3,...,L; x^{0} = [1,1, ..., 1]^T; \f]; */; /// Where L is given number of iterations (numberIterations parameter).; ///; /// #### Boosted deconvolution:; ///; /// 1. Set the initial solution:; /// \f$ x^{(0)} = [1,1,...,1]^{T} \f$; /// 2. Set required number of repetitions R and iterations L.; /// 3. Set r = 1.; /// 4. Using Gold deconvolution algorithm for k=1,2,...,L find; /// \f$ x^{(L)} \f$; /// 5. If r = R stop calculation, else; ///; /// 1. Apply boosting operation, i.e., set; /// \f$ x^{(0)}(i) = [x^{(L)}(i)]^{p} \f$; /// i=0,1,...N-1 and p is boosting coefficient >0.; /// 2. r = r + 1; /// 3. continue in 4.; ///; /// #### References:; ///; /// 1. Gold R., ANL-6984, Argonne National Laboratories, Argonne Ill, 1964.; /// 2. Coote G.E., Iterative smoothing and deconvolution of one- and two-dimensional; /// elemental distribution data, NIM B 130 (1997) 118.; /// 3. M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky,; /// I. Turzo: Efficient one- and two-dimensional Gold deconvolution and; /// its application to gamma-ray spectra decomposition. NIM, A401 (1997) 385-408.; /// 4. Morhac; M., Matouoek V., Kliman J., Efficient algorithm of multidimensional; /// deconvolution and its application to nuclear data processing, Digital Signal; /// Processing 13 (2003) 144.; ///; /// ### Example 8 - script Deconvolution.C :; ///; /// response function (usually peak) should be shifted left to the first; /// non-zero channel (bin).; ///; /// \image html TSpectrum_Deconvolution2.jpg Principle how the response matrix is composed inside of the Deconvolution function.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Deconvolution.C; /// End_Macro; ///; /// ### Examples of Gold deconvolution method:; ///; /// First let us study the influence of the number of iterations on the; /// deconvolved spectrum (Fig. 12).; ///; /// \image html TSpectrum_Deconvolution_wide1.jpg Fig. 12 Study of Gold deconvolution algorithm.The original source spectrum is drawn with black color, s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:3765,Efficient,Efficient,3765,hist/spectrum/src/TSpectrum.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx,1,['Efficient'],['Efficient']
Energy Efficiency,"- blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x); *; * green-scale =; * ( (red-y - blue-y) * (white-x - blue-x) -; * (red-x - blue-x) * (white-y - blue-y) ) / white-y; * -------------------------------------------------------------------------; * (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x); *; * Accuracy:; * The input values have 5 decimal digits of accuracy. The values are all in; * the range 0 < value < 1, so simple products are in the same range but may; * need up to 10 decimal digits to preserve the original precision and avoid; * underflow. Because we are using a 32-bit signed representation we cannot; * match this; the best is a little over 9 decimal digits, less than 10.; *; * The approach used here is to preserve the maximum precision within the; * signed representation. Because the red-scale calculation above uses the; * difference between two products of values that must be in the range -1..+1; * it is sufficient to divide the product by 7; ceil(100,000/32767*2). The; * factor is irrelevant in the calculation because it is applied to both; * numerator and denominator.; *; * Note that the values of the differences of the products of the; * chromaticities in the above equations tend to be small, for example for; * the sRGB chromaticities they are:; *; * red numerator: -0.04751; * green numerator: -0.08788; * denominator: -0.2241 (without white-y multiplication); *; * The resultant Y coefficients from the chromaticities of some widely used; * color space definitions are (to 15 decimal places):; *; * sRGB; * 0.212639005871510 0.715168678767756 0.072192315360734; * Kodak ProPhoto; * 0.288071128229293 0.711843217810102 0.000085653960605; * Adobe RGB; * 0.297344975250536 0.627363566255466 0.075291458493998; * Adobe Wide Gamut RGB; * 0.258728243040113 0.724682314948566 0.016589442011321; */; /* By the argument, above overflow should be impossible here. The return; * value of 2 indicates an internal error to the caller.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:6912,green,green,6912,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['green'],['green']
Energy Efficiency,"-*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that collect the Linker Optimization Hint (LOH).; // This pass should be run at the very end of the compilation flow, just before; // assembly printer.; // To be useful for the linker, the LOH must be printed into the assembly file.; //; // A LOH describes a sequence of instructions that may be optimized by the; // linker.; // This same sequence cannot be optimized by the compiler because some of; // the information will be known at link time.; // For instance, consider the following sequence:; // L1: adrp xA, sym@PAGE; // L2: add xB, xA, sym@PAGEOFF; // L3: ldr xC, [xB, #imm]; // This sequence can be turned into:; // A literal load if sym@PAGE + sym@PAGEOFF + #imm - address(L3) is < 1MB:; // L3: ldr xC, sym+#imm; // It may also be turned into either the following more efficient; // code sequences:; // - If sym@PAGEOFF + #imm fits the encoding space of L3.; // L1: adrp xA, sym@PAGE; // L3: ldr xC, [xB, sym@PAGEOFF + #imm]; // - If sym@PAGE + sym@PAGEOFF - address(L1) < 1MB:; // L1: adr xA, sym; // L3: ldr xC, [xB, #imm]; //; // To be valid a LOH must meet all the requirements needed by all the related; // possible linker transformations.; // For instance, using the running example, the constraints to emit; // "".loh AdrpAddLdr"" are:; // - L1, L2, and L3 instructions are of the expected type, i.e.,; // respectively ADRP, ADD (immediate), and LD.; // - The result of L1 is used only by L2.; // - The register argument (xA) used in the ADD instruction is defined; // only by L1.; // - The result of L2 is used only by L3.; // - The base address (xB) in L3 is defined only L2.; // - The ADRP in L1 and the ADD in L2 must reference the same s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp:1189,efficient,efficient,1189,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp,1,['efficient'],['efficient']
Energy Efficiency,"---- PPCVSXSwapRemoval.cpp - Remove VSX LE Swaps -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly. Such operat",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:995,reduce,reduce,995,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,1,['reduce'],['reduce']
Energy Efficiency,"--------------+-----------------++-+-------; // | parameter area for | variable-size | fixed-size |LR| arg; // | called functions | local objects | local objects |FP|; // --+----------------------+------------------+-----------------+--+-------; // <- size known -> <- size unknown -> <- size known ->; //; // Low address High address; //; // <--- stack growth; //; //; // - In any circumstances, the outgoing function arguments are always accessi-; // ble using the SP, and the incoming arguments are accessible using the FP.; // - If the local objects are not aligned, they can always be accessed using; // the FP.; // - If there are no variable-sized objects, the local objects can always be; // accessed using the SP, regardless whether they are aligned or not. (The; // alignment padding will be at the bottom of the stack (highest address),; // and so the offset with respect to the SP will be known at the compile-; // -time.); //; // The only complication occurs if there are both, local aligned objects, and; // dynamically allocated (variable-sized) objects. The alignment pad will be; // placed between the FP and the local objects, thus preventing the use of the; // FP to access the local objects. At the same time, the variable-sized objects; // will be between the SP and the local objects, thus introducing an unknown; // distance from the SP to the locals.; //; // To avoid this problem, a new register is created that holds the aligned; // address of the bottom of the stack, referred in the sources as AP (aligned; // pointer). The AP will be equal to ""FP-p"", where ""p"" is the smallest pad; // that aligns AP to the required boundary (a maximum of the alignments of; // all stack objects, fixed- and variable-sized). All local objects[1] will; // then use AP as the base pointer.; // [1] The exception is with ""fixed"" stack objects. ""Fixed"" stack objects get; // their name from being allocated at fixed locations on the stack, relative; // to the FP. In the presence of dynamic al",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:1292,allocate,allocated,1292,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to con",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:974,reduce,reduce,974,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['reduce'],['reduce']
Energy Efficiency,"--------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the VE implementation of TargetFrameLowering class.; //; // On VE, stack frames are structured as follows:; //; // The stack grows downward.; //; // All of the individual frame areas on the frame below are optional, i.e. it's; // possible to create a function so that the particular area isn't present; // in the frame.; //; // At function entry, the ""frame"" looks as follows:; //; // | | Higher address; // |----------------------------------------------|; // | Parameter area for this function |; // |----------------------------------------------|; // | Register save area (RSA) for this function |; // |----------------------------------------------|; // | Return address for this function |; // |----------------------------------------------|; // | Frame pointer for this function |; // |----------------------------------------------| <- sp; // | | Lower address; //; // VE doesn't use on demand stack allocation, so user code generated by LLVM; // needs to call VEOS to allocate stack frame. VE's ABI want to reduce the; // number of VEOS calls, so ABI requires to allocate not only RSA (in general; // CSR, callee saved register) area but also call frame at the prologue of; // caller function.; //; // After the prologue has run, the frame has the following general structure.; // Note that technically the last frame area (VLAs) doesn't get created until; // in the main function body, after the prologue is run. However, it's depicted; // here for completeness.; //; // | | Higher address; // |----------------------------------------------|; // | Parameter area for this function |; // |----------------------------------------------|; // | Regis",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:1380,allocate,allocate,1380,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"-Fourier-transform spectral enhancement techniques for gamma-ray; /// spectroscopy. NIM A353 (1994) 280-284.; ///; /// [2] Morhac M., Matouoek V.,; /// New adaptive Cosine-Walsh transform and its application to nuclear data; /// compression, IEEE Transactions on Signal Processing 48 (2000) 2693.; ///; /// [3] Morhac M., Matouoek V.,; /// Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal; /// Processing 8 (1998) 63.; ///; /// [4] Morhac M., Matouoek V.:; /// Multidimensional nuclear data compression using fast adaptive Walsh-Haar; /// transform. Acta Physica Slovaca 51 (2001) 307.; ///; /// ### Example 1 - script Transform2.c:; ///; /// \image html spectrum2transform_transform_image002.jpg Fig. 1 Original two-dimensional noisy spectrum; ///; /// \image html spectrum2transform_transform_image003.jpg Fig. 2 Transformed spectrum from Fig. 1 using Cosine transform. Energy of the transformed data is concentrated around the beginning of the coordinate system; ///; /// #### Script:; ///; /// Example to illustrate Transform function (class TSpectrumTransform2).; /// To execute this example, do; ///; /// `root > .x Transform2.C`; ///; /// ~~~ {.cpp}; /// void Transform2() {; /// Int_t i, j;; /// Int_t nbinsx = 256;; /// Int_t nbinsy = 256;; /// Int_t xmin = 0;; /// Int_t xmax = nbinsx;; /// Int_t ymin = 0;; /// Int_t ymax = nbinsy;; /// Double_t ** source = new Double_t *[nbinsx];; /// Double_t ** dest = new Double_t *[nbinsx];; /// for (i=0;i<nbinsx;i++); /// source[i]=newDouble_t[nbinsy];; /// for (i=0;i<nbinsx;i++); /// dest[i]=newDouble_t[nbinsy];; /// TH2F *trans = newTH2F(""trans"",""Background estimation"",nbinsx,xmin,xmax,nbinsy,ymin,ymax);; /// TFile *f = new TFile(""TSpectrum2.root"");; /// trans=(TH2F*)f->Get(""back3;1"");; /// TCanvas *Tr = new TCanvas(""Transform"",""Illustration of transform function"",10,10,1000,700);; /// for (i = 0; i < nbinsx; i++){; /// for (j = 0; j < nbinsy; j++){; /// source[i][j] = trans->GetBinContent(i + 1,j + 1);; /",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2Transform.cxx:2415,Energy,Energy,2415,hist/spectrum/src/TSpectrum2Transform.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2Transform.cxx,1,['Energy'],['Energy']
Energy Efficiency,"-K Heidelberg, Germany *; * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; * *; * Copyright (c) 2005: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * LAPP, Annecy, France *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; /*! \class TMVA::MethodCFMlpANN; \ingroup TMVA. Interface to Clermond-Ferrand artificial neural network. The CFMlpANN belong to the class of Multilayer Perceptrons (MLP), which are; feed-forward networks according to the following propagation schema:. \image html tmva_mlp.png Schema for artificial neural network. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of <i>k</i> hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.). As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. The learning method used by the CFMlpANN is only stochastic.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCFMlpANN.cxx:2384,power,power,2384,tmva/tmva/src/MethodCFMlpANN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCFMlpANN.cxx,1,['power'],['power']
Energy Efficiency,"-saved; // area to allow SVE stack objects (allocated directly below the callee-saves,; // if available) to be accessed directly from the framepointer.; // The SVE spill/fill instructions have VL-scaled addressing modes such; // as:; // ldr z8, [fp, #-7 mul vl]; // For SVE the size of the vector length (VL) is not known at compile-time, so; // '#-7 mul vl' is an offset that can only be evaluated at runtime. With this; // layout, we don't need to add an unscaled offset to the framepointer before; // accessing the SVE object in the frame.; //; // In some cases when a base pointer is not strictly needed, it is generated; // anyway when offsets from the frame pointer to access local variables become; // so large that the offset can't be encoded in the immediate fields of loads; // or stores.; //; // Outgoing function arguments must be at the bottom of the stack frame when; // calling another function. If we do not have variable-sized stack objects, we; // can allocate a ""reserved call frame"" area at the bottom of the local; // variable area, large enough for all outgoing calls. If we do have VLAs, then; // the stack pointer must be decremented and incremented around each call to; // make space for the arguments below the VLAs.; //; // FIXME: also explain the redzone concept.; //; // An example of the prologue:; //; // .globl __foo; // .align 2; // __foo:; // Ltmp0:; // .cfi_startproc; // .cfi_personality 155, ___gxx_personality_v0; // Leh_func_begin:; // .cfi_lsda 16, Lexception33; //; // stp xa,bx, [sp, -#offset]!; // ...; // stp x28, x27, [sp, #offset-32]; // stp fp, lr, [sp, #offset-16]; // add fp, sp, #offset - 16; // sub sp, sp, #1360; //; // The Stack:; // +-------------------------------------------+; // 10000 | ........ | ........ | ........ | ........ |; // 10004 | ........ | ........ | ........ | ........ |; // +-------------------------------------------+; // 10008 | ........ | ........ | ........ | ........ |; // 1000c | ........ | ........ | ........ | ....",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:4839,allocate,allocate,4839,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,".; /// delete event;; /// event = 0;; /// ~~~; /// These rules affect users of TTree::Branch(),; /// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); /// as well because those routines call this one.; ///; /// An example of a tree with branches with objects allocated; /// and owned by us:; /// ~~~ {.cpp}; /// TFile* f1 = new TFile(""myfile_original.root"");; /// TTree* t1 = (TTree*) f->Get(""MyTree"");; /// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; /// TTree* t2 = t1->Clone(0);; /// for (Int_t i = 0; i < 10; ++i) {; /// t1->GetEntry(i);; /// t2->Fill();; /// }; /// t2->Write(); /// delete f2;; /// f2 = 0;; /// delete f1;; /// f1 = 0;; /// ~~~; /// An example of a branch with an object allocated by us,; /// but owned by the caller:; /// ~~~ {.cpp}; /// TFile* f = new TFile(""myfile.root"", ""recreate"");; /// TTree* t = new TTree(""t"", ""A test tree.""); /// Event* event = 0;; /// TBranchElement* br = t->Branch(""event."", &event);; /// for (Int_t i = 0; i < 10; ++i) {; /// ... Fill event with meaningful data in some way.; /// t->Fill();; /// }; /// t->Write();; /// delete event;; /// event = 0;; /// delete f;; /// f = 0;; /// ~~~; /// Notice that the only difference between this example; /// and the following example is that the event pointer; /// is zero when the branch is created.; ///; /// An example of a branch with an object allocated and; /// owned by the caller:; /// ~~~ {.cpp}; /// TFile* f = new TFile(""myfile.root"", ""recreate"");; /// TTree* t = new TTree(""t"", ""A test tree.""); /// Event* event = new Event();; /// TBranchElement* br = t->Branch(""event."", &event);; /// for (Int_t i = 0; i < 10; ++i) {; /// ... Fill event with meaningful data in some way.; /// t->Fill();; /// }; /// t->Write();; /// delete event;; /// event = 0;; /// delete f;; /// f = 0;; /// ~~~; /// If AutoDelete is on (see TBranch::SetAutoDelete),; /// the top level objet will be deleted and recreate; /// each time an entry is read, whether or not the; /// TTree owns the object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:2873,allocate,allocated,2873,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['allocate'],['allocated']
Energy Efficiency,".; With x = (x,y,z) and gamma = 1/Sqrt(1-beta*beta) (beta being the module of vector b),; an arbitrary active Lorentz boost transformation (from the rod frame; to the original frame) can be written as:. ~~~ {.cpp}; x = x' + (gamma-1)/(beta*beta) * (b*x') * b + gamma * t' * b; t = gamma (t'+ b*x').; ~~~. The member function Boost() performs a boost transformation; from the rod frame to the original frame. BoostVector() returns; a TVector3 of the spatial components divided by the time component:. ~~~ {.cpp}; TVector3 b;; v.Boost(bx,by,bz);; v.Boost(b);; b = v.BoostVector(); // b=(x/t,y/t,z/t); ~~~. ### Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. #### rotation around axes. ~~~ {.cpp}; v.RotateX(TMath::Pi()/2.);; v.RotateY(.5);; v.RotateZ(.99);; ~~~. #### rotation around an arbitrary axis; v.Rotate(TMath::Pi()/4., v1); // rotation around v1. #### transformation from rotated frame. ~~~ {.cpp}; v.RotateUz(direction); // direction must be a unit TVector3; ~~~. #### by TRotation (see TRotation). ~~~ {.cpp}; TRotation r;; v.Transform(r); or v *= r; // Attention v=M*v; ~~~. ### Misc. #### Angle between two vectors. ~~~ {.cpp}; Double_t a = v1.Angle(v2.Vect()); // get angle between v1 and v2; ~~~. #### Light-cone components; Member functions Plus() and Minus() return the positive; and negative light-cone components:. ~~~ {.cpp}; Double_t pcone = v.Plus();; Double_t mcone = v.Minus();; ~~~. CAVEAT: The values returned are T{+,-}Z. It is known that some authors; find it easier to define these components as (T{+,-}Z)/sqrt(2). Thus; check what definition is used in the physics you're working in and adapt; your code accordingly. #### Transformation by TLorentzRotation; A general Lorentz transformation see class TLorentzRotation can; be used by the Transform() member function, the *= or; * operator of the TLorentzRotation class:. ~~~ {.cpp}; TLorentzRotation l;; v.Transform(l);; v = l*v; or v *= l; // Attention v = l*v; ~~~; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TLorentzVector.cxx:6859,adapt,adapt,6859,math/physics/src/TLorentzVector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TLorentzVector.cxx,1,['adapt'],['adapt']
Energy Efficiency,"/ This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the result must be zero anyway. We prefer here to do it in the width of; // the induction variable because it helps a lot for certain cases; CodeGen; // isn't smart enough to ignore the overflow, which leads to much less; // efficient code if the width of the subtraction is wider than the native; // register width.; //; // (It's possible to not widen at all by pulling out factors of 2 before; // the multiplication; for example, K=2 can be calculated as; // It/2*(It+(It*INT_MIN/INT_MIN)+-1). However, it requires; // extra arithmetic, so it's not an obvious win, and it gets; // much more complicated for K > 3.); // Protection from insane SCEVs; this bound is conservative,; // but it probably doesn't matter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2219,efficient,efficient,2219,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['efficient'],['efficient']
Energy Efficiency,/*			green = ( blue == 0 && red == 0 )?1:0 ; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.c:5,green,green,5,graf2d/asimage/src/libAfterImage/asvisual.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.c,1,['green'],['green']
Energy Efficiency,"/*		fprintf( stderr, ""src:"");; 		for( i = 0 ; i < im->width ; i++ ); 			fprintf( stderr, ""%2.2X%2.2X%2.2X "", buffer[0][i*3], buffer[0][i*3+1], buffer[0][i*3+2] );; 		fprintf( stderr, ""\ndst:"");; 		for( i = 0 ; i < im->width ; i++ ); 			fprintf( stderr, ""%2.2X%2.2X%2.2X "", buf.red[i], buf.green[i], buf.blue[i] );; 		fprintf( stderr, ""\n"");; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c:289,green,green,289,graf2d/asimage/src/libAfterImage/import.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c,1,['green'],['green']
Energy Efficiency,"/* ! HAVE_STRLCPY */; /* g_strlcpy; *; * Copy string src to buffer dest (of buffer size dest_size). At most; * dest_size-1 characters will be copied. Always NUL terminates; * (unless dest_size == 0). This function does NOT allocate memory.; * Unlike strncpy, this function doesn't pad dest (so it's often faster).; * Returns size of attempted result, strlen(src),; * so if retval >= dest_size, truncation occurred.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstrfuncs.c:223,allocate,allocate,223,graf2d/win32gdk/gdk/src/glib/gstrfuncs.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstrfuncs.c,1,['allocate'],['allocate']
Energy Efficiency,"/* ! HAVE_STRLCPY */; /**; * g_ascii_strdown:; * @str: a string; * @len: length of @str in bytes, or -1 if @str is nul-terminated.; * ; * Converts all upper case ASCII letters to lower case ASCII letters.; * ; * Return value: a newly allocated string, with all the upper case; * characters in @str converted to lower case, with; * semantics that exactly match g_ascii_tolower. (Note; * that this is unlike the old g_strdown, which modified; * the string in place.); **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstrfuncs.c:234,allocate,allocated,234,graf2d/win32gdk/gdk/src/glib/gstrfuncs.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstrfuncs.c,1,['allocate'],['allocated']
Energy Efficiency,"/* ""g_mem_chunk_new"" creates a new memory chunk.; * Memory chunks are used to allocate pieces of memory which are; * always the same size. Lists are a good example of such a data type.; * The memory chunk allocates and frees blocks of memory as needed.; * Just be sure to call ""g_mem_chunk_free"" and not ""g_free"" on data; * allocated in a mem chunk. (""g_free"" will most likely cause a seg; * fault...somewhere).; *; * Oh yeah, GMemChunk is an opaque data type. (You don't really; * want to know what's going on inside do you?); */; /* ALLOC_ONLY MemChunk's can only allocate memory. The free operation; * is interpreted as a no op. ALLOC_ONLY MemChunk's save 4 bytes per; * atom. (They are also useful for lists which use MemChunk to allocate; * memory but are also part of the MemChunk implementation).; * ALLOC_AND_FREE MemChunk's can allocate and free memory.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.h:78,allocate,allocate,78,graf2d/win32gdk/gdk/src/glib/gmem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.h,6,['allocate'],"['allocate', 'allocated', 'allocates']"
Energy Efficiency,"/* $TOG: imakemdep.h /main/101 1997/06/06 09:13:20 bill $ */; /*. Copyright (c) 1993, 1994 X Consortium. Permission is hereby granted, free of charge, to any person obtaining a copy; of this software and associated documentation files (the ""Software""), to deal; in the Software without restriction, including without limitation the rights; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; copies of the Software, and to permit persons to whom the Software is; furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in; all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN; AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Except as contained in this notice, the name of the X Consortium shall not be; used in advertising or otherwise to promote the sale, use or other dealings; in this Software without prior written authorization from the X Consortium. */; /* $XFree86: xc/config/imake/imakemdep.h,v 3.24.2.3 1997/07/27 02:41:05 dawes Exp $ */; /*; * This file contains machine-dependent constants for the imake utility.; * When porting imake, read each of the steps below and add in any necessary; * definitions. In general you should *not* edit ccimake.c or imake.c!; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/imakemdep.h:143,charge,charge,143,misc/rmkdepend/imakemdep.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/imakemdep.h,1,['charge'],['charge']
Energy Efficiency,"/* $XConsortium: cppsetup.c /main/17 1996/09/28 16:15:03 rws $ */; /*. Copyright (c) 1993, 1994 X Consortium. Permission is hereby granted, free of charge, to any person obtaining a copy; of this software and associated documentation files (the ""Software""), to deal; in the Software without restriction, including without limitation the rights; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; copies of the Software, and to permit persons to whom the Software is; furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in; all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN; AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Except as contained in this notice, the name of the X Consortium shall not be; used in advertising or otherwise to promote the sale, use or other dealings; in this Software without prior written authorization from the X Consortium. */; /* $XFree86: xc/config/makedepend/cppsetup.c,v 3.2 1996/12/30 13:57:53 dawes Exp $ */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/cppsetup.c:148,charge,charge,148,misc/rmkdepend/cppsetup.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/cppsetup.c,1,['charge'],['charge']
Energy Efficiency,"/* $XConsortium: def.h /main/30 1996/12/04 10:11:12 swick $ */; /* $XFree86: xc/config/makedepend/def.h,v 3.3 1997/01/12 10:38:17 dawes Exp $ */; /*. Copyright (c) 1993, 1994 X Consortium. Permission is hereby granted, free of charge, to any person obtaining a copy; of this software and associated documentation files (the ""Software""), to deal; in the Software without restriction, including without limitation the rights; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; copies of the Software, and to permit persons to whom the Software is; furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in; all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN; AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Except as contained in this notice, the name of the X Consortium shall not be; used in advertising or otherwise to promote the sale, use or other dealings; in this Software without prior written authorization from the X Consortium. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/def.h:227,charge,charge,227,misc/rmkdepend/def.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/def.h,1,['charge'],['charge']
Energy Efficiency,"/* $XConsortium: main.c /main/84 1996/12/04 10:11:23 swick $ */; /* $XFree86: xc/config/makedepend/main.c,v 3.11.2.1 1997/05/11 05:04:07 dawes Exp $ */; /*. Copyright (c) 1993, 1994 X Consortium. Permission is hereby granted, free of charge, to any person obtaining a copy; of this software and associated documentation files (the ""Software""), to deal; in the Software without restriction, including without limitation the rights; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; copies of the Software, and to permit persons to whom the Software is; furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in; all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN; AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Except as contained in this notice, the name of the X Consortium shall not be; used in advertising or otherwise to promote the sale, use or other dealings; in this Software without prior written authorization from the X Consortium. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/main.c:234,charge,charge,234,misc/rmkdepend/main.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/main.c,1,['charge'],['charge']
Energy Efficiency,"/* $XConsortium: parse.c /main/33 1996/12/04 10:11:28 swick $ */; /*. Copyright (c) 1993, 1994 X Consortium. Permission is hereby granted, free of charge, to any person obtaining a copy; of this software and associated documentation files (the ""Software""), to deal; in the Software without restriction, including without limitation the rights; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; copies of the Software, and to permit persons to whom the Software is; furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in; all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN; AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Except as contained in this notice, the name of the X Consortium shall not be; used in advertising or otherwise to promote the sale, use or other dealings; in this Software without prior written authorization from the X Consortium. */; /* $XFree86: xc/config/makedepend/parse.c,v 1.3 1997/01/12 10:39:45 dawes Exp $ */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/parse.c:147,charge,charge,147,misc/rmkdepend/parse.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/parse.c,1,['charge'],['charge']
Energy Efficiency,"/* $XConsortium: pr.c /main/20 1996/12/04 10:11:41 swick $ */; /*. Copyright (c) 1993, 1994 X Consortium. Permission is hereby granted, free of charge, to any person obtaining a copy; of this software and associated documentation files (the ""Software""), to deal; in the Software without restriction, including without limitation the rights; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; copies of the Software, and to permit persons to whom the Software is; furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in; all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN; AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Except as contained in this notice, the name of the X Consortium shall not be; used in advertising or otherwise to promote the sale, use or other dealings; in this Software without prior written authorization from the X Consortium. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/pr.c:144,charge,charge,144,misc/rmkdepend/pr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/pr.c,1,['charge'],['charge']
Energy Efficiency,"/* ***************************************************************; * Tuning parameters; *****************************************************************/; /*!; * COMPRESS_HEAPMODE :; * Select how default decompression function ZSTD_compress() allocates its context,; * on stack (0, default), or into heap (1).; * Note that functions with explicit context such as ZSTD_compressCCtx() are unaffected.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:245,allocate,allocates,245,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['allocate'],['allocates']
Energy Efficiency,"/* **************************************************************; * Tuning parameters; ****************************************************************/; /*!MEMORY_USAGE :; * Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.); * Increasing memory usage improves compression ratio; * Reduced memory usage can improve speed, due to cache effect; * Recommended max value is 14, for 16KB, which nicely fits into Intel x86 L1 cache */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:333,Reduce,Reduced,333,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['Reduce'],['Reduced']
Energy Efficiency,"/* ****************************; * INLINE mode; ******************************/; /*!; * XXH_INLINE_ALL (and XXH_PRIVATE_API); * Use these build macros to inline xxhash into the target unit.; * Inlining improves performance on small inputs, especially when the length is; * expressed as a compile-time constant:; *; * https://fastcompression.blogspot.com/2018/03/xxhash-for-small-keys-impressive-power.html; *; * It also keeps xxHash symbols private to the unit, so they are not exported.; *; * Usage:; * #define XXH_INLINE_ALL; * #include ""xxhash.h""; *; * Do not compile and link xxhash.o as a separate object, as it is not useful.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:395,power,power,395,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['power'],['power']
Energy Efficiency,/* ----- Allocate memory ----- */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/NdbMTReacDesc.cxx:9,Allocate,Allocate,9,test/periodic/NdbMTReacDesc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/NdbMTReacDesc.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,"/* 0 is red, 1 is green, 2 is blue, 3 is alpha */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/export.c:18,green,green,18,graf2d/asimage/src/libAfterImage/export.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/export.c,1,['green'],['green']
Energy Efficiency,/* 04/13/00 DM (CFITSIO): Add these lines for NT */; /* with PowerStationFortran and and Visual C++ */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h:61,Power,PowerStationFortran,61,montecarlo/eg/inc/cfortran.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h,1,['Power'],['PowerStationFortran']
Energy Efficiency,/* 1: always flush; reduces usage of internal buffers */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.h:20,reduce,reduces,20,builtins/lz4/lz4frame.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.h,1,['reduce'],['reduces']
Energy Efficiency,"/* 8-bit or 16-bit PNG with two channels - gray and alpha. A minimum; * of 65536 combinations. If, however, the alpha channel is to be; * removed there are only 256 possibilities if the background is gray.; * (Otherwise there is a subset of the 65536 possibilities defined by; * the triangle between black, white and the background color.); *; * Reduce 16-bit files to 8-bit and sRGB encode the result. No need to; * worry about tRNS matching - tRNS is ignored if there is an alpha; * channel.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:346,Reduce,Reduce,346,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['Reduce'],['Reduce']
Energy Efficiency,/* 8-bit sRGB gray values with an alpha channel; the alpha channel is; * to be removed by composing on a background: either the row if; * display->background is NULL or display->background->green if not.; * Unlike the code above ALPHA_OPTIMIZED has *not* been done.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:190,green,green,190,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['green'],['green']
Energy Efficiency,"/* === Experimental API === */; /* Symbols defined below must be considered tied to a specific library version. */; /*; * XXH3_generateSecret():; *; * Derive a high-entropy secret from any user-defined content, named customSeed.; * The generated secret can be used in combination with `*_withSecret()` functions.; * The `_withSecret()` variants are useful to provide a higher level of protection than 64-bit seed,; * as it becomes much more difficult for an external actor to guess how to impact the calculation logic.; *; * The function accepts as input a custom seed of any length and any content,; * and derives from it a high-entropy secret of length XXH3_SECRET_DEFAULT_SIZE; * into an already allocated buffer secretBuffer.; * The generated secret is _always_ XXH_SECRET_DEFAULT_SIZE bytes long.; *; * The generated secret can then be used with any `*_withSecret()` variant.; * Functions `XXH3_128bits_withSecret()`, `XXH3_64bits_withSecret()`,; * `XXH3_128bits_reset_withSecret()` and `XXH3_64bits_reset_withSecret()`; * are part of this list. They all accept a `secret` parameter; * which must be very long for implementation reasons (>= XXH3_SECRET_SIZE_MIN); * _and_ feature very high entropy (consist of random-looking bytes).; * These conditions can be a high bar to meet, so; * this function can be used to generate a secret of proper quality.; *; * customSeed can be anything. It can have any size, even small ones,; * and its content can be anything, even stupidly ""low entropy"" source such as a bunch of zeroes.; * The resulting `secret` will nonetheless provide all expected qualities.; *; * Supplying NULL as the customSeed copies the default secret into `secretBuffer`.; * When customSeedSize > 0, supplying NULL as customSeed is undefined behavior.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:699,allocate,allocated,699,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['allocate'],['allocated']
Energy Efficiency,"/* === XXH3 streaming === */; /*; * Malloc's a pointer that is always aligned to align.; *; * This must be freed with `XXH_alignedFree()`.; *; * malloc typically guarantees 16 byte alignment on 64-bit systems and 8 byte; * alignment on 32-bit. This isn't enough for the 32 byte aligned loads in AVX2; * or on 32-bit, the 16 byte aligned loads in SSE2 and NEON.; *; * This underalignment previously caused a rather obvious crash which went; * completely unnoticed due to XXH3_createState() not actually being tested.; * Credit to RedSpah for noticing this bug.; *; * The alignment is done manually: Functions like posix_memalign or _mm_malloc; * are avoided: To maintain portability, we would have to write a fallback; * like this anyways, and besides, testing for the existence of library; * functions without relying on external build tools is impossible.; *; * The method is simple: Overallocate, manually align, and store the offset; * to the original behind the returned pointer.; *; * Align must be a power of 2 and 8 <= align <= 128.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:1006,power,power,1006,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['power'],['power']
Energy Efficiency,"/* ========================== */; /* *** simple functions *** */; /* ========================== */; /** HUF_compress() :; * Compress content from buffer 'src', of size 'srcSize', into buffer 'dst'.; * 'dst' buffer must be already allocated.; * Compression runs faster if `dstCapacity` >= HUF_compressBound(srcSize).; * `srcSize` must be <= `HUF_BLOCKSIZE_MAX` == 128 KB.; * @return : size of compressed data (<= `dstCapacity`).; * Special values : if return == 0, srcData is not compressible => Nothing is stored within dst !!!; * if HUF_isError(return), compression failed (more details using HUF_getErrorName()); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/huf.h:230,allocate,allocated,230,builtins/zstd/common/huf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/huf.h,1,['allocate'],['allocated']
Energy Efficiency,"/* ============================ */; /** Block level API */; /* ============================ */; /*!; Block functions produce and decode raw zstd blocks, without frame metadata.; Frame metadata cost is typically ~12 bytes, which can be non-negligible for very small blocks (< 100 bytes).; But users will have to take in charge needed metadata to regenerate data, such as compressed and content sizes. A few rules to respect :; - Compressing and decompressing require a context structure; + Use ZSTD_createCCtx() and ZSTD_createDCtx(); - It is necessary to init context before starting; + compression : any ZSTD_compressBegin*() variant, including with dictionary; + decompression : any ZSTD_decompressBegin*() variant, including with dictionary; + copyCCtx() and copyDCtx() can be used too; - Block size is limited, it must be <= ZSTD_getBlockSize() <= ZSTD_BLOCKSIZE_MAX == 128 KB; + If input is larger than a block size, it's necessary to split input data into multiple blocks; + For inputs larger than a single block, consider using regular ZSTD_compress() instead.; Frame metadata is not that costly, and quickly becomes negligible as source size grows larger than a block.; - When a block is considered not compressible enough, ZSTD_compressBlock() result will be 0 (zero) !; ===> In which case, nothing is produced into `dst` !; + User __must__ test for such outcome and deal directly with uncompressed data; + A block cannot be declared incompressible if ZSTD_compressBlock() return value was != 0.; Doing so would mess up with statistics history, leading to potential data corruption.; + ZSTD_decompressBlock() _doesn't accept uncompressed data as input_ !!; + In case of multiple successive blocks, should some of them be uncompressed,; decoder must be informed of their existence in order to follow proper history.; Use ZSTD_insertBlock() for such a case.; */; /*===== Raw zstd block functions =====*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:319,charge,charge,319,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['charge'],['charge']
Energy Efficiency,"/* ==========================================; * Short keys; * ==========================================; * One of the shortcomings of XXH32 and XXH64 was that their performance was; * sub-optimal on short lengths. It used an iterative algorithm which strongly; * favored lengths that were a multiple of 4 or 8.; *; * Instead of iterating over individual inputs, we use a set of single shot; * functions which piece together a range of lengths and operate in constant time.; *; * Additionally, the number of multiplies has been significantly reduced. This; * reduces latency, especially when emulating 64-bit multiplies on 32-bit.; *; * Depending on the platform, this may or may not be faster than XXH32, but it; * is almost guaranteed to be faster than XXH64.; */; /*; * At very short lengths, there isn't enough input to fully hide secrets, or use; * the entire secret.; *; * There is also only a limited amount of mixing we can do before significantly; * impacting performance.; *; * Therefore, we use different sections of the secret and always mix two secret; * samples with an XOR. This should have no effect on performance on the; * seedless or withSeed variants because everything _should_ be constant folded; * by modern compilers.; *; * The XOR mixing hides individual parts of the secret and increases entropy.; *; * This adds an extra layer of strength for custom secrets.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:543,reduce,reduced,543,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,['reduce'],"['reduced', 'reduces']"
Energy Efficiency,"/* ===========================================================================; * Allocate the match buffer, initialize the various tables and save the; * location of the internal file attribute (ascii/binary) and method; * (DEFLATE/STORE).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZTrees.c:82,Allocate,Allocate,82,core/zip/src/ZTrees.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZTrees.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* ===========================================================================; * Allocate the per thread ZTree internal state object; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZTrees.c:82,Allocate,Allocate,82,core/zip/src/ZTrees.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZTrees.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/* ===========================================================================; Opens a gzip (.gz) file for reading or writing. The mode parameter; is as in fopen (""rb"" or ""wb""). The file is given either by file descriptor; or path name (if fd == -1).; gz_open returns NULL if the file could not be opened or if there was; insufficient memory to allocate the (de)compression state; errno; can be checked to distinguish the two cases (if errno is zero, the; zlib error is Z_MEM_ERROR).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/gzio.c:346,allocate,allocate,346,graf2d/asimage/src/libAfterImage/zlib/gzio.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/gzio.c,1,['allocate'],['allocate']
Energy Efficiency,/* ??? */; /* a CLUT for storing allocated pixel indices */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:33,allocate,allocated,33,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,1,['allocate'],['allocated']
Energy Efficiency,/* ??? reduce max_chain_length for binary files */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c:7,reduce,reduce,7,core/zip/src/ZDeflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c,1,['reduce'],['reduce']
Energy Efficiency,"/* @(#)root/auth:$Id$ */; /* Author: Martin Nicolay 22/11/1988 */; /******************************************************************************; Copyright (C) 2006 Martin Nicolay <m.nicolay@osm-gmbh.de>. This library is free software; you can redistribute it and/or; modify it under the terms of the GNU Lesser General Public; License as published by the Free Software Foundation; either; version 2.1 of the License, or (at your option) any later; version. This library is distributed in the hope that it will be useful,; but WITHOUT ANY WARRANTY; without even the implied warranty of; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public; License along with this library; if not, write to the Free; Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,; MA 02110-1301 USA; ******************************************************************************/; /*******************************************************************************; * *; * Simple RSA public key code. *; * Adaptation in library for ROOT by G. Ganis, July 2003 *; * (gerardo.ganis@cern.ch) *; * *; * Header used by internal rsa functions *; * *; *******************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/res/rsaaux.h:1116,Adapt,Adaptation,1116,net/auth/res/rsaaux.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/res/rsaaux.h,4,['Adapt'],['Adaptation']
Energy Efficiency,"/* @(#)root/auth:$Id$ */; /* Author: Martin Nicolay 22/11/1988 */; /******************************************************************************; Copyright (C) 2006 Martin Nicolay <m.nicolay@osm-gmbh.de>. This library is free software; you can redistribute it and/or; modify it under the terms of the GNU Lesser General Public; License as published by the Free Software Foundation; either; version 2.1 of the License, or (at your option) any later; version. This library is distributed in the hope that it will be useful,; but WITHOUT ANY WARRANTY; without even the implied warranty of; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public; License along with this library; if not, write to the Free; Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,; MA 02110-1301 USA; ******************************************************************************/; /*******************************************************************************; * *; * Simple RSA public key code. *; * Adaptation in library for ROOT by G. Ganis, July 2003 *; * (gerardo.ganis@cern.ch) *; * *; *******************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/rsaaux.cxx:1116,Adapt,Adaptation,1116,net/auth/src/rsaaux.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/rsaaux.cxx,3,['Adapt'],['Adaptation']
Energy Efficiency,"/* @(#)root/clib:$Id$ */; /* Author: */; /* Change the size of a block allocated by `mmalloc'.; Copyright 1990, 1991 Free Software Foundation; Written May 1989 by Mike Haertel. The GNU C Library is free software; you can redistribute it and/or; modify it under the terms of the GNU Library General Public License as; published by the Free Software Foundation; either version 2 of the; License, or (at your option) any later version. The GNU C Library is distributed in the hope that it will be useful,; but WITHOUT ANY WARRANTY; without even the implied warranty of; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; Library General Public License for more details. You should have received a copy of the GNU Library General Public; License along with the GNU C Library; see the file COPYING.LIB. If; not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,; Boston, MA 02111-1307, USA. The author may be reached (Email) at the address mike@ai.mit.edu,; or (US mail) as Mike Haertel c/o Free Software Foundation. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mrealloc.c:71,allocate,allocated,71,core/clib/src/mrealloc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mrealloc.c,1,['allocate'],['allocated']
Energy Efficiency,"/* @(#)root/clib:$Id$ */; /* Author: */; /* Free a block of memory allocated by `mmalloc'.; Copyright 1990, 1991, 1992 Free Software Foundation. Written May 1989 by Mike Haertel.; Heavily modified Mar 1992 by Fred Fish. (fnf@cygnus.com). The GNU C Library is free software; you can redistribute it and/or; modify it under the terms of the GNU Library General Public License as; published by the Free Software Foundation; either version 2 of the; License, or (at your option) any later version. The GNU C Library is distributed in the hope that it will be useful,; but WITHOUT ANY WARRANTY; without even the implied warranty of; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; Library General Public License for more details. You should have received a copy of the GNU Library General Public; License along with the GNU C Library; see the file COPYING.LIB. If; not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,; Boston, MA 02111-1307, USA. The author may be reached (Email) at the address mike@ai.mit.edu,; or (US mail) as Mike Haertel c/o Free Software Foundation. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mfree.c:67,allocate,allocated,67,core/clib/src/mfree.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mfree.c,1,['allocate'],['allocated']
Energy Efficiency,"/* @(#)root/zip:$Id$ */; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /* tailor.h -- Not copyrighted 1993 Mark Adler */; /* Define MSDOS for Turbo C and Power C */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Tailor.h:466,Power,Power,466,core/zip/src/Tailor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Tailor.h,1,['Power'],['Power']
Energy Efficiency,"/* A Windows Device Context (DC) is not equivalent to an X11; * GC. We can use a DC only in the window for which it was; * allocated, or (in the case of a memory DC) with the bitmap that; * has been selected into it. Thus, we have to release and; * reallocate a DC each time the GdkGC is used to paint into a new; * window or pixmap. We thus keep all the necessary values in the; * GdkGCWin32Data struct.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkprivate-win32.h:123,allocate,allocated,123,graf2d/win32gdk/gdk/src/gdk/win32/gdkprivate-win32.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkprivate-win32.h,1,['allocate'],['allocated']
Energy Efficiency,/* A longjmp because of a bug in the application storage allocator or a; * simple failure to allocate the png_struct.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:93,allocate,allocate,93,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['allocate'],['allocate']
Energy Efficiency,"/* A tight upper bound on number of bits required to hold an; N-digit decimal integer is N * 196 / 59. Allocate enough space; to hold the full significand, and an extra part required by; tcMultiplyPart. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:103,Allocate,Allocate,103,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"/* A tight upper bound on number of parts required to hold the value; pow(5, power) is. power * 815 / (351 * integerPartWidth) + 1. However, whilst the result may require only this many parts,; because we are multiplying two values to get it, the; multiplication may require an extra part with the excess part; being zero (consider the trivial case of 1 * 1, tcFullMultiply; requires two parts to hold the single-part result). So we add an; extra one to guarantee enough space whilst multiplying. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:77,power,power,77,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,2,['power'],['power']
Energy Efficiency,/* Accuracy can be reduced */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/fse_compress.c:19,reduce,reduced,19,builtins/zstd/compress/fse_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/fse_compress.c,1,['reduce'],['reduced']
Energy Efficiency,/* Adapt buffer sizes to frame header instructions */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c:3,Adapt,Adapt,3,builtins/zstd/decompress/zstd_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c,1,['Adapt'],['Adapt']
Energy Efficiency,/* Adapt scan script for use with reduced block size;; * assume that script has been validated before.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c:3,Adapt,Adapt,3,graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,2,"['Adapt', 'reduce']","['Adapt', 'reduced']"
Energy Efficiency,"/* Add a complete header string (key + value).; * This function is less efficient as compared to mg_response_header_add,; * and should only be used to convert complete HTTP/1.x header lines.; * Parameters:; * conn: Current connection handle.; * http1_headers: Header line(s) in the form ""name: value\r\n"".; * Return:; * >=0: no error, number of header lines added; * -1: parameter error; * -2: invalid connection type; * -3: invalid connection status; * -4: too many headers; * -5: out of memory; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h:72,efficient,efficient,72,net/http/civetweb/civetweb.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h,1,['efficient'],['efficient']
Energy Efficiency,"/* Adjust output image parameters as needed.; *; * This must be called after jpeg_copy_critical_parameters(); * and before jpeg_write_coefficients().; *; * The return value is the set of virtual coefficient arrays to be written; * (either the ones allocated by jtransform_request_workspace, or the; * original source data arrays). The caller will need to pass this value; * to jpeg_write_coefficients().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/transupp.c:248,allocate,allocated,248,graf2d/asimage/src/libAfterImage/libjpeg/transupp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/transupp.c,1,['allocate'],['allocated']
Energy Efficiency,/* All tables are allocated inside cctx->workspace by ZSTD_resetCCtx_internal() */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h:18,allocate,allocated,18,builtins/zstd/compress/zstd_compress_internal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h,1,['allocate'],['allocated']
Energy Efficiency,/* Allocate & initialize requested statistics areas */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,2,['Allocate'],['Allocate']
Energy Efficiency,"/* Allocate Floyd-Steinberg workspace if necessary.; * This isn't really needed until pass 2, but again it is FAR storage.; * Although we will cope with a later change in dither_mode,; * we do not promise to honor max_memory_to_use if dither_mode changes.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate Floyd-Steinberg workspace if we didn't already. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/* Allocate Floyd-Steinberg workspace now if requested.; * We do this now since it is FAR storage and may affect the memory; * manager's space calculations. If the user changes to FS dither; * mode in a later pass, we will allocate the space then, and will; * possibly overrun the max_memory_to_use setting.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,2,"['Allocate', 'allocate']","['Allocate', 'allocate']"
Energy Efficiency,"/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmalloc.h:3,Allocate,Allocate,3,core/clib/res/mmalloc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmalloc.h,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate SIZE bytes allocated to ALIGNMENT bytes. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmalloc.h:3,Allocate,Allocate,3,core/clib/res/mmalloc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmalloc.h,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,/* Allocate SIZE bytes of memory. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmalloc.h:3,Allocate,Allocate,3,core/clib/res/mmalloc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmalloc.h,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate SIZE bytes on a page boundary. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmalloc.h:3,Allocate,Allocate,3,core/clib/res/mmalloc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmalloc.h,1,['Allocate'],['Allocate']
Energy Efficiency,"/* Allocate a ""large"" object */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/* Allocate a ""small"" object */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate a 2-D coefficient-block array */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate a 2-D sample array */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate a full-image virtual array for each component */; /* Note we pad the bottom to a multiple of the iMCU height */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmainct.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jcmainct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmainct.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/* Allocate a full-image virtual array for each component, */; /* padded to a multiple of samp_factor DCT blocks in each direction. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/* Allocate a full-image virtual array for each component, */; /* padded to a multiple of samp_factor DCT blocks in each direction. */; /* Note we ask for a pre-zeroed array. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate a mutex for this connection to allow communication both; 	 * within the request handler and from elsewhere in the application; 	 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Allocate,Allocate,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate a spare row buffer */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmerge.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jdmerge.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmerge.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate a strip buffer for each component */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmainct.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jcmainct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmainct.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/* Allocate a thread local storage slot for the thread ""stack"" */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate a workspace if we haven't already done so. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,2,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate an array of NMEMB elements each SIZE bytes long.; The entire array is initialized to zeros. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mcalloc.c:3,Allocate,Allocate,3,core/clib/src/mcalloc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mcalloc.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/* Allocate and fill in the colormap. */; /* The colors are ordered in the map in standard row-major order, */; /* i.e. rightmost (highest-indexed) color changes most rapidly. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate and fill in the conversion tables. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccolor.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jccolor.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccolor.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate and fill in the error_limiter table */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate and fill in the sample_range_limit table */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate and free half-edges in pairs for efficiency.; * The *only* place that should use this fact is allocation/free.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/mesh.h:3,Allocate,Allocate,3,graf3d/eve7/glu/mesh.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/mesh.h,1,['Allocate'],['Allocate']
Energy Efficiency,"/* Allocate and initialize png_ptr struct for reading, and any other memory. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['Allocate'],['Allocate']
Energy Efficiency,"/* Allocate and initialize png_ptr struct for writing, and any other memory */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate and initialize the info structure */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate and pre-zero a multiplier table for each component */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jddctmgr.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jddctmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jddctmgr.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate and pre-zero space for dummy DCT blocks. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jctrans.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jctrans.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jctrans.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate and zero the statistics tables */; /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,2,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate comp_info array large enough for maximum component count.; * Array is made permanent in case application wants to compress; * multiple images at same param settings.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate connection handle */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/odbc/src/TODBCServer.cxx:3,Allocate,Allocate,3,sql/odbc/src/TODBCServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/odbc/src/TODBCServer.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate context and initialize reasonable general case defaults. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Allocate,Allocate,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate dst with enough space to compress the maximum sized sample */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/cover.c:3,Allocate,Allocate,3,builtins/zstd/dictBuilder/cover.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/cover.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate initial buffer */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate latch area if not already done */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate maximum headers */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h:3,Allocate,Allocate,3,net/http/civetweb/civetweb.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h,2,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate memory from the heap. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mmalloc.c:3,Allocate,Allocate,3,core/clib/src/mmalloc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mmalloc.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/* Allocate memory. For reasonable files, size should never exceed; * 64K. However, zlib may allocate more than 64K if you don't tell; * it not to. See zconf.h and png.h for more information. zlib does; * need to allocate exactly 64K, so whatever you call here must; * have the ability to do that.; *; * This piece of code can be compiled to validate max 64K allocations; * by setting MAXSEG_64K in zlib zconf.h *or* PNG_MAX_MALLOC_64K.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngtest.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libpng/pngtest.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngtest.c,3,"['Allocate', 'allocate']","['Allocate', 'allocate']"
Energy Efficiency,/* Allocate needed row buffers if they have not already been; * allocated.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,/* Allocate new block */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Allocate,Allocate,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate new buffer */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Allocate,Allocate,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/* Allocate space for hash table, dict, and freqs */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/cover.c:3,Allocate,Allocate,3,builtins/zstd/dictBuilder/cover.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/cover.c,2,['Allocate'],['Allocate']
Energy Efficiency,"/* Allocate space for script.; * We need to put it in the permanent pool in case the application performs; * multiple compressions without changing the settings. To avoid a memory; * leak if jpeg_simple_progression is called repeatedly for the same JPEG; * object, we try to re-use previously allocated space, and we allocate; * enough space to handle YCbCr even if initially asked for grayscale.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,3,"['Allocate', 'allocate']","['Allocate', 'allocate', 'allocated']"
Energy Efficiency,"/* Allocate space for the funny pointer lists.; * This is done only once, not once per pass.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate space for the thread handles */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:3,Allocate,Allocate,3,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate space if necessary */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/cover.c:3,Allocate,Allocate,3,builtins/zstd/dictBuilder/cover.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/cover.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate space to hold websocket payload */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Allocate,Allocate,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/* Allocate the actual buffer space (3 row groups) for this component.; * We make the buffer wide enough to allow the downsampler to edge-expand; * horizontally within the buffer, if it so chooses.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcprepct.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jcprepct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcprepct.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/* Allocate the color conversion buffer.; * We make the buffer wide enough to allow the downsampler to edge-expand; * horizontally within the buffer, if it so chooses.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcprepct.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jcprepct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcprepct.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate the context and zero initialize */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:3,Allocate,Allocate,3,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate the histogram/inverse colormap storage */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate the in-memory buffers and initialize backing store as needed. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate the in-memory buffers for any unrealized virtual arrays */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate the memory for an info_struct for the application. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate the output buffer --- it will be released when done with image */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate the workspace.; * ngroups is the number of row groups we need.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocate workspace for box list */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/* Allocate workspace if needed.; * Note that we allocate arrays padded out to the next iMCU boundary,; * so that transform routines need not worry about missing edge blocks.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/transupp.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/transupp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/transupp.c,2,"['Allocate', 'allocate']","['Allocate', 'allocate']"
Energy Efficiency,/* Allocate/initialize the memory for image information. REQUIRED. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c:3,Allocate,Allocate,3,graf2d/asimage/src/libAfterImage/import.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* Allocated multiplier tables: big enough for any supported variant */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jddctmgr.c:3,Allocate,Allocated,3,graf2d/asimage/src/libAfterImage/libjpeg/jddctmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jddctmgr.c,1,['Allocate'],['Allocated']
Energy Efficiency,/* Allocates descriptor for code conversion from encoding ‘fromcode’ to; encoding ‘tocode’ into preallocated memory. Returns an error indicator; (0 or -1 with errno set). */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/iconv.h:3,Allocate,Allocates,3,graf2d/win32gdk/gdk/src/iconv/iconv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/iconv.h,1,['Allocate'],['Allocates']
Energy Efficiency,/* Allocates descriptor for code conversion from encoding ‘fromcode’ to; encoding ‘tocode’. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/iconv.h:3,Allocate,Allocates,3,graf2d/win32gdk/gdk/src/iconv/iconv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/iconv.h,1,['Allocate'],['Allocates']
Energy Efficiency,"/* Allow machine dependent optimization for post-increment or pre-increment.; Based on testing to date,; Pre-increment preferred for:; - PowerPC G3 (Adler); - MIPS R5000 (Randers-Pehrson); Post-increment preferred for:; - none; No measurable difference:; - Pentium III (Anderson); - M68060 (Nikl); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inffast.c:137,Power,PowerPC,137,builtins/zlib/inffast.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inffast.c,2,['Power'],['PowerPC']
Energy Efficiency,"/* Alpha must be removed as the PNG data is processed when the; * background is a color because the G and A channels are; * independent and the vector addition (non-parallel vectors) is a; * 2-D problem.; *; * This can be reduced to the same algorithm as above by making a; * colormap containing gray levels (for the opaque grays), a; * background entry (for a transparent pixel) and a set of four six; * level color values, one set for each intermediate alpha value.; * See the comments in make_ga_colormap for how this works in the; * per-pixel processing.; *; * If the background is gray, however, we only need a 256 entry gray; * level color map. It is sufficient to make the entry generated; * for the background color be exactly the color specified.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:222,reduce,reduced,222,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['reduce'],['reduced']
Energy Efficiency,/* Already allocated: check the size */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c:11,allocate,allocated,11,graf2d/asimage/src/libAfterImage/libpng/pngerror.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c,1,['allocate'],['allocated']
Energy Efficiency,/* Also flag odither arrays not allocated */; /* Make sure my internal arrays won't overflow */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c:32,allocate,allocated,32,graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,1,['allocate'],['allocated']
Energy Efficiency,"/* Alternate initialize png_ptr structure, and allocate any memory needed */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c:47,allocate,allocate,47,graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,1,['allocate'],['allocate']
Energy Efficiency,"/* BITS_IN_JSAMPLE == 12 */; /* Representation of a DCT frequency coefficient.; * This should be a signed value of at least 16 bits; ""short"" is usually OK.; * Again, we allocate large arrays of these, but you can change to int; * if you have memory to burn and ""short"" is really slow.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h:169,allocate,allocate,169,graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h,1,['allocate'],['allocate']
Energy Efficiency,/* Block information table.; Allocated with malign/__mmalloc_free (not mmalloc/mfree). */; /* Table indexed by block number giving per-block information. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h:29,Allocate,Allocated,29,core/clib/res/mmprivate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h,1,['Allocate'],['Allocated']
Energy Efficiency,"/* Build the initializer for a C++20 module:; This is arranged to be run only once regardless of how many times the module; might be included transitively. This arranged by using a guard variable. If there are no initializers at all (and also no imported modules) we reduce; this to an empty function (since the Itanium ABI requires that this function; be available to a caller, which might be produced by a different; implementation). First we call any initializers for imported modules.; We then call initializers for the Global Module Fragment (if present); We then call initializers for the current module.; We then call initializers for the Private Module Fragment (if present); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:267,reduce,reduce,267,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,1,['reduce'],['reduce']
Energy Efficiency,/* Byte total of user-allocated chunks. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h:22,allocate,allocated,22,core/clib/res/mmprivate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h,1,['allocate'],['allocated']
Energy Efficiency,/* CRAYFortran PowerStationFortran */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h:15,Power,PowerStationFortran,15,montecarlo/eg/inc/cfortran.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h,1,['Power'],['PowerStationFortran']
Energy Efficiency,/* Call progress monitor hook if present */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcapistd.c:17,monitor,monitor,17,graf2d/asimage/src/libAfterImage/libjpeg/jcapistd.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcapistd.c,7,['monitor'],['monitor']
Energy Efficiency,"/* Called after civetweb has closed a connection. The per-context mutex is; 	 locked when this is invoked. 	Connection specific data:; 	If memory has been allocated for the connection specific user data; 	(mg_request_info->conn_data, mg_get_user_connection_data),; 	this is the last chance to free it.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h:155,allocate,allocated,155,net/http/civetweb/civetweb.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h,1,['allocate'],['allocated']
Energy Efficiency,"/* Changed in libpng-1.2.1 to allocate PNG_MAX_PALETTE_LENGTH instead; * of num_palette entries, in case of an invalid PNG file or incorrect; * call to png_set_PLTE() with too-large sample values.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngset.c:30,allocate,allocate,30,graf2d/asimage/src/libAfterImage/libpng/pngset.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngset.c,1,['allocate'],['allocate']
Energy Efficiency,/* Check for an exact match among previously allocated colors */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c:45,allocate,allocated,45,graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c,1,['allocate'],['allocated']
Energy Efficiency,/* Chunks allocated by the user. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h:10,allocate,allocated,10,core/clib/res/mmprivate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h,1,['allocate'],['allocated']
Energy Efficiency,/* Color Context modes.; *; * GDK_CC_MODE_UNDEFINED - unknown; * GDK_CC_MODE_BW	 - default B/W; * GDK_CC_MODE_STD_CMAP	 - has a standard colormap; * GDK_CC_MODE_TRUE	 - is a TrueColor/DirectColor visual; * GDK_CC_MODE_MY_GRAY	 - my grayramp; * GDK_CC_MODE_PALETTE	 - has a pre-allocated palette; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkcc.h:277,allocate,allocated,277,graf2d/win32gdk/gdk/src/gdk/gdkcc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkcc.h,1,['allocate'],['allocated']
Energy Efficiency,"/* Colorspace support; structures used in png_struct, png_info and in internal; * functions to hold and communicate information about the color space.; *; * PNG_COLORSPACE_SUPPORTED is only required if the application will perform; * colorspace corrections, otherwise all the colorspace information can be; * skipped and the size of libpng can be reduced (significantly) by compiling; * out the colorspace support.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h:347,reduce,reduced,347,graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,1,['reduce'],['reduced']
Energy Efficiency,/* Computing 2nd power */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/mnteigen.cxx:17,power,power,17,math/minuit2/src/mnteigen.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/mnteigen.cxx,3,['power'],['power']
Energy Efficiency,/* Concatenate dir and base into freshly allocated file_name. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/localcharset.c:41,allocate,allocated,41,graf2d/win32gdk/gdk/src/iconv/localcharset.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/localcharset.c,1,['allocate'],['allocated']
Energy Efficiency,/* Connection structure has been pre-allocated */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:37,allocate,allocated,37,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['allocate'],['allocated']
Energy Efficiency,"/* Constants for known chunk types.; *; * MAINTAINERS: If you need to add a chunk, define the name here.; * For historical reasons these constants have the form png_<name>; i.e.; * the prefix is lower case. Please use decimal values as the parameters to; * match the ISO PNG specification and to avoid relying on the C locale; * interpretation of character values. Please keep the list sorted.; *; * Notice that PNG_U32 is used to define a 32-bit value for the 4 byte chunk; * type. In fact the specification does not express chunk types this way,; * however using a 32-bit value means that the chunk type can be read from the; * stream using exactly the same code as used for a 32-bit unsigned value and; * can be examined far more efficiently (using one arithmetic compare).; *; * Prior to 1.5.6 the chunk type constants were expressed as C strings. The; * libpng API still uses strings for 'unknown' chunks and a macro,; * PNG_STRING_FROM_CHUNK, allows a string to be generated if required. Notice; * that for portable code numeric values must still be used; the string ""IHDR""; * is not portable and neither is PNG_U32('I', 'H', 'D', 'R').; *; * In 1.7.0 the definitions will be made public in png.h to avoid having to; * duplicate the same definitions in application code.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:733,efficient,efficiently,733,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['efficient'],['efficiently']
Energy Efficiency,"/* Convert a positive real constant to an integer scaled by CONST_SCALE.; * Caution: some C compilers fail to reduce ""FIX(constant)"" at compile time,; * thus causing a lot of useless floating-point operations at run time.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdct.h:110,reduce,reduce,110,graf2d/asimage/src/libAfterImage/libjpeg/jdct.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdct.h,1,['reduce'],['reduce']
Energy Efficiency,"/* Convert from meters * 1,000,000 to inches * 100,000, meters to; * inches is simply *(100/2.54), so we want *(10/2.54) == 500/127.; * Notice that this can overflow - a warning is output and 0 is; * returned.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngget.c:16,meter,meters,16,graf2d/asimage/src/libAfterImage/libpng/pngget.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngget.c,2,['meter'],['meters']
Energy Efficiency,"/* Convert to binary efficiently - we do almost all multiplication; in an integerPart. When this would overflow do we do a single; bignum multiplication, and then revert again to multiplication; in an integerPart. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:21,efficient,efficiently,21,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['efficient'],['efficiently']
Energy Efficiency,/* Copy rest of data;; * note we stay in given chunk of allocated memory.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c:56,allocate,allocated,56,graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,1,['allocate'],['allocated']
Energy Efficiency,"/* Copy the control structure so that the original, allocated, version can be; * safely freed. Notice that a png_error here stops the remainder of the; * cleanup, but this is probably fine because that would indicate bad memory; * problems anyway.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:52,allocate,allocated,52,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['allocate'],['allocated']
Energy Efficiency,/* Copy the source's per-component info.; * Note we assume jpeg_set_defaults has allocated the dest comp_info array.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jctrans.c:81,allocate,allocated,81,graf2d/asimage/src/libAfterImage/libjpeg/jctrans.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jctrans.c,1,['allocate'],['allocated']
Energy Efficiency,"/* Copyright (c) 2013-2021 the Civetweb developers; * Copyright (c) 2004-2013 Sergey Lyubka; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h:136,charge,charge,136,net/http/civetweb/civetweb.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h,1,['charge'],['charge']
Energy Efficiency,/* Count the number of elements in an array. The array must be defined; * as such; using this with a dynamically allocated array will give; * incorrect results.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmacros.h:113,allocate,allocated,113,graf2d/win32gdk/gdk/src/glib/gmacros.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmacros.h,1,['allocate'],['allocated']
Energy Efficiency,"/* Create an error message in allocated memory and set state->err and; state->msg accordingly. Free any previous error message already there. Do; not try to free or allocate space if the error is Z_MEM_ERROR (out of; memory). Simply save the error message as a static string. If there is an; allocation failure constructing the error message, then convert the error to; out of memory. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzlib.c:30,allocate,allocated,30,builtins/zlib/gzlib.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzlib.c,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"/* Create the funny pointer lists discussed in the comments above.; * The actual workspace is already allocated (in mainptr->buffer),; * and the space for the pointer lists is allocated too.; * This routine just fills in the curiously ordered lists.; * This will be repeated at the beginning of each pass.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c:102,allocate,allocated,102,graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c,2,['allocate'],['allocated']
Energy Efficiency,/* Current PowerPC will ignores the hint parameters. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:11,Power,PowerPC,11,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,1,['Power'],['PowerPC']
Energy Efficiency,/* D65 XYZ (*not* the D50 adapted values!) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:26,adapt,adapted,26,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['adapt'],['adapted']
Energy Efficiency,"/* Declarations for Floyd-Steinberg dithering.; *; * Errors are accumulated into the array fserrors[], at a resolution of; * 1/16th of a pixel count. The error at a given pixel is propagated; * to its not-yet-processed neighbors using the standard F-S fractions,; *		...	(here)	7/16; *		3/16	5/16	1/16; * We work left-to-right on even rows, right-to-left on odd rows.; *; * We can get away with a single array (holding one row's worth of errors); * by using it to store the current row's errors at pixel columns not yet; * processed, but the next row's errors at columns already processed. We; * need only a few extra variables to hold the errors immediately around the; * current column. (If we are lucky, those variables are in registers, but; * even if not, they're probably cheaper to access than array elements are.); *; * The fserrors[] array is indexed [component#][position].; * We provide (#columns + 2) entries per component; the extra entry at each; * end saves us from special-casing the first and last pixels.; *; * Note: on a wide image, we might not have enough room in a PC's near data; * segment to hold the error array; so it is allocated with alloc_large.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c:1147,allocate,allocated,1147,graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,1,['allocate'],['allocated']
Energy Efficiency,/* Decompose power bitwise. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:13,power,power,13,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['power'],['power']
Energy Efficiency,"/* Define as a marker that can be attached to function parameter declarations; for parameters that are not used. This helps to reduce warnings, such as; from GCC -Wunused-parameter. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/config.h:127,reduce,reduce,127,graf2d/win32gdk/gdk/src/iconv/config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/config.h,1,['reduce'],['reduce']
Energy Efficiency,"/* Determine the current locale's character encoding, and canonicalize it; into one of the canonical names listed in config.charset.; The result must not be freed; it is statically allocated.; If the canonical name cannot be determined, the result is a non-canonical; name. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/localcharset.c:181,allocate,allocated,181,graf2d/win32gdk/gdk/src/iconv/localcharset.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/localcharset.c,2,['allocate'],['allocated']
Energy Efficiency,"/* Determine where data comes from in input_buf and do the DCT thing.; * Each call on forward_DCT processes a horizontal row of DCT blocks; * as wide as an MCU; we rely on having allocated the MCU_buffer[] blocks; * sequentially. Dummy blocks at the right or bottom edge are filled in; * specially. The data in them does not matter for image reconstruction,; * so we fill them with values that will encode to the smallest amount of; * data, viz: all zeroes in the AC entries, DC entries equal to previous; * block's DC value. (Thanks to Thomas Kinsman for this idea.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c:179,allocate,allocated,179,graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c,1,['allocate'],['allocated']
Energy Efficiency,/* Determine where data should go in output_buf and do the IDCT thing.; * We skip dummy blocks at the right and bottom edges (but blkn gets; * incremented past them!). Note the inner loop relies on having; * allocated the MCU_buffer[] blocks sequentially.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c:208,allocate,allocated,208,graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c,1,['allocate'],['allocated']
Energy Efficiency,/* Determine which area this piece of memory is allocated from */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c:48,allocate,allocated,48,graf2d/win32gdk/gdk/src/glib/gmem.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c,1,['allocate'],['allocated']
Energy Efficiency,/* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 		 * to effectively fill up the underlying IP packet payload and; 		 * reduce the overhead of sending lots of small buffers. However; 		 * this hurts the server's throughput (ie. operations per second); 		 * when HTTP 1.1 persistent connections are used and the responses; 		 * are relatively small (eg. less than 1400 bytes).; 		 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:141,reduce,reduce,141,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['reduce'],['reduce']
Energy Efficiency,/* Do nothing; fflush() is said to be just a waste of energy. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngtest.c:54,energy,energy,54,graf2d/asimage/src/libAfterImage/libpng/pngtest.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngtest.c,1,['energy'],['energy']
Energy Efficiency,"/* Do the expansion now, after all the arithmetic has been done. Notice; * that previous transformations can handle the PNG_EXPAND_16 flag if this; * is efficient (particularly true in the case of gamma correction, where; * better accuracy results faster!); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:153,efficient,efficient,153,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['efficient'],['efficient']
Energy Efficiency,/* Example of using row callbacks to make a simple progress meter */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngtest.c:60,meter,meter,60,graf2d/asimage/src/libAfterImage/libpng/pngtest.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngtest.c,1,['meter'],['meter']
Energy Efficiency,/* Expand input data enough to let all the output samples be generated; * by the standard loop. Special-casing padded output would be more; * efficient.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcsample.c:142,efficient,efficient,142,graf2d/asimage/src/libAfterImage/libjpeg/jcsample.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcsample.c,5,['efficient'],['efficient']
Energy Efficiency,/* FIXME: Update when P8 InstrScheduling model is ready */; // FIXME: Update when POWER9 scheduling model is ready.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:89,schedul,scheduling,89,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/* FSE_compress_wksp() :; * Same as FSE_compress2(), but using an externally allocated scratch buffer (`workSpace`).; * `wkspSize` size must be `(1<<tableLog)`.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/fse_compress.c:77,allocate,allocated,77,builtins/zstd/compress/fse_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/fse_compress.c,1,['allocate'],['allocated']
Energy Efficiency,"/* Find the polygon normal. It is important to get a reasonable; * normal even when the polygon is self-intersecting (eg. a bowtie).; * Otherwise, the computed normal could be very tiny, but perpendicular; * to the true plane of the polygon due to numerical noise. Then all; * the triangles would appear to be degenerate and we would incorrectly; * decompose the polygon as a fan (or simply not render it at all).; *; * We use a sum-of-triangles normal algorithm rather than the more; * efficient sum-of-trapezoids method (used in CheckOrientation(); * in normal.c). This lets us explicitly reverse the signed area; * of some triangles to get a reasonable normal in the self-intersecting; * case.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/render.c:487,efficient,efficient,487,graf3d/eve7/glu/render.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/render.c,1,['efficient'],['efficient']
Energy Efficiency,"/* Finish reading the image into the supplied buffer and clean up the; * png_image structure.; *; * row_stride is the step, in byte or 2-byte units as appropriate,; * between adjacent rows. A positive stride indicates that the top-most row; * is first in the buffer - the normal top-down arrangement. A negative; * stride indicates that the bottom-most row is first in the buffer.; *; * background need only be supplied if an alpha channel must be removed from; * a png_byte format and the removal is to be done by compositing on a solid; * color; otherwise it may be NULL and any composition will be done directly; * onto the buffer. The value is an sRGB color to use for the background,; * for grayscale output the green channel is used.; *; * background must be supplied when an alpha channel must be removed from a; * single byte color-mapped output format, in other words if:; *; * 1) The original format from png_image_begin_read_from_* had; * PNG_FORMAT_FLAG_ALPHA set.; * 2) The format set by the application does not.; * 3) The format set by the application has PNG_FORMAT_FLAG_COLORMAP set and; * PNG_FORMAT_FLAG_LINEAR *not* set.; *; * For linear output removing the alpha channel is always done by compositing; * on black and background is ignored.; *; * colormap must be supplied when PNG_FORMAT_FLAG_COLORMAP is set. It must; * be at least the size (in bytes) returned by PNG_IMAGE_COLORMAP_SIZE.; * image->colormap_entries will be updated to the actual number of entries; * written to the colormap; this may be less than the original value.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:717,green,green,717,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['green'],['green']
Energy Efficiency,/* First allocate all pixels */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:9,allocate,allocate,9,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,2,['allocate'],['allocate']
Energy Efficiency,"/* First lay down the symbols in order.; * We use a uint64_t to lay down 8 bytes at a time. This reduces branch; * misses since small blocks generally have small table logs, so nearly; * all symbols have counts <= 8. We ensure we have 8 bytes at the end of; * our buffer to handle the over-write.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse_decompress.c:97,reduce,reduces,97,builtins/zstd/common/fse_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse_decompress.c,2,['reduce'],['reduces']
Energy Efficiency,/* Flag FS workspace not allocated */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c:25,allocate,allocated,25,graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,1,['allocate'],['allocated']
Energy Efficiency,"/* For each dimension, we need to calculate powers of an; * appropriate irreducible polynomial, see Niederreiter; * page 65, just below equation (19).; * Copy the appropriate irreducible polynomial into PX,; * and its degree into E. Set polynomial B = PX ** 0 = 1.; * M is the degree of B. Subsequently B will hold higher; * powers of PX.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooQuasiRandomGenerator.cxx:44,power,powers,44,roofit/roofitcore/src/RooQuasiRandomGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooQuasiRandomGenerator.cxx,2,['power'],['powers']
Energy Efficiency,/* For non-interlaced images this reduces to a memcpy(). A memcpy(); * will also happen if interlacing isn't supported or if the application; * does not call png_set_interlace_handling(). In the latter cases the; * caller just gets a sequence of the unexpanded rows from each interlace; * pass.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:34,reduce,reduces,34,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['reduce'],['reduces']
Energy Efficiency,"/* For pseudo-color and grayscale visuals, we have to remember; * the colors we allocated, so we can free them later.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkpixmap-win32.c:80,allocate,allocated,80,graf2d/win32gdk/gdk/src/gdk/win32/gdkpixmap-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkpixmap-win32.c,1,['allocate'],['allocated']
Energy Efficiency,"/* Force C2FLOGICAL to generate only the values for either .TRUE. or .FALSE.; SX/PowerStationFortran only have 0 and 1 defined.; Elsewhere, only needed if you want to do:; logical lvariable; if (lvariable .eq. .true.) then ! (1); instead of; if (lvariable .eqv. .true.) then ! (2); - (1) may not even be FORTRAN/77 and that Apollo's f77 and IBM's xlf; refuse to compile (1), so you are probably well advised to stay away from; (1) and from LOGICAL_STRICT.; - You pay a (slight) performance penalty for using LOGICAL_STRICT. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h:81,Power,PowerStationFortran,81,montecarlo/eg/inc/cfortran.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h,1,['Power'],['PowerStationFortran']
Energy Efficiency,"/* Free a block allocated by `mmalloc', `mrealloc' or `mcalloc'. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmalloc.h:16,allocate,allocated,16,core/clib/res/mmalloc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmalloc.h,1,['allocate'],['allocated']
Energy Efficiency,/* Free allocated memory */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c:8,allocate,allocated,8,graf3d/x3d/src/x3d.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c,1,['allocate'],['allocated']
Energy Efficiency,/* Free an allocated jmp_buf (always succeeds) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:11,allocate,allocated,11,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['allocate'],['allocated']
Energy Efficiency,/* Free any PLTE entry that was internally allocated */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:43,allocate,allocated,43,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['allocate'],['allocated']
Energy Efficiency,"/* Free any data allocated by libpng in image->opaque, setting the pointer to; * NULL. May be called at any time after the structure is initialized.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:17,allocate,allocated,17,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['allocate'],['allocated']
Energy Efficiency,/* Free data that was allocated internally */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:22,allocate,allocated,22,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['allocate'],['allocated']
Energy Efficiency,/* Frees a pointer allocated by png_malloc() */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:19,allocate,allocated,19,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['allocate'],['allocated']
Energy Efficiency,/* Frees resources allocated for conversion descriptor ‘cd’. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/iconv.h:19,allocate,allocated,19,graf2d/win32gdk/gdk/src/iconv/iconv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/iconv.h,1,['allocate'],['allocated']
Energy Efficiency,"/* From libpng 1.6.0 the app gets one chance to set a 'jmpbuf_size' value; * and it must not change after that. Libpng doesn't care how big the; * buffer is, just that it doesn't change.; *; * If the buffer size is no *larger* than the size of jmp_buf when libpng is; * compiled a built in jmp_buf is returned; this preserves the pre-1.6.0; * semantics that this call will not fail. If the size is larger, however,; * the buffer is allocated and this may fail, causing the function to return; * NULL.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c:432,allocate,allocated,432,graf2d/asimage/src/libAfterImage/libpng/pngerror.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c,1,['allocate'],['allocated']
Energy Efficiency,"/* Function templates */; /* FSE_buildCTable_wksp() :; * Same as FSE_buildCTable(), but using an externally allocated scratch buffer (`workSpace`).; * wkspSize should be sized to handle worst case situation, which is `1<<max_tableLog * sizeof(FSE_FUNCTION_TYPE)`; * workSpace must also be properly aligned with FSE_FUNCTION_TYPE requirements; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/fse_compress.c:108,allocate,allocated,108,builtins/zstd/compress/fse_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/fse_compress.c,1,['allocate'],['allocated']
Energy Efficiency,/* Function to allocate memory for zlib */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:15,allocate,allocate,15,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['allocate'],['allocate']
Energy Efficiency,/* Function to allocate memory for zlib. PNGAPI is disallowed. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:15,allocate,allocate,15,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['allocate'],['allocate']
Energy Efficiency,"/* GCC-compatible compiler, targeting PowerPC with SPE */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/adler32_cf.c:38,Power,PowerPC,38,builtins/zlib/adler32_cf.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/adler32_cf.c,2,['Power'],['PowerPC']
Energy Efficiency,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /* Originally developed and coded by Makoto Matsumoto and Takuji; * Nishimura. Please mail <matumoto@math.keio.ac.jp>, if you're using; * code from this file in your own programs or libraries.; * Further information on the Mersenne Twister can be found at; * http://www.math.keio.ac.jp/~matumoto/emt.html; * This code was adapted to glib by Sebastian Wilhelmi <wilhelmi@ira.uka.de>.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /* ; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/grand.c:1198,adapt,adapted,1198,graf2d/win32gdk/gdk/src/glib/grand.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/grand.c,1,['adapt'],['adapted']
Energy Efficiency,"/* GStaticMutexes can be statically initialized with the value; * G_STATIC_MUTEX_INIT, and then they can directly be used, that is; * much easier, than having to explicitly allocate the mutex before; * use; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthread.h:173,allocate,allocate,173,graf2d/win32gdk/gdk/src/glib/gthread.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthread.h,1,['allocate'],['allocate']
Energy Efficiency,/* G_DISABLE_DEPRECATED */; /* String utility functions that return a newly allocated string which; * ought to be freed with g_free from the caller at some point.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstrfuncs.h:76,allocate,allocated,76,graf2d/win32gdk/gdk/src/glib/gstrfuncs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstrfuncs.h,1,['allocate'],['allocated']
Energy Efficiency,/* G_DISABLE_DEPRECATED */; /* The returned strings are newly allocated with g_malloc() */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutils.h:62,allocate,allocated,62,graf2d/win32gdk/gdk/src/glib/gutils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutils.h,1,['allocate'],['allocated']
Energy Efficiency,"/* Get connection information. Useful for server diagnosis.; Parameters:; ctx: Context handle; idx: Connection index; buffer: Store context information here.; buflen: Length of buffer (including a byte required for a terminating 0).; Return:; Available size of system information, exluding a terminating 0.; The information is complete, if the return value is smaller than buflen.; The result is a JSON formatted string, the exact content may vary.; Note:; It is possible to determine the required buflen, by first calling this; function with buffer = NULL and buflen = NULL. The required buflen is; one byte more than the returned value. However, since the available; context information changes, you should allocate a few bytes more.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h:709,allocate,allocate,709,net/http/civetweb/civetweb.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h,1,['allocate'],['allocate']
Energy Efficiency,"/* Get context information. Useful for server diagnosis.; Parameters:; ctx: Context handle; buffer: Store context information here.; buflen: Length of buffer (including a byte required for a terminating 0).; Return:; Available size of system information, exluding a terminating 0.; The information is complete, if the return value is smaller than buflen.; The result is a JSON formatted string, the exact content may vary.; Note:; It is possible to determine the required buflen, by first calling this; function with buffer = NULL and buflen = NULL. The required buflen is; one byte more than the returned value. However, since the available; context information changes, you should allocate a few bytes more.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h:683,allocate,allocate,683,net/http/civetweb/civetweb.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h,1,['allocate'],['allocate']
Energy Efficiency,"/* Get the list of ports that civetweb is listening on.; The parameter size is the size of the ports array in elements.; The caller is responsibility to allocate the required memory.; This function returns the number of struct mg_server_port elements; filled in, or <0 in case of an error. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h:153,allocate,allocate,153,net/http/civetweb/civetweb.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h,1,['allocate'],['allocate']
Energy Efficiency,/* Green */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:3,Green,Green,3,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,1,['Green'],['Green']
Energy Efficiency,/* HARDWARE: PowerPC VSX SIMD instructions supported */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:13,Power,PowerPC,13,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['Power'],['PowerPC']
Energy Efficiency,/* HASH_SIZE and WSIZE must be powers of two */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c:31,power,powers,31,core/zip/src/ZDeflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c,1,['power'],['powers']
Energy Efficiency,"/* Half-edges are allocated in pairs (see mesh.c) */; //typedef struct { GLUhalfEdge e, eSym; } EdgePair;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/tess.c:18,allocate,allocated,18,graf3d/eve7/glu/tess.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/tess.c,1,['allocate'],['allocated']
Energy Efficiency,"/* Half-edges are allocated in pairs, see EdgePair above */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/mesh.c:18,allocate,allocated,18,graf3d/eve7/glu/mesh.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/mesh.c,1,['allocate'],['allocated']
Energy Efficiency,"/* If U = 0, we need to set B to the next power of PX; * and recalculate V.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooQuasiRandomGenerator.cxx:42,power,power,42,roofit/roofitcore/src/RooQuasiRandomGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooQuasiRandomGenerator.cxx,1,['power'],['power']
Energy Efficiency,"/* If a DC is allocated, for which window; * or what bitmap is selected into it; */; // bb add",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkprivate-win32.h:14,allocate,allocated,14,graf2d/win32gdk/gdk/src/gdk/win32/gdkprivate-win32.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkprivate-win32.h,1,['allocate'],['allocated']
Energy Efficiency,"/* If correct type is being requested, allocate an; * instance of TestType and return the IUnknown interface.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootsl/main.c:39,allocate,allocate,39,misc/rootsl/main.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootsl/main.c,1,['allocate'],['allocate']
Energy Efficiency,"/* If correct type is being requested, allocate an; * instance of kQLGeneratorTypeID and return the IUnknown interface.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/main.c:39,allocate,allocate,39,misc/rootql/main.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/main.c,1,['allocate'],['allocate']
Energy Efficiency,"/* If jpeg_start_decompress will read the whole file, initialize; * progress monitoring appropriately. The input step is counted; * as one pass.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c:77,monitor,monitoring,77,graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c,1,['monitor'],['monitoring']
Energy Efficiency,"/* If that failed, we try to allocate a new color, or approxmiate; * with what we can get if best_match is TRUE.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c:29,allocate,allocate,29,graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c,1,['allocate'],['allocate']
Energy Efficiency,"/* If the area has been marked, then it is being destroyed.; * (ie marked to be destroyed).; * We check to see if all of the segments on the free list that; * reference this area have been removed. This occurs when; * the ammount of free memory is less than the allocatable size.; * If the chunk should be freed, then we place it in the ""free_mem_area"".; * This is so we make sure not to free the mem area here and then; * allocate it again a few lines down.; * If we don't allocate a chunk a few lines down then the ""free_mem_area""; * will be freed.; * If there is already a ""free_mem_area"" then we'll just free this mem area.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c:423,allocate,allocate,423,graf2d/win32gdk/gdk/src/glib/gmem.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c,2,['allocate'],['allocate']
Energy Efficiency,"/* If there isn't a current mem area or the current mem area is out of space; * then allocate a new mem area. We'll first check and see if we can use; * the ""free_mem_area"". Otherwise we'll just malloc the mem area.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c:85,allocate,allocate,85,graf2d/win32gdk/gdk/src/glib/gmem.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c,1,['allocate'],['allocate']
Energy Efficiency,"/* If we allocate less than 65520 bytes, we assume that farmalloc; * will return a usable pointer which doesn't have to be normalized.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zutil.c:9,allocate,allocate,9,builtins/zlib/zutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zutil.c,2,['allocate'],['allocate']
Energy Efficiency,"/* If we have allocated the row_buf, this means we have already started; * with the image and we should have allocated all of the filter buffers; * that have been selected. If prev_row isn't already allocated, then; * it is too late to start using the filters that need it, since we; * will be missing the data in the previous row. If an application; * wants to start and stop using particular filters during compression,; * it should start out with all of the filters, and then remove them; * or add them back after the start of compression.; *; * NOTE: this is a nasty constraint on the code, because it means that the; * prev_row buffer must be maintained even if there are currently no; * 'prev_row' requiring filters active.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c:14,allocate,allocated,14,graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,3,['allocate'],['allocated']
Energy Efficiency,"/* Implementation note: unlike 'png_deflate_claim' this internal function; * does not take the size of the data as an argument. Some efficiency could; * be gained by using this when it is known *if* the zlib stream itself does; * not record the number; however, this is an illusion: the original writer; * of the PNG may have selected a lower window size, and we really must; * follow that because, for systems with with limited capabilities, we; * would otherwise reject the application's attempts to use a smaller window; * size (zlib doesn't have an interface to say ""this or lower""!).; *; * inflateReset2 was added to zlib 1.2.4; before this the window could not be; * reset, therefore it is necessary to always allocate the maximum window; * size with earlier zlibs just in case later compressed chunks need it.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:716,allocate,allocate,716,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['allocate'],['allocate']
Energy Efficiency,"/* In selecting the actual DCT scaling for each component, we try to; * scale down the chroma components via DCT scaling rather than downsampling.; * This saves time if the downsampler gets to use 1:1 scaling.; * Note this code adapts subsampling ratios which are powers of 2.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c:228,adapt,adapts,228,graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,2,"['adapt', 'power']","['adapts', 'powers']"
Energy Efficiency,"/* In selecting the actual DCT scaling for each component, we try to; * scale up the chroma components via IDCT scaling rather than upsampling.; * This saves time if the upsampler gets to use 1:1 scaling.; * Note this code adapts subsampling ratios which are powers of 2.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c:223,adapt,adapts,223,graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c,2,"['adapt', 'power']","['adapts', 'powers']"
Energy Efficiency,/* Increment unknown_chunks_num each time round the loop to protect the; * just-allocated chunk data.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngset.c:80,allocate,allocated,80,graf2d/asimage/src/libAfterImage/libpng/pngset.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngset.c,1,['allocate'],['allocated']
Energy Efficiency,"/* Initial wild guess at how far apart the farthest pixel; * pair we will be eliminating will be. Larger; * numbers mean more areas will be allocated, Smaller; * numbers run the risk of not saving enough data, and; * having to do this all over again.; *; * I have not done extensive checking on this number.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:140,allocate,allocated,140,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['allocate'],['allocated']
Energy Efficiency,"/* Initialize png_ptr structure, and allocate any memory needed */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c:37,allocate,allocate,37,graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,1,['allocate'],['allocate']
Energy Efficiency,/* Initialize progress monitoring. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdtrans.c:23,monitor,monitoring,23,graf2d/asimage/src/libAfterImage/libjpeg/jdtrans.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdtrans.c,1,['monitor'],['monitoring']
Energy Efficiency,"/* Initialize the default malloc descriptor if this is the first time; a request has been made to use the default sbrk'd region. Since no alignment guarantees are made about the initial value returned; by sbrk, test the initial value and (if necessary) sbrk enough additional; memory to start off with alignment to BLOCKSIZE. We actually only need; it aligned to an alignment suitable for any object, so this is overkill.; But at most it wastes just part of one BLOCKSIZE chunk of memory and; minimizes portability problems by avoiding us having to figure out; what the actual minimal alignment is. The rest of the malloc code; avoids this as well, by always aligning to the minimum of the requested; size rounded up to a power of two, or to BLOCKSIZE. Note that we are going to use some memory starting at this initial sbrk; address for the sbrk region malloc descriptor, which is a struct, so the; base address must be suitably aligned. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/sbrksup.c:722,power,power,722,core/clib/src/sbrksup.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/sbrksup.c,1,['power'],['power']
Energy Efficiency,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:105,schedul,schedule,105,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,4,['schedul'],['schedule']
Energy Efficiency,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:108,schedul,schedule,108,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,4,['schedul'],['schedule']
Energy Efficiency,"/* Internal base allocator - no messages, NULL on failure to allocate. This; * does, however, call the application provided allocator and that could call; * png_error (although that would be a bug in the application implementation.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:61,allocate,allocate,61,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['allocate'],['allocate']
Energy Efficiency,/* Intrinsic functions that require PowerISA 2.07 minimum. */; /* Creates a 2-bit mask from the most significant bits of the DPFP values. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:36,Power,PowerISA,36,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,1,['Power'],['PowerISA']
Energy Efficiency,/* Intrinsic functions that require PowerISA 2.07 minimum. */; /* Creates a 4-bit mask from the most significant bits of the SPFP values. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:36,Power,PowerISA,36,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,1,['Power'],['PowerISA']
Energy Efficiency,/* Intrinsic functions that require PowerISA 2.07 minimum. */; /* Return a mask created from the most significant bit of each 8-bit; element in A. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:36,Power,PowerISA,36,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,1,['Power'],['PowerISA']
Energy Efficiency,"/* It a buffer has been allocated, free it again */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:24,allocate,allocated,24,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['allocate'],['allocated']
Energy Efficiency,/* It is possible to statically allocate FSE CTable/DTable as a table of FSE_CTable/FSE_DTable using below macros */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:32,allocate,allocate,32,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['allocate'],['allocate']
Energy Efficiency,"/* It is up to the application to check that the profile class matches the; * application requirements; the spec provides no guidance, but it's pretty; * weird if the profile is not scanner ('scnr'), monitor ('mntr'), printer; * ('prtr') or 'spac' (for generic color spaces). Issue a warning in these; * cases. Issue an error for device link or abstract profiles - these don't; * contain the records necessary to transform the color-space to anything; * other than the target device (and not even that for an abstract profile).; * Profiles of these classes may not be embedded in images.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:200,monitor,monitor,200,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['monitor'],['monitor']
Energy Efficiency,"/* JPEG doesn't allow symbols with code lengths over 16 bits, so if the pure; * Huffman procedure assigned any such lengths, we must adjust the coding.; * Here is what the JPEG spec says about how this next bit works:; * Since symbols are paired for the longest Huffman code, the symbols are; * removed from this length category two at a time. The prefix for the pair; * (which is one bit shorter) is allocated to one of the pair; then,; * skipping the BITS entry for that prefix length, a code word from the next; * shortest nonzero BITS entry is converted into a prefix for two code words; * one bit longer.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:401,allocate,allocated,401,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,1,['allocate'],['allocated']
Energy Efficiency,"/* Known chunks that exist in pngtest.png must be supported or pngtest will fail; * simply as a result of re-ordering them. This may be fixed in 1.7; *; * pngtest allocates a single row buffer for each row and overwrites it,; * therefore if the write side doesn't support the writing of interlaced images; * nothing can be done for an interlaced image (and the code below will fail; * horribly trying to write extra data after writing garbage).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngtest.c:163,allocate,allocates,163,graf2d/asimage/src/libAfterImage/libpng/pngtest.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngtest.c,1,['allocate'],['allocates']
Energy Efficiency,/* Lazy allocate buffers */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c:8,allocate,allocate,8,graf2d/win32gdk/gdk/src/glib/giochannel.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c,1,['allocate'],['allocate']
Energy Efficiency,/* Length limit mustn't be larger than what we can allocate; * (should only be a concern in a 16-bit environment).; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c:51,allocate,allocate,51,graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,1,['allocate'],['allocate']
Energy Efficiency,/* List of blocks allocated by memalign. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h:18,allocate,allocated,18,core/clib/res/mmprivate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h,1,['allocate'],['allocated']
Energy Efficiency,/* List of blocks allocated with `mmemalign' (or `mvalloc'). */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h:18,allocate,allocated,18,core/clib/res/mmprivate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h,1,['allocate'],['allocated']
Energy Efficiency,"/* Look for a linear combination with a single variable, and at least; one multiplication.; Reject anything that applies to the variable: an explicit cast,; conditional expression, an operation that could reduce the range; of the result, or anything too complicated :-). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:205,reduce,reduce,205,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/* Look for gzip header, set up for inflate or copy. state->x.have must be 0.; If this is the first time in, allocate required memory. state->how will be; left unchanged if there is no more input data available, will be set to COPY; if there is no gzip header and direct copying will be performed, or it will; be set to GZIP for decompression. If direct copying, then leftover input; data from the input buffer will be copied to the output buffer. In that; case, all further file reads will be directly to either the output buffer or; a user buffer. If decompressing, the inflate state will be initialized.; gz_look() will return 0 on success or -1 on failure. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c:109,allocate,allocate,109,builtins/zlib/gzread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c,1,['allocate'],['allocate']
Energy Efficiency,"/* MAKECRCH */; /*; Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:; x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1. Polynomials over GF(2) are represented in binary, one bit per coefficient,; with the lowest powers in the most significant bit. Then adding polynomials; is just exclusive-or, and multiplying a polynomial by x is a right shift by; one. If we call the above polynomial p, and represent a byte as the; polynomial q, also with the lowest power in the most significant bit (so the; byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,; where a mod b means the remainder after dividing a by b. This calculation is done using the shift-register method of multiplying and; taking the remainder. The register is initialized to zero, and for each; incoming bit, x^32 is added mod p to the register if the bit is a one (where; x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by; x (which is shifting right by one and adding x^32 mod p if the bit shifted; out is a one). We start with the highest power (least significant bit) of; q and repeat for all eight bits of q. The first table is simply the CRC of all possible eight bit values. This is; all the information needed to generate CRCs on data a byte at a time for all; combinations of CRC register values and incoming bytes. The remaining tables; allow for word-at-a-time CRC calculation for both big-endian and little-; endian machines, where a word is four bytes.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/crc32.c:252,power,powers,252,builtins/zlib/crc32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/crc32.c,9,['power'],"['power', 'powers']"
Energy Efficiency,"/* MAX_PREPRO_ARGS */; /*-------------------------------------------------------------------------*/; /* UTILITIES FOR C TO CALL FORTRAN FUNCTIONS */; /*N.B. PROTOCCALLSFFUNn(..) generates code, whether or not the FORTRAN; function is called. Therefore, especially for creator's of C header files; for large FORTRAN libraries which include many functions, to reduce; compile time and object code size, it may be desirable to create; preprocessor directives to allow users to create code for only those; functions which they use. */; /* The following defines the maximum length string that a function can return.; Of course it may be undefine-d and re-define-d before individual; PROTOCCALLSFFUNn(..) as required. It would also be nice to have this derived; from the individual machines' limits. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h:359,reduce,reduce,359,montecarlo/eg/inc/cfortran.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h,1,['reduce'],['reduce']
Energy Efficiency,"/* MIPS architecture has special instructions to evaluate boolean; * conditions -- more efficient than branching, IF you can get the; * compiler to generate the right instructions (SGI compiler doesn't); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/geom.h:88,efficient,efficient,88,graf3d/eve7/glu/geom.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/geom.h,1,['efficient'],['efficient']
Energy Efficiency,/* Make sure to avoid that in the master control logic!; * We are fully adaptive here and need no extra; * statistics gathering pass!; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c:72,adapt,adaptive,72,graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,1,['adapt'],['adaptive']
Energy Efficiency,"/* Manage the read buffer; this simply reallocates the buffer if it is not small; * enough (or if it is not allocated). The routine returns a pointer to the; * buffer; if an error occurs and 'warn' is set the routine returns NULL, else; * it will call png_error (via png_malloc) on failure. (warn == 2 means; * 'silent').; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:108,allocate,allocated,108,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['allocate'],['allocated']
Energy Efficiency,/* Match description too long : reduce it */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:32,reduce,reduce,32,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['reduce'],['reduce']
Energy Efficiency,"/* Maximum allowed back-reference distance, expressed as power of 2.; * This will set a memory budget for streaming decompression,; * with larger values requiring more memory; * and typically compressing more.; * Must be clamped between ZSTD_WINDOWLOG_MIN and ZSTD_WINDOWLOG_MAX.; * Special: value 0 means ""use default windowLog"".; * Note: Using a windowLog greater than ZSTD_WINDOWLOG_LIMIT_DEFAULT; * requires explicitly allowing such size at streaming decompression stage. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:57,power,power,57,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['power'],['power']
Energy Efficiency,"/* Maximum window size = 32K. If you are really short of memory, compile; * with a smaller WSIZE but this reduces the compression ratio for files; * of size > WSIZE. WSIZE must be a power of two in the current implementation.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZIP.h:106,reduce,reduces,106,core/zip/src/ZIP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZIP.h,2,"['power', 'reduce']","['power', 'reduces']"
Energy Efficiency,/* Memory has been allocated if (valid & PNG_ALLOCATED_INFO_ROWS); non-zero */; /* Data valid if (valid & PNG_INFO_IDAT) non-zero */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pnginfo.h:19,allocate,allocated,19,graf2d/asimage/src/libAfterImage/libpng/pnginfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pnginfo.h,1,['allocate'],['allocated']
Energy Efficiency,"/* Merge together all vertices at exactly the same location.; * This is more efficient than processing them one at a time,; * simplifies the code (see ConnectLeftDegenerate), and is also; * important for correct handling of certain degenerate cases.; * For example, suppose there are two identical edges A and B; * that belong to different contours (so without this code they would; * be processed by separate sweep events). Suppose another edge C; * crosses A and B from above. When A is processed, we split it; * at its intersection point with C. However this also splits C,; * so when we insert B we may compute a slightly different; * intersection point. This might leave two edges with a small; * gap between them. This kind of error is especially obvious; * when using boundary extraction (GLU_TESS_BOUNDARY_ONLY).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c:77,efficient,efficient,77,graf3d/eve7/glu/sweep.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c,1,['efficient'],['efficient']
Energy Efficiency,"/* Monitoring (int argc, char* /\*argv[]*\/) */; /* { */; /* } */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Monitoring.h:3,Monitor,Monitoring,3,tmva/tmva/inc/TMVA/Monitoring.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Monitoring.h,1,['Monitor'],['Monitoring']
Energy Efficiency,/* Mutex array required - allocate it */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:26,allocate,allocate,26,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['allocate'],['allocate']
Energy Efficiency,"/* NB: if ODITHER_SIZE is not a power of 2, ODITHER_MASK uses will break */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c:32,power,power,32,graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,1,['power'],['power']
Energy Efficiency,"/* NEED_SHORT_EXTERNAL_NAMES */; /*; * These two functions are used to allocate and release small chunks of; * memory. (Typically the total amount requested through jpeg_get_small is; * no more than 20K or so; this will be requested in chunks of a few K each.); * Behavior should be the same as for the standard library functions malloc; * and free; in particular, jpeg_get_small must return NULL on failure.; * On most systems, these ARE malloc and free. jpeg_free_small is passed the; * size of the object being freed, just in case it's needed.; * On an 80x86 machine using small-data memory model, these manage near heap.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemsys.h:71,allocate,allocate,71,graf2d/asimage/src/libAfterImage/libjpeg/jmemsys.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemsys.h,1,['allocate'],['allocate']
Energy Efficiency,/* NOTE: prior to 1.5.4 this test used to include PNG_BACKGROUND (now; * PNG_COMPOSE). This effectively smashed the background calculation for; * 16-bit output because the 8-bit table assumes the result will be; * reduced to 8 bits.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:214,reduce,reduced,214,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['reduce'],['reduced']
Energy Efficiency,/* NOTE: the 'setjmp' buffer may still be allocated and the memory and error; * callbacks are still set at this point. They are required to complete the; * destruction of the png_struct itself.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:42,allocate,allocated,42,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['allocate'],['allocated']
Energy Efficiency,"/* NULL terminated string arrays.; * g_strsplit() splits up string into max_tokens tokens at delim and; * returns a newly allocated string array.; * g_strjoinv() concatenates all of str_array's strings, sliding in an; * optional separator, the returned string is newly allocated.; * g_strfreev() frees the array itself and all of its strings.; * g_strdupv() copies a NULL-terminated array of strings; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstrfuncs.h:122,allocate,allocated,122,graf2d/win32gdk/gdk/src/glib/gstrfuncs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstrfuncs.h,2,['allocate'],['allocated']
Energy Efficiency,/* Now allocate a new array and copy the old members in; this does all; * the overflow checks.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngset.c:7,allocate,allocate,7,graf2d/asimage/src/libAfterImage/libpng/pngset.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngset.c,1,['allocate'],['allocate']
Energy Efficiency,"/* Now read the rows. Do this here if it is possible to read directly into; * the output buffer, otherwise allocate a local row buffer of the maximum; * size libpng requires and call the relevant processing routine safely.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:107,allocate,allocate,107,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['allocate'],['allocate']
Energy Efficiency,"/* Now read the tag table; a variable size buffer is; * needed at this point, allocate one for the whole; * profile. The header check has already validated; * that none of this stuff will overflow.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:78,allocate,allocate,78,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['allocate'],['allocate']
Energy Efficiency,/* Now reduce the location to the top-most set bit by removing each least; * significant bit in turn.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngset.c:7,reduce,reduce,7,graf2d/asimage/src/libAfterImage/libpng/pngset.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngset.c,1,['reduce'],['reduce']
Energy Efficiency,"/* Number of search attempts, as a power of 2.; * More attempts result in better and slower compression.; * This parameter is useless for ""fast"" and ""dFast"" strategies.; * Special: value 0 means ""use default searchLog"". */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:35,power,power,35,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['power'],['power']
Energy Efficiency,"/* OK, allocate the object from the current pool */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:7,allocate,allocate,7,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,1,['allocate'],['allocate']
Energy Efficiency,/* Offset in micrometers (1/10^6 meter) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:33,meter,meter,33,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['meter'],['meter']
Energy Efficiency,/* Offset of Green */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h:13,Green,Green,13,graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h,1,['Green'],['Green']
Energy Efficiency,"/* On aarch64, we disable this optimization for clang because on certain; * mobile chipsets, performance is reduced with clang. For information; * refer to https://github.com/lz4/lz4/pull/707 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:108,reduce,reduced,108,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['reduce'],['reduced']
Energy Efficiency,"/* On the other hand, if a 16-bit file is to be reduced to 8-bits per; * component this will also happen after PNG_COMPOSE and so the background; * color must be pre-expanded here.; *; * TODO: fix this too.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:48,reduce,reduced,48,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['reduce'],['reduced']
Energy Efficiency,"/* Once the BASE_PTR array is partially sorted by quicksort the rest; * is completely sorted using insertion sort, since this is efficient; * for partitions below MAX_THRESH size. BASE_PTR points to the beginning; * of the array to sort, and END_PTR points at the very last element in; * the array (*not* one beyond it!). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gqsort.c:129,efficient,efficient,129,graf2d/win32gdk/gdk/src/glib/gqsort.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gqsort.c,1,['efficient'],['efficient']
Energy Efficiency,"/* Order size using quicksort. This implementation incorporates; * four optimizations discussed in Sedgewick:; *; * 1. Non-recursive, using an explicit stack of pointer that store the next; * array partition to sort. To save time, this maximum amount of space; * required to store an array of MAX_INT is allocated on the stack. Assuming; * a 32-bit integer, this needs only 32 * sizeof(stack_node) == 136 bits.; * Pretty cheap, actually.; *; * 2. Chose the pivot element using a median-of-three decision tree. This; * reduces the probability of selecting a bad pivot value and eliminates; * certain * extraneous comparisons.; *; * 3. Only quicksorts TOTAL_ELEMS / MAX_THRESH partitions, leaving insertion; * sort to order the MAX_THRESH items within each partition. This is a big; * win, since insertion sort is faster for small, mostly sorted array; * segments.; *; * 4. The larger of the two sub-partitions is always pushed onto the stack; * first, with the algorithm then concentrating on the smaller partition.; * This *guarantees* no more than log (n) stack size is needed (actually O(1); * in this case)!; */; /**; * g_qsort_with_data:; * @pbase: start of array to sort; * @total_elems: elements in the array; * @size: size of each element; * @compare_func: function to compare elements; * @user_data: data to pass to @compare_func; *; * This is just like the standard C qsort() function, but; * the comparison routine accepts a user data argument.; * ; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gqsort.c:304,allocate,allocated,304,graf2d/win32gdk/gdk/src/glib/gqsort.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gqsort.c,2,"['allocate', 'reduce']","['allocated', 'reduces']"
Energy Efficiency,"/* Pass 1: process rows. */; /* Note results are scaled up by sqrt(8) compared to a true DCT; */; /* furthermore, we scale the results by 2**PASS1_BITS. */; /* We scale the results further by 2 as part of output adaption */; /* scaling for different DCT size. */; /* 3-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/6). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:212,adapt,adaption,212,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['adapt'],['adaption']
Energy Efficiency,"/* Pass 1: process rows. */; /* Note results are scaled up by sqrt(8) compared to a true DCT; */; /* furthermore, we scale the results by 2**PASS1_BITS. */; /* We scale the results further by 2 as part of output adaption */; /* scaling for different DCT size. */; /* 6-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/12). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:212,adapt,adaption,212,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['adapt'],['adaption']
Energy Efficiency,"/* Pass 1: process rows. */; /* Note results are scaled up by sqrt(8) compared to a true DCT; */; /* furthermore, we scale the results by 2**PASS1_BITS. */; /* We scale the results further by 2 as part of output adaption */; /* scaling for different DCT size. */; /* cK represents sqrt(2) * cos(K*pi/10). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:212,adapt,adaption,212,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['adapt'],['adaption']
Energy Efficiency,"/* Pass 1: process rows. */; /* Note results are scaled up by sqrt(8) compared to a true DCT; */; /* furthermore, we scale the results by 2**PASS1_BITS. */; /* We scale the results further by 2**2 as part of output adaption */; /* scaling for different DCT size. */; /* cK represents sqrt(2) * cos(K*pi/6). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:215,adapt,adaption,215,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['adapt'],['adaption']
Energy Efficiency,/* Pass 1: process rows. */; /* Note results are scaled up by sqrt(8) compared to a true DCT; */; /* we scale the results further by 2 as part of output adaption */; /* scaling for different DCT size. */; /* cK represents sqrt(2) * cos(K*pi/18). */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:153,adapt,adaption,153,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['adapt'],['adaption']
Energy Efficiency,/* Pass 1: process rows. */; /* Note results are scaled up by sqrt(8) compared to a true DCT; */; /* we scale the results further by 2 as part of output adaption */; /* scaling for different DCT size. */; /* cK represents sqrt(2) * cos(K*pi/20). */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:153,adapt,adaption,153,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['adapt'],['adaption']
Energy Efficiency,/* Pass 1: process rows. */; /* Note results are scaled up by sqrt(8) compared to a true DCT; */; /* we scale the results further by 2 as part of output adaption */; /* scaling for different DCT size. */; /* cK represents sqrt(2) * cos(K*pi/22). */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:153,adapt,adaption,153,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['adapt'],['adaption']
Energy Efficiency,"/* Place pow(5, power) in DST, and return the number of parts used.; DST must be at least one part larger than size of the answer. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:16,power,power,16,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['power'],['power']
Energy Efficiency,"/* Power 8 Crypto functions; Note: We diverge from the current GCC implementation with regard; to cryptography and related functions as follows:; - Only the SHA and AES instructions and builtins are disabled by -mno-crypto; - The remaining ones are only available on Power8 and up so; require -mpower8-vector; The justification for this is that export requirements require that; Category:Vector.Crypto is optional (i.e. compliant hardware may not provide; support). As a result, we need to be able to turn off support for those.; The remaining ones (currently controlled by -mcrypto for GCC) still; need to be provided on compliant hardware even if Vector.Crypto is not; provided.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h:3,Power,Power,3,interpreter/llvm-project/clang/lib/Headers/altivec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h,1,['Power'],['Power']
Energy Efficiency,/* Power series for incomplete beta integral.; Use when b*x is small and x not too close to 1. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephes.h:3,Power,Power,3,math/mathcore/src/SpecFuncCephes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephes.h,1,['Power'],['Power']
Energy Efficiency,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we do the operation. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Power,PowerISA,3,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,1,['Power'],['PowerISA']
Energy Efficiency,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Power,PowerISA,3,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,9,['Power'],['PowerISA']
Energy Efficiency,/* PowerISA VSX does not allow partial (for just lower double); * results. So to insure we don't generate spurious exceptions; * (from the upper double values) we splat the lower double; * before we to the operation. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Power,PowerISA,3,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,3,['Power'],['PowerISA']
Energy Efficiency,/* PowerISA VSX does not allow partial (for just lower double); results. So to insure we don't generate spurious exceptions; (from the upper double values) we splat the lower double; before we do the operation. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:3,Power,PowerISA,3,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,1,['Power'],['PowerISA']
Energy Efficiency,/* PowerISA VSX does not allow partial (for just lower double); results. So to insure we don't generate spurious exceptions; (from the upper double values) we splat the lower double; before we to the operation. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Power,PowerISA,3,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,4,['Power'],['PowerISA']
Energy Efficiency,/* PowerISA VSX does not allow partial (for just lower float); * results. So to insure we don't generate spurious exceptions; * (from the upper float values) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Power,PowerISA,3,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,2,['Power'],['PowerISA']
Energy Efficiency,"/* Provide simple macro statement wrappers (adapted from Perl):; * G_STMT_START { statements; } G_STMT_END;; * can be used as a single statement, as in; * if (x) G_STMT_START { ... } G_STMT_END; else ...; *; * For gcc we will wrap the statements within `({' and `})' braces.; * For SunOS they will be wrapped within `if (1)' and `else (void) 0',; * and otherwise within `do' and `while (0)'.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmacros.h:44,adapt,adapted,44,graf2d/win32gdk/gdk/src/glib/gmacros.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmacros.h,1,['adapt'],['adapted']
Energy Efficiency,"/* RLE encoding of difference ; * We calculate difference between following bytes. If differece is zero - its RLE encoded.; * If its +-1 - its encoded as 2 bit values; * If Its +-(from 2 to 7) - its encoded using 4 bit values; * If Its +-(from 8 to 127) - its encoded using 8 bit values ; * If Its +-(from 128 to 255) - its encoded using 9 bit values; * ; * The hope is that most of the bytes will be reduced to 0 ; * The next likely value will be from 2 to 7 ; * and only few cases will fall in other categories; * ; * For bitmaps we store lengths of ones and zerous, assuming that each string tsarts with 0; * ; * */; /* The following lines is used only for non-bitmaps : */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.h:401,reduce,reduced,401,graf2d/asimage/src/libAfterImage/asstorage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.h,1,['reduce'],['reduced']
Energy Efficiency,"/* Re-allocate the previously allocated block in PTR, making the new block; SIZE bytes long. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmalloc.h:6,allocate,allocate,6,core/clib/res/mmalloc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmalloc.h,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"/* Reassign responsibility for freeing existing data, whether allocated; * by libpng or by the application; this works on the png_info structure passed; * in, it does not change the state for other png_info structures.; *; * It is unlikely that this function works correctly as of 1.6.0 and using it; * may result either in memory leaks or double free of allocated data.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:62,allocate,allocated,62,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,2,['allocate'],['allocated']
Energy Efficiency,"/* Reduce RGB files to grayscale, with or without alpha; * using the equation given in Poynton's ColorFAQ of 1998-01-04 at; * <http://www.inforamp.net/~poynton/> (THIS LINK IS DEAD June 2008 but; * versions dated 1998 through November 2002 have been archived at; * https://web.archive.org/web/20000816232553/www.inforamp.net/; * ~poynton/notes/colour_and_gamma/ColorFAQ.txt ); * Charles Poynton poynton at poynton.com; *; * Y = 0.212671 * R + 0.715160 * G + 0.072169 * B; *; * which can be expressed with integers as; *; * Y = (6969 * R + 23434 * G + 2365 * B)/32768; *; * Poynton's current link (as of January 2003 through July 2011):; * <http://www.poynton.com/notes/colour_and_gamma/>; * has changed the numbers slightly:; *; * Y = 0.2126*R + 0.7152*G + 0.0722*B; *; * which can be expressed with integers as; *; * Y = (6966 * R + 23436 * G + 2366 * B)/32768; *; * Historically, however, libpng uses numbers derived from the ITU-R Rec 709; * end point chromaticities and the D65 white point. Depending on the; * precision used for the D65 white point this produces a variety of different; * numbers, however if the four decimal place value used in ITU-R Rec 709 is; * used (0.3127,0.3290) the Y calculation would be:; *; * Y = (6968 * R + 23435 * G + 2366 * B)/32768; *; * While this is correct the rounding results in an overflow for white, because; * the sum of the rounded coefficients is 32769, not 32768. Consequently; * libpng uses, instead, the closest non-overflowing approximation:; *; * Y = (6968 * R + 23434 * G + 2366 * B)/32768; *; * Starting with libpng-1.5.5, if the image being converted has a cHRM chunk; * (including an sRGB chunk) then the chromaticities are used to calculate the; * coefficients. See the chunk handling in pngrutil.c for more information.; *; * In all cases the calculation is to be done in a linear colorspace. If no; * gamma information is available to correct the encoding of the original RGB; * values this results in an implicit assumption that the origina",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:3,Reduce,Reduce,3,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['Reduce'],['Reduce']
Energy Efficiency,/* Reduce RGB to grayscale. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:3,Reduce,Reduce,3,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['Reduce'],['Reduce']
Energy Efficiency,"/* Request any required workspace.; *; * This routine figures out the size that the output image will be; * (which implies that all the transform parameters must be set before; * it is called).; *; * We allocate the workspace virtual arrays from the source decompression; * object, so that all the arrays (both the original data and the workspace); * will be taken into account while making memory management decisions.; * Hence, this routine must be called after jpeg_read_header (which reads; * the image dimensions) and before jpeg_read_coefficients (which realizes; * the source's virtual arrays).; *; * This function returns FALSE right away if -perfect is given; * and transformation is not perfect. Otherwise returns TRUE.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/transupp.c:203,allocate,allocate,203,graf2d/asimage/src/libAfterImage/libjpeg/transupp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/transupp.c,1,['allocate'],['allocate']
Energy Efficiency,/* Request buffers are not pre-allocated. They are private to the; 	 * request and do not contain any state information that might be; 	 * of interest to anyone observing a server status. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:31,allocate,allocated,31,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['allocate'],['allocated']
Energy Efficiency,"/* Return the amount of memory in 'size' required to compress this image.; * The png_image structure 'image' must be filled in as in the above; * function and must not be changed before the actual write call, the buffer; * and all other parameters must also be identical to that in the final; * write call. The 'size' variable need not be initialized.; *; * NOTE: the macro returns true/false, if false is returned 'size' will be; * set to zero and the write failed and probably will fail if tried again.; */; /* You can pre-allocate the buffer by making sure it is of sufficient size; * regardless of the amount of compression achieved. The buffer size will; * always be bigger than the original image and it will never be filled. The; * following macros are provided to assist in allocating the buffer.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:525,allocate,allocate,525,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['allocate'],['allocate']
Energy Efficiency,"/* Return the length of the queue, negative values mean, that threads; * are waiting, positve values mean, that there are entries in the; * queue. Actually this function returns the length of the queue minus; * the number of waiting threads, g_async_queue_length == 0 could also; * mean 'n' entries in the queue and 'n' thread waiting, such can; * happen due to locking of the queue or due to scheduling. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h:393,schedul,scheduling,393,graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,1,['schedul'],['scheduling']
Energy Efficiency,"/* Return the size, in bytes, of the color-map of this image. If the image; * format is not a color-map format this will return a size sufficient for; * 256 entries in the given format; check PNG_FORMAT_FLAG_COLORMAP if; * you don't want to allocate a color-map in this case.; */; /* PNG_IMAGE_FLAG_*; *; * Flags containing additional information about the image are held in the; * 'flags' field of png_image.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:241,allocate,allocate,241,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['allocate'],['allocate']
Energy Efficiency,"/* Returns TRUE if current locale uses UTF-8 charset. If CHARSET is; * not null, sets *CHARSET to the name of the current locale's; * charset. This value is statically allocated, and should be copied; * in case the locale's charset will be changed later using setlocale(); * or in some other way.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gunicode.h:168,allocate,allocated,168,graf2d/win32gdk/gdk/src/glib/gunicode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gunicode.h,1,['allocate'],['allocated']
Energy Efficiency,"/* Returns image resolution in pixels per meter, from pHYs chunk data. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:42,meter,meter,42,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['meter'],['meter']
Energy Efficiency,"/* SECURITY and SAFETY:; *; * libpng is built with support for internal limits on image dimensions and; * memory usage. These are documented in scripts/pnglibconf.dfa of the; * source and recorded in the machine generated header file pnglibconf.h.; */; /* If you are running on a machine where you cannot allocate more; * than 64K of memory at once, uncomment this. While libpng will not; * normally need that much memory in a chunk (unless you load up a very; * large file), zlib needs to know how big of a chunk it can use, and; * libpng thus makes sure to check any memory allocation to verify it; * will fit into memory.; *; * zlib provides 'MAXSEG_64K' which, if defined, indicates the; * same limit and pngconf.h (already included) sets the limit; * if certain operating systems are detected.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:305,allocate,allocate,305,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['allocate'],['allocate']
Energy Efficiency,"/* SX/PowerStationFortran have 0 and 1 defined, others are neither T nor F. */; /* hpuxFortran800 has 0 and 0x01000000 defined. Others are unknown. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h:6,Power,PowerStationFortran,6,montecarlo/eg/inc/cfortran.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h,1,['Power'],['PowerStationFortran']
Energy Efficiency,"/* Scaling decisions are generally the same as in the LL&M algorithm;; * see jfdctint.c for more details. However, we choose to descale; * (right shift) multiplication products as soon as they are formed,; * rather than carrying additional fractional bits into subsequent additions.; * This compromises accuracy slightly, but it lets us save a few shifts.; * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples); * everywhere except in the multiplications proper; this saves a good deal; * of work on 16-bit-int machines.; *; * Again to save a few shifts, the intermediate results between pass 1 and; * pass 2 are not upscaled, but are represented only to integral precision.; *; * A final compromise is to represent the multiplicative constants to only; * 8 fractional bits, rather than 13. This saves some shifting work on some; * machines, and may also reduce the cost of multiplication (since there; * are fewer one-bits in the constants).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctfst.c:876,reduce,reduce,876,graf2d/asimage/src/libAfterImage/libjpeg/jfdctfst.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctfst.c,1,['reduce'],['reduce']
Energy Efficiency,"/* Scaling decisions are generally the same as in the LL&M algorithm;; * see jidctint.c for more details. However, we choose to descale; * (right shift) multiplication products as soon as they are formed,; * rather than carrying additional fractional bits into subsequent additions.; * This compromises accuracy slightly, but it lets us save a few shifts.; * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples); * everywhere except in the multiplications proper; this saves a good deal; * of work on 16-bit-int machines.; *; * The dequantized coefficients are not integers because the AA&N scaling; * factors have been incorporated. We represent them scaled up by PASS1_BITS,; * so that the first and second IDCT rounds have the same input scaling.; * For 8-bit JSAMPLEs, we choose IFAST_SCALE_BITS = PASS1_BITS so as to; * avoid a descaling shift; this compromises accuracy rather drastically; * for small quantization table entries, but it saves a lot of shifts.; * For 12-bit JSAMPLEs, there's no hope of using 16x16 multiplies anyway,; * so we use a much larger scaling factor to preserve accuracy.; *; * A final compromise is to represent the multiplicative constants to only; * 8 fractional bits, rather than 13. This saves some shifting work on some; * machines, and may also reduce the cost of multiplication (since there; * are fewer one-bits in the constants).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctfst.c:1304,reduce,reduce,1304,graf2d/asimage/src/libAfterImage/libjpeg/jidctfst.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctfst.c,1,['reduce'],['reduce']
Energy Efficiency,"/* See if another task is already doing this (not thread-safe, but better; than nothing -- significantly reduces duration of vulnerability in; case the advice about DYNAMIC_CRC_TABLE is ignored) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/crc32.c:105,reduce,reduces,105,builtins/zlib/crc32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/crc32.c,3,['reduce'],['reduces']
Energy Efficiency,"/* Select a size limit (in power of 2) beyond which; * the streaming API will refuse to allocate memory buffer; * in order to protect the host from unreasonable memory requirements.; * This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode.; * By default, a decompression context accepts window sizes <= (1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT).; * Special: value 0 means ""use default maximum windowLog"". */; /* note : additional experimental parameters are also available; * within the experimental section of the API.; * At the time of this writing, they include :; * ZSTD_d_format; * ZSTD_d_stableOutBuffer; * ZSTD_d_forceIgnoreChecksum; * Because they are not stable, it's necessary to define ZSTD_STATIC_LINKING_ONLY to access them.; * note : never ever use experimentalParam? names directly; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:27,power,power,27,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,3,"['allocate', 'power']","['allocate', 'allocated', 'power']"
Energy Efficiency,/* Set up progress monitor's pass info if present */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c:19,monitor,monitor,19,graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,2,['monitor'],['monitor']
Energy Efficiency,/* Should the alloc parameter do something? */; /* Allocate a starting palette with all of the reserved colors. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c:51,Allocate,Allocate,51,graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/* Since we support deletion the data structure is a little more; * complicated than an ordinary heap. ""nodes"" is the heap itself;; * active nodes are stored in the range 1..pq->size. When the; * heap exceeds its allocated size (pq->max), its size doubles.; * The children of node i are nodes 2i and 2i+1.; *; * Each node stores an index into an array ""handles"". Each handle; * stores a key, plus a pointer back to the node which currently; * represents that key (ie. nodes[handles[i].node].handle == i).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/priorityq-heap.h:213,allocate,allocated,213,graf3d/eve7/glu/priorityq-heap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/priorityq-heap.h,3,['allocate'],['allocated']
Energy Efficiency,"/* Size of match buffer for literals/lengths. There are 4 reasons for; * limiting lit_bufsize to 64K:; * - frequencies can be kept in 16 bit counters; * - if compression is not successful for the first block, all input; * data is still in the window so we can still emit a stored block even; * when input comes from standard input. (This can also be done for; * all blocks if lit_bufsize is not greater than 32K.); * - if compression is not successful for a file smaller than 64K, we can; * even emit a stored file instead of a stored block (saving 5 bytes).; * This is applicable only for zip (not gzip or zlib).; * - creating new Huffman trees less frequently may not provide fast; * adaptation to changes in the input data statistics. (Take for; * example a binary file with poorly compressible code followed by; * a highly compressible string table.) Smaller buffer sizes give; * fast adaptation but have of course the overhead of transmitting; * trees more frequently.; * - I can't count above 4; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.h:686,adapt,adaptation,686,builtins/zlib/deflate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.h,6,['adapt'],['adaptation']
Energy Efficiency,"/* Size of the initial probe table, as a power of 2.; * Resulting memory usage is (1 << (hashLog+2)).; * Must be clamped between ZSTD_HASHLOG_MIN and ZSTD_HASHLOG_MAX.; * Larger tables improve compression ratio of strategies <= dFast,; * and improve speed of strategies > dFast.; * Special: value 0 means ""use default hashLog"". */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:41,power,power,41,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['power'],['power']
Energy Efficiency,"/* Size of the multi-probe search table, as a power of 2.; * Resulting memory usage is (1 << (chainLog+2)).; * Must be clamped between ZSTD_CHAINLOG_MIN and ZSTD_CHAINLOG_MAX.; * Larger tables result in better and slower compression.; * This parameter is useless for ""fast"" strategy.; * It's still useful when using ""dfast"" strategy,; * in which case it defines a secondary probe table.; * Special: value 0 means ""use default chainLog"". */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:46,power,power,46,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['power'],['power']
Energy Efficiency,"/* Size of the table for long distance matching, as a power of 2.; * Larger values increase memory usage and compression ratio,; * but decrease compression speed.; * Must be clamped between ZSTD_HASHLOG_MIN and ZSTD_HASHLOG_MAX; * default: windowlog - 7.; * Special: value 0 means ""automatically determine hashlog"". */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:54,power,power,54,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['power'],['power']
Energy Efficiency,"/* Sizes of match buffers for literals/lengths and distances. There are; * 4 reasons for limiting LIT_BUFSIZE to 64K:; * - frequencies can be kept in 16 bit counters; * - if compression is not successful for the first block, all input data is; * still in the window so we can still emit a stored block even when input; * comes from standard input. (This can also be done for all blocks if; * LIT_BUFSIZE is not greater than 32K.); * - if compression is not successful for a file smaller than 64K, we can; * even emit a stored file instead of a stored block (saving 5 bytes).; * - creating new Huffman trees less frequently may not provide fast; * adaptation to changes in the input data statistics. (Take for; * example a binary file with poorly compressible code followed by; * a highly compressible string table.) Smaller buffer sizes give; * fast adaptation but have of course the overhead of transmitting trees; * more frequently.; * - I can't count above 4; * The current code is general and allows DIST_BUFSIZE < LIT_BUFSIZE (to save; * memory at the expense of compression). Some optimizations would be possible; * if we rely on DIST_BUFSIZE == LIT_BUFSIZE.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZTrees.c:647,adapt,adaptation,647,core/zip/src/ZTrees.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZTrees.c,2,['adapt'],['adaptation']
Energy Efficiency,"/* Sliding window. Input bytes are read into the second half of the window,; * and move to the first half later to keep a dictionary of at least WSIZE; * bytes. With this organization, matches are limited to a distance of; * WSIZE-MAX_MATCH bytes, but this ensures that IO is always; * performed with a length multiple of the block size. Also, it limits; * the window size to 64K, which is quite useful on MSDOS.; * To do: limit the window size to WSIZE+BSZ if SMALL_MEM (the code would; * be less efficient since the data would have to be copied WSIZE/BSZ times); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Bits.h:498,efficient,efficient,498,core/zip/src/Bits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Bits.h,1,['efficient'],['efficient']
Energy Efficiency,"/* Some C compilers fail to reduce ""FIX(constant)"" at compile time, thus; * causing a lot of useless floating-point operations at run time.; * To get around this we use the following pre-calculated constants.; * If you change CONST_BITS you may want to add appropriate values.; * (With a reasonable C compiler, you can just rely on the FIX() macro...); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctfst.c:28,reduce,reduce,28,graf2d/asimage/src/libAfterImage/libjpeg/jfdctfst.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctfst.c,4,['reduce'],['reduce']
Energy Efficiency,"/* Some simplifying macros, which reduce the need to worry whether the; * buffers have been allocated. These also make USE_BUF () an lvalue,; * which is used in g_io_channel_read_to_end ().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c:34,reduce,reduce,34,graf2d/win32gdk/gdk/src/glib/giochannel.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c,2,"['allocate', 'reduce']","['allocated', 'reduce']"
Energy Efficiency,"/* Split form encoded data into a list of key value pairs.; A form encoded input might be a query string, the body of a; x-www-form-urlencoded POST request or any other data with this; structure: ""keyName1=value1&keyName2=value2&keyName3=value3"".; Values might be percent-encoded - this function will transform; them to the unencoded characters.; The input string is modified by this function: To split the; ""query_string"" member of struct request_info, create a copy first; (e.g., using strdup).; The function itself does not allocate memory. Thus, it is not; required to free any pointer returned from this function.; The output list of is limited to MG_MAX_FORM_FIELDS name-value-; pairs. The default value is reasonably oversized for typical; applications, however, for special purpose systems it might be; required to increase this value at compile time. Parameters:; data: form encoded iput string. Will be modified by this function.; form_fields: output list of name/value-pairs. A buffer with a size; specified by num_form_fields must be provided by the; caller.; num_form_fields: Size of provided form_fields buffer in number of; ""struct mg_header"" elements. Return:; On success: number of form_fields filled; On error:; -1 (parameter error). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h:527,allocate,allocate,527,net/http/civetweb/civetweb.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h,1,['allocate'],['allocate']
Energy Efficiency,"/* Step 1: allocate and initialize JPEG compression object */; /* We have to set up the error handler first, in case the initialization; 	* step fails. (Unlikely, but it could happen if you are out of memory.); 	* This routine fills in the contents of struct jerr, and returns jerr's; 	* address which we place into the link field in cinfo.; 	*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/export.c:11,allocate,allocate,11,graf2d/asimage/src/libAfterImage/export.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/export.c,1,['allocate'],['allocate']
Energy Efficiency,"/* Step 1: allocate and initialize JPEG decompression object */; /* We set up the normal JPEG error routines, then override error_exit. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c:11,allocate,allocate,11,graf2d/asimage/src/libAfterImage/import.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c,1,['allocate'],['allocate']
Energy Efficiency,"/* Support for compiler specific function attributes. These are used; * so that where compiler support is available, incorrect use of API; * functions in png.h will generate compiler warnings. Added at libpng; * version 1.2.41. Disabling these removes the warnings but may also produce; * less efficient code.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngconf.h:294,efficient,efficient,294,graf2d/asimage/src/libAfterImage/libpng/pngconf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngconf.h,1,['efficient'],['efficient']
Energy Efficiency,"/* TODO: fix this. Because the expand_16 operation is after the compose; * handling the background color must be 8, not 16, bits deep, but the; * application will supply a 16-bit value so reduce it here.; *; * The PNG_BACKGROUND_EXPAND code above does not expand to 16 bits at; * present, so that case is ok (until do_expand_16 is moved.); *; * NOTE: this discards the low 16 bits of the user supplied background; * color, but until expand_16 works properly there is no choice!; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:188,reduce,reduce,188,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['reduce'],['reduce']
Energy Efficiency,"/* TODO: implement different limits for different types of chunk.; *; * The caller supplies *newlength set to the maximum length of the; * uncompressed data, but this routine allocates space for the prefix and; * maybe a '\0' terminator too. We have to assume that 'prefix_size' is; * limited only by the maximum chunk size.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:175,allocate,allocates,175,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['allocate'],['allocates']
Energy Efficiency,"/* The allocator divides the heap into blocks of fixed size; large; requests receive one or more whole blocks, and small requests; receive a fragment of a block. Fragment sizes are powers of two,; and all fragments of a block are the same size. When all the; fragments in a block have been freed, the block itself is freed. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h:181,power,powers,181,core/clib/res/mmprivate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h,1,['power'],['powers']
Energy Efficiency,"/* The basic operations are insertion of a new key (pqInsert),; * and examination/extraction of a key whose value is minimum; * (pqMinimum/pqExtractMin). Deletion is also allowed (pqDelete);; * for this purpose pqInsert returns a ""handle"" which is supplied; * as the argument.; *; * An initial heap may be created efficiently by calling pqInsert; * repeatedly, then calling pqInit. In any case pqInit must be called; * before any operations other than pqInsert are used.; *; * If the heap is empty, pqMinimum/pqExtractMin will return a NULL key.; * This may also be tested with pqIsEmpty.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/priorityq-heap.h:314,efficient,efficiently,314,graf3d/eve7/glu/priorityq-heap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/priorityq-heap.h,3,['efficient'],['efficiently']
Energy Efficiency,"/* The buffer strip height is max_v_samp_factor, which is typically; * an efficient number of rows for upsampling to return.; * (In the presence of output rescaling, we might want to be smarter?); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdpostct.c:74,efficient,efficient,74,graf2d/asimage/src/libAfterImage/libjpeg/jdpostct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdpostct.c,1,['efficient'],['efficient']
Energy Efficiency,"/* The chromaticities of the red, green and blue colorants and the chromaticity; * of the corresponding white point (i.e. of rgb(1.0,1.0,1.0)).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h:34,green,green,34,graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,1,['green'],['green']
Energy Efficiency,"/* The color type.; * A color consists of red, green and blue values in the; * range 0-65535 and a pixel value. The pixel value is highly; * dependent on the depth and colormap which this color will; * be used to draw into. Therefore, sharing colors between; * colormaps is a bad idea.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkcolor.h:47,green,green,47,graf2d/win32gdk/gdk/src/gdk/gdkcolor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkcolor.h,1,['green'],['green']
Energy Efficiency,"/* The connection struct, pre-; 	 * allocated for each worker */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:36,allocate,allocated,36,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['allocate'],['allocated']
Energy Efficiency,"/* The following are examples of calls to png_set_alpha_mode to achieve the; * required overall gamma correction and, where necessary, alpha; * premultiplication.; *; * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);; * This is the default libpng handling of the alpha channel - it is not; * pre-multiplied into the color components. In addition the call states; * that the output is for a sRGB system and causes all PNG files without gAMA; * chunks to be assumed to be encoded using sRGB.; *; * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);; * In this case the output is assumed to be something like an sRGB conformant; * display preceded by a power-law lookup table of power 1.45. This is how; * early Mac systems behaved.; *; * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_GAMMA_LINEAR);; * This is the classic Jim Blinn approach and will work in academic; * environments where everything is done by the book. It has the shortcoming; * of assuming that input PNG data with no gamma information is linear - this; * is unlikely to be correct unless the PNG files where generated locally.; * Most of the time the output precision will be so low as to show; * significant banding in dark areas of the image.; *; * png_set_expand_16(pp);; * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_DEFAULT_sRGB);; * This is a somewhat more realistic Jim Blinn inspired approach. PNG files; * are assumed to have the sRGB encoding if not marked with a gamma value and; * the output is always 16 bits per component. This permits accurate scaling; * and processing of the data. If you know that your input PNG files were; * generated locally you might need to replace PNG_DEFAULT_sRGB with the; * correct value for your system.; *; * png_set_alpha_mode(pp, PNG_ALPHA_OPTIMIZED, PNG_DEFAULT_sRGB);; * If you just need to composite the PNG image onto an existing background; * and if you control the code that does this you can use the optimization; * setting. In this case you just copy completely ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:662,power,power-law,662,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,2,['power'],"['power', 'power-law']"
Energy Efficiency,"/* The fun part. We now try to allocate the colors we couldn't allocate; * directly. The first step will map a color onto its nearest color; * that has been allocated (either by us or someone else). If any colors; * remain unallocated, we map these onto the colors that we have allocated; * ourselves.; */; /* read up to MAX_IMAGE_COLORS colors of the current colormap */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:31,allocate,allocate,31,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,4,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"/* The hIST chunk contains the relative frequency or importance of the; * various palette entries, so that a viewer can intelligently select a; * reduced-color palette, if required. Data is an array of ""num_palette""; * values in the range [0,65535]. Data valid if (valid & PNG_INFO_hIST); * is non-zero.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pnginfo.h:146,reduce,reduced-color,146,graf2d/asimage/src/libAfterImage/libpng/pnginfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pnginfo.h,1,['reduce'],['reduced-color']
Energy Efficiency,"/* The input is an array of 16-bit components, these must be scaled to; * 8 bits each. For a 16-bit value V the required value (from the PNG; * specification) is:; *; * (V * 255) / 65535; *; * This reduces to round(V / 257), or floor((V + 128.5)/257); *; * Represent V as the two byte value vhi.vlo. Make a guess that the; * result is the top byte of V, vhi, then the correction to this value; * is:; *; * error = floor(((V-vhi.vhi) + 128.5) / 257); * = floor(((vlo-vhi) + 128.5) / 257); *; * This can be approximated using integer arithmetic (and a signed; * shift):; *; * error = (vlo-vhi+128) >> 8;; *; * The approximate differs from the exact answer only when (vlo-vhi) is; * 128; it then gives a correction of +1 when the exact correction is; * 0. This gives 128 errors. The exact answer (correct for all 16-bit; * input values) is:; *; * error = (vlo-vhi+128)*65535 >> 24;; *; * An alternative arithmetic calculation which also gives no errors is:; *; * (V * 255 + 32895) >> 16; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:198,reduce,reduces,198,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['reduce'],['reduces']
Energy Efficiency,/* The maximum size of the color-map required by the format expressed in a; * count of components. This can be used to compile-time allocate a; * color-map:; *; * png_uint_16 colormap[PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(linear_fmt)];; *; * png_byte colormap[PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(sRGB_fmt)];; *; * Alternatively use the PNG_IMAGE_COLORMAP_SIZE macro below to use the; * information from one of the png_image_begin_read_ APIs and dynamically; * allocate the required memory.; */; /* Corresponding information about the pixels */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:132,allocate,allocate,132,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,2,['allocate'],['allocate']
Energy Efficiency,"/* The memory requirements for deflate are (in bytes):; (1 << (windowBits+2)) + (1 << (memLevel+9)); that is: 128K for windowBits=15 + 128K for memLevel = 8 (default values); plus a few kilobytes for small objects. For example, if you want to reduce; the default memory requirements from 256K to 128K, compile with; make CFLAGS=""-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7""; Of course this will generally degrade compression (there's no free lunch). The memory requirements for inflate are (in bytes) 1 << windowBits; that is, 32K for windowBits=15 (default value) plus a few kilobytes; for small objects.; */; /* Type declarations */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zconf.h:243,reduce,reduce,243,builtins/zlib/zconf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zconf.h,3,['reduce'],['reduce']
Energy Efficiency,"/* The new size is different; allocate a new space,; and copy the lesser of the new size and the old. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mrealloc.c:30,allocate,allocate,30,core/clib/src/mrealloc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mrealloc.c,1,['allocate'],['allocate']
Energy Efficiency,/* The pre-allocated buffer is large enough.; 		 * Use it to store the string and return the address. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:11,allocate,allocated,11,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['allocate'],['allocated']
Energy Efficiency,/* The pre-allocated buffer not large enough. */; /* Allocate a new buffer. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:11,allocate,allocated,11,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,"/* The reverse calculation is more difficult because the original tristimulus; * value had 9 independent values (red,green,blue)x(X,Y,Z) however only 8; * derived values were recorded in the cHRM chunk;; * (red,green,blue,white)x(x,y). This loses one degree of freedom and; * therefore an arbitrary ninth value has to be introduced to undo the; * original transformations.; *; * Think of the original end-points as points in (X,Y,Z) space. The; * chromaticity values (c) have the property:; *; * C; * c = ---------; * X + Y + Z; *; * For each c (x,y,z) from the corresponding original C (X,Y,Z). Thus the; * three chromaticity values (x,y,z) for each end-point obey the; * relationship:; *; * x + y + z = 1; *; * This describes the plane in (X,Y,Z) space that intersects each axis at the; * value 1.0; call this the chromaticity plane. Thus the chromaticity; * calculation has scaled each end-point so that it is on the x+y+z=1 plane; * and chromaticity is the intersection of the vector from the origin to the; * (X,Y,Z) value with the chromaticity plane.; *; * To fully invert the chromaticity calculation we would need the three; * end-point scale factors, (red-scale, green-scale, blue-scale), but these; * were not recorded. Instead we calculated the reference white (X,Y,Z) and; * recorded the chromaticity of this. The reference white (X,Y,Z) would have; * given all three of the scale factors since:; *; * color-C = color-c * color-scale; * white-C = red-C + green-C + blue-C; * = red-c*red-scale + green-c*green-scale + blue-c*blue-scale; *; * But cHRM records only white-x and white-y, so we have lost the white scale; * factor:; *; * white-C = white-c*white-scale; *; * To handle this the inverse transformation makes an arbitrary assumption; * about white-scale:; *; * Assume: white-Y = 1.0; * Hence: white-scale = 1/white-y; * Or: red-Y + green-Y + blue-Y = 1.0; *; * Notice the last statement of the assumption gives an equation in three of; * the nine values we want to calculate. 8 mor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:117,green,green,117,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,2,['green'],['green']
Energy Efficiency,"/* The samples of the image have one to four channels whose components have; * original values in the range 0 to 1.0:; *; * 1: A single gray or luminance channel (G).; * 2: A gray/luminance channel and an alpha channel (GA).; * 3: Three red, green, blue color channels (RGB).; * 4: Three color channels and an alpha channel (RGBA).; *; * The components are encoded in one of two ways:; *; * a) As a small integer, value 0..255, contained in a single byte. For the; * alpha channel the original value is simply value/255. For the color or; * luminance channels the value is encoded according to the sRGB specification; * and matches the 8-bit format expected by typical display devices.; *; * The color/gray channels are not scaled (pre-multiplied) by the alpha; * channel and are suitable for passing to color management software.; *; * b) As a value in the range 0..65535, contained in a 2-byte integer. All; * channels can be converted to the original value by dividing by 65535; all; * channels are linear. Color channels use the RGB encoding (RGB end-points) of; * the sRGB specification. This encoding is identified by the; * PNG_FORMAT_FLAG_LINEAR flag below.; *; * When the simplified API needs to convert between sRGB and linear colorspaces,; * the actual sRGB transfer curve defined in the sRGB specification (see the; * article at <https://en.wikipedia.org/wiki/SRGB>) is used, not the gamma=1/2.2; * approximation used elsewhere in libpng.; *; * When an alpha channel is present it is expected to denote pixel coverage; * of the color or luminance channels and is returned as an associated alpha; * channel: the color/gray channels are scaled (pre-multiplied) by the alpha; * value.; *; * The samples are either contained directly in the image data, between 1 and 8; * bytes per pixel according to the encoding, or are held in a color-map indexed; * by bytes in the image data. In the case of a color-map the color-map entries; * are individual samples, encoded as above, and the image data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:242,green,green,242,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['green'],['green']
Energy Efficiency,"/* The visual type.; * ""type"" is the type of visual this is (PseudoColor, TrueColor, etc).; * ""depth"" is the bit depth of this visual.; * ""colormap_size"" is the size of a colormap for this visual.; * ""bits_per_rgb"" is the number of significant bits per red, green and blue.; * The red, green and blue masks, shifts and precisions refer; * to value needed to calculate pixel values in TrueColor and DirectColor; * visuals. The ""mask"" is the significant bits within the pixel. The; * ""shift"" is the number of bits left we must shift a primary for it; * to be in position (according to the ""mask""). ""prec"" refers to how; * much precision the pixel value contains for a particular primary.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkvisual.h:258,green,green,258,graf2d/win32gdk/gdk/src/gdk/gdkvisual.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkvisual.h,2,['green'],['green']
Energy Efficiency,"/* Then allocate that much, and actualy do the expansion and insert; 	* the new found pair into our buffer ; 	*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutils.c:8,allocate,allocate,8,graf2d/win32gdk/gdk/src/glib/gutils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutils.c,1,['allocate'],['allocate']
Energy Efficiency,"/* These buffer sizes are softly recommended.; * They are not required : ZSTD_compressStream*() happily accepts any buffer size, for both input and output.; * Respecting the recommended size just makes it a bit easier for ZSTD_compressStream*(),; * reducing the amount of memory shuffling and buffering, resulting in minor performance savings.; *; * However, note that these recommendations are from the perspective of a C caller program.; * If the streaming interface is invoked from some other language,; * especially managed ones such as Java or Go, through a foreign function interface such as jni or cgo,; * a major performance rule is to reduce crossing such interface to an absolute minimum.; * It's not rare that performance ends being spent more into the interface, rather than compression itself.; * In which cases, prefer using large buffers, as large as practical,; * for both input and output, to reduce the nb of roundtrips.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:644,reduce,reduce,644,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,2,['reduce'],['reduce']
Energy Efficiency,"/* This Source Code Form is subject to the terms of the Mozilla Public; * License, v. 2.0. If a copy of the MPL was not distributed with this; * file, You can obtain one at https://mozilla.org/MPL/2.0/. */; /**; * @file; * Adapter between for KDTree and CDT; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/LocatorKDTree.h:223,Adapt,Adapter,223,math/mathcore/src/CDT/LocatorKDTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/LocatorKDTree.h,1,['Adapt'],['Adapter']
Energy Efficiency,/* This function returns the jmp_buf built in to *png_ptr. It must be; * supplied with an appropriate 'longjmp' function to use on that jmp_buf; * unless the default error function is overridden in which case NULL is; * acceptable. The size of the jmp_buf is checked against the actual size; * allocated by the library - the call will return NULL on a mismatch; * indicating an ABI mismatch.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:294,allocate,allocated,294,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['allocate'],['allocated']
Energy Efficiency,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since PowerPC target doesn't support native 64-bit vector type, we; typedef __m64 to 64-bit unsigned long long in MMX intrinsics, which; works well for _si64 and some _pi32 operations. For _pi16 and _pi8 operations, it's better to transfer __m64 into; 128-bit PowerPC vector first. Power8 introduced direct register; move instructions which helps for more efficient implementation. It's user's responsibility to determine if the results of such port; are acceptable or further changes are needed. Please note that much; code using Intel intrinsics CAN BE REWRITTEN in more portable and; efficient standard C or GNU C extensions with 64-bit scalar; operations, or 128-bit SSE/Altivec operations, which are more; recommended. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h:123,Power,PowerPC,123,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,4,"['Power', 'efficient']","['PowerPC', 'efficient']"
Energy Efficiency,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:170,Power,PowerPC,170,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,4,"['POWER', 'Power', 'efficient']","['POWER', 'PowerISA', 'PowerPC', 'efficiently']"
Energy Efficiency,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:185,Power,PowerPC,185,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,4,"['POWER', 'Power', 'efficient']","['POWER', 'PowerISA', 'PowerPC', 'efficiently']"
Energy Efficiency,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:463,Power,PowerPC,463,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,4,"['Power', 'monitor', 'schedul']","['PowerISA', 'PowerPC', 'monitor', 'schedule']"
Energy Efficiency,"/* This indicates that the RGB values of the in-memory bitmap do not; * correspond to the red, green and blue end-points defined by sRGB.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:95,green,green,95,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['green'],['green']
Energy Efficiency,"/* This is a 'mntr' (display) profile with a mediaWhitePointTag that does not; * match the D50 PCS illuminant in the header (it is in fact the D65 values,; * so the white point is recorded as the un-adapted value.) The profiles; * below only differ in one byte - the intent - and are basically the same as; * the previous profile except for the mediaWhitePointTag error and a missing; * chromaticAdaptationTag.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:199,adapt,adapted,199,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['adapt'],['adapted']
Energy Efficiency,"/* This is always an 8-bit sRGB value, using the 'green' channel; * for gray is much better than calculating the luminance here;; * we can get off-by-one errors in that calculation relative to; * the app expectations and that will show up in transparent; * pixels.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:50,green,green,50,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['green'],['green']
Energy Efficiency,"/* This is an internal error in libpng: somehow we have been left; * with a stack allocated jmp_buf when the application regained; * control. It's always possible to fix this up, but for the moment; * this is a png_error because that makes it easy to detect.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c:82,allocate,allocated,82,graf2d/asimage/src/libAfterImage/libpng/pngerror.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c,1,['allocate'],['allocated']
Energy Efficiency,"/* This is certainly not the most efficient way to find the intersection; * of two line segments, but it is very numerically stable.; *; * Strategy: find the two middle vertices in the VertLeq ordering,; * and interpolate the intersection s-value from these. Then repeat; * using the TransLeq ordering to find the intersection t-value.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/geom.c:34,efficient,efficient,34,graf3d/eve7/glu/geom.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/geom.c,1,['efficient'],['efficient']
Energy Efficiency,/* This is the maximum no. of allocated colors. See also the nopen == 0; * note above.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:30,allocate,allocated,30,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,1,['allocate'],['allocated']
Energy Efficiency,"/* This looks real messy, but the compiler will reduce; * it down to a reasonable formula. For example, with; * 5 bits per color, we get:; * p = (((r >> 3) & 0x1f) << 10) |; * (((g >> 3) & 0x1f) << 5) |; * ((b >> 3) & 0x1f);; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:48,reduce,reduce,48,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['reduce'],['reduce']
Energy Efficiency,"/* This needs to be here because the 'normal' check is in; * png_decompress_chunk, yet this happens after the attempt to; * png_malloc_base the required data. We only need this on read; on write; * the caller supplies the profile buffer so libpng doesn't allocate it. See; * the call to icc_check_length below (the write case).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:255,allocate,allocate,255,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['allocate'],['allocate']
Energy Efficiency,/* This struct contains the JPEG decompression parameters and pointers to; 	 * working space (which is allocated as needed by the JPEG library).; 	 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/export.c:103,allocate,allocated,103,graf2d/asimage/src/libAfterImage/export.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/export.c,2,['allocate'],['allocated']
Energy Efficiency,/* This temporary stack-allocated structure is used to provide a place to; * build enough context to allow the user provided memory allocator (if any); * to be called.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:24,allocate,allocated,24,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['allocate'],['allocated']
Energy Efficiency,"/* Three color definitions. The order of the red, green, and blue, (and the; * exact size) is not important, although the size of the fields need to; * be png_byte or png_uint_16 (as defined below).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:50,green,green,50,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['green'],['green']
Energy Efficiency,"/* To find the length of the output it is necessary to first compress the; * input. The result is buffered rather than using the two-pass algorithm; * that is used on the inflate side; deflate is assumed to be slower and a; * PNG writer is assumed to have more memory available than a PNG reader.; *; * IMPLEMENTATION NOTE: the zlib API deflateBound() can be used to find an; * upper limit on the output size, but it is always bigger than the input; * size so it is likely to be more efficient to use this linked-list; * approach.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c:484,efficient,efficient,484,graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,1,['efficient'],['efficient']
Energy Efficiency,"/* Traditionally Hue is represented by 360 degree circle.; For our needs we use 255 degree circle instead. Now the circle is separated into 6 segments :; Trad:		Us:				Color range: Red:	Green:	Blue:; 0-60		0 -42.5 		red-yellow FF-7F 0 -7F 0 -0; 60-120 42.5 -85 		yellow-green 7F-0 7F-FF 0 -0; 120-180 85 -127.5 	green-cyan 0 -0 FF-7F 0 -7F; 180-240 127.5-170 	cyan-blue 0 -0 7F-0 7F-FF; 240-300 170 -212.5 blue-magenta 0-7F 0 -0	FF-7F; 300-360 212.5-255 magenta-red 7F-FF 0 -0 7F-0. As seen from above in each segment at least one of the RGB values is 0.; To achieve that we find minimum of R, G and b and substract it from all,; and then multiply values by ratio to bring it into range :. new_val = ((val - min_val)*0xFEFF)/(max_val-min_val); (note that we use 16bit values, instead of 8 bit as above). WE store hue in 16 bits, so instead of above value of 42.5 per segment; we should use 85<<7 == 0x00002A80 per segment. When all the RGB values are the same - then hue is invalid and = 0;; To distinguish between hue == 0 when color is Red and invalid hue, we; make all valid hues to fit in range 0x0001-0xFF00, with 0x0001 being RED.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.c:186,Green,Green,186,graf2d/asimage/src/libAfterImage/blender.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.c,3,"['Green', 'green']","['Green', 'green', 'green-cyan']"
Energy Efficiency,/* Try to allocate new buffer with double size */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c:10,allocate,allocate,10,graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c,1,['allocate'],['allocate']
Energy Efficiency,"/* Try to get space, if fail reduce slop and try again */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:29,reduce,reduce,29,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,1,['reduce'],['reduce']
Energy Efficiency,/* Try to reduce the next power of 2 above totalCost because we; * gain back half the rank.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/huf_compress.c:10,reduce,reduce,10,builtins/zstd/compress/huf_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/huf_compress.c,2,"['power', 'reduce']","['power', 'reduce']"
Energy Efficiency,"/* Turn on default checking for mmalloc/mrealloc/mfree, for the heap specified; by MD. If FUNC is non-NULL, it is a pointer to the function to call; to abort whenever memory corruption is detected. By default, this is the; standard library function abort(). Note that we disallow installation of initial checking hooks if mmalloc; has been called at any time for this particular heap, since if any region; that is allocated prior to installation of the hooks is subsequently; reallocated or freed after installation of the hooks, it is guaranteed; to trigger a memory corruption error. We do this by checking the state; of the MMALLOC_INITIALIZED flag. However, we can call this function at any time after the initial call,; to update the function pointers to the checking routines and to the; user defined corruption handler routine, as long as these function pointers; have been previously extablished by the initial call. Note that we; do this automatically when remapping an previously used heap, to ensure; that the hooks get updated to the correct values, although the corruption; handler pointer gets set back to the default. The application can then; call mmcheck to use a different corruption handler if desired. Returns non-zero if checking is successfully enabled, zero otherwise. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mmcheck.c:414,allocate,allocated,414,core/clib/src/mmcheck.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mmcheck.c,1,['allocate'],['allocated']
Energy Efficiency,"/* Turn on quantizing, and reduce the palette to the number of colors; * available.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:27,reduce,reduce,27,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['reduce'],['reduce']
Energy Efficiency,"/* Two strategies here - 1 - the fast one - we try to allocate new slot ; 	 * and avoid copying the body of the data over - we can do that only if; 	 * there is enough space in its block, otherwise we have to relocate it ; 	 * into different block, which is slower.; 	 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.c:54,allocate,allocate,54,graf2d/asimage/src/libAfterImage/asstorage.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.c,1,['allocate'],['allocate']
Energy Efficiency,/* Under MSDOS we may run out of memory when processing a large number; * of files. Compile with MEDIUM_MEM to reduce the memory requirements or; * with SMALL_MEM to use as little memory as possible.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Tailor.h:111,reduce,reduce,111,core/zip/src/Tailor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Tailor.h,1,['reduce'],['reduce']
Energy Efficiency,/* Update the number of allocated atoms count.; 	 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c:24,allocate,allocated,24,graf2d/win32gdk/gdk/src/glib/gmem.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c,1,['allocate'],['allocated']
Energy Efficiency,"/* Use blue, green, red order for pixels. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:13,green,green,13,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['green'],['green']
Energy Efficiency,/* Utility used below - a simple accurate power of ten from an integral; * exponent.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:42,power,power,42,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['power'],['power']
Energy Efficiency,"/* WIN32 */; /* We start off with the malloc descriptor allocated on the stack, until; we build it up enough to call _mmalloc_mmap_morecore() to allocate the; first page of the region and copy it there. Ensure that it is zero'd and; then initialize the fields that we know values for. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/attach.c:56,allocate,allocated,56,core/clib/src/attach.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/attach.c,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"/* We allocate one big table and divide it up into eight parts, instead of; * doing eight alloc_small requests. This lets us use a single table base; * address, which can be held in a register in the inner loops on many; * machines (more than can hold all eight addresses, anyway).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccolor.c:6,allocate,allocate,6,graf2d/asimage/src/libAfterImage/libjpeg/jccolor.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccolor.c,1,['allocate'],['allocate']
Energy Efficiency,"/* We are deallocating memory. If the amount requested would cause; us to try to deallocate back past the base of the mmap'd region; then do nothing, and return NULL. Otherwise, deallocate the; memory and return the old break value. */; /* only munmap whole mapping, called via mmalloc_detach, smaller size; reductions cause the breakval to be reduced but not the mapping; to be undone (rdm). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mmapsup.c:344,reduce,reduced,344,core/clib/src/mmapsup.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mmapsup.c,1,['reduce'],['reduced']
Energy Efficiency,"/* We build the 8- or 16-bit gamma tables here. Note that for 16-bit; * tables, we don't make a full table if we are reducing to 8-bit in; * the future. Note also how the gamma_16 tables are segmented so that; * we don't need to allocate > 64K chunks for a full 16-bit table.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:229,allocate,allocate,229,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['allocate'],['allocate']
Energy Efficiency,/* We can allocate at least the nc'th root of max_colors per component. */; /* Compute floor(nc'th root of max_colors). */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c:10,allocate,allocate,10,graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,1,['allocate'],['allocate']
Energy Efficiency,/* We can now tell the memory manager to allocate virtual arrays. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcinit.c:41,allocate,allocate,41,graf2d/asimage/src/libAfterImage/libjpeg/jcinit.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcinit.c,4,['allocate'],['allocate']
Energy Efficiency,"/* We could be doing buffered-image output before starting a 2-pass; * color quantization; in that case, jinit_d_post_controller did not; * allocate a strip buffer. Use the virtual-array buffer as workspace.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdpostct.c:140,allocate,allocate,140,graf2d/asimage/src/libAfterImage/libjpeg/jdpostct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdpostct.c,1,['allocate'],['allocate']
Energy Efficiency,"/* We could be somewhat more efficient here by computing; * the length, adding the space, then converting into that; * space, by cut-and-pasting the internals of g_unichar_to_utf8.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstring.c:29,efficient,efficient,29,graf2d/win32gdk/gdk/src/glib/gstring.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstring.c,1,['efficient'],['efficient']
Energy Efficiency,/* We could use png_quantize here so long as there is no transparent; * color or alpha; png_quantize ignores alpha. Easier overall just; * to do it once and using PNG_DIV51 on the 6x6x6 reduced RGB cube.; * Consequently we always want libpng to produce sRGB data.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:186,reduce,reduced,186,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['reduce'],['reduced']
Energy Efficiency,"/* We don't do this when the workspace is statically allocated, because; * when that is the case, we have no capability to hook into the end of the; * workspace's lifecycle to unpoison the memory.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h:53,allocate,allocated,53,builtins/zstd/compress/zstd_cwksp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h,2,['allocate'],['allocated']
Energy Efficiency,"/* We want to break any ties in favor of green, then red, blue last.; * This code does the right thing for R,G,B or B,G,R color orders only.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:41,green,green,41,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['green'],['green']
Energy Efficiency,"/* Where to start searching the free list when looking for new memory.; The two possible values are 0 and heapindex. Starting at 0 seems; to reduce total memory usage, while starting at heapindex seems to; run faster. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h:141,reduce,reduce,141,core/clib/res/mmprivate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h,1,['reduce'],['reduce']
Energy Efficiency,"/* Won't fit, so allocate a new region that will.; Free the old region first in case there is sufficient; adjacent free space to grow without moving. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mrealloc.c:17,allocate,allocate,17,core/clib/src/mrealloc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mrealloc.c,1,['allocate'],['allocate']
Energy Efficiency,"/* XLC or GCC-compatible compiler, targeting PowerPC with VMX/VSX */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/adler32_cf.c:45,Power,PowerPC,45,builtins/zlib/adler32_cf.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/adler32_cf.c,2,['Power'],['PowerPC']
Energy Efficiency,"/* ZSTDMT_allocJobsTable(); * allocate and init a job table.; * update *nbJobsPtr to next power of 2 value, as size of table */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c:30,allocate,allocate,30,builtins/zstd/compress/zstdmt_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c,2,"['allocate', 'power']","['allocate', 'power']"
Energy Efficiency,"/* ZSTD_buildFSETable() :; * generate FSE decoding table for one symbol (ll, ml or off); * this function must be called with valid parameters only; * (dt is large enough, normalizedCounter distribution total is a power of 2, max is within range, etc.); * in which case it cannot fail.; * The workspace must be 4-byte aligned and at least ZSTD_BUILD_FSE_TABLE_WKSP_SIZE bytes, which is; * defined in zstd_decompress_internal.h.; * Internal use only.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.h:213,power,power,213,builtins/zstd/decompress/zstd_decompress_block.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.h,1,['power'],['power']
Energy Efficiency,"/* ZSTD_c_stableInBuffer; * Experimental parameter.; * Default is 0 == disabled. Set to 1 to enable.; *; * Tells the compressor that the ZSTD_inBuffer will ALWAYS be the same; * between calls, except for the modifications that zstd makes to pos (the; * caller must not modify pos). This is checked by the compressor, and; * compression will fail if it ever changes. This means the only flush; * mode that makes sense is ZSTD_e_end, so zstd will error if ZSTD_e_end; * is not used. The data in the ZSTD_inBuffer in the range [src, src + pos); * MUST not be modified during compression or you will get data corruption.; *; * When this flag is enabled zstd won't allocate an input window buffer,; * because the user guarantees it can reference the ZSTD_inBuffer until; * the frame is complete. But, it will still allocate an output buffer; * large enough to fit a block (see ZSTD_c_stableOutBuffer). This will also; * avoid the memcpy() from the input buffer to the input window buffer.; *; * NOTE: ZSTD_compressStream2() will error if ZSTD_e_end is not used.; * That means this flag cannot be used with ZSTD_compressStream().; *; * NOTE: So long as the ZSTD_inBuffer always points to valid memory, using; * this flag is ALWAYS memory safe, and will never access out-of-bounds; * memory. However, compression WILL fail if you violate the preconditions.; *; * WARNING: The data in the ZSTD_inBuffer in the range [dst, dst + pos) MUST; * not be modified during compression or you will get data corruption. This; * is because zstd needs to reference data in the ZSTD_inBuffer to find; * matches. Normally zstd maintains its own window buffer for this purpose,; * but passing this flag tells zstd to use the user provided buffer.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:660,allocate,allocate,660,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,2,['allocate'],['allocate']
Energy Efficiency,"/* ZSTD_c_stableOutBuffer; * Experimental parameter.; * Default is 0 == disabled. Set to 1 to enable.; *; * Tells he compressor that the ZSTD_outBuffer will not be resized between; * calls. Specifically: (out.size - out.pos) will never grow. This gives the; * compressor the freedom to say: If the compressed data doesn't fit in the; * output buffer then return ZSTD_error_dstSizeTooSmall. This allows us to; * always decompress directly into the output buffer, instead of decompressing; * into an internal buffer and copying to the output buffer.; *; * When this flag is enabled zstd won't allocate an output buffer, because; * it can write directly to the ZSTD_outBuffer. It will still allocate the; * input window buffer (see ZSTD_c_stableInBuffer).; *; * Zstd will check that (out.size - out.pos) never grows and return an error; * if it does. While not strictly necessary, this should prevent surprises.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:591,allocate,allocate,591,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,2,['allocate'],['allocate']
Energy Efficiency,"/* ZSTD_d_stableOutBuffer; * Experimental parameter.; * Default is 0 == disabled. Set to 1 to enable.; *; * Tells the decompressor that the ZSTD_outBuffer will ALWAYS be the same; * between calls, except for the modifications that zstd makes to pos (the; * caller must not modify pos). This is checked by the decompressor, and; * decompression will fail if it ever changes. Therefore the ZSTD_outBuffer; * MUST be large enough to fit the entire decompressed frame. This will be; * checked when the frame content size is known. The data in the ZSTD_outBuffer; * in the range [dst, dst + pos) MUST not be modified during decompression; * or you will get data corruption.; *; * When this flags is enabled zstd won't allocate an output buffer, because; * it can write directly to the ZSTD_outBuffer, but it will still allocate; * an input buffer large enough to fit any compressed block. This will also; * avoid the memcpy() from the internal output buffer to the ZSTD_outBuffer.; * If you need to avoid the input buffer allocation use the buffer-less; * streaming API.; *; * NOTE: So long as the ZSTD_outBuffer always points to valid memory, using; * this flag is ALWAYS memory safe, and will never access out-of-bounds; * memory. However, decompression WILL fail if you violate the preconditions.; *; * WARNING: The data in the ZSTD_outBuffer in the range [dst, dst + pos) MUST; * not be modified during decompression or you will get data corruption. This; * is because zstd needs to reference data in the ZSTD_outBuffer to regenerate; * matches. Normally zstd maintains its own buffer for this purpose, but passing; * this flag tells zstd to use the user provided buffer.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:713,allocate,allocate,713,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,2,['allocate'],['allocate']
Energy Efficiency,/* ZSTD_downscaleStat() :; * reduce all elements in table by a factor 2^(ZSTD_FREQ_DIV+malus); * return the resulting sum of elements */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c:29,reduce,reduce,29,builtins/zstd/compress/zstd_opt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c,1,['reduce'],['reduce']
Energy Efficiency,"/* ZSTD_indexTooCloseToMax() :; * minor optimization : prefer memset() rather than reduceIndex(); * which is measurably slow in some circumstances (reported for Visual Studio).; * Works when re-using a context for a lot of smallish inputs :; * if all inputs are smaller than ZSTD_INDEXOVERFLOW_MARGIN,; * memset() will be triggered before reduceIndex().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:83,reduce,reduceIndex,83,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,2,['reduce'],['reduceIndex']
Energy Efficiency,"/* __STDC_ISO_10646__ */; /**; * g_utf8_collate_key:; * @str: a UTF-8 encoded string.; * @len: length of @str, in bytes, or -1 if @str is nul-terminated.; *; * Converts a string into a collation key that can be compared; * with other collation keys using <function>strcmp()</function>. ; * The results of comparing the collation keys of two strings ; * with <function>strcmp()</function> will always be the same as ; * comparing the two original keys with g_utf8_collate().; * ; * Return value: a newly allocated string. This string should; * be freed with g_free() when you are done with it.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gunicollate.c:503,allocate,allocated,503,graf2d/win32gdk/gdk/src/glib/gunicollate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gunicollate.c,1,['allocate'],['allocated']
Energy Efficiency,"/* __gl_meshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst; * to eDst->Org, and returns the corresponding half-edge eNew.; * If eOrg->Lface == eDst->Lface, this splits one loop into two,; * and the newly created loop is eNew->Lface. Otherwise, two disjoint; * loops are merged into one, and the loop eDst->Lface is destroyed.; *; * If (eOrg == eDst), the new face will have only two edges.; * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.; * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/mesh.c:444,reduce,reduced,444,graf3d/eve7/glu/mesh.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/mesh.c,2,['reduce'],['reduced']
Energy Efficiency,"/* __gl_meshDelete( eDel ) removes the edge eDel. There are several cases:; * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop; * eDel->Lface is deleted. Otherwise, we are splitting one loop into two;; * the newly created loop will contain eDel->Dst. If the deletion of eDel; * would create isolated vertices, those are deleted as well.; *; * This function could be implemented as two calls to __gl_meshSplice; * plus a few calls to memFree, but this would allocate and delete; * unnecessary vertices and faces.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/mesh.c:478,allocate,allocate,478,graf3d/eve7/glu/mesh.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/mesh.c,1,['allocate'],['allocate']
Energy Efficiency,/* __x86_64__ */; /// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param __A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see _rdpmc,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:54,monitor,monitoring,54,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,1,['monitor'],['monitoring']
Energy Efficiency,/* accum green */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/visualinfo.c:9,green,green,9,builtins/glew/src/visualinfo.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/visualinfo.c,1,['green'],['green']
Energy Efficiency,/* accum green size */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/visualinfo.c:9,green,green,9,builtins/glew/src/visualinfo.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/visualinfo.c,1,['green'],['green']
Energy Efficiency,/* adapt lastRun to fill 'dst' */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:3,adapt,adapt,3,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['adapt'],['adapt']
Energy Efficiency,/* adapt lastRunSize to fill 'dest' */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4hc.c:3,adapt,adapt,3,builtins/lz4/lz4hc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4hc.c,1,['adapt'],['adapt']
Energy Efficiency,/* adapt lastRunSize to fill 'dst' */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4hc.c:3,adapt,adapt,3,builtins/lz4/lz4hc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4hc.c,1,['adapt'],['adapt']
Energy Efficiency,"/* advantage to algorithm using less memory, to reduce cache eviction */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/huf_decompress.c:48,reduce,reduce,48,builtins/zstd/decompress/huf_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/huf_decompress.c,1,['reduce'],['reduce']
Energy Efficiency,/* allocate */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:3,allocate,allocate,3,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,2,['allocate'],['allocate']
Energy Efficiency,/* allocate DIB bits : */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/bmp.c:3,allocate,allocate,3,graf2d/asimage/src/libAfterImage/bmp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/bmp.c,1,['allocate'],['allocate']
Energy Efficiency,/* allocate a new gdk pixmap */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkpixmap-win32.c:3,allocate,allocate,3,graf2d/win32gdk/gdk/src/gdk/win32/gdkpixmap-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkpixmap-win32.c,1,['allocate'],['allocate']
Energy Efficiency,/* allocate and initialize the marker item */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c:3,allocate,allocate,3,graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,1,['allocate'],['allocate']
Energy Efficiency,/* allocate buffers */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c:3,allocate,allocate,3,builtins/zlib/gzread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c,1,['allocate'],['allocate']
Energy Efficiency,"/* allocate deflate memory, set up for gzip compression */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzwrite.c:3,allocate,allocate,3,builtins/zlib/gzwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzwrite.c,1,['allocate'],['allocate']
Energy Efficiency,/* allocate gzFile structure to return */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzlib.c:3,allocate,allocate,3,builtins/zlib/gzlib.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzlib.c,1,['allocate'],['allocate']
Energy Efficiency,/* allocate inflate memory */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c:3,allocate,allocate,3,builtins/zlib/gzread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c,1,['allocate'],['allocate']
Energy Efficiency,/* allocate input buffer */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzwrite.c:3,allocate,allocate,3,builtins/zlib/gzwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzwrite.c,1,['allocate'],['allocate']
Energy Efficiency,/* allocate memory */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx:3,allocate,allocate,3,graf2d/x11/src/Rotated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx,1,['allocate'],['allocate']
Energy Efficiency,/* allocate memory if this is the first time through */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzwrite.c:3,allocate,allocate,3,builtins/zlib/gzwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzwrite.c,2,['allocate'],['allocate']
Energy Efficiency,"/* allocate mutex array, if required */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,allocate,allocate,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['allocate'],['allocate']
Energy Efficiency,/* allocate output buffer */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzwrite.c:3,allocate,allocate,3,builtins/zlib/gzwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzwrite.c,1,['allocate'],['allocate']
Energy Efficiency,/* allocate read buffers and inflate memory */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c:3,allocate,allocate,3,builtins/zlib/gzread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c,1,['allocate'],['allocate']
Energy Efficiency,/* allocate space */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c:3,allocate,allocate,3,builtins/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c,2,['allocate'],['allocate']
Energy Efficiency,/* allocate the state */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/mixmax.h:3,allocate,allocate,3,math/mathcore/src/mixmax.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/mixmax.h,1,['allocate'],['allocate']
Energy Efficiency,/* allocate*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:3,allocate,allocate,3,hist/hist/src/THnBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx,1,['allocate'],['allocate']
Energy Efficiency,/* allocated size */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.c:3,allocate,allocated,3,graf2d/asimage/src/libAfterImage/asimage.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.c,1,['allocate'],['allocated']
Energy Efficiency,"/* allocated sliding window, if needed */; /* bit accumulator */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.h:3,allocate,allocated,3,builtins/zlib/inflate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.h,2,['allocate'],['allocated']
Energy Efficiency,"/* allocated sliding window, if wsize != 0 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inffast.c:3,allocate,allocated,3,builtins/zlib/inffast.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inffast.c,2,['allocate'],['allocated']
Energy Efficiency,"/* array of pointers to slots is allocated separately, so that we can reallocate it ; 	 in case we have lots of small slots */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.h:33,allocate,allocated,33,graf2d/asimage/src/libAfterImage/asstorage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.h,1,['allocate'],['allocated']
Energy Efficiency,"/* blue was max, then green */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.c:22,green,green,22,graf2d/asimage/src/libAfterImage/blender.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.c,1,['green'],['green']
Energy Efficiency,"/* buffer size, zero if not allocated yet */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzguts.h:28,allocate,allocated,28,builtins/zlib/gzguts.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzguts.h,1,['allocate'],['allocated']
Energy Efficiency,"/* buffer to save current (unfiltered) row.; * While reading, this is a pointer into; * big_row_buf; while writing it is separately; * allocated.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h:135,allocate,allocated,135,graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,1,['allocate'],['allocated']
Energy Efficiency,/* buffer to save previous (unfiltered) row.; * While reading this is a pointer into; * big_prev_row; while writing it is separately; * allocated if needed.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h:136,allocate,allocated,136,graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,1,['allocate'],['allocated']
Energy Efficiency,"/* by default, the streaming decoder will refuse any frame; * requiring larger than (1<<ZSTD_WINDOWLOG_LIMIT_DEFAULT) window size,; * to preserve host's memory from unreasonable requirements.; * This limit can be overridden using ZSTD_DCtx_setParameter(,ZSTD_d_windowLogMax,).; * The limit does not apply for one-pass decoders (such as ZSTD_decompress()), since no additional memory is allocated */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:386,allocate,allocated,386,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['allocate'],['allocated']
Energy Efficiency,"/* calloc implemented as malloc+memset;; * not as efficient as calloc, but next best guess for custom malloc */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/zstd_common.c:50,efficient,efficient,50,builtins/zstd/common/zstd_common.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/zstd_common.c,1,['efficient'],['efficient']
Energy Efficiency,/* choose an efficiently fread'able size */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatasrc.c:13,efficient,efficiently,13,graf2d/asimage/src/libAfterImage/libjpeg/jdatasrc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatasrc.c,1,['efficient'],['efficiently']
Energy Efficiency,/* choose an efficiently fwrite'able size */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c:13,efficient,efficiently,13,graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c,1,['efficient'],['efficiently']
Energy Efficiency,/* chunkSize must be power of 2 for mask==(chunkSize-1) to work */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c:21,power,power,21,builtins/zstd/compress/zstdmt_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c,1,['power'],['power']
Energy Efficiency,"/* clean up after the read, and free any memory allocated - REQUIRED */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c:48,allocate,allocated,48,graf2d/asimage/src/libAfterImage/import.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c,1,['allocate'],['allocated']
Energy Efficiency,/* colormap allocated at init time */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:12,allocate,allocated,12,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['allocate'],['allocated']
Energy Efficiency,/* colors[i] is only zero if the pixel at that location hasn't; * been allocated yet. This is a sanity check required for proper; * color allocation by the progressive image loader; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:71,allocate,allocated,71,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,1,['allocate'],['allocated']
Energy Efficiency,"/* crc32.c -- compute the CRC-32 of a data stream; * Copyright (C) 1995-2005 Mark Adler; * For conditions of distribution and use, see copyright notice in zlib.h; *; * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster; * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing; * tables for updating the shift register in one step with three exclusive-ors; * instead of four steps with four exclusive-ors. This results in about a; * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.; */; /* @(#) $Id$ */; /*; Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore; protection on the static variables used to control the first-use generation; of the crc tables. Therefore, if you #define DYNAMIC_CRC_TABLE, you should; first call get_crc_table() to initialize the tables before allowing more than; one thread to use crc32().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/crc32.c:514,Power,Power,514,graf2d/asimage/src/libAfterImage/zlib/crc32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/crc32.c,1,['Power'],['Power']
Energy Efficiency,"/* crc32.c -- compute the CRC-32 of a data stream; * Copyright (C) 1995-2006, 2010, 2011, 2012 Mark Adler; * For conditions of distribution and use, see copyright notice in zlib.h; *; * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster; * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing; * tables for updating the shift register in one step with three exclusive-ors; * instead of four steps with four exclusive-ors. This results in about a; * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.; */; /* @(#) $Id$ */; /*; Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore; protection on the static variables used to control the first-use generation; of the crc tables. Therefore, if you #define DYNAMIC_CRC_TABLE, you should; first call get_crc_table() to initialize the tables before allowing more than; one thread to use crc32(). DYNAMIC_CRC_TABLE and MAKECRCH can be #defined to write out crc32.h.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/crc32.c:532,Power,Power,532,builtins/zlib/crc32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/crc32.c,2,['Power'],['Power']
Energy Efficiency,"/* current operating mode */; /* If using just a strip buffer, this points to the entire set of buffers; * (we allocate one for each component). In the full-image case, this; * points to the currently accessible strips of the virtual arrays.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmainct.c:111,allocate,allocate,111,graf2d/asimage/src/libAfterImage/libjpeg/jcmainct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmainct.c,1,['allocate'],['allocate']
Energy Efficiency,"/* data points to the place where the message is stored when passed to; 	 * the websocket_data callback. This is either mem on the stack, or a; 	 * dynamically allocated buffer if it is too large. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:160,allocate,allocated,160,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['allocate'],['allocated']
Energy Efficiency,/* do it! calculate the energy/cost for that route */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx:24,energy,energy,24,math/mathmore/test/simanTSP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx,1,['energy'],['energy']
Energy Efficiency,/* don't allocate that. It's just a way to be more restrictive than void* */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:9,allocate,allocate,9,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['allocate'],['allocate']
Energy Efficiency,/* don't allocate that. It's only meant to be more restrictive than void* */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:9,allocate,allocate,9,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['allocate'],['allocate']
Energy Efficiency,/* else power is 0 and d is 1 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:8,power,power,8,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['power'],['power']
Energy Efficiency,/* ensure nbJobs is a power of 2 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c:22,power,power,22,builtins/zstd/compress/zstdmt_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c,2,['power'],['power']
Energy Efficiency,"/* estimateCCtxSize is for one-shot compression. So no buffers should; * be needed. However, we still allocate two 0-sized buffers, which can; * take space under ASAN. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:102,allocate,allocate,102,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['allocate'],['allocate']
Energy Efficiency,/* even-power-of-two zeros operator */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/crc32.c:8,power,power-of-two,8,builtins/zlib/crc32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/crc32.c,3,['power'],['power-of-two']
Energy Efficiency,"/* finally, it's all reduced to the easy case */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c:21,reduce,reduced,21,interpreter/llvm-project/llvm/lib/Support/regcomp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c,1,['reduce'],['reduced']
Energy Efficiency,/* flag optional arrays not allocated */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:28,allocate,allocated,28,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['allocate'],['allocated']
Energy Efficiency,"/* for safety if init fails */; /* Check for configuration errors.; * SIZEOF(ALIGN_TYPE) should be a power of 2; otherwise, it probably; * doesn't reflect any real hardware alignment requirement.; * The test is a little tricky: for X>0, X and X-1 have no one-bits; * in common if and only if X is a power of 2, ie has only one one-bit.; * Some compilers may give an ""unreachable code"" warning here; ignore it.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:101,power,power,101,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,2,['power'],['power']
Energy Efficiency,/* for use in red green blue files */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:18,green,green,18,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,2,['green'],['green']
Energy Efficiency,/* free previously allocated message and clear */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzlib.c:19,allocate,allocated,19,builtins/zlib/gzlib.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzlib.c,1,['allocate'],['allocated']
Energy Efficiency,"/* g_date_new() returns an invalid date, you then have to _set() stuff; * to get a usable object. You can also allocate a GDate statically,; * then call g_date_clear() to initialize.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gdate.h:111,allocate,allocate,111,graf2d/win32gdk/gdk/src/glib/gdate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gdate.h,1,['allocate'],['allocate']
Energy Efficiency,"/* g_strlcat; *; * Appends string src to buffer dest (of buffer size dest_size).; * At most dest_size-1 characters will be copied.; * Unlike strncat, dest_size is the full size of dest, not the space left over.; * This function does NOT allocate memory.; * This always NUL terminates (unless siz == 0 or there were no NUL characters; * in the dest_size characters of dest to start with).; * Returns size of attempted result, which is; * MIN (dest_size, strlen (original dest)) + strlen (src),; * so if retval >= dest_size, truncation occurred.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstrfuncs.c:237,allocate,allocate,237,graf2d/win32gdk/gdk/src/glib/gstrfuncs.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstrfuncs.c,1,['allocate'],['allocate']
Energy Efficiency,/* gcc needs inline assembly */; /* Adapted from https://github.com/google/highwayhash/blob/master/highwayhash/hh_vsx.h. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:36,Adapt,Adapted,36,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['Adapt'],['Adapted']
Energy Efficiency,/* green */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/visualinfo.c:3,green,green,3,builtins/glew/src/visualinfo.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/visualinfo.c,7,['green'],['green']
Energy Efficiency,/* green has highier priority then red */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.c:3,green,green,3,graf2d/asimage/src/libAfterImage/asvisual.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.c,3,['green'],['green']
Energy Efficiency,/* green size */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/visualinfo.c:3,green,green,3,builtins/glew/src/visualinfo.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/visualinfo.c,1,['green'],['green']
Energy Efficiency,"/* green was max, then blue*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.c:3,green,green,3,graf2d/asimage/src/libAfterImage/blender.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.c,1,['green'],['green']
Energy Efficiency,"/* green was max, then red */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.c:3,green,green,3,graf2d/asimage/src/libAfterImage/blender.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.c,1,['green'],['green']
Energy Efficiency,/* hash table of allocated colors */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkcc.h:17,allocate,allocated,17,graf2d/win32gdk/gdk/src/gdk/gdkcc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkcc.h,1,['allocate'],['allocated']
Energy Efficiency,"/* histogram is garbage now */; /* Allocate storage for the completed colormap, if required.; * We do this now since it is FAR storage and may affect; * the memory manager's space calculations.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:35,Allocate,Allocate,35,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* if input and dictionary overlap : reduce dictionary (area presumed modified by input) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h:37,reduce,reduce,37,builtins/zstd/compress/zstd_compress_internal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h,1,['reduce'],['reduce']
Energy Efficiency,"/* if it hasn't been done already, allocate space for the window */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c:35,allocate,allocate,35,builtins/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c,2,['allocate'],['allocate']
Energy Efficiency,"/* if there are no points, return back */; /*; * Allocate memory for colors; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/X3DBuffer.c:49,Allocate,Allocate,49,graf3d/g3d/src/X3DBuffer.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/X3DBuffer.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/* inflate.c -- zlib decompression; * Copyright (C) 1995-2005 Mark Adler; * For conditions of distribution and use, see copyright notice in zlib.h; */; /*; * Change history:; *; * 1.2.beta0 24 Nov 2002; * - First version -- complete rewrite of inflate to simplify code, avoid; * creation of window when not needed, minimize use of window when it is; * needed, make inffast.c even faster, implement gzip decoding, and to; * improve code readability and style over the previous zlib inflate code; *; * 1.2.beta1 25 Nov 2002; * - Use pointers for available input and output checking in inffast.c; * - Remove input and output counters in inffast.c; * - Change inffast.c entry and loop from avail_in >= 7 to >= 6; * - Remove unnecessary second byte pull from length extra in inffast.c; * - Unroll direct copy to three copies per loop in inffast.c; *; * 1.2.beta2 4 Dec 2002; * - Change external routine names to reduce potential conflicts; * - Correct filename to inffixed.h for fixed tables in inflate.c; * - Make hbuf[] unsigned char to match parameter type in inflate.c; * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset); * to avoid negation problem on Alphas (64 bit) in inflate.c; *; * 1.2.beta3 22 Dec 2002; * - Add comments on state->bits assertion in inffast.c; * - Add comments on op field in inftrees.h; * - Fix bug in reuse of allocated window after inflateReset(); * - Remove bit fields--back to byte structure for speed; * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths; * - Change post-increments to pre-increments in inflate_fast(), PPC biased?; * - Add compile time option, POSTINC, to use post-increments instead (Intel?); * - Make MATCH copy in inflate() much faster for when inflate_fast() not used; * - Use local copies of stream next and avail values, as well as local bit; * buffer and bit count in inflate()--for speed when inflate_fast() not used; *; * 1.2.beta4 1 Jan 2003; * - Split ptr - 257 statements in inflate_table(",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inflate.c:907,reduce,reduce,907,graf2d/asimage/src/libAfterImage/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inflate.c,1,['reduce'],['reduce']
Energy Efficiency,"/* inflate.c -- zlib decompression; * Copyright (C) 1995-2012 Mark Adler; * For conditions of distribution and use, see copyright notice in zlib.h; */; /*; * Change history:; *; * 1.2.beta0 24 Nov 2002; * - First version -- complete rewrite of inflate to simplify code, avoid; * creation of window when not needed, minimize use of window when it is; * needed, make inffast.c even faster, implement gzip decoding, and to; * improve code readability and style over the previous zlib inflate code; *; * 1.2.beta1 25 Nov 2002; * - Use pointers for available input and output checking in inffast.c; * - Remove input and output counters in inffast.c; * - Change inffast.c entry and loop from avail_in >= 7 to >= 6; * - Remove unnecessary second byte pull from length extra in inffast.c; * - Unroll direct copy to three copies per loop in inffast.c; *; * 1.2.beta2 4 Dec 2002; * - Change external routine names to reduce potential conflicts; * - Correct filename to inffixed.h for fixed tables in inflate.c; * - Make hbuf[] unsigned char to match parameter type in inflate.c; * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset); * to avoid negation problem on Alphas (64 bit) in inflate.c; *; * 1.2.beta3 22 Dec 2002; * - Add comments on state->bits assertion in inffast.c; * - Add comments on op field in inftrees.h; * - Fix bug in reuse of allocated window after inflateReset(); * - Remove bit fields--back to byte structure for speed; * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths; * - Change post-increments to pre-increments in inflate_fast(), PPC biased?; * - Add compile time option, POSTINC, to use post-increments instead (Intel?); * - Make MATCH copy in inflate() much faster for when inflate_fast() not used; * - Use local copies of stream next and avail values, as well as local bit; * buffer and bit count in inflate()--for speed when inflate_fast() not used; *; * 1.2.beta4 1 Jan 2003; * - Split ptr - 257 statements in inflate_table(",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c:907,reduce,reduce,907,builtins/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c,1,['reduce'],['reduce']
Energy Efficiency,"/* inftrees.c -- generate Huffman trees for efficient decoding; * Copyright (C) 1995-2005 Mark Adler; * For conditions of distribution and use, see copyright notice in zlib.h; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inftrees.c:44,efficient,efficient,44,graf2d/asimage/src/libAfterImage/zlib/inftrees.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inftrees.c,1,['efficient'],['efficient']
Energy Efficiency,"/* inftrees.c -- generate Huffman trees for efficient decoding; * Copyright (C) 1995-2013 Mark Adler; * For conditions of distribution and use, see copyright notice in zlib.h; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inftrees.c:44,efficient,efficient,44,builtins/zlib/inftrees.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inftrees.c,1,['efficient'],['efficient']
Energy Efficiency,"/* init from vector, takes the vector Y, ; returns pointer to the newly allocated and initialized state */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/mixmax.h:72,allocate,allocated,72,math/mathcore/src/mixmax.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/mixmax.h,1,['allocate'],['allocated']
Energy Efficiency,/* initialize state for F-S dither */; /* Allocate Floyd-Steinberg workspace if didn't already. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c:42,Allocate,Allocate,42,graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,1,['Allocate'],['Allocate']
Energy Efficiency,/* interpolation of blue from green + (B-G) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c:30,green,green,30,graf2d/asimage/src/libAfterImage/scanline.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c,1,['green'],['green']
Energy Efficiency,/* interpolation of green */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c:20,green,green,20,graf2d/asimage/src/libAfterImage/scanline.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c,1,['green'],['green']
Energy Efficiency,/* interpolation of red from green + (R-G) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c:29,green,green,29,graf2d/asimage/src/libAfterImage/scanline.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c,1,['green'],['green']
Energy Efficiency,/* last value must be a clean power of 2 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/entropy_common.c:30,power,power,30,builtins/zstd/common/entropy_common.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/entropy_common.c,1,['power'],['power']
Energy Efficiency,"/* length of code for each symbol */; /* If no code has been allocated for a symbol S, ehufsi[S] contains 0 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:61,allocate,allocated,61,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,2,['allocate'],['allocated']
Energy Efficiency,/* make sure we haven't already allocated memory */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzlib.c:32,allocate,allocated,32,builtins/zlib/gzlib.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzlib.c,1,['allocate'],['allocated']
Energy Efficiency,/* malloced strip size (allocated) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c:24,allocate,allocated,24,interpreter/llvm-project/llvm/lib/Support/regcomp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c,1,['allocate'],['allocated']
Energy Efficiency,/* mask flag and opcode */; /* Variables used for connection monitoring */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:61,monitor,monitoring,61,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['monitor'],['monitoring']
Energy Efficiency,/* meters per pixel */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:3,meter,meters,3,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['meter'],['meters']
Energy Efficiency,/* must be ZSTD_BLOCKSIZE_MAX allocated */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/zdict.c:30,allocate,allocated,30,builtins/zstd/dictBuilder/zdict.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/zdict.c,1,['allocate'],['allocated']
Energy Efficiency,/* newly allocated buffer */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c:9,allocate,allocated,9,graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c,1,['allocate'],['allocated']
Energy Efficiency,/* no available blocks found - need to allocate a new block */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.c:39,allocate,allocate,39,graf2d/asimage/src/libAfterImage/asstorage.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.c,1,['allocate'],['allocate']
Energy Efficiency,/* no buffers allocated yet */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzlib.c:14,allocate,allocated,14,builtins/zlib/gzlib.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzlib.c,1,['allocate'],['allocated']
Energy Efficiency,/* no. of allocated colors */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkcc.h:10,allocate,allocated,10,graf2d/win32gdk/gdk/src/gdk/gdkcc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkcc.h,1,['allocate'],['allocated']
Energy Efficiency,/* no. of colors allocated yet */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:17,allocate,allocated,17,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,1,['allocate'],['allocated']
Energy Efficiency,/* not allocated */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c:7,allocate,allocated,7,graf2d/asimage/src/libAfterImage/libpng/pngerror.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c,1,['allocate'],['allocated']
Energy Efficiency,"/* not first */; /* wait for the other guy to finish (not efficient, but rare) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/crc32.c:58,efficient,efficient,58,builtins/zlib/crc32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/crc32.c,3,['efficient'],['efficient']
Energy Efficiency,/* nothing to do on PowerPC. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h:20,Power,PowerPC,20,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,2,['Power'],['PowerPC']
Energy Efficiency,"/* now that we have smooth subtrate of green - we can build red/blue channels : ; * 1) Calculate R-G difference for all RG lines, averaging missing values from 2 neightbours; * 2) Calculate R-G difference for all GB lines, averaging values from lines above and below it.; * 3) Calculate ALL RED values by adding calulated difference to Green channel.; * Do the same for BLUE.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c:39,green,green,39,graf2d/asimage/src/libAfterImage/scanline.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c,2,"['Green', 'green']","['Green', 'green']"
Energy Efficiency,/* number of csets allocated */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c:19,allocate,allocated,19,interpreter/llvm-project/llvm/lib/Support/regcomp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c,1,['allocate'],['allocated']
Energy Efficiency,"/* number of such rows needed */; /* For single-pass compression, it's sufficient to buffer just one MCU; * (although this may prove a bit slow in practice). We allocate a; * workspace of C_MAX_BLOCKS_IN_MCU coefficient blocks, and reuse it for each; * MCU constructed and sent. (On 80x86, the workspace is FAR even though; * it's not really very big; this is to keep the module interfaces unchanged; * when a large coefficient buffer is necessary.); * In multi-pass modes, this array points to the current MCU's blocks; * within the virtual arrays.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c:161,allocate,allocate,161,graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c,1,['allocate'],['allocate']
Energy Efficiency,"/* number of such rows needed */; /* The output side's location is represented by cinfo->output_iMCU_row. */; /* In single-pass modes, it's sufficient to buffer just one MCU.; * We allocate a workspace of D_MAX_BLOCKS_IN_MCU coefficient blocks,; * and let the entropy decoder write into that workspace each time.; * (On 80x86, the workspace is FAR even though it's not really very big;; * this is to keep the module interfaces unchanged when a large coefficient; * buffer is necessary.); * In multi-pass modes, this array points to the current MCU's blocks; * within the virtual arrays; it is used only by the input side.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c:181,allocate,allocate,181,graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c,1,['allocate'],['allocate']
Energy Efficiency,/* odd-power-of-two zeros operator */; /* degenerate case (also disallow negative lengths) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/crc32.c:7,power,power-of-two,7,builtins/zlib/crc32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/crc32.c,2,['power'],['power-of-two']
Energy Efficiency,/* odd-power-of-two zeros operator */; /* degenerate case */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/crc32.c:7,power,power-of-two,7,graf2d/asimage/src/libAfterImage/zlib/crc32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/crc32.c,1,['power'],['power-of-two']
Energy Efficiency,"/* only allow pulling `cacheSize` number of entries; * into the cache or chainTable beyond `minChain`,; * to replace the entries pulled out of the; * chainTable into the cache. This lets us reach; * back further without increasing the total number; * of entries in the chainTable, guaranteeing the; * DDSS chain table will fit into the space; * allocated for the regular one. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_lazy.c:345,allocate,allocated,345,builtins/zstd/compress/zstd_lazy.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_lazy.c,1,['allocate'],['allocated']
Energy Efficiency,"/* otherwise, a sufficient buffer is allocated, but we need to; * reset it to the correct context type */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c:37,allocate,allocated,37,builtins/lz4/lz4frame.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c,1,['allocate'],['allocated']
Energy Efficiency,/* pixels/meter */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:10,meter,meter,10,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['meter'],['meter']
Energy Efficiency,/* power of 2 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:3,power,power,3,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['power'],['power']
Energy Efficiency,/* power series */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,power,power,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,3,['power'],['power']
Energy Efficiency,/* pthread adaptation */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:11,adapt,adaptation,11,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,1,['adapt'],['adaptation']
Energy Efficiency,"/* public fields */; /* Color conversion buffer. When using separate upsampling and color; * conversion steps, this buffer holds one upsampled row group until it; * has been color converted and output.; * Note: we do not allocate any storage for component(s) which are full-size,; * ie do not need rescaling. The corresponding entry of color_buf[] is; * simply set to point to the input data array, thereby avoiding copying.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdsample.c:221,allocate,allocate,221,graf2d/asimage/src/libAfterImage/libjpeg/jdsample.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdsample.c,1,['allocate'],['allocate']
Energy Efficiency,/* public fields */; /* Initially allocated colormap is saved here */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c:34,allocate,allocated,34,graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,1,['allocate'],['allocated']
Energy Efficiency,/* public fields */; /* Pointer to allocated workspace (M or M+2 row groups). */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c:35,allocate,allocated,35,graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c,1,['allocate'],['allocated']
Energy Efficiency,/* pure green */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.c:8,green,green,8,graf2d/asimage/src/libAfterImage/asvisual.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.c,1,['green'],['green']
Energy Efficiency,"/* red was max, then green */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.c:21,green,green,21,graf2d/asimage/src/libAfterImage/blender.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.c,1,['green'],['green']
Energy Efficiency,/* red/green/blue */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jpeglib.h:7,green,green,7,graf2d/asimage/src/libAfterImage/libjpeg/jpeglib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jpeglib.h,1,['green'],['green']
Energy Efficiency,/* reduce code size; check here not in the caller */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:3,reduce,reduce,3,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['reduce'],['reduce']
Energy Efficiency,/* reduce lazy search above this match length */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:3,reduce,reduce,3,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,4,['reduce'],['reduce']
Energy Efficiency,/* reduce maxLength in case of final into repetitive data */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/zdict.c:3,reduce,reduce,3,builtins/zstd/dictBuilder/zdict.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/zdict.c,1,['reduce'],['reduce']
Energy Efficiency,"/* reduce the dictionary size if larger than 1/4 the input size, preset; dictionaries size can be expensively large; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/lzma/src/ZipLZMA.c:3,reduce,reduce,3,core/lzma/src/ZipLZMA.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/lzma/src/ZipLZMA.c,1,['reduce'],['reduce']
Energy Efficiency,"/* sRGB sets known gamma, end points and (from the chunk) intent. */; /* IMPORTANT: these are not necessarily the values found in an ICC profile; * because ICC profiles store values adapted to a D50 environment; it is; * expected that the ICC profile mediaWhitePointTag will be D50; see the; * checks and code elsewhere to understand this better.; *; * These XYZ values, which are accurate to 5dp, produce rgb to gray; * coefficients of (6968,23435,2366), which are reduced (because they add up; * to 32769 not 32768) to (6968,23434,2366). These are the values that; * libpng has traditionally used (and are the best values given the 15bit; * algorithm used by the rgb to gray code.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:182,adapt,adapted,182,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,2,"['adapt', 'reduce']","['adapted', 'reduced']"
Energy Efficiency,"/* samples is a two-dimensional double array with length k;; it stores an array of k pointers to double arrays which are; the k samples being compared */; // double **samples;; /* dynamically allocate memory */; //std::vector< std::vector<double> > samples(k);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GoFTest.cxx:192,allocate,allocate,192,math/mathcore/src/GoFTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GoFTest.cxx,1,['allocate'],['allocate']
Energy Efficiency,"/* scaling factor for litFreq, so that frequencies adapt faster to new stats */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c:51,adapt,adapt,51,builtins/zstd/compress/zstd_opt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c,1,['adapt'],['adapt']
Energy Efficiency,/* search allocated colors */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:10,allocate,allocated,10,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,2,['allocate'],['allocated']
Energy Efficiency,/* set table size in stack */; /* allocate and link in new table */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c:34,allocate,allocate,34,core/zip/src/ZInflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c,1,['allocate'],['allocate']
Energy Efficiency,"/* size of the above, if allocated */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h:25,allocate,allocated,25,graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,1,['allocate'],['allocated']
Energy Efficiency,/* space for slots is allocated in 16 byte increments */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.h:22,allocate,allocated,22,graf2d/asimage/src/libAfterImage/asstorage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.h,1,['allocate'],['allocated']
Energy Efficiency,/* statically allocated in resetCCtx */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:14,allocate,allocated,14,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,4,['allocate'],['allocated']
Energy Efficiency,"/* std::cout << ""start monitoring"" << std::endl; */; /* std::cout << "" new tapp "" << std::endl; */; /* fApplication = new TApplication (""TMVA Monitoring"", 0, 0); */; /* std::cout << "" set return from run"" << std::endl; */; /* // fApplication->SetReturnFromRun (true); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Monitoring.h:23,monitor,monitoring,23,tmva/tmva/inc/TMVA/Monitoring.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Monitoring.h,2,"['Monitor', 'monitor']","['Monitoring', 'monitoring']"
Energy Efficiency,/* step 3. Calculating BLUE from green + R-G */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c:33,green,green,33,graf2d/asimage/src/libAfterImage/scanline.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c,1,['green'],['green']
Energy Efficiency,/* step 3. Calculating RED from green + R-G */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c:32,green,green,32,graf2d/asimage/src/libAfterImage/scanline.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c,1,['green'],['green']
Energy Efficiency,"/* successfully allocated, store it */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:16,allocate,allocated,16,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,2,['allocate'],['allocated']
Energy Efficiency,/* system-dependent initialization */; /* Attempt to allocate memory manager's control block */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:53,allocate,allocate,53,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,1,['allocate'],['allocate']
Energy Efficiency,/* temporary XImages to be allocated from static pool of memory :*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:27,allocate,allocated,27,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,1,['allocate'],['allocated']
Energy Efficiency,"/* the mem array from which atoms get allocated; 			 * the actual size of this array is determined by; 			 * the mem chunk ""area_size"". ANSI says that it; 			 * must be declared to be the maximum size it; 			 * can possibly be (even though the actual size; 			 * may be less).; 			 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c:38,allocate,allocated,38,graf2d/win32gdk/gdk/src/glib/gmem.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c,1,['allocate'],['allocated']
Energy Efficiency,/* the number of atoms allocated from this area */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c:23,allocate,allocated,23,graf2d/win32gdk/gdk/src/glib/gmem.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c,1,['allocate'],['allocated']
Energy Efficiency,/* try to allocate this color */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:10,allocate,allocate,10,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,1,['allocate'],['allocate']
Energy Efficiency,"/* type for top-level pointer */; /* Declarations for Floyd-Steinberg dithering.; *; * Errors are accumulated into the array fserrors[], at a resolution of; * 1/16th of a pixel count. The error at a given pixel is propagated; * to its not-yet-processed neighbors using the standard F-S fractions,; *		...	(here)	7/16; *		3/16	5/16	1/16; * We work left-to-right on even rows, right-to-left on odd rows.; *; * We can get away with a single array (holding one row's worth of errors); * by using it to store the current row's errors at pixel columns not yet; * processed, but the next row's errors at columns already processed. We; * need only a few extra variables to hold the errors immediately around the; * current column. (If we are lucky, those variables are in registers, but; * even if not, they're probably cheaper to access than array elements are.); *; * The fserrors[] array has (#columns + 2) entries; the extra entry at; * each end saves us from special-casing the first and last pixels.; * Each entry is three values long, one value for each color component.; *; * Note: on a wide image, we might not have enough room in a PC's near data; * segment to hold the error array; so it is allocated with alloc_large.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:1194,allocate,allocated,1194,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['allocate'],['allocated']
Energy Efficiency,"/* typedef'd to LZ4F_dctx in lz4frame.h */; /*! LZ4F_createDecompressionContext() :; * Create a decompressionContext object, which will track all decompression operations.; * Provides a pointer to a fully allocated and initialized LZ4F_decompressionContext object.; * Object can later be released using LZ4F_freeDecompressionContext().; * @return : if != 0, there was an error during context creation.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c:205,allocate,allocated,205,builtins/lz4/lz4frame.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c,1,['allocate'],['allocated']
Energy Efficiency,/* until allocated by get_sof */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c:9,allocate,allocated,9,graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,1,['allocate'],['allocated']
Energy Efficiency,/* use the distance_matrix to optimize this calculation; it had; better be allocated!! */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx:75,allocate,allocated,75,math/mathmore/test/simanTSP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx,1,['allocate'],['allocated']
Energy Efficiency,/* use zfree if we ever allocate msg dynamically */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:24,allocate,allocate,24,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,3,['allocate'],['allocate']
Energy Efficiency,/* used to allocate the internal state */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:11,allocate,allocate,11,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,2,['allocate'],['allocate']
Energy Efficiency,/* used[i] is only -1 if the pixel at that location hasn't; * been allocated yet. This is a sanity check required for proper; * color allocation by the progressive image loader.; * When colors[i] == 0 it indicates the slot is available for; * allocation.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:67,allocate,allocated,67,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,1,['allocate'],['allocated']
Energy Efficiency,/* using 3 and -4 would be slightly more efficient on 32-bit machines; with > 1bpp displays */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkrgb.c:41,efficient,efficient,41,graf2d/win32gdk/gdk/src/gdk/gdkrgb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkrgb.c,1,['efficient'],['efficient']
Energy Efficiency,/* want to deallocate if too much is allocated ? */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.c:37,allocate,allocated,37,graf2d/asimage/src/libAfterImage/asvisual.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.c,1,['allocate'],['allocated']
Energy Efficiency,/* we allocate pointers to slots in batches of one page eache */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.h:6,allocate,allocate,6,graf2d/asimage/src/libAfterImage/asstorage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.h,1,['allocate'],['allocate']
Energy Efficiency,/* we need to allocate new usable list of colors based on available bpp */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.c:14,allocate,allocate,14,graf2d/asimage/src/libAfterImage/asvisual.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.c,1,['allocate'],['allocate']
Energy Efficiency,/* width and height must be the power of 2 !!! */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ximage.c:32,power,power,32,graf2d/asimage/src/libAfterImage/ximage.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ximage.c,1,['power'],['power']
Energy Efficiency,"/* window size--must be a power of two, and at least */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c:26,power,power,26,core/zip/src/ZInflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c,1,['power'],['power']
Energy Efficiency,"/* zlib can't necessarily handle more than 65535 bytes at once (i.e. it; * can't even necessarily handle 65536 bytes) because the type uInt is; * ""16 bits or more"". Consequently it is necessary to chunk the input to; * zlib. This code uses ZLIB_IO_MAX, from pngpriv.h, as the maximum (the; * maximum value that can be stored in a uInt.) It is possible to set; * ZLIB_IO_MAX to a lower value in pngpriv.h and this may sometimes have; * a performance advantage, because it reduces the amount of data accessed; * at each step and that may give the OS more time to page it in.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:471,reduce,reduces,471,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['reduce'],['reduces']
Energy Efficiency,"/*! FSE_buildCTable():; Builds `ct`, which must be already allocated, using FSE_createCTable().; @return : 0, or an errorCode, which can be tested using FSE_isError() */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:59,allocate,allocated,59,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['allocate'],['allocated']
Energy Efficiency,"/*! FSE_buildDTable():; Builds 'dt', which must be already allocated, using FSE_createDTable().; return : 0, or an errorCode, which can be tested using FSE_isError() */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:59,allocate,allocated,59,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['allocate'],['allocated']
Energy Efficiency,"/*! FSE_compress_usingCTable():; Compress `src` using `ct` into `dst` which must be already allocated.; @return : size of compressed data (<= `dstCapacity`),; or 0 if compressed data could not fit into `dst`,; or an errorCode, which can be tested using FSE_isError() */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:92,allocate,allocated,92,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['allocate'],['allocated']
Energy Efficiency,"/*! FSE_decompress():; Decompress FSE data from buffer 'cSrc', of size 'cSrcSize',; into already allocated destination buffer 'dst', of size 'dstCapacity'.; @return : size of regenerated data (<= maxDstSize),; or an error code, which can be tested using FSE_isError() . ** Important ** : FSE_decompress() does not decompress non-compressible nor RLE data !!!; Why ? : making this distinction requires a header.; Header management is intentionally delegated to the user layer, which can better manage special cases.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:97,allocate,allocated,97,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['allocate'],['allocated']
Energy Efficiency,"/*! FSE_decompress_usingDTable():; Decompress compressed source `cSrc` of size `cSrcSize` using `dt`; into `dst` which must be already allocated.; @return : size of regenerated data (necessarily <= `dstCapacity`),; or an errorCode, which can be tested using FSE_isError() */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:135,allocate,allocated,135,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['allocate'],['allocated']
Energy Efficiency,"/*! In-place compression and decompression; *; * It's possible to have input and output sharing the same buffer,; * for highly contrained memory environments.; * In both cases, it requires input to lay at the end of the buffer,; * and decompression to start at beginning of the buffer.; * Buffer size must feature some margin, hence be larger than final size.; *; * |<------------------------buffer--------------------------------->|; * |<-----------compressed data--------->|; * |<-----------decompressed size------------------>|; * |<----margin---->|; *; * This technique is more useful for decompression,; * since decompressed size is typically larger,; * and margin is short.; *; * In-place decompression will work inside any buffer; * which size is >= LZ4_DECOMPRESS_INPLACE_BUFFER_SIZE(decompressedSize).; * This presumes that decompressedSize > compressedSize.; * Otherwise, it means compression actually expanded data,; * and it would be more efficient to store such data with a flag indicating it's not compressed.; * This can happen when data is not compressible (already compressed, or encrypted).; *; * For in-place compression, margin is larger, as it must be able to cope with both; * history preservation, requiring input data to remain unmodified up to LZ4_DISTANCE_MAX,; * and data expansion, which can happen when input is not compressible.; * As a consequence, buffer size requirements are much higher,; * and memory savings offered by in-place compression are more limited.; *; * There are ways to limit this cost for compression :; * - Reduce history size, by modifying LZ4_DISTANCE_MAX.; * Note that it is a compile-time constant, so all compressions will apply this limit.; * Lower values will reduce compression ratio, except when input_size < LZ4_DISTANCE_MAX,; * so it's a reasonable trick when inputs are known to be small.; * - Require the compressor to deliver a ""maximum compressed size"".; * This is the `dstCapacity` parameter in `LZ4_compress*()`.; * When this size is ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:951,efficient,efficient,951,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['efficient'],['efficient']
Energy Efficiency,"/*! LZ4F_decodeHeader() :; * input : `src` points at the **beginning of the frame**; * output : set internal values of dctx, such as; * dctx->frameInfo and dctx->dStage.; * Also allocates internal buffers.; * @return : nb Bytes read from src (necessarily <= srcSize); * or an error code (testable with LZ4F_isError()); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c:178,allocate,allocates,178,builtins/lz4/lz4frame.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c,1,['allocate'],['allocates']
Energy Efficiency,"/*! LZ4F_getFrameInfo() :; * This function extracts frame parameters (max blockSize, frame checksum, etc.).; * Usage is optional. Objective is to provide relevant information for allocation purposes.; * This function works in 2 situations :; * - At the beginning of a new frame, in which case it will decode this information from `srcBuffer`, and start the decoding process.; * Amount of input data provided must be large enough to successfully decode the frame header.; * A header size is variable, but is guaranteed to be <= LZ4F_HEADER_SIZE_MAX bytes. It's possible to provide more input data than this minimum.; * - After decoding has been started. In which case, no input is read, frame parameters are extracted from dctx.; * The number of bytes consumed from srcBuffer will be updated within *srcSizePtr (necessarily <= original value).; * Decompression must resume from (srcBuffer + *srcSizePtr).; * @return : an hint about how many srcSize bytes LZ4F_decompress() expects for next call,; * or an error code which can be tested using LZ4F_isError(); * note 1 : in case of error, dctx is not modified. Decoding operations can resume from where they stopped.; * note 2 : frame parameters are *copied into* an already allocated LZ4F_frameInfo_t structure.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c:1222,allocate,allocated,1222,builtins/lz4/lz4frame.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c,1,['allocate'],['allocated']
Energy Efficiency,"/*! LZ4_attach_dictionary() :; * This is an experimental API that allows; * efficient use of a static dictionary many times.; *; * Rather than re-loading the dictionary buffer into a working context before; * each compression, or copying a pre-loaded dictionary's LZ4_stream_t into a; * working LZ4_stream_t, this function introduces a no-copy setup mechanism,; * in which the working stream references the dictionary stream in-place.; *; * Several assumptions are made about the state of the dictionary stream.; * Currently, only streams which have been prepared by LZ4_loadDict() should; * be expected to work.; *; * Alternatively, the provided dictionaryStream may be NULL,; * in which case any existing dictionary stream is unset.; *; * If a dictionary is provided, it replaces any pre-existing stream history.; * The dictionary contents are the only history that can be referenced and; * logically immediately precede the data compressed in the first subsequent; * compression call.; *; * The dictionary will only remain attached to the working stream through the; * first compression call, at the end of which it is cleared. The dictionary; * stream (and source buffer) must remain in-place / accessible / unchanged; * through the completion of the first compression call on the stream.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:76,efficient,efficient,76,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['efficient'],['efficient']
Energy Efficiency,"/*! LZ4_compress_destSize() :; * Reverse the logic : compresses as much data as possible from 'src' buffer; * into already allocated buffer 'dst', of size >= 'targetDestSize'.; * This function either compresses the entire 'src' content into 'dst' if it's large enough,; * or fill 'dst' buffer completely with as much data as possible from 'src'.; * note: acceleration parameter is fixed to ""default"".; *; * *srcSizePtr : will be modified to indicate how many bytes where read from 'src' to fill 'dst'.; * New value is necessarily <= input value.; * @return : Nb bytes written into 'dst' (necessarily <= targetDestSize); * or 0 if compression fails.; *; * Note : from v1.8.2 to v1.9.1, this function had a bug (fixed un v1.9.2+):; * the produced compressed content could, in specific circumstances,; * require to be decompressed into a destination buffer larger; * by at least 1 byte than the content to decompress.; * If an application uses `LZ4_compress_destSize()`,; * it's highly recommended to update liblz4 to v1.9.2 or better.; * If this can't be done or ensured,; * the receiving decompression function should provide; * a dstCapacity which is > decompressedSize, by at least 1 byte.; * See https://github.com/lz4/lz4/issues/859 for details; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:123,allocate,allocated,123,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['allocate'],['allocated']
Energy Efficiency,"/*! LZ4_compress_fast_continue() :; * Compress 'src' content using data from previously compressed blocks, for better compression ratio.; * 'dst' buffer must be already allocated.; * If dstCapacity >= LZ4_compressBound(srcSize), compression is guaranteed to succeed, and runs faster.; *; * @return : size of compressed block; * or 0 if there is an error (typically, cannot fit into 'dst').; *; * Note 1 : Each invocation to LZ4_compress_fast_continue() generates a new block.; * Each block has precise boundaries.; * Each block must be decompressed separately, calling LZ4_decompress_*() with relevant metadata.; * It's not possible to append blocks together and expect a single invocation of LZ4_decompress_*() to decompress them together.; *; * Note 2 : The previous 64KB of source data is __assumed__ to remain present, unmodified, at same address in memory !; *; * Note 3 : When input is structured as a double-buffer, each buffer can have any size, including < 64 KB.; * Make sure that buffers are separated, by at least one byte.; * This construction ensures that each block only depends on previous block.; *; * Note 4 : If input buffer is a ring-buffer, it can have any size, including < 64 KB.; *; * Note 5 : After an error, the stream status is undefined (invalid), it can only be reset or freed.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:169,allocate,allocated,169,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['allocate'],['allocated']
Energy Efficiency,"/*! LZ4_compress_fast_extState() :; * Same as LZ4_compress_fast(), using an externally allocated memory space for its state.; * Use LZ4_sizeofState() to know how much memory must be allocated,; * and allocate it on 8-bytes boundaries (using `malloc()` typically).; * Then, provide this buffer as `void* state` to compression function.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:87,allocate,allocated,87,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,3,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"/*! LZ4_decompress_safe() :; * compressedSize : is the exact complete size of the compressed block.; * dstCapacity : is the size of destination buffer (which must be already allocated), presumed an upper bound of decompressed size.; * @return : the number of bytes decompressed into destination buffer (necessarily <= dstCapacity); * If destination buffer is not large enough, decoding will stop and output an error code (negative value).; * If the source stream is detected malformed, the function will stop decoding and return a negative result.; * Note 1 : This function is protected against malicious data packets :; * it will never writes outside 'dst' buffer, nor read outside 'source' buffer,; * even if the compressed block is maliciously modified to order the decoder to do these actions.; * In such case, the decoder stops immediately, and considers the compressed block malformed.; * Note 2 : compressedSize and dstCapacity must be provided to the function, the compressed block does not contain them.; * The implementation is free to send / store / derive this information in whichever way is most beneficial.; * If there is a need for a different format which bundles together both compressed data and its metadata, consider looking at lz4frame.h instead.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:174,allocate,allocated,174,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['allocate'],['allocated']
Energy Efficiency,"/*! LZ4_setStreamDecode() :; * An LZ4_streamDecode_t context can be allocated once and re-used multiple times.; * Use this function to start decompression of a new stream of blocks.; * A dictionary can optionally be set. Use NULL or size 0 for a reset order.; * Dictionary is presumed stable : it must remain accessible and unmodified during next decompression.; * @return : 1 if OK, 0 if error; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:68,allocate,allocated,68,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['allocate'],['allocated']
Energy Efficiency,"/*! LZ4_stream_t :; * Do not use below internal definitions directly !; * Declare or allocate an LZ4_stream_t instead.; * LZ4_stream_t can also be created using LZ4_createStream(), which is recommended.; * The structure definition can be convenient for static allocation; * (on stack, or as part of larger structure).; * Init this structure with LZ4_initStream() before first use.; * note : only use this definition in association with static linking !; * this definition is not API/ABI safe, and may change in future versions.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:85,allocate,allocate,85,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['allocate'],['allocate']
Energy Efficiency,"/*! Obsolete LZ4_decompress_fast variants (since v1.9.0) :; * These functions used to be faster than LZ4_decompress_safe(),; * but this is no longer the case. They are now slower.; * This is because LZ4_decompress_fast() doesn't know the input size,; * and therefore must progress more cautiously into the input buffer to not read beyond the end of block.; * On top of that `LZ4_decompress_fast()` is not protected vs malformed or malicious inputs, making it a security liability.; * As a consequence, LZ4_decompress_fast() is strongly discouraged, and deprecated.; *; * The last remaining LZ4_decompress_fast() specificity is that; * it can decompress a block without knowing its compressed size.; * Such functionality can be achieved in a more secure manner; * by employing LZ4_decompress_safe_partial().; *; * Parameters:; * originalSize : is the uncompressed size to regenerate.; * `dst` must be already allocated, its size must be >= 'originalSize' bytes.; * @return : number of bytes read from source buffer (== compressed size).; * The function expects to finish at block's end exactly.; * If the source stream is detected malformed, the function stops decoding and returns a negative result.; * note : LZ4_decompress_fast*() requires originalSize. Thanks to this information, it never writes past the output buffer.; * However, since it doesn't know its 'src' size, it may read an unknown amount of input, past input buffer bounds.; * Also, since match offsets are not validated, match reads from 'src' may underflow too.; * These issues never happen if input (compressed) data is correct.; * But they may happen if input data is invalid (error or intentional tampering).; * As a consequence, use these functions in trusted environments with trusted data **only**.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:908,allocate,allocated,908,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['allocate'],['allocated']
Energy Efficiency,"/*! POOL_resize() :; * Expands or shrinks pool's number of threads.; * This is more efficient than releasing + creating a new context,; * since it tries to preserve and re-use existing threads.; * `numThreads` must be at least 1.; * @return : 0 when resize was successful,; * !0 (typically 1) if there is an error.; * note : only numThreads can be resized, queueSize remains unchanged.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.h:84,efficient,efficient,84,builtins/zstd/common/pool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.h,1,['efficient'],['efficient']
Energy Efficiency,"/*! ZSTD_DCtx_setMaxWindowSize() :; * Refuses allocating internal buffers for frames requiring a window size larger than provided limit.; * This protects a decoder context from reserving too much memory for itself (potential attack scenario).; * This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode.; * By default, a decompression context accepts all window sizes <= (1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT); * @return : 0, or an error code (which can be tested using ZSTD_isError()).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:323,allocate,allocated,323,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['allocate'],['allocated']
Energy Efficiency,"/*! ZSTD_decompressDCtx() :; * Same as ZSTD_decompress(),; * requires an allocated ZSTD_DCtx.; * Compatible with sticky parameters.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:73,allocate,allocated,73,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['allocate'],['allocated']
Energy Efficiency,/*! ZSTD_freeCDict() :; * Function frees memory allocated by ZSTD_createCDict(). */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:48,allocate,allocated,48,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['allocate'],['allocated']
Energy Efficiency,/*! ZSTD_freeDDict() :; * Function frees memory allocated with ZSTD_createDDict() */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:48,allocate,allocated,48,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['allocate'],['allocated']
Energy Efficiency,"/*! ZSTD_initStaticCDict_advanced() :; * Generate a digested dictionary in provided memory area.; * workspace: The memory area to emplace the dictionary into.; * Provided pointer must 8-bytes aligned.; * It must outlive dictionary usage.; * workspaceSize: Use ZSTD_estimateCDictSize(); * to determine how large workspace must be.; * cParams : use ZSTD_getCParams() to transform a compression level; * into its relevants cParams.; * @return : pointer to ZSTD_CDict*, or NULL if error (size too small); * Note : there is no corresponding ""free"" function.; * Since workspace was allocated externally, it must be freed externally.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:576,allocate,allocated,576,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['allocate'],['allocated']
Energy Efficiency,/*! ZSTD_ldm_reduceTable() :; * reduce table indexes by `reducerValue` */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_ldm.c:32,reduce,reduce,32,builtins/zstd/compress/zstd_ldm.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_ldm.c,2,['reduce'],"['reduce', 'reducerValue']"
Energy Efficiency,"/*! ZSTD_reduceTable() :; * reduce table indexes by `reducerValue`, or squash to zero.; * PreserveMark preserves ""unsorted mark"" for btlazy2 strategy.; * It must be set to a clear 0/1 value, to remove branch during inlining.; * Presume table size is a multiple of ZSTD_ROWSIZE; * to help auto-vectorization */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:28,reduce,reduce,28,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,2,['reduce'],"['reduce', 'reducerValue']"
Energy Efficiency,/*!; * ValueProfRecordClosure Interface implementation for InstrProfRecord; * class. These C wrappers are used as adaptors so that C++ code can be; * invoked as callbacks.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp:114,adapt,adaptors,114,interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,1,['adapt'],['adaptors']
Energy Efficiency,"/*!; * XXH32():; * Calculate the 32-bit hash of sequence ""length"" bytes stored at memory address ""input"".; * The memory between input & input+length must be valid (allocated and read-accessible).; * ""seed"" can be used to alter the result predictably.; * Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark): 5.4 GB/s; *; * Note: XXH3 provides competitive speed for both 32-bit and 64-bit systems,; * and offers true 64/128 bit hash results. It provides a superior level of; * dispersion, and greatly reduces the risks of collisions.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:164,allocate,allocated,164,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,"['allocate', 'reduce']","['allocated', 'reduces']"
Energy Efficiency,"/*!; * XXH64():; * Returns the 64-bit hash of sequence of length @length stored at memory; * address @input.; * @seed can be used to alter the result predictably.; *; * This function usually runs faster on 64-bit systems, but slower on 32-bit; * systems (see benchmark).; *; * Note: XXH3 provides competitive speed for both 32-bit and 64-bit systems,; * and offers true 64/128 bit hash results. It provides a superior level of; * dispersion, and greatly reduces the risks of collisions.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:454,reduce,reduces,454,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['reduce'],['reduces']
Energy Efficiency,"/*!; * XXH_NO_INLINE_HINTS:; *; * By default, xxHash tries to force the compiler to inline almost all internal; * functions.; *; * This can usually improve performance due to reduced jumping and improved; * constant folding, but significantly increases the size of the binary which; * might not be favorable.; *; * Additionally, sometimes the forced inlining can be detrimental to performance,; * depending on the architecture.; *; * XXH_NO_INLINE_HINTS marks all internal functions as static, giving the; * compiler full control on whether to inline or not.; *; * When not optimizing (-O0), optimizing for size (-Os, -Oz), or using; * -fno-inline with GCC or Clang, this will automatically be defined.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:175,reduce,reduced,175,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['reduce'],['reduced']
Energy Efficiency,"/*!; Tutorial :; ----------; (Note : these functions only decompress FSE-compressed blocks.; If block is uncompressed, use memcpy() instead; If block is a single repeated byte, use memset() instead ). The first step is to obtain the normalized frequencies of symbols.; This can be performed by FSE_readNCount() if it was saved using FSE_writeNCount().; 'normalizedCounter' must be already allocated, and have at least 'maxSymbolValuePtr[0]+1' cells of signed short.; In practice, that means it's necessary to know 'maxSymbolValue' beforehand,; or size the table to handle worst case situations (typically 256).; FSE_readNCount() will provide 'tableLog' and 'maxSymbolValue'.; The result of FSE_readNCount() is the number of bytes read from 'rBuffer'.; Note that 'rBufferSize' must be at least 4 bytes, even if useful information is less than that.; If there is an error, the function will return an error code, which can be tested using FSE_isError(). The next step is to build the decompression tables 'FSE_DTable' from 'normalizedCounter'.; This is performed by the function FSE_buildDTable().; The space required by 'FSE_DTable' must be already allocated using FSE_createDTable().; If there is an error, the function will return an error code, which can be tested using FSE_isError(). `FSE_DTable` can then be used to decompress `cSrc`, with FSE_decompress_usingDTable().; `cSrcSize` must be strictly correct, otherwise decompression will fail.; FSE_decompress_usingDTable() result will tell how many bytes were regenerated (<=`dstCapacity`).; If there is an error, the function will return an error code, which can be tested using FSE_isError(). (ex: dst buffer too small); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:389,allocate,allocated,389,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,2,['allocate'],['allocated']
Energy Efficiency,"/*!; Tutorial :; ----------; The first step is to count all symbols. FSE_count() does this job very fast.; Result will be saved into 'count', a table of unsigned int, which must be already allocated, and have 'maxSymbolValuePtr[0]+1' cells.; 'src' is a table of bytes of size 'srcSize'. All values within 'src' MUST be <= maxSymbolValuePtr[0]; maxSymbolValuePtr[0] will be updated, with its real value (necessarily <= original value); FSE_count() will return the number of occurrence of the most frequent symbol.; This can be used to know if there is a single symbol within 'src', and to quickly evaluate its compressibility.; If there is an error, the function will return an ErrorCode (which can be tested using FSE_isError()). The next step is to normalize the frequencies.; FSE_normalizeCount() will ensure that sum of frequencies is == 2 ^'tableLog'.; It also guarantees a minimum of 1 to any Symbol with frequency >= 1.; You can use 'tableLog'==0 to mean ""use default tableLog value"".; If you are unsure of which tableLog value to use, you can ask FSE_optimalTableLog(),; which will provide the optimal valid tableLog given sourceSize, maxSymbolValue, and a user-defined maximum (0 means ""default""). The result of FSE_normalizeCount() will be saved into a table,; called 'normalizedCounter', which is a table of signed short.; 'normalizedCounter' must be already allocated, and have at least 'maxSymbolValue+1' cells.; The return value is tableLog if everything proceeded as expected.; It is 0 if there is a single symbol within distribution.; If there is an error (ex: invalid tableLog value), the function will return an ErrorCode (which can be tested using FSE_isError()). 'normalizedCounter' can be saved in a compact manner to a memory area using FSE_writeNCount().; 'buffer' must be already allocated.; For guaranteed success, buffer size must be at least FSE_headerBound().; The result of the function is the number of bytes written into 'buffer'.; If there is an error, the function will",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:189,allocate,allocated,189,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['allocate'],['allocated']
Energy Efficiency,"/*!< maximum compression level available */; /***************************************; * Explicit context; ***************************************/; /*= Compression context; * When compressing many times,; * it is recommended to allocate a context just once,; * and re-use it for each successive compression operation.; * This will make workload friendlier for system's memory.; * Note : re-using context is just a speed / resource optimization.; * It doesn't change the compression ratio, which remains identical.; * Note 2 : In multi-threaded environments,; * use one different context per thread for parallel execution.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:229,allocate,allocate,229,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['allocate'],['allocate']
Energy Efficiency,"/** ====================================================================; * @license; * jsPDF XMP metadata plugin; * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi; *; * Permission is hereby granted, free of charge, to any person obtaining; * a copy of this software and associated documentation files (the; * ""Software""), to deal in the Software without restriction, including; * without limitation the rights to use, copy, modify, merge, publish,; * distribute, sublicense, and/or sell copies of the Software, and to; * permit persons to whom the Software is furnished to do so, subject to; * the following conditions:; *; * The above copyright notice and this permission notice shall be; * included in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF; * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE; * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION; * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION; * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.; * ====================================================================; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/jspdf.mjs:213,charge,charge,213,js/modules/jspdf.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/jspdf.mjs,1,['charge'],['charge']
Energy Efficiency,"/** ====================================================================; * @license; * jsPDF XMP metadata plugin; * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi; *; * Permission is hereby granted, free of charge, to any person obtaining; * a copy of this software and associated documentation files (the; * ""Software""), to deal in the Software without restriction, including; * without limitation the rights to use, copy, modify, merge, publish,; * distribute, sublicense, and/or sell copies of the Software, and to; * permit persons to whom the Software is furnished to do so, subject to; * the following conditions:; *; * The above copyright notice and this permission notice shall be; * included in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF; * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE; * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION; * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION; * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.; * ====================================================================; */; /**; * @name xmp_metadata; * @module; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:213,charge,charge,213,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['charge'],['charge']
Energy Efficiency,"/** @brief BidirMMapPipe creates a bidirectional channel between the current; * process and a child it forks.; *; * @author Manuel Schiller <manuel.schiller@nikhef.nl>; * @date 2013-07-07; *; * This class creates a bidirectional channel between this process and a child; * it creates with fork().; *; * The channel is comrised of a small shared pool of buffer memory mmapped into; * both process spaces, and two pipes to synchronise the exchange of data. The; * idea behind using the pipes at all is to have some primitive which we can; * block on without having to worry about atomic operations or polling, leaving; * these tasks to the OS. In case the anonymous mmap cannot be performed on the; * OS the code is running on (for whatever reason), the code falls back to; * mmapping /dev/zero, mmapping a temporary file, or (if those all fail), a; * dynamically allocated buffer which is then transmitted through the pipe(s),; * a slightly slower alternative (because the data is copied more often).; *; * The channel supports five major operations: read(), write(), flush(),; * purge() and close(). Reading and writing may block until the required buffer; * space is available. Writes may queue up data to be sent to the other end; * until either enough pages are full, or the user calls flush which forces; * any unsent buffers to be sent to the other end. flush forces any data that; * is to be sent to be sent. purge discards any buffered data waiting to be; * read and/or sent. Closing the channel on the child returns zero, closing it; * on the parent returns the child's exit status.; *; * The class also provides operator<< and operator>> for C++-style I/O for; * basic data types (bool, char, short, int, long, long long, float, double; * and their unsigned counterparts). Data is transmitted binary (i.e. no; * formatting to strings like std::cout does). There are also overloads to; * support C-style zero terminated strings and std::string. In terms of; * performance, the former is to be ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:862,allocate,allocated,862,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,1,['allocate'],['allocated']
Energy Efficiency,"/** @brief class representing a page pool; *; * @author Manuel Schiller <manuel.schiller@nikhef.nl>; * @date 2013-07-24; *; * pool of mmapped pages (on systems which support it, on all others, the; * functionality is emulated with dynamically allocated memory); *; * in most operating systems there is a limit to how many mappings any one; * process is allowed to request; for this reason, we mmap a relatively; * large amount up front, and then carve off little pieces as we need them; *; * Moreover, some systems have too large a physical page size in their MMU; * for the code to handle (we want offsets and lengths to fit into 16; * bits), so we carve such big physical pages into smaller logical Pages; * if needed. The largest logical page size is currently 16 KiB.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx:243,allocate,allocated,243,roofit/roofitcore/src/BidirMMapPipe.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx,1,['allocate'],['allocated']
Energy Efficiency,"/** @brief evaluate Faddeeva function for complex argument; *; * @author Manuel Schiller <manuel.schiller@nikhef.nl>; * @date 2013-02-21; *; * Calculate the value of the Faddeeva function @f$w(z) = \exp(-z^2); * \mathrm{erfc}(-i z)@f$.; *; * The method described in; *; * S.M. Abrarov, B.M. Quine: ""Efficient algorithmic implementation of; * Voigt/complex error function based on exponential series approximation""; * published in Applied Mathematics and Computation 218 (2011) 1894-1902; * doi:10.1016/j.amc.2011.06.072; *; * is used. At the heart of the method (equation (14) of the paper) is the; * following Fourier series based approximation:; *; * @f[ w(z) \approx \frac{i}{2\sqrt{\pi}}\left(; * \sum^N_{n=nullptr} a_n \tau_m\left(; * \frac{1-e^{i(n\pi+\tau_m z)}}{n\pi + \tau_m z} -; * \frac{1-e^{i(-n\pi+\tau_m z)}}{n\pi - \tau_m z}; * \right) - a_0 \frac{1-e^{i \tau_m z}}{z}; * \right) @f]; *; * The coefficients @f$a_b@f$ are given by:; *; * @f[ a_n=\frac{2\sqrt{\pi}}{\tau_m}; * \exp\left(-\frac{n^2\pi^2}{\tau_m^2}\right) @f]; *; * To achieve machine accuracy in double precision floating point arithmetic; * for most of the upper half of the complex plane, chose @f$t_m=12@f$ and; * @f$N=23@f$ as is done in the paper.; *; * There are two complications: For Im(z) negative, the exponent in the; * equation above becomes so large that the roundoff in the rest of the; * calculation is amplified enough that the result cannot be trusted.; * Therefore, for Im(z) < 0, the symmetry of the erfc function under the; * transformation z --> -z is used to avoid accuracy issues for Im(z) < 0 by; * formulating the problem such that the calculation can be done for Im(z) > 0; * where the accuracy of the method is fine, and some postprocessing then; * yields the desired final result.; *; * Second, the denominators in the equation above become singular at; * @f$z = n * pi / 12@f$ (for 0 <= n < 24). In a tiny disc around these; * points, Taylor expansions are used to overcome that difficulty.; *",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMath.h:299,Efficient,Efficient,299,roofit/roofitcore/inc/RooMath.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMath.h,1,['Efficient'],['Efficient']
Energy Efficiency,"/** @brief read a C-style string; *; * @param str pointer to string (space allocated with malloc!); * @returns pipe read from; *; * since this is for C-style strings, we use malloc/realloc/free for; * strings. passing in a nullptr pointer is valid here, and the routine; * will use realloc to allocate a chunk of memory of the right size.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:75,allocate,allocated,75,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,/** @defgroup helpers Helpers; * Helpers for working with CDT::Triangulation.; */; /// @{; /**; * Calculate triangles adjacent to vertices (triangles by vertex index); * @param triangles triangulation; * @param verticesSize total number of vertices to pre-allocate the output; * @return triangles by vertex index; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/CDT.h:256,allocate,allocate,256,math/mathcore/src/CDT/CDT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/CDT.h,1,['allocate'],['allocate']
Energy Efficiency,"/** @license; * Copyright (c) 2017 Dominik Homberger. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. https://webpjs.appspot.com; WebPRiffParser dominikhlbg@gmail.com; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:92,charge,charge,92,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,3,['charge'],['charge']
Energy Efficiency,"/** @license; * MIT license.; * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems; * 2014 Diego Casorran, https://github.com/diegocr; *; * Permission is hereby granted, free of charge, to any person obtaining; * a copy of this software and associated documentation files (the; * ""Software""), to deal in the Software without restriction, including; * without limitation the rights to use, copy, modify, merge, publish,; * distribute, sublicense, and/or sell copies of the Software, and to; * permit persons to whom the Software is furnished to do so, subject to; * the following conditions:; *; * The above copyright notice and this permission notice shall be; * included in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF; * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE; * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION; * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION; * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.; * ====================================================================; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/jspdf.mjs:207,charge,charge,207,js/modules/jspdf.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/jspdf.mjs,1,['charge'],['charge']
Energy Efficiency,"/** @license; * MIT license.; * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems; * 2014 Diego Casorran, https://github.com/diegocr; *; * Permission is hereby granted, free of charge, to any person obtaining; * a copy of this software and associated documentation files (the; * ""Software""), to deal in the Software without restriction, including; * without limitation the rights to use, copy, modify, merge, publish,; * distribute, sublicense, and/or sell copies of the Software, and to; * permit persons to whom the Software is furnished to do so, subject to; * the following conditions:; *; * The above copyright notice and this permission notice shall be; * included in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF; * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE; * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION; * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION; * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.; * ====================================================================; */; /**; * jsPDF split_text_to_size plugin; *; * @name split_text_to_size; * @module; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:207,charge,charge,207,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['charge'],['charge']
Energy Efficiency,"/** @license; * jsPDF addImage plugin; * Copyright (c) 2012 Jason Siefken, https://github.com/siefkenj/; * 2013 Chris Dowling, https://github.com/gingerchris; * 2013 Trinh Ho, https://github.com/ineedfat; * 2013 Edwin Alejandro Perez, https://github.com/eaparango; * 2013 Norah Smith, https://github.com/burnburnrocket; * 2014 Diego Casorran, https://github.com/diegocr; * 2014 James Robb, https://github.com/jamesbrobb; *; * Permission is hereby granted, free of charge, to any person obtaining; * a copy of this software and associated documentation files (the; * ""Software""), to deal in the Software without restriction, including; * without limitation the rights to use, copy, modify, merge, publish,; * distribute, sublicense, and/or sell copies of the Software, and to; * permit persons to whom the Software is furnished to do so, subject to; * the following conditions:; *; * The above copyright notice and this permission notice shall be; * included in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF; * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE; * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION; * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION; * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:464,charge,charge,464,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,3,['charge'],['charge']
Energy Efficiency,"/** @license; jsPDF standard_fonts_metrics plugin; * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems; * MIT license.; * Permission is hereby granted, free of charge, to any person obtaining; * a copy of this software and associated documentation files (the; * ""Software""), to deal in the Software without restriction, including; * without limitation the rights to use, copy, modify, merge, publish,; * distribute, sublicense, and/or sell copies of the Software, and to; * permit persons to whom the Software is furnished to do so, subject to; * the following conditions:; * ; * The above copyright notice and this permission notice shall be; * included in all copies or substantial portions of the Software.; * ; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF; * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE; * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION; * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION; * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.; * ====================================================================; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/jspdf.mjs:190,charge,charge,190,js/modules/jspdf.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/jspdf.mjs,1,['charge'],['charge']
Energy Efficiency,"/** @license; jsPDF standard_fonts_metrics plugin; * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems; * MIT license.; * Permission is hereby granted, free of charge, to any person obtaining; * a copy of this software and associated documentation files (the; * ""Software""), to deal in the Software without restriction, including; * without limitation the rights to use, copy, modify, merge, publish,; * distribute, sublicense, and/or sell copies of the Software, and to; * permit persons to whom the Software is furnished to do so, subject to; * the following conditions:; * ; * The above copyright notice and this permission notice shall be; * included in all copies or substantial portions of the Software.; * ; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF; * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE; * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION; * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION; * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.; * ====================================================================; */; /**; * This file adds the standard font metrics to jsPDF.; *; * Font metrics data is reprocessed derivative of contents of; * ""Font Metrics for PDF Core 14 Fonts"" package, which exhibits the following copyright and license:; *; * Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated. All Rights Reserved.; *; * This file and the 14 PostScript(R) AFM files it accompanies may be used,; * copied, and distributed for any purpose and without charge, with or without; * modification, provided that all copyright notices are retained; that the AFM; * files are not distributed without this file; that all modifications to this; * file or any of the AFM files are prominently noted",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:190,charge,charge,190,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['charge'],['charge']
Energy Efficiency,/** @name --- Static methods --- **/; /**; Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLDerivator.h:115,adapt,adaptive,115,math/mathmore/src/GSLDerivator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLDerivator.h,1,['adapt'],['adaptive']
Energy Efficiency,"/** @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case; */; /**; Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Derivator.h:335,adapt,adaptive,335,math/mathmore/inc/Math/Derivator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Derivator.h,1,['adapt'],['adaptive']
Energy Efficiency,"/** @summary Add face with 4 vertices; * @desc From four vertices one normally creates two faces (1,2,3) and (1,3,4); * if (reduce === 1), first face is reduced; * if (reduce === 2), second face is reduced */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:124,reduce,reduce,124,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,16,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,/** @summary Configures monitoring interval; * @param {number} interval - repetition interval in ms; * @param {boolean} flag - initial monitoring state */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:24,monitor,monitoring,24,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['monitor'],['monitoring']
Energy Efficiency,/** @summary Enable monitoring mode */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:20,monitor,monitoring,20,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['monitor'],['monitoring']
Energy Efficiency,/** @summary Returns configured monitoring interval in ms */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:32,monitor,monitoring,32,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['monitor'],['monitoring']
Energy Efficiency,/** @summary Returns true when monitoring is enabled */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:31,monitor,monitoring,31,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['monitor'],['monitoring']
Energy Efficiency,/** @summary Runs monitoring event loop; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:18,monitor,monitoring,18,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['monitor'],['monitoring']
Energy Efficiency,"/** @summary Set marker attributes.; * @param {object} args - arguments can be; * @param {object} args.attr - instance of TAttrMarker (or derived class) or; * @param {string} args.color - color in HTML form like grb(1,4,5) or 'green'; * @param {number} args.style - marker style; * @param {number} args.size - marker size; * @param {number} [args.refsize] - when specified and marker size < 1, marker size will be calculated relative to that size */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:227,green,green,227,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['green'],['green']
Energy Efficiency,"/** @summary Specify normal for face with 4 vertices; * @desc same as addFace4, assign normals for each individual vertex; * reduce has same meaning and should be the same */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:125,reduce,reduce,125,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['reduce'],['reduce']
Energy Efficiency,/** Adaptor class for mixing declarations with statements and; * expressions.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:4,Adapt,Adaptor,4,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['Adapt'],['Adaptor']
Energy Efficiency,/** Construct matrix and allocate space for its elements. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuMatrix.h:25,allocate,allocate,25,tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuMatrix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuMatrix.h,1,['allocate'],['allocate']
Energy Efficiency,"/** Executes all of the function passes scheduled in the function pass manager; on the provided function. Returns 1 if any of the passes modified the; function, false otherwise.; @see llvm::FunctionPassManager::run(Function&) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:40,schedul,scheduled,40,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['schedul'],['scheduled']
Energy Efficiency,"/** Finalizes all of the function passes scheduled in the function pass; manager. Returns 1 if any of the passes modified the module, 0 otherwise.; @see llvm::FunctionPassManager::doFinalization */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:41,schedul,scheduled,41,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['schedul'],['scheduled']
Energy Efficiency,"/** Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integration methods); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorMultiDim.h:96,adapt,adaptive,96,math/mathcore/inc/Math/IntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorMultiDim.h,2,['adapt'],['adaptive']
Energy Efficiency,"/** HUF_buildCTable_wksp() :; * Same as HUF_buildCTable(), but using externally allocated scratch buffer.; * `workSpace` must be aligned on 4-bytes boundaries, and be at least as large as sizeof(HUF_buildCTable_wksp_tables).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/huf_compress.c:80,allocate,allocated,80,builtins/zstd/compress/huf_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/huf_compress.c,1,['allocate'],['allocated']
Energy Efficiency,"/** HUF_buildCTable_wksp() :; * Same as HUF_buildCTable(), but using externally allocated scratch buffer.; * `workSpace` must be aligned on 4-bytes boundaries, and its size must be >= HUF_CTABLE_WORKSPACE_SIZE.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/huf.h:80,allocate,allocated,80,builtins/zstd/common/huf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/huf.h,1,['allocate'],['allocated']
Energy Efficiency,"/** HUF_compress4X_wksp() :; * Same as HUF_compress2(), but uses externally allocated `workSpace`.; * `workspace` must have minimum alignment of 4, and be at least as large as HUF_WORKSPACE_SIZE */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/huf.h:76,allocate,allocated,76,builtins/zstd/common/huf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/huf.h,1,['allocate'],['allocated']
Energy Efficiency,"/** HUF_decompress() :; * Decompress HUF data from buffer 'cSrc', of size 'cSrcSize',; * into already allocated buffer 'dst', of minimum size 'dstSize'.; * `originalSize` : **must** be the ***exact*** size of original (uncompressed) data.; * Note : in contrast with FSE, HUF_decompress can regenerate; * RLE (cSrcSize==1) and uncompressed (cSrcSize==dstSize) data,; * because it knows size to regenerate (originalSize).; * @return : size of regenerated data (== originalSize),; * or an error code, which can be tested using HUF_isError(); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/huf.h:102,allocate,allocated,102,builtins/zstd/common/huf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/huf.h,1,['allocate'],['allocated']
Energy Efficiency,"/** HUF_getNbBits() :; * Read nbBits from CTable symbolTable, for symbol `symbolValue` presumed <= HUF_SYMBOLVALUE_MAX; * Note 1 : is not inlined, as HUF_CElt definition is private; * Note 2 : const void* used, so that it can provide a statically allocated table as argument (which uses type U32) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/huf.h:247,allocate,allocated,247,builtins/zstd/common/huf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/huf.h,1,['allocate'],['allocated']
Energy Efficiency,"/** Initializes all of the function passes scheduled in the function pass; manager. Returns 1 if any of the passes modified the module, 0 otherwise.; @see llvm::FunctionPassManager::doInitialization */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:43,schedul,scheduled,43,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['schedul'],['scheduled']
Energy Efficiency,/** Initializes all shared devices resource and makes sure that a sufficient; * number of curand states are allocated on the device and initialized as; * well as that the one-vector for the summation over columns has the right; * size. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaMatrix.h:108,allocate,allocated,108,tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaMatrix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaMatrix.h,2,['allocate'],['allocated']
Energy Efficiency,"/** Initializes, executes on the provided module, and finalizes all of the; passes scheduled in the pass manager. Returns 1 if any of the passes; modified the module, 0 otherwise.; @see llvm::PassManager::run(Module&) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:83,schedul,scheduled,83,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['schedul'],['scheduled']
Energy Efficiency,/** Returns green color component 0..255 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RColor.hxx:12,green,green,12,graf2d/gpadv7/inc/ROOT/RColor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RColor.hxx,1,['green'],['green']
Energy Efficiency,"/** Set the Red Green and Blue (RGB) values from the Hue, Light, Saturation (HLS). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RColor.hxx:16,Green,Green,16,graf2d/gpadv7/inc/ROOT/RColor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RColor.hxx,1,['Green'],['Green']
Energy Efficiency,"/** StackAllocator controls the memory allocation/deallocation of Minuit. If; _MN_NO_THREAD_SAVE_ is defined, memory is taken from a pre-allocated piece; of heap memory which is then used like a stack, otherwise via standard; malloc/free. Note that defining _MN_NO_THREAD_SAVE_ makes the code thread-; unsave. The gain in performance is mainly for cost-cheap FCN functions.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/StackAllocator.h:137,allocate,allocated,137,math/minuit2/inc/Minuit2/StackAllocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/StackAllocator.h,1,['allocate'],['allocated']
Energy Efficiency,/** ZSTD_adjustCParams_internal() :; * optimize `cPar` for a specified input (`srcSize` and `dictSize`).; * mostly downsize to reduce memory consumption and initialization latency.; * `srcSize` can be ZSTD_CONTENTSIZE_UNKNOWN when not known.; * `mode` is the mode for parameter adjustment. See docs for `ZSTD_cParamMode_e`.; * note : `srcSize==0` means 0!; * condition : cPar is presumed validated (can be checked using ZSTD_checkCParams()). */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:127,reduce,reduce,127,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,2,"['consumption', 'reduce']","['consumption', 'reduce']"
Energy Efficiency,/** \brief action to be done after the computation of a test sample (e.g. update some monitoring output); *; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/NeuralNet.cxx:86,monitor,monitoring,86,tmva/tmva/src/NeuralNet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/NeuralNet.cxx,1,['monitor'],['monitoring']
Energy Efficiency,/** \brief action to be done when the test cycle is started (e.g. update some monitoring output); *; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/NeuralNet.cxx:78,monitor,monitoring,78,tmva/tmva/src/NeuralNet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/NeuralNet.cxx,1,['monitor'],['monitoring']
Energy Efficiency,/** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); *; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/NeuralNet.cxx:80,monitor,monitoring,80,tmva/tmva/src/NeuralNet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/NeuralNet.cxx,2,['monitor'],['monitoring']
Energy Efficiency,/** \brief action to be done when the training cycle is started (e.g. update some monitoring output); *; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/NeuralNet.cxx:82,monitor,monitoring,82,tmva/tmva/src/NeuralNet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/NeuralNet.cxx,1,['monitor'],['monitoring']
Energy Efficiency,/** \brief preparation for monitoring output; *; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/NeuralNet.cxx:27,monitor,monitoring,27,tmva/tmva/src/NeuralNet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/NeuralNet.cxx,1,['monitor'],['monitoring']
Energy Efficiency,/** \brief set the weight sums to be scaled to (preparations for monitoring output); *; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/NeuralNet.cxx:65,monitor,monitoring,65,tmva/tmva/src/NeuralNet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/NeuralNet.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"/** \class AdaptiveIntegratorMultiDim; \ingroup Integration. Class for adaptive quadrature integration in multi-dimensions using rectangular regions.; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. - \f$ minpts \f$: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to \f$ 2^n +2n(n+1) +1 \f$ where n is the function dimension; - \f$ maxpts \f$: Maximum number of function evaluations to be allowed.; \f$ maxpts >= 2^n +2n(n+1) +1 \f$; if \f$ maxpts<minpts \f$, \f$ maxpts \f$ is set to \f$ 10minpts \f$; - \f$ epstol \f$, \f$ epsrel \f$ : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function in the desired interval:. - an estimation of the relative accuracy of the result.; - number of function evaluations performed.; - status code:; 0. Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1. maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 2. size is too small for the specified number MAXPTS of function evaluations.; 3. n<2 or n>15. ### Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. ### Notes:. 1..Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h:11,Adapt,AdaptiveIntegratorMultiDim,11,math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,4,"['Adapt', 'adapt']","['AdaptiveIntegratorMultiDim', 'adapted', 'adaptive']"
Energy Efficiency,"/** \class REveCaloData::CellData_t; \ingroup REve; Cell data inner structure.; */; ////////////////////////////////////////////////////////////////////////////////; /// Return energy value associated with the cell, usually Et.; /// If isEt is false it is transformed into energy E.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveCaloData.cxx:177,energy,energy,177,graf3d/eve7/src/REveCaloData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveCaloData.cxx,2,['energy'],['energy']
Energy Efficiency,"/** \class REveTrack; \ingroup REve; Visual representation of a track. If member fDpDs is set, the momentum is reduced on all path-marks that do; not fix the momentum according to the distance travelled from the previous; pathmark.; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveTrack.cxx:111,reduce,reduced,111,graf3d/eve7/src/REveTrack.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveTrack.cxx,1,['reduce'],['reduced']
Energy Efficiency,"/** \class TColor; \ingroup Base; \ingroup GraphicsAtt. The color creation and management class. - [Introduction](\ref C00); - [Basic colors](\ref C01); - [The color wheel](\ref C02); - [Bright and dark colors](\ref C03); - [Accessible Color Schemes](\ref C031); - [Gray scale view of of canvas with colors](\ref C04); - [Color palettes](\ref C05); - [High quality predefined palettes](\ref C06); - [Colour Vision Deficiency (CVD) friendly palettes](\ref C06a); - [Non Colour Vision Deficiency (CVD) friendly palettes](\ref C06b); - [Palette inversion](\ref C061); - [Color transparency](\ref C07). \anchor C00; ## Introduction. Colors are defined by their red, green and blue components, simply called the; RGB components. The colors are also known by the hue, light and saturation; components also known as the HLS components. When a new color is created the; components of both color systems are computed. At initialization time, a table of colors is generated. An existing color can; be retrieved by its index:. ~~~ {.cpp}; TColor *color = gROOT->GetColor(10);; ~~~. Then it can be manipulated. For example its RGB components can be modified:. ~~~ {.cpp}; color->SetRGB(0.1, 0.2, 0.3);; ~~~. A new color can be created the following way:. ~~~ {.cpp}; Int_t ci = 1756; // color index; auto color = new TColor(ci, 0.1, 0.2, 0.3);; ~~~. \since **6.07/07:**; TColor::GetFreeColorIndex() allows to make sure the new color is created with an; unused color index:. ~~~ {.cpp}; Int_t ci = TColor::GetFreeColorIndex();; auto color = new TColor(ci, 0.1, 0.2, 0.3);; ~~~. Two sets of colors are initialized;. - The basic colors: colors with index from 0 to 50.; - The color wheel: colors with indices from 300 to 1000. \anchor C01; ## Basic colors; The following image displays the 50 basic colors. Begin_Macro(source); {; auto c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; c->DrawColorTable();; return c;; }; End_Macro. \anchor C02; ## The color wheel; The wheel contains the recommended 216 colors ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx:662,green,green,662,core/base/src/TColor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx,1,['green'],['green']
Energy Efficiency,"/** \class TDenseLayer. Generic layer class. This generic layer class represents a dense layer of a neural network with; a given width n and activation function f. The activation function of each; layer is given by \f$\mathbf{u} = \mathbf{W}\mathbf{x} + \boldsymbol{\theta}\f$. In addition to the weight and bias matrices, each layer allocates memory; for its activations and the corresponding input tensor before evaluation of; the activation function as well as the gradients of the weights and biases. The layer provides member functions for the forward propagation of; activations through the given layer.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DenseLayer.h:334,allocate,allocates,334,tmva/tmva/inc/TMVA/DNN/DenseLayer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DenseLayer.h,1,['allocate'],['allocates']
Energy Efficiency,"/** \class TEveCaloData::CellData_t; \ingroup TEve; Cell data inner structure.; */; ////////////////////////////////////////////////////////////////////////////////; /// Return energy value associated with the cell, usually Et.; /// If isEt is false it is transformed into energy E.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCaloData.cxx:177,energy,energy,177,graf3d/eve/src/TEveCaloData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCaloData.cxx,2,['energy'],['energy']
Energy Efficiency,"/** \class TEveTrack; \ingroup TEve; Visual representation of a track. If member fDpDs is set, the momentum is reduced on all path-marks that do; not fix the momentum according to the distance travelled from the previous; pathmark.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrack.cxx:111,reduce,reduced,111,graf3d/eve/src/TEveTrack.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrack.cxx,1,['reduce'],['reduced']
Energy Efficiency,"/** \class TF1Parameters; TF1 Parameters class; */; ////////////////////////////////////////////////////////////////////////////////; /// Returns the parameter number given a name; /// not very efficient but list of parameters is typically small; /// could use a map if needed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:194,efficient,efficient,194,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['efficient'],['efficient']
Energy Efficiency,"/** \class TGLLogicalShape; \ingroup opengl; Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :. - Sphere A - Radius r1, center v1; - Sphere B - Radius r2, center v2; - Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes do not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:; ~~~ {.cpp}; * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod.; ~~~; Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx:746,reduce,reduces,746,graf3d/gl/src/TGLLogicalShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx,2,"['consumption', 'reduce']","['consumption', 'reduces']"
Energy Efficiency,"/** \class TGLRotateManip; \ingroup opengl; Rotate manipulator - attaches to physical shape and draws local axes; widgets - rings drawn from attached physical center, in plane defined; by axis. User can mouse over (turns yellow) and L click/drag to; rotate attached physical round the ring center.; Widgets use standard 3D package axes colours: X red, Y green, Z blue.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLRotateManip.cxx:354,green,green,354,graf3d/gl/src/TGLRotateManip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLRotateManip.cxx,1,['green'],['green']
Energy Efficiency,"/** \class TGLTransManip; \ingroup opengl; Translation manipulator - attaches to physical shape and draws local; axes widgets with arrow heads. User can mouse over (turns yellow) and; L click/drag to translate along this axis.; Widgets use standard 3D package axes colours: X red, Y green, Z blue.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLTransManip.cxx:283,green,green,283,graf3d/gl/src/TGLTransManip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLTransManip.cxx,1,['green'],['green']
Energy Efficiency,"/** \class TGeoRCExtension; \ingroup Geometry_classes. Reference counted extension which has a pointer to and; owns a user defined TObject. This class can be used as; model for a reference counted derivation from TGeoExtension. Note: Creating a TGeoRCExtension with new() automatically grabs it, but the; creator has to Release it before the pointer gets out of scope.; The following sequence is valid:. ~~~ {.cpp}; // producer:; TGeoRCExtension *ext = new TGeoRCExtension();; some_TGeoVolume->SetUserExtension(ext);; ext->Release();; // user:; TGeoRCExtension *ext = dynamic_cast<TGeoRCExtension*>(some_TGeoVolume->GrabUserExtension());; // ... use extension; ext->Release();; ~~~. The extension is going to be released by the TGeoVolume holder at the destruction; or when calling SetUserExtension(0). The following usage is not correct:. ~~~ {.cpp}; some_TGeoVolume->SetUserExtension(new TGeoRCExtension()); ~~~. since the producer code does not release the extension.; One cannot call directly ""delete ext"" nor allocate an extension on the stack,; since the destructor is protected. Use Release instead.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoExtension.cxx:1014,allocate,allocate,1014,geom/geom/src/TGeoExtension.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoExtension.cxx,1,['allocate'],['allocate']
Energy Efficiency,"/** \class THnSparse; \ingroup Hist. Efficient multidimensional histogram. Use a THnSparse instead of TH1 / TH2 / TH3 / array for histogramming when; only a small fraction of bins is filled. A 10-dimensional histogram with 10; bins per dimension has 10^10 bins; in a naive implementation this will not; fit in memory. THnSparse only allocates memory for the bins that have; non-zero bin content instead, drastically reducing both the memory usage; and the access time. To construct a THnSparse object you must use one of its templated, derived; classes:; - THnSparseD (typedef for THnSparseT<ArrayD>): bin content held by a Double_t,; - THnSparseF (typedef for THnSparseT<ArrayF>): bin content held by a Float_t,; - THnSparseL (typedef for THnSparseT<ArrayL64>): bin content held by a Long64_t,; - THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; - THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; - THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to. Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparseD hs(""hs"", ""hs"", 2, bins, xmin, xmax);. ## Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram. Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). ## Fast Bin Content Access; When iterating over a THnSparse one should only look at filled bins to save; processing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnS",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:37,Efficient,Efficient,37,hist/hist/src/THnSparse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx,2,"['Efficient', 'allocate']","['Efficient', 'allocates']"
Energy Efficiency,"/** \class THttpServer; \ingroup http. Online http server for arbitrary ROOT application. Idea of THttpServer - provide remote http access to running; ROOT application and enable HTML/JavaScript user interface.; Any registered object can be requested and displayed in the browser.; There are many benefits of such approach:. 1. standard http interface to ROOT application; 2. no any temporary ROOT files when access data; 3. user interface running in all browsers. To start http server simply create instance; of the THttpServer class like:. serv = new THttpServer(""http:8080"");. This will starts civetweb-based http server with http port 8080.; Than one should be able to open address ""http://localhost:8080""; in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; created in ROOT application. By default, server can access files,; canvases and histograms via `gROOT` pointer. All such objects; can be displayed with JSROOT graphics. At any time one could register other objects with the command:. TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);. If objects content is changing in the application, one could; enable monitoring flag in the browser - than objects view; will be regularly updated. More information: https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx:1182,monitor,monitoring,1182,net/http/src/THttpServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"/** \class TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array.; */; /** \class TNDArrayRef. gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];; */; // Array layout:; // nbins[0] = 2, nbins[1] = 4, nbins[2] = 3 => 24 bins; //; // fSizes: 24, 12, 3 [, 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TNDArray.h:298,allocate,allocated,298,hist/hist/inc/TNDArray.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TNDArray.h,1,['allocate'],['allocated']
Energy Efficiency,"/** \class TNet. Generic neural network class. This generic neural network class represents a concrete neural; network through a vector of layers and coordinates the forward; and backward propagation through the net. The net takes as input a batch from the training data given in; matrix form, with each row corresponding to a certain training; event. On construction, the neural network allocates all the memory; required for the training of the neural net and keeps it until; its destruction. The Architecture type argument simply holds the; architecture-specific data types, which are just the matrix type; Matrix_t and the used scalar type Scalar_t. \tparam Architecture The Architecture type that holds the; \tparam Layer_t The type used for the layers. Can be either; Layer<Architecture> or SharedWeightLayer<Architecture>.; datatypes for a given architecture.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Net.h:388,allocate,allocates,388,tmva/tmva/inc/TMVA/DNN/Net.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Net.h,1,['allocate'],['allocates']
Energy Efficiency,/** \class TObjectRefSpy; \class TObjectSpy; \ingroup Base. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/gui/src/TObjectSpy.cxx:60,Monitor,Monitors,60,core/gui/src/TObjectSpy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/gui/src/TObjectSpy.cxx,1,['Monitor'],['Monitors']
Energy Efficiency,"/** \class TParallelCoord; Parallel Coordinates class. The multidimensional system of Parallel coordinates is a common way of studying; high-dimensional geometry and visualizing multivariate problems. It has first; been proposed by A. Inselberg in 1981. To show a set of points in an n-dimensional space, a backdrop is drawn; consisting of n parallel lines. A point in n-dimensional space is represented as; a polyline with vertices on the parallel axes; the position of the vertex on the; i-th axis corresponds to the i-th coordinate of the point. This tool comes with a rather large gui in the editor. It is necessary to use; this editor in order to explore a data set, as explained below. ### Reduce cluttering:. The main issue for parallel coordinates is the very high cluttering of the; output when dealing with large data set. Two techniques have been implemented to; bypass that so far:. - Draw doted lines instead of plain lines with an adjustable dots spacing. A; slider to adjust the dots spacing is available in the editor.; - Sort the entries to display with a ""weight cut"". On each axis is drawn a; histogram describing the distribution of the data on the corresponding; variable. The ""weight"" of an entry is the sum of the bin content of each bin; the entry is going through. An entry going through the histograms peaks will; have a big weight wether an entry going randomly through the histograms will; have a rather small weight. Setting a cut on this weight allows to draw only; the most representative entries. A slider set the cut is also available in; the gui. ## Selections:. Selections of specific entries can be defined over the data se using parallel; coordinates. With that representation, a selection is an ensemble of ranges; defined on the axes. Ranges defined on the same axis are conjugated with OR; (an entry must be in one or the other ranges to be selected). Ranges on; different axes are are conjugated with AND (an entry must be in all the ranges; to be selected). S",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TParallelCoord.cxx:696,Reduce,Reduce,696,tree/treeviewer/src/TParallelCoord.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TParallelCoord.cxx,1,['Reduce'],['Reduce']
Energy Efficiency,/** \class TParallelCoordEditor. This is the TParallelCoord editor. It brings tools to explore datas; Using parallel coordinates. The main tools are:. - Dots spacing : Set the dots spacing with which-one the lines; must be drawn. This tool is useful to reduce the image; cluttering.; - The Selections section : Set the current edited selection and; allows to apply it to the tree through a generated entry list.; - The Entries section : Set how many events must be drawn.; A weight cut can be defined here (see TParallelCoord for a; a description of the weight cut).; - The Variables tab : To define the global settings to display; the axes. It is also possible to add a variable from its; expression or delete a selected one (also possible using right; click on the pad.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TParallelCoordEditor.cxx:253,reduce,reduce,253,tree/treeviewer/src/TParallelCoordEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TParallelCoordEditor.cxx,1,['reduce'],['reduce']
Energy Efficiency,"/** \class TPolyLine3D; \ingroup g3d; A 3-dimensional polyline. It has 4 different constructors. First one, without any parameters TPolyLine3D(), we call 'default; constructor' and it's used in a case that just an initialisation is; needed (i.e. pointer declaration). Example:. ~~~ {.cpp}; TPolyLine3D *pl1 = new TPolyLine3D;; ~~~. Second one is 'normal constructor' with, usually, one parameter; n (number of points), and it just allocates a space for the points. Example:. ~~~ {.cpp}; TPolyLine3D pl1(150);; ~~~. Third one allocates a space for the points, and also makes; initialisation from the given array. Example:. ~~~ {.cpp}; TPolyLine3D pl1(150, pointerToAnArray);; ~~~. Fourth one is, almost, similar to the constructor above, except; initialisation is provided with three independent arrays (array of; x coordinates, y coordinates and z coordinates). Example:. ~~~ {.cpp}; TPolyLine3D pl1(150, xArray, yArray, zArray);; ~~~. Example:. Begin_Macro(source); {; TCanvas *c1 = new TCanvas(""c1"",""c1"",500,500);; TView *view = TView::CreateView(1);; view->SetRange(0,0,0,2,2,2);; const Int_t n = 500;; auto r = new TRandom();; Double_t x, y, z;; TPolyLine3D *l = new TPolyLine3D(n);; for (Int_t i=0;i<n;i++) {; r->Sphere(x, y, z, 1);; l->SetPoint(i,x+1,y+1,z+1);; }; l->Draw();; }; End_Macro. TPolyLine3D is a basic graphics primitive which ignores the fact the current pad; has logarithmic scale(s). It simply draws the 3D line in the current user coordinates.; If logarithmic scale is set along one of the three axis, the logarithm of; vector coordinates along this axis should be use. Alternatively and higher level; class, knowing about logarithmic scales, might be used. For instance TGraph2D with; option `L`.; */; ////////////////////////////////////////////////////////////////////////////////; /// 3-D polyline default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TPolyLine3D.cxx:431,allocate,allocates,431,graf3d/g3d/src/TPolyLine3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TPolyLine3D.cxx,2,['allocate'],['allocates']
Energy Efficiency,"/** \class TSPlot. \legacy{TSPlot}. A common method used in High Energy Physics to perform measurements is; the maximum Likelihood method, exploiting discriminating variables to; disentangle signal from background. The crucial point for such an; analysis to be reliable is to use an exhaustive list of sources of; events combined with an accurate description of all the Probability; Density Functions (PDF). To assess the validity of the fit, a convincing quality check; is to explore further the data sample by examining the distributions of; control variables. A control variable can be obtained for instance by; removing one of the discriminating variables before performing again; the maximum Likelihood fit: this removed variable is a control; variable. The expected distribution of this control variable, for; signal, is to be compared to the one extracted, for signal, from the; data sample. In order to be able to do so, one must be able to unfold; from the distribution of the whole data sample. The TSPlot method allows to reconstruct the distributions for; the control variable, independently for each of the various sources of; events, without making use of any <em>a priori</em> knowledge on <u>this</u>; variable. The aim is thus to use the knowledge available for the; discriminating variables to infer the behaviour of the individual; sources of events with respect to the control variable. TSPlot is optimal if the control variable is uncorrelated with the discriminating variables. A detail description of the formalism itself, called \f$\hbox{$_s$}{\cal P}lot\f$, is given; in [[1](https://arxiv.org/abs/physics/0402083)]. ### The method. The \f$\hbox{$_s$}{\cal P}lot\f$ technique is developed in the above context of a; maximum Likelihood method making use of discriminating variables. One considers a data sample in which are merged several species; of events. These species represent various signal components and; background components which all together account for the data s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/splot/src/TSPlot.cxx:65,Energy,Energy,65,math/splot/src/TSPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/splot/src/TSPlot.cxx,1,['Energy'],['Energy']
Energy Efficiency,"/** \class TSpectrum; \ingroup Spectrum; \brief Advanced Spectra Processing; \author Miroslav Morhac. \legacy{TSpectrum, For modeling a spectrum fitting and estimating the background one can use RooFit while for deconvolution and unfolding one can use TUnfold.}. This class contains advanced spectra processing functions for:. - One-dimensional background estimation; - One-dimensional smoothing; - One-dimensional deconvolution; - One-dimensional peak search. The algorithms in this class have been published in the following references:. 1. M.Morhac et al.: Background elimination methods for multidimensional coincidence gamma-ray spectra. Nuclear Instruments and Methods in Physics Research A 401 (1997) 113-132.; 2. M.Morhac et al.: Efficient one- and two-dimensional Gold deconvolution and its application to gamma-ray spectra decomposition. Nuclear Instruments and Methods in Physics Research A 401 (1997) 385-408.; 3. M.Morhac et al.: Identification of peaks in multidimensional coincidence gamma-ray spectra. Nuclear Instruments and Methods in Research Physics A 443(2000), 108-125. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:738,Efficient,Efficient,738,hist/spectrum/src/TSpectrum.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx,1,['Efficient'],['Efficient']
Energy Efficiency,"/** \class TView3D; \ingroup g3d; The 3D view class. This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Begin_Macro(source); {; auto cV3D = new TCanvas(""cV3D"",""PolyLine3D & PolyMarker3D Window"",200,10,500,500);. // Creating a view; TView3D *view = (TView3D*) TView::CreateView(1);; view->SetRange(5,5,5,25,25,25);. // Create a first PolyLine3D; TPolyLine3D *pl3d1 = new TPolyLine3D(6);; pl3d1->SetPoint(0, 10, 20, 10);; pl3d1->SetPoint(1, 15, 15, 15);; pl3d1->SetPoint(2, 20, 20, 20);; pl3d1->SetPoint(3, 20, 10, 20);; pl3d1->SetPoint(4, 10, 10, 20);; pl3d1->SetPoint(5, 10, 10, 10);. // Create a first PolyMarker3D; TPolyMarker3D *pm3d1 = new TPolyMarker3D(9);; pm3d1->SetPoint( 0, 10, 10, 10);; pm3d1->SetPoint( 1, 20, 20, 20);; pm3d1->SetPoint( 2, 10, 20, 20);; pm3d1->SetPoint( 3, 10, 10, 20);; pm3d1->SetPoint( 4, 20, 20, 10);; pm3d1->SetPoint( 5, 20, 10, 10);; pm3d1->SetPoint( 6, 20, 10, 20);; pm3d1->SetPoint( 7, 10, 20, 10);; pm3d1->SetPoint( 8, 15, 15, 15);; pm3d1->SetMarkerSize(2);; pm3d1->SetMarkerColor(4);; pm3d1->SetMarkerStyle(2);. // Draw; pl3d1->Draw();; pm3d1->Draw();; }; End_Macro. Several coordinate systems are available:. - Cartesian; - Polar; - Cylindrical; - Spherical; - PseudoRapidity/Phi; */; ////////////////////////////////////////////////////////////////////////////////; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TView3D.cxx:171,adapt,adapted,171,graf3d/g3d/src/TView3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TView3D.cxx,1,['adapt'],['adapted']
Energy Efficiency,"/** \class UrlRequestJobHolder; \ingroup qt5webdisplay. Class UrlRequestJobHolder; Required to monitor state of QWebEngineUrlRequestJob; Qt can delete object at any time, therefore one connects destroy signal; from the request to clear pointer. */; /////////////////////////////////////////////////////////////////; /// Constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/qt5webdisplay/rooturlschemehandler.cpp:95,monitor,monitor,95,gui/qt5webdisplay/rooturlschemehandler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/qt5webdisplay/rooturlschemehandler.cpp,1,['monitor'],['monitor']
Energy Efficiency,/** constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h:50,Adapt,Adaptive,50,math/mathmore/inc/Math/GSLIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h,1,['Adapt'],['Adaptive']
Energy Efficiency,/** constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h:50,Adapt,Adaptive,50,math/mathmore/inc/Math/GSLIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h,1,['Adapt'],['Adaptive']
Energy Efficiency,"/*** \class TDLGradientDescent; *; * Generic implementation of gradient descent minimization for the; * deep learning neural nets.; *; * The TDLGradientDescent class implements an architecture, input data and; * deep learning neural network type independent implementation of the gradient; * descent minimization algorithm.; *; * This is provided by the Step(...), StepMomentum(...) and; * StepNesterov(...) functions that perform a single minimization step.; *; * The main training characteristics are defined by the provided learning rate,; * the test interval, and the convergence steps required for convergence. The; * test interval defines how often the error on the validation set is computed,; * and the values with which the step counter is increased each time the; * HasConverged() member function is called. A convergence step is defined as; * a step in which the test error is NOT less than 0.999 times the current; * minimal test error that has been reached. If between two subsequent calls; * to HasConverged(Double_t) the test error has not been sufficiently reduced; * it is assumed that a number of convergence steps equal to the test interval; * has been performed.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DLMinimizers.h:1073,reduce,reduced,1073,tmva/tmva/inc/TMVA/DNN/DLMinimizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DLMinimizers.h,1,['reduce'],['reduced']
Energy Efficiency,"/******* Streaming *******/; /*; * Streaming functions generate the xxHash value from an incrememtal input.; * This method is slower than single-call functions, due to state management.; * For small inputs, prefer `XXH32()` and `XXH64()`, which are better optimized.; *; * An XXH state must first be allocated using `XXH*_createState()`.; *; * Start a new hash by initializing the state with a seed using `XXH*_reset()`.; *; * Then, feed the hash state by calling `XXH*_update()` as many times as necessary.; *; * The function returns an error code, with 0 meaning OK, and any other value; * meaning there is an error.; *; * Finally, a hash value can be produced anytime, by using `XXH*_digest()`.; * This function returns the nn-bits hash as an int or long long.; *; * It's still possible to continue inserting input into the hash state after a; * digest, and generate new hash values later on by invoking `XXH*_digest()`.; *; * When done, release the state using `XXH*_freeState()`.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:300,allocate,allocated,300,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['allocate'],['allocated']
Energy Efficiency,"/************************ Utility Routines ************************/; /* MakeEdge creates a new pair of half-edges which form their own loop.; * No vertex or face structures are allocated, but these must be assigned; * before the current edge operation is completed.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/mesh.c:178,allocate,allocated,178,graf3d/eve7/glu/mesh.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/mesh.c,1,['allocate'],['allocated']
Energy Efficiency,"/**************************** Array cookies ******************************/; /// Returns the extra size required in order to store the array; /// cookie for the given new-expression. May return 0 to indicate that no; /// array cookie is required.; ///; /// Several cases are filtered out before this method is called:; /// - non-array allocations never need a cookie; /// - calls to \::operator new(size_t, void*) never need a cookie; ///; /// \param expr - the new-expression being allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:483,allocate,allocated,483,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,1,['allocate'],['allocated']
Energy Efficiency,/***********************************************************************************/; /* reduced colormap building code : */; /***********************************************************************************/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ascmap.c:90,reduce,reduced,90,graf2d/asimage/src/libAfterImage/ascmap.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ascmap.c,1,['reduce'],['reduced']
Energy Efficiency,"/******************************************************************************/; /* Logic for testing clang code completion. */; /******************************************************************************/; /* Parse file:line:column from the input string. Returns 0 on success, non-zero; on failure. If successful, the pointer *filename will contain newly-allocated; memory (that will be owned by the caller) to store the file name. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:361,allocate,allocated,361,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,1,['allocate'],['allocated']
Energy Efficiency,/******************************************************************************; * Initialize HashTable - allocate the memory needed and clear it.	 *; ******************************************************************************/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/gif_hash.c:106,allocate,allocate,106,graf2d/asimage/src/libAfterImage/libungif/gif_hash.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/gif_hash.c,1,['allocate'],['allocate']
Energy Efficiency,"/******************************************************************************; * Quantize high resolution image into lower one. Input image consists of a *; * 2D array for each of the RGB colors with size Width by Height. There is no *; * Color map for the input. Output is a quantized image with 2D array of *; * indexes into the output color map. *; * Note input image can be 24 bits at the most (8 for red/green/blue) and *; * the output has 256 colors at the most (256 entries in the color map.). *; * ColorMapSize specifies size of color map up to 256 and will be updated to *; * real size before returning. *; * Also non of the parameter are allocated by this routine. *; * This function returns GIF_OK if successful, GIF_ERROR otherwise. *; ******************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/gifquantize.c:411,green,green,411,graf2d/win32gdk/src/gifquantize.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/gifquantize.c,4,"['allocate', 'green']","['allocated', 'green']"
Energy Efficiency,"/******************************************************************************; * Update a new gif file, given its file handle, which must be opened for *; * write in binary mode.							 *; * Returns GifFileType pointer dynamically allocated which serves as the gif *; * info record. _GifError is cleared if successful.			 *; ******************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/egif_lib.c:233,allocate,allocated,233,graf2d/asimage/src/libAfterImage/libungif/egif_lib.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/egif_lib.c,1,['allocate'],['allocated']
Energy Efficiency,"/******************************************************************************; Allocate memory for points, colors, segments and polygons.; Returns 1 if OK, otherwise 0.; ******************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/X3DBuffer.c:81,Allocate,Allocate,81,graf3d/g3d/src/X3DBuffer.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/X3DBuffer.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2019, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; // Authors of this class:; // T. Skwarnicki:; // - modify RooCBShape to Asymmetrical Double-Sided CB; // Michael Wilkinson; // - add to RooFit source; // Jonas Rembser, CERN 02/2021:; // - merging RooDSCBShape with RooSDSCBShape to RooCrystalBall; // - implement possibility to have asymmetrical Gaussian core; // - complete rewrite of evaluation and integral code to reduce code; // duplication; /** \class RooCrystalBall; \ingroup Roofit. PDF implementing the generalized Asymmetrical Double-Sided Crystall Ball line shape.; \f[; f(m;m_0,\sigma,\alpha_L,n_L,\alpha_R,n_R) =; \begin{cases}; A_L \cdot (B_L - \frac{m - m_0}{\sigma_L})^{-n_L}, & \mbox{for }\frac{m - m_0}{\sigma_L} < -\alpha_L \\; \exp \left( - \frac{1}{2} \cdot \left[ \frac{m - m_0}{\sigma_L} \right]^2 \right), & \mbox{for }\frac{m - m_0}{\sigma_L} \leq 0 \\; \exp \left( - \frac{1}{2} \cdot \left[ \frac{m - m_0}{\sigma_R} \right]^2 \right), & \mbox{for }\frac{m - m_0}{\sigma_R} \leq \alpha_R \\; A_R \cdot (B_R + \frac{m - m_0}{\sigma_R})^{-n_R}, & \mbox{otherwise}, \\; \end{cases}; \f]; times some normalization factor,; where; \f[; \begin{align}; A_i &= \left(\frac{n_i}{\left| \alpha_i \right|}\right)^{n_i} \cdot \exp\left(- \frac {\left| \alpha_i \right|^2}{2}\right) \\; B_i &= \frac{n_i}{\left| \alpha_i \right|} - \left| \alpha_i \right| \\; \end{align}; \f]; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooCrystalBall.cxx:1010,reduce,reduce,1010,roofit/roofit/src/RooCrystalBall.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooCrystalBall.cxx,1,['reduce'],['reduce']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, NIKHEF; * GR, Gerhard Raven, NIKHEF/VU *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /////////////////////////////////////////////////////////////////////////////////////; /// \class RooEffProd; /// The class RooEffProd implements the product of a PDF with an efficiency function.; /// The normalization integral of the product is calculated numerically, but the; /// event generation is handled by a specialized generator context that implements; /// the event generation in a more efficient for cases where the PDF has an internal; /// generator that is smarter than accept reject.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooEffProd.cxx:911,efficient,efficient,911,roofit/roofitcore/src/RooEffProd.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooEffProd.cxx,1,['efficient'],['efficient']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /** \class RooChi2MCSModule; \ingroup Roofit. RooChi2MCSModule is an add-on module to RooMCStudy that; calculates the chi-squared of fitted p.d.f with respect to a binned; version of the data. For each fit the chi-squared, the reduced chi-squared; the number of degrees of freedom and the probability of the chi-squared; is store in the summary dataset.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooChi2MCSModule.cxx:922,reduce,reduced,922,roofit/roofit/src/RooChi2MCSModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooChi2MCSModule.cxx,1,['reduce'],['reduced']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooAbsCategory.cxx; \class RooAbsCategory; \ingroup Roofitcore. RooAbsCategory is the base class for objects that represent a discrete value with a finite number of states. Each state is denoted by an integer and a name. Both can be used to retrieve and; set states, but referring to states by index is more efficient. Conversion between; index and name can be done using lookupName() or lookupIndex().; It is possible to iterate through all defined states using begin() and end(). For category classes deriving from RooAbsCategory, states can only be evaluated, *i.e.*, queried.; Refer to RooAbsCategoryLValue and its derived classes for categories where states can also be set. The; simplest category class whose states can be set, queried and saved in a dataset, refer to RooCategory. ### Interface change in ROOT-6.22; Category data were based in the class RooCatType, holding an index state and a category name truncated to 256; characters. This wastes 64 bytes of storage space per entry, and prevents fast retrieval of category data.; Since ROOT-6.22, categories are only represented by an integer. RooAbsCategory::lookupName() can be used to; retrieve the corresponding state name. There is no limit for the length of the state name. To not break old code, the old RooCatType interfaces ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCategory.cxx:1014,efficient,efficient,1014,roofit/roofitcore/src/RooAbsCategory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCategory.cxx,1,['efficient'],['efficient']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooAdaptiveGaussKronrodIntegrator1D.cxx; \class RooAdaptiveGaussKronrodIntegrator1D; \ingroup Roofitcore. Implements the Gauss-Kronrod integration algorithm. An adaptive Gaussian quadrature method for numerical integration in; which error is estimated based on evaluation at special points; known as the ""Kronrod points"". By suitably picking these points,; abscissas from previous iterations can be reused as part of the new; set of points, whereas usual Gaussian quadrature would require; recomputation of all abscissas at each iteration. This class automatically handles (-inf,+inf) integrals by dividing; the integration in three regions (-inf,-1), (-1,1), (1,inf) and; calculating the 1st and 3rd term using a \f$ x \rightarrow 1/x \f$ coordinate; transformation. This class embeds the adaptive Gauss-Kronrod integrator from the; GNU Scientific Library version 1.5 and applies a chosen rule ( 10-,; 21-, 31-, 41, 51- or 61-point). The integration domain is; subdivided and recursively integrated until the required precision; is reached. For integrands with integrable singularities the Wynn epsilon rule; can be selected to speed up the convergence of these integrals.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx:867,adapt,adaptive,867,roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,2,['adapt'],['adaptive']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooAdaptiveIntegratorND.cxx; \class RooAdaptiveIntegratorND; \ingroup Roofitcore. Adaptive one-dimensional numerical integration algorithm.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAdaptiveIntegratorND.cxx:788,Adapt,Adaptive,788,roofit/roofitcore/src/RooAdaptiveIntegratorND.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAdaptiveIntegratorND.cxx,1,['Adapt'],['Adaptive']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooAddGenContext.cxx; \class RooAddGenContext; \ingroup Roofitcore. Efficient implementation of the; generator context specific for RooAddPdf PDFs. The strategy; of RooAddGenContext is to defer generation of each component; to a dedicated generator context for that component and to; randomly choose one of those context to generate an event,; with a probability proportional to its associated coefficient.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddGenContext.cxx:774,Efficient,Efficient,774,roofit/roofitcore/src/RooAddGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddGenContext.cxx,1,['Efficient'],['Efficient']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooBinnedGenContext.cxx; \class RooBinnedGenContext; \ingroup Roofitcore. Efficient implementation of the generator context specific for binned pdfs.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinnedGenContext.cxx:780,Efficient,Efficient,780,roofit/roofitcore/src/RooBinnedGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinnedGenContext.cxx,1,['Efficient'],['Efficient']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooConvGenContext.cxx; \class RooConvGenContext; \ingroup Roofitcore. Efficient implementation of the generator context; specific for RooAbsAnaConvPdf objects. The physics model is generated; with a truth resolution model and the requested resolution model is generated; separately as a PDF. The convolution variable of the physics model is; subsequently explicitly smeared with the resolution model distribution.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooConvGenContext.cxx:776,Efficient,Efficient,776,roofit/roofitcore/src/RooConvGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooConvGenContext.cxx,1,['Efficient'],['Efficient']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooDataProjBinding.cxx; \class RooDataProjBinding; \ingroup Roofitcore. adaptor that projects a real function via summation of states; provided in a dataset. The real function must be attached to the; dataset before creating this binding object. If the dataset only contains category variables, the summation is optimized; performing a weighted sum over the states of a RooSuperCategory that is; constructed from all the categories in the dataset. **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataProjBinding.cxx:778,adapt,adaptor,778,roofit/roofitcore/src/RooDataProjBinding.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataProjBinding.cxx,1,['adapt'],['adaptor']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooFunctor.cxx; \class RooFunctor; \ingroup Roofitcore. Lightweight interface adaptor that exports a RooAbsPdf as a functor.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFunctor.cxx:784,adapt,adaptor,784,roofit/roofitcore/src/RooFunctor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFunctor.cxx,1,['adapt'],['adaptor']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooMCIntegrator.cxx; \class RooMCIntegrator; \ingroup Roofitcore. Implements an adaptive multi-dimensional Monte Carlo; numerical integration, following the VEGAS algorithm originally described; in G. P. Lepage, J. Comp. Phys. 27, 192(1978). This implementation is; based on a C version from the 0.9 beta release of the GNU scientific library.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCIntegrator.cxx:786,adapt,adaptive,786,roofit/roofitcore/src/RooMCIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCIntegrator.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooProdGenContext.cxx; \class RooProdGenContext; \ingroup Roofitcore. Efficient implementation of the generator context; specific for RooProdPdf PDFs. The sim-context owns a list of; component generator contexts that are used to generate the dependents; for each component PDF sequentially.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdGenContext.cxx:776,Efficient,Efficient,776,roofit/roofitcore/src/RooProdGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdGenContext.cxx,1,['Efficient'],['Efficient']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooProdPdf.cxx; \class RooProdPdf; \ingroup Roofitcore. Efficient implementation of a product of PDFs of the form; \f[ \prod_{i=1}^{N} \mathrm{PDF}_i (x, \ldots) \f]. PDFs may share observables. If that is the case any irreducible subset; of PDFs that share observables will be normalised with explicit numeric; integration as any built-in normalisation will no longer be valid. Alternatively, products using conditional PDFs can be defined, *e.g.*. \f[ F(x|y) \cdot G(y), \f]. meaning a PDF \f$ F(x) \f$ **given** \f$ y \f$ and a PDF \f$ G(y) \f$.; In this construction, \f$ F \f$ is only; normalised w.r.t \f$ x\f$, and \f$ G \f$ is normalised w.r.t \f$ y \f$. The product in this construction; is properly normalised. If exactly one of the component PDFs supports extended likelihood fits, the; product will also be usable in extended mode, returning the number of expected; events from the extendable component PDF. The extendable component does not; have to appear in any specific place in the list.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:762,Efficient,Efficient,762,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['Efficient'],['Efficient']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooQuasiRandomGenerator.cxx; \class RooQuasiRandomGenerator; \ingroup Roofitcore. This class generates the quasi-random (aka ""low discrepancy""); sequence for dimensions up to 12 using the Niederreiter base 2; algorithm described in Bratley, Fox, Niederreiter, ACM Trans.; Model. Comp. Sim. 2, 195 (1992). This implementation was adapted; from the 0.9 beta release of the GNU scientific library.; Quasi-random number sequences are useful for improving the; convergence of a Monte Carlo integration.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooQuasiRandomGenerator.cxx:1035,adapt,adapted,1035,roofit/roofitcore/src/RooQuasiRandomGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooQuasiRandomGenerator.cxx,1,['adapt'],['adapted']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooRealBinding.cxx; \class RooRealBinding; \ingroup Roofitcore. Lightweight interface adaptor that binds a RooAbsReal object to a subset; of its servers and present it as a simple array oriented interface.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealBinding.cxx:792,adapt,adaptor,792,roofit/roofitcore/src/RooRealBinding.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealBinding.cxx,1,['adapt'],['adaptor']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooRombergIntegrator.cxx; \class RooRombergIntegrator; \ingroup Roofitcore. Adaptive numerical integration algorithm. It uses Romberg's method with trapezoids or midpoints.; The integrand is approximated by \f$ 1, 2, 4, 8, \ldots, 2^n \f$ trapezoids, and; Richardson series acceleration is applied to the series. For refinement step \f$ n \f$, that is; \f[; R(n,m) = \frac{1}{4^m - 1} \left( 4^m R(n, m-1) - R(n-1, m-1) \right); \f]; The integrator will evaluate the first six refinements (i.e. 64 points) in one go,; apply a five-point series acceleration, and successively add more steps until the; desired precision is reached.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRombergIntegrator.cxx:782,Adapt,Adaptive,782,roofit/roofitcore/src/RooRombergIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRombergIntegrator.cxx,1,['Adapt'],['Adaptive']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooSimGenContext.cxx; \class RooSimGenContext; \ingroup Roofitcore. Efficient implementation of the generator context; specific for RooSimultaneous PDFs when generating more than one of the; component pdfs.; It runs in two modes:; - Proto data with category entries are given: An event from the same category as; in the proto data is created.; - No proto data: A category is chosen randomly.; \note This requires that the PDFs are extended, to determine the relative probabilities; that an event originates from a certain category.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimGenContext.cxx:774,Efficient,Efficient,774,roofit/roofitcore/src/RooSimGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimGenContext.cxx,1,['Efficient'],['Efficient']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooSimSplitGenContext.cxx; \class RooSimSplitGenContext; \ingroup Roofitcore. Efficient implementation of the generator context; specific for RooSimultaneous PDFs when generating more than one of the; component pdfs.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimSplitGenContext.cxx:784,Efficient,Efficient,784,roofit/roofitcore/src/RooSimSplitGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimSplitGenContext.cxx,1,['Efficient'],['Efficient']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooTreeDataStore.cxx; \class RooTreeDataStore; \ingroup Roofitcore. TTree-backed data storage. When a file is opened before; creating the data storage, the storage will be file-backed. This reduces memory; pressure because it allows storing the data in the file and reading it on demand.; For a completely memory-backed storage, which is faster than the file-backed storage,; RooVectorDataStore can be used. With tree-backed storage, the tree can be found in the file with the name; `RooTreeDataStore_name_title` for a dataset created as; `RooDataSet(""name"", ""title"", ...)`. \note A file needs to be opened **before** creating the data storage to enable file-backed; storage.; ```; TFile outputFile(""filename.root"", ""RECREATE"");; RooAbsData::setDefaultStorageType(RooAbsData::Tree);; RooDataSet mydata(...);; ```. One can also change between TTree- and std::vector-backed storage using; RooAbsData::convertToTreeStore() and; RooAbsData::convertToVectorStore().; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx:896,reduce,reduces,896,roofit/roofitcore/src/RooTreeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx,1,['reduce'],['reduces']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; //////////////////////////////////////////////////////////////////////////////; /** \class RooAddPdf; \ingroup Roofitcore. Efficient implementation of a sum of PDFs of the form. \f[; \sum_{i=1}^{n} c_i \cdot \mathrm{PDF}_i; \f]. or; \f[; c_1\cdot\mathrm{PDF}_1 + c_2\cdot\mathrm{PDF}_2 \; + \; ... \; + \; \left( 1-\sum_{i=1}^{n-1}c_i \right) \cdot \mathrm{PDF}_n; \f]. The first form is for extended likelihood fits, where the; expected number of events is \f$ \sum_i c_i \f$. The coefficients \f$ c_i \f$; can either be explicitly provided, or, if all components support; extended likelihood fits, they can be calculated from the contribution; of each PDF to the total expected number of events. In the second form, the sum of the coefficients is required to be 1 or less,; and the coefficient of the last PDF is calculated automatically from the condition; that the sum of all coefficients has to be 1. ### Recursive coefficients; It is also possible to parameterise the coefficients recursively. \f[; \sum_{i=1}^n c_i \prod_{j=1}^{i-1} \left[ (1-c_j) \right] \cdot \mathrm{PDF}_i \\; = c_1 \cdot \mathrm{PDF}_1 + (1-c_1)\, c_2 \cdot \mathrm{PDF}_2 + \ldots + (1-c_1)\ldots(1-c_{n-1}) \cdot 1 \cdot \mathrm{PDF}_n \\; \f]. In this form the sum of the coefficients is always less than 1.0; for all possib",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:818,Efficient,Efficient,818,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,1,['Efficient'],['Efficient']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; //////////////////////////////////////////////////////////////////////////////; /// \class RooAddModel; ///; /// RooAddModel is an efficient implementation of a sum of PDFs of the form; /// \f[; /// c_1 \cdot \mathrm{PDF}_1 + c_2 \cdot \mathrm{PDF}_2 + ... + c_n \cdot \mathrm{PDF}_n; /// \f]; /// or; /// \f[; /// c_1 \cdot \mathrm{PDF}_1 + c_2 \cdot \mathrm{PDF}_2 + ... + \left( 1-\sum_{i=1}^{n-1} c_i \right) \cdot \mathrm{PDF}_n; /// \f]; /// The first form is for extended likelihood fits, where the; /// expected number of events is \f$ \sum_i c_i \f$. The coefficients \f$ c_i \f$; /// can either be explicitly provided, or, if all components support; /// extended likelihood fits, they can be calculated from the contribution; /// of each PDF to the total number of expected events.; ///; /// In the second form, the sum of the coefficients is enforced to be one,; /// and the coefficient of the last PDF is calculated from that condition.; ///; /// RooAddModel relies on each component PDF to be normalized, and will perform; /// no normalization other than calculating the proper last coefficient \f$ c_n \f$, if requested.; /// An (enforced) condition for this assumption is that each \f$ \mathrm{PDF}_i \f$ is independent; /// of each coefficient \f$ i \f$.; ///; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx:826,efficient,efficient,826,roofit/roofitcore/src/RooAddModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx,1,['efficient'],['efficient']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitModels *; * @(#)root/roofit:$Id$; * Authors: *; * AH, Andreas Hoecker, Orsay, hoecker@slac.stanford.edu *; * SL, Sandrine Laplace, Orsay, laplace@slac.stanford.edu *; * JS, Jan Stark, Paris, stark@slac.stanford.edu *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California, *; * IN2P3. All rights reserved. *; * *; * History *; * Nov-2001 WV Created initial version *; * Dec-2001 SL mischarge correction, direct CPV *; * Jan-2002 AH built dedicated generator + code cleaning *; * Mar-2002 JS committed debugged version to CVS *; * Apr-2002 AH allow prompt (ie, non-Pdf) mischarge treatment *; * May-2002 JS Changed the set of CP parameters (mathematically equiv.) *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /** \class RooNonCPEigenDecay; \ingroup Roofit. Time-dependent RooAbsAnaConvPdf for CP violating decays; to Non-CP eigenstates (eg, \f$ B_0 \rightarrow \rho^\pm \pi^\mp\f$).; For a description of the physics model see the; BaBar Physics Book, section 6.5.2.3 .; The set of CP parameters used in this class is equivalent to; the one used in the Physics Book, but it is not exactly the; same. Starting from the set in the BaBar Book, in order to; get the parameters used here you have to change the sign of both; \f$a_c^+\f$ and \f$a_c^-\f$, and then substitute:; \f[; a_s^Q = S + Q \cdot \delta S \\; a_c^Q = C + Q \cdot \delta C; \f]; where Q denotes the charge of the \f$\rho\f$ meson.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx:1808,charge,charge,1808,roofit/roofit/src/RooNonCPEigenDecay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx,1,['charge'],['charge']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitModels *; * @(#)root/roofit:$Id$; * Authors: *; * GR, Gerhard Raven, UC San Diego, raven@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /** \class RooKeysPdf; \ingroup Roofit. Class RooKeysPdf implements a one-dimensional kernel estimation p.d.f which model the distribution; of an arbitrary input dataset as a superposition of Gaussian kernels, one for each data point,; each contributing 1/N to the total integral of the pdf.; If the 'adaptive mode' is enabled, the width of the Gaussian is adaptively calculated from the; local density of events, i.e. narrow for regions with high event density to preserve details and; wide for regions with low event density to promote smoothness. The details of the general algorithm; are described in the following paper:. Cranmer KS, Kernel Estimation in High-Energy Physics.; Computer Physics Communications 136:198-207,2001 - e-Print Archive: hep ex/0011057; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooKeysPdf.cxx:1056,adapt,adaptive,1056,roofit/roofit/src/RooKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooKeysPdf.cxx,3,"['Energy', 'adapt']","['Energy', 'adaptive', 'adaptively']"
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitModels *; * @(#)root/roofit:$Id$; * Authors: *; * TS, Thomas Schietinger, SLAC, schieti@slac.stanford.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /** \class RooVoigtian; \ingroup Roofit. RooVoigtian is an efficient implementation of the convolution of a; Breit-Wigner with a Gaussian, making use of the complex error function.; RooFitCore provides two algorithms for the evaluation of the complex error; function (the default CERNlib C335 algorithm, and a faster, look-up-table; based method). By default, RooVoigtian employs the default (CERNlib); algorithm. Select the faster algorithm either in the constructor, or with; the selectFastAlgorithm() method. \note The ""width"" parameter that determines the Breit-Wigner shape; represents the **full width at half maximum (FWHM)** of the; Breit-Wigner (often referred to as \f$\Gamma\f$ or \f$2\gamma\f$).; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooVoigtian.cxx:692,efficient,efficient,692,roofit/roofit/src/RooVoigtian.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooVoigtian.cxx,1,['efficient'],['efficient']
Energy Efficiency,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitModels *; * File: $Id: RooNDKeysPdf.cxx 31258 2009-11-17 22:41:06Z wouter $; * Authors: *; * Max Baak, CERN, mbaak@cern.ch *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /** \class RooNDKeysPdf; \ingroup Roofit. Generic N-dimensional implementation of a kernel estimation p.d.f. This p.d.f. models the distribution; of an arbitrary input dataset as a superposition of Gaussian kernels, one for each data point,; each contributing 1/N to the total integral of the p.d.f.; If the 'adaptive mode' is enabled, the width of the Gaussian is adaptively calculated from the; local density of events, i.e. narrow for regions with high event density to preserve details and; wide for regions with log event density to promote smoothness. The details of the general algorithm; are described in the following paper:; Cranmer KS, Kernel Estimation in High-Energy Physics.; Computer Physics Communications 136:198-207,2001 - e-Print Archive: hep ex/0011057; For multi-dimensional datasets, the kernels are modeled by multidimensional Gaussians. The kernels are; constructed such that they reflect the correlation coefficients between the observables; in the input dataset.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx:833,adapt,adaptive,833,roofit/roofit/src/RooNDKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx,3,"['Energy', 'adapt']","['Energy', 'adaptive', 'adaptively']"
Energy Efficiency,"/*************************************************************************. THnSparse: histogramming multi-dimensional, sparse distributions in; a memory-efficient way. *************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/THnSparse.h:154,efficient,efficient,154,hist/hist/inc/THnSparse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/THnSparse.h,1,['efficient'],['efficient']
Energy Efficiency,"/*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; // ----------------------------------------------------------------------; // HEP coherent Physical Constants; // Adapted for ROOT by Marko Petric; //; // This file has been provided by Geant4 (simulation toolkit for HEP).; //; // Below is a non exhaustive list of Physical CONSTANTS,; // computed in the Internal HEP System Of Units.; //; // Most of them are extracted from the Particle Data Book :; // Phys. Rev. D volume 50 3-1 (1994) page 1233; //; //; // Author: M.Maire; //; // History:; //; // 23.02.96 Created; // 26.03.96 Added constants for standard conditions of temperature; // and pressure; also added Gas threshold.; // 29.04.08 use PDG 2006 values; // 03.11.08 use PDG 2008 values; // 02.10.17 addopted constant from CLHEP 2.3.4.3",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeant4PhysicalConstants.h:472,Adapt,Adapted,472,geom/geom/inc/TGeant4PhysicalConstants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeant4PhysicalConstants.h,2,['Adapt'],['Adapted']
Energy Efficiency,"/*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; // ----------------------------------------------------------------------; // HEP coherent system of Units; //; // This file has been provided to CLHEP by Geant4 (simulation toolkit for HEP).; // Adapted to TGeo units base by Marko Petric; //; // The basic units are :; // millimeter (millimeter); // nanosecond (nanosecond); // Mega electron Volt (MeV); // positron charge (eplus); // degree Kelvin (kelvin); // the amount of substance (mole); // luminous intensity (candela); // radian (radian); // steradian (steradian); //; // Below is a non exhaustive list of derived and pratical units; // (i.e. mostly the SI units).; // You can add your own units.; //; // The SI numerical value of the positron charge is defined here,; // as it is needed for conversion factor : positron charge = e_SI (coulomb); //; // The others physical constants are defined in the header file :; // PhysicalConstants.h; //; // Authors: M.Maire, S.Giani; //; // History:; //; // 06.02.96 Created.; // 28.03.96 Added miscellaneous constants.; // 05.12.97 E.Tcherniaev: Redefined pascal (to avoid warnings on WinNT); // 20.05.98 names: meter, second, gram, radian, degree; // (from Brian.Lasiuk@yale.edu (STAR)). Added luminous units.; // 05.08.98 angstrom, picobarn, microsecond, picosecond, petaelectronvolt; // 01.03.01 parsec; // 31.01.06 kilogray, milligray, microgray; // 29.04.08 use PDG 2006 value of e_SI; // 03.11.08 use PDG 2008 value of e_SI; // 19.08.15 added liter and its sub units (mma); // 12.01.16 added symbols for microsecond (us) and picosecond (ps) (mma); // 02.10.17 addopted units from CLHEP 2.3.4.3 and converted to TGeo unit base",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeant4SystemOfUnits.h:554,Adapt,Adapted,554,geom/geom/inc/TGeant4SystemOfUnits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeant4SystemOfUnits.h,10,"['Adapt', 'charge', 'meter']","['Adapted', 'charge', 'meter']"
Energy Efficiency,"/***********************************************************************; * *; * Name: GIFencode Date: 02.10.92 *; * Author: E.Chernyaev (IHEP/Protvino) Revised: *; * *; * Function: GIF compression of the image *; * *; * Input: Width - image width (must be >= 8) *; * Height - image height (must be >= 8) *; * Ncol - number of colors *; * R[] - red components *; * G[] - green components *; * B[] - blue components *; * ScLine[] - array for scan line (byte per pixel) *; * get_scline - user routine to read scan line: *; * get_scline(y, Width, ScLine) *; * pb - user routine for ""put_byte"": pb(b) *; * *; * Return: size of GIF *; * *; ***********************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/gifencode.c:371,green,green,371,graf2d/win32gdk/src/gifencode.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/gifencode.c,2,['green'],['green']
Energy Efficiency,/***************************************************************; * *; * Name: GIFdecode Date: 06.10.92 *; * *; * Function: Decode image from GIF array *; * *; * Input: GIFarr[] - compressed image in GIF format *; * *; * Output: PIXarr[] - image (byte per pixel) *; * Width - image width *; * Height - image height *; * Ncols - number of colors *; * R[] - red components *; * G[] - green components *; * B[] - blue components *; * return - 0 - if O.K. *; * 1 - if error *; * *; ***************************************************************/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/gifdecode.c:382,green,green,382,graf2d/win32gdk/src/gifdecode.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/gifdecode.c,2,['green'],['green']
Energy Efficiency,"/***************************************; * Simple API; ***************************************/; /*! ZSTD_compress() :; * Compresses `src` content as a single zstd compressed frame into already allocated `dst`.; * Hint : compression runs faster if `dstCapacity` >= `ZSTD_compressBound(srcSize)`.; * @return : compressed size written into `dst` (<= `dstCapacity),; * or an error code if it fails (which can be tested using ZSTD_isError()). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:195,allocate,allocated,195,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['allocate'],['allocated']
Energy Efficiency,"/********************; * Color allocation *; ********************/; /* Try to allocate a single color using alloc_color. If it succeeds,; * cache the result in our colormap, and store in ret.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c:78,allocate,allocate,78,graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c,1,['allocate'],['allocate']
Energy Efficiency,/*******************/; /****d* libAfterImage/ARGB32; * NAME; * ARGB32 - main color datatype; * FUNCTION; * ARGB32 is fundamental datatype that hold 32bit value corresponding to; * pixels color and transparency value (alpha channel) in ARGB; * colorspace. It is encoded as follows :; * Lowermost 8 bits - Blue channel; * bits 8 to 15 - Green channel; * bits 16 to 23 - Red channel; * bits 24 to 31 - Alpha channel; * EXAMPLE; * ASTile.1; * SOURCE; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.h:335,Green,Green,335,graf2d/asimage/src/libAfterImage/asvisual.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.h,1,['Green'],['Green']
Energy Efficiency,"/********/; /****f* libAfterImage/asimage/start_image_decoding(); * NAME; * start_image_decoding() - allocates and initializes decoder structure.; * SYNOPSIS; * ASImageDecoder *start_image_decoding( ASVisual *asv,ASImage *im,; * ASFlagType filter,; * int offset_x, int offset_y,; * unsigned int out_width,; * unsigned int out_height,; * ASImageBevel *bevel );; * INPUTS; * asv - pointer to valid ASVisual structure ( needed mostly; * 			to see if we are in BGR mode or not );; * im - ASImage we are going to decode;; * filter - bitmask where set bits mark channels that has to be; * 			decoded.; * offset_x - left margin inside im, from which we should start; * 			reading pixel data, effectively clipping source image.; * offset_y - top margin inside im, from which we should start; * 			reading scanlines, effectively clipping source image.; * 			Note that when edge of the image is reached,; * 			subsequent requests for scanlines will wrap around to; * 			the top of the image, and not offset_y.; * out_width- width of the scanline needed. If it is larger then; * 			source image - then image data will be tiled in it.; * 			If it is smaller - then image data will be clipped.; * out_height - height of the output drawable. -1 means that same as; * image height. if out_height is greater then image height,; * then image will be tiled.; * bevel - NULL or pointer to valid ASImageBevel structure if; * 			decoded data should be overlayed with bevel at the; * 			time of decoding.; * RETURN VALUE; * start_image_decoding() returns pointer to newly allocated; * ASImageDecoder structure on success, NULL on failure.; * DESCRIPTION; * Normal process of reading image data from ASImage consists of; * 3 steps :; * 1) start decoding by calling start_image_decoding.; * 2) call decode_image_scanline() method of returned structure, for; * each scanline upto desired height of the target image. Decoded data; * will be returned in buffer member of the ASImageDecoder structure.; * 3) finish decoding and d",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/imencdec.h:101,allocate,allocates,101,graf2d/asimage/src/libAfterImage/imencdec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/imencdec.h,1,['allocate'],['allocates']
Energy Efficiency,/****d* libAfterImage/ColorPart; * NAME; * IC_RED - red channel; * NAME; * IC_GREEN - green channel; * NAME ; * IC_BLUE - blue channel; * NAME; * IC_ALPHA - alpha channel; * NAME; * IC_NUM_CHANNELS - number of supported channels; * FUNCTION; * Ids of the channels. These are basically synonyms to related ARGB32; * channel numbers; * SOURCE; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.h:86,green,green,86,graf2d/asimage/src/libAfterImage/asvisual.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.h,1,['green'],['green']
Energy Efficiency,"/****d* libAfterImage/colorspace; * NAME; * colorspace; * DESCRIPTION; * RGB colorspace: each color is represented as a combination of; * red, green and blue values. Each value can be in 2 formats :; * 8 bit and 24.8 bit. 24.8 bit makes for 32bit value with lower 8 bits; * used as a fraction for better calculation precision.; *; * HSV colorspace: each color is represented as a combination of; * hue, saturation and value. Hue is generally colorizing component where; * value represents brightness.; *; * HLS colorspace: each color is represented as a combination of; * hue, luminance and saturation. It is analogous to HSV with value; * substituted by luminance, except that luminance could be both; * negative and positive.; *; * alpha channel could be added to any of the above colorspaces. alpha; * channel is generally used to define transparentness of the color.; * libAfterImage is using ARGB colorspace as a base colorspace, and; * represents most colors as ARGB32 values or ASScanline scanlines of; * pixels.; ****************/; /****f* libAfterImage/rgb2value(); * NAME; * rgb2value(); * NAME; * rgb2saturation(); * NAME; * rgb2hue(); * NAME; * rgb2luminance(); * SYNOPSIS; * CARD32 rgb2value( CARD32 red, CARD32 green, CARD32 blue );; * CARD32 rgb2saturation( CARD32 red, CARD32 green, CARD32 blue );; * CARD32 rgb2hue( CARD32 red, CARD32 green, CARD32 blue );; * CARD32 rgb2luminance (CARD32 red, CARD32 green, CARD32 blue );; * INPUTS; * red - 32 bit value, 16 lower bits of which represent red channel; * green - 32 bit value, 16 lower bits of which represent green channel; * blue - 32 bit value, 16 lower bits of which represent blue channel; * RETURN VALUE; * 32 bit value, 16 lower bits of which represent value, saturation, hue,; * or luminance respectively.; * DESCRIPTION; * This functions translate RGB color into respective coordinates of; * HSV and HLS colorspaces.; * Returned hue values are in 16bit format. To translate it to and from; * conventional 0-360 degree range, p",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.h:143,green,green,143,graf2d/asimage/src/libAfterImage/blender.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.h,1,['green'],['green']
Energy Efficiency,"/****f* libAfterImage/asimage/asimage_init(); * NAME ; * asimage_init() frees datamembers of the supplied ASImage structure, and; * 	initializes it to all 0.; * SYNOPSIS; * void asimage_init (ASImage * im, Bool free_resources);; * INPUTS; * im - pointer to valid ASImage structure; * free_resources - if True will make function attempt to free; * all non-NULL pointers.; *********/; /****f* libAfterImage/asimage/flush_asimage_cache(); * NAME; * flush_asimage_cache() destroys XImage and mask XImage kept from previous ; * conversions to/from X Pixmap.; * SYNOPSIS; * void flush_asimage_cache (ASImage * im );; * INPUTS; * im - pointer to valid ASImage structure; *********/; /****f* libAfterImage/asimage/asimage_start(); * NAME; * asimage_start() Allocates memory needed to store scanline of the image ; * of supplied size. Assigns all the data members valid values. Makes sure ; * that ASImage structure is ready to store image data.; * SYNOPSIS; * void asimage_start (ASImage * im, unsigned int width,; * unsigned int height,; * unsigned int compression);; * INPUTS; * im - pointer to valid ASImage structure; * width - width of the image; * height - height of the image; * compression - level of compression to perform on image data.; * compression has to be in range of 0-100 with 100; * signifying highest level of compression.; * NOTES; * In order to resize ASImage structure after asimage_start() has been; * called, asimage_init() must be invoked to free all the memory, and; * then asimage_start() has to be called with new dimensions.; *********/; /****f* libAfterImage/asimage/create_asimage(); * NAME; * create_asimage() Performs memory allocation for the new ASImage ; * structure, as well as initialization of allocated structure based on ; * supplied parameters.; * SYNOPSIS; * ASImage *create_asimage( unsigned int width,; * unsigned int height,; * unsigned int compression);; * INPUTS; * width - desired image width; * height - desired image height; * compression - compression leve",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:749,Allocate,Allocates,749,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,1,['Allocate'],['Allocates']
Energy Efficiency,"/****f* libAfterImage/asimage/create_image_layers(); * NAME ; * create_image_layers() - allocate and initialize set of ASImageLayer's.; * SYNOPSIS; * ASImageLayer *create_image_layers( int count );; * INPUTS; * count - number of ASImageLayer structures in allocated array.; * RETURN VALUE; * Pointer to newly allocated and initialized array of ASImageLayer; * structures on Success. NULL in case of any kind of error - that; * should never happen.; * DESCRIPTION; * Performs memory allocation for the new array of ASImageLayer; * structures, as well as initialization of allocated structure to; * sensible defaults - merge_func will be set to alphablend_scanlines.; *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:88,allocate,allocate,88,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,4,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"/****f* libAfterImage/asimage/destroy_image_layers(); * NAME ; * destroy_image_layers() - destroy set of ASImageLayer structures.; * SYNOPSIS; * void destroy_image_layers(ASImageLayer *l,; * int count,; * Bool reusable );; * INPUTS; * l			- pointer to pointer to valid array of ASImageLayer; * structures.; * count - number of structures in array.; * reusable - if True - then array itself will not be deallocates -; * which is usable when it was allocated on stack.; * DESCRIPTION; * frees all the memory allocated for specified array of ASImageLayer s.; * If there was ASImage and/or ASImageBevel attached to it - it will be; * deallocated as well.; *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:447,allocate,allocated,447,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,2,['allocate'],['allocated']
Energy Efficiency,"/****f* libAfterImage/asimage2ximage(); * NAME; * asimage2ximage(); * SYNOPSIS; * XImage *asimage2ximage (struct ASVisual *asv, ASImage *im);; * INPUTS; * asv 		- pointer to valid ASVisual structure; * im 		- source ASImage; * RETURN VALUE; * On success returns newly created and encoded XImage of the same; * colordepth as the supplied ASVisual. NULL on failure.; * DESCRIPTION; * asimage2ximage() creates new XImage of the exact same size as; * supplied ASImage, and depth of supplied ASVisual. REd, Green and; * Blue channels of ASImage then gets decoded, and encoded into XImage.; * Missing scanlines get filled with black color.; * NOTES; * Returned pointer to XImage will also be stored in im->alt.ximage,; * and It will be destroyed when XImage is destroyed, or reused in any; * subsequent calls to asimage2ximage(). If any other behaviour is; * desired - make sure you set im->alt.ximage to NULL, to dissociate; * XImage object from ASImage.; * SEE ALSO; * create_visual_ximage(); *********/; /****f* libAfterImage/asimage2alpha_ximage(); * NAME; * asimage2alpha_ximage(); * SYNOPSIS; * XImage *asimage2alpha_ximage (struct ASVisual *asv, ; * ASImage *im, Bool bitmap);; * INPUTS; * asv 		- pointer to valid ASVisual structure; * im 		- source ASImage; * bitmap - if True resulting XImage will have depth of 1 bit -; * traditional X mask; otherwise it will have depth of 8; * (usefull for XFree86 RENDER extension); * RETURN VALUE; * On success returns newly created and encoded XImage of the depth 1 or 8.; * NULL on failure.; * DESCRIPTION; * asimage2alpha_ximage() creates new XImage of the exact same size as; * supplied ASImage, and depth 1 or 8. Alpha channels of ASImage then gets; * decoded, and encoded into XImage. In case requested depth is 1 then; * alpha channel is interpreted like so: 127 or greater is encoded as 1,; * otherwise as 0.; * Missing scanlines get filled with 1s as they signify absence of mask.; * NOTES; * Returned pointer to XImage will also be stored in im->alt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ximage.h:502,Green,Green,502,graf2d/asimage/src/libAfterImage/ximage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ximage.h,1,['Green'],['Green']
Energy Efficiency,"/****f* libAfterImage/colormap_asimage(); * NAME; * colormap_asimage(); * SYNOPSIS; * int *colormap_asimage( ASImage *im, ASColormap *cmap,; * unsigned int max_colors, unsigned int dither,; * int opaque_threshold );; * INPUTS; * im				- pointer to valid ASImage structure.; * cmap - preallocated structure to store colormap in.; * max_colors - maximum size of the colormap.; * dither - number of bits to strip off the color data ( 0...7 ); * opaque_threshold - alpha channel threshold at which pixel should be; * treated as opaque; * RETURN VALUE; * pointer to the array of indexes representing pixel's colorcells. This; * array has size of WIDTHxHEIGHT where WIDTH and HEIGHT are size of the; * source image.; * DESCRIPTION; * This function is all that is needed to quantize the ASImage. In order; * to obtain colorcell of the pixel at (x,y) from result, the following; * code could be used :; * cmap->entries[res[y*width+x]]; * where res is returned pointer.; * Recommended value for dither parameter is 4 while quantizing photos to; * 256 colors, and it could be less , if original has limited number of; * colors.; *; *********/; /****f* libAfterImage/destroy_colormap(); * NAME; * destroy_colormap(); * SYNOPSIS; * void destroy_colormap( ASColormap *cmap, Bool reusable );; * INPUTS; * cmap				- pointer to valid ASColormap structure.; * reusable - if True, then the memory pointed to by cmap will; * not be deallocated, as if it was allocated on stack; * DESCRIPTION; * Destroys ASColormap object created using colormap_asimage.; *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ascmap.h:1439,allocate,allocated,1439,graf2d/asimage/src/libAfterImage/ascmap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ascmap.h,1,['allocate'],['allocated']
Energy Efficiency,"/****f* libAfterImage/create_asvisual_for_id(); * NAME; * create_asvisual_for_id(); * SYNOPSIS; * ASVisual *create_asvisual_for_id( Display *dpy, int screen,; * int default_depth,; * VisualID visual_id, Colormap cmap,; * ASVisual *reusable_memory );; * INPUTS; * dpy 		- valid pointer to opened X display.; * screen 	- screen number on which to query visuals.; * root 	- root window on that screen.; * default_depth- default colordepth of the screen.; * visual_id - ID of X visual to use.; * cmap - optional ID of the colormap to be used.; * reusable_memory - pointer to preallocated ASVisual structure.; * RETURN VALUE; * Pointer to ASVisual structure initialized with enough information; * to be able to deal with current X Visual.; * DESCRIPTION; * This function calls all the needed functions in order to setup new; * ASVisual structure for the specified screen and visual. If; * reusable_memory is not null - it will not allocate new ASVisual; * structure, but instead will use supplied one. Useful for allocating; * ASVisual on stack.; * This particular function will not do any autodetection and will use; * Visual ID supplied. That is usefull when libAfterImage is used with; * an app that has its own approach to Visual handling, and since Visuals; * on all Windows, Pixmaps and colormaps must match, there is a need to; * synchronise visuals used by an app and libAfterImage.; *********/; /****f* libAfterImage/create_asvisual(); * NAME; * create_asvisual(); * SYNOPSIS; * ASVisual *create_asvisual( Display *dpy, int screen,; * int default_depth,; * ASVisual *reusable_memory );; * INPUTS; * dpy 		- valid pointer to opened X display.; * screen 	- screen number on which to query visuals.; * root 	- root window on that screen.; * default_depth- default colordepth of the screen.; * reusable_memory - pointer to preallocated ASVisual structure.; * RETURN VALUE; * Pointer to ASVisual structure initialized with enough information; * to be able to deal with current X Visual.; * DESCRIPTION;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.h:926,allocate,allocate,926,graf2d/asimage/src/libAfterImage/asvisual.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.h,1,['allocate'],['allocate']
Energy Efficiency,"/****f* libAfterImage/hsv2rgb(); * NAME; * hsv2rgb(); * NAME; * hls2rgb(); * SYNOPSIS; * void hsv2rgb( CARD32 hue, CARD32 saturation, CARD32 value,; * CARD32 *red, CARD32 *green, CARD32 *blue);; * void hls2rgb( CARD32 hue, CARD32 luminance, CARD32 saturation,; * CARD32 *red, CARD32 *green, CARD32 *blue);; * INPUTS; * hue - 32 bit value, 16 lower bits of which represent hue.; * saturation - 32 bit value, 16 lower bits of which represent saturation.; * value - 32 bit value, 16 lower bits of which represent value.; * luminance - 32 bit value, 16 lower bits of which represent luminance.; * RETURN VALUE; * 32bit value pointed to by red, green and blue will be set; * respectively to RGB color channels.; * DESCRIPTION; * This functions performs reverse translation from HSV and HSL to; * RGB color; ****************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.h:172,green,green,172,graf2d/asimage/src/libAfterImage/blender.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.h,3,['green'],['green']
Energy Efficiency,"/****f* libAfterImage/prepare_scanline(); * NAME; * prepare_scanline(); * SYNOPSIS; * ASScanline *prepare_scanline ( unsigned int width,; * unsigned int shift,; * ASScanline *reusable_memory,; * Bool BGR_mode);; * INPUTS; * width - width of the scanline.; * shift - format of contained data. 0 means - 32bit unshifted; * 8 means - 24.8bit ( 8 bit left shifted ).; * reusable_memory - preallocated object.; * BGR_mode - if True will cause xc3 to point to Blue and xc1 to; * point to red.; * DESCRIPTION; * This function allocates memory ( if reusable_memory is NULL ) for; * the new ASScanline structure. Structures buffers gets allocated to; * hold scanline data of at least width pixel wide. Buffers are adjusted; * to start on 8 byte boundary.; *********/; /****f* libAfterImage/free_scanline(); * NAME; * free_scanline(); * SYNOPSIS; * void free_scanline ( ASScanline *sl, Bool reusable );; * INPUTS; * sl - pointer to previously allocated ASScanline structure to be; * deallocated.; * reusable - if true then ASScanline object itself will not be; * deallocated.; * DESCRIPTION; * free_scanline() frees all the buffer memory allocated for ASScanline.; * If reusable is false then object itself in not freed. That is usable; * for declaring ASScanline on stack.; *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.h:519,allocate,allocates,519,graf2d/asimage/src/libAfterImage/scanline.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.h,4,['allocate'],"['allocated', 'allocates']"
Energy Efficiency,"/****f* libAfterImage/rgb2hsv(); * NAME; * rgb2hsv(); * NAME; * rgb2hls(); * SYNOPSIS; * CARD32 rgb2hsv( CARD32 red, CARD32 green, CARD32 blue,; * CARD32 *saturation, CARD32 *value );; * CARD32 rgb2hls( CARD32 red, CARD32 green, CARD32 blue,; * CARD32 *luminance, CARD32 *saturation );; * INPUTS; * red - 32 bit value, 16 lower bits of which represent red channel; * green - 32 bit value, 16 lower bits of which represent green channel; * blue - 32 bit value, 16 lower bits of which represent blue channel; * RETURN VALUE; * 32 bit value, 16 lower bits of which represent hue.; * 32bit value pointed to by luminance, value and saturation will be set; * respectively to color luminance, value and saturation.; * DESCRIPTION; * This functions translate RGB color into full set of HSV and HLS; * coordinates at once. These functions work faster then separate; * translation into each channel.; ****************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.h:124,green,green,124,graf2d/asimage/src/libAfterImage/blender.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.h,4,['green'],['green']
Energy Efficiency,"/****h* libAfterImage/ascmap.h; * NAME; * ascmap - Defines main structures and function for image quantization.; * DESCRIPTION; * Image quantization is needed primarily in order to be able to export; * images into file, with colormap format, such as GIF and XPM.; * libAfterImage attempts to allocate colorcells to the most used colors,; * and then approximate remaining colors with the closest colorcell.; *; * Since quality of quantization is in reverse proportion to the number; * of colors in original image, libAfterImage allows to set arbitrary; * level of downsampling of the color spectrum in the range of 8 bit per; * channel to 1 bit per channel. Downsampling is performed by simple; * dropping of less significant bits off of color values.; *; * In order to be able to determine closeness of colors, 3-channel RGB; * values are converted into flat 24bit (or less if downsampling is used); * index. That is done by intermixing bits from different channels, like; * so : R8G8B8R7G7B7...R1G1B1. That flat index is used to arrange colors; * in ascending order, and later on to be able to find closest mapped; * color. Simple hashing technique is used to speed up the; * sorting/searching, as it allows to limit linked lists traversals.; *; * SEE ALSO; * Structures :; * ASColormapEntry; * ASColormap; *; * Functions :; * colormap_asimage(), destroy_colormap(); *; * Other libAfterImage modules :; * ascmap.h asfont.h asimage.h asvisual.h blender.h export.h; * import.h transform.h ximage.h; * AUTHOR; * Sasha Vasko <sasha at aftercode dot net>; *******/; /***********************************************************************************/; /* reduced colormap building code : */; /***********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ascmap.h:292,allocate,allocate,292,graf2d/asimage/src/libAfterImage/ascmap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ascmap.h,2,"['allocate', 'reduce']","['allocate', 'reduced']"
Energy Efficiency,"/****h* libAfterImage/asimage.h; * NAME; * asimage defines main structures and function for image manipulation.; * DESCRIPTION; * libAfterImage provides powerful functionality to load, store; * and transform images. It allows for smaller memory utilization by; * utilizing run-length encoding of the image data. There could be; * different levels of compression selected, allowing to choose best; * speed/memory ratio.; *; * SEE ALSO; * Structures :; * ASImage; * ASImageManager; * ASImageBevel; * ASImageDecoder; * ASImageOutput; * ASImageLayer; * ASGradient; *; * Functions :; * asimage_init(), asimage_start(), create_asimage(),; * clone_asimage(), destroy_asimage(); *; * ImageManager Reference counting and managing :; * create_image_manager(), destroy_image_manager(),; * store_asimage(), fetch_asimage(), query_asimage(),; * dup_asimage(), release_asimage(),; * release_asimage_by_name(), forget_asimage(),; * safe_asimage_destroy(); *; * Gradients helper functions :; * flip_gradient(), destroy_asgradient(); *; * Layers helper functions :; * init_image_layers(), create_image_layers(),; * destroy_image_layers(); *; * Encoding :; * asimage_add_line(),	asimage_add_line_mono(),; * asimage_print_line(), get_asimage_chanmask(),; * move_asimage_channel(), copy_asimage_channel(),; * copy_asimage_lines(); *; * Decoding; * start_image_decoding(), stop_image_decoding(),; * asimage_decode_line (), set_decoder_shift(),; * set_decoder_back_color(); *; * Output :; * start_image_output(), set_image_output_back_color(),; * toggle_image_output_direction(), stop_image_output(); *; * Other libAfterImage modules :; * ascmap.h asfont.h asimage.h asvisual.h blender.h export.h; * import.h transform.h ximage.h; * AUTHOR; * Sasha Vasko <sasha at aftercode dot net>; ******/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:153,power,powerful,153,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,1,['power'],['powerful']
Energy Efficiency,"/****h* libAfterImage/scanline.h; * NAME; * scanline - Structures and functions for manipulation of image data ; * in blocks of uncompressed scanlines. Each scanline has 4 32 bit channels.; * Data in scanline could be both 8bit or 16 bit, with automated ; * dithering of 16 bit data into standard 8-bit image.; * SEE ALSO; * Structures:; * 	 ASScanline; *; * Functions :; * ASScanline handling:; * 	 prepare_scanline(), free_scanline(); *; * Other libAfterImage modules :; * asvisual.h imencdec.h asimage.h blender.h; * AUTHOR; * Sasha Vasko <sasha at aftercode dot net>; ******************/; /****s* libAfterImage/ASScanline; * NAME; * ASScanline - structure to hold contents of the single scanline.; * DESCRIPTION; * ASScanline holds data for the single scanline, split into channels; * with 32 bits per pixel per channel. All the memory is allocated at; * once, and then split in between channels. There are three ways to; * access channel data :; * 1) using blue, green, red, alpha pointers.; * 2) using channels[] array of pointers - convenient in loops; * 4) using xc3, xc2, xc1 pointers. These are different from red, green,; * blue in the way that xc3 will point to blue when BGR mode is specified; * at the time of creation, otherwise it will point to red channel.; * Likewise xc1 will point to red in BGR mode and blue otherwise.; * xc2 always points to green channel's data. This is convenient while; * writing XImages and when channels in source and destination has to be; * reversed, while reading images from files.; * Channel data is always aligned by 8 byte boundary allowing for; * utilization of MMX, floating point and other 64bit registers for; * transfer and processing.; * SEE ALSO; * ASImage; * SOURCE; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.h:843,allocate,allocated,843,graf2d/asimage/src/libAfterImage/scanline.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.h,4,"['allocate', 'green']","['allocated', 'green']"
Energy Efficiency,"/****s* libAfterImage/ASVisual; * NAME; * ASVisual - an abstraction layer on top of X Server Visual.; * DESCRIPTION; * This structure has been introduced in order to compensate for the; * fact that X may have so many different types of Visuals. It provides; * shortcuts to most Visual data, compensated for differences in Visuals.; * For PseudoColor visual it also contains preallocated set of colors.; * This colormap allows us to write XImages very fast and without; * exhausting available X colors. This colormap consist of 8, 64, or 4096; * colors and constitutes fraction of colors available in particular; * colordepth. This colors are allocated to be evenly spread around RGB; * spectrum. Thus when converting from internal presentation - all we; * need to do is to discard unused bits, and use rest of them bits as; * an index in our colormap. Opposite conversion is much trickier and we; * engage into nasty business of having hash table mapping pixel values; * into colors, or straight table doing same in lower colordepths.; * Idea is that we do all internal processing in 32bit colordepth, and; * ASVisual provides us with means to convert it to actual X display; * format. Respectively ASVisual has methods to write out XImage lines; * and read XImage lines.; * ASVisual creation is a tricky process. Basically first we have to go; * through the list of available Visuals and choose the best suitable.; * Then based on the type of this Visual we have to setup our data; * members and method hooks. Several functions provided for that :; * query_screen_visual() - will lookup best suitable visual; * setup_truecolor_visual() - will setup hooks if visual is TrueColor; * setup_pseudo_visual()	 - will setup hooks and data if Visual is; * PseudoColor.; * setup_as_colormap() - will preallocate colors for PseudoColor.; * Alternative to the above is :; * create_asvisual() - it encapsulates all of the above; * functionality, and returns completely set; * up ASVisual object.; * Since Visual ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.h:642,allocate,allocated,642,graf2d/asimage/src/libAfterImage/asvisual.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.h,1,['allocate'],['allocated']
Energy Efficiency,"/***/; /* We intentionally run in a separate thread to ensure we at least minimal; * testing of a multithreaded environment (for example, having a reduced stack; * size). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c:147,reduce,reduced,147,interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c,2,['reduce'],['reduced']
Energy Efficiency,/**. template wrapped class for adapting to FCNBase signature a IGradFunction. @author Lorenzo Moneta. @ingroup Minuit. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FCNGradAdapter.h:32,adapt,adapting,32,math/minuit2/inc/Minuit2/FCNGradAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FCNGradAdapter.h,1,['adapt'],['adapting']
Energy Efficiency,/**. template wrapped class for adapting to FCNBase signature. @author Lorenzo Moneta. @ingroup Minuit. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FCNAdapter.h:32,adapt,adapting,32,math/minuit2/inc/Minuit2/FCNAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FCNAdapter.h,1,['adapt'],['adapting']
Energy Efficiency,/**. template wrapped class for adapting to FumiliFCNBase signature. @author Lorenzo Moneta. @ingroup Minuit. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FumiliFCNAdapter.h:32,adapt,adapting,32,math/minuit2/inc/Minuit2/FumiliFCNAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FumiliFCNAdapter.h,1,['adapt'],['adapting']
Energy Efficiency,"/**; 	 * Sets an offset in a larger frustum. This is useful for multi-window or; 	 * multi-monitor/multi-machine setups.; 	 *; 	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and; 	 * the monitors are in grid like this; 	 *; 	 * +---+---+---+; 	 * | A | B | C |; 	 * +---+---+---+; 	 * | D | E | F |; 	 * +---+---+---+; 	 *; 	 * then for each monitor you would call it like this; 	 *; 	 * const w = 1920;; 	 * const h = 1080;; 	 * const fullWidth = w * 3;; 	 * const fullHeight = h * 2;; 	 *; 	 * --A--; 	 * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );; 	 * --B--; 	 * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );; 	 * --C--; 	 * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );; 	 * --D--; 	 * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );; 	 * --E--; 	 * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );; 	 * --F--; 	 * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );; 	 *; 	 * Note there is no reason monitors have to be the same size or in a grid.; 	 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:91,monitor,monitor,91,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,12,['monitor'],"['monitor', 'monitors']"
Energy Efficiency,"/**; * @brief Determines the minimum lengths of the buffer and options arrays used for Parser.; *; * Because Parser doesn't use dynamic memory its output arrays have to be pre-allocated.; * If you don't want to use fixed size arrays (which may turn out too small, causing; * command line arguments to be dropped), you can use Stats to determine the correct sizes.; * Stats work cumulative. You can first pass in your default options and then the real; * options and afterwards the counts will reflect the union.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h:176,allocate,allocated,176,core/dictgen/res/OptionParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h,1,['allocate'],['allocated']
Energy Efficiency,"/**; * @defgroup Triangulation Triangulation Class; * Class performing triangulations.; */; /// @{; /**; * Data structure representing a 2D constrained Delaunay triangulation; *; * @tparam T type of vertex coordinates (e.g., float, double); * @tparam TNearPointLocator class providing locating near point for efficiently; * inserting new points. Provides methods: 'addPoint(vPos, iV)' and; * 'nearPoint(vPos) -> iV'; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:309,efficient,efficiently,309,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['efficient'],['efficiently']
Energy Efficiency,"/**; * @file; *; * @brief This is the only file required to use The Lean Mean C++ Option Parser.; * Just \#include it and you're set.; *; * The Lean Mean C++ Option Parser handles the program's command line arguments; * (argc, argv).; * It supports the short and long option formats of getopt(), getopt_long(); * and getopt_long_only() but has a more convenient interface.; * The following features set it apart from other option parsers:; *; * @par Highlights:; * <ul style=""padding-left:1em;margin-left:0"">; * <li> It is a header-only library. Just <code>\#include ""optionparser.h""</code> and you're set.; * <li> It is freestanding. There are no dependencies whatsoever, not even the; * C or C++ standard library.; * <li> It has a usage message formatter that supports column alignment and; * line wrapping. This aids localization because it adapts to; * translated strings that are shorter or longer (even if they contain; * Asian wide characters).; * <li> Unlike getopt() and derivatives it doesn't force you to loop through; * options sequentially. Instead you can access options directly like this:; * <ul style=""margin-top:.5em"">; * <li> Test for presence of a switch in the argument vector:; * @code if ( options[QUIET] ) ... @endcode; * <li> Evaluate --enable-foo/--disable-foo pair where the last one used wins:; * @code if ( options[FOO].last()->type() == DISABLE ) ... @endcode; * <li> Cumulative option (-v verbose, -vv more verbose, -vvv even more verbose):; * @code int verbosity = options[VERBOSE].count(); @endcode; * <li> Iterate over all --file=&lt;fname> arguments:; * @code for (Option* opt = options[FILE]; opt; opt = opt->next()); * fname = opt->arg; ... @endcode; * <li> If you really want to, you can still process all arguments in order:; * @code; * for (int i = 0; i < p.optionsCount(); ++i) {; * Option& opt = buffer[i];; * switch(opt.index()) {; * case HELP: ...; * case VERBOSE: ...; * case FILE: fname = opt.arg; ...; * case UNKNOWN: ...; * @endcode; * </ul>; * </ul> @n",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h:844,adapt,adapts,844,core/dictgen/res/OptionParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h,1,['adapt'],['adapts']
Energy Efficiency,"/**; * @license; * (c) Dean McNamee <dean@gmail.com>, 2013.; *; * https://github.com/deanm/omggif; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to; * deal in the Software without restriction, including without limitation the; * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or; * sell copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING; * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS; * IN THE SOFTWARE.; *; * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,; * including animation and compression. It does not rely on any specific; * underlying system, so should run in the browser, Node, or Plask.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:142,charge,charge,142,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['charge'],['charge']
Energy Efficiency,"/**; * @license; * ====================================================================; * Copyright (c) 2013 Eduardo Menezes de Morais, eduardo.morais@usp.br; *; * Permission is hereby granted, free of charge, to any person obtaining; * a copy of this software and associated documentation files (the; * ""Software""), to deal in the Software without restriction, including; * without limitation the rights to use, copy, modify, merge, publish,; * distribute, sublicense, and/or sell copies of the Software, and to; * permit persons to whom the Software is furnished to do so, subject to; * the following conditions:; *; * The above copyright notice and this permission notice shall be; * included in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF; * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE; * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION; * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION; * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.; * ====================================================================; */; /**; * jsPDF total_pages plugin; * @name total_pages; * @module; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:203,charge,charge,203,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['charge'],['charge']
Energy Efficiency,"/**; * @license; * ====================================================================; * Copyright (c) 2013 Youssef Beddad, youssef.beddad@gmail.com; * 2013 Eduardo Menezes de Morais, eduardo.morais@usp.br; * 2013 Lee Driscoll, https://github.com/lsdriscoll; * 2014 Juan Pablo Gaviria, https://github.com/juanpgaviria; * 2014 James Hall, james@parall.ax; * 2014 Diego Casorran, https://github.com/diegocr; *; * Permission is hereby granted, free of charge, to any person obtaining; * a copy of this software and associated documentation files (the; * ""Software""), to deal in the Software without restriction, including; * without limitation the rights to use, copy, modify, merge, publish,; * distribute, sublicense, and/or sell copies of the Software, and to; * permit persons to whom the Software is furnished to do so, subject to; * the following conditions:; *; * The above copyright notice and this permission notice shall be; * included in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF; * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE; * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION; * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION; * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.; * ====================================================================; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/jspdf.mjs:451,charge,charge,451,js/modules/jspdf.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/jspdf.mjs,1,['charge'],['charge']
Energy Efficiency,"/**; * @license; * ====================================================================; * Copyright (c) 2013 Youssef Beddad, youssef.beddad@gmail.com; * 2013 Eduardo Menezes de Morais, eduardo.morais@usp.br; * 2013 Lee Driscoll, https://github.com/lsdriscoll; * 2014 Juan Pablo Gaviria, https://github.com/juanpgaviria; * 2014 James Hall, james@parall.ax; * 2014 Diego Casorran, https://github.com/diegocr; *; * Permission is hereby granted, free of charge, to any person obtaining; * a copy of this software and associated documentation files (the; * ""Software""), to deal in the Software without restriction, including; * without limitation the rights to use, copy, modify, merge, publish,; * distribute, sublicense, and/or sell copies of the Software, and to; * permit persons to whom the Software is furnished to do so, subject to; * the following conditions:; *; * The above copyright notice and this permission notice shall be; * included in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF; * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE; * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION; * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION; * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.; * ====================================================================; */; /**; * @name cell; * @module; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:451,charge,charge,451,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['charge'],['charge']
Energy Efficiency,"/**; * @license; * ====================================================================; * Copyright (c) 2013 Youssef Beddad, youssef.beddad@gmail.com; *; * Permission is hereby granted, free of charge, to any person obtaining; * a copy of this software and associated documentation files (the; * ""Software""), to deal in the Software without restriction, including; * without limitation the rights to use, copy, modify, merge, publish,; * distribute, sublicense, and/or sell copies of the Software, and to; * permit persons to whom the Software is furnished to do so, subject to; * the following conditions:; *; * The above copyright notice and this permission notice shall be; * included in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF; * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE; * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION; * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION; * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.; * ====================================================================; */; /**; * jsPDF JavaScript plugin; *; * @name javascript; * @module; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:195,charge,charge,195,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['charge'],['charge']
Energy Efficiency,"/**; * @license; *; * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb; *; * Permission is hereby granted, free of charge, to any person obtaining; * a copy of this software and associated documentation files (the; * ""Software""), to deal in the Software without restriction, including; * without limitation the rights to use, copy, modify, merge, publish,; * distribute, sublicense, and/or sell copies of the Software, and to; * permit persons to whom the Software is furnished to do so, subject to; * the following conditions:; *; * The above copyright notice and this permission notice shall be; * included in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF; * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE; * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION; * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION; * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.; * ====================================================================; */; /**; * @license; * (c) Dean McNamee <dean@gmail.com>, 2013.; *; * https://github.com/deanm/omggif; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to; * deal in the Software without restriction, including without limitation the; * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or; * sell copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/jspdf.mjs:127,charge,charge,127,js/modules/jspdf.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/jspdf.mjs,1,['charge'],['charge']
Energy Efficiency,"/**; * @license; *; * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb; *; * Permission is hereby granted, free of charge, to any person obtaining; * a copy of this software and associated documentation files (the; * ""Software""), to deal in the Software without restriction, including; * without limitation the rights to use, copy, modify, merge, publish,; * distribute, sublicense, and/or sell copies of the Software, and to; * permit persons to whom the Software is furnished to do so, subject to; * the following conditions:; *; * The above copyright notice and this permission notice shall be; * included in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF; * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE; * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION; * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION; * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.; * ====================================================================; */; /**; * jsPDF PNG PlugIn; * @name png_support; * @module; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:127,charge,charge,127,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['charge'],['charge']
Energy Efficiency,"/**; * @license; *; * Copyright (c) 2021 Antti Palola, https://github.com/Pantura; *; * Permission is hereby granted, free of charge, to any person obtaining; * a copy of this software and associated documentation files (the; * ""Software""), to deal in the Software without restriction, including; * without limitation the rights to use, copy, modify, merge, publish,; * distribute, sublicense, and/or sell copies of the Software, and to; * permit persons to whom the Software is furnished to do so, subject to; * the following conditions:; *; * The above copyright notice and this permission notice shall be; * included in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF; * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE; * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION; * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION; * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.; * ====================================================================; */; /**; * jsPDF RGBA array PlugIn; * @name rgba_support; * @module; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:126,charge,charge,126,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['charge'],['charge']
Energy Efficiency,"/**; * @name processRGBA; * @function; *; * Process RGBA Array. This is a one-dimension array with pixel data [red, green, blue, alpha, red, green, ...].; * RGBA array data can be obtained from DOM canvas getImageData.; * @ignore; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:116,green,green,116,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['green'],['green']
Energy Efficiency,/**; * @}; */; /**; * @defgroup LLVMCCoreValueInstructionAlloca Allocas; *; * Functions in this group only apply to instructions that map to; * llvm::AllocaInst instances.; *; * @{; */; /**; * Obtain the type that is being allocated by the alloca instruction.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:223,allocate,allocated,223,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['allocate'],['allocated']
Energy Efficiency,"/**; * A pinned array of specific type that allocated on the host with `cudaMallocHost` and freed with `cudaFreeHost`.; * The memory is ""pinned"", i.e. page-locked and accessible to the device for fast copying.; * \see The documentation of `cudaMallocHost` on <a; * href=""https://developer.download.nvidia.com/compute/DevZone/docs/html/C/doc/html/group__CUDART__HIGHLEVEL_ge439496de696b166ba457dab5dd4f356.html"">developer.download.nvidia.com</a>.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/CudaInterface.h:44,allocate,allocated,44,roofit/batchcompute/src/CudaInterface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/CudaInterface.h,1,['allocate'],['allocated']
Energy Efficiency,/**; * Align must be a power of 2.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h:23,power,power,23,builtins/zstd/compress/zstd_cwksp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h,1,['power'],['power']
Energy Efficiency,/**; * An array of specific type that is allocated on the device with `cudaMalloc` and freed with `cudaFree`.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/CudaInterface.h:41,allocate,allocated,41,roofit/batchcompute/src/CudaInterface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/CudaInterface.h,1,['allocate'],['allocated']
Energy Efficiency,"/**; * An opaque lookup state object. Instances of this type can be captured to; * suspend a lookup while a custom generator function attempts to produce a; * definition.; *; * If a client captures a lookup state object then they must eventually call; * LLVMOrcLookupStateContinueLookup to restart the lookup. This is required; * in order to release memory allocated for the lookup state, even if errors; * have occurred while the lookup was suspended (if these errors have made the; * lookup impossible to complete then it will issue its own error before; * destruction).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:357,allocate,allocated,357,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h,1,['allocate'],['allocated']
Energy Efficiency,"/**; * Compute x to the power y, where x is >= 0. The range of; * x and y are implementation-defined. The maximum error; * is implementation-defined.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:24,power,power,24,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h,1,['power'],['power']
Energy Efficiency,"/**; * Compute x to the power y, where x is >= 0.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:24,power,power,24,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h,1,['power'],['power']
Energy Efficiency,/**; * Constructor; * @param vertexInsertionOrder strategy used for ordering vertex insertions; * @param nearPtLocator class providing locating near point for efficiently; * inserting new points; * @param intersectingEdgesStrategy strategy for treating intersecting; * constraint edges; * @param minDistToConstraintEdge distance within which point is considered; * to be lying on a constraint edge. Used when adding constraints to the; * triangulation.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:159,efficient,efficiently,159,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['efficient'],['efficiently']
Energy Efficiency,"/**; * Conversion functions between full- and half-precision floats. The code used here is taken (with some modifications); * from the `half` C++ library (https://half.sourceforge.net/index.html), distributed under the MIT license.; *; * Original license:; *; * The MIT License; *; * Copyright (c) 2012-2021 Christian Rau; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/v7/inc/ROOT/RFloat16.hxx:366,charge,charge,366,core/base/v7/inc/ROOT/RFloat16.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/v7/inc/ROOT/RFloat16.hxx,1,['charge'],['charge']
Energy Efficiency,"/**; * Create a simple custom MCJIT memory manager. This memory manager can; * intercept allocations in a module-oblivious way. This will return NULL; * if any of the passed functions are NULL.; *; * @param Opaque An opaque client object to pass back to the callbacks.; * @param AllocateCodeSection Allocate a block of memory for executable code.; * @param AllocateDataSection Allocate a block of memory for data.; * @param FinalizeMemory Set page permissions and flush cache. Return 0 on; * success, 1 on error.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:279,Allocate,AllocateCodeSection,279,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,4,['Allocate'],"['Allocate', 'AllocateCodeSection', 'AllocateDataSection']"
Energy Efficiency,/**; * Dispose of a heap-allocated PassBuilderOptions instance; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h:25,allocate,allocated,25,interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h,1,['allocate'],['allocated']
Energy Efficiency,"/**; * Draws an image, canvas, or video onto the canvas; *; * @function; * @param img {} Specifies the image, canvas, or video element to use; * @param sx {Number} Optional. The x coordinate where to start clipping; * @param sy {Number} Optional. The y coordinate where to start clipping; * @param swidth {Number} Optional. The width of the clipped image; * @param sheight {Number} Optional. The height of the clipped image; * @param x {Number} The x coordinate where to place the image on the canvas; * @param y {Number} The y coordinate where to place the image on the canvas; * @param width {Number} Optional. The width of the image to use (stretch or reduce the image); * @param height {Number} Optional. The height of the image to use (stretch or reduce the image); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:655,reduce,reduce,655,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['reduce'],['reduce']
Energy Efficiency,"/**; * Draws the element referenced by a use node, makes use of pdf's XObjects/FormObjects so nodes are only written once; * to the pdf document. This highly reduces the file size and computation time.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:158,reduce,reduces,158,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['reduce'],['reduces']
Energy Efficiency,/**; * Frees all code generator and all memory it internally allocated.; * Upon return the lto_code_gen_t is no longer valid.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:61,allocate,allocated,61,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['allocate'],['allocated']
Energy Efficiency,/**; * Frees all memory internally allocated by the LTO input file.; * Upon return the lto_module_t is no longer valid.; *; * \since LTO_API_VERSION=24; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:35,allocate,allocated,35,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['allocate'],['allocated']
Energy Efficiency,/**; * Frees all memory internally allocated by the module.; * Upon return the lto_module_t is no longer valid.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:35,allocate,allocated,35,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['allocate'],['allocated']
Energy Efficiency,/**; * Frees the generator and all memory it internally allocated.; * Upon return the thinlto_code_gen_t is no longer valid.; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:56,allocate,allocated,56,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['allocate'],['allocated']
Energy Efficiency,"/**; * Frontend action adaptor that merges ASTs together.; *; * This action takes an existing AST file and ""merges"" it into the AST; * context, producing a merged context. This action is an action; * adaptor, which forwards most of its calls to another action that; * will consume the merged context.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendActions.h:23,adapt,adaptor,23,interpreter/llvm-project/clang/include/clang/Frontend/FrontendActions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendActions.h,2,['adapt'],['adaptor']
Energy Efficiency,"/**; * Get the elements within a structure.; *; * The function is passed the address of a pre-allocated array of; * LLVMTypeRef at least LLVMCountStructElementTypes() long. After; * invocation, this array will be populated with the structure's; * elements. The objects in the destination array will have a lifetime; * of the structure type itself, which is the lifetime of the context it; * is contained in.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:94,allocate,allocated,94,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['allocate'],['allocated']
Energy Efficiency,"/**; * Index initialization options.; *; * 0 is the default value of each member of this struct except for Size.; * Initialize the struct in one of the following three ways to avoid adapting; * code each time a new member is added to it:; * \code; * CXIndexOptions Opts;; * memset(&Opts, 0, sizeof(Opts));; * Opts.Size = sizeof(CXIndexOptions);; * \endcode; * or explicitly initialize the first data member and zero-initialize the rest:; * \code; * CXIndexOptions Opts = { sizeof(CXIndexOptions) };; * \endcode; * or to prevent the -Wmissing-field-initializers warning for the above version:; * \code; * CXIndexOptions Opts{};; * Opts.Size = sizeof(CXIndexOptions);; * \endcode; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:182,adapt,adapting,182,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['adapt'],['adapting']
Energy Efficiency,"/**; * Look up symbols in an execution session.; *; * This is a wrapper around the general ExecutionSession::lookup function.; *; * The SearchOrder argument contains a list of (JITDylibs, JITDylibSearchFlags); * pairs that describe the search order. The JITDylibs will be searched in the; * given order to try to find the symbols in the Symbols argument.; *; * The Symbols argument should contain a null-terminated array of; * (SymbolStringPtr, SymbolLookupFlags) pairs describing the symbols to be; * searched for. This function takes ownership of the elements of the Symbols; * array. The Name fields of the Symbols elements are taken to have been; * retained by the client for this function. The client should *not* release the; * Name fields, but are still responsible for destroying the array itself.; *; * The HandleResult function will be called once all searched for symbols have; * been found, or an error occurs. The HandleResult function will be passed an; * LLVMErrorRef indicating success or failure, and (on success) a; * null-terminated LLVMOrcCSymbolMapPairs array containing the function result,; * and the Ctx value passed to the lookup function.; *; * The client is fully responsible for managing the lifetime of the Ctx object.; * A common idiom is to allocate the context prior to the lookup and deallocate; * it in the handler.; *; * THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:1272,allocate,allocate,1272,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h,1,['allocate'],['allocate']
Energy Efficiency,"/**; * Marks a memory region (<c>[addr, addr+size)</c>) as addressable.; *; * This memory must be previously allocated by your program. Accessing; * addresses in this region is allowed until this region is poisoned again.; * This function could unpoison a super-region of <c>[addr, addr+size)</c> due; * to ASan alignment restrictions.; *; * \note This function is not thread-safe because no two threads can; * poison or unpoison memory in the same memory region simultaneously.; *; * \param addr Start of memory region.; * \param size Size of memory region. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/compiler.h:109,allocate,allocated,109,builtins/zstd/common/compiler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/compiler.h,1,['allocate'],['allocated']
Energy Efficiency,"/**; * Marks a memory region (<c>[addr, addr+size)</c>) as unaddressable.; *; * This memory must be previously allocated by your program. Instrumented; * code is forbidden from accessing addresses in this region until it is; * unpoisoned. This function is not guaranteed to poison the entire region -; * it could poison only a subregion of <c>[addr, addr+size)</c> due to ASan; * alignment restrictions.; *; * \note This function is not thread-safe because no two threads can poison or; * unpoison memory in the same memory region simultaneously.; *; * \param addr Start of memory region.; * \param size Size of memory region. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/compiler.h:111,allocate,allocated,111,builtins/zstd/common/compiler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/compiler.h,1,['allocate'],['allocated']
Energy Efficiency,/**; * Obtain all of the basic blocks in a function.; *; * This operates on a function value. The BasicBlocks parameter is a; * pointer to a pre-allocated array of LLVMBasicBlockRef of at least; * LLVMCountBasicBlocks() in length. This array is populated with; * LLVMBasicBlockRef instances.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:145,allocate,allocated,145,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['allocate'],['allocated']
Energy Efficiency,"/**; * Obtain the basic blocks acting as handlers for a catchswitch instruction.; *; * The Handlers parameter should point to a pre-allocated array of; * LLVMBasicBlockRefs at least LLVMGetNumHandlers() large. On return, the; * first LLVMGetNumHandlers() entries in the array will be populated; * with LLVMBasicBlockRef instances.; *; * @param CatchSwitch The catchswitch instruction to operate on.; * @param Handlers Memory address of an array to be filled with basic blocks.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:132,allocate,allocated,132,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['allocate'],['allocated']
Energy Efficiency,/**; * Obtain the parameters in a function.; *; * The takes a pointer to a pre-allocated array of LLVMValueRef that is; * at least LLVMCountParams() long. This array will be filled with; * LLVMValueRef instances which correspond to the parameters the; * function receives. Each LLVMValueRef corresponds to a llvm::Argument; * instance.; *; * @see llvm::Function::arg_begin(); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:79,allocate,allocated,79,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['allocate'],['allocated']
Energy Efficiency,"/**; * Obtain the types of a function's parameters.; *; * The Dest parameter should point to a pre-allocated array of; * LLVMTypeRef at least LLVMCountParamTypes() large. On return, the; * first LLVMCountParamTypes() entries in the array will be populated; * with LLVMTypeRef instances.; *; * @param FunctionTy The function type to operate on.; * @param Dest Memory address of an array to be filled with result.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:99,allocate,allocated,99,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['allocate'],['allocated']
Energy Efficiency,"/**; * Provides a non-STL alternative to the STL std::map<unsigned long, unsigned long>; * which maps character codes to glyph indices inside FTCharmap.; *; * Implementation:; * - NumberOfBuckets buckets are considered.; * - Each bucket has BucketSize entries.; * - When the glyph index for the character code C has to be stored, the; * bucket this character belongs to is found using 'C div BucketSize'.; * If this bucket has not been allocated yet, do it now.; * The entry in the bucked is found using 'C mod BucketSize'.; * If it is set to IndexNotFound, then the glyph entry has not been set.; * - Try to mimic the calls made to the STL map API.; *; * Caveats:; * - The glyph index is now a signed long instead of unsigned long, so; * the special value IndexNotFound (= -1) can be used to specify that the; * glyph index has not been stored yet.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTCharToGlyphIndexMap.h:436,allocate,allocated,436,graf3d/ftgl/inc/FTCharToGlyphIndexMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTCharToGlyphIndexMap.h,1,['allocate'],['allocated']
Energy Efficiency,/**; * Reduces the ref-count for of a SymbolStringPool entry.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:7,Reduce,Reduces,7,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h,1,['Reduce'],['Reduces']
Energy Efficiency,/**; * Reduces the ref-count of a ResourceTracker.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:7,Reduce,Reduces,7,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h,1,['Reduce'],['Reduces']
Energy Efficiency,"/**; * Reparse the source files that produced this translation unit.; *; * This routine can be used to re-parse the source files that originally; * created the given translation unit, for example because those source files; * have changed (either on disk or as passed via \p unsaved_files). The; * source code will be reparsed with the same command-line options as it; * was originally parsed.; *; * Reparsing a translation unit invalidates all cursors and source locations; * that refer into that translation unit. This makes reparsing a translation; * unit semantically equivalent to destroying the translation unit and then; * creating a new translation unit with the same command-line arguments.; * However, it may be more efficient to reparse a translation; * unit using this routine.; *; * \param TU The translation unit whose contents will be re-parsed. The; * translation unit must originally have been built with; * \c clang_createTranslationUnitFromSourceFile().; *; * \param num_unsaved_files The number of unsaved file entries in \p; * unsaved_files.; *; * \param unsaved_files The files that have not yet been saved to disk; * but may be required for parsing, including the contents of; * those files. The contents and name of these files (as specified by; * CXUnsavedFile) are copied when necessary, so the client only needs to; * guarantee their validity until the call to this function returns.; *; * \param options A bitset of options composed of the flags in CXReparse_Flags.; * The function \c clang_defaultReparseOptions() produces a default set of; * options recommended for most uses, based on the translation unit.; *; * \returns 0 if the sources could be reparsed. A non-zero error code will be; * returned if reparsing was impossible, such that the translation unit is; * invalid. In such cases, the only valid call for \c TU is; * \c clang_disposeTranslationUnit(TU). The error codes returned by this; * routine are described by the \c CXErrorCode enum.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:727,efficient,efficient,727,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['efficient'],['efficient']
Energy Efficiency,/**; * Returns whether this object/buffer/etc was allocated in this workspace.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h:50,allocate,allocated,50,builtins/zstd/compress/zstd_cwksp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h,1,['allocate'],['allocated']
Energy Efficiency,"/**; * Sets the maximum cache size that can be persistent across build, in terms of; * percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over half the; * available space. A value over 100 will be reduced to 100, a value of 0 will; * be ignored. An unspecified default value will be applied.; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:281,reduce,reduced,281,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['reduce'],['reduced']
Energy Efficiency,"/**; * Sets the maximum cache size that can be persistent across build, in terms; * of percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over; * half the available space. A value over 100 will be reduced to 100, and a; * value of 0 will be ignored.; *; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:281,reduce,reduced,281,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['reduce'],['reduced']
Energy Efficiency,/**; * Sets the maximum size of the cache directory (in bytes). A value over the; * amount of available space on the disk will be reduced to the amount of; * available space. An unspecified default value will be applied. A value of 0; * will be ignored.; *; * \since LTO_API_VERSION=22; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:130,reduce,reduced,130,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['reduce'],['reduced']
Energy Efficiency,"/**; * Similar to ZSTD_nextSrcSizeToDecompress(), but when when a block input can be streamed,; * we allow taking a partial block as the input. Currently only raw uncompressed blocks can; * be streamed.; *; * For blocks that can be streamed, this allows us to reduce the latency until we produce; * output, and avoid copying the input.; *; * @param inputSize - The total amount of input that the caller currently has.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c:260,reduce,reduce,260,builtins/zstd/decompress/zstd_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c,1,['reduce'],['reduce']
Energy Efficiency,"/**; * The MIT License (MIT); *; * Copyright (c) 2015-2023 yWorks GmbH; * Copyright (c) 2013-2015 by Vitaly Puzrin; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in all; * copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; * SOFTWARE.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/svg2pdf.mjs:162,charge,charge,162,js/modules/svg2pdf.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/svg2pdf.mjs,2,['charge'],['charge']
Energy Efficiency,"/**; * The MIT License (MIT); *; * Copyright (c) 2015-2023 yWorks GmbH; * Copyright (c) 2013-2015 by Vitaly Puzrin; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in all; * copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; * SOFTWARE.; */; /******************************************************************************; Copyright (c) Microsoft Corporation. Permission to use, copy, modify, and/or distribute this software for any; purpose with or without fee is hereby granted. THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH; REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY; AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,; INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM; LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR; OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR; PERFORMANCE OF THIS SOFTWARE.; ***********************************************************************",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:162,charge,charge,162,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,1,['charge'],['charge']
Energy Efficiency,/**; * The texture index of the currently active texture; *; * We keep track of the currently active texture to try to reduce the number; * of texture bind operations.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTTextureGlyph.h:119,reduce,reduce,119,graf3d/ftgl/inc/FTTextureGlyph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTTextureGlyph.h,1,['reduce'],['reduce']
Energy Efficiency,"/**; * This is submodule produces visualizations for decision trees. The visualization is interactive, and it is made; * with d3js.; * Interactions supported:; * - Mouseover (node, weight): showing decision path; * - Zooming and grab and move supported; * - Reset zoomed tree: double click; * - Expand all closed subtrees, turn off zoom: button in the bottom of the picture; * - Click on node:; * * hiding subtree, if node children are hidden the node will have a green border; * * rescaling: bigger nodes, bigger texts; * * click again to show the subtree; * Author: Attila Bagoly <battila93@gmail.com>; * Created: 6/11/16; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/notebook/JsMVA/js/DecisionTree.js:464,green,green,464,etc/notebook/JsMVA/js/DecisionTree.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/notebook/JsMVA/js/DecisionTree.js,1,['green'],['green']
Energy Efficiency,"/**; * Use this to determine how much space in the workspace we will consume to; * allocate this object. (Normally it should be exactly the size of the object,; * but under special conditions, like ASAN, where we pad each object, it might; * be larger.); *; * Since tables aren't currently redzoned, you don't need to call through this; * to figure out how much space you need for the matchState tables. Everything; * else is though.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h:83,allocate,allocate,83,builtins/zstd/compress/zstd_cwksp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h,1,['allocate'],['allocate']
Energy Efficiency,"/**; * Used to describe whether the workspace is statically allocated (and will not; * necessarily ever be freed), or if it's dynamically allocated and we can; * expect a well-formed caller to free this.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h:60,allocate,allocated,60,builtins/zstd/compress/zstd_cwksp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h,2,['allocate'],['allocated']
Energy Efficiency,/**; * Used to indicate that the precompiled preamble should be created on; * the first parse. Otherwise it will be created on the first reparse. This; * trades runtime on the first parse (serializing the preamble takes time) for; * reduced runtime on the second parse (can now reuse the preamble).; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:233,reduce,reduced,233,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['reduce'],['reduced']
Energy Efficiency,/**; * Zero the part of the allocated tables not already marked clean.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h:28,allocate,allocated,28,builtins/zstd/compress/zstd_cwksp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h,1,['allocate'],['allocated']
Energy Efficiency,"/**; * Zstd fits all its internal datastructures into a single continuous buffer,; * so that it only needs to perform a single OS allocation (or so that a buffer; * can be provided to it and it can perform no allocations at all). This buffer; * is called the workspace.; *; * Several optimizations complicate that process of allocating memory ranges; * from this workspace for each internal datastructure:; *; * - These different internal datastructures have different setup requirements:; *; * - The static objects need to be cleared once and can then be trivially; * reused for each compression.; *; * - Various buffers don't need to be initialized at all--they are always; * written into before they're read.; *; * - The matchstate tables have a unique requirement that they don't need; * their memory to be totally cleared, but they do need the memory to have; * some bound, i.e., a guarantee that all values in the memory they've been; * allocated is less than some maximum value (which is the starting value; * for the indices that they will then use for compression). When this; * guarantee is provided to them, they can use the memory without any setup; * work. When it can't, they have to clear the area.; *; * - These buffers also have different alignment requirements.; *; * - We would like to reuse the objects in the workspace for multiple; * compressions without having to perform any expensive reallocation or; * reinitialization work.; *; * - We would like to be able to efficiently reuse the workspace across; * multiple compressions **even when the compression parameters change** and; * we need to resize some of the objects (where possible).; *; * To attempt to manage this buffer, given these constraints, the ZSTD_cwksp; * abstraction was created. It works as follows:; *; * Workspace Layout:; *; * [ ... workspace ... ]; * [objects][tables ... ->] free space [<- ... aligned][<- ... buffers]; *; * The various objects that live in the workspace are divided into the; * following",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h:943,allocate,allocated,943,builtins/zstd/compress/zstd_cwksp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h,1,['allocate'],['allocated']
Energy Efficiency,"/**; * \class RooBatchComputeInterface; * \ingroup roofit_dev_docs_batchcompute; * \brief The interface which should be implemented to provide optimised computation functions for implementations of; * RooAbsReal::doEval().; *; * The class RooBatchComputeInterface provides the mechanism for external modules (like RooFit) to call; * functions from the library. The power lies in the virtual functions that can resolve to different; * implementations for the functionality; for example, calling a function through dispatchCuda; * will resolve to efficient CUDA implementations.; *; * This interface contains the signatures of the compute functions of every PDF that has an optimised implementation; * available. These are the functions that perform the actual computations in batches.; *; * Several implementations of this interface may be provided, e.g. SSE, AVX, AVX2 etc. At run time, the fastest; * implementation of this interface is selected, and using a virtual call, the computation is dispatched to the best; * backend.; *; * \see RooBatchCompute::dispatch, RooBatchComputeClass, RF_ARCH; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooBatchCompute.h:365,power,power,365,roofit/batchcompute/res/RooBatchCompute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooBatchCompute.h,2,"['efficient', 'power']","['efficient', 'power']"
Energy Efficiency,/**; * \defgroup CINDEX_COMMENT Comment introspection; *; * The routines in this group provide access to information in documentation; * comments. These facilities are distinct from the core and may be subject to; * their own schedule of stability and deprecation.; *; * @{; */; /**; * A parsed comment.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h:226,schedul,schedule,226,interpreter/llvm-project/clang/include/clang-c/Documentation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h,1,['schedul'],['schedule']
Energy Efficiency,"/**; * class for wrapping ROOT Engines in gsl_rng types which can be used as extra; * GSL random number generators; * For this we need to implement functions which will be called by gsl_rng.; * The functions (Seed, Rndm, IntRndm) are passed in the gsl_rng_type and used to build a gsl_rng object.; * When gsl_rng is alloacated, only the memory state is allocated using calloc(1,size), which gives a memory ; * block of the given bytes and it initializes to zero. Therefore no constructor of GSLRngROOTWrapper can be called ; * and also we cannot call non-static member function of the class. ; * The underlined ROOT engine is then built and deleted using the functions CreateEngine() and FreeEngine(), ; * called by the specific GSLRandomEngine class that instantiates for the the generator (e.g. GSLRngMixMax); *; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRngROOTWrapper.h:353,allocate,allocated,353,math/mathmore/src/GSLRngROOTWrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRngROOTWrapper.h,1,['allocate'],['allocated']
Energy Efficiency,"/**; * free memory allocated by libclang, such as the buffer returned by; * \c CXVirtualFileOverlay() or \c clang_ModuleMapDescriptor_writeToBuffer().; *; * \param buffer memory pointer to free.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/BuildSystem.h:19,allocate,allocated,19,interpreter/llvm-project/clang/include/clang-c/BuildSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/BuildSystem.h,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_ascii_strup:; * @str: a string; * @len: length of @str in bytes, or -1 if @str is nul-terminated.; * ; * Converts all lower case ASCII letters to upper case ASCII letters.; * ; * Return value: a newly allocated string, with all the lower case; * characters in @str converted to upper case, with; * semantics that exactly match g_ascii_toupper. (Note; * that this is unlike the old g_strup, which modified; * the string in place.); **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstrfuncs.c:210,allocate,allocated,210,graf2d/win32gdk/gdk/src/glib/gstrfuncs.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstrfuncs.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_async_queue_length:; * @queue: a #GAsyncQueue.; * ; * Returns the length of the queue, negative values mean waiting; * threads, positive values mean available entries in the; * @queue. Actually this function returns the number of data items in; * the queue minus the number of waiting threads. Thus a return value; * of 0 could mean 'n' entries in the queue and 'n' thread waiting.; * That can happen due to locking of the queue or due to; * scheduling. ; *; * Return value: the length of the @queue.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:451,schedul,scheduling,451,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,1,['schedul'],['scheduling']
Energy Efficiency,"/**; * g_async_queue_length_unlocked:; * @queue: a #GAsyncQueue.; * ; * Returns the length of the queue, negative values mean waiting; * threads, positive values mean available entries in the; * @queue. Actually this function returns the number of data items in; * the queue minus the number of waiting threads. Thus a return value; * of 0 could mean 'n' entries in the queue and 'n' thread waiting.; * That can happen due to locking of the queue or due to; * scheduling. This function must be called while holding the @queue's; * lock.; *; * Return value: the length of the @queue.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:460,schedul,scheduling,460,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,1,['schedul'],['scheduling']
Energy Efficiency,"/**; * g_async_queue_unref:; * @queue: a #GAsyncQueue.; * ; * Decreases the reference count of the asynchronous @queue by 1. If; * the reference count went to 0, the @queue will be destroyed and the; * memory allocated will be freed. So you are not allowed to use the; * @queue afterwards, as it might have disappeared.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:209,allocate,allocated,209,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_async_queue_unref_and_unlock:; * @queue: a #GAsyncQueue.; * ; * Decreases the reference count of the asynchronous @queue by 1 and; * releases the lock. This function must be called while holding the; * @queue's lock. If the reference count went to 0, the @queue will be; * destroyed and the memory allocated will be freed. So you are not; * allowed to use the @queue afterwards, as it might have disappeared.; * The obvious asymmetry (it is not named; * g_async_queue_unref_unlocked) is because the queue can't be; * unlocked after dereffing it, as it might already have disappeared.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:307,allocate,allocated,307,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_build_filename:; * @first_element: the first element in the path; * @Varargs: remaining elements in path; * ; * Create a filename from a series of elements using the correct; * separator for filenames. This function behaves identically; * to g_build_path (G_DIR_SEPARATOR_S, first_element, ....); *; * No attempt is made to force the resulting filename to be an absolute; * path. If the first element is a relative path, the result will; * be a relative path. ; * ; * Return value: a newly allocated string that must be freed with g_free().; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gfileutils.c:499,allocate,allocated,499,graf2d/win32gdk/gdk/src/glib/gfileutils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gfileutils.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_build_path:; * @separator: a string used to separator the elements of the path.; * @first_element: the first element in the path; * @Varargs: remaining elements in path; * ; * Create a path from a series of elements using @separator as the; * separator between elements. At the boundary between two elements,; * any trailing occurrences of separator in the first element, or; * leading occurrences of separator in the second element are removed; * and exactly one copy of the separator is inserted.; * ; * Return value: a newly allocated string that must be freed with g_free().; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gfileutils.c:537,allocate,allocated,537,graf2d/win32gdk/gdk/src/glib/gfileutils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gfileutils.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_convert:; * @str: the string to convert; * @len: the length of the string; * @to_codeset: name of character set into which to convert @str; * @from_codeset: character set of @str.; * @bytes_read: location to store the number of bytes in the; * input string that were successfully converted, or %NULL.; * Even if the conversion was succesful, this may be ; * less than len if there were partial characters; * at the end of the input. If the error; * G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value; * stored will the byte fofset after the last valid; * input sequence.; * @bytes_written: the stored in the output buffer (not including the; * terminating nul.; * @error: location to store the error occuring, or %NULL to ignore; * errors. Any of the errors in #GConvertError may occur.; *; * Convert a string from one character set to another.; *; * Return value: If the conversion was successful, a newly allocated; * NUL-terminated string, which must be freed with; * g_free. Otherwise %NULL and @error will be set.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gconvert.c:916,allocate,allocated,916,graf2d/win32gdk/gdk/src/glib/gconvert.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gconvert.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_convert_with_fallback:; * @str: the string to convert; * @len: the length of the string; * @to_codeset: name of character set into which to convert @str; * @from_codeset: character set of @str.; * @fallback: UTF-8 string to use in place of character not; * present in the target encoding. (This must be; * in the target encoding), if %NULL, characters; * not in the target encoding will be represented; * as Unicode escapes \x{XXXX} or \x{XXXXXX}.; * @bytes_read: location to store the number of bytes in the; * input string that were successfully converted, or %NULL.; * Even if the conversion was succesful, this may be ; * less than len if there were partial characters; * at the end of the input.; * @bytes_written: the stored in the output buffer (not including the; * terminating nul.; * @error: location to store the error occuring, or %NULL to ignore; * errors. Any of the errors in #GConvertError may occur.; *; * Convert a string from one character set to another, possibly; * including fallback sequences for characters not representable; * in the output. Note that it is not guaranteed that the specification; * for the fallback sequences in @fallback will be honored. Some; * systems may do a approximate conversion from @from_codeset; * to @to_codeset in their iconv() functions, in which case GLib; * will simply return that approximate conversion.; *; * Return value: If the conversion was successful, a newly allocated; * NUL-terminated string, which must be freed with; * g_free. Otherwise %NULL and @error will be set.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gconvert.c:1435,allocate,allocated,1435,graf2d/win32gdk/gdk/src/glib/gconvert.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gconvert.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_convert_with_iconv:; * @str: the string to convert; * @len: the length of the string; * @converter: conversion descriptor from g_iconv_open(); * @bytes_read: location to store the number of bytes in the; * input string that were successfully converted, or %NULL.; * Even if the conversion was succesful, this may be ; * less than len if there were partial characters; * at the end of the input. If the error; * G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value; * stored will the byte fofset after the last valid; * input sequence.; * @bytes_written: the stored in the output buffer (not including the; * terminating nul.; * @error: location to store the error occuring, or %NULL to ignore; * errors. Any of the errors in #GConvertError may occur.; *; * Convert a string from one character set to another.; *; * Return value: If the conversion was successful, a newly allocated; * NUL-terminated string, which must be freed with; * g_free. Otherwise %NULL and @error will be set.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gconvert.c:878,allocate,allocated,878,graf2d/win32gdk/gdk/src/glib/gconvert.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gconvert.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_file_get_contents:; * @filename: a file to read contents from; * @contents: location to store an allocated string; * @length: location to store length in bytes of the contents; * @error: return location for a #GError; * ; * Reads an entire file into allocated memory, with good error; * checking. If @error is set, FALSE is returned, and @contents is set; * to NULL. If TRUE is returned, @error will not be set, and @contents; * will be set to the file contents. The string stored in @contents; * will be nul-terminated, so for text files you can pass NULL for the; * @length argument. The error domain is #G_FILE_ERROR. Possible; * error codes are those in the #GFileError enumeration.; *; * FIXME currently crashes if the file is too big to fit in memory;; * should probably use g_try_malloc() when we have that function.; * ; * Return value: TRUE on success, FALSE if error is set; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gfileutils.c:106,allocate,allocated,106,graf2d/win32gdk/gdk/src/glib/gfileutils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gfileutils.c,2,['allocate'],['allocated']
Energy Efficiency,"/**; * g_filename_from_uri:; * @uri: a uri describing a filename (escaped, encoded in UTF-8); * @hostname: Location to store hostname for the URI, or %NULL.; * If there is no hostname in the URI, %NULL will be; * stored in this location.; * @error: location to store the error occuring, or %NULL to ignore; * errors. Any of the errors in #GConvertError may occur.; * ; * Converts an escaped UTF-8 encoded URI to a local filename in the; * encoding used for filenames. ; * ; * Return value: a newly allocated string holding the resulting; * filename, or %NULL on an error.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gconvert.c:498,allocate,allocated,498,graf2d/win32gdk/gdk/src/glib/gconvert.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gconvert.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_filename_to_uri:; * @filename: an absolute filename specified in the encoding; * used for filenames by the operating system.; * @hostname: A UTF-8 encoded hostname, or %NULL for none.; * @error: location to store the error occuring, or %NULL to ignore; * errors. Any of the errors in #GConvertError may occur.; * ; * Converts an absolute filename to an escaped UTF-8 encoded URI.; * ; * Return value: a newly allocated string holding the resulting; * URI, or %NULL on an error.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gconvert.c:418,allocate,allocated,418,graf2d/win32gdk/gdk/src/glib/gconvert.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gconvert.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_find_program_in_path:; * @program: a program name; * ; * Locates the first executable named @program in the user's path, in the; * same way that execvp() would locate it. Returns an allocated string; * with the absolute path name, or NULL if the program is not found in; * the path. If @program is already an absolute path, returns a copy of; * @program if @program exists and is executable, and NULL otherwise.; * ; * On Windows, if @program does not have a file type suffix, tries to; * append the suffixes in the PATHEXT environment variable (if that; * doesn't exists, the suffixes .com, .exe, and .bat) in turn, and; * then look for the resulting file name in the same way as; * CreateProcess() would. This means first in the directory where the; * program was loaded from, then in the current directory, then in the; * Windows 32-bit system directory, then in the Windows directory, and; * finally in the directories in the PATH environment variable. If; * the program is found, the return value contains the full name; * including the type suffix.; *; * Return value: absolute path, or NULL; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutils.c:191,allocate,allocated,191,graf2d/win32gdk/gdk/src/glib/gutils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutils.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_get_charset:; * @charset: return location for character set name; * ; * Obtains the character set for the current locale; you might use; * this character set as an argument to g_convert(), to convert from; * the current locale's encoding to some other encoding. (Frequently; * g_locale_to_utf8() and g_locale_from_utf8() are nice shortcuts,; * though.); *; * The return value is %TRUE if the locale's encoding is UTF-8, in that; * case you can perhaps avoid calling g_convert().; *; * The string returned in @charset is not allocated, and should not be; * freed.; * ; * Return value: %TRUE if the returned charset is UTF-8; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c:533,allocate,allocated,533,graf2d/win32gdk/gdk/src/glib/gutf8.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c,1,['allocate'],['allocated']
Energy Efficiency,/**; * g_get_codeset:; * ; * Get the codeset for the current locale.; * ; * Return value: a newly allocated string containing the name; * of the codeset. This string must be freed with g_free().; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutils.c:98,allocate,allocated,98,graf2d/win32gdk/gdk/src/glib/gutils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutils.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_hash_table_destroy:; * @hash_table: a #GHashTable.; * ; * Destroys the #GHashTable. If keys and/or values are dynamically ; * allocated, you should either free them first or create the #GHashTable; * using g_hash_table_new_full(). In the latter case the destroy functions ; * you supplied will be called on all keys and values before destroying ; * the #GHashTable.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/ghash.c:135,allocate,allocated,135,graf2d/win32gdk/gdk/src/glib/ghash.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/ghash.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_hash_table_foreach_remove:; * @hash_table: a #GHashTable.; * @func: the function to call for each key/value pair.; * @user_data: user data to pass to the function.; * ; * Calls the given function for each key/value pair in the #GHashTable.; * If the function returns TRUE, then the key/value pair is removed from the; * #GHashTable. If you supplied key or value destroy functions when creating; * the #GHashTable, they are used to free the memory allocated for the removed; * keys and values.; * ; * Return value: the number of key/value pairs removed.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/ghash.c:456,allocate,allocated,456,graf2d/win32gdk/gdk/src/glib/ghash.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/ghash.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_hash_table_lookup_extended:; * @hash_table: a #GHashTable.; * @lookup_key: the key to look up.; * @orig_key: returns the original key.; * @value: returns the value associated with the key.; * ; * Looks up a key in the #GHashTable, returning the original key and the; * associated value and a gboolean which is TRUE if the key was found. This ; * is useful if you need to free the memory allocated for the original key, ; * for example before calling g_hash_table_remove().; * ; * Return value: #TRUE if the key was found in the #GHashTable.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/ghash.c:396,allocate,allocated,396,graf2d/win32gdk/gdk/src/glib/ghash.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/ghash.c,1,['allocate'],['allocated']
Energy Efficiency,/**; * g_hash_table_new_full:; * @hash_func: a function to create a hash value from a key.; * @key_equal_func: a function to check two keys for equality.; * @key_destroy_func: a function to free the memory allocated for the key ; * used when removing the entry from the #GHashTable or #NULL if you ; * don't want to supply such a function.; * @value_destroy_func: a function to free the memory allocated for the ; * value used when removing the entry from the #GHashTable or #NULL if ; * you don't want to supply such a function.; * ; * Creates a new #GHashTable like g_hash_table_new() and allows to specify; * functions to free the memory allocated for the key and value that get ; * called when removing the entry from the #GHashTable.; * ; * Return value: a new #GHashTable.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/ghash.c:206,allocate,allocated,206,graf2d/win32gdk/gdk/src/glib/ghash.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/ghash.c,3,['allocate'],['allocated']
Energy Efficiency,"/**; * g_hash_table_remove:; * @hash_table: a #GHashTable.; * @key: the key to remove.; * ; * Removes a key and its associated value from a #GHashTable.; *; * If the #GHashTable was created using g_hash_table_new_full(), the; * key and value are freed using the supplied destroy_functions, otherwise; * you have to make sure that any dynamically allocated values are freed ; * yourself.; * ; * Return value: #TRUE if the key was found and removed from the #GHashTable.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/ghash.c:346,allocate,allocated,346,graf2d/win32gdk/gdk/src/glib/ghash.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/ghash.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_io_channel_read_line:; * @channel: a #GIOChannel; * @str_return: The line read from the #GIOChannel, not including the; * line terminator. This data should be freed with g_free(); * when no longer needed. This; * is a null terminated string. If a @length of zero is; * returned, this will be %NULL instead.; * @length: location to store length of the read data, or %NULL; * @terminator_pos: location to store position of line terminator, or %NULL; * @error: A location to return an error of type #GConvertError; * or #GIOChannelError; *; * Read a line, including the terminating character(s),; * from a #GIOChannel into a newly allocated string.; * @length will contain allocated memory if the return; * is %G_IO_STATUS_NORMAL.; *; * Return value: a newly allocated string. Free this string; * with g_free() when you are done with it.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c:637,allocate,allocated,637,graf2d/win32gdk/gdk/src/glib/giochannel.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c,3,['allocate'],['allocated']
Energy Efficiency,"/**; * g_mem_is_system_malloc; * ; * Checks whether the allocator used by g_malloc() is the system's; * malloc implementation. If it returns %TRUE memory allocated with; * malloc() can be used interchangeable with memory allocated using; * g_malloc(). This function is useful for avoiding an extra copy; * of allocated memory returned by a non-GLib-based API.; *; * A different allocator can be set using g_mem_set_vtable().; *; * Return value: if %TRUE, malloc() and g_malloc() can be mixed.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c:154,allocate,allocated,154,graf2d/win32gdk/gdk/src/glib/gmem.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c,3,['allocate'],['allocated']
Energy Efficiency,/**; * g_rand_free:; * @rand: a #GRand.; *; * Frees the memory allocated for the #GRand.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/grand.c:63,allocate,allocated,63,graf2d/win32gdk/gdk/src/glib/grand.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/grand.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_strsplit:; * @string: a string to split.; * @delimiter: a string which specifies the places at which to split the string.; * The delimiter is not included in any of the resulting strings, unless; * max_tokens is reached.; * @max_tokens: the maximum number of pieces to split @string into. If this is; * less than 1, the string is split completely.; * ; * Splits a string into a maximum of @max_tokens pieces, using the given; * @delimiter. If @max_tokens is reached, the remainder of @string is appended; * to the last token. ; *; * As a special case, the result of splitting the empty string """" is an empty; * vector, not a vector containing a single string. The reason for this; * special case is that being able to represent a empty vector is typically; * more useful than consistent handling of empty elements. If you do need; * to represent empty elements, you'll need to check for the empty string; * before calling g_strsplit().; * ; * Return value: a newly-allocated %NULL-terminated array of strings. Use g_strfreev(); * to free it.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstrfuncs.c:974,allocate,allocated,974,graf2d/win32gdk/gdk/src/glib/gstrfuncs.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstrfuncs.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_thread_pool_free:; * @pool: a #GThreadPool; * @immediate: should @pool shut down immediately?; * @wait: should the function wait for all tasks to be finished?; *; * Frees all resources allocated for @pool.; *; * If @immediate is #TRUE, no new task is processed for; * @pool. Otherwise @pool is not freed before the last task is; * processed. Note however, that no thread of this pool is; * interrupted, while processing a task. Instead at least all still; * running threads can finish their tasks before the @pool is freed.; *; * If @wait is #TRUE, the functions does not return before all tasks; * to be processed (dependent on @immediate, whether all or only the; * currently running) are ready. Otherwise the function returns immediately.; *; * After calling this function @pool must not be used anymore. ; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c:194,allocate,allocated,194,graf2d/win32gdk/gdk/src/glib/gthreadpool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_thread_pool_set_max_threads:; * @pool: a #GThreadPool; * @max_threads: a new maximal number of threads for @pool; * @error: return location for error; * ; * Sets the maximal allowed number of threads for @pool. A value of -1; * means, that the maximal number of threads is unlimited.; *; * Setting @max_threads to 0 means stopping all work for @pool. It is; * effectively frozen until @max_threads is set to a non-zero value; * again.; * ; * A thread is never terminated while calling @func, as supplied by; * g_thread_pool_new (). Instead the maximal number of threads only; * has effect for the allocation of new threads in g_thread_pool_push; * (). A new thread is allocated, whenever the number of currently; * running threads in @pool is smaller than the maximal number.; *; * @error can be NULL to ignore errors, or non-NULL to report; * errors. An error can only occur, when a new thread couldn't be; * created. ; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c:677,allocate,allocated,677,graf2d/win32gdk/gdk/src/glib/gthreadpool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_tree_destroy:; * @tree: a #GTree.; * ; * Destroys the #GTree. If keys and/or values are dynamically allocated, you ; * should either free them first or create the #GTree using g_tree_new_full().; * In the latter case the destroy functions you supplied will be called on ; * all keys and values before destroying the #GTree.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gtree.c:109,allocate,allocated,109,graf2d/win32gdk/gdk/src/glib/gtree.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gtree.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_tree_lookup_extended:; * @tree: a #GTree.; * @lookup_key: the key to look up.; * @orig_key: returns the original key.; * @value: returns the value associated with the key.; * ; * Looks up a key in the #GTree, returning the original key and the; * associated value and a gboolean which is TRUE if the key was found. This ; * is useful if you need to free the memory allocated for the original key, ; * for example before calling g_tree_remove().; * ; * Return value: #TRUE if the key was found in the #GTree.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gtree.c:374,allocate,allocated,374,graf2d/win32gdk/gdk/src/glib/gtree.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gtree.c,1,['allocate'],['allocated']
Energy Efficiency,/**; * g_tree_new_full:; * @key_compare_func: qsort()-style comparison function.; * @key_compare_data: data to pass to comparison function.; * @key_destroy_func: a function to free the memory allocated for the key ; * used when removing the entry from the #GTree or #NULL if you don't; * want to supply such a function.; * @value_destroy_func: a function to free the memory allocated for the ; * value used when removing the entry from the #GTree or #NULL if you ; * don't want to supply such a function.; * ; * Creates a new #GTree like g_tree_new() and allows to specify functions ; * to free the memory allocated for the key and value that get called when ; * removing the entry from the #GTree.; * ; * Return value: a new #GTree.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gtree.c:192,allocate,allocated,192,graf2d/win32gdk/gdk/src/glib/gtree.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gtree.c,3,['allocate'],['allocated']
Energy Efficiency,"/**; * g_tree_remove:; * @tree: a #Gtree.; * @key: the key to remove.; * ; * Removes a key/value pair from a #GTree.; *; * If the #GTree was created using g_tree_new_full(), the key and value ; * are freed using the supplied destroy_functions, otherwise you have to ; * make sure that any dynamically allocated values are freed yourself.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gtree.c:301,allocate,allocated,301,graf2d/win32gdk/gdk/src/glib/gtree.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gtree.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_ucs4_to_utf16:; * @str: a UCS-4 encoded string; * @len: the maximum length of @str to use. If @len < 0, then; * the string is terminated with a 0 character.; * @items_read: location to store number of bytes read, or %NULL.; * If an error occurs then the index of the invalid input; * is stored here.; * @items_written: location to store number of words written, or %NULL.; * The value stored here does not include the trailing; * 0 word.; * @error: location to store the error occuring, or %NULL to ignore; * errors. Any of the errors in #GConvertError other than; * %G_CONVERT_ERROR_NO_CONVERSION may occur.; *; * Convert a string from UCS-4 to UTF-16. A 0 word will be; * added to the result after the converted text.; * ; * Return value: a pointer to a newly allocated UTF-16 string.; * This value must be freed with g_free(). If an; * error occurs, %NULL will be returned and; * @error set.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c:771,allocate,allocated,771,graf2d/win32gdk/gdk/src/glib/gutf8.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_ucs4_to_utf8:; * @str: a UCS-4 encoded string; * @len: the maximum length of @str to use. If @len < 0, then; * the string is terminated with a 0 character.; * @items_read: location to store number of characters read read, or %NULL.; * @items_written: location to store number of bytes written or %NULL.; * The value here stored does not include the trailing 0; * byte. ; * @error: location to store the error occuring, or %NULL to ignore; * errors. Any of the errors in #GConvertError other than; * %G_CONVERT_ERROR_NO_CONVERSION may occur.; *; * Convert a string from a 32-bit fixed width representation as UCS-4.; * to UTF-8. The result will be terminated with a 0 byte.; * ; * Return value: a pointer to a newly allocated UTF-8 string.; * This value must be freed with g_free(). If an; * error occurs, %NULL will be returned and; * @error set.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c:724,allocate,allocated,724,graf2d/win32gdk/gdk/src/glib/gutf8.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c,1,['allocate'],['allocated']
Energy Efficiency,/**; * g_unicode_canonical_decomposition:; * @ch: a Unicode character.; * @result_len: location to store the length of the return value.; *; * Computes the canonical decomposition of a Unicode character. ; * ; * Return value: a newly allocated string of Unicode characters.; * @result_len is set to the resulting length of the string.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gunidecomp.c:234,allocate,allocated,234,graf2d/win32gdk/gdk/src/glib/gunidecomp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gunidecomp.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_utf16_to_ucs4:; * @str: a UTF-16 encoded string; * @len: the maximum length of @str to use. If @len < 0, then; * the string is terminated with a 0 character.; * @items_read: location to store number of words read, or %NULL.; * If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will be; * returned in case @str contains a trailing partial; * character. If an error occurs then the index of the; * invalid input is stored here.; * @items_written: location to store number of characters written, or %NULL.; * The value stored here does not include the trailing; * 0 character.; * @error: location to store the error occuring, or %NULL to ignore; * errors. Any of the errors in #GConvertError other than; * %G_CONVERT_ERROR_NO_CONVERSION may occur.; *; * Convert a string from UTF-16 to UCS-4. The result will be; * terminated with a 0 character.; * ; * Return value: a pointer to a newly allocated UCS-4 string.; * This value must be freed with g_free(). If an; * error occurs, %NULL will be returned and; * @error set.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c:890,allocate,allocated,890,graf2d/win32gdk/gdk/src/glib/gutf8.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_utf16_to_utf8:; * @str: a UTF-16 encoded string; * @len: the maximum length of @str to use. If @len < 0, then; * the string is terminated with a 0 character.; * @items_read: location to store number of words read, or %NULL.; * If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will be; * returned in case @str contains a trailing partial; * character. If an error occurs then the index of the; * invalid input is stored here.; * @items_written: location to store number of bytes written, or %NULL.; * The value stored here does not include the trailing; * 0 byte.; * @error: location to store the error occuring, or %NULL to ignore; * errors. Any of the errors in #GConvertError other than; * %G_CONVERT_ERROR_NO_CONVERSION may occur.; *; * Convert a string from UTF-16 to UTF-8. The result will be; * terminated with a 0 byte.; * ; * Return value: a pointer to a newly allocated UTF-8 string.; * This value must be freed with g_free(). If an; * error occurs, %NULL will be returned and; * @error set.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c:875,allocate,allocated,875,graf2d/win32gdk/gdk/src/glib/gutf8.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_utf8_casefold:; * @str: a UTF-8 encoded string; * @len: length of @str, in bytes, or -1 if @str is nul-terminated.; * ; * Converts a string into a form that is independent of case. The; * result will not correspond to any particular case, but can be; * compared for equality or ordered with the results of calling; * g_utf8_casefold() on other strings.; * ; * Note that calling g_utf8_casefold() followed by g_utf8_collate() is; * only an approximation to the correct linguistic case insensitive; * ordering, though it is a fairly good one. Getting this exactly; * right would require a more sophisticated collation function that; * takes case sensitivity into account. GLib does not currently; * provide such a function.; * ; * Return value: a newly allocated string, that is a; * case independent form of @str.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/guniprop.c:760,allocate,allocated,760,graf2d/win32gdk/gdk/src/glib/guniprop.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/guniprop.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_utf8_normalize:; * @str: a UTF-8 encoded string.; * @len: length of @str, in bytes, or -1 if @str is nul-terminated.; * @mode: the type of normalization to perform.; * ; * Converts a string into canonical form, standardizing; * such issues as whether a character with an accent; * is represented as a base character and combining; * accent or as a single precomposed character. You; * should generally call g_utf8_normalize() before; * comparing two Unicode strings.; *; * The normalization mode %G_NORMALIZE_DEFAULT only; * standardizes differences that do not affect the; * text content, such as the above-mentioned accent; * representation. %G_NORMALIZE_ALL also standardizes; * the ""compatibility"" characters in Unicode, such; * as SUPERSCRIPT THREE to the standard forms; * (in this case DIGIT THREE). Formatting information; * may be lost but for most text operations such; * characters should be considered the same.; * For example, g_utf8_collate() normalizes; * with %G_NORMALIZE_ALL as its first step.; *; * %G_NORMALIZE_DEFAULT_COMPOSE and %G_NORMALIZE_ALL_COMPOSE; * are like %G_NORMALIZE_DEFAULT and %G_NORMALIZE_ALL,; * but returned a result with composed forms rather; * than a maximally decomposed form. This is often; * useful if you intend to convert the string to; * a legacy encoding or pass it to a system with; * less capable Unicode handling.; * ; * Return value: a newly allocated string, that is the ; * normalized form of @str.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gunidecomp.c:1404,allocate,allocated,1404,graf2d/win32gdk/gdk/src/glib/gunidecomp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gunidecomp.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_utf8_strdown:; * @str: a UTF-8 encoded string; * @len: length of @str, in bytes, or -1 if @str is nul-terminated.; * ; * Converts all Unicode characters in the string that have a case; * to lowercase. The exact manner that this is done depends; * on the current locale, and may result in the number of; * characters in the string changing.; * ; * Return value: a newly allocated string, with all characters; * converted to lowercase. ; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/guniprop.c:378,allocate,allocated,378,graf2d/win32gdk/gdk/src/glib/guniprop.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/guniprop.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_utf8_strup:; * @str: a UTF-8 encoded string; * @len: length of @str, in bytes, or -1 if @str is nul-terminated.; * ; * Converts all Unicode characters in the string that have a case; * to uppercase. The exact manner that this is done depends; * on the current locale, and may result in the number of; * characters in the string increasing. (For instance, the; * German ess-zet will be changed to SS.); * ; * Return value: a newly allocated string, with all characters; * converted to uppercase. ; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/guniprop.c:439,allocate,allocated,439,graf2d/win32gdk/gdk/src/glib/guniprop.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/guniprop.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_utf8_to_ucs4:; * @str: a UTF-8 encoded string; * @len: the maximum length of @str to use. If @len < 0, then; * the string is nul-terminated.; * @items_read: location to store number of bytes read, or %NULL.; * If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will be; * returned in case @str contains a trailing partial; * character. If an error occurs then the index of the; * invalid input is stored here.; * @items_written: location to store number of characters written or %NULL.; * The value here stored does not include the trailing 0; * character. ; * @error: location to store the error occuring, or %NULL to ignore; * errors. Any of the errors in #GConvertError other than; * %G_CONVERT_ERROR_NO_CONVERSION may occur.; *; * Convert a string from UTF-8 to a 32-bit fixed width; * representation as UCS-4. A trailing 0 will be added to the; * string after the converted text.; * ; * Return value: a pointer to a newly allocated UCS-4 string.; * This value must be freed with g_free(). If an; * error occurs, %NULL will be returned and; * @error set.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c:931,allocate,allocated,931,graf2d/win32gdk/gdk/src/glib/gutf8.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_utf8_to_ucs4_fast:; * @str: a UTF-8 encoded string; * @len: the maximum length of @str to use. If @len < 0, then; * the string is nul-terminated.; * @items_written: location to store the number of characters in the; * result, or %NULL.; *; * Convert a string from UTF-8 to a 32-bit fixed width; * representation as UCS-4, assuming valid UTF-8 input.; * This function is roughly twice as fast as g_utf8_to_ucs4(); * but does no error checking on the input.; * ; * Return value: a pointer to a newly allocated UCS-4 string.; * This value must be freed with g_free().; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c:507,allocate,allocated,507,graf2d/win32gdk/gdk/src/glib/gutf8.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_utf8_to_utf16:; * @str: a UTF-8 encoded string; * @len: the maximum length of @str to use. If @len < 0, then; * the string is nul-terminated.; ; * @items_read: location to store number of bytes read, or %NULL.; * If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will be; * returned in case @str contains a trailing partial; * character. If an error occurs then the index of the; * invalid input is stored here.; * @items_written: location to store number of words written, or %NULL.; * The value stored here does not include the trailing; * 0 word.; * @error: location to store the error occuring, or %NULL to ignore; * errors. Any of the errors in #GConvertError other than; * %G_CONVERT_ERROR_NO_CONVERSION may occur.; *; * Convert a string from UTF-8 to UTF-16. A 0 word will be; * added to the result after the converted text.; * ; * Return value: a pointer to a newly allocated UTF-16 string.; * This value must be freed with g_free(). If an; * error occurs, %NULL will be returned and; * @error set.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c:879,allocate,allocated,879,graf2d/win32gdk/gdk/src/glib/gutf8.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_win32_error_message:; * @error: error code; *; * Translate a Win32 error code (as returned by GetLastError()) into; * the corresponding message. The message is either language neutral,; * or in the thread's language, or the user's language, the system's; * langauge, or US English (see docs for FormatMessage). The returned; * string should be deallocated with g_free().; *; * Returns: allocated error message; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gwin32.c:395,allocate,allocated,395,graf2d/win32gdk/gdk/src/glib/gwin32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gwin32.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; * g_win32_getlocale:; *; * The setlocale in the Microsoft C library uses locale names of the; * form ""English_United States.1252"" etc. We want the Unixish standard; * form ""en"", ""zh_TW"" etc. This function gets the current thread; * locale from Windows and returns it as a string of the above form; * for use in forming file names etc. The returned string should be; * deallocated with g_free().; *; * Returns: allocated locale name; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gwin32.c:415,allocate,allocated,415,graf2d/win32gdk/gdk/src/glib/gwin32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gwin32.c,1,['allocate'],['allocated']
Energy Efficiency,"/**; @defgroup CppFunctions Function Classes and Interfaces. Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods; for describing function classes. They define function and gradient evaluation and as well the; functionality for dealing with parameters in the case of parametric functions which are used for; fitting and data modeling.; Included are also adapter classes, such as functors, to wrap generic callable C++ objects; in the desired interface. @ingroup MathCore; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h:396,adapt,adapter,396,math/mathcore/inc/Math/IFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h,1,['adapt'],['adapter']
Energy Efficiency,"/**; @defgroup NumAlgo Numerical Algorithms. Numerical Algorithm classes from the \ref MathCore and \ref MathMore libraries. @ingroup MathCore; @ingroup MathMore. */; /**. @defgroup Integration Numerical Integration. Classes for numerical integration of functions.; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods; and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator).; The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class; ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones.; The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and; ROOT::Math::IntegratorMultiDimOptions classes. @ingroup NumAlgo. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h:358,adapt,adaptive,358,math/mathcore/inc/Math/Integrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h,3,['adapt'],['adaptive']
Energy Efficiency,/**; Assignment operator from a position vector; (not necessarily efficient unless one or the other is Cartesian); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/DisplacementVector2D.h:66,efficient,efficient,66,math/genvector/inc/Math/GenVector/DisplacementVector2D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/DisplacementVector2D.h,2,['efficient'],['efficient']
Energy Efficiency,"/**; Class for adapting a C++ functor class to C function pointers used by GSL MultiFit; Algorithm; The templated C++ function class must implement:. <em> double operator( const double * x)</em>; and if the derivatives are required:; <em> void Gradient( const double * x, double * g)</em>; and; <em> void FdF( const double * x, double &f, double * g)</em>. This class defines static methods with will be used to fill the; \a gsl_multimin_function and; \a gsl_multimin_function_fdf structs used by GSL.; See for examples the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Providing-a-function-to-minimize.html#Providing-a-function-to-minimize"">GSL online manual</A>. @ingroup MultiMin; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiFitFunctionAdapter.h:15,adapt,adapting,15,math/mathmore/src/GSLMultiFitFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiFitFunctionAdapter.h,1,['adapt'],['adapting']
Energy Efficiency,"/**; Class for adapting a C++ functor class to C function pointers used by GSL MultiRoot; Algorithm; The templated C++ function class must implement:. <em> double operator( const double * x)</em>; and if the derivatives are required:; <em> void Gradient( const double * x, double * g)</em>; and; <em> void FdF( const double * x, double &f, double * g)</em>. @ingroup MultiRoot; */; // FuncVector must contain a vector of pointers to functions; // this same as MultiFit but here need to use pointers where there we used class elements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootFunctionAdapter.h:15,adapt,adapting,15,math/mathmore/src/GSLMultiRootFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootFunctionAdapter.h,1,['adapt'],['adapting']
Energy Efficiency,"/**; Class for adapting any C++ functor class to C function pointers used by GSL.; The templated C++ function class must implement:. <em> double operator( double x)</em>; and if the derivatives are required:; <em> double Gradient( double x)</em>. This class defines static methods with will be used to fill the; \a gsl_function and \a gsl_function_fdf structs used by GSL.; See for examples the <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_32.html#SEC432"">GSL online manual</A>; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLFunctionAdapter.h:15,adapt,adapting,15,math/mathmore/inc/Math/GSLFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLFunctionAdapter.h,1,['adapt'],['adapting']
Energy Efficiency,"/**; Class for adapting any multi-dimension C++ functor class to C function pointers used by; GSL MonteCarlo integration algorithms.; The templated C++ function class must implement:. <em> double operator( const double * x)</em>. This class defines static methods with will be used to fill the; \a gsl_monte_function used by GSL.; See for examples the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Monte-Carlo-Interface.html"">GSL online manual</A>. @ingroup MCIntegration; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMonteFunctionAdapter.h:15,adapt,adapting,15,math/mathmore/src/GSLMonteFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMonteFunctionAdapter.h,1,['adapt'],['adapting']
Energy Efficiency,"/**; Class for adapting any multi-dimension C++ functor class to C function pointers used by; GSL MultiMin algorithms.; The templated C++ function class must implement:. <em> double operator( const double * x)</em>; and if the derivatives are required:; <em> void Gradient( const double * x, double * g)</em>. This class defines static methods with will be used to fill the; \a gsl_multimin_function and; \a gsl_multimin_function_fdf structs used by GSL.; See for examples the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Providing-a-function-to-minimize.html#Providing-a-function-to-minimize"">GSL online manual</A>. @ingroup MultiMin. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiMinFunctionAdapter.h:15,adapt,adapting,15,math/mathmore/src/GSLMultiMinFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiMinFunctionAdapter.h,1,['adapt'],['adapting']
Energy Efficiency,/**; Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Derivator.h:61,adapt,adaptive,61,math/mathmore/inc/Math/Derivator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Derivator.h,2,['adapt'],['adaptive']
Energy Efficiency,/**; Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Derivator.h:61,adapt,adaptive,61,math/mathmore/inc/Math/Derivator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Derivator.h,2,['adapt'],['adaptive']
Energy Efficiency,/**; Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Derivator.h:61,adapt,adaptive,61,math/mathmore/inc/Math/Derivator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Derivator.h,2,['adapt'],['adaptive']
Energy Efficiency,/**; Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Derivator.h:77,adapt,adaptive,77,math/mathmore/inc/Math/Derivator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Derivator.h,2,['adapt'],['adaptive']
Energy Efficiency,/**; Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Derivator.h:77,adapt,adaptive,77,math/mathmore/inc/Math/Derivator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Derivator.h,1,['adapt'],['adaptive']
Energy Efficiency,/**; Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Derivator.h:77,adapt,adaptive,77,math/mathmore/inc/Math/Derivator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Derivator.h,2,['adapt'],['adaptive']
Energy Efficiency,/**; Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Derivator.h:137,adapt,adaptive,137,math/mathmore/inc/Math/Derivator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Derivator.h,1,['adapt'],['adaptive']
Energy Efficiency,"/**; Construct Monte Carlo Study Manager. This class automates generating data from a given PDF,; fitting the PDF to data and accumulating the fit statistics. \param[in] model The PDF to be studied; \param[in] observables The variables of the PDF to be considered observables; \param[in] arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8 Optional arguments according to table below. <table>; <tr><th> Optional arguments <th>; <tr><td> Silence() <td> Suppress all RooFit messages during running below PROGRESS level; <tr><td> FitModel(const RooAbsPdf&) <td> The PDF for fitting if it is different from the PDF for generating.; <tr><td> ConditionalObservables(const RooArgSet& set) <td> The set of observables that the PDF should _not_ be normalized over; <tr><td> Binned(bool flag) <td> Bin the dataset before fitting it. Speeds up fitting of large data samples; <tr><td> FitOptions(....) <td> Options to be used for fitting. All named arguments inside FitOptions() are passed to RooAbsPdf::fitTo().; `Save()` is especially interesting to be able to retrieve fit results of each run using fitResult().; <tr><td> Verbose(bool flag) <td> Activate informational messages in event generation phase; <tr><td> Extended(bool flag) <td> Determine number of events for each sample anew from a Poisson distribution; <tr><td> Constrain(const RooArgSet& pars) <td> Apply internal constraints on given parameters in fit and sample constrained parameter values from constraint p.d.f for each toy.; <tr><td> ProtoData(const RooDataSet&, bool randOrder); <td> Prototype data for the event generation. If the randOrder flag is set, the order of the dataset will be re-randomized for each generation; cycle to protect against systematic biases if the number of generated events does not exactly match the number of events in the prototype dataset; at the cost of reduced precision with mu equal to the specified number of events; </table>; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCStudy.cxx:1834,reduce,reduced,1834,roofit/roofitcore/src/RooMCStudy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCStudy.cxx,1,['reduce'],['reduced']
Energy Efficiency,"/**; Constructor from the function object , dimension of the function and; and coordinate we want to adapt.; The coordinate cached vector is created inside and eventually the values must be passed; later with the SetX which will copy them; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/OneDimFunctionAdapter.h:101,adapt,adapt,101,math/mathcore/inc/Math/OneDimFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/OneDimFunctionAdapter.h,1,['adapt'],['adapt']
Energy Efficiency,"/**; Constructor from the function object , pointer to an external array of x values; and coordinate we want to adapt; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/OneDimFunctionAdapter.h:112,adapt,adapt,112,math/mathcore/inc/Math/OneDimFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/OneDimFunctionAdapter.h,1,['adapt'],['adapt']
Energy Efficiency,"/**; Constructor from the function object , x value and coordinate we want to adapt; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/OneDimFunctionAdapter.h:78,adapt,adapt,78,math/mathcore/inc/Math/OneDimFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/OneDimFunctionAdapter.h,1,['adapt'],['adapt']
Energy Efficiency,"/**; Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute tolerance. The algorithm will stop when either the absolute OR the relative tolerance are satisfied.; @param relTol desired relative tolerance; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When no values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h:174,adapt,adaptive,174,math/mathcore/inc/Math/Integrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h,3,"['ADAPT', 'adapt']","['ADAPTIVE', 'adaptive']"
Energy Efficiency,/**; Create a QuasiRandom generator based on a provided generic engine.; Engine will be initialized via Initialize() function in order to; allocate resources; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/QuasiRandom.h:139,allocate,allocate,139,math/mathmore/inc/Math/QuasiRandom.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/QuasiRandom.h,1,['allocate'],['allocate']
Energy Efficiency,/**; Create a QuasiRandom generator. Use default engine constructor.; Engine will be initialized via Initialize() function in order to; allocate resources; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/QuasiRandom.h:136,allocate,allocate,136,math/mathmore/inc/Math/QuasiRandom.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/QuasiRandom.h,1,['allocate'],['allocate']
Energy Efficiency,/**; Destructor: call Terminate() function of engine to free any; allocated resource; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/QuasiRandom.h:66,allocate,allocated,66,math/mathmore/inc/Math/QuasiRandom.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/QuasiRandom.h,1,['allocate'],['allocated']
Energy Efficiency,/**; Destructor: free allocated resources; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMinimizer1D.h:22,allocate,allocated,22,math/mathmore/inc/Math/GSLMinimizer1D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMinimizer1D.h,1,['allocate'],['allocated']
Energy Efficiency,/**; Determine if momentum-energy can represent a massless particle; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzVector.h:27,energy,energy,27,math/genvector/inc/Math/GenVector/LorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzVector.h,1,['energy'],['energy']
Energy Efficiency,/**; Determine if momentum-energy can represent a physical massive particle; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzVector.h:27,energy,energy,27,math/genvector/inc/Math/GenVector/LorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzVector.h,1,['energy'],['energy']
Energy Efficiency,"/**; Determine if momentum-energy is spacelike, and represents a tachyon; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzVector.h:27,energy,energy,27,math/genvector/inc/Math/GenVector/LorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzVector.h,1,['energy'],['energy']
Energy Efficiency,/**; Energy (timelike component of momentum-energy 4-vector); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h:5,Energy,Energy,5,math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h,2,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,/**; Free functions adapter needed by UNURAN for multidimensional cont distribution; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/src/UnuranDistrAdapter.h:20,adapt,adapter,20,math/unuran/src/UnuranDistrAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/src/UnuranDistrAdapter.h,1,['adapt'],['adapter']
Energy Efficiency,/**; Free functions adapter needed by UNURAN for one-dimensional discrete distribution; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/src/UnuranDistrAdapter.h:20,adapt,adapter,20,math/unuran/src/UnuranDistrAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/src/UnuranDistrAdapter.h,1,['adapt'],['adapter']
Energy Efficiency,/**; Free functions adapter needed by UNURAN for onedimensional continuous distributions; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/src/UnuranDistrAdapter.h:20,adapt,adapter,20,math/unuran/src/UnuranDistrAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/src/UnuranDistrAdapter.h,1,['adapt'],['adapter']
Energy Efficiency,/**; MultiDimParamFunctionAdapter class to wrap a one-dimensional parametric function in; a multi dimensional parametric function interface; This is used typically in fitting where internally the function is stored as multidimensional. To wrap a non-parametric one-dim function in a multi-dim interface one can use simply a; ROOT::Math::WrappedFunction<ROOT::Math::IGenFunction> or ROOT::Math::Functor; and ROOT::Math::GradFunctor for gradient functions. This class differs from WrappedParamFunction in the fact that the parameters are not stored in; the adapter class and optionally it keeps a cloned and managed copy of the adapter class. @ingroup ParamFunc. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MultiDimParamFunctionAdapter.h:555,adapt,adapter,555,math/mathcore/inc/Math/MultiDimParamFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MultiDimParamFunctionAdapter.h,2,['adapt'],['adapter']
Energy Efficiency,/**; MultiDimParamGradFunctionAdapter class to wrap a one-dimensional parametric gradient function in; a multi dimensional parametric gradient function interface; This is used typically in fitting where internally the function is stored as multidimensional. To wrap a non-parametric one-dim gradient function in a multi-dim interface one can use simply a; a ROOT::Math::GradFunctor. The parameters are not stored in the adapter class and by default the pointer to the 1D function is owned.; This means that deleting the class deletes also the 1D function and copying the class copies also the; 1D function; This class differs from WrappedParamFunction in the fact that the parameters are not stored in; the adapter class and optionally it keeps a cloned and managed copy of the adapter class. @ingroup ParamFunc. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MultiDimParamFunctionAdapter.h:420,adapt,adapter,420,math/mathcore/inc/Math/MultiDimParamFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MultiDimParamFunctionAdapter.h,3,['adapt'],['adapter']
Energy Efficiency,"/**; OneDimMultiFunctionAdapter class to wrap a multidimensional function in; one dimensional one.; Given a f(x1,x2,x3,....xn) transforms in a f( x_i) given the coordinate intex i and the vector x[]; of the coordinates.; It provides the possibility to copy and own the data array of the coordinates or to maintain internally a pointer to an external array; for being more efficient. In this last case the user must guarantee the life of the given passed pointer. @ingroup GenFunc. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/OneDimFunctionAdapter.h:372,efficient,efficient,372,math/mathcore/inc/Math/OneDimFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/OneDimFunctionAdapter.h,1,['efficient'],['efficient']
Energy Efficiency,"/**; Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Interpolator.h:48,efficient,efficient,48,math/mathmore/inc/Math/Interpolator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Interpolator.h,1,['efficient'],['efficient']
Energy Efficiency,"/**; Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Interpolator.h:48,efficient,efficient,48,math/mathmore/inc/Math/Interpolator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Interpolator.h,1,['efficient'],['efficient']
Energy Efficiency,"/**; Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute tolerance. The algorithm will stop when either the absolute OR the relative tolerance are satisfied.; @param relTol desired relative tolerance; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When no values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h:211,adapt,adaptive,211,math/mathcore/inc/Math/Integrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h,3,"['ADAPT', 'adapt']","['ADAPTIVE', 'adaptive']"
Energy Efficiency,/**; Wrapper class to the gsl_function C structure.; This class to fill the GSL C structure gsl_function with; the C++ function objcet.; Use the class ROOT::Math::GSLFunctionAdapter to adapt the; C++ function object to the right signature (function pointer type); requested by GSL; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLFunctionWrapper.h:185,adapt,adapt,185,math/mathmore/src/GSLFunctionWrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLFunctionWrapper.h,1,['adapt'],['adapt']
Energy Efficiency,"/**; \class TRInterface; ROOT R was implemented using the; <A HREF=""http://www.r-project.org/"">R Project</A> library and the modules; <A HREF=""http://cran.r-project.org/web/packages/Rcpp/index.html"">Rcpp</A> and; <A HREF=""http://cran.r-project.org/web/packages/RInside/index.html"">RInside</A>; <h2>Users Guide </h2>; <a href=""https://oproject.org/pages/ROOT%20R%20Users%20Guide""> https://oproject.org/pages/ROOT R Users Guide</a><br>. \ingroup R; */; /**; <center><h2>TRInterface class</h2></center>. </p>; The TRInterface class lets you process R code from ROOT.<br>; You can call R libraries and their functions, plot results in R or ROOT,<br>; and use the power of ROOT and R at the same time.<br>; It also lets you pass scalars, vectors and matrices from ROOT to R<br>; and from R to ROOT using TRObject; but you can to use overloaded operators [],<< and >> <br>; to work with ROOTR like work with streams of data.<br>. TRInterface class can not be instantiated directly, but you can create objects using the static methods; TRInterface& Instance() and TRInterface* InstancePtr() to create your own objects.<br>; <br>; </p>; Show an example below:; Create an exponential fit, the idea is to create a set of numbers x,y with noise from ROOT,; pass them to R and fit the data to \f$ x^3 \f$, get the fitted coefficient(power) and plot the data,; the known function and the fitted function.; \code{.cpp}. TCanvas *c1 = new TCanvas(""c1"",""Curve Fit"",700,500);; c1->SetGrid();. // draw a frame for multiples graphs; TMultiGraph *mg = new TMultiGraph();. // create the first graph (points with gaussian noise); const Int_t n = 24;; Double_t x[n] ;; Double_t y[n] ;; //Generate points along a X^3 with noise; TRandom rg;; rg.SetSeed(520);; for (Int_t i = 0; i < n; i++) {; x[i] = rg.Uniform(0, 1);; y[i] = TMath::Power(x[i], 3) + rg.Gaus() * 0.06;; }. TGraph *gr1 = new TGraph(n,x,y);; gr1->SetMarkerColor(kBlue);; gr1->SetMarkerStyle(8);; gr1->SetMarkerSize(1);; mg->Add(gr1);. // create second graph; TF",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/inc/TRInterface.h:659,power,power,659,bindings/r/inc/TRInterface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/inc/TRInterface.h,1,['power'],['power']
Energy Efficiency,/**; class to reduce the covariance matrix when a parameter is fixed by; removing the corresponding row and index; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnCovarianceSqueeze.h:14,reduce,reduce,14,math/minuit2/inc/Minuit2/MnCovarianceSqueeze.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnCovarianceSqueeze.h,1,['reduce'],['reduce']
Energy Efficiency,/**; constructor from dimension of point and max number of points (to pre-allocate vector); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/UnBinData.h:74,allocate,allocate,74,math/mathcore/inc/Fit/UnBinData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/UnBinData.h,1,['allocate'],['allocate']
Energy Efficiency,/**; constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/BinData.h:74,allocate,allocate,74,math/mathcore/inc/Fit/BinData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/BinData.h,1,['allocate'],['allocate']
Energy Efficiency,/**; energy squared; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h:5,energy,energy,5,math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h,2,['energy'],['energy']
Energy Efficiency,/**; evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLSimAnnealing.h:18,energy,energy,18,math/mathmore/inc/Math/GSLSimAnnealing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLSimAnnealing.h,1,['energy'],['energy']
Energy Efficiency,/**; generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h:199,ADAPT,ADAPTIVE,199,math/mathmore/inc/Math/GSLIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h,1,['ADAPT'],['ADAPTIVE']
Energy Efficiency,"/**; preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/BinData.cxx:308,allocate,allocated,308,math/mathcore/src/BinData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/BinData.cxx,1,['allocate'],['allocated']
Energy Efficiency,"/**; print the position in the standard output std::ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLSimAnnealing.h:131,energy,energy,131,math/mathmore/inc/Math/GSLSimAnnealing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLSimAnnealing.h,1,['energy'],['energy']
Energy Efficiency,"/**; retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i); */; // not threadsafe, to be replaced with never constructs!; // for example: just return std::array or std::vector, there's; // is going to be only minor overhead in c++11.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/BinData.h:88,efficient,efficient,88,math/mathcore/inc/Fit/BinData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/BinData.h,1,['efficient'],['efficient']
Energy Efficiency,"/**; return 4-th component (time, or energy for a 4-momentum vector); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzVector.h:37,energy,energy,37,math/genvector/inc/Math/GenVector/LorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzVector.h,1,['energy'],['energy']
Energy Efficiency,/**; return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzVector.h:27,energy,energy,27,math/genvector/inc/Math/GenVector/LorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzVector.h,1,['energy'],['energy']
Energy Efficiency,/**; return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzVector.h:27,energy,energy,27,math/genvector/inc/Math/GenVector/LorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzVector.h,1,['energy'],['energy']
Energy Efficiency,/**; set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h:171,ADAPT,ADAPTIVE,171,math/mathmore/inc/Math/GSLIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h,1,['ADAPT'],['ADAPTIVE']
Energy Efficiency,/**; transverse energy squared; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PtEtaPhiE4D.h:16,energy,energy,16,math/genvector/inc/Math/GenVector/PtEtaPhiE4D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PtEtaPhiE4D.h,4,['energy'],['energy']
Energy Efficiency,/**; transverse energy; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h:16,energy,energy,16,math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h,3,['energy'],['energy']
Energy Efficiency,/**; transverse energy; */; /**; transverse energy; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PtEtaPhiE4D.h:16,energy,energy,16,math/genvector/inc/Math/GenVector/PtEtaPhiE4D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PtEtaPhiE4D.h,2,['energy'],['energy']
Energy Efficiency,"/**< Same as FSE_buildDTable(), using an externally allocated `workspace` produced with `FSE_BUILD_DTABLE_WKSP_SIZE_U32(maxSymbolValue)` */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:52,allocate,allocated,52,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['allocate'],['allocated']
Energy Efficiency,"/**< build a fake FSE_CTable, designed to compress always the same symbolValue */; /* FSE_buildCTable_wksp() :; * Same as FSE_buildCTable(), but using an externally allocated scratch buffer (`workSpace`).; * `wkspSize` must be >= `FSE_BUILD_CTABLE_WORKSPACE_SIZE_U32(maxSymbolValue, tableLog)` of `unsigned`.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:165,allocate,allocated,165,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['allocate'],['allocated']
Energy Efficiency,"/**< library version number; to be used when checking dll version */; /*-****************************************; * FSE simple functions; ******************************************/; /*! FSE_compress() :; Compress content of buffer 'src', of size 'srcSize', into destination buffer 'dst'.; 'dst' buffer must be already allocated. Compression runs faster is dstCapacity >= FSE_compressBound(srcSize).; @return : size of compressed data (<= dstCapacity).; Special values : if return == 0, srcData is not compressible => Nothing is stored within dst !!!; if return == 1, srcData is a single byte symbol * srcSize times. Use RLE compression instead.; if FSE_isError(return), compression failed (more details using FSE_getErrorName()); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:320,allocate,allocated,320,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['allocate'],['allocated']
Energy Efficiency,"/**< library version string; useful to check dll version */; /*-************************************; * Tuning parameter; **************************************/; /*!; * LZ4_MEMORY_USAGE :; * Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.); * Increasing memory usage improves compression ratio.; * Reduced memory usage may improve speed, thanks to better cache locality.; * Default value is 14, for 16KB, which nicely fits into Intel x86 L1 cache; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:350,Reduce,Reduced,350,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['Reduce'],['Reduced']
Energy Efficiency,"/**< same as FSE_decompress(), using an externally allocated `workSpace` produced with `FSE_DECOMPRESS_WKSP_SIZE_U32(maxLog, maxSymbolValue)` */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:51,allocate,allocated,51,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['allocate'],['allocated']
Energy Efficiency,"/**< same as FSE_optimalTableLog(), which used `minus==2` */; /* FSE_compress_wksp() :; * Same as FSE_compress2(), but using an externally allocated scratch buffer (`workSpace`).; * FSE_COMPRESS_WKSP_SIZE_U32() provides the minimum size required for `workSpace` as a table of FSE_CTable.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:139,allocate,allocated,139,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['allocate'],['allocated']
Energy Efficiency,"/*-***********************************************************************; * Streaming compression - HowTo; *; * A ZSTD_CStream object is required to track streaming operation.; * Use ZSTD_createCStream() and ZSTD_freeCStream() to create/release resources.; * ZSTD_CStream objects can be reused multiple times on consecutive compression operations.; * It is recommended to re-use ZSTD_CStream since it will play nicer with system's memory, by re-using already allocated memory.; *; * For parallel execution, use one separate ZSTD_CStream per thread.; *; * note : since v1.3.0, ZSTD_CStream and ZSTD_CCtx are the same thing.; *; * Parameters are sticky : when starting a new compression on the same context,; * it will re-use the same sticky parameters as previous compression session.; * When in doubt, it's recommended to fully initialize the context before usage.; * Use ZSTD_CCtx_reset() to reset the context and ZSTD_CCtx_setParameter(),; * ZSTD_CCtx_setPledgedSrcSize(), or ZSTD_CCtx_loadDictionary() and friends to; * set more specific parameters, the pledged source size, or load a dictionary.; *; * Use ZSTD_compressStream2() with ZSTD_e_continue as many times as necessary to; * consume input stream. The function will automatically update both `pos`; * fields within `input` and `output`.; * Note that the function may not consume the entire input, for example, because; * the output buffer is already full, in which case `input.pos < input.size`.; * The caller must check if input has been entirely consumed.; * If not, the caller must make some room to receive more compressed data,; * and then present again remaining input data.; * note: ZSTD_e_continue is guaranteed to make some forward progress when called,; * but doesn't guarantee maximal forward progress. This is especially relevant; * when compressing with multiple threads. The call won't block if it can; * consume some input, but if it can't it will wait for some, but not all,; * output to be flushed.; * @return : provides ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:461,allocate,allocated,461,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['allocate'],['allocated']
Energy Efficiency,"/*-********************************************************; * bitStream decoding; **********************************************************/; /*! BIT_initDStream() :; * Initialize a BIT_DStream_t.; * `bitD` : a pointer to an already allocated BIT_DStream_t structure.; * `srcSize` must be the *exact* size of the bitStream, in bytes.; * @return : size of stream (== srcSize), or an errorCode if a problem is detected; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h:235,allocate,allocated,235,builtins/zstd/common/bitstream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h,1,['allocate'],['allocated']
Energy Efficiency,"/*-************************************; * Simple Functions; **************************************/; /*! LZ4_compress_default() :; * Compresses 'srcSize' bytes from buffer 'src'; * into already allocated 'dst' buffer of size 'dstCapacity'.; * Compression is guaranteed to succeed if 'dstCapacity' >= LZ4_compressBound(srcSize).; * It also runs faster, so it's a recommended setting.; * If the function cannot compress 'src' into a more limited 'dst' budget,; * compression stops *immediately*, and the function result is zero.; * In which case, 'dst' content is undefined (invalid).; * srcSize : max supported value is LZ4_MAX_INPUT_SIZE.; * dstCapacity : size of buffer 'dst' (which must be already allocated); * @return : the number of bytes written into buffer 'dst' (necessarily <= dstCapacity); * or 0 if compression fails; * Note : This function is protected against buffer overflow scenarios (never writes outside 'dst' buffer, nor read outside 'source' buffer).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:195,allocate,allocated,195,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,2,['allocate'],['allocated']
Energy Efficiency,"/*-************************************; * Tuning parameters; **************************************/; /*; * LZ4F_HEAPMODE :; * Select how default compression functions will allocate memory for their hash table,; * in memory stack (0:default, fastest), or in memory heap (1:requires malloc()).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c:174,allocate,allocate,174,builtins/lz4/lz4frame.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c,1,['allocate'],['allocate']
Energy Efficiency,"/*-*********************************; * Advanced compression functions; ***********************************/; /*! LZ4F_createCompressionContext() :; * The first thing to do is to create a compressionContext object, which will be used in all compression operations.; * This is achieved using LZ4F_createCompressionContext(), which takes as argument a version and an LZ4F_preferences_t structure.; * The version provided MUST be LZ4F_VERSION. It is intended to track potential incompatible differences between different binaries.; * The function will provide a pointer to an allocated LZ4F_compressionContext_t object.; * If the result LZ4F_errorCode_t is not OK_NoError, there was an error during context creation.; * Object can release its memory using LZ4F_freeCompressionContext();; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c:573,allocate,allocated,573,builtins/lz4/lz4frame.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c,1,['allocate'],['allocated']
Energy Efficiency,/*---------------------------------------------------------------------------*/; /* Power series for incomplete beta integral.; Use when b*x is small and x not too close to 1. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephes.cxx:84,Power,Power,84,math/mathcore/src/SpecFuncCephes.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephes.cxx,1,['Power'],['Power']
Energy Efficiency,"/*---------------------------------------------------------------------------*/; /* implementation of the incomplete beta function */; /**; * DESCRIPTION:; *; * Returns incomplete beta integral of the arguments, evaluated; * from zero to x. The function is defined as; *; * x; * - -; * | (a+b) | | a-1 b-1; * ----------- | t (1-t) dt.; * - - | |; * | (a) | (b) -; * 0; *; * The domain of definition is 0 <= x <= 1. In this; * implementation a and b are restricted to positive values.; * The integral from x to 1 may be obtained by the symmetry; * relation; *; * 1 - incbet( a, b, x ) = incbet( b, a, 1-x ).; *; * The integral is evaluated by a continued fraction expansion; * or, when b*x is small, by a power series.; *; * ACCURACY:; *; * Tested at uniformly distributed random points (a,b,x) with a and b; * in ""domain"" and x between 0 and 1.; * Relative error; * arithmetic domain # trials peak rms; * IEEE 0,5 10000 6.9e-15 4.5e-16; * IEEE 0,85 250000 2.2e-13 1.7e-14; * IEEE 0,1000 30000 5.3e-12 6.3e-13; * IEEE 0,10000 250000 9.3e-11 7.1e-12; * IEEE 0,100000 10000 8.7e-10 4.8e-11; * Outputs smaller than the IEEE gradual underflow threshold; * were excluded from these statistics.; *; * ERROR MESSAGES:; * message condition value returned; * incbet domain x<0, x>1 0.0; * incbet underflow 0.0; *; * Cephes Math Library, Release 2.8: June, 2000; * Copyright 1984, 1995, 2000 by Stephen L. Moshier; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephes.cxx:704,power,power,704,math/mathcore/src/SpecFuncCephes.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephes.cxx,1,['power'],['power']
Energy Efficiency,"/*; 	 * Make our own allocated copies of the heap fields in the; 	 * copied record. This guards against potential aliasing; 	 * problems.; 	 */; /* first, the local color map */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/gifalloc.c:21,allocate,allocated,21,graf2d/asimage/src/libAfterImage/libungif/gifalloc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/gifalloc.c,1,['allocate'],['allocated']
Energy Efficiency,/*; 	 * Zero out slots up to next power of 2.; 	 * We know these slots exist because of the way ColorUnion's; 	 * start dimension was computed.; 	 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/gifalloc.c:34,power,power,34,graf2d/asimage/src/libAfterImage/libungif/gifalloc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/gifalloc.c,1,['power'],['power']
Energy Efficiency,"/*; * (C) Copyright 2016-2018 Intel Corporation.; *; * Licensed under the Apache License, Version 2.0 (the ""License"");; * you may not use this file except in compliance with the License.; * You may obtain a copy of the License at; *; * http://www.apache.org/licenses/LICENSE-2.0; *; * Unless required by applicable law or agreed to in writing, software; * distributed under the License is distributed on an ""AS IS"" BASIS,; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.; * See the License for the specific language governing permissions and; * limitations under the License.; */; /**; * \file; *; * This file is a reduced version of `daos_xxx.h` headers that provides (simplified) declarations for use in; * libdaos_mock.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h:642,reduce,reduced,642,tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,1,['reduce'],['reduced']
Energy Efficiency,"/*; * About virtual array management:; *; * The above ""normal"" array routines are only used to allocate strip buffers; * (as wide as the image, but just a few rows high). Full-image-sized buffers; * are handled as ""virtual"" arrays. The array is still accessed a strip at a; * time, but the memory manager must save the whole array for repeated; * accesses. The intended implementation is that there is a strip buffer in; * memory (as high as is possible given the desired memory limit), plus a; * backing file that holds the rest of the array.; *; * The request_virt_array routines are told the total size of the image and; * the maximum number of rows that will be accessed at once. The in-memory; * buffer must be at least as large as the maxaccess value.; *; * The request routines create control blocks but not the in-memory buffers.; * That is postponed until realize_virt_arrays is called. At that time the; * total amount of space needed is known (approximately, anyway), so free; * memory can be divided up fairly.; *; * The access_virt_array routines are responsible for making a specific strip; * area accessible (after reading or writing the backing file, if necessary).; * Note that the access routines are told whether the caller intends to modify; * the accessed strip; during a read-only pass this saves having to rewrite; * data to disk. The access routines are also responsible for pre-zeroing; * any newly accessed rows, if pre-zeroing was requested.; *; * In current usage, the access requests are usually for nonoverlapping; * strips; that is, successive access start_row numbers differ by exactly; * num_rows = maxaccess. This means we can get good performance with simple; * buffer dump/reload logic, by making the in-memory buffer be a multiple; * of the access height; then there will never be accesses across bufferload; * boundaries. The code will still work with overlapping access requests,; * but it doesn't handle bufferload overlaps very efficiently.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:95,allocate,allocate,95,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,2,"['allocate', 'efficient']","['allocate', 'efficiently']"
Energy Efficiency,/*; * Allocate a color map of given size; initialize with contents of; * ColorMap if that pointer is non-NULL.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/gifalloc.c:6,Allocate,Allocate,6,graf2d/asimage/src/libAfterImage/libungif/gifalloc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/gifalloc.c,1,['Allocate'],['Allocate']
Energy Efficiency,/*; * Allocate memory for points; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/X3DBuffer.c:6,Allocate,Allocate,6,graf3d/g3d/src/X3DBuffer.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/X3DBuffer.c,1,['Allocate'],['Allocate']
Energy Efficiency,/*; * Allocate memory for polygons; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/X3DBuffer.c:6,Allocate,Allocate,6,graf3d/g3d/src/X3DBuffer.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/X3DBuffer.c,1,['Allocate'],['Allocate']
Energy Efficiency,/*; * Allocate memory for segments; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/X3DBuffer.c:6,Allocate,Allocate,6,graf3d/g3d/src/X3DBuffer.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/X3DBuffer.c,1,['Allocate'],['Allocate']
Energy Efficiency,/*; * Allocate table which will hold the result for sure.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/gifalloc.c:6,Allocate,Allocate,6,graf2d/asimage/src/libAfterImage/libungif/gifalloc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/gifalloc.c,1,['Allocate'],['Allocate']
Energy Efficiency,/*; * Allocate workspace for Floyd-Steinberg errors.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c:6,Allocate,Allocate,6,graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/*; * Basic data types.; * You may need to change these if you have a machine with unusual data; * type sizes; for example, ""char"" not 8 bits, ""short"" not 16 bits,; * or ""long"" not 32 bits. We don't care whether ""int"" is 16 or 32 bits,; * but it had better be at least 16.; */; /* Representation of a single sample (pixel element value).; * We frequently allocate large arrays of these, so it's important to keep; * them small. But if you have memory to burn and access to char or short; * arrays is very slow on your hardware, you might want to change these.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h:355,allocate,allocate,355,graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h,1,['allocate'],['allocate']
Energy Efficiency,/*; * Compile with -DMAXSEG_64K if the alloc function cannot allocate more; * than 64k bytes at a time (needed on systems with 16-bit int).; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zconf.h:61,allocate,allocate,61,builtins/zlib/zconf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zconf.h,3,['allocate'],['allocate']
Energy Efficiency,"/*; * Compute the union of two given color maps and return it. If result can't ; * fit into 256 colors, NULL is returned, the allocated union otherwise.; * ColorIn1 is copied as is to ColorUnion, while colors from ColorIn2 are; * copied iff they didn't exist before. ColorTransIn2 maps the old; * ColorIn2 into ColorUnion color map table.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/gifalloc.c:126,allocate,allocated,126,graf2d/asimage/src/libAfterImage/libungif/gifalloc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/gifalloc.c,1,['allocate'],['allocated']
Energy Efficiency,"/*; * Copyright (c) 2016-2020, Yann Collet, Facebook, Inc.; * All rights reserved.; *; * This source code is licensed under both the BSD-style license (found in the; * LICENSE file in the root directory of this source tree) and the GPLv2 (found; * in the COPYING file in the root directory of this source tree).; * You may select, at your option, one of the above-listed licenses.; */; /* *****************************************************************************; * Constructs a dictionary using a heuristic based on the following paper:; *; * Liao, Petri, Moffat, Wirth; * Effective Construction of Relative Lempel-Ziv Dictionaries; * Published in WWW 2016.; *; * Adapted from code originally written by @ot (Giuseppe Ottaviano).; ******************************************************************************/; /*-*************************************; * Dependencies; ***************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/cover.c:669,Adapt,Adapted,669,builtins/zstd/dictBuilder/cover.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/cover.c,1,['Adapt'],['Adapted']
Energy Efficiency,"/*; * Copyright (c) 2016-2020, Yann Collet, Facebook, Inc.; * All rights reserved.; *; * This source code is licensed under both the BSD-style license (found in the; * LICENSE file in the root directory of this source tree) and the GPLv2 (found; * in the COPYING file in the root directory of this source tree).; * You may select, at your option, one of the above-listed licenses.; */; /* ***************************************************************; * Tuning parameters; *****************************************************************/; /*!; * HEAPMODE :; * Select how default decompression function ZSTD_decompress() allocates its context,; * on stack (0), or into heap (1, default; requires malloc()).; * Note that functions with explicit context such as ZSTD_decompressDCtx() are unaffected.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c:624,allocate,allocates,624,builtins/zstd/decompress/zstd_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c,1,['allocate'],['allocates']
Energy Efficiency,"/*; * Creation of 2-D sample arrays.; * The pointers are in near heap, the samples themselves in FAR heap.; *; * To minimize allocation overhead and to allow I/O of large contiguous; * blocks, we allocate the sample rows in groups of as many rows as possible; * without exceeding MAX_ALLOC_CHUNK total bytes per allocation request.; * NB: the virtual array control routines, later in this file, know about; * this chunking of rows. The rowsperchunk value is left in the mem manager; * object so that it can be saved away if this sarray is the workspace for; * a virtual array.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:196,allocate,allocate,196,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,1,['allocate'],['allocate']
Energy Efficiency,/*; * Decompress trailing data in a chunk. The assumption is that read_buffer; * points at an allocated area holding the contents of a chunk with a; * trailing compressed part. What we get back is an allocated area; * holding the original prefix part and an uncompressed version of the; * trailing part (the malloc area passed in is freed).; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:94,allocate,allocated,94,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,2,['allocate'],['allocated']
Energy Efficiency,"/*; * Fetching the next N bits from the input stream is a time-critical operation; * for the Huffman decoders. We implement it with a combination of inline; * macros and out-of-line subroutines. Note that N (the number of bits; * demanded at one time) never exceeds 15 for JPEG use.; *; * We read source bytes into get_buffer and dole out bits as needed.; * If get_buffer already contains enough bits, they are fetched in-line; * by the macros CHECK_BIT_BUFFER and GET_BITS. When there aren't enough; * bits, jpeg_fill_bit_buffer is called; it will attempt to fill get_buffer; * as full as possible (not just to the number of bits needed; this; * prefetching reduces the overhead cost of calling jpeg_fill_bit_buffer).; * Note that jpeg_fill_bit_buffer may return FALSE to indicate suspension.; * On TRUE return, jpeg_fill_bit_buffer guarantees that get_buffer contains; * at least the requested number of bits --- dummy zeroes are inserted if; * necessary.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c:659,reduce,reduces,659,graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,2,['reduce'],['reduces']
Energy Efficiency,"/*; * Find some weights which describe how the intersection vertex is; * a linear combination of ""org"" and ""dest"". Each of the two edges; * which generated ""isect"" is allocated 50% of the weight; each edge; * splits the weight between its org and dst according to the; * relative distance to ""isect"".; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c:167,allocate,allocated,167,graf3d/eve7/glu/sweep.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c,1,['allocate'],['allocated']
Energy Efficiency,"/*; * First we have the histogram data structure and routines for creating it.; *; * The number of bits of precision can be adjusted by changing these symbols.; * We recommend keeping 6 bits for G and 5 each for R and B.; * If you have plenty of memory and cycles, 6 bits all around gives marginally; * better results; if you are short of memory, 5 bits all around will save; * some space but degrade the results.; * To maintain a fully accurate histogram, we'd need to allocate a ""long""; * (preferably unsigned long) for each cell. In practice this is overkill;; * we can get by with 16 bits per cell. Few of the cell counts will overflow,; * and clamping those that do overflow to the maximum value will give close-; * enough results. This reduces the recommended histogram size from 256Kb; * to 128Kb, which is a useful savings on PC-class machines.; * (In the second pass the histogram space is re-used for pixel mapping data;; * in that capacity, each cell must be able to store zero to the number of; * desired colors. 16 bits/cell is plenty for that too.); * Since the JPEG code is intended to run in small memory model on 80x86; * machines, we can't just allocate the histogram in one chunk. Instead; * of a true 3-D array, we use a row of pointers to 2-D arrays. Each; * pointer corresponds to a C0 value (typically 2^5 = 32 pointers) and; * each 2-D array has 2^6*2^5 = 2048 or 2^6*2^6 = 4096 entries. Note that; * on 80x86 machines, the pointer row is in near memory but the actual; * arrays are in far memory (same arrangement as we use for image arrays).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:470,allocate,allocate,470,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,3,"['allocate', 'reduce']","['allocate', 'reduces']"
Energy Efficiency,"/*; * For the simple (no-context-row) case, we just need to buffer one; * row group's worth of pixels for the downsampling step. At the bottom of; * the image, we pad to a full row group by replicating the last pixel row.; * The downsampler's last output row is then replicated if needed to pad; * out to a full iMCU row.; *; * When providing context rows, we must buffer three row groups' worth of; * pixels. Three row groups are physically allocated, but the row pointer; * arrays are made five row groups high, with the extra pointers above and; * below ""wrapping around"" to point to the last and first real row groups.; * This allows the downsampler to access the proper context rows.; * At the top and bottom of the image, we create dummy context rows by; * copying the first or last real pixel row. This copying could be avoided; * by pointer hacking as is done in jdmainct.c, but it doesn't seem worth the; * trouble on the compression side.; */; /* Private buffer controller object */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcprepct.c:442,allocate,allocated,442,graf2d/asimage/src/libAfterImage/libjpeg/jcprepct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcprepct.c,1,['allocate'],['allocated']
Energy Efficiency,/*; * Free allocated memory & reset counters; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c:11,allocate,allocated,11,graf3d/x3d/src/x3d.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c,1,['allocate'],['allocated']
Energy Efficiency,"/*; * Frees an aligned pointer allocated by XXH_alignedMalloc(). Don't pass; * normal malloc'd pointers, XXH_alignedMalloc has a specific data layout.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:31,allocate,allocated,31,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['allocate'],['allocated']
Energy Efficiency,"/*; * Here is a struct to help with storage allocation; * so we can allocate a big chunk at a time, and then take; * pieces from this heap when we need to.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPolyUtils.c:68,allocate,allocate,68,graf2d/asimage/src/TASPolyUtils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPolyUtils.c,1,['allocate'],['allocate']
Energy Efficiency,"/*; * In case of error, free allocated memory; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/X3DBuffer.c:29,allocate,allocated,29,graf3d/g3d/src/X3DBuffer.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/X3DBuffer.c,1,['allocate'],['allocated']
Energy Efficiency,"/*; * In library releases up through v6a, we called jpeg_abort() here to free; * any working memory allocated by the destination manager and marker; * writer. Some applications had a problem with that: they allocated space; * of their own from the library memory manager, and didn't want it to go; * away during write_tables. So now we do nothing. This will cause a; * memory leak if an app calls write_tables repeatedly without doing a full; * compression cycle or otherwise resetting the JPEG object. However, that; * seems less bad than unexpectedly freeing memory in the normal case.; * An app that prefers the old behavior can call jpeg_abort for itself after; * each call to jpeg_write_tables().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcapimin.c:100,allocate,allocated,100,graf2d/asimage/src/libAfterImage/libjpeg/jcapimin.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcapimin.c,2,['allocate'],['allocated']
Energy Efficiency,"/*; * In the current system design, the main buffer need never be a full-image; * buffer; any full-height buffers will be found inside the coefficient or; * postprocessing controllers. Nonetheless, the main controller is not; * trivial. Its responsibility is to provide context rows for upsampling/; * rescaling, and doing this in an efficient fashion is a bit tricky.; *; * Postprocessor input data is counted in ""row groups"". A row group; * is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size); * sample rows of each component. (We require DCT_scaled_size values to be; * chosen such that these numbers are integers. In practice DCT_scaled_size; * values will likely be powers of two, so we actually have the stronger; * condition that DCT_scaled_size / min_DCT_scaled_size is an integer.); * Upsampling will typically produce max_v_samp_factor pixel rows from each; * row group (times any additional scale factor that the upsampler is; * applying).; *; * The coefficient controller will deliver data to us one iMCU row at a time;; * each iMCU row contains v_samp_factor * DCT_scaled_size sample rows, or; * exactly min_DCT_scaled_size row groups. (This amount of data corresponds; * to one row of MCUs when the image is fully interleaved.) Note that the; * number of sample rows varies across components, but the number of row; * groups does not. Some garbage sample rows may be included in the last iMCU; * row at the bottom of the image.; *; * Depending on the vertical scaling algorithm used, the upsampler may need; * access to the sample row(s) above and below its current input row group.; * The upsampler is required to set need_context_rows TRUE at global selection; * time if so. When need_context_rows is FALSE, this controller can simply; * obtain one iMCU row at a time from the coefficient controller and dole it; * out as row groups to the postprocessor.; *; * When need_context_rows is TRUE, this controller guarantees that the buffer; * passed to postprocessing ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c:334,efficient,efficient,334,graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c,2,"['efficient', 'power']","['efficient', 'powers']"
Energy Efficiency,"/*; * Initialize the error-limiting transfer function (lookup table).; * The raw F-S error computation can potentially compute error values of up to; * +- MAXJSAMPLE. But we want the maximum correction applied to a pixel to be; * much less, otherwise obviously wrong pixels will be created. (Typical; * effects include weird fringes at color-area boundaries, isolated bright; * pixels in a dark area, etc.) The standard advice for avoiding this problem; * is to ensure that the ""corners"" of the color cube are allocated as output; * colors; then repeated errors in the same direction cannot cause cascading; * error buildup. However, that only prevents the error from getting; * completely out of hand; Aaron Giles reports that error limiting improves; * the results even with corner colors allocated.; * A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty; * well, but the smoother transfer function used below is even better. Thanks; * to Aaron Giles for this idea.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:510,allocate,allocated,510,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,2,['allocate'],['allocated']
Energy Efficiency,"/*; * Need RHist::iterator for full range, takes a predicate for ""in range?""; * Returns true for RHist; for RHistView, checks range, returns false if not in; * range. i+= 7 then does i++ seven times and checks at each step.; * iterator is simply an int with a predicate functor. end is end of the; * histogram - i.e. the number of bins (incl over / underflow).; *; * Add is then an operation (through a functor) on two bins.; *; * Drawing: need adaptor from RHist<n,p>::GetBinContent(...) to; * RHistPrecNormalizer<n>::Get(i) that casts the bin content to a double. That; * should be in internal but outside the drawing library (that needs to; * communicate through abstract interfaces and can thus not instantiate; * templates with user precision parameters.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistView.hxx:445,adapt,adaptor,445,hist/histv7/inc/ROOT/RHistView.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistView.hxx,1,['adapt'],['adaptor']
Energy Efficiency,"/*; * Out-of-line code for bit fetching.; * Note: current values of get_buffer and bits_left are passed as parameters,; * but are returned in the corresponding fields of the state struct.; *; * On most machines MIN_GET_BITS should be 25 to allow the full 32-bit width; * of get_buffer to be used. (On machines with wider words, an even larger; * buffer could be used.) However, on some machines 32-bit shifts are; * quite slow and take time proportional to the number of places shifted.; * (This is true with most PC compilers, for instance.) In this case it may; * be a win to set MIN_GET_BITS to the minimum value of 15. This reduces the; * average shift distance at the cost of more calls to jpeg_fill_bit_buffer.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c:628,reduce,reduces,628,graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,1,['reduce'],['reduces']
Energy Efficiency,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a reduced-size 1x1 output block.; *; * We hardly need an inverse DCT routine for this: just take the; * average pixel value, which is one-eighth of the DC coefficient.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:90,reduce,reduced-size,90,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['reduce'],['reduced-size']
Energy Efficiency,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a reduced-size 2x2 output block.; *; * Multiplication-less algorithm.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:90,reduce,reduced-size,90,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['reduce'],['reduced-size']
Energy Efficiency,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a reduced-size 3x3 output block.; *; * Optimized algorithm with 2 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/6).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:90,reduce,reduced-size,90,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['reduce'],['reduced-size']
Energy Efficiency,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a reduced-size 3x6 output block.; *; * 6-point IDCT in pass 1 (columns), 3-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:90,reduce,reduced-size,90,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['reduce'],['reduced-size']
Energy Efficiency,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a reduced-size 4x4 output block.; *; * Optimized algorithm with 3 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point IDCT].; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:90,reduce,reduced-size,90,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['reduce'],['reduced-size']
Energy Efficiency,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a reduced-size 5x5 output block.; *; * Optimized algorithm with 5 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/10).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:90,reduce,reduced-size,90,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['reduce'],['reduced-size']
Energy Efficiency,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a reduced-size 6x3 output block.; *; * 3-point IDCT in pass 1 (columns), 6-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:90,reduce,reduced-size,90,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['reduce'],['reduced-size']
Energy Efficiency,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a reduced-size 6x6 output block.; *; * Optimized algorithm with 3 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/12).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:90,reduce,reduced-size,90,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['reduce'],['reduced-size']
Energy Efficiency,/*; * Portable and safe solution. Generally efficient.; * see: https://stackoverflow.com/a/32095106/646947; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:44,efficient,efficient,44,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,['efficient'],['efficient']
Energy Efficiency,"/*; * Portable scalar method. Optimized for 32-bit and 64-bit ALUs.; *; * This is a fast and simple grade school multiply, which is shown below; * with base 10 arithmetic instead of base 0x100000000.; *; * 9 3 // D2 lhs = 93; * x 7 5 // D2 rhs = 75; * ----------; * 1 5 // D2 lo_lo = (93 % 10) * (75 % 10) = 15; * 4 5 | // D2 hi_lo = (93 / 10) * (75 % 10) = 45; * 2 1 | // D2 lo_hi = (93 % 10) * (75 / 10) = 21; * + 6 3 | | // D2 hi_hi = (93 / 10) * (75 / 10) = 63; * ---------; * 2 7 | // D2 cross = (15 / 10) + (45 % 10) + 21 = 27; * + 6 7 | | // D2 upper = (27 / 10) + (45 / 10) + 63 = 67; * ---------; * 6 9 7 5 // D4 res = (27 * 10) + (15 % 10) + (67 * 100) = 6975; *; * The reasons for adding the products like this are:; * 1. It avoids manual carry tracking. Just like how; * (9 * 9) + 9 + 9 = 99, the same applies with this for UINT64_MAX.; * This avoids a lot of complexity.; *; * 2. It hints for, and on Clang, compiles to, the powerful UMAAL; * instruction available in ARM's Digital Signal Processing extension; * in 32-bit ARMv6 and later, which is shown below:; *; * void UMAAL(xxh_u32 *RdLo, xxh_u32 *RdHi, xxh_u32 Rn, xxh_u32 Rm); * {; * xxh_u64 product = (xxh_u64)*RdLo * (xxh_u64)*RdHi + Rn + Rm;; * *RdLo = (xxh_u32)(product & 0xFFFFFFFF);; * *RdHi = (xxh_u32)(product >> 32);; * }; *; * This instruction was designed for efficient long multiplication, and; * allows this to be calculated in only 4 instructions at speeds; * comparable to some 64-bit ALUs.; *; * 3. It isn't terrible on other platforms. Usually this will be a couple; * of 32-bit ADD/ADCs.; */; /* First calculate all of the cross products. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:938,power,powerful,938,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,"['efficient', 'power']","['efficient', 'powerful']"
Energy Efficiency,"/*; * Prepare for output to a memory buffer.; * The caller may supply an own initial buffer with appropriate size.; * Otherwise, or when the actual data output exceeds the given size,; * the library adapts the buffer size as necessary.; * The standard library functions malloc/free are used for allocating; * larger memory, so the buffer is available to the application after; * finishing compression, and then the application is responsible for; * freeing the requested memory.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c:199,adapt,adapts,199,graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c,1,['adapt'],['adapts']
Energy Efficiency,"/*; * Project: RooFit; * Authors:; * Jonas Rembser, CERN 2021; * Emmanouil Michalainas, CERN 2021; *; * Copyright (c) 2021, CERN; *; * Redistribution and use in source and binary forms,; * with or without modification, are permitted according to the terms; * listed in LICENSE (http://roofit.sourceforge.net/license.txt); */; /**; \file Evaluator.cxx; \class RooFit::Evaluator; \ingroup Roofitcore. Evaluates a RooAbsReal object in other ways than recursive graph; traversal. Currently, it is being used for evaluating a RooAbsReal object and; supplying the value to the minimizer, during a fit. The class scans the; dependencies and schedules the computations in a secure and efficient way. The; computations take place in the RooBatchCompute library and can be carried off; by either the CPU or a CUDA-supporting GPU. The Evaluator class takes care; of data transfers. An instance of this class is created every time; RooAbsPdf::fitTo() is called and gets destroyed when the fitting ends.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Evaluator.cxx:634,schedul,schedules,634,roofit/roofitcore/src/RooFit/Evaluator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Evaluator.cxx,2,"['efficient', 'schedul']","['efficient', 'schedules']"
Energy Efficiency,"/*; * Project: RooFit; *; * Copyright (c) 2022, CERN; *; * Redistribution and use in source and binary forms,; * with or without modification, are permitted according to the terms; * listed in LICENSE (http://roofit.sourceforge.net/license.txt); */; /** \class RooPowerSum; \ingroup Roofit. RooPowerSum implements a power law PDF of the form; \f[ f(x) = \mathcal{N} \cdot \sum_{i} a_{i} * x^{b_i} \f]. \image html RooPowerSum.png; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooPowerSum.cxx:316,power,power,316,roofit/roofit/src/RooPowerSum.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooPowerSum.cxx,1,['power'],['power']
Energy Efficiency,"/*; * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008); * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.; *; * Permission is hereby granted, free of charge, to any person obtaining a; * copy of this software and associated documentation files (the ""Software""),; * to deal in the Software without restriction, including without limitation; * the rights to use, copy, modify, merge, publish, distribute, sublicense,; * and/or sell copies of the Software, and to permit persons to whom the; * Software is furnished to do so, subject to the following conditions:; *; * The above copyright notice including the dates of first publication and; * either this permission notice or a reference to; * http://oss.sgi.com/projects/FreeB/; * shall be included in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS; * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL; * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,; * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF; * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; * SOFTWARE.; *; * Except as contained in this notice, the name of Silicon Graphics, Inc.; * shall not be used in advertising or otherwise to promote the sale, use or; * other dealings in this Software without prior written authorization from; * Silicon Graphics, Inc.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/GL_glu.h:179,charge,charge,179,graf3d/eve7/glu/GL_glu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/GL_glu.h,1,['charge'],['charge']
Energy Efficiency,"/*; * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008); * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.; *; * Permission is hereby granted, free of charge, to any person obtaining a; * copy of this software and associated documentation files (the ""Software""),; * to deal in the Software without restriction, including without limitation; * the rights to use, copy, modify, merge, publish, distribute, sublicense,; * and/or sell copies of the Software, and to permit persons to whom the; * Software is furnished to do so, subject to the following conditions:; *; * The above copyright notice including the dates of first publication and; * either this permission notice or a reference to; * http://oss.sgi.com/projects/FreeB/; * shall be included in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS; * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL; * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,; * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF; * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; * SOFTWARE.; *; * Except as contained in this notice, the name of Silicon Graphics, Inc.; * shall not be used in advertising or otherwise to promote the sale, use or; * other dealings in this Software without prior written authorization from; * Silicon Graphics, Inc.; */; /*; ** Author: Eric Veach, July 1994.; **; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/dict-list.h:179,charge,charge,179,graf3d/eve7/glu/dict-list.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/dict-list.h,24,['charge'],['charge']
Energy Efficiency,"/*; * The Lean Mean C++ Option Parser; *; * Copyright (C) 2012 Matthias S. Benkmann; *; * The ""Software"" in the following 2 paragraphs refers to this file containing; * the code to The Lean Mean C++ Option Parser.; * The ""Software"" does NOT refer to any other files which you; * may have received alongside this file (e.g. as part of a larger project that; * incorporates The Lean Mean C++ Option Parser).; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software, to deal in the Software without restriction, including; * without limitation the rights to use, copy, modify, merge, publish,; * distribute, sublicense, and/or sell copies of the Software, and to permit; * persons to whom the Software is furnished to do so, subject to the following; * conditions:; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; * SOFTWARE.; */; /*; * NOTE: It is recommended that you read the processed HTML doxygen documentation; * rather than this source. If you don't know doxygen, it's like javadoc for C++.; * If you don't want to install doxygen you can find a copy of the processed; * documentation at; *; * http://optionparser.sourceforge.net/; *; */; /*; Danio Piparo - Since we import this parser from tan external source, we keep; track of the changes:. New Features 6-7-12:; o Added FullArg class from the examples in the header. Bugs Fixed 8-7-12:; o Cov: Add initialisation of screenlen variable in Li",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h:450,charge,charge,450,core/dictgen/res/OptionParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h,1,['charge'],['charge']
Energy Efficiency,"/*; * The control blocks for virtual arrays.; * Note that these blocks are allocated in the ""small"" pool area.; * System-dependent info for the associated backing store (if any) is hidden; * inside the backing_store_info struct.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:75,allocate,allocated,75,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,1,['allocate'],['allocated']
Energy Efficiency,"/*; * The core arithmetic decoding routine (common in JPEG and JBIG).; * This needs to go as fast as possible.; * Machine-dependent optimization facilities; * are not utilized in this portable implementation.; * However, this code should be fairly efficient and; * may be a good base for further optimizations anyway.; *; * Return value is 0 or 1 (binary decision).; *; * Note: I've changed the handling of the code base & bit; * buffer register C compared to other implementations; * based on the standards layout & procedures.; * While it also contains both the actual base of the; * coding interval (16 bits) and the next-bits buffer,; * the cut-point between these two parts is floating; * (instead of fixed) with the bit shift counter CT.; * Thus, we also need only one (variable instead of; * fixed size) shift for the LPS/MPS decision, and; * we can get away with any renormalization update; * of C (except for new data insertion, of course).; *; * I've also introduced a new scheme for accessing; * the probability estimation state machine table,; * derived from Markus Kuhn's JBIG implementation.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdarith.c:248,efficient,efficient,248,graf2d/asimage/src/libAfterImage/libjpeg/jdarith.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdarith.c,1,['efficient'],['efficient']
Energy Efficiency,"/*; * The core arithmetic encoding routine (common in JPEG and JBIG).; * This needs to go as fast as possible.; * Machine-dependent optimization facilities; * are not utilized in this portable implementation.; * However, this code should be fairly efficient and; * may be a good base for further optimizations anyway.; *; * Parameter 'val' to be encoded may be 0 or 1 (binary decision).; *; * Note: I've added full ""Pacman"" termination support to the; * byte output routines, which is equivalent to the optional; * Discard_final_zeros procedure (Figure D.15) in the spec.; * Thus, we always produce the shortest possible output; * stream compliant to the spec (no trailing zero bytes,; * except for FF stuffing).; *; * I've also introduced a new scheme for accessing; * the probability estimation state machine table,; * derived from Markus Kuhn's JBIG implementation.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c:248,efficient,efficient,248,graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,1,['efficient'],['efficient']
Energy Efficiency,"/*; * These are the data structures needed to scan; * convert regions. Two different scan conversion; * methods are available -- the even-odd method, and; * the winding number method.; * The even-odd rule states that a point is inside; * the polygon if a ray drawn from that point in any; * direction will pass through an odd number of; * path segments.; * By the winding number rule, a point is decided; * to be inside the polygon if a ray drawn from that; * point in any direction passes through a different; * number of clockwise and counter-clockwise path; * segments.; *; * These data structures are adapted somewhat from; * the algorithm in (Foley/Van Dam) for scan converting; * polygons.; * The basic algorithm is to start at the top (smallest y); * of the polygon, stepping down to the bottom of; * the polygon by incrementing the y coordinate. We; * keep a list of edges which the current scanline crosses,; * sorted by x. This list is called the Active Edge Table (AET); * As we change the y-coordinate, we update each entry in; * in the active edge table to reflect the edges new xcoord.; * This list must be sorted at each scanline in case; * two edges intersect.; * We also keep a data structure known as the Edge Table (ET),; * which keeps track of all the edges which the current; * scanline has not yet reached. The ET is basically a; * list of ScanLineList structures containing a list of; * edges which are entered at a given scanline. There is one; * ScanLineList per scanline at which an edge is entered.; * When we enter a new edge, we move it from the ET to the AET.; *; * From the AET, we can implement the even-odd rule as in; * (Foley/Van Dam).; * The winding number rule is a little trickier. We also; * keep the EdgeTableEntries in the AET linked by the; * nextWETE (winding EdgeTableEntry) link. This allows; * the edges to be linked just as before for updating; * purposes, but only uses the edges linked by the nextWETE; * link as edges representing spans of the polygon",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPolyUtils.c:605,adapt,adapted,605,graf2d/asimage/src/TASPolyUtils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPolyUtils.c,1,['adapt'],['adapted']
Energy Efficiency,"/*; * These routines are concerned with the time-critical task of mapping input; * colors to the nearest color in the selected colormap.; *; * We re-use the histogram space as an ""inverse color map"", essentially a; * cache for the results of nearest-color searches. All colors within a; * histogram cell will be mapped to the same colormap entry, namely the one; * closest to the cell's center. This may not be quite the closest entry to; * the actual input color, but it's almost as good. A zero in the cache; * indicates we haven't found the nearest color for that cell yet; the array; * is cleared to zeroes before starting the mapping pass. When we find the; * nearest color for a cell, its colormap index plus one is recorded in the; * cache for future use. The pass2 scanning routines call fill_inverse_cmap; * when they need to use an unfilled entry in the cache.; *; * Our method of efficiently finding nearest colors is based on the ""locally; * sorted search"" idea described by Heckbert and on the incremental distance; * calculation described by Spencer W. Thomas in chapter III.1 of Graphics; * Gems II (James Arvo, ed. Academic Press, 1991). Thomas points out that; * the distances from a given colormap entry to each cell of the histogram can; * be computed quickly using an incremental method: the differences between; * distances to adjacent cells themselves differ by a constant. This allows a; * fairly fast implementation of the ""brute force"" approach of computing the; * distance from every colormap entry to every histogram cell. Unfortunately,; * it needs a work array to hold the best-distance-so-far for each histogram; * cell (because the inner loop has to be over cells, not colormap entries).; * The work array elements have to be INT32s, so the work array would need; * 256Kb at our recommended precision. This is not feasible in DOS machines.; *; * To get around these problems, we apply Thomas' method to compute the; * nearest colors for only the cells within a small sub",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:891,efficient,efficiently,891,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['efficient'],['efficiently']
Energy Efficiency,"/*; * These routines take care of any system-dependent initialization and; * cleanup required. jpeg_mem_init will be called before anything is; * allocated (and, therefore, nothing in cinfo is of use except the error; * manager pointer). It should return a suitable default value for; * max_memory_to_use; this may subsequently be overridden by the surrounding; * application. (Note that max_memory_to_use is only important if; * jpeg_mem_available chooses to consult it ... no one else will.); * jpeg_mem_term may assume that all requested memory has been freed and that; * all opened backing-store objects have been closed.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemsys.h:146,allocate,allocated,146,graf2d/asimage/src/libAfterImage/libjpeg/jmemsys.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemsys.h,1,['allocate'],['allocated']
Energy Efficiency,"/*; * These two functions are used to allocate and release large chunks of; * memory (up to the total free space designated by jpeg_mem_available).; * The interface is the same as above, except that on an 80x86 machine,; * far pointers are used. On most other machines these are identical to; * the jpeg_get/free_small routines; but we keep them separate anyway,; * in case a different allocation strategy is desirable for large chunks.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemsys.h:38,allocate,allocate,38,graf2d/asimage/src/libAfterImage/libjpeg/jmemsys.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemsys.h,1,['allocate'],['allocate']
Energy Efficiency,"/*; * This code is derived from (original license follows):; *; * This is an OpenSSL-compatible implementation of the RSA Data Security, Inc.; * MD5 Message-Digest Algorithm (RFC 1321).; *; * Homepage:; * http://openwall.info/wiki/people/solar/software/public-domain-source-code/md5; *; * Author:; * Alexander Peslyak, better known as Solar Designer <solar at openwall.com>; *; * This software was written by Alexander Peslyak in 2001. No copyright is; * claimed, and the software is hereby placed in the public domain.; * In case this attempt to disclaim copyright and place the software in the; * public domain is deemed null and void, then the software is; * Copyright (c) 2001 Alexander Peslyak and it is hereby released to the; * general public under the following terms:; *; * Redistribution and use in source and binary forms, with or without; * modification, are permitted.; *; * There's ABSOLUTELY NO WARRANTY, express or implied.; *; * (This is a heavily cut-down ""BSD license"".); *; * This differs from Colin Plumb's older public domain implementation in that; * no exactly 32-bit integer data type is required (any 32-bit or wider; * unsigned integer data type will do), there's no compile-time endianness; * configuration, and the function prototypes match OpenSSL's. No code from; * Colin Plumb's implementation has been reused; this comment merely compares; * the properties of the two independent implementations.; *; * The primary goals of this implementation are portability and ease of use.; * It is meant to be fast, but not as fast as possible. Some known; * optimizations are not included to reduce source code size and avoid; * compile-time configuration.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MD5.cpp:1614,reduce,reduce,1614,interpreter/llvm-project/llvm/lib/Support/MD5.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MD5.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/*; * This module implements the well-known Heckbert paradigm for color; * quantization. Most of the ideas used here can be traced back to; * Heckbert's seminal paper; * Heckbert, Paul. ""Color Image Quantization for Frame Buffer Display"",; * Proc. SIGGRAPH '82, Computer Graphics v.16 #3 (July 1982), pp 297-304.; *; * In the first pass over the image, we accumulate a histogram showing the; * usage count of each possible color. To keep the histogram to a reasonable; * size, we reduce the precision of the input; typical practice is to retain; * 5 or 6 bits per color, so that 8 or 4 different input values are counted; * in the same histogram cell.; *; * Next, the color-selection step begins with a box representing the whole; * color space, and repeatedly splits the ""largest"" remaining box until we; * have as many boxes as desired colors. Then the mean color in each; * remaining box becomes one of the possible output colors.; * ; * The second pass over the image maps each input pixel to the closest output; * color (optionally after applying a Floyd-Steinberg dithering correction).; * This mapping is logically trivial, but making it go fast enough requires; * considerable care.; *; * Heckbert-style quantizers vary a good deal in their policies for choosing; * the ""largest"" box and deciding where to cut it. The particular policies; * used here have proved out well in experimental comparisons, but better ones; * may yet be found.; *; * In earlier versions of the IJG code, this module quantized in YCbCr color; * space, processing the raw upsampled data without a color conversion step.; * This allowed the color conversion math to be done only once per colormap; * entry, not once per pixel. However, that optimization precluded other; * useful optimizations (such as merging color conversion with upsampling); * and it also interfered with desired capabilities such as quantizing to an; * externally-supplied colormap. We have therefore abandoned that approach.; * The present code w",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:480,reduce,reduce,480,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['reduce'],['reduce']
Energy Efficiency,"/*; * This routine computes the total space still available for allocation by; * jpeg_get_large. If more space than this is needed, backing store will be; * used. NOTE: any memory already allocated must not be counted.; *; * There is a minimum space requirement, corresponding to the minimum; * feasible buffer sizes; jmemmgr.c will request that much space even if; * jpeg_mem_available returns zero. The maximum space needed, enough to hold; * all working storage in memory, is also passed in case it is useful.; * Finally, the total space already allocated is passed. If no better; * method is available, cinfo->mem->max_memory_to_use - already_allocated; * is often a suitable calculation.; *; * It is OK for jpeg_mem_available to underestimate the space available; * (that'll just lead to more backing-store access than is really necessary).; * However, an overestimate will lead to failure. Hence it's wise to subtract; * a slop factor from the true available space. 5% should be enough.; *; * On machines with lots of virtual memory, any large constant may be returned.; * Conversely, zero may be returned to always use the minimum amount of memory.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemsys.h:188,allocate,allocated,188,graf2d/asimage/src/libAfterImage/libjpeg/jmemsys.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemsys.h,2,['allocate'],['allocated']
Energy Efficiency,"/*; * UGLY HACK:; * Clang generates a bunch of MOV/MOVK pairs for aarch64, and they are; * placed sequentially, in order, at the top of the unrolled loop.; *; * While MOVK is great for generating constants (2 cycles for a 64-bit; * constant compared to 4 cycles for LDR), long MOVK chains stall the; * integer pipelines:; * I L S; * MOVK; * MOVK; * MOVK; * MOVK; * ADD; * SUB STR; * STR; * By forcing loads from memory (as the asm line causes Clang to assume; * that XXH3_kSecretPtr has been changed), the pipelines are used more; * efficiently:; * I L S; * LDR; * ADD LDR; * SUB STR; * STR; * XXH3_64bits_withSeed, len == 256, Snapdragon 835; * without hack: 2654.4 MB/s; * with hack: 3202.9 MB/s; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:533,efficient,efficiently,533,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['efficient'],['efficiently']
Energy Efficiency,"/*; * We allocate objects from ""pools"", where each pool is gotten with a single; * request to jpeg_get_small() or jpeg_get_large(). There is no per-object; * overhead within a pool, except for alignment padding. Each pool has a; * header with a link to the next pool of the same class.; * Small and large pool headers are identical except that the latter's; * link pointer must be FAR on 80x86 machines.; * Notice that the ""real"" header fields are union'ed with a dummy ALIGN_TYPE; * field. This forces the compiler to make SIZEOF(small_pool_hdr) a multiple; * of the alignment requirement of ALIGN_TYPE.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:9,allocate,allocate,9,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,1,['allocate'],['allocate']
Energy Efficiency,"/*; * XXH3_accumulate_512 is the tightest loop for long inputs, and it is the most optimized.; *; * It is a hardened version of UMAC, based off of FARSH's implementation.; *; * This was chosen because it adapts quite well to 32-bit, 64-bit, and SIMD; * implementations, and it is ridiculously fast.; *; * We harden it by mixing the original input to the accumulators as well as the product.; *; * This means that in the (relatively likely) case of a multiply by zero, the; * original input is preserved.; *; * On 128-bit inputs, we swap 64-bit pairs when we add the input to improve; * cross-pollination, as otherwise the upper and lower halves would be; * essentially independent.; *; * This doesn't matter on 64-bit hashes since they all get merged together in; * the end, so we skip the extra step.; *; * Both XXH3_64bits and XXH3_128bits use this subroutine.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:204,adapt,adapts,204,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['adapt'],['adapts']
Energy Efficiency,"/*; * divsufsort.c for libdivsufsort-lite; * Copyright (c) 2003-2008 Yuta Mori All Rights Reserved.; *; * Permission is hereby granted, free of charge, to any person; * obtaining a copy of this software and associated documentation; * files (the ""Software""), to deal in the Software without; * restriction, including without limitation the rights to use,; * copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the; * Software is furnished to do so, subject to the following; * conditions:; *; * The above copyright notice and this permission notice shall be; * included in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES; * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT; * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,; * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING; * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR; * OTHER DEALINGS IN THE SOFTWARE.; */; /*- Compiler specifics -*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/divsufsort.c:144,charge,charge,144,builtins/zstd/dictBuilder/divsufsort.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/divsufsort.c,1,['charge'],['charge']
Energy Efficiency,"/*; * divsufsort.h for libdivsufsort-lite; * Copyright (c) 2003-2008 Yuta Mori All Rights Reserved.; *; * Permission is hereby granted, free of charge, to any person; * obtaining a copy of this software and associated documentation; * files (the ""Software""), to deal in the Software without; * restriction, including without limitation the rights to use,; * copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the; * Software is furnished to do so, subject to the following; * conditions:; *; * The above copyright notice and this permission notice shall be; * included in all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES; * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT; * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,; * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING; * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR; * OTHER DEALINGS IN THE SOFTWARE.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/divsufsort.h:144,charge,charge,144,builtins/zstd/dictBuilder/divsufsort.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/divsufsort.h,1,['charge'],['charge']
Energy Efficiency,"/*; * gdk_wcstombs ; *; * Returns a multi-byte string converted from the specified array; * of wide characters. The string is newly allocated. The array of; * wide characters must be null-terminated. If the conversion is; * failed, it returns NULL.; *; * On Win32, we always use UTF-8.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkim-win32.c:132,allocate,allocated,132,graf2d/win32gdk/gdk/src/gdk/win32/gdkim-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkim-win32.c,1,['allocate'],['allocated']
Energy Efficiency,"/*; * jcinit.c; *; * Copyright (C) 1991-1997, Thomas G. Lane.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This file contains initialization logic for the JPEG compressor.; * This routine is in charge of selecting the modules to be executed and; * making an initialization call to each one.; *; * Logically, this code belongs in jcmaster.c. It's split out because; * linking this routine implies linking the entire compression library.; * For a transcoding-only application, we want to be able to use jcmaster.c; * without linking in the whole library.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcinit.c:295,charge,charge,295,graf2d/asimage/src/libAfterImage/libjpeg/jcinit.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcinit.c,1,['charge'],['charge']
Energy Efficiency,"/*; * jcsample.c; *; * Copyright (C) 1991-1996, Thomas G. Lane.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This file contains downsampling routines.; *; * Downsampling input data is counted in ""row groups"". A row group; * is defined to be max_v_samp_factor pixel rows of each component,; * from which the downsampler produces v_samp_factor sample rows.; * A single row group is processed in each call to the downsampler module.; *; * The downsampler is responsible for edge-expansion of its output data; * to fill an integral number of DCT blocks horizontally. The source buffer; * may be modified if it is helpful for this purpose (the source buffer is; * allocated wide enough to correspond to the desired output width).; * The caller (the prep controller) is responsible for vertical padding.; *; * The downsampler may request ""context rows"" by setting need_context_rows; * during startup. In this case, the input arrays will contain at least; * one row group's worth of pixels above and below the passed-in data;; * the caller will create dummy rows at image top and bottom by replicating; * the first or last real pixel row.; *; * An excellent reference for image resampling is; * Digital Image Warping, George Wolberg, 1990.; * Pub. by IEEE Computer Society Press, Los Alamitos, CA. ISBN 0-8186-8944-7.; *; * The downsampling algorithm used here is a simple average of the source; * pixels covered by the output pixel. The hi-falutin sampling literature; * refers to this as a ""box filter"". In general the characteristics of a box; * filter are not very good, but for the specific cases we normally use (1:1; * and 2:1 ratios) the box is equivalent to a ""triangle filter"" which is not; * nearly so bad. If you intend to use other sampling ratios, you'd be well; * advised to improve this code.; *; * A simple input-smoothing capability is provided. This is mainly intended; * for cleaning up ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcsample.c:760,allocate,allocated,760,graf2d/asimage/src/libAfterImage/libjpeg/jcsample.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcsample.c,1,['allocate'],['allocated']
Energy Efficiency,"/*; * jfdctflt.c; *; * Copyright (C) 1994-1996, Thomas G. Lane.; * Modified 2003-2009 by Guido Vollbeding.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This file contains a floating-point implementation of the; * forward DCT (Discrete Cosine Transform).; *; * This implementation should be more accurate than either of the integer; * DCT implementations. However, it may not give the same results on all; * machines because of differences in roundoff behavior. Speed will depend; * on the hardware's floating point capacity.; *; * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT; * on each column. Direct algorithms are also available, but they are; * much more complex and seem not to be any faster when reduced to code.; *; * This implementation is based on Arai, Agui, and Nakajima's algorithm for; * scaled DCT. Their original paper (Trans. IEICE E-71(11):1095) is in; * Japanese, but the algorithm is described in the Pennebaker & Mitchell; * JPEG textbook (see REFERENCES section in file README). The following code; * is based directly on figure 4-8 in P&M.; * While an 8-point DCT cannot be done in less than 11 multiplies, it is; * possible to arrange the computation so that many of the multiplies are; * simple scalings of the final outputs. These multiplies can then be; * folded into the multiplications or divisions by the JPEG quantization; * table entries. The AA&N method leaves only 5 multiplies and 29 adds; * to be done in the DCT itself.; * The primary disadvantage of this method is that with a fixed-point; * implementation, accuracy is lost due to imprecise representation of the; * scaled quantization values. However, that problem does not arise if; * we use floating point arithmetic.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctflt.c:823,reduce,reduced,823,graf2d/asimage/src/libAfterImage/libjpeg/jfdctflt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctflt.c,1,['reduce'],['reduced']
Energy Efficiency,"/*; * jfdctfst.c; *; * Copyright (C) 1994-1996, Thomas G. Lane.; * Modified 2003-2009 by Guido Vollbeding.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This file contains a fast, not so accurate integer implementation of the; * forward DCT (Discrete Cosine Transform).; *; * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT; * on each column. Direct algorithms are also available, but they are; * much more complex and seem not to be any faster when reduced to code.; *; * This implementation is based on Arai, Agui, and Nakajima's algorithm for; * scaled DCT. Their original paper (Trans. IEICE E-71(11):1095) is in; * Japanese, but the algorithm is described in the Pennebaker & Mitchell; * JPEG textbook (see REFERENCES section in file README). The following code; * is based directly on figure 4-8 in P&M.; * While an 8-point DCT cannot be done in less than 11 multiplies, it is; * possible to arrange the computation so that many of the multiplies are; * simple scalings of the final outputs. These multiplies can then be; * folded into the multiplications or divisions by the JPEG quantization; * table entries. The AA&N method leaves only 5 multiplies and 29 adds; * to be done in the DCT itself.; * The primary disadvantage of this method is that with fixed-point math,; * accuracy is lost due to imprecise representation of the scaled; * quantization values. The smaller the quantization table entry, the less; * precise the scaled value, so this implementation does worse with high-; * quality-setting files than with low-quality ones.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctfst.c:567,reduce,reduced,567,graf2d/asimage/src/libAfterImage/libjpeg/jfdctfst.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctfst.c,1,['reduce'],['reduced']
Energy Efficiency,"/*; * jfdctint.c; *; * Copyright (C) 1991-1996, Thomas G. Lane.; * Modification developed 2003-2009 by Guido Vollbeding.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This file contains a slow-but-accurate integer implementation of the; * forward DCT (Discrete Cosine Transform).; *; * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT; * on each column. Direct algorithms are also available, but they are; * much more complex and seem not to be any faster when reduced to code.; *; * This implementation is based on an algorithm described in; * C. Loeffler, A. Ligtenberg and G. Moschytz, ""Practical Fast 1-D DCT; * Algorithms with 11 Multiplications"", Proc. Int'l. Conf. on Acoustics,; * Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.; * The primary algorithm described there uses 11 multiplies and 29 adds.; * We use their alternate method with 12 multiplies and 32 adds.; * The advantage of this method is that no data path contains more than one; * multiplication; this allows a very simple and accurate implementation in; * scaled fixed-point arithmetic, with a minimal number of shifts.; *; * We also provide FDCT routines with various input sample block sizes for; * direct resolution reduction or enlargement and for direct resolving the; * common 2x1 and 1x2 subsampling cases without additional resampling: NxN; * (N=1...16), 2NxN, and Nx2N (N=1...8) pixels for one 8x8 output DCT block.; *; * For N<8 we fill the remaining block coefficients with zero.; * For N>8 we apply a partial N-point FDCT on the input samples, computing; * just the lower 8 frequency coefficients and discarding the rest.; *; * We must scale the output coefficients of the N-point FDCT appropriately; * to the standard 8-point FDCT level by 8/N per 1-D pass. This scaling; * is folded into the constant multipliers (pass 2) and/or final/initial; * shifting.; *; * CAUTION: We rely on t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:577,reduce,reduced,577,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['reduce'],['reduced']
Energy Efficiency,"/*; * jidctflt.c; *; * Copyright (C) 1994-1998, Thomas G. Lane.; * Modified 2010 by Guido Vollbeding.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This file contains a floating-point implementation of the; * inverse DCT (Discrete Cosine Transform). In the IJG code, this routine; * must also perform dequantization of the input coefficients.; *; * This implementation should be more accurate than either of the integer; * IDCT implementations. However, it may not give the same results on all; * machines because of differences in roundoff behavior. Speed will depend; * on the hardware's floating point capacity.; *; * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT; * on each row (or vice versa, but it's more convenient to emit a row at; * a time). Direct algorithms are also available, but they are much more; * complex and seem not to be any faster when reduced to code.; *; * This implementation is based on Arai, Agui, and Nakajima's algorithm for; * scaled DCT. Their original paper (Trans. IEICE E-71(11):1095) is in; * Japanese, but the algorithm is described in the Pennebaker & Mitchell; * JPEG textbook (see REFERENCES section in file README). The following code; * is based directly on figure 4-8 in P&M.; * While an 8-point DCT cannot be done in less than 11 multiplies, it is; * possible to arrange the computation so that many of the multiplies are; * simple scalings of the final outputs. These multiplies can then be; * folded into the multiplications or divisions by the JPEG quantization; * table entries. The AA&N method leaves only 5 multiplies and 29 adds; * to be done in the DCT itself.; * The primary disadvantage of this method is that with a fixed-point; * implementation, accuracy is lost due to imprecise representation of the; * scaled quantization values. However, that problem does not arise if; * we use floating point arithmetic.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctflt.c:984,reduce,reduced,984,graf2d/asimage/src/libAfterImage/libjpeg/jidctflt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctflt.c,1,['reduce'],['reduced']
Energy Efficiency,"/*; * jidctfst.c; *; * Copyright (C) 1994-1998, Thomas G. Lane.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This file contains a fast, not so accurate integer implementation of the; * inverse DCT (Discrete Cosine Transform). In the IJG code, this routine; * must also perform dequantization of the input coefficients.; *; * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT; * on each row (or vice versa, but it's more convenient to emit a row at; * a time). Direct algorithms are also available, but they are much more; * complex and seem not to be any faster when reduced to code.; *; * This implementation is based on Arai, Agui, and Nakajima's algorithm for; * scaled DCT. Their original paper (Trans. IEICE E-71(11):1095) is in; * Japanese, but the algorithm is described in the Pennebaker & Mitchell; * JPEG textbook (see REFERENCES section in file README). The following code; * is based directly on figure 4-8 in P&M.; * While an 8-point DCT cannot be done in less than 11 multiplies, it is; * possible to arrange the computation so that many of the multiplies are; * simple scalings of the final outputs. These multiplies can then be; * folded into the multiplications or divisions by the JPEG quantization; * table entries. The AA&N method leaves only 5 multiplies and 29 adds; * to be done in the DCT itself.; * The primary disadvantage of this method is that with fixed-point math,; * accuracy is lost due to imprecise representation of the scaled; * quantization values. The smaller the quantization table entry, the less; * precise the scaled value, so this implementation does worse with high-; * quality-setting files than with low-quality ones.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctfst.c:689,reduce,reduced,689,graf2d/asimage/src/libAfterImage/libjpeg/jidctfst.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctfst.c,1,['reduce'],['reduced']
Energy Efficiency,"/*; * jidctint.c; *; * Copyright (C) 1991-1998, Thomas G. Lane.; * Modification developed 2002-2009 by Guido Vollbeding.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This file contains a slow-but-accurate integer implementation of the; * inverse DCT (Discrete Cosine Transform). In the IJG code, this routine; * must also perform dequantization of the input coefficients.; *; * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT; * on each row (or vice versa, but it's more convenient to emit a row at; * a time). Direct algorithms are also available, but they are much more; * complex and seem not to be any faster when reduced to code.; *; * This implementation is based on an algorithm described in; * C. Loeffler, A. Ligtenberg and G. Moschytz, ""Practical Fast 1-D DCT; * Algorithms with 11 Multiplications"", Proc. Int'l. Conf. on Acoustics,; * Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.; * The primary algorithm described there uses 11 multiplies and 29 adds.; * We use their alternate method with 12 multiplies and 32 adds.; * The advantage of this method is that no data path contains more than one; * multiplication; this allows a very simple and accurate implementation in; * scaled fixed-point arithmetic, with a minimal number of shifts.; *; * We also provide IDCT routines with various output sample block sizes for; * direct resolution reduction or enlargement and for direct resolving the; * common 2x1 and 1x2 subsampling cases without additional resampling: NxN; * (N=1...16), 2NxN, and Nx2N (N=1...8) pixels for one 8x8 input DCT block.; *; * For N<8 we simply take the corresponding low-frequency coefficients of; * the 8x8 input DCT block and apply an NxN point IDCT on the sub-block; * to yield the downscaled outputs.; * This can be seen as direct low-pass downsampling from the DCT domain; * point of view rather than the usual spatial dom",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:742,reduce,reduced,742,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['reduce'],['reduced']
Energy Efficiency,"/*; * trees.c by Jean-loup Gailly; *; * This is a new version of im_ctree.c originally written by Richard B. Wales; * for the defunct implosion method.; *; * PURPOSE; *; * Encode various sets of source values using variable-length; * binary code trees.; *; * DISCUSSION; *; * The PKZIP ""deflation"" process uses several Huffman trees. The more; * common source values are represented by shorter bit sequences.; *; * Each code tree is stored in the ZIP file in a compressed form; * which is itself a Huffman encoding of the lengths of; * all the code strings (in ascending order by source values).; * The actual code strings are reconstructed from the lengths in; * the UNZIP process, as described in the ""application note""; * (APPNOTE.TXT) distributed as part of PKWARE's PKZIP program.; *; * REFERENCES; *; * Lynch, Thomas J.; * Data Compression: Techniques and Applications, pp. 53-55.; * Lifetime Learning Publications, 1985. ISBN 0-534-03418-7.; *; * Storer, James A.; * Data Compression: Methods and Theory, pp. 49-50.; * Computer Science Press, 1988. ISBN 0-7167-8156-5.; *; * Sedgewick, R.; * Algorithms, p290.; * Addison-Wesley, 1983. ISBN 0-201-06672-6.; *; * INTERFACE; *; * void ct_init (ush *attr, int *method); * Allocate the match buffer, initialize the various tables and save; * the location of the internal file attribute (ascii/binary) and; * method (DEFLATE/STORE); *; * void ct_tally (int dist, int lc);; * Save the match info and tally the frequency counts.; *; * long flush_block (char *buf, ulg stored_len, int eof); * Determine the best encoding for the current block: dynamic trees,; * static trees or store, and output the encoded block to the zip; * file. Returns the total compressed length for the file so far.; *; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZTrees.c:1225,Allocate,Allocate,1225,core/zip/src/ZTrees.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZTrees.c,1,['Allocate'],['Allocate']
Energy Efficiency,"/*; * vec_mulo and vec_mule are very problematic intrinsics on PowerPC; *; * These intrinsics weren't added until GCC 8, despite existing for a while,; * and they are endian dependent. Also, their meaning swap depending on version.; * */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:63,Power,PowerPC,63,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['Power'],['PowerPC']
Energy Efficiency,"/*; ** visualinfo.c; **; ** Copyright (C) Nate Robins, 1997; ** Michael Wimmer, 1999; ** Milan Ikits, 2002-2008; ** Nigel Stewart, 2008-2013; **; ** visualinfo is a small utility that displays all available visuals,; ** aka. pixelformats, in an OpenGL system along with renderer version; ** information. It shows a table of all the visuals that support OpenGL; ** along with their capabilities. The format of the table is similar to; ** that of glxinfo on Unix systems:; **; ** visual ~= pixel format descriptor; ** id = visual id (integer from 1 - max visuals); ** tp = type (wn: window, pb: pbuffer, wp: window & pbuffer, bm: bitmap); ** ac	 = acceleration (ge: generic, fu: full, no: none); ** fm	 = format (i: integer, f: float, c: color index); ** db	 = double buffer (y = yes); ** sw = swap method (x: exchange, c: copy, u: undefined); ** st	 = stereo (y = yes); ** sz = total # bits; ** r = # bits of red; ** g = # bits of green; ** b = # bits of blue; ** a = # bits of alpha; ** axbf = # aux buffers; ** dpth = # bits of depth; ** stcl = # bits of stencil; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/visualinfo.c:930,green,green,930,builtins/glew/src/visualinfo.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/visualinfo.c,1,['green'],['green']
Energy Efficiency,/*; *----------------------------------------------------------------------; *; * XCreateColormap --; *; *	Allocate a new colormap.; *; * Results:; *	Returns a newly allocated colormap.; *; * Side effects:; *	Allocates an empty palette and color list.; *; *----------------------------------------------------------------------; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c:107,Allocate,Allocate,107,graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c,3,"['Allocate', 'allocate']","['Allocate', 'Allocates', 'allocated']"
Energy Efficiency,"/*; *--------------------------------------------------------------; * gdk_exit; *; * Restores the library to an un-itialized state and exits; * the program using the ""exit"" system call.; *; * Arguments:; * ""errorcode"" is the error value to pass to ""exit"".; *; * Results:; * Allocated structures are freed and the program exits; * cleanly.; *; * Side effects:; *; *--------------------------------------------------------------; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdk.c:275,Allocate,Allocated,275,graf2d/win32gdk/gdk/src/gdk/gdk.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdk.c,1,['Allocate'],['Allocated']
Energy Efficiency,/*; - allocset - allocate a set of characters for []; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c:17,allocate,allocate,17,interpreter/llvm-project/llvm/lib/Support/regcomp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c,1,['allocate'],['allocate']
Energy Efficiency,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any pending; output. deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the; stream state was inconsistent, Z_DATA_ERROR if the stream was freed; prematurely (some input or output was discarded). In the error case, msg; may be set but then points to a static string (which must not be; deallocated).; */; /*; ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));. Initializes the internal stream state for decompression. The fields; next_in, avail_in, zalloc, zfree and opaque must be initialized before by; the caller. If next_in is not Z_NULL and avail_in is large enough (the; exact value depends on the compression method), inflateInit determines the; compression method from the zlib header and allocates all data structures; accordingly; otherwise the allocation will be deferred to the first call of; inflate. If zalloc and zfree are set to Z_NULL, inflateInit updates them to; use default allocation functions. inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller, or Z_STREAM_ERROR if the parameters are; invalid, such as a null pointer to the structure. msg is set to null if; there is no error message. inflateInit does not perform any decompression; apart from possibly reading the zlib header if present: actual decompression; will be done by inflate(). (So next_in and avail_in may be modified, but; next_out and avail_out are unused and unchanged.) The current implementation; of inflateInit() does not process any header information -- that is deferred; until inflate() is called.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:20,allocate,allocated,20,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,2,['allocate'],"['allocated', 'allocates']"
Energy Efficiency,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any pending; output. inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state; was inconsistent. In the error case, msg may be set but then points to a; static string (which must not be deallocated).; */; /* Advanced functions */; /*; The following functions are needed only in some special applications.; */; /*; ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,; int level,; int method,; int windowBits,; int memLevel,; int strategy));. This is another version of deflateInit with more compression options. The; fields next_in, zalloc, zfree and opaque must be initialized before by the; caller. The method parameter is the compression method. It must be Z_DEFLATED in; this version of the library. The windowBits parameter is the base two logarithm of the window size; (the size of the history buffer). It should be in the range 8..15 for this; version of the library. Larger values of this parameter result in better; compression at the expense of memory usage. The default value is 15 if; deflateInit is used instead. windowBits can also be -8..-15 for raw deflate. In this case, -windowBits; determines the window size. deflate() will then generate raw deflate data; with no zlib header or trailer, and will not compute an adler32 check value. windowBits can also be greater than 15 for optional gzip encoding. Add; 16 to windowBits to write a simple gzip header and trailer around the; compressed data instead of a zlib wrapper. The gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:20,allocate,allocated,20,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['allocate'],['allocated']
Energy Efficiency,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any; pending output. deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the; stream state was inconsistent, Z_DATA_ERROR if the stream was freed; prematurely (some input or output was discarded). In the error case,; msg may be set but then points to a static string (which must not be; deallocated).; */; /*; ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));. Initializes the internal stream state for decompression. The fields; next_in, avail_in, zalloc, zfree and opaque must be initialized before by; the caller. If next_in is not Z_NULL and avail_in is large enough (the exact; value depends on the compression method), inflateInit determines the; compression method from the zlib header and allocates all data structures; accordingly; otherwise the allocation will be deferred to the first call of; inflate. If zalloc and zfree are set to Z_NULL, inflateInit updates them to; use default allocation functions. inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller. msg is set to null if there is no error; message. inflateInit does not perform any decompression apart from reading; the zlib header if present: this will be done by inflate(). (So next_in and; avail_in may be modified, but next_out and avail_out are unchanged.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:20,allocate,allocated,20,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,2,['allocate'],"['allocated', 'allocates']"
Energy Efficiency,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any; pending output. inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state; was inconsistent. In the error case, msg may be set but then points to a; static string (which must not be deallocated).; */; /* Advanced functions */; /*; The following functions are needed only in some special applications.; */; /*; ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,; int level,; int method,; int windowBits,; int memLevel,; int strategy));. This is another version of deflateInit with more compression options. The; fields next_in, zalloc, zfree and opaque must be initialized before by; the caller. The method parameter is the compression method. It must be Z_DEFLATED in; this version of the library. The windowBits parameter is the base two logarithm of the window size; (the size of the history buffer). It should be in the range 8..15 for this; version of the library. Larger values of this parameter result in better; compression at the expense of memory usage. The default value is 15 if; deflateInit is used instead. windowBits can also be -8..-15 for raw deflate. In this case, -windowBits; determines the window size. deflate() will then generate raw deflate data; with no zlib header or trailer, and will not compute an adler32 check value. windowBits can also be greater than 15 for optional gzip encoding. Add; 16 to windowBits to write a simple gzip header and trailer around the; compressed data instead of a zlib wrapper. The gzip header will have no; file name, no extra data, no comment, no modification time (set to zero),; no header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but; is slow and",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:20,allocate,allocated,20,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['allocate'],['allocated']
Energy Efficiency,"/*; All memory allocated by inflateBackInit() is freed. inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream; state was inconsistent.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:15,allocate,allocated,15,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,2,['allocate'],['allocated']
Energy Efficiency,"/*; Create and fill in decoding tables. In this loop, the table being; filled is at next and has curr index bits. The code being used is huff; with length len. That code is converted to an index by dropping drop; bits off of the bottom. For codes where len is less than drop + curr,; those top drop + curr - len bits are incremented through all values to; fill the table with replicated entries. root is the number of index bits for the root table. When len exceeds; root, sub-tables are created pointed to by the root entry with an index; of the low root bits of huff. This is saved in low to check for when a; new sub-table should be started. drop is zero when the root table is; being filled, and drop is root when sub-tables are being filled. When a new sub-table is needed, it is necessary to look ahead in the; code lengths to determine what size sub-table is needed. The length; counts are used for this, and so count[] is decremented as codes are; entered in the tables. used keeps track of how many table entries have been allocated from the; provided *table space. It is checked for LENS and DIST tables against; the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in; the initial root table size constants. See the comments in inftrees.h; for more information. sym increments through all symbols, and the loop terminates when; all codes of length max, i.e. all codes, have been processed. This; routine permits incomplete codes, so another loop after this one fills; in the rest of the decoding tables with invalid code markers.; */; /* set up for code type */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inftrees.c:1032,allocate,allocated,1032,builtins/zlib/inftrees.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inftrees.c,1,['allocate'],['allocated']
Energy Efficiency,"/*; Create and fill in decoding tables. In this loop, the table being; filled is at next and has curr index bits. The code being used is huff; with length len. That code is converted to an index by dropping drop; bits off of the bottom. For codes where len is less than drop + curr,; those top drop + curr - len bits are incremented through all values to; fill the table with replicated entries. root is the number of index bits for the root table. When len exceeds; root, sub-tables are created pointed to by the root entry with an index; of the low root bits of huff. This is saved in low to check for when a; new sub-table should be started. drop is zero when the root table is; being filled, and drop is root when sub-tables are being filled. When a new sub-table is needed, it is necessary to look ahead in the; code lengths to determine what size sub-table is needed. The length; counts are used for this, and so count[] is decremented as codes are; entered in the tables. used keeps track of how many table entries have been allocated from the; provided *table space. It is checked when a LENS table is being made; against the space in *table, ENOUGH, minus the maximum space needed by; the worst case distance code, MAXD. This should never happen, but the; sufficiency of ENOUGH has not been proven exhaustively, hence the check.; This assumes that when type == LENS, bits == 9. sym increments through all symbols, and the loop terminates when; all codes of length max, i.e. all codes, have been processed. This; routine permits incomplete codes, so another loop after this one fills; in the rest of the decoding tables with invalid code markers.; */; /* set up for code type */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inftrees.c:1032,allocate,allocated,1032,graf2d/asimage/src/libAfterImage/zlib/inftrees.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inftrees.c,1,['allocate'],['allocated']
Energy Efficiency,"/*; Data set adapted from the paper (1); ""K-Sample Anderson-Darling Tests of Fit for continuous and discrete cases"" by Scholz and Stephens; values of expected A2 taken by running R kSamples code; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/stressGoFTest.cxx:13,adapt,adapted,13,math/mathcore/test/stressGoFTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/stressGoFTest.cxx,1,['adapt'],['adapted']
Energy Efficiency,"/*; Data sets adapted from the paper (1); ""K-Sample Anderson-Darling Tests of Fit for continuous and discrete cases"" by Scholz and Stephens; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/stressGoFTest.cxx:14,adapt,adapted,14,math/mathcore/test/stressGoFTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/stressGoFTest.cxx,1,['adapt'],['adapted']
Energy Efficiency,"/*; Kernel Density Estimation class.; The three main references are. (1) ""Scott DW, Multivariate Density Estimation.Theory, Practice and Visualization. New York: Wiley"",; (2) ""Jann Ben - ETH Zurich, Switzerland -, Univariate kernel density estimation document for KDENS: Stata module for univariate kernel density estimation.""; (3) ""Hardle W, Muller M, Sperlich S, Werwatz A, Nonparametric and Semiparametric Models. Springer.""The algorithm is briefly described in; ""Cranmer KS, Kernel Estimation in High-Energy Physics. Computer Physics Communications 136:198-207,2001"" - e-Print Archive: hep ex/0011057.; A binned version is also implemented to address the performance issue due to its data size dependence.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TKDE.h:505,Energy,Energy,505,hist/hist/inc/TKDE.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TKDE.h,1,['Energy'],['Energy']
Energy Efficiency,"/*; LZ4 HC - High Compression Mode of LZ4; Copyright (C) 2011-2017, Yann Collet. BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php). Redistribution and use in source and binary forms, with or without; modification, are permitted provided that the following conditions are; met:. * Redistributions of source code must retain the above copyright; notice, this list of conditions and the following disclaimer.; * Redistributions in binary form must reproduce the above; copyright notice, this list of conditions and the following disclaimer; in the documentation and/or other materials provided with the; distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR; A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. You can contact the author at :; - LZ4 source repository : https://github.com/lz4/lz4; - LZ4 public forum : https://groups.google.com/forum/#!forum/lz4c; */; /* note : lz4hc is not an independent module, it requires lz4.h/lz4.c for proper compilation */; /* *************************************; * Tuning Parameter; ***************************************/; /*! HEAPMODE :; * Select how default compression function will allocate workplace memory,; * in stack (0:fastest), or in heap (1:requires malloc()).; * Since workplace is rather large, heap mode is recommended.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4hc.c:1826,allocate,allocate,1826,builtins/lz4/lz4hc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4hc.c,1,['allocate'],['allocate']
Energy Efficiency,"/*; Opens a gzip (.gz) file for reading or writing. The mode parameter; is as in fopen (""rb"" or ""wb"") but can also include a compression level; (""wb9"") or a strategy: 'f' for filtered data as in ""wb6f"", 'h' for; Huffman only compression as in ""wb1h"", or 'R' for run-length encoding; as in ""wb1R"". (See the description of deflateInit2 for more information; about the strategy parameter.). gzopen can be used to read a file which is not in gzip format; in this; case gzread will directly read from the file without decompression. gzopen returns NULL if the file could not be opened or if there was; insufficient memory to allocate the (de)compression state; errno; can be checked to distinguish the two cases (if errno is zero, the; zlib error is Z_MEM_ERROR). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:620,allocate,allocate,620,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['allocate'],['allocate']
Energy Efficiency,"/*; Purely notional variadic template describing the layout of a block. template <class _ResultType, class... _ParamTypes, class... _CaptureTypes>; struct Block_literal {; /// Initialized to one of:; /// extern void *_NSConcreteStackBlock[];; /// extern void *_NSConcreteGlobalBlock[];; ///; /// In theory, we could start one off malloc'ed by setting; /// BLOCK_NEEDS_FREE, giving it a refcount of 1, and using; /// this isa:; /// extern void *_NSConcreteMallocBlock[];; struct objc_class *isa;. /// These are the flags (with corresponding bit number) that the; /// compiler is actually supposed to know about.; /// 23. BLOCK_IS_NOESCAPE - indicates that the block is non-escaping; /// 25. BLOCK_HAS_COPY_DISPOSE - indicates that the block; /// descriptor provides copy and dispose helper functions; /// 26. BLOCK_HAS_CXX_OBJ - indicates that there's a captured; /// object with a nontrivial destructor or copy constructor; /// 28. BLOCK_IS_GLOBAL - indicates that the block is allocated; /// as global memory; /// 29. BLOCK_USE_STRET - indicates that the block function; /// uses stret, which objc_msgSend needs to know about; /// 30. BLOCK_HAS_SIGNATURE - indicates that the block has an; /// @encoded signature string; /// And we're not supposed to manipulate these:; /// 24. BLOCK_NEEDS_FREE - indicates that the block has been moved; /// to malloc'ed memory; /// 27. BLOCK_IS_GC - indicates that the block has been moved to; /// to GC-allocated memory; /// Additionally, the bottom 16 bits are a reference count which; /// should be zero on the stack.; int flags;. /// Reserved; should be zero-initialized.; int reserved;. /// Function pointer generated from block literal.; _ResultType (*invoke)(Block_literal *, _ParamTypes...);. /// Block description metadata generated from block literal.; struct Block_descriptor *block_descriptor;. /// Captured values follow.; _CapturesTypes captures...;; };; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:978,allocate,allocated,978,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,2,['allocate'],['allocated']
Energy Efficiency,"/*; Return state with length and distance decoding tables and index sizes set to; fixed code decoding. Normally this returns fixed tables from inffixed.h.; If BUILDFIXED is defined, then instead this routine builds the tables the; first time it's called, and returns those tables the first time and; thereafter. This reduces the size of the code by about 2K bytes, in; exchange for a little execution time. However, BUILDFIXED should not be; used for threaded applications, since the rewriting of the tables and virgin; may not be thread-safe.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/infback.c:317,reduce,reduces,317,builtins/zlib/infback.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/infback.c,4,['reduce'],['reduces']
Energy Efficiency,"/*; Returns true (1) if file is being copied directly while reading, or false; (0) if file is a gzip stream being decompressed. If the input file is empty, gzdirect() will return true, since the input; does not contain a gzip stream. If gzdirect() is used immediately after gzopen() or gzdopen() it will; cause buffers to be allocated to allow reading the file to determine if it; is a gzip file. Therefore if gzbuffer() is used, it should be called before; gzdirect(). When writing, gzdirect() returns true (1) if transparent writing was; requested (""wT"" for the gzopen() mode), or false (0) otherwise. (Note:; gzdirect() is not needed when writing. Transparent writing must be; explicitly requested, so the application already knows the answer. When; linking statically, using gzdirect() will include all of the zlib code for; gzip file reading and decompression, which may not be desired.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:325,allocate,allocated,325,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['allocate'],['allocated']
Energy Efficiency,"/*; Set the internal buffer size used by this library's functions. The; default buffer size is 8192 bytes. This function must be called after; gzopen() or gzdopen(), and before any other calls that read or write the; file. The buffer memory allocation is always deferred to the first read or; write. Two buffers are allocated, either both of the specified size when; writing, or one of the specified size and the other twice that size when; reading. A larger buffer size of, for example, 64K or 128K bytes will; noticeably increase the speed of decompression (reading). The new buffer size also affects the maximum length for gzprintf(). gzbuffer() returns 0 on success, or -1 on failure, such as being called; too late.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:316,allocate,allocated,316,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['allocate'],['allocated']
Energy Efficiency,"/*; TMessage msg(kPROOF_GETOUTPUTLIST);; TList* slaves = fActiveSlaves;; Broadcast(msg, slaves);; TMonitor mon;; TList* outputList = new TList();. TIter si(slaves);; TSlave *slave;; while ((slave = (TSlave*)si.Next()) != 0) {; PDB(kGlobal,4) Info(""GetOutputNames"",""Socket added to monitor: %p (%s)"",; slave->GetSocket(), slave->GetName());; mon.Add(slave->GetSocket());; }; mon.ActivateAll();; ((TProof*)gProof)->DeActivateAsyncInput();; ((TProof*)gProof)->fCurrentMonitor = &mon;. while (mon.GetActive() != 0) {; TSocket *sock = mon.Select();; if (!sock) {; Error(""GetOutputList"",""TMonitor::.Select failed!"");; break;; }; mon.DeActivate(sock);; TMessage *reply;; if (sock->Recv(reply) <= 0) {; MarkBad(slave, ""receive failed after kPROOF_GETOUTPUTLIST request"");; // Error(""GetOutputList"",""Recv failed! for slave-%d (%s)"",; // slave->GetOrdinal(), slave->GetName());; continue;; }; if (reply->What() != kPROOF_GETOUTPUTNAMES ) {; // Error(""GetOutputList"",""unexpected message %d from slawe-%d (%s)"", reply->What(),; // slave->GetOrdinal(), slave->GetName());; MarkBad(slave, ""wrong reply to kPROOF_GETOUTPUTLIST request"");; continue;; }; TList* l;. (*reply) >> l;; TIter next(l);; TNamed *n;; while ( (n = dynamic_cast<TNamed*> (next())) ) {; if (!outputList->FindObject(n->GetName())); outputList->Add(n);; }; delete reply;; }; ((TProof*)gProof)->fCurrentMonitor = 0;. return outputList;; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:281,monitor,monitor,281,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['monitor'],['monitor']
Energy Efficiency,"/*; Test macro for TKDTree. TestBuild(); // test build function of kdTree for memory leaks; TestSpeed(); // test the CPU consumption to build kdTree; TestkdtreeIF(); // test functionality of the kdTree; TestSizeIF(); // test the size of kdtree - search application - Alice TPC tracker situation; //; */; //#include <malloc.h>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/kDTreeTest.cxx:121,consumption,consumption,121,math/mathcore/test/kDTreeTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/kDTreeTest.cxx,1,['consumption'],['consumption']
Energy Efficiency,"/*; The application must update next_in and avail_in when avail_in has dropped; to zero. It must update next_out and avail_out when avail_out has dropped; to zero. The application must initialize zalloc, zfree and opaque before; calling the init function. All other fields are set by the compression; library and must not be updated by the application. The opaque value provided by the application will be passed as the first; parameter for calls of zalloc and zfree. This can be useful for custom; memory management. The compression library attaches no meaning to the; opaque value. zalloc must return Z_NULL if there is not enough memory for the object.; If zlib is used in a multi-threaded application, zalloc and zfree must be; thread safe. On 16-bit systems, the functions zalloc and zfree must be able to allocate; exactly 65536 bytes, but will not be required to allocate more than this if; the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS, pointers; returned by zalloc for objects of exactly 65536 bytes *must* have their; offset normalized to zero. The default allocation function provided by this; library ensures this (see zutil.c). To reduce memory requirements and avoid; any allocation of 64K objects, at the expense of compression ratio, compile; the library with -DMAX_WBITS=14 (see zconf.h). The fields total_in and total_out can be used for statistics or progress; reports. After compression, total_in holds the total size of the; uncompressed data and may be saved for use in the decompressor (particularly; if the decompressor wants to decompress everything in a single step).; */; /* constants */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:811,allocate,allocate,811,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,3,"['allocate', 'reduce']","['allocate', 'reduce']"
Energy Efficiency,"/*; The application must update next_in and avail_in when avail_in has; dropped to zero. It must update next_out and avail_out when avail_out; has dropped to zero. The application must initialize zalloc, zfree and; opaque before calling the init function. All other fields are set by the; compression library and must not be updated by the application. The opaque value provided by the application will be passed as the first; parameter for calls of zalloc and zfree. This can be useful for custom; memory management. The compression library attaches no meaning to the; opaque value. zalloc must return Z_NULL if there is not enough memory for the object.; If zlib is used in a multi-threaded application, zalloc and zfree must be; thread safe. On 16-bit systems, the functions zalloc and zfree must be able to allocate; exactly 65536 bytes, but will not be required to allocate more than this; if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,; pointers returned by zalloc for objects of exactly 65536 bytes *must*; have their offset normalized to zero. The default allocation function; provided by this library ensures this (see zutil.c). To reduce memory; requirements and avoid any allocation of 64K objects, at the expense of; compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h). The fields total_in and total_out can be used for statistics or; progress reports. After compression, total_in holds the total size of; the uncompressed data and may be saved for use in the decompressor; (particularly if the decompressor wants to decompress everything in; a single step).; */; /* constants */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:811,allocate,allocate,811,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,3,"['allocate', 'reduce']","['allocate', 'reduce']"
Energy Efficiency,/*; compressBound() returns an upper bound on the compressed size after; compress() or compress2() on sourceLen bytes. It would be used before a; compress() or compress2() call to allocate the destination buffer.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:180,allocate,allocate,180,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['allocate'],['allocate']
Energy Efficiency,/*; compressBound() returns an upper bound on the compressed size after; compress() or compress2() on sourceLen bytes. It would be used before; a compress() or compress2() call to allocate the destination buffer.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:180,allocate,allocate,180,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['allocate'],['allocate']
Energy Efficiency,"/*; deflateBound() returns an upper bound on the compressed size after; deflation of sourceLen bytes. It must be called after deflateInit() or; deflateInit2(), and after deflateSetHeader(), if used. This would be used; to allocate an output buffer for deflation in a single pass, and so would be; called before deflate(). If that first deflate() call is provided the; sourceLen input bytes, an output buffer allocated to the size returned by; deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed; to return Z_STREAM_END. Note that it is possible for the compressed size to; be larger than the value returned by deflateBound() if flush options other; than Z_FINISH or Z_NO_FLUSH are used.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:222,allocate,allocate,222,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"/*; deflateBound() returns an upper bound on the compressed size after; deflation of sourceLen bytes. It must be called after deflateInit(); or deflateInit2(). This would be used to allocate an output buffer; for deflation in a single pass, and so would be called before deflate().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:182,allocate,allocate,182,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['allocate'],['allocate']
Energy Efficiency,"/*; gzdopen associates a gzFile with the file descriptor fd. File descriptors; are obtained from calls like open, dup, creat, pipe or fileno (if the file; has been previously opened with fopen). The mode parameter is as in gzopen. The next call of gzclose on the returned gzFile will also close the file; descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor; fd. If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,; mode);. The duplicated descriptor should be saved to avoid a leak, since; gzdopen does not close fd if it fails. If you are using fileno() to get the; file descriptor from a FILE *, then you will have to use dup() to avoid; double-close()ing the file descriptor. Both gzclose() and fclose() will; close the associated file descriptor, so they need to have different file; descriptors. gzdopen returns NULL if there was insufficient memory to allocate the; gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not; provided, or '+' was provided), or if fd is -1. The file descriptor is not; used until the next gz* read, write, seek, or close operation, so gzdopen; will not detect if fd is invalid (unless fd is -1).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:899,allocate,allocate,899,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['allocate'],['allocate']
Energy Efficiency,"/*; gzdopen() associates a gzFile with the file descriptor fd. File; descriptors are obtained from calls like open, dup, creat, pipe or; fileno (in the file has been previously opened with fopen).; The mode parameter is as in gzopen.; The next call of gzclose on the returned gzFile will also close the; file descriptor fd, just like fclose(fdopen(fd), mode) closes the file; descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).; gzdopen returns NULL if there was insufficient memory to allocate; the (de)compression state.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:506,allocate,allocate,506,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['allocate'],['allocate']
Energy Efficiency,"/*; inflateBack() does a raw inflate with a single call using a call-back; interface for input and output. This is more efficient than inflate() for; file i/o applications in that it avoids copying between the output and the; sliding window by simply making the window itself the output buffer. This; function trusts the application to not change the output buffer passed by; the output function, at least until inflateBack() returns. inflateBackInit() must be called first to allocate the internal state; and to initialize the state with the user-provided window buffer.; inflateBack() may then be used multiple times to inflate a complete, raw; deflate stream with each call. inflateBackEnd() is then called to free; the allocated state. A raw deflate stream is one with no zlib or gzip header or trailer.; This routine would normally be used in a utility that reads zip or gzip; files and writes out uncompressed files. The utility would decode the; header and process the trailer on its own, hence this routine expects; only the raw deflate stream to decompress. This is different from the; normal behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the uncompressed data buf[0..len-1]. out(); should return zero on success, or non-zero on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:120,efficient,efficient,120,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,3,"['allocate', 'efficient']","['allocate', 'allocated', 'efficient']"
Energy Efficiency,"/*; inflateBack() does a raw inflate with a single call using a call-back; interface for input and output. This is potentially more efficient than; inflate() for file i/o applications, in that it avoids copying between the; output and the sliding window by simply making the window itself the output; buffer. inflate() can be faster on modern CPUs when used with large; buffers. inflateBack() trusts the application to not change the output; buffer passed by the output function, at least until inflateBack() returns. inflateBackInit() must be called first to allocate the internal state; and to initialize the state with the user-provided window buffer.; inflateBack() may then be used multiple times to inflate a complete, raw; deflate stream with each call. inflateBackEnd() is then called to free the; allocated state. A raw deflate stream is one with no zlib or gzip header or trailer.; This routine would normally be used in a utility that reads zip or gzip; files and writes out uncompressed files. The utility would decode the; header and process the trailer on its own, hence this routine expects only; the raw deflate stream to decompress. This is different from the normal; behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the un",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:132,efficient,efficient,132,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,3,"['allocate', 'efficient']","['allocate', 'allocated', 'efficient']"
Energy Efficiency,"/*; inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):; - Using bit fields for code structure; - Different op definition to avoid & for extra bits (do & for table bits); - Three separate decoding do-loops for direct, window, and wnext == 0; - Special case for distance > 1 copies to do overlapped load and store copy; - Explicit branch predictions (based on measured branch probabilities); - Deferring match copy and interspersed it with decoding subsequent codes; - Swapping literal/length else; - Swapping window/direct else; - Larger unrolled copy loops (three is about right); - Moving len -= 3 statement into middle of loop; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inffast.c:57,Power,PowerPC,57,builtins/zlib/inffast.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inffast.c,1,['Power'],['PowerPC']
Energy Efficiency,"/*; inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):; - Using bit fields for code structure; - Different op definition to avoid & for extra bits (do & for table bits); - Three separate decoding do-loops for direct, window, and write == 0; - Special case for distance > 1 copies to do overlapped load and store copy; - Explicit branch predictions (based on measured branch probabilities); - Deferring match copy and interspersed it with decoding subsequent codes; - Swapping literal/length else; - Swapping window/direct else; - Larger unrolled copy loops (three is about right); - Moving len -= 3 statement into middle of loop; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inffast.c:57,Power,PowerPC,57,graf2d/asimage/src/libAfterImage/zlib/inffast.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inffast.c,1,['Power'],['PowerPC']
Energy Efficiency,"/*; strm provides the memory allocation functions and window buffer on input,; and provides information on the unused input on return. For Z_DATA_ERROR; returns, strm will also provide an error message. in() and out() are the call-back input and output functions. When; inflateBack() needs more input, it calls in(). When inflateBack() has; filled the window with output, or when it completes with data in the; window, it calls out() to write out the data. The application must not; change the provided input until in() is called again or inflateBack(); returns. The application must not change the window/output buffer until; inflateBack() returns. in() and out() are called with a descriptor parameter provided in the; inflateBack() call. This parameter can be a structure that provides the; information required to do the read or write, as well as accumulated; information on the input and output such as totals and check values. in() should return zero on failure. out() should return non-zero on; failure. If either in() or out() fails, than inflateBack() returns a; Z_BUF_ERROR. strm->next_in can be checked for Z_NULL to see whether it; was in() or out() that caused in the error. Otherwise, inflateBack(); returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format; error, or Z_MEM_ERROR if it could not allocate memory for the state.; inflateBack() can also return Z_STREAM_ERROR if the input parameters; are not correct, i.e. strm is Z_NULL or the state was not initialized.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/infback.c:1321,allocate,allocate,1321,builtins/zlib/infback.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/infback.c,2,['allocate'],['allocate']
Energy Efficiency,"/*; title = TString::Format( ""(%i) Decision Tree Control Plots (BDT)"", ++ic );; MultiClassActionButton( cbar, ; title,; TString::Format( ""TMVA::BDTControlPlots(\""%s\"")"", fName ),; ""Plots to monitor boosting and pruning of decision trees (macro BDTControlPlots.cxx)"",; buttonType, ""BDT"" );. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx:190,monitor,monitor,190,tmva/tmvagui/src/TMVAMultiClassGui.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx,1,['monitor'],['monitor']
Energy Efficiency,"/*; title = TString::Format( ""(%i) General Boost Control Plots"", ++ic );; MultiClassActionButton( cbar, ; title,; TString::Format( ""TMVA::BoostControlPlots(\""%s\"")"", fName ),; ""Plots to monitor boosting of general classifiers (macro BoostControlPlots.cxx)"",; buttonType, ""Boost"" );; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx:186,monitor,monitor,186,tmva/tmvagui/src/TMVAMultiClassGui.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx,1,['monitor'],['monitor']
Energy Efficiency,"/*= Decompression context; * When decompressing many times,; * it is recommended to allocate a context only once,; * and re-use it for each successive compression operation.; * This will make workload friendlier for system's memory.; * Use one context per thread for parallel execution. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:84,allocate,allocate,84,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['allocate'],['allocate']
Energy Efficiency,"/*===--- ConvertUTF.c - Universal Character Names conversions ---------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===------------------------------------------------------------------------=*/; /*; * Copyright © 1991-2015 Unicode, Inc. All rights reserved.; * Distributed under the Terms of Use in; * http://www.unicode.org/copyright.html.; *; * Permission is hereby granted, free of charge, to any person obtaining; * a copy of the Unicode data files and any associated documentation; * (the ""Data Files"") or Unicode software and any associated documentation; * (the ""Software"") to deal in the Data Files or Software; * without restriction, including without limitation the rights to use,; * copy, modify, merge, publish, distribute, and/or sell copies of; * the Data Files or Software, and to permit persons to whom the Data Files; * or Software are furnished to do so, provided that; * (a) this copyright and permission notice appear with all copies; * of the Data Files or Software,; * (b) this copyright and permission notice appear in associated; * documentation, and; * (c) there is clear notice in each modified Data File or in the Software; * as well as in the documentation associated with the Data File(s) or; * Software that the data or software has been modified.; *; * THE DATA FILES AND SOFTWARE ARE PROVIDED ""AS IS"", WITHOUT WARRANTY OF; * ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE; * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT OF THIRD PARTY RIGHTS.; * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS; * NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL; * DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,; * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER; * TORT",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp:560,charge,charge,560,interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp,1,['charge'],['charge']
Energy Efficiency,"/*===--- ConvertUTF.h - Universal Character Names conversions ---------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *==------------------------------------------------------------------------==*/; /*; * Copyright © 1991-2015 Unicode, Inc. All rights reserved.; * Distributed under the Terms of Use in; * http://www.unicode.org/copyright.html.; *; * Permission is hereby granted, free of charge, to any person obtaining; * a copy of the Unicode data files and any associated documentation; * (the ""Data Files"") or Unicode software and any associated documentation; * (the ""Software"") to deal in the Data Files or Software; * without restriction, including without limitation the rights to use,; * copy, modify, merge, publish, distribute, and/or sell copies of; * the Data Files or Software, and to permit persons to whom the Data Files; * or Software are furnished to do so, provided that; * (a) this copyright and permission notice appear with all copies; * of the Data Files or Software,; * (b) this copyright and permission notice appear in associated; * documentation, and; * (c) there is clear notice in each modified Data File or in the Software; * as well as in the documentation associated with the Data File(s) or; * Software that the data or software has been modified.; *; * THE DATA FILES AND SOFTWARE ARE PROVIDED ""AS IS"", WITHOUT WARRANTY OF; * ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE; * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT OF THIRD PARTY RIGHTS.; * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS; * NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL; * DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,; * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER; * TORT",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h:560,charge,charge,560,interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h,1,['charge'],['charge']
Energy Efficiency,"/*===--- x86gprintrin.h - Implementation of X86 GPR intrinsics on PowerPC --===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86gprintrin.h:66,Power,PowerPC,66,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86gprintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86gprintrin.h,1,['Power'],['PowerPC']
Energy Efficiency,"/*===---- bmiintrin.h - Implementation of BMI intrinsics on PowerPC --------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmiintrin.h:60,Power,PowerPC,60,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmiintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmiintrin.h,1,['Power'],['PowerPC']
Energy Efficiency,"/*===---- bmiintrin.h - Implementation of BMI2 intrinsics on PowerPC -------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:61,Power,PowerPC,61,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,1,['Power'],['PowerPC']
Energy Efficiency,"/*===---- htmintrin.h - Standard header for PowerPC HTM ---------------===*\; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmintrin.h:44,Power,PowerPC,44,interpreter/llvm-project/clang/lib/Headers/htmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmintrin.h,1,['Power'],['PowerPC']
Energy Efficiency,"/*===---- immintrin.h - Implementation of Intel intrinsics on PowerPC ------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/immintrin.h:62,Power,PowerPC,62,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/immintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/immintrin.h,1,['Power'],['PowerPC']
Energy Efficiency,"/*===---- mwaitxintrin.h - MONITORX/MWAITX intrinsics ----------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:27,MONITOR,MONITORX,27,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,1,['MONITOR'],['MONITORX']
Energy Efficiency,"/*===---- nmmintrin.h - Implementation of SSE4 intrinsics on PowerPC -------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h:61,Power,PowerPC,61,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h,1,['Power'],['PowerPC']
Energy Efficiency,"/*===---- pmmintrin.h - Implementation of SSE3 intrinsics on PowerPC -------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:61,Power,PowerPC,61,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,1,['Power'],['PowerPC']
Energy Efficiency,"/*===---- smmintrin.h - Implementation of SSE4 intrinsics on PowerPC -------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. NOTE: This is NOT a complete implementation of the SSE4 intrinsics! */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:61,Power,PowerPC,61,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,1,['Power'],['PowerPC']
Energy Efficiency,"/*===---- tmmintrin.h - Implementation of SSSE3 intrinsics on PowerPC ------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h:62,Power,PowerPC,62,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h,1,['Power'],['PowerPC']
Energy Efficiency,"/*===---- x86intrin.h - Implementation of X86 intrinsics on PowerPC --------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h:60,Power,PowerPC,60,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h,1,['Power'],['PowerPC']
Energy Efficiency,"/*===---- xmmintrin.h - Implementation of SSE intrinsics on PowerPC --------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:60,Power,PowerPC,60,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,1,['Power'],['PowerPC']
Energy Efficiency,"/*===------ avx512vlvp2intersectintrin.h - VL VP2INTERSECT intrinsics ------===; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:127,charge,charge,127,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,1,['charge'],['charge']
Energy Efficiency,"/*===------- avx512vpintersectintrin.h - VP2INTERSECT intrinsics ------------===; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:128,charge,charge,128,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,1,['charge'],['charge']
Energy Efficiency,"/*===--------------- avxvnniintrin.h - VNNI intrinsics --------------------===; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxvnniintrin.h:126,charge,charge,126,interpreter/llvm-project/clang/lib/Headers/avxvnniintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxvnniintrin.h,1,['charge'],['charge']
Energy Efficiency,"/*===----------------- keylockerintrin.h - KL Intrinsics -------------------===; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:124,charge,charge,124,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,1,['charge'],['charge']
Energy Efficiency,"/*LOCAL_DEBUG_OUT( ""indexed color added: 0x%X(%d): #%2.2X%2.2X%2.2X"", indexed, indexed, red, green, blue );*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ascmap.c:93,green,green,93,graf2d/asimage/src/libAfterImage/ascmap.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ascmap.c,1,['green'],['green']
Energy Efficiency,/*allocate*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/THn.h:2,allocate,allocate,2,hist/hist/inc/THn.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/THn.h,9,['allocate'],['allocate']
Energy Efficiency,/*for red/green coefficients*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:10,green,green,10,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['green'],['green']
Energy Efficiency,"/*fprintf( stderr, ""#%2.2X%2.2X%2.2X%2.2X "", imbuf.alpha[i], imbuf.red[i], imbuf.green[i], imbuf.blue[i] );*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/export.c:81,green,green,81,graf2d/asimage/src/libAfterImage/export.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/export.c,1,['green'],['green']
Energy Efficiency,"/*fprintf( stderr, ""#%FFX%2.2X%2.2X%2.2X "", imbuf.red[i], imbuf.green[i], imbuf.blue[i] );*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/export.c:64,green,green,64,graf2d/asimage/src/libAfterImage/export.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/export.c,1,['green'],['green']
Energy Efficiency,/*reduced*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:2,reduce,reduced,2,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['reduce'],['reduced']
Energy Efficiency,// !NDEBUG; //===----------------------------------------------------------------------===//; // GraphWriter support for ScheduleDAGMILive.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:121,Schedul,ScheduleDAGMILive,121,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['Schedul'],['ScheduleDAGMILive']
Energy Efficiency,"// ""N"" is a positive constant that is an exact power of two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:47,power,power,47,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['power'],['power']
Energy Efficiency,"// ""Typed"" pointer that recalls how TClass::New allocated the object.; // It is returned by TClass:NewObject and should be passed to TClass::DeleteArray or TClass::Destructor; // to delete the object.; // It is also used in TVirtualCollectionProxy for the same reasons.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TClass.h:48,allocate,allocated,48,core/meta/inc/TClass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TClass.h,1,['allocate'],['allocated']
Energy Efficiency,"// ""energy""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SimulatedAnnealing.cxx:4,energy,energy,4,tmva/tmva/src/SimulatedAnnealing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SimulatedAnnealing.cxx,1,['energy'],['energy']
Energy Efficiency,"// #pragma 'align' '=' {'native','natural','mac68k','power','reset'}; // #pragma 'options 'align' '=' {'native','natural','mac68k','power','reset'}; // #pragma 'align' '(' {'native','natural','mac68k','power','reset'} ')'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:53,power,power,53,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,3,['power'],['power']
Energy Efficiency,// #pragma options align=power,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:25,power,power,25,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['power'],['power']
Energy Efficiency,"// 'allocClassWithName' allocates an object with the given type.; // The type is actually provided as a string argument (type's name).; // This makes the following pattern possible:; //; // Foo *object = (Foo *)allocClassWithName(""Foo"");; //; // While OSRequiredCast can be used here, it is still not a useful warning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/OSObjectCStyleCast.cpp:24,allocate,allocates,24,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/OSObjectCStyleCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/OSObjectCStyleCast.cpp,1,['allocate'],['allocates']
Energy Efficiency,// (PowerOfTwo >>u B) --> isExact since shifting out the result would make it; // inexact. Similarly for <<.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:4,Power,PowerOfTwo,4,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['Power'],['PowerOfTwo']
Energy Efficiency,"// (X & Y) != 0 --> (X & Y) == Y iff Y is power-of-2.; // Revert part of the simplifySetCCWithAnd combine, to avoid an invert.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:42,power,power-of-,42,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,"// (X > Y) ? X : max(X, Y) --> max(X, Y); // (X >= Y) ? X : max(X, Y) --> max(X, Y); // (X < Y) ? X : min(X, Y) --> min(X, Y); // (X <= Y) ? X : min(X, Y) --> min(X, Y); //; // The equivalence allows a vector select (shuffle) of max/min and Y. Ex:; // (X > Y) ? X : (Z ? max(X, Y) : Y); // If Z is true, this reduces as above, and if Z is false:; // (X > Y) ? X : Y --> max(X, Y)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:309,reduce,reduces,309,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['reduce'],['reduces']
Energy Efficiency,// (X l<< C2) u</u>= C1 iff C1 is power of two -> X & (-C1 l>> C2) ==/!= 0,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:34,power,power,34,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power']
Energy Efficiency,// (X l<< C2) u<=/u> C1 iff C1+1 is power of two -> X & (~C1 l>> C2) ==/!= 0,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:36,power,power,36,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power']
Energy Efficiency,"// (X | C1) & C2 --> (X & C2^(C1&C2)) | (C1&C2); // NOTE: This reduces the number of bits set in the & mask, which; // can expose opportunities for store narrowing for scalars.; // NOTE: SimplifyDemandedBits should have already removed bits from C1; // that aren't set in C2. Meaning we can replace (C1&C2) with C1 in; // above, but this feels safer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:63,reduce,reduces,63,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// (X*Y) * X => (X*X) * Y where Y != X; // The purpose is two-fold:; // 1) to form a power expression (of X).; // 2) potentially shorten the critical path: After transformation, the; // latency of the instruction Y is amortized by the expression of X*X,; // and therefore Y is in a ""less critical"" position compared to what it; // was before the transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:85,power,power,85,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['power'],['power']
Energy Efficiency,// (signmask) >>l X is clearly a power of two if the one is not shifted off; // the bottom. If it is shifted off the bottom then the result is undefined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:33,power,power,33,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['power'],['power']
Energy Efficiency,"// (x << N) & ((x << M) - 1) --> 0, where x is known to be a power of 2 and; // M <= N.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:61,power,power,61,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['power'],['power']
Energy Efficiency,"// (xor X, -C) <u C --> X >u ~C (when C is a power of 2)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:45,power,power,45,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power']
Energy Efficiency,"// (xor X, C) <u C --> X >u ~C (when -C is a power of 2)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:45,power,power,45,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power']
Energy Efficiency,"// (xor X, C) >u C --> X >u C (when C+1 is a power of 2)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:45,power,power,45,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power']
Energy Efficiency,"// (xor X, ~C) >u C --> X <u ~C (when C+1 is a power of 2)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:47,power,power,47,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power']
Energy Efficiency,"// * Power(2,-32)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/MersenneTwisterEngine.cxx:5,Power,Power,5,math/mathcore/src/MersenneTwisterEngine.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/MersenneTwisterEngine.cxx,3,['Power'],['Power']
Energy Efficiency,"// * if Size == 1, it is sufficient to load its origin aligned at 4.; // * if Size == 2, we assume most cases Addr % 2 == 0, so it is sufficient to; // load its origin aligned at 4. If not, although origins may be lost, it; // should not happen very often.; // * if align >= 4, Addr must be aligned to 4, otherwise it is UB. When; // Size % 4 == 0, it is more efficient to load origins without callbacks.; // * Otherwise we use __dfsan_load_label_and_origin.; // This should ensure that common cases run efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:360,efficient,efficient,360,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,2,['efficient'],"['efficient', 'efficiently']"
Energy Efficiency,"// ******************************************************************; // *** PART 3 *** Make adjustments for fit ranges, if specified *; // ******************************************************************; // TODO; // Jonas R.: The following code is commented out, because the functionality; // to mask out-of-range entries with `RooDataHist::cacheValidEntries` has; // been removed from the RooDataHist. If you want to implement ranged fits; // properly, please create a RooDataHist for the requested range with; // `RooDataHist::reduce`.; //// If dataset is binned, activate caching of bins that are invalid because they're outside the; //// updated range definition (WVE need to add virtual interface here); // RooDataHist *tmph = dynamic_cast<RooDataHist *>(data_.get());; // if (tmph) {; // tmph->cacheValidEntries();; //}; // This is deferred from part 2 - but must happen after part 3 - otherwise invalid bins cannot be properly marked in; // cacheValidEntries",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/RooAbsL.cxx:534,reduce,reduce,534,roofit/roofitcore/src/TestStatistics/RooAbsL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/RooAbsL.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// *beginPtr points to the array of item values (allocated in an earlier call by the following malloc())",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:49,allocate,allocated,49,tree/ntuple/v7/src/RField.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx,2,['allocate'],['allocated']
Energy Efficiency,"// +ive Y axis deep green",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx:20,green,green,20,graf3d/gl/src/TGLUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx,1,['green'],['green']
Energy Efficiency,"// - Allocate space to store the integral and compute integral",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:5,Allocate,Allocate,5,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,"// - Allocate temporary space to store the integral and compute integral",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:5,Allocate,Allocate,5,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,"// -- Caller wants us to allocate the STL container, but they will own it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:25,allocate,allocate,25,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,2,['allocate'],['allocate']
Energy Efficiency,"// -- Caller wants us to allocate the clones array, but they will own it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:25,allocate,allocate,25,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,2,['allocate'],['allocate']
Energy Efficiency,"// -- Reallocate.; // Note:; // 1) For a varying length array we do this based on; // an indirect estimator of the size of the value; // buffer since we have no record of how large it; // actually is. If the current length of the; // varying length array is less than it has been; // in the past, then reallocate the value buffer; // to the larger of either the calculated new size; // or the maximum size it has ever been.; //; // 2) The second condition checks if the new value; // buffer size calculated by ResetAddress() is; // smaller than the most we have ever used, and; // if it is, then we increase the new size and; // reallocate.; //; // 3) The third condition is checking to see if we; // have been given a value buffer, if not then; // we must allocate one.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafB.cxx:757,allocate,allocate,757,tree/tree/src/TLeafB.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafB.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// -- The interleave heuristics --; // We interleave the loop in order to expose ILP and reduce the loop overhead.; // There are many micro-architectural considerations that we can't predict; // at this level. For example, frontend pressure (on decode or fetch) due to; // code size, or the number and capabilities of the execution ports.; //; // We use the following heuristics to select the interleave count:; // 1. If the code has reductions, then we interleave to break the cross; // iteration dependency.; // 2. If the loop is really small, then we interleave to reduce the loop; // overhead.; // 3. We don't interleave if we think that we will spill registers to memory; // due to the increased register pressure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:89,reduce,reduce,89,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['reduce'],['reduce']
Energy Efficiency,"// -- We are a top-level branch, allocate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:33,allocate,allocate,33,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// -- We are a top-level branch.; // Idea: Consider making a zero address not allocate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:78,allocate,allocate,78,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// -- We are a varying-length array of objects.; // Note: Polymorphism is not allowed here.; // Allocate a new array of objects to read into.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:96,Allocate,Allocate,96,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,4,['Allocate'],['Allocate']
Energy Efficiency,"// -- We are a varying-length array of pointers to objects.; // Note: The object pointers are allowed to be polymorphic.; // Allocate a new array of pointers to objects to read into.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:125,Allocate,Allocate,125,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,4,['Allocate'],['Allocate']
Energy Efficiency,"// -- We have been given a non-zero address, allocate if necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:45,allocate,allocate,45,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,2,['allocate'],['allocate']
Energy Efficiency,"// -- We have been given a zero address, allocate for top-level only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:41,allocate,allocate,41,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,2,['allocate'],['allocate']
Energy Efficiency,// -- its value is such that the size of the allocated object would; // exceed the implementation-defined limit,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:45,allocate,allocated,45,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// --- Choosing an allocation function ---; // C++ 5.3.4p8 - 14 & 18; // 1) If looking in AFS_Global scope for allocation functions, only look in; // the global scope. Else, if AFS_Class, only look in the scope of the; // allocated class. If AFS_Both, look in both.; // 2) If an array size is given, look for operator new[], else look for; // operator new.; // 3) The first argument is always size_t. Append the arguments from the; // placement form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:222,allocate,allocated,222,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['allocate'],['allocated']
Energy Efficiency,// ------ Manipulations -------------; /**; negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PxPyPzM4D.h:80,energy,energy,80,math/genvector/inc/Math/GenVector/PxPyPzM4D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PxPyPzM4D.h,2,['energy'],['energy']
Energy Efficiency,// ------ Manipulations -------------; /**; negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h:81,energy,energy,81,math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h,2,['energy'],['energy']
Energy Efficiency,"// ------------- Table Sorted by Charge -------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSElementDlg.cxx:33,Charge,Charge,33,test/periodic/XSElementDlg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSElementDlg.cxx,1,['Charge'],['Charge']
Energy Efficiency,"// -----------------------------------------------------------------------------; // AllocMetadataImporterPluginType; // -----------------------------------------------------------------------------; // Utility function that allocates a new instance.; // You can do some initial setup for the importer here if you wish; // like allocating globals etc...; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootsl/main.c:225,allocate,allocates,225,misc/rootsl/main.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootsl/main.c,1,['allocate'],['allocates']
Energy Efficiency,"// -----------------------------------------------------------------------------; // AllocQuickLookGeneratorPluginType; // -----------------------------------------------------------------------------; // Utility function that allocates a new instance.; // You can do some initial setup for the generator here if you wish; // like allocating globals etc...; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/main.c:227,allocate,allocates,227,misc/rootql/main.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/main.c,1,['allocate'],['allocates']
Energy Efficiency,"// -0.0 is used to ignore the start value since it is the neutral value of; // floating point addition. For more information, please refer to; // https://llvm.org/docs/LangRef.html#llvm-vector-reduce-fadd-intrinsic",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:193,reduce,reduce-fadd-intrinsic,193,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,1,['reduce'],['reduce-fadd-intrinsic']
Energy Efficiency,// -A & A = A if A is a power of two or zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:24,power,power,24,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['power'],['power']
Energy Efficiency,"// -ive Y axis light green",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx:21,green,green,21,graf3d/gl/src/TGLUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx,1,['green'],['green']
Energy Efficiency,"// ... and create either the list to merge in one-go at the end; // (more efficient than merging one by one) or, if too big, merge; // these two and start the 'one-by-one' technology",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:74,efficient,efficient,74,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['efficient'],['efficient']
Energy Efficiency,// ... schedule the node...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:7,schedul,schedule,7,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['schedul'],['schedule']
Energy Efficiency,// ...and a similar frame index for the caller-allocated save area; // that will be used to store the incoming registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:47,allocate,allocated,47,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// // @(#)root/hist:$Id$; // Authors: Bartolomeu Rabacal 07/2010; /**********************************************************************; * *; * Copyright (c) 2006 , ROOT MathLib Team *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; * *; **********************************************************************/; /** \class TKDE; \ingroup Hist; Kernel Density Estimation class.; The three main references are:; 1. ""Scott DW, Multivariate Density Estimation. Theory, Practice and Visualization. New York: Wiley"",; 2. ""Jann Ben - ETH Zurich, Switzerland -, Univariate kernel density estimation document for KDENS:; Stata module for univariate kernel density estimation.""; 3. ""Hardle W, Muller M, Sperlich S, Werwatz A, Nonparametric and Semiparametric Models. Springer.""; 4. ""Cranmer KS, Kernel Estimation in High-Energy; Physics. Computer Physics Communications 136:198-207,2001"" - e-Print Archive: hep ex/0011057. The algorithm is briefly described in (4). A binned version is also implemented to address the; performance issue due to its data size dependance.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:884,Energy,Energy,884,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['Energy'],['Energy']
Energy Efficiency,"// // re-implement this since is more efficient; // double operator() (const double * x, const double * p) {; // unsigned int n = fX.size();; // unsigned int npar = fParams.size();; // unsigned j = 0;; // return (*fFunc)( fX);; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedParamFunction.h:38,efficient,efficient,38,math/mathcore/inc/Math/WrappedParamFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedParamFunction.h,1,['efficient'],['efficient']
Energy Efficiency,"// // type of integration; // enum Type { NONADAPTIVE, ADAPTIVE, ADAPTIVESINGULAR } ;; /**; enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type; @ingroup Integration; */; // Gauss KronRod Adaptive rule",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/IntegrationTypes.h:55,ADAPT,ADAPTIVE,55,math/mathmore/inc/Math/IntegrationTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/IntegrationTypes.h,4,"['ADAPT', 'Adapt']","['ADAPTIVE', 'ADAPTIVESINGULAR', 'Adaptive']"
Energy Efficiency,"// 0 means the classic and 1 (default) - the adaptive strategy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TPacketizerAdaptive.h:45,adapt,adaptive,45,proof/proofplayer/inc/TPacketizerAdaptive.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TPacketizerAdaptive.h,2,['adapt'],['adaptive']
Energy Efficiency,"// 0x42: sub rsp, 0x20 (Allocate shadow space)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:24,Allocate,Allocate,24,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// 1 / TMath::Power(2 * TMath::Pi(), .5) * TMath::Exp(-.5). Approximated geometric mean over pointwise data (the KDE function is substituted by the ""real Gaussian"" pdf) and proportional to sigma. Used directly when the mirroring is enabled, otherwise computed from the data; // not sure for this special case for mirror. This results in a much smaller bandwidth for mirror case",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:14,Power,Power,14,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['Power'],['Power']
Energy Efficiency,// 1 << X is clearly a power of two if the one is not shifted off the end. If; // it is shifted off the end then the result is undefined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:23,power,power,23,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['power'],['power']
Energy Efficiency,// 1. The number of elements in the mask must be a power-of-2 and at least 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:51,power,power-of-,51,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['power'],['power-of-']
Energy Efficiency,"// 1. We'll allow it in std::allocator::allocate, and anything which that; // calls.; // 2. HACK 2022-03-28: Work around an issue with libstdc++'s; // <source_location> header. Fixed in GCC 12 and later (2022-04-??).; // We'll allow it in the body of std::source_location::current. GCC's; // implementation had a parameter of type `void*`, and casts from; // that back to `const __impl*` in its body.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:40,allocate,allocate,40,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// 128 Mb; ////////////////////////////////////////////////////////////////////////////////; /// Return limit for maximal allocated memory for single parameter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/mysql/src/TMySQLStatement.cxx:122,allocate,allocated,122,sql/mysql/src/TMySQLStatement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/mysql/src/TMySQLStatement.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// 1w; /// The maximum size for the cache directory, in terms of percentage of the; /// available space on the disk. Set to 100 to indicate no limit, 50 to; /// indicate that the cache size will not be left over half the available disk; /// space. A value over 100 will be reduced to 100. A value of 0 disables the; /// percentage size-based pruning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h:273,reduce,reduced,273,interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,1,['reduce'],['reduced']
Energy Efficiency,"// 2 = 2**0 + 1; // 3 = 2**1 + 1; // 4 = 2**1 + 2; // 5 = 2**2 + 1; // 6 = 2**2 + 2; // 7 = 2**2 + 3; // 8 = 2**2 + 4; //3.; // allocate space for boundaries",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TKDTree.cxx:128,allocate,allocate,128,math/mathcore/src/TKDTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TKDTree.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// 2. Section 3.3.1, item 1: user input must be a power of 2 for; // Advanced SIMD output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:50,power,power,50,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['power'],['power']
Energy Efficiency,// 2i64 vector logical shifts can efficiently avoid scalarization - do the; // shifts per-lane and then shuffle the partial results back together.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,efficient,efficiently,34,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// 32-bit PowerPC wants to expand i64 shifts itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Power,PowerPC,10,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// 32-bit SVR4 ABI Stack Frame Layout:; // +-----------------------------------+; // +--> | Back chain |; // | +-----------------------------------+; // | | Floating-point register save area |; // | +-----------------------------------+; // | | General register save area |; // | +-----------------------------------+; // | | CR save word |; // | +-----------------------------------+; // | | VRSAVE save word |; // | +-----------------------------------+; // | | Alignment padding |; // | +-----------------------------------+; // | | Vector register save area |; // | +-----------------------------------+; // | | Local variable space |; // | +-----------------------------------+; // | | Parameter list area |; // | +-----------------------------------+; // | | LR save word |; // | +-----------------------------------+; // SP--> +--- | Back chain |; // +-----------------------------------+; //; // Specifications:; // System V Application Binary Interface PowerPC Processor Supplement; // AltiVec Technology Programming Interface Manual,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:962,Power,PowerPC,962,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// 6. Build then branch: where we have reduced values in the master; // thread in each team.; // __kmpc_end_reduce{_nowait}(<gtid>);; // break;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:39,reduce,reduced,39,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['reduce'],['reduced']
Energy Efficiency,// 64-bit PowerPC implementations can support i64 types directly,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Power,PowerPC,10,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// 64-bit PowerPC wants to expand i128 shifts itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,Power,PowerPC,10,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// <copyright file=""Program.cpp"" company=""Microsoft Corporation"">; // Copyright (C) Microsoft Corporation. All rights reserved.; // Licensed under the MIT license.; // </copyright>; // <license>; // The MIT License (MIT); //; // Copyright (C) Microsoft Corporation. All rights reserved.; //; // Permission is hereby granted, free of charge, to any person obtaining; // a copy of this software and associated documentation files (the ""Software""),; // to deal in the Software without restriction, including without limitation the; // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or; // sell copies of the Software, and to permit persons to whom the Software is; // furnished to do so, subject to the following conditions:; //; // The above copyright notice and this permission notice shall be included in; // all copies or substantial portions of the Software.; //; // THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; // SOFTWARE.; // </license>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:333,charge,charge,333,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,1,['charge'],['charge']
Energy Efficiency,"// =============================================================================; // If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),; // and we can't guarantee that the only accesses are loads,; // then add the following instructions to the first basic block:; //; // %temp = alloca %struct.x, align 8; // %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*; // %tv = load %struct.x addrspace(101)* %tempd; // store %struct.x %tv, %struct.x* %temp, align 8; //; // The above code allocates some space in the stack and copies the incoming; // struct from param space to local space.; // Then replace all occurrences of %d by %temp.; //; // In case we know that all users are GEPs or Loads, replace them with the same; // ones in parameter AS, so we can access them using ld.param.; // =============================================================================; // Replaces the \p OldUser instruction with the same in parameter AS.; // Only Load and GEP are supported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:520,allocate,allocates,520,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,1,['allocate'],['allocates']
Energy Efficiency,"// @(#):$Id$; // Author: Andrei Gheata 01/03/11; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TGeoBranchArray; \ingroup Geometry_classes. An array of daughter indices making a geometry path. Can be used to; backup/restore a state. Allocated contiguously in memory. To setup an object of this type, one should use:. ~~~ {.cpp}; TGeoBranchArray *array = new TGeoBranchArray(level);; array->InitFromNavigator(nav); // To initialize from current navigator state; ~~~. The navigator can be updated to reflect this path array: `array->UpdateNavigator();`; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBranchArray.cxx:555,Allocate,Allocated,555,geom/geom/src/TGeoBranchArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBranchArray.cxx,1,['Allocate'],['Allocated']
Energy Efficiency,"// @(#)root/base:$Id$; // Author: Andreas-Joachim Peters 15/05/2006; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TVirtualMonitoring; \ingroup Base. Provides the interface for externel Monitoring; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualMonitoring.cxx:509,Monitor,Monitoring,509,core/base/src/TVirtualMonitoring.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualMonitoring.cxx,1,['Monitor'],['Monitoring']
Energy Efficiency,"// @(#)root/base:$Id$; // Authors: Fons Rademakers, Eddy Offermann Jan 2004; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TMatrixTCramerInv; \ingroup Matrix. TMatrixTCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; ~~~; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k; ~~~. however Cramer algorithm is about 10 (!) times faster; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixTCramerInv.cxx:578,adapt,adapted,578,math/matrix/src/TMatrixTCramerInv.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixTCramerInv.cxx,1,['adapt'],['adapted']
Energy Efficiency,"// @(#)root/base:$Id$; // Authors: Fons Rademakers, Eddy Offermann Oct 2004; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TMatrixTSymCramerInv; \ingroup Matrix. TMatrixTSymCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; ~~~; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k; ~~~. however Cramer algorithm is about 10 (!) times faster; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixTSymCramerInv.cxx:584,adapt,adapted,584,math/matrix/src/TMatrixTSymCramerInv.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixTSymCramerInv.cxx,1,['adapt'],['adapted']
Energy Efficiency,"// @(#)root/base:$Id: 5d6810ad46b864564f576f88aa9b154789d91d48 $; // Author: Valeriy Onuchin & Fons Rademakers 15/10/2000; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TQObject; \ingroup Base. This is the ROOT implementation of the Qt object communication; mechanism (see also http://www.troll.no/qt/metaobjects.html). Signals and slots are used for communication between objects.; When an object has changed in some way that might be interesting; for the outside world, it emits a signal to tell whoever is; listening. All slots that are connected to this signal will be; activated (called). It is even possible to connect a signal; directly to another signal (this will emit the second signal; immediately whenever the first is emitted.) There is no limitation; on the number of slots that can be connected to a signal.; The slots will be activated in the order they were connected; to the signal. This mechanism allows objects to be easily reused,; because the object that emits a signal does not need to know; to which objects the signals are connected.; Together, signals and slots make up a powerfull component; programming mechanism. ### Signals. ~~~ {.cpp}; Destroyed(); ~~~; Signal emitted when object is destroyed.; This signal could be connected to some garbage-collector object. ~~~ {.cpp}; ChangedBy(const char *method_name); ~~~; This signal is emitted when some important data members of; the object were changed. method_name parameter can be used; as an identifier of the modifier method. ~~~ {.cpp}; Message(const char *msg); ~~~. General purpose message signal; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQObject.cxx:1421,power,powerfull,1421,core/base/src/TQObject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQObject.cxx,1,['power'],['powerfull']
Energy Efficiency,"// @(#)root/cont:$Id$; // Author: Fons Rademakers 10/10/95; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TBtree; \ingroup Containers; B-tree class. TBtree inherits from the TSeqCollection ABC. ## B-tree Implementation notes. This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. 1. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; 2. Every LeafNode has at most 2*(Order+1) keys.; 3. An InnerNode with k keys has k+1 sub-trees.; 4. Every InnerNode that is not the root has at least InnerLowWaterMark keys.; 5. Every LeafNode that is not the root has at least LeafLowWaterMark keys.; 6. If the root is a LeafNode, it has at least one key.; 7. If the root is an InnerNode, it has at least one key and two sub-trees.; 8. All LeafNodes are the same distance from the root as all the other; LeafNodes.; 9. For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TBtree.cxx:669,adapt,adapt,669,core/cont/src/TBtree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TBtree.cxx,1,['adapt'],['adapt']
Energy Efficiency,"// @(#)root/cont:$Id$; // Author: Fons Rademakers 12/11/95; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TMap; \ingroup Containers; TMap implements an associative array of (key,value) pairs using a; THashTable for efficient retrieval (therefore TMap does not conserve; the order of the entries). The hash value is calculated; using the value returned by the keys Hash() function and the; key comparison is done via the IsEqual() function.; Both key and value must inherit from TObject.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TMap.cxx:538,efficient,efficient,538,core/cont/src/TMap.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TMap.cxx,1,['efficient'],['efficient']
Energy Efficiency,"// @(#)root/cont:$Id$; // Author: Philippe Canal 05/02/2001; // Feb 5 2001: Creation; // Feb 6 2001: Changed all int to unsigned int.; /** \class TBits; \ingroup Containers; Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TBits.cxx:465,reduce,reduce,465,core/cont/src/TBits.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TBits.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// @(#)root/cont:$Id$; // Author: Rene Brun 11/02/96; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TClonesArray; \ingroup Containers; An array of clone (identical) objects. Memory for the objects; stored in the array is allocated only once in the lifetime of the; clones array. All objects must be of the same class. For the rest; this class has the same properties as TObjArray. To reduce the very large number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):; ~~~ {.cpp}; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);; ...; ...; }; ...; a.Delete();; }; ~~~; One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):; ~~~ {.cpp}; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);; ...; ...; }; ...; a.Delete(); // or a.Clear() or a.Clear(""C""); }; ~~~; To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot.; ~~~ {.cpp}; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear(); // or a.Clear(""C"");; }; ~~~; Note: the only supported way to add objects to a ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx:544,allocate,allocated,544,core/cont/src/TClonesArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx,2,"['allocate', 'reduce']","['allocated', 'reduce']"
Energy Efficiency,"// @(#)root/eg:$Id$; // Author: Pasha Murat 12/02/99; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TParticlePDG; \ingroup eg. Description of the static properties of a particle. The class is typically generated by the TDatabasePDG class.; It is referenced by the dynamic particle class TParticle.; \verbatim; Int_t fPdgCode; // PDG code of the particle; Double_t fMass; // particle mass in GeV; Double_t fCharge; // charge in units of |e|/3; Double_t fLifetime; // proper lifetime in seconds; Double_t fWidth; // total width in GeV; Int_t fParity; // parity; Double_t fSpin; // spin; Double_t fIsospin; // isospin; Double_t fI3; // i3; Int_t fStrangeness; // flavours are defined if i3 != -1; Int_t fCharm; // 1 or -1 for C-particles, 0 for others; Int_t fBeauty;; Int_t fTop;; Int_t fY; // X,Y: quantum numbers for the 4-th generation; Int_t fX;; Int_t fStable; // 1 if stable, 0 otherwise. TObjArray* fDecayList; // array of decay channels. TString fParticleClass; // lepton, meson etc. Int_t fTrackingCode; // G3 tracking code of the particle; TParticlePDG* fAntiParticle; // pointer to antiparticle; \endverbatim; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/src/TParticlePDG.cxx:740,charge,charge,740,montecarlo/eg/src/TParticlePDG.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/src/TParticlePDG.cxx,1,['charge'],['charge']
Energy Efficiency,"// @(#)root/eg:$Id$; // Author: Rene Brun , Federico Carminati 26/04/99; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TParticle; \ingroup eg. Description of the dynamic properties of a particle. A dynamic particle class created by event generators and used during; the propagation in detectors. The static attributes of a TParticle; are described by TParticlePDG. \verbatim; Int_t fPdgCode; // PDG code of the particle; Int_t fStatusCode; // generation status code; Int_t fMother[2]; // Indices of the mother particles; Int_t fDaughter[2]; // Indices of the daughter particles; Float_t fWeight; // particle weight. Double_t fCalcMass; // Calculated mass. Double_t fPx; // x component of momentum; Double_t fPy; // y component of momentum; Double_t fPz; // z component of momentum; Double_t fE; // Energy. Double_t fVx; // x of production vertex; Double_t fVy; // y of production vertex; Double_t fVz; // z of production vertex; Double_t fVt; // t of production vertex. Double_t fPolarTheta; // Polar angle of polarisation; Double_t fPolarPhi; // azymutal angle of polarisation. TParticlePDG* fParticlePDG; //! reference to the particle record in PDG database; \endverbatim; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/src/TParticle.cxx:1121,Energy,Energy,1121,montecarlo/eg/src/TParticle.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/src/TParticle.cxx,1,['Energy'],['Energy']
Energy Efficiency,"// @(#)root/fft:$Id$; // Author: Anna Kreshuk 07/4/2006; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; /// \class TFFTComplex; ///; /// One of the interface classes to the FFTW package, can be used directly; /// or via the TVirtualFFT class. Only the basic interface of FFTW is implemented.; /// Computes complex input/output discrete Fourier transforms (DFT); /// in one or more dimensions. For the detailed information on the computed; /// transforms please refer to the FFTW manual, chapter ""What FFTW really computes"".; ///; /// How to use it:; ///; /// 1. Create an instance of TFFTComplex - this will allocate input and output; /// arrays (unless an in-place transform is specified); /// 2. Run the Init() function with the desired flags and settings; /// 3. Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); /// 4. Run the Transform() function; /// 5. Get the output (via GetPoints(), GetPoint() or GetPointComplex() functions); /// 6. Repeat steps 3)-5) as needed; ///; /// For a transform of the same size, but with different flags or sign, rerun the Init(); /// function and continue with steps 3)-5); ///; /// NOTE:; /// 1. running Init() function will overwrite the input array! Don't set any data; /// before running the Init() function; /// 2. FFTW computes unnormalized transform, so doing a transform followed by; /// its inverse will lead to the original array scaled by the transform size; ///; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fftw/src/TFFTComplex.cxx:1001,allocate,allocate,1001,math/fftw/src/TFFTComplex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fftw/src/TFFTComplex.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// @(#)root/fft:$Id$; // Author: Anna Kreshuk 07/4/2006; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; ///; /// \class TFFTRealComplex; ///; /// One of the interface classes to the FFTW package, can be used directly; /// or via the TVirtualFFT class. Only the basic interface of FFTW is implemented.; ///; /// Computes a real input/complex output discrete Fourier transform in 1 or more; /// dimensions. However, only out-of-place transforms are now supported for transforms; /// in more than 1 dimension. For detailed information about the computed transforms,; /// please refer to the FFTW manual; ///; /// How to use it:; /// 1. Create an instance of TFFTRealComplex - this will allocate input and output; /// arrays (unless an in-place transform is specified); /// 2. Run the Init() function with the desired flags and settings (see function; /// comments for possible kind parameters); /// 3. Set the data (via SetPoints()or SetPoint() functions); /// 4. Run the Transform() function; /// 5. Get the output (via GetPoints() or GetPoint() functions); /// 6. Repeat steps 3)-5) as needed; /// For a transform of the same size, but with different flags,; /// rerun the Init() function and continue with steps 3)-5); ///; /// NOTE:; /// 1. running Init() function will overwrite the input array! Don't set any data; /// before running the Init() function; /// 2. FFTW computes unnormalized transform, so doing a transform followed by; /// its inverse will lead to the original array scaled by the transform size; ///; ///; /////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fftw/src/TFFTRealComplex.cxx:1076,allocate,allocate,1076,math/fftw/src/TFFTRealComplex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fftw/src/TFFTRealComplex.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// @(#)root/foam:$Id$; // Author: S. Jadach <mailto:Stanislaw.jadach@ifj.edu.pl>, P.Sawicki <mailto:Pawel.Sawicki@ifj.edu.pl>; /** \class TFoam. TFoam is the main class of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM. ### FOAM Version 1.02M. \authors; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. ### What is FOAM for?. - Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own method. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; - FOAM generates random points with weight one or with variable weight.; - FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.). ### How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. \image html foam_MapCamel1000.png width=400. FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:; See [full version of FOAM](http://jadach.home.cern.ch/jadach/Foam/Index.html). ### Simple example of the use of FOAM:. Begin_Macro(source); ../../../tutorials/foam/foam_kanwa.C; End_Macro. ### Canonical nine steering parameters of FOAM. | Name | default | Description |; |----------|----------|--------------------------------------------------------|; | kDim | 0 | Dimension of the integration space. Must be redefined! |; | nCells | 1000 | No of allocated number of cells, |; | nSampl | 200 | No. of MC events in the cell ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:815,efficient,efficient,815,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,2,"['adapt', 'efficient']","['adaptive', 'efficient']"
Energy Efficiency,"// @(#)root/g3d:$Id$; // Author: Ping Yeh 19/12/97; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class THelix; \ingroup g3d; THelix has two different constructors. If a particle with charge q passes through a point (x,y,z); with momentum (px,py,pz) with magnetic field B along an axis (nx,ny,nz),; this helix can be constructed like:. ~~~ {.cpp}; THelix p(x,y,z, px,py,pz, q*B, nx,ny,nz);; (nx,ny,nz) defaults to (0,0,1).; ~~~. A helix in its own frame can be defined with a pivotal point; (x0,y0,z0), the velocity at that point (vx0,vy0,vz0), and; an angular frequency w. Combining vx0 and vy0 to a transverse; velocity vt0 one can parametrize the helix as:. ~~~ {.cpp}; x(t) = x0 - vt0 / w * sin(-w * t + phi0); y(t) = y0 + vt0 / w * cos(-w * t + phi0); z(t) = z0 + vz0 * t; ~~~. The second constructor has 6 parameters,. Example:. ~~~ {.cpp}; THelix pl1(xyz, v, w, range, rtype, axis);; ~~~. where:. - xyz : array of initial position; - v : array of initial velocity; - w : angular frequency; - range: helix range; - rtype: kHelixZ specifies allowed drawing range in helix Z direction, i.e., along B field.; kLabZ specifies drawing range in lab frame.; kHelixX, kHelixY, kLabX, kLabY, kUnchanged ... etc can also be specified; - axis : helix axis. Example constructing a helix with several default values and drawing it:. Begin_Macro(source); {; TCanvas* helix_example_c1 = new TCanvas(""helix_example_c1"");; TView *view = TView::CreateView(1);; view->SetRange(-1,-1,-1,1,1,1);; THelix *helix = new THelix(0., 0., 0., 1., 0., 0.3, 10.);; helix->Draw();; }; End_Macro. This initializes a helix with its axis in Z direction (rtype=kHelixZ).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/THelix.cxx:501,charge,charge,501,graf3d/g3d/src/THelix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/THelix.cxx,1,['charge'],['charge']
Energy Efficiency,"// @(#)root/geom:$Id$; // Author: Andrei Gheata 28/04/04; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TGeoHelix; \ingroup Shapes_classes. Class representing a helix curve. A helix is a curve defined by the following equations:. ~~~ {.cpp}; x = (1/c) * COS(q*phi); y = (1/c) * SIN(q*phi); z = s * alfa; ~~~. where:. ~~~ {.cpp}; c = 1/Rxy - curvature in XY plane; phi - phi angle; S = 2*PI*s - vertical separation between helix loops; q = +/- 1 - (+)=left-handed, (-)=right-handed; ~~~. In particular, a helix describes the trajectory of a charged particle in magnetic; field. In such case, the helix is right-handed for negative particle charge.; To define a helix, one must define:; - the curvature - positive defined; - the Z step made after one full turn of the helix; - the particle charge sign; - the initial particle position and direction (force normalization to unit); - the magnetic field direction. A helix provides:; - propagation to a given Z position (in global frame); Double_t *point = TGeoHelix::PropagateToZ(Double_t z);; - propagation to an arbitrary plane, returning also the new point; - propagation in a geometry until the next crossed surface; - computation of the total track length along a helix; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoHelix.cxx:863,charge,charged,863,geom/geom/src/TGeoHelix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoHelix.cxx,3,['charge'],"['charge', 'charged']"
Energy Efficiency,"// @(#)root/gpad:$Id$; // Author: Nenad Buncic 20/02/96; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TControlBarButton; \ingroup gpad; This class defines the control bar buttons. Created by the TControlBar. Not for general consumption.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TControlBarButton.cxx:548,consumption,consumption,548,graf2d/gpad/src/TControlBarButton.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TControlBarButton.cxx,1,['consumption'],['consumption']
Energy Efficiency,"// @(#)root/gui:$Id$; // Author: Fons Rademakers 05/05/98; /*************************************************************************; * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**************************************************************************. This source is based on Xclass95, a Win95-looking GUI toolkit.; Copyright (C) 1996, 1997 David Barth, Ricky Ralston, Hector Peraza. Xclass95 is free software; you can redistribute it and/or; modify it under the terms of the GNU Library General Public; License as published by the Free Software Foundation; either; version 2 of the License, or (at your option) any later version. **************************************************************************/; /** \class TGTextBuffer; \ingroup guiwidgets. A text buffer is used in several widgets, like TGTextEntry,; TGFileDialog, etc. It is a little wrapper around the powerful; TString class and used for single line texts. For multi line texts; use TGText. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextBuffer.cxx:1110,power,powerful,1110,gui/gui/src/TGTextBuffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextBuffer.cxx,1,['power'],['powerful']
Energy Efficiency,"// @(#)root/hist:$Id$; // Author: Christian Holm Christensen 07/11/2000; /** \class TMultiDimFit; \ingroup Hist. Multidimensional Fits in ROOT.; ## Overview; A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable. An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; <I>least squares</I> fitting procedure applied to a representative; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class <TT>TMultiDimFit</TT> implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package [2].; Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:357,energy,energy,357,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,2,"['charge', 'energy']","['charged', 'energy']"
Energy Efficiency,"// @(#)root/hist:$Id$; // Author: Christian Holm Christensen 1/8/2000; /*************************************************************************; * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TPrincipal; \ingroup Hist; Principal Components Analysis (PCA). The current implementation is based on the LINTRA package from CERNLIB; by R. Brun, H. Hansroul, and J. Kubler.; The class has been implemented by Christian Holm Christensen in August 2000. ## Introduction. In many applications of various fields of research, the treatment of; large amounts of data requires powerful techniques capable of rapid; data reduction and analysis. Usually, the quantities most; conveniently measured by the experimentalist, are not necessarily the; most significant for classification and analysis of the data. It is; then useful to have a way of selecting an optimal set of variables; necessary for the recognition process and reducing the dimensionality; of the problem, resulting in an easier classification procedure. This paper describes the implementation of one such method of; feature selection, namely the principal components analysis. This; multidimensional technique is well known in the field of pattern; recognition and and its use in Particle Physics has been documented; elsewhere (cf. H. Wind, <I>Function Parameterization</I>, CERN; 72-21). ## Overview; Suppose we have prototypes which are trajectories of particles,; passing through a spectrometer. If one measures the passage of the; particle at say 8 fixed planes, the trajectory is described by an; 8-component vector:; \f[; \mathbf{x} = \left(x_0, x_1, \ldots, x_7\right); \f]; in 8-dimensional pattern space. One proceeds by generating a representative tracks sample and; building up the covaria",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:812,power,powerful,812,hist/hist/src/TPrincipal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx,1,['power'],['powerful']
Energy Efficiency,"// @(#)root/hist:$Id$; // Author: Christian Stratowa 30/09/2001; /*************************************************************************; * Copyright (C) 2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /******************************************************************************; * Copyright(c) 2001-2006, Dr. Christian Stratowa, Vienna, Austria. *; * Author: Christian Stratowa with help from Rene Brun. *; * *; * Algorithms for smooth regression adapted from: *; * R: A Computer Language for Statistical Data Analysis *; * *; ******************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:667,adapt,adapted,667,hist/hist/src/TGraphSmooth.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx,1,['adapt'],['adapted']
Energy Efficiency,"// @(#)root/hist:$Id$; // Author: Christian Stratowa 30/09/2001; /*************************************************************************; * Copyright (C) 2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /******************************************************************************; * Copyright(c) 2001-2006, Dr. Christian Stratowa, Vienna, Austria. *; * Author: Christian Stratowa with help from Rene Brun. *; * *; * Algorithms for smooth regression adapted from: *; * R: A Computer Language for Statistical Data Analysis *; ******************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TGraphSmooth.h:667,adapt,adapted,667,hist/hist/inc/TGraphSmooth.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TGraphSmooth.h,1,['adapt'],['adapted']
Energy Efficiency,// @(#)root/hist:$Id$; // Author: Christophe.Delaere@cern.ch 21/08/2002; ////////////////////////////////////////////////////////////////////////////////; /** \class TConfidenceLevel; \ingroup Hist; \brief Class to compute 95% CL limits; */; //////////////////////////////////////////////////////////////////////////////; /*************************************************************************; * C.Delaere *; * adapted from the mclimit code from Tom Junk *; * see http://cern.ch/thomasj/searchlimits/ecl.html *; *************************************************************************/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TConfidenceLevel.cxx:415,adapt,adapted,415,hist/hist/src/TConfidenceLevel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TConfidenceLevel.cxx,1,['adapt'],['adapted']
Energy Efficiency,"// @(#)root/hist:$Id$; // Author: Christophe.Delaere@cern.ch 21/08/2002; ///////////////////////////////////////////////////////////////////////////; //; // TLimit; //; // Class to compute 95% CL limits; //; // adapted from the mclimit code from Tom Junk (CLs method); // see http://root.cern/root/doc/TomJunk.pdf; // see http://cern.ch/thomasj/searchlimits/ecl.html; // see: Tom Junk,NIM A434, p. 435-443, 1999; //; // see also the following interesting references:; // Alex Read, ""Presentation of search results: the CLs technique""; // Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; // http://www.iop.org/EJ/abstract/0954-3899/28/10/313/; //; // A nice article is also available in the CERN yellow report with the proceeding; // of the 2000 CERN workshop on confidence intervals.; //; // Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; // CERN 2000-005 (30 May 2000); //; ///////////////////////////////////////////////////////////////////////////; /** \class TLimit; \legacy{TLimit, Consider switching to RooStats.}; \ingroup Hist; Algorithm to compute 95% CL limits using the Likelihood ratio semi-bayesian method. Implemented by C. Delaere from the mclimit code written by Tom Junk [HEP-EX/9902006].; See [http://cern.ch/thomasj/searchlimits/ecl.html](http://cern.ch/thomasj/searchlimits/ecl.html) for more details. It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. The class TLimitDataSource takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. The class TConfidenceLevel represents the final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, CLb and ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:211,adapt,adapted,211,hist/hist/src/TLimit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx,1,['adapt'],['adapted']
Energy Efficiency,"// @(#)root/histpainter:$Id$; // Author: Rene Brun, Evgueni Tcherniaev, Olivier Couet 12/12/94; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /*! \class TPainter3dAlgorithms; \ingroup Histpainter; \brief The Legos and Surfaces painter class. 3D graphics representations package. This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet; and Evgueni Tcherniaev. This class is a subset of the original system. It has been converted to a C++; class by Rene Brun.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:709,adapt,adapted,709,hist/histpainter/src/TPainter3dAlgorithms.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx,1,['adapt'],['adapted']
Energy Efficiency,"// @(#)root/mathcore:$Id$; // Author: Jonas Hahnfeld 11/2020; /*************************************************************************; * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class ROOT::Math::RanluxppEngine; Implementation of the RANLUX++ generator. RANLUX++ is an LCG equivalent of RANLUX using 576 bit numbers. The idea of the generator (such as the initialization method) and the algorithm; for the modulo operation are described in; A. Sibidanov, *A revision of the subtract-with-borrow random numbergenerators*,; *Computer Physics Communications*, 221(2017), 299-303,; preprint https://arxiv.org/pdf/1705.03123.pdf. The code is loosely based on the Assembly implementation by A. Sibidanov; available at https://github.com/sibidanov/ranluxpp/. Compared to the original generator, this implementation contains a fix to ensure; that the modulo operation of the LCG always returns the smallest value congruent; to the modulus (based on notes by M. Lüscher). Also, the generator converts the; LCG state back to RANLUX numbers (implementation based on notes by M. Lüscher).; This avoids a bias in the generated numbers because the upper bits of the LCG; state, that is smaller than the modulus \f$ m = 2^{576} - 2^{240} + 1 \f$ (not; a power of 2!), have a higher probability of being 0 than 1. And finally, this; implementation draws 48 random bits for each generated floating point number; (instead of 52 bits as in the original generator) to maintain the theoretical; properties from understanding the original transition function of RANLUX as a; chaotic dynamical system.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RanluxppEngineImpl.cxx:1486,power,power,1486,math/mathcore/src/RanluxppEngineImpl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RanluxppEngineImpl.cxx,1,['power'],['power']
Energy Efficiency,"// @(#)root/mathcore:$Id$; // Author: M. Slawinska 08/2007; /**********************************************************************; * *; * Copyright (c) 2007 , LCG ROOT MathLib Team *; * *; * *; **********************************************************************/; // Header source file for class AdaptiveIntegratorMultiDim",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h:301,Adapt,AdaptiveIntegratorMultiDim,301,math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,1,['Adapt'],['AdaptiveIntegratorMultiDim']
Energy Efficiency,"// @(#)root/mathmore:$Id$; // Authors: L. Moneta, 08/2007; /**********************************************************************; * *; * Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; * *; * This library is free software; you can redistribute it and/or *; * modify it under the terms of the GNU General Public License *; * as published by the Free Software Foundation; either version 2 *; * of the License, or (at your option) any later version. *; * *; * This library is distributed in the hope that it will be useful, *; * but WITHOUT ANY WARRANTY; without even the implied warranty of *; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU *; * General Public License for more details. *; * *; * You should have received a copy of the GNU General Public License *; * along with this library (see file COPYING); if not, write *; * to the Free Software Foundation, Inc., 59 Temple Place, Suite *; * 330, Boston, MA 02111-1307 USA, or contact the author. *; * *; **********************************************************************/; // Header file for class GSLMultiMinFunctionAdapter; //; // Generic adapter for gsl_multimin_function signature; // usable for any c++ class which defines operator( ); //; // Created by: Lorenzo Moneta at Fri Nov 12 16:58:51 2004; //; // Last update: Fri Nov 12 16:58:51 2004; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMonteFunctionAdapter.h:1125,adapt,adapter,1125,math/mathmore/src/GSLMonteFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMonteFunctionAdapter.h,1,['adapt'],['adapter']
Energy Efficiency,"// @(#)root/mathmore:$Id$; // Authors: L. Moneta, 12/2006; /**********************************************************************; * *; * Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; * *; * This library is free software; you can redistribute it and/or *; * modify it under the terms of the GNU General Public License *; * as published by the Free Software Foundation; either version 2 *; * of the License, or (at your option) any later version. *; * *; * This library is distributed in the hope that it will be useful, *; * but WITHOUT ANY WARRANTY; without even the implied warranty of *; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU *; * General Public License for more details. *; * *; * You should have received a copy of the GNU General Public License *; * along with this library (see file COPYING); if not, write *; * to the Free Software Foundation, Inc., 59 Temple Place, Suite *; * 330, Boston, MA 02111-1307 USA, or contact the author. *; * *; **********************************************************************/; // Header file for class GSLMultiMinFunctionAdapter; //; // Generic adapter for gsl_multimin_function signature; // usable for any c++ class which defines operator( ); //; // Created by: Lorenzo Moneta at Fri Nov 12 16:58:51 2004; //; // Last update: Fri Nov 12 16:58:51 2004; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiMinFunctionAdapter.h:1125,adapt,adapter,1125,math/mathmore/src/GSLMultiMinFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiMinFunctionAdapter.h,1,['adapt'],['adapter']
Energy Efficiency,"// @(#)root/mathmore:$Id$; // Authors: L. Moneta, A. Zsenei 08/2005; /**********************************************************************; * *; * Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; * *; * This library is free software; you can redistribute it and/or *; * modify it under the terms of the GNU General Public License *; * as published by the Free Software Foundation; either version 2 *; * of the License, or (at your option) any later version. *; * *; * This library is distributed in the hope that it will be useful, *; * but WITHOUT ANY WARRANTY; without even the implied warranty of *; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU *; * General Public License for more details. *; * *; * You should have received a copy of the GNU General Public License *; * along with this library (see file COPYING); if not, write *; * to the Free Software Foundation, Inc., 59 Temple Place, Suite *; * 330, Boston, MA 02111-1307 USA, or contact the author. *; * *; **********************************************************************/; // Header file for class GSLFunctionAdapter; //; // Generic adapter for gsl_function signature; // usable for any c++ class which defines operator( ); //; // Created by: Lorenzo Moneta at Fri Nov 12 16:58:51 2004; //; // Last update: Fri Nov 12 16:58:51 2004; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLFunctionAdapter.h:1127,adapt,adapter,1127,math/mathmore/inc/Math/GSLFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLFunctionAdapter.h,1,['adapt'],['adapter']
Energy Efficiency,"// @(#)root/mathmore:$Id$; // Authors: L. Moneta, Dec 2006; /**********************************************************************; * *; * Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; * *; * This library is free software; you can redistribute it and/or *; * modify it under the terms of the GNU General Public License *; * as published by the Free Software Foundation; either version 2 *; * of the License, or (at your option) any later version. *; * *; * This library is distributed in the hope that it will be useful, *; * but WITHOUT ANY WARRANTY; without even the implied warranty of *; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU *; * General Public License for more details. *; * *; * You should have received a copy of the GNU General Public License *; * along with this library (see file COPYING); if not, write *; * to the Free Software Foundation, Inc., 59 Temple Place, Suite *; * 330, Boston, MA 02111-1307 USA, or contact the author. *; * *; **********************************************************************/; // Header file for class GSLMultiMinFunctionAdapter; //; // Generic adapter for gsl_multimin_function signature; // usable for any c++ class which defines operator( ); //; // Created by: Lorenzo Moneta at Fri Nov 12 16:58:51 2004; //; // Last update: Fri Nov 12 16:58:51 2004; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiFitFunctionAdapter.h:1126,adapt,adapter,1126,math/mathmore/src/GSLMultiFitFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiFitFunctionAdapter.h,1,['adapt'],['adapter']
Energy Efficiency,"// @(#)root/mathmore:$Id$; // Authors: L. Moneta, Mar 2011; /**********************************************************************; * *; * Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; * *; * This library is free software; you can redistribute it and/or *; * modify it under the terms of the GNU General Public License *; * as published by the Free Software Foundation; either version 2 *; * of the License, or (at your option) any later version. *; * *; * This library is distributed in the hope that it will be useful, *; * but WITHOUT ANY WARRANTY; without even the implied warranty of *; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU *; * General Public License for more details. *; * *; * You should have received a copy of the GNU General Public License *; * along with this library (see file COPYING); if not, write *; * to the Free Software Foundation, Inc., 59 Temple Place, Suite *; * 330, Boston, MA 02111-1307 USA, or contact the author. *; * *; **********************************************************************/; // Header file for class GSLMultiMinFunctionAdapter; //; // Generic adapter for gsl_multiroot_function signature type; // usable for any array of function pointers; // implementing operator()(const double *x) and (if needed); // Gradient(const double *x, double * g); //; // The class is very similar to GSLMultiFitFunctionAdapter,; // but in that case the array is for function references (or value); //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootFunctionAdapter.h:1126,adapt,adapter,1126,math/mathmore/src/GSLMultiRootFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootFunctionAdapter.h,1,['adapt'],['adapter']
Energy Efficiency,"// @(#)root/matrix:$Id$; // Authors: Fons Rademakers, Eddy Offermann Dec 2003; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TDecompBase; \ingroup Matrix. Decomposition Base class. This class forms the base for all the decompositions methods in the; linear algebra package .; It or its derived classes have installed the methods to solve; equations,invert matrices and calculate determinants while monitoring; the accuracy. Each derived class has always the following methods available:. #### Condition() :; In an iterative scheme the condition number for matrix inversion is; calculated . This number is of interest for estimating the accuracy; of x in the equation Ax=b; For example:; A is a (10x10) Hilbert matrix which looks deceivingly innocent; and simple, A(i,j) = 1/(i+j+1); b(i) = Sum_j A(i,j), so a sum of a row in A. the solution is x(i) = 1. i=0,.,9. However,; ~~~; TMatrixD m....; TVectorD b.....; TDecompLU lu(m); lu.SetTol(1.0e-12); lu.Solve(b); b.Print(); ~~~; gives,. ~~~; {1.000,1.000,1.000,1.000,0.998,1.000,0.993,1.001,0.996,1.000}; ~~~. Looking at the condition number, this is in line with expected the; accuracy . The condition number is 3.957e+12 . As a simple rule of; thumb, a condition number of 1.0e+n means that you lose up to n; digits of accuracy in a solution . Since doubles are stored with 15; digits, we can expect the accuracy to be as small as 3 digits . #### Det(Double_t &d1,Double_t &d2); The determinant is d1*TMath::Power(2.,d2); Expressing the determinant this way makes under/over-flow very; unlikely . #### Decompose(); Here the actually decomposition is performed . One can change the; matrix A after the decomposition constructor h",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompBase.cxx:721,monitor,monitoring,721,math/matrix/src/TDecompBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompBase.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// @(#)root/matrix:$Id$; // Authors: Fons Rademakers, Eddy Offermann Mar 2004; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /*************************************************************************; * Parts of this file are copied from the OOQP distribution and *; * are subject to the following license: *; * *; * COPYRIGHT 2001 UNIVERSITY OF CHICAGO *; * *; * The copyright holder hereby grants you royalty-free rights to use, *; * reproduce, prepare derivative works, and to redistribute this software*; * to others, provided that any changes are clearly documented. This *; * software was authored by: *; * *; * E. MICHAEL GERTZ gertz@mcs.anl.gov *; * Mathematics and Computer Science Division *; * Argonne National Laboratory *; * 9700 S. Cass Avenue *; * Argonne, IL 60439-4844 *; * *; * STEPHEN J. WRIGHT swright@cs.wisc.edu *; * Computer Sciences Department *; * University of Wisconsin *; * 1210 West Dayton Street *; * Madison, WI 53706 FAX: (608)262-9777 *; * *; * Any questions or comments may be directed to one of the authors. *; * *; * ARGONNE NATIONAL LABORATORY (ANL), WITH FACILITIES IN THE STATES OF *; * ILLINOIS AND IDAHO, IS OWNED BY THE UNITED STATES GOVERNMENT, AND *; * OPERATED BY THE UNIVERSITY OF CHICAGO UNDER PROVISION OF A CONTRACT *; * WITH THE DEPARTMENT OF ENERGY. *; *************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpProbDens.cxx:1605,ENERGY,ENERGY,1605,math/quadp/src/TQpProbDens.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpProbDens.cxx,1,['ENERGY'],['ENERGY']
Energy Efficiency,"// @(#)root/net:$Id$; // Author: Fons Rademakers 09/01/97; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////////; // //; // TMonitor //; // //; // This class monitors activity on a number of network sockets. //; // The actual monitoring is done by TSystem::DispatchOneEvent(). //; // Typical usage: create a TMonitor object. Register a number of //; // TSocket objects and call TMonitor::Select(). Select() returns the //; // socket object which has data waiting. TSocket objects can be added, //; // removed, (temporary) enabled or disabled. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMonitor.cxx:537,monitor,monitors,537,net/net/src/TMonitor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMonitor.cxx,2,['monitor'],"['monitoring', 'monitors']"
Energy Efficiency,"// @(#)root/physics:$Id$; // Author: Pasha Murat , Peter Malzacher 12/02/99; // Oct 8 1999: changed Warning to Error and; // return fX in Double_t & operator(); // Oct 20 1999: ditto in Double_t operator(); // Jan 25 2000: implemented as (fP,fE) instead of (fX,fY,fZ,fE); /** \class TLorentzVector; \ingroup Physics. \attention \parblock; TLorentzVector is a legacy class.; It is slower and worse for serialization than the recommended superior alternative ROOT::Math::LorentzVector.; ROOT provides specialisations of the ROOT::Math::LorentzVector template which; offer superior runtime performance, i.e.:; - ROOT::Math::PtEtaPhiMVector based on pt (rho),eta,phi and M (t) coordinates in double precision; - ROOT::Math::PtEtaPhiEVector based on pt (rho),eta,phi and E (t) coordinates in double precision; - ROOT::Math::PxPyPzMVector based on px,py,pz and M (mass) coordinates in double precision; - ROOT::Math::PxPyPzEVector based on px,py,pz and E (energy) coordinates in double precision; - ROOT::Math::XYZTVector based on x,y,z,t coordinates (cartesian) in double precision (same as PxPyPzEVector); - ROOT::Math::XYZTVectorF based on x,y,z,t coordinates (cartesian) in float precision (same as PxPyPzEVector but float). More details can be found in the documentation of the @ref GenVector package.; \endparblock. ### Description; TLorentzVector is a general four-vector class, which can be used; either for the description of position and time (x,y,z,t) or momentum and; energy (px,py,pz,E). ### Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable.; By default all components are initialized by zero. ~~~ {.cpp}; TLorentzVector v1; // initialized by (0., 0., 0., 0.); TLorentzVector v2(1., 1., 1., 1.);; TLorentzVector v3(v1);; TLorentzVector v4(TVector3(1., 2., 3.),4.);; ~~~. For backward compatibility there are two constructors from an Double_t; and Float_t C array. ### Access to the components; There are two sets of access functions to the components",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TLorentzVector.cxx:950,energy,energy,950,math/physics/src/TLorentzVector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TLorentzVector.cxx,1,['energy'],['energy']
Energy Efficiency,"// @(#)root/physics:$Id$; // Author: Rene Brun , Valerio Filippini 06/09/2000; /** \class TGenPhaseSpace; \legacy{TGenPhaseSpace, No alternative classes are currently available.}; \ingroup Physics. Utility class to generate n-body event,; with constant cross-section (default); or with Fermi energy dependence (opt=""Fermi"").; The event is generated in the center-of-mass frame,; but the decay products are finally boosted; using the betas of the original particle. The code is based on the GENBOD function (W515 from CERNLIB); using the Raubold and Lynch method; F. James, Monte Carlo Phase Space, CERN 68-15 (1968). see example of use in PhaseSpace.C. Note that Momentum, Energy units are Gev/C, GeV; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TGenPhaseSpace.cxx:292,energy,energy,292,math/physics/src/TGenPhaseSpace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TGenPhaseSpace.cxx,2,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,"// @(#)root/proof:$Id$; // Author: G Ganis Sep 2005; /*************************************************************************; * Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TProofQueryResult; \ingroup proofkernel. TQueryResult version adapted to PROOF neeeds. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofQueryResult.cxx:484,adapt,adapted,484,proof/proof/src/TProofQueryResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofQueryResult.cxx,1,['adapt'],['adapted']
Energy Efficiency,"// @(#)root/proof:$Id$; // Author: G. Ganis, Nov 2005; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TProofMgr; \ingroup proofkernel. The PROOF manager interacts with the PROOF server coordinator to; create or destroy a PROOF session, attach to or detach from; existing one, and to monitor any client activity on the cluster.; At most one manager instance per server is allowed. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofMgr.cxx:605,monitor,monitor,605,proof/proof/src/TProofMgr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofMgr.cxx,1,['monitor'],['monitor']
Energy Efficiency,"// @(#)root/proofplayer:$Id$; // Author: G.Ganis July 2011; /*************************************************************************; * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TProofMonSender; \ingroup proofkernel. Provides the interface for PROOF monitoring to different writers.; Allows to decouple the information sent from the backend. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofMonSender.cxx:501,monitor,monitoring,501,proof/proofplayer/src/TProofMonSender.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofMonSender.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// @(#)root/proofplayer:$Id$; // Author: Maarten Ballintijn 7/06/2004; /*************************************************************************; * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TStatus; \ingroup proofkernel. This class holds the status of an ongoing operation and collects; error messages. It provides a Merge() operation allowing it to; be used in PROOF to monitor status in the slaves.; No messages indicates success. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TStatus.cxx:621,monitor,monitor,621,proof/proofplayer/src/TStatus.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TStatus.cxx,1,['monitor'],['monitor']
Energy Efficiency,"// @(#)root/quadp:$Id$; // Author: Eddy Offermann May 2004; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /*************************************************************************; * Parts of this file are copied from the OOQP distribution and *; * are subject to the following license: *; * *; * COPYRIGHT 2001 UNIVERSITY OF CHICAGO *; * *; * The copyright holder hereby grants you royalty-free rights to use, *; * reproduce, prepare derivative works, and to redistribute this software*; * to others, provided that any changes are clearly documented. This *; * software was authored by: *; * *; * E. MICHAEL GERTZ gertz@mcs.anl.gov *; * Mathematics and Computer Science Division *; * Argonne National Laboratory *; * 9700 S. Cass Avenue *; * Argonne, IL 60439-4844 *; * *; * STEPHEN J. WRIGHT swright@cs.wisc.edu *; * Computer Sciences Department *; * University of Wisconsin *; * 1210 West Dayton Street *; * Madison, WI 53706 FAX: (608)262-9777 *; * *; * Any questions or comments may be directed to one of the authors. *; * *; * ARGONNE NATIONAL LABORATORY (ANL), WITH FACILITIES IN THE STATES OF *; * ILLINOIS AND IDAHO, IS OWNED BY THE UNITED STATES GOVERNMENT, AND *; * OPERATED BY THE UNIVERSITY OF CHICAGO UNDER PROVISION OF A CONTRACT *; * WITH THE DEPARTMENT OF ENERGY. *; *************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/inc/TGondzioSolver.h:1586,ENERGY,ENERGY,1586,math/quadp/inc/TGondzioSolver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/inc/TGondzioSolver.h,19,['ENERGY'],['ENERGY']
Energy Efficiency,"// @(#)root/quadp:$Id$; // Author: Eddy Offermann May 2004; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /*************************************************************************; * Parts of this file are copied from the OOQP distribution and *; * are subject to the following license: *; * *; * COPYRIGHT 2001 UNIVERSITY OF CHICAGO *; * *; * The copyright holder hereby grants you royalty-free rights to use, *; * reproduce, prepare derivative works, and to redistribute this software*; * to others, provided that any changes are clearly documented. This *; * software was authored by: *; * *; * E. MICHAEL GERTZ gertz@mcs.anl.gov *; * Mathematics and Computer Science Division *; * Argonne National Laboratory *; * 9700 S. Cass Avenue *; * Argonne, IL 60439-4844 *; * *; * STEPHEN J. WRIGHT swright@cs.wisc.edu *; * Computer Sciences Department *; * University of Wisconsin *; * 1210 West Dayton Street *; * Madison, WI 53706 FAX: (608)262-9777 *; * *; * Any questions or comments may be directed to one of the authors. *; * *; * ARGONNE NATIONAL LABORATORY (ANL), WITH FACILITIES IN THE STATES OF *; * ILLINOIS AND IDAHO, IS OWNED BY THE UNITED STATES GOVERNMENT, AND *; * OPERATED BY THE UNIVERSITY OF CHICAGO UNDER PROVISION OF A CONTRACT *; * WITH THE DEPARTMENT OF ENERGY. *; *************************************************************************/; /** \class TQpVar. Class containing the variables for the general QP formulation. In terms of in our abstract problem formulation, these variables are; the vectors x, y, z and s.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpVar.cxx:1586,ENERGY,ENERGY,1586,math/quadp/src/TQpVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpVar.cxx,1,['ENERGY'],['ENERGY']
Energy Efficiency,"// @(#)root/quadp:$Id$; // Author: Eddy Offermann May 2004; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /*************************************************************************; * Parts of this file are copied from the OOQP distribution and *; * are subject to the following license: *; * *; * COPYRIGHT 2001 UNIVERSITY OF CHICAGO *; * *; * The copyright holder hereby grants you royalty-free rights to use, *; * reproduce, prepare derivative works, and to redistribute this software*; * to others, provided that any changes are clearly documented. This *; * software was authored by: *; * *; * E. MICHAEL GERTZ gertz@mcs.anl.gov *; * Mathematics and Computer Science Division *; * Argonne National Laboratory *; * 9700 S. Cass Avenue *; * Argonne, IL 60439-4844 *; * *; * STEPHEN J. WRIGHT swright@cs.wisc.edu *; * Computer Sciences Department *; * University of Wisconsin *; * 1210 West Dayton Street *; * Madison, WI 53706 FAX: (608)262-9777 *; * *; * Any questions or comments may be directed to one of the authors. *; * *; * ARGONNE NATIONAL LABORATORY (ANL), WITH FACILITIES IN THE STATES OF *; * ILLINOIS AND IDAHO, IS OWNED BY THE UNITED STATES GOVERNMENT, AND *; * OPERATED BY THE UNIVERSITY OF CHICAGO UNDER PROVISION OF A CONTRACT *; * WITH THE DEPARTMENT OF ENERGY. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; ///; /// \class TMehrotraSolver; ///; /// Derived class of TQpSolverBase implementing the original Mehrotra; /// predictor-corrector algorithm; ///; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TMehrotraSolver.cxx:1586,ENERGY,ENERGY,1586,math/quadp/src/TMehrotraSolver.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TMehrotraSolver.cxx,1,['ENERGY'],['ENERGY']
Energy Efficiency,"// @(#)root/quadp:$Id$; // Author: Eddy Offermann May 2004; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /*************************************************************************; * Parts of this file are copied from the OOQP distribution and *; * are subject to the following license: *; * *; * COPYRIGHT 2001 UNIVERSITY OF CHICAGO *; * *; * The copyright holder hereby grants you royalty-free rights to use, *; * reproduce, prepare derivative works, and to redistribute this software*; * to others, provided that any changes are clearly documented. This *; * software was authored by: *; * *; * E. MICHAEL GERTZ gertz@mcs.anl.gov *; * Mathematics and Computer Science Division *; * Argonne National Laboratory *; * 9700 S. Cass Avenue *; * Argonne, IL 60439-4844 *; * *; * STEPHEN J. WRIGHT swright@cs.wisc.edu *; * Computer Sciences Department *; * University of Wisconsin *; * 1210 West Dayton Street *; * Madison, WI 53706 FAX: (608)262-9777 *; * *; * Any questions or comments may be directed to one of the authors. *; * *; * ARGONNE NATIONAL LABORATORY (ANL), WITH FACILITIES IN THE STATES OF *; * ILLINOIS AND IDAHO, IS OWNED BY THE UNITED STATES GOVERNMENT, AND *; * OPERATED BY THE UNIVERSITY OF CHICAGO UNDER PROVISION OF A CONTRACT *; * WITH THE DEPARTMENT OF ENERGY. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; ///; /// \class TQpLinSolverBase; ///; /// Implementation of main solver for linear systems; ///; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpLinSolverBase.cxx:1586,ENERGY,ENERGY,1586,math/quadp/src/TQpLinSolverBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpLinSolverBase.cxx,1,['ENERGY'],['ENERGY']
Energy Efficiency,"// @(#)root/quadp:$Id$; // Author: Eddy Offermann May 2004; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /*************************************************************************; * Parts of this file are copied from the OOQP distribution and *; * are subject to the following license: *; * *; * COPYRIGHT 2001 UNIVERSITY OF CHICAGO *; * *; * The copyright holder hereby grants you royalty-free rights to use, *; * reproduce, prepare derivative works, and to redistribute this software*; * to others, provided that any changes are clearly documented. This *; * software was authored by: *; * *; * E. MICHAEL GERTZ gertz@mcs.anl.gov *; * Mathematics and Computer Science Division *; * Argonne National Laboratory *; * 9700 S. Cass Avenue *; * Argonne, IL 60439-4844 *; * *; * STEPHEN J. WRIGHT swright@cs.wisc.edu *; * Computer Sciences Department *; * University of Wisconsin *; * 1210 West Dayton Street *; * Madison, WI 53706 FAX: (608)262-9777 *; * *; * Any questions or comments may be directed to one of the authors. *; * *; * ARGONNE NATIONAL LABORATORY (ANL), WITH FACILITIES IN THE STATES OF *; * ILLINOIS AND IDAHO, IS OWNED BY THE UNITED STATES GOVERNMENT, AND *; * OPERATED BY THE UNIVERSITY OF CHICAGO UNDER PROVISION OF A CONTRACT *; * WITH THE DEPARTMENT OF ENERGY. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; ///; /// \class TQpLinSolverDens; ///; /// Implements the aspects of the solvers for dense general QP; /// formulation that are specific to the dense case.; ///; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpLinSolverDens.cxx:1586,ENERGY,ENERGY,1586,math/quadp/src/TQpLinSolverDens.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpLinSolverDens.cxx,1,['ENERGY'],['ENERGY']
Energy Efficiency,"// @(#)root/quadp:$Id$; // Author: Eddy Offermann May 2004; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /*************************************************************************; * Parts of this file are copied from the OOQP distribution and *; * are subject to the following license: *; * *; * COPYRIGHT 2001 UNIVERSITY OF CHICAGO *; * *; * The copyright holder hereby grants you royalty-free rights to use, *; * reproduce, prepare derivative works, and to redistribute this software*; * to others, provided that any changes are clearly documented. This *; * software was authored by: *; * *; * E. MICHAEL GERTZ gertz@mcs.anl.gov *; * Mathematics and Computer Science Division *; * Argonne National Laboratory *; * 9700 S. Cass Avenue *; * Argonne, IL 60439-4844 *; * *; * STEPHEN J. WRIGHT swright@cs.wisc.edu *; * Computer Sciences Department *; * University of Wisconsin *; * 1210 West Dayton Street *; * Madison, WI 53706 FAX: (608)262-9777 *; * *; * Any questions or comments may be directed to one of the authors. *; * *; * ARGONNE NATIONAL LABORATORY (ANL), WITH FACILITIES IN THE STATES OF *; * ILLINOIS AND IDAHO, IS OWNED BY THE UNITED STATES GOVERNMENT, AND *; * OPERATED BY THE UNIVERSITY OF CHICAGO UNDER PROVISION OF A CONTRACT *; * WITH THE DEPARTMENT OF ENERGY. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; ///; /// \class TQpLinSolverSparse; ///; /// Implements the aspects of the solvers for dense general QP; /// formulation that are specific to the dense case.; ///; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpLinSolverSparse.cxx:1586,ENERGY,ENERGY,1586,math/quadp/src/TQpLinSolverSparse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpLinSolverSparse.cxx,1,['ENERGY'],['ENERGY']
Energy Efficiency,"// @(#)root/roostats:$Id$; // Author: Kyle Cranmer 28/07/2008; /*************************************************************************; * Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; /** \class RooStats::NumberCountingPdfFactory; \ingroup Roostats. A factory for building PDFs and data for a number counting combination.; The factory produces a PDF for N channels with uncorrelated background; uncertainty. Correlations can be added by extending this PDF with additional terms.; The factory relates the signal in each channel to a master signal strength times the; expected signal in each channel. Thus, the final test is performed on the master signal strength.; This yields a more powerful test than letting signal in each channel be independent. The problem has been studied in these references:. - http://arxiv.org/abs/physics/0511028; - http://arxiv.org/abs/physics/0702156; - http://cdsweb.cern.ch/record/1099969?ln=en. One can incorporate uncertainty on the expected signal by adding additional terms.; For the future, perhaps this factory should be extended to include the efficiency terms automatically. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/NumberCountingPdfFactory.cxx:1003,power,powerful,1003,roofit/roostats/src/NumberCountingPdfFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/NumberCountingPdfFactory.cxx,1,['power'],['powerful']
Energy Efficiency,"// @(#)root/roostats:$Id$; // Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke; /*************************************************************************; * Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class RooStats::HypoTestInverterResult; \ingroup Roostats. HypoTestInverterResult class holds the array of hypothesis test results and compute a confidence interval.; Based on the RatioFinder code available in the RooStatsCms package developed by Gregory Schott and Danilo Piparo; Ported and adapted to RooStats by Gregory Schott; Some contributions to this class have been written by Matthias Wolf (error estimation). */; // include header file of this class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverterResult.cxx:756,adapt,adapted,756,roofit/roostats/src/HypoTestInverterResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverterResult.cxx,1,['adapt'],['adapted']
Energy Efficiency,"// @(#)root/roostats:$Id$; // Authors: Kevin Belasco 17/06/2009; // Authors: Kyle Cranmer 17/06/2009; /*************************************************************************; * Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class RooStats::MCMCInterval; \ingroup Roostats. MCMCInterval is a concrete implementation of the RooStats::ConfInterval; interface. It takes as input Markov Chain of data points in the parameter; space generated by Monte Carlo using the Metropolis algorithm. From the Markov; Chain, the confidence interval can be determined in two ways:. #### Using a Kernel-Estimated PDF: (not the default method). A RooNDKeysPdf is constructed from the data set using adaptive kernel width.; With this RooNDKeysPdf F, we then integrate over the most likely domain in the; parameter space (tallest points in the posterior RooNDKeysPdf) until the target; confidence level is reached within an acceptable neighborhood as defined by; SetEpsilon(). More specifically: we calculate the following for different; cutoff values C until we reach the target confidence level: \f$\int_{ F >= C } F; d{normset} \f$.; Important note: this is not the default method because of a bug in constructing; the RooNDKeysPdf from a weighted data set. Configure to use this method by; calling SetUseKeys(true), and the data set will be interpreted without weights. #### Using a binned data set: (the default method). This is the binned analog of the continuous integrative method that uses the; kernel-estimated PDF. The points in the Markov Chain are put into a binned; data set and the interval is then calculated by adding the heights of the bins; in decreasing order until the desired level of confidence has been reached.; Note that this means the actual confidence le",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/MCMCInterval.cxx:920,adapt,adaptive,920,roofit/roostats/src/MCMCInterval.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/MCMCInterval.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// @(#)root/roostats:$Id$; // Authors: Kevin Belasco 17/06/2009; // Authors: Kyle Cranmer 17/06/2009; /*************************************************************************; * Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; /** \class RooStats::PdfProposal; \ingroup Roostats. PdfProposal is a concrete implementation of the ProposalFunction interface.; It proposes points across the parameter space in the distribution of the; given PDF. To make Propose(xPrime, x) dependent on x, configure with; PdfProposal::AddMapping(varToUpdate, valueToUse). For example, suppose we have:. ~~~{.cpp}; // our parameter; RooRealVar p(""p"", ""p"", 5, 0, 10);. // create mean and sigma for gaussian proposal function; RooRealVar meanP(""meanP"", ""meanP"", 0, 10);; RooRealVar sigma(""sigma"", ""sigma"", 1, 0, 5);; RooGaussian pGaussian(""pGaussian"", ""pGaussian"", p, meanP, sigma);. // configure proposal function; PdfProposal pdfProposal(pGaussian);; pdfProposal.AddMapping(meanP, p); // each call of Propose(xPrime, x), meanP in; // the proposal function will be updated to; // the value of p in x. this will center the; // proposal function about x's p when; // proposing for xPrime. // To improve performance, PdfProposal has the ability to cache a specified; // number of proposals. If you don't call this function, the default cache size; // is 1, which can be slow.; pdfProposal.SetCacheSize(desiredCacheSize);; ~~~. PdfProposal currently uses a fixed cache size. Adaptive caching methods are in the works; for future versions.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/PdfProposal.cxx:1763,Adapt,Adaptive,1763,roofit/roostats/src/PdfProposal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/PdfProposal.cxx,1,['Adapt'],['Adaptive']
Energy Efficiency,"// @(#)root/spectrum:$Id$; // Author: Miroslav Morhac 25/09/06; /** \class TSpectrum2Transform; \ingroup Spectrum; \brief Advanced 2-dimensional orthogonal transform functions; \author Miroslav Morhac. \legacy{TSpectrum2Transform, For modeling a spectrum fitting and estimating the background one can use RooFit while for deconvolution and unfolding one can use TUnfold.}. Class to carry out transforms of 2D spectra, its filtering and; enhancement. It allows to calculate classic Fourier, Cosine, Sin,; Hartley, Walsh, Haar transforms as well as mixed transforms (Fourier-; Walsh, Fourier-Haar, Walsh-Haar, Cosine-Walsh, Cosine-Haar, Sin-Walsh; and Sin-Haar). All the transforms are fast. The algorithms in this class have been published in the following; references:. 1. C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform; spectral enhancement techniques for gamma-ray spectroscopy.NIM A353; (1994) 280-284.; 2. Morhac M., Matousek V., New adaptive Cosine-Walsh transform and; its application to nuclear data compression, IEEE Transactions on; Signal Processing 48 (2000) 2693.; 3. Morhac M., Matousek V., Data compression using new fast adaptive; Cosine-Haar transforms, Digital Signal Processing 8 (1998) 63.; 4. Morhac M., Matousek V.: Multidimensional nuclear data compression; using fast adaptive Walsh-Haar transform. Acta Physica Slovaca 51; (2001) 307.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2Transform.cxx:954,adapt,adaptive,954,hist/spectrum/src/TSpectrum2Transform.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2Transform.cxx,3,['adapt'],['adaptive']
Energy Efficiency,"// @(#)root/spectrum:$Id$; // Author: Miroslav Morhac 25/09/06; /** \class TSpectrumFit; \ingroup Spectrum; \brief Advanced 1-dimensional spectra fitting functions; \author Miroslav Morhac. \legacy{TSpectrumFit, For modeling a spectrum fitting and estimating the background one can use RooFit while for deconvolution and unfolding one can use TUnfold.}. Class for fitting 1D spectra using AWMI (algorithm without matrix; inversion) and conjugate gradient algorithms for symmetrical; matrices (Stiefel-Hestens method). AWMI method allows to fit; simultaneously 100s up to 1000s peaks. Stiefel method is very stable,; it converges faster, but is more time consuming. The algorithms in this class have been published in the following; references:; 1. M. Morhac et al.: Efficient fitting algorithms applied to; analysis of coincidence gamma-ray spectra. Computer Physics; Communications, Vol 172/1 (2005) pp. 19-41. 2. M. Morhac et al.: Study of fitting algorithms applied to; simultaneous analysis of large number of peaks in gamma-ray spectra.; Applied Spectroscopy, Vol. 57, No. 7, pp. 753-760, 2003. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrumFit.cxx:766,Efficient,Efficient,766,hist/spectrum/src/TSpectrumFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrumFit.cxx,1,['Efficient'],['Efficient']
Energy Efficiency,"// @(#)root/spectrum:$Id$; // Author: Miroslav Morhac 25/09/06; /** \class TSpectrumTransform; \ingroup Spectrum; \brief Advanced 1-dimensional orthogonal transform functions; \author Miroslav Morhac. \legacy{TSpectrumTransform, For modeling a spectrum fitting and estimating the background one can use RooFit while for deconvolution and unfolding one can use TUnfold.}. Class to carry out transforms of 1D spectra, its filtering and; enhancement. It allows to calculate classic Fourier, Cosine, Sin,; Hartley, Walsh, Haar transforms as well as mixed transforms (Fourier-; Walsh, Fourier-Haar, Walsh-Haar, Cosine-Walsh, Cosine-Haar, Sin-Walsh; and Sin-Haar). All the transforms are fast. The algorithms in this class have been published in the following; references:. 1. C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform; spectral enhancement techniques for gamma-ray spectroscopy.NIM A353(1994) 280-284.; 2. Morhac M., Matousek V., New adaptive Cosine-Walsh transform and; its application to nuclear data compression, IEEE Transactions on; Signal Processing 48 (2000) 2693.; 3. Morhac M., Matousek V., Data compression using new fast adaptive; Cosine-Haar transforms, Digital Signal Processing 8 (1998) 63.; 4. Morhac M., Matousek V.: Multidimensional nuclear data compression; using fast adaptive Walsh-Haar transform. Acta Physica Slovaca 51 (2001) 307.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrumTransform.cxx:950,adapt,adaptive,950,hist/spectrum/src/TSpectrumTransform.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrumTransform.cxx,3,['adapt'],['adaptive']
Energy Efficiency,"// @(#)root/spectrum:$Id$; // Author: Miroslav Morhac 25/09/2006; /** \class TSpectrum2Fit; \ingroup Spectrum; \brief Advanced 2-dimensional spectra fitting functions; \author Miroslav Morhac. \legacy{TSpectrum2Fit, For modeling a spectrum fitting and estimating the background one can use RooFit while for deconvolution and unfolding one can use TUnfold.}. Class for fitting 2D spectra using AWMI (algorithm without matrix; inversion) and conjugate gradient algorithms for symmetrical; matrices (Stiefel-Hestens method). AWMI method allows to fit; simultaneously 100s up to 1000s peaks. Stiefel method is very stable,; it converges faster, but is more time consuming. The algorithms in this class have been published in the following references:. 1. M. Morhac et al.: Efficient fitting algorithms applied to; analysis of coincidence gamma-ray spectra. Computer Physics; Communications, Vol 172/1 (2005) pp. 19-41. 2. M. Morhac et al.: Study of fitting algorithms applied to; simultaneous analysis of large number of peaks in gamma-ray spectra.; Applied Spectroscopy, Vol. 57, No. 7, pp. 753-760, 2003.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2Fit.cxx:769,Efficient,Efficient,769,hist/spectrum/src/TSpectrum2Fit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2Fit.cxx,1,['Efficient'],['Efficient']
Energy Efficiency,"// @(#)root/spectrum:$Id$; // Author: Miroslav Morhac 25/09/2006; /** \class TSpectrum3; \ingroup Spectrum; \brief Advanced 3-dimensional spectra processing functions; \author Miroslav Morhac. \legacy{TSpectrum3, For modeling a spectrum fitting and estimating the background one can use RooFit while for deconvolution and unfolding one can use TUnfold.}. This class contains advanced spectra processing functions. - Three-dimensional background estimation functions; - Three-dimensional smoothing functions; - Three-dimensional deconvolution functions; - Three-dimensional peak search functions. The algorithms in this class have been published in the following; references:. [1] M.Morhac et al.: Background elimination methods for; multidimensional coincidence gamma-ray spectra. Nuclear; Instruments and Methods in Physics Research A 401 (1997) 113-132. [2] M.Morhac et al.: Efficient one- and two-dimensional Gold; deconvolution and its application to gamma-ray spectra; decomposition. Nuclear Instruments and Methods in Physics; Research A 401 (1997) 385-408. [3] M. Morhac et al.: Efficient algorithm of multidimensional; deconvolution and its application to nuclear data processing. Digital; Signal Processing, Vol. 13, No. 1, (2003), 144-171. [4] M.Morhac et al.: Identification of peaks in multidimensional; coincidence gamma-ray spectra. Nuclear Instruments and Methods in; Research Physics A 443(2000), 108-125. These NIM papers are also available as Postscript files from:. - [SpectrumDec.ps.gz](ftp://root.cern/root/SpectrumDec.ps.gz); - [SpectrumSrc.ps.gz](ftp://root.cern/root/SpectrumSrc.ps.gz); - [SpectrumBck.ps.gz](ftp://root.cern/root/SpectrumBck.ps.gz). See also the; [online documentation](https://root.cern/guides/tspectrum-manual) and; [tutorials](https://root.cern/doc/master/group__tutorial__spectrum.html).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum3.cxx:877,Efficient,Efficient,877,hist/spectrum/src/TSpectrum3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum3.cxx,2,['Efficient'],['Efficient']
Energy Efficiency,"// @(#)root/test:$Id$; // Author: Rene Brun 12/09/2006; ///////////////////////////////////////////////////////////////////////////////; //; // R O O T S T R E S S H E P I X G L O B A L B E N C H M A R K; // ===============================================================; //; // HEPiX-HEPNT is an organization comprised of UNIX and Windows support staff; // in the High Energy Physics community.; // One of the HEPIX activities is to gather knowledge about new hardware; // and software and to recommend common solutions (eg Scientific Linux); // see: http://wwwhepix.web.cern.ch/wwwhepix/; //; // This benchmark suite has been implemented following several requests; // from HEPIX members interested by a collection of benchmarks representative; // of typical applications.; //; // stressHepix is a single benchmark inclusing several standard ROOT benchmarks; // with a mixture of CPU intensive tests and I/O tests.; // The output of stressHepix is one single number (the ROOTMARK).; // A Pentium IV 2.8GHz running Linux SLC3 and gcc3.2.3 runs this benchmark; // with a reference at 800 ROOTMARKs.; // To build the executable for this benchmark, do; // cd $ROOTSYS/test; // make; //; // The default configuration of ROOT is enough.; // The output of this benchmark looks like:; //; /// stressHepix; ///; ///; ///Starting stressHepix benchmark (details will be in stressHepix.log); ///Takes 442 CP seconds on a 500 rootmarks machine (IBM Thinkpad centrino 1.4GHz VC++7.1); ///Takes 278 CP seconds on a 800 rootmarks reference machine (P IV 2.8 GHz, SLC3 gcc3.2.3); ///Takes 239 CP seconds on a 924 rootmarks machine (MacBook 2.0GHz gcc4.0.1); ///Takes 209 CP seconds on a 1056 rootmarks machine (MacBook 2.0GHz icc9.1); ///Takes 147 CP seconds on a 1512 rootmarks machine (MacPro 3.0GHz gcc4.0.1); ///Takes 142 CP seconds on a 1550 rootmarks machine (AMD64/280, FC5 gcc4.1); ///Takes 121 CP seconds on a 1828 rootmarks machine (MacPro 3.0GHz icc9.1); ///; ///Running : stressFit Minuit 2000, (takes 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHepix.cxx:371,Energy,Energy,371,test/stressHepix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHepix.cxx,1,['Energy'],['Energy']
Energy Efficiency,"// @(#)root/tmva $Id$; // Author: Tancredi Carli, Dominik Dannheim, Alexander Voigt; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate Data analysis *; * Package: TMVA *; * Class : MethodPDEFoam *; * *; * *; * Description: *; * Implementation (see header for description) *; * *; * Authors (alphabetical): *; * Tancredi Carli - CERN, Switzerland *; * Dominik Dannheim - CERN, Switzerland *; * Alexander Voigt - TU Dresden, Germany *; * Peter Speckmayer - CERN, Switzerland *; * *; * Original author of the TFoam implementation: *; * S. Jadach - Institute of Nuclear Physics, Cracow, Poland *; * *; * Copyright (c) 2008, 2010: *; * CERN, Switzerland *; * MPI-K Heidelberg, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; /*! \class TMVA::MethodPDEFoam; \ingroup TMVA. The PDEFoam method is an extension of the PDERS method, which; divides the multi-dimensional phase space in a finite number of; hyper-rectangles (cells) of constant event density. This ""foam"" of; cells is filled with averaged probability-density information; sampled from a training event sample. For a given number of cells, the binning algorithm adjusts the size; and position of the cells inside the multidimensional phase space; based on a binary-split algorithm, minimizing the variance of the; event density in the cell.; The binned event density information of the final foam is stored in; binary trees, allowing for a fast and memory-efficient; classification of events. The implementation of PDEFoam is based on the Monte-Carlo; integration package TFoam included in the analysis package ROOT.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDEFoam.cxx:1732,efficient,efficient,1732,tmva/tmva/src/MethodPDEFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDEFoam.cxx,1,['efficient'],['efficient']
Energy Efficiency,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Simon Pfreundschuh 06/06/17; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /////////////////////////////////////////////////////////////////////; // Partial specialization of the TDataLoader class to adapt it to //; // the TMatrix class. Also the data transfer is kept simple, since //; // this implementation (being intended as reference and fallback //; // is not optimized for performance. //; /////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference/DataLoader.h:538,adapt,adapt,538,tmva/tmva/inc/TMVA/DNN/Architectures/Reference/DataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference/DataLoader.h,1,['adapt'],['adapt']
Energy Efficiency,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : TTensorDataLoader *; * *; * *; * Description: *; * Specialization of the Tensor Data Loader Class *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; //////////////////////////////////////////////////////////////////////////; // Partial specialization of the TTensorDataLoader class to adapt //; // it to the TMatrix class. Also the data transfer is kept simple, //; // since this implementation (being intended as reference and fallback) //; // is not optimized for performance. //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference/TensorDataLoader.h:1003,adapt,adapt,1003,tmva/tmva/inc/TMVA/DNN/Architectures/Reference/TensorDataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference/TensorDataLoader.h,1,['adapt'],['adapt']
Energy Efficiency,"// @(#)root/tree:$Id$; // Author: Rene Brun 12/01/96; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**; \defgroup tree Tree Library. In order to store columnar datasets, ROOT provides the TTree, TChain,; TNtuple and TNtupleD classes.; The TTree class represents a columnar dataset. Any C++ type can be stored in the; columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; it is demonstrated to scale and it's battle tested. It has been optimized during the years; to reduce dataset sizes on disk and to deliver excellent runtime performance.; It allows to access only part of the columns of the datasets, too.; The TNtuple and TNtupleD classes are specialisations of the TTree class which can; only hold single precision and double precision floating-point numbers respectively;; The TChain is a collection of TTrees, which can be located also in different files. */; /** \class TTree; \ingroup tree. A TTree represents a columnar dataset. Any C++ type can be stored in its columns. A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; represented by the TBranch class.; Behind each branch, buffers are allocated automatically by ROOT.; Such buffers are automatically written to disk or kept in memory until the size stored in the; attribute fMaxVirtualSize is reached.; Variables of one branch are written to the same buffer. A branch buffer is; automatically compressed if the file compression attribute is set (default).; Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one object into; one single I/O buffer or to make ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:816,reduce,reduce,816,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// @(#)root/treeviewer:$Id: c8e226dde2f9b6f39946bfe90cabcb778d63dc4f $; //Author : Andrei Gheata 16/08/00; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TTreeViewer; A graphic user interface designed to handle ROOT trees and to take advantage of; TTree class features. It uses ROOT native GUI widgets adapted for ""drag and drop"" functionality.; in the same session. ### The following capabilities are making the viewer a helpful tool for analysis:. - several trees may be opened in the same session;; - branches and leaves can be easily browsed or scanned;; - fast drawing of branch expressions by double-clicking;; - new variables/selections easy to compose with the built-in editor;; - histograms can be composed by dragging leaves or user-defined expressions; to X, Y and Z axis items;; - the tree entries to be processed can be selected with a double slider;; - selections can be defined and activated by dragging them to the 'Cut' item;; - all expressions can be aliased and aliases can be used in composing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. ### The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, cha",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx:624,adapt,adapted,624,tree/treeviewer/src/TTreeViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx,1,['adapt'],['adapted']
Energy Efficiency,"// @(#)root/xml:$Id: 1bd040ac1c03c58bcad15b5206d602680a831c0a $; // Author: Sergey Linev 10.05.2004; /*************************************************************************; * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //________________________________________________________________________; //; // TXMLEngine class is used to write and read ROOT XML files - TXMLFile.; // It does not conform to complete xml standard and cannot be used; // as parser for arbitrary XML files. For such cases TXMLParser should; // be used. This class was introduced to exclude dependency from; // external libraries (like libxml2) and improve speed / memory consumption.; //; //________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/xml/src/TXMLEngine.cxx:883,consumption,consumption,883,io/xml/src/TXMLEngine.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/xml/src/TXMLEngine.cxx,1,['consumption'],['consumption']
Energy Efficiency,"// @(#)root/xmlparser:$Id$; // Author: Jose Lo 12/1/2005; /*************************************************************************; * Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**; \class TSAXParser; \ingroup IO. TSAXParser is a subclass of TXMLParser, it is a wraper class to; libxml library.; SAX (Simple API for XML) is an event based interface, which doesn't; maintain the DOM tree in memory, in other words, it's much more; efficient for large document.; TSAXParserCallback contains a number of callback routines to the; parser in a xmlSAXHandler structure. The parser will then parse the; document and call the appropriate callback when certain conditions; occur.; */; /*************************************************************************; This source is based on libxml++, a C++ wrapper for the libxml XML; parser library.Copyright (C) 2000 by Ari Johnson. libxml++ are copyright (C) 2000 by Ari Johnson, and are covered by the; GNU Lesser General Public License, which should be included with; libxml++ as the file COPYING.; *************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/xmlparser/src/TSAXParser.cxx:669,efficient,efficient,669,io/xmlparser/src/TSAXParser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/xmlparser/src/TSAXParser.cxx,1,['efficient'],['efficient']
Energy Efficiency,// @llvm.readcyclecounter requires the Performance Monitors extension.; // Default to the 0 expansion on unsupported platforms.; // FIXME: Technically there are older ARM CPUs that have; // implementation-specific ways of obtaining this information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:51,Monitor,Monitors,51,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Monitor'],['Monitors']
Energy Efficiency,"// A (multi-)dword access at an address == 2 (mod 4) will be decomposed by the; // hardware into byte accesses. If you assume all alignments are equally; // probable, it's more efficient on average to use short accesses for this; // case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:177,efficient,efficient,177,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// A COFF string table always starts with a 4 byte size field. Offsets into; // it include this size, so allocate it now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/COFFEmitter.cpp:105,allocate,allocate,105,interpreter/llvm-project/llvm/lib/ObjectYAML/COFFEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/COFFEmitter.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// A PHI node is power of two if all incoming values are power of two, or if; // it is an induction variable where in each step its value is a power of; // two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:17,power,power,17,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,3,['power'],['power']
Energy Efficiency,"// A RUToken is created by the RCU for every instruction dispatched to the; // schedulers. These ""tokens"" are managed by the RCU in its token Queue.; //; // On every cycle ('cycleEvent'), the RCU iterates through the token queue; // looking for any token with its 'Executed' flag set. If a token has that; // flag set, then the instruction has reached the write-back stage and will; // be retired by the RCU.; //; // 'NumSlots' represents the number of entries consumed by the instruction in; // the reorder buffer. Those entries will become available again once the; // instruction is retired.; //; // Note that the size of the reorder buffer is defined by the scheduling; // model via field 'NumMicroOpBufferSize'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RetireControlUnit.h:79,schedul,schedulers,79,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RetireControlUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RetireControlUnit.h,2,['schedul'],"['schedulers', 'scheduling']"
Energy Efficiency,// A RegAlloc pass should call this before allocatePhysRegs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:43,allocate,allocatePhysRegs,43,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,1,['allocate'],['allocatePhysRegs']
Energy Efficiency,// A SUnit is ready to bottom schedule if it has no successors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:30,schedul,schedule,30,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['schedule']
Energy Efficiency,// A SUnit is ready to top schedule if it has no predecessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:27,schedul,schedule,27,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// A SchedModel is needed before any DAG is built while advancing past; // non-scheduled instructions, so it would not always be possible to call; // DAG->getSchedClass(SU).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:79,schedul,scheduled,79,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,1,['schedul'],['scheduled']
Energy Efficiency,"// A Tri-tree based data structure to group probes by inline stack.; // A tree is allocated for a standalone .text section. A fake; // instance is created as the root of a tree.; // A real instance of this class is created for each function, either a; // not inlined function that has code in .text section or an inlined function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCPseudoProbe.h:82,allocate,allocated,82,interpreter/llvm-project/llvm/include/llvm/MC/MCPseudoProbe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCPseudoProbe.h,1,['allocate'],['allocated']
Energy Efficiency,"// A UTF-16 representation of a unicode string contains at most the same; // number of code units as a UTF-8 representation. Allocate that much; // space, plus one for the final null character.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:125,Allocate,Allocate,125,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// A boolean compared to true/false can be reduced in 14 out of the 20; // (10 predicates * 2 constants) possible combinations. The other; // 6 cases require a 'not' of the LHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:43,reduce,reduced,43,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['reduce'],['reduced']
Energy Efficiency,// A bundle member was scheduled as single instruction before and now; // needs to be scheduled as part of the bundle. We just get rid of the; // existing schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:23,schedul,scheduled,23,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,3,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"// A call can access a locally allocated object either because it is passed as; // an argument to the call, or because it has escaped prior to the call.; //; // Make sure the object has not escaped here, and then check that none of the; // call arguments alias the object below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:31,allocate,allocated,31,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['allocate'],['allocated']
Energy Efficiency,// A costly instruction is replaced in this work by N efficient instructions; // The maximum of N is curently 10 and it is for ST4 case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:54,efficient,efficient,54,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,1,['efficient'],['efficient']
Energy Efficiency,// A cracked instruction only fits into schedule if the current; // group is empty.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:40,schedul,schedule,40,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,1,['schedul'],['schedule']
Energy Efficiency,// A default register file is always allocated at index #0. That register file; // is mainly used to count the total number of mappings created by all; // register files at runtime. Users can limit the number of available physical; // registers in register file #0 through the command line flag; // `-register-file-size`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp:37,allocate,allocated,37,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:987,allocate,allocated,987,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,1,['allocate'],['allocated']
Energy Efficiency,"// A general case: Start and End are some values, but the actual; // iteration count may not be available. If it is not, insert; // a computation of it into the preheader.; // If the induction variable bump is not a power of 2, quit.; // Othwerise we'd need a general integer division.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:216,power,power,216,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['power'],['power']
Energy Efficiency,"// A hack... we need to insert the aliasing info in a predictable order for; // lit tests. Would like to have them in a stable order already, ideally the; // same order they get allocated, which might mean an ordered set container",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:178,allocate,allocated,178,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// A helper function that factors ArrayIdx to a product of a stride and a; // constant index, and invokes allocateCandidatesAndFindBasis with the; // factorings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:106,allocate,allocateCandidatesAndFindBasis,106,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,1,['allocate'],['allocateCandidatesAndFindBasis']
Energy Efficiency,// A helper function that scales Idx with ElementSize before invoking; // allocateCandidatesAndFindBasis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:74,allocate,allocateCandidatesAndFindBasis,74,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,1,['allocate'],['allocateCandidatesAndFindBasis']
Energy Efficiency,"// A helper method for computeTotalAllocSize.; // Computes the memory size required to allocate sections with the given sizes,; // assuming that all sections are allocated with the given alignment",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:87,allocate,allocate,87,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// A key point - if we got here, pre-scheduling was able to find a valid; // scheduling of the sub-graph of the scheduling window which consists; // of all vector bundles and their transitive users. As such, we do not; // need to reschedule anything *outside of* that subgraph.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,schedul,scheduling,37,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,3,['schedul'],['scheduling']
Energy Efficiency,"// A list of 8-bit numbers that have at most one run of non-zero bits.; // x = x ^ (mask << 56) can be encoded as a single armv8 instruction for these; // masks.; // The list does not include the value 255, which is used for UAR.; //; // Because we are more likely to use earlier elements of this list than later; // ones, it is sorted in increasing order of probability of collision with a; // mask allocated (temporally) nearby. The program that generated this list; // can be found at:; // https://github.com/google/sanitizers/blob/master/hwaddress-sanitizer/sort_masks.py",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:400,allocate,allocated,400,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// A mask of busy resource units. It defaults to the empty set (i.e. a zero; // mask), and it is cleared at the beginning of every cycle.; // It is updated every time the scheduler fails to issue an instruction from; // the ready set due to unavailable pipeline resources.; // Each bit of the mask represents an unavailable resource.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:171,schedul,scheduler,171,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,1,['schedul'],['scheduler']
Energy Efficiency,"// A pointer to an object in a function which neither frees, nor can arrange; // for another thread to free on its behalf, can not be freed in the scope; // of the function. Note that this logic is restricted to memory; // allocations in existance before the call; a nofree function *is* allowed; // to free memory it allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:318,allocate,allocated,318,interpreter/llvm-project/llvm/lib/IR/Value.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// A pointer union of Stmt * and EvaluatedStmt *. When an EvaluatedStmt, we; // have allocated the auxiliary struct of information there.; //; // TODO: It is a bit unfortunate to use a PointerUnion inside the VarDecl for; // this as *many* VarDecls are ParmVarDecls that don't have default; // arguments. We could save some space by moving this pointer union to be; // allocated in trailing space when necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:85,allocate,allocated,85,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,2,['allocate'],['allocated']
Energy Efficiency,// A power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:5,power,power,5,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['power'],['power']
Energy Efficiency,// A power of 2. If End <= Start range is empty.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:5,power,power,5,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['power'],['power']
Energy Efficiency,// A power of two and'd with anything is a power of two or zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:5,power,power,5,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,2,['power'],['power']
Energy Efficiency,"// A power of two or a constant between 0 and 32. This is used in; // GCC for the shift amount on shifted register operands, but it is; // useful in general for any shift amounts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:5,power,power,5,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['power'],['power']
Energy Efficiency,"// A power-of-2 multiply is just a shift. LEA also cheaply handles multiply by; // 3, 5, or 9 with i32/i64, so those get transformed too.; // TODO: For constants that overflow or do not differ by power-of-2 or small; // multiplier, convert to 'and' + 'add'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:5,power,power-of-,5,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['power'],['power-of-']
Energy Efficiency,"// A runtime call that involves memory offloading looks something like:; // call void @__tgt_target_data_begin_mapper(arg0, arg1,; // i8** %offload_baseptrs, i8** %offload_ptrs, i64* %offload_sizes,; // ...); // So, the idea is to access the allocas that allocate space for these; // offload arrays, offload_baseptrs, offload_ptrs, offload_sizes.; // Therefore:; // i8** %offload_baseptrs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:255,allocate,allocate,255,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['allocate'],['allocate']
Energy Efficiency,// A set of live-in regs for each MBB which is used to update LV; // efficiently also with large functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:69,efficient,efficiently,69,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// A shuffle of a concat of the same narrow vector can be reduced to use; // only low-half elements of a concat with undef:; // shuf (concat X, X), undef, Mask --> shuf (concat X, undef), undef, Mask'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,reduce,reduced,58,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// A special case is a situation where the vector is built entirely from; // elements extracted from another vector. This could be done via a shuffle; // more efficiently, but typically, the size of the source vector will not; // match the size of the vector being built (which precludes the use of a; // shuffle directly).; // This only handles a single source vector, and the vector being built; // should be of a sub-vector type of the source vector type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:159,efficient,efficiently,159,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// A subroutine of MatchRotate used once we have found an OR of two opposite; // shifts of N0 + N1. If Neg == <operand size> - Pos then the OR reduces; // to both (PosOpcode N0, N1, Pos) and (NegOpcode N0, N1, Neg), with the; // former being preferred if supported. InnerPos and InnerNeg are Pos and; // Neg with outer conversions stripped away.; // TODO: Merge with MatchRotatePosNeg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:143,reduce,reduces,143,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// A subroutine of MatchRotate used once we have found an OR of two opposite; // shifts of Shifted. If Neg == <operand size> - Pos then the OR reduces; // to both (PosOpcode Shifted, Pos) and (NegOpcode Shifted, Neg), with the; // former being preferred if supported. InnerPos and InnerNeg are Pos and; // Neg with outer conversions stripped away.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:143,reduce,reduces,143,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reduce'],['reduces']
Energy Efficiency,// A table that maps resource indices to actual processor resource IDs in the; // scheduling model.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:82,schedul,scheduling,82,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['schedul'],['scheduling']
Energy Efficiency,"// A user can appear in a use list multiple times, and when this happens the; // uses are usually next to each other in the list. To help reduce the; // number of CSE and divergence recomputations, process all the uses of this; // user that we can find this way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:138,reduce,reduce,138,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// A user can appear in a use list multiple times, and when this; // happens the uses are usually next to each other in the list.; // To help reduce the number of CSE recomputations, process all; // the uses of this user that we can find this way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:142,reduce,reduce,142,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,3,['reduce'],['reduce']
Energy Efficiency,// A value is not more reduced than itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp:23,reduce,reduced,23,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp,1,['reduce'],['reduced']
Energy Efficiency,// A variant scheduling class may define transitions for multiple; // processors. This function identifies wich processors are associated with; // transition rules specified by variant class `SC`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp:13,schedul,scheduling,13,interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// A zero latency instruction doesn't consume any scheduler resources.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:50,schedul,scheduler,50,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['schedul'],['scheduler']
Energy Efficiency,"// AA might be used later for instruction scheduling, and we need it to be; // able to deduce the correct aliasing releationships between pointers; // derived from the alloca being remapped and the target of that remapping.; // The only safe way, without directly informing AA about the remapping; // somehow, is to directly update the IR to reflect the change being made; // here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:42,schedul,scheduling,42,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// AGPRs to spill VGPRs and vice versa are allocated in a reverse order,; // starting from the last lane. In case if a register cannot be completely; // spilled into another register that will ensure its alignment does not; // change. For targets with VGPR alignment requirement this is important; // in case of flat scratch usage as we might get a scratch_load or; // scratch_store of an unaligned register otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:43,allocate,allocated,43,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,// AIX `power` alignment does not apply the preferred alignment for; // non-union classes if the source of the alignment (the current base in; // this context) follows introduction of the first subobject with; // exclusively allocated space or zero-extent array.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:8,power,power,8,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,2,"['allocate', 'power']","['allocated', 'power']"
Energy Efficiency,"// ARM mode is a bit simpler than Thumb: we can handle large power; // of 2 immediates with 1 mov instruction; no further checks required,; // just return the sdiv node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:61,power,power,61,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['power'],['power']
Energy Efficiency,"// ARMv7k passes structs bigger than 16 bytes indirectly, in space; // allocated by the caller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/ARM.cpp:71,allocate,allocated,71,interpreter/llvm-project/clang/lib/CodeGen/Targets/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/ARM.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// ASTContext::getTypeSize will return the size rounded up to a; // power of 2, so instead of using that, we need to use the raw; // element size multiplied by the element count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:68,power,power,68,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['power'],['power']
Energy Efficiency,// AVX2 has efficient 32/64-bit element cross-lane shuffles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:12,efficient,efficient,12,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// AVX2 has efficient 64-bit element cross-lane shuffles.; // TODO: Refine to account for unary shuffle, splat, and other masks?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:12,efficient,efficient,12,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,// AVX512 has efficient cross-lane shuffles for all legal 512-bit types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:14,efficient,efficient,14,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['efficient'],['efficient']
Energy Efficiency,"// Above we eagerly create divs and rems, as pairs, so that we can efficiently; // create divrem machine instructions. Now erase any unused divs / rems so we; // don't leave extra instructions sitting around.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:67,efficient,efficiently,67,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// Absolute value reduces number of sign bits by at most 1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:18,reduce,reduces,18,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['reduce'],['reduces']
Energy Efficiency,// Abuse object size to record number of WebAssembly locals allocated to; // this object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp:60,allocate,allocated,60,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Accept any mixture of instructions.; // On Power for AIX and Linux, this behaviour matches that of GCC for both the; // user-provided assembler source case and the compiler-produced assembler; // source case. Yet XL with user-provided assembler source would not add this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AIX.cpp:46,Power,Power,46,interpreter/llvm-project/clang/lib/Driver/ToolChains/AIX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AIX.cpp,1,['Power'],['Power']
Energy Efficiency,"// Access to the Processor Version Register (PVR) on PowerPC is privileged,; // and so we must use an operating-system interface to determine the current; // processor type. On Linux, this is exposed through the /proc/cpuinfo file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp:53,Power,PowerPC,53,interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// Accesses sizes are powers of two: 1, 2, 4, 8, 16.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:22,power,powers,22,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,3,['power'],['powers']
Energy Efficiency,"// Accesses sizes are powers of two: 1, 2, 4, 8.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:22,power,powers,22,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['power'],['powers']
Energy Efficiency,"// According to GCC 'Basic PowerPC Built-in Functions Available on ISA 2.05',; // __builtin_(un)pack_longdouble are available only if long double uses IBM; // extended double representation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:27,Power,PowerPC,27,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// According to [dcl.fct.def.coroutine]p9, Lookup allocation functions using a; // parameter list composed of the requested size of the coroutine state being; // allocated, followed by the coroutine function's arguments. If a matching; // allocation function exists, use it. Otherwise, use an allocation function; // that just takes the requested size.; //; // [dcl.fct.def.coroutine]p9; // An implementation may need to allocate additional storage for a; // coroutine.; // This storage is known as the coroutine state and is obtained by calling a; // non-array allocation function ([basic.stc.dynamic.allocation]). The; // allocation function's name is looked up by searching for it in the scope of; // the promise type.; // - If any declarations are found, overload resolution is performed on a; // function call created by assembling an argument list. The first argument is; // the amount of space requested, and has type std::size_t. The; // lvalues p1 ... pn are the succeeding arguments.; //; // ...where ""p1 ... pn"" are defined earlier as:; //; // [dcl.fct.def.coroutine]p3; // The promise type of a coroutine is `std::coroutine_traits<R, P1, ...,; // Pn>`; // , where R is the return type of the function, and `P1, ..., Pn` are the; // sequence of types of the non-object function parameters, preceded by the; // type of the object parameter ([dcl.fct]) if the coroutine is a non-static; // member function. [dcl.fct.def.coroutine]p4 In the following, p_i is an; // lvalue of type P_i, where p1 denotes the object parameter and p_i+1 denotes; // the i-th non-object function parameter for a non-static member function,; // and p_i denotes the i-th function parameter otherwise. For a non-static; // member function, q_1 is an lvalue that denotes *this; any other q_i is an; // lvalue that denotes the parameter copy corresponding to p_i.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:162,allocate,allocated,162,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,// Accumulate the allocated size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:18,allocate,allocated,18,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Activate monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:12,monitor,monitoring,12,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,1,['monitor'],['monitoring']
Energy Efficiency,// Actual scheduling work.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:10,schedul,scheduling,10,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,1,['schedul'],['scheduling']
Energy Efficiency,// Adapt following lines on the current indent level to the same level; // unless the current \c AnnotatedLine is not at the beginning of a line.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:3,Adapt,Adapt,3,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['Adapt'],['Adapt']
Energy Efficiency,"// Adapt the end range, because LocationCompare() reports; // RangeOverlap even for the not-inclusive end location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Adapt,Adapt,3,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['Adapt'],['Adapt']
Energy Efficiency,"// Adapt the start of the token, for example indent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:3,Adapt,Adapt,3,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,2,['Adapt'],['Adapt']
Energy Efficiency,// Adapt to the width of a register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Adapt,Adapt,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Adapt'],['Adapt']
Energy Efficiency,"// Adaptable scheduling; // A small, but very parallel; // region, where reg pressure is an issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp:3,Adapt,Adaptable,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,2,"['Adapt', 'schedul']","['Adaptable', 'scheduling']"
Energy Efficiency,"// Adapted from VisualStudio/VC/crt/src/vcruntime/throw.cpp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/PlatformWin.cpp:3,Adapt,Adapted,3,interpreter/cling/lib/Utils/PlatformWin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/PlatformWin.cpp,1,['Adapt'],['Adapted']
Energy Efficiency,"// Adapted from clang/lib/Frontend/CompilerInvocation.cpp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/Paths.cpp:3,Adapt,Adapted,3,interpreter/cling/lib/Utils/Paths.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/Paths.cpp,1,['Adapt'],['Adapted']
Energy Efficiency,"// Adapted from http://stackoverflow.com/questions/3758606/; // how-to-convert-byte-size-into-human-readable-format-in-java; // and http://agentzlerich.blogspot.com/2011/01/converting-to-and-from-human-readable.html; // However those sources use the 'conventional' 'legacy' nomenclature,; // rather than the official Standard Units. See; // http://physics.nist.gov/cuu/Units/binary.html; // and http://www.dr-lex.be/info-stuff/bytecalc.html for example.; ///////////////////////////////////////////////////////////////////////////////; /// Return the size expressed in 'human readable' format.; /// \param bytes the size in bytes to be converted; /// \param si whether to use the SI units or not.; /// \param coeff return the size expressed in the new unit.; /// \param units return a pointer to the string representation of the new unit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/ROOT/StringConv.hxx:3,Adapt,Adapted,3,core/base/inc/ROOT/StringConv.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/ROOT/StringConv.hxx,1,['Adapt'],['Adapted']
Energy Efficiency,"// Adapted from https://gcc.gnu.org/wiki/Visibility",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Visibility.h:3,Adapt,Adapted,3,interpreter/cling/include/cling/Interpreter/Visibility.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Visibility.h,1,['Adapt'],['Adapted']
Energy Efficiency,"// Adapted from https://github.com/mountainstorm/CoreSymbolication; // Under the hood the framework basically just calls through to a set of C++ libraries",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx:3,Adapt,Adapted,3,core/unix/src/TUnixSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx,1,['Adapt'],['Adapted']
Energy Efficiency,"// Adapted from llvm/Support/Compiler.h",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Visibility.h:3,Adapt,Adapted,3,interpreter/cling/include/cling/Interpreter/Visibility.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Visibility.h,1,['Adapt'],['Adapted']
Energy Efficiency,"// Adapted from utf8++",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/UTF8.cpp:3,Adapt,Adapted,3,interpreter/cling/lib/Utils/UTF8.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/UTF8.cpp,1,['Adapt'],['Adapted']
Energy Efficiency,// Adapter class to llvm::support::endian::Writer for pwrite().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp:3,Adapt,Adapter,3,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp,1,['Adapt'],['Adapter']
Energy Efficiency,"// Adapter for a VecGeom shape",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/vecgeom/inc/TGeoVGShape.h:3,Adapt,Adapter,3,geom/vecgeom/inc/TGeoVGShape.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/vecgeom/inc/TGeoVGShape.h,1,['Adapt'],['Adapter']
Energy Efficiency,"// Adaptive kernel estimation pdf with increased bandwidth scale factor; // (promotes smoothness over detail preservation)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:3,Adapt,Adaptive,3,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['Adapt'],['Adaptive']
Energy Efficiency,// Adapts the external decomposeBitTestICmp for local use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3,Adapt,Adapts,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['Adapt'],['Adapts']
Energy Efficiency,// Add a prefix to allocated sections and their relocation sections. This; // should be done after renaming the section by Config.SectionToRename to; // imitate the GNU objcopy behavior.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp:19,allocate,allocated,19,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Add a type reducer to map type2 to type2 on function returns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:14,reduce,reducer,14,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['reduce'],['reducer']
Energy Efficiency,// Add address space cast if array for storing arguments is not allocated; // in address space 0,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:64,allocate,allocated,64,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Add alignment attribute if alignment is a power of two constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:45,power,power,45,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['power'],['power']
Energy Efficiency,// Add allocated arguments to the final DAL.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Compilation.cpp:7,allocate,allocated,7,interpreter/llvm-project/clang/lib/Driver/Compilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Compilation.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Add an implicit def of exec to discourage scheduling VALU after this which; // will interfere with trying to form s_and_saveexec_b64 later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp:45,schedul,scheduling,45,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Add an intermediate block between the BodyBlock and the; // ExitConditionBlock to represent the ""loop back"" transition. Create an; // empty block to represent the transition block for looping back to the; // head of the loop.; // FIXME: Can we do this more efficiently without adding another block?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:260,efficient,efficiently,260,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// Add both scheduling passes to give the subtarget an opportunity to pick; // between them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:12,schedul,scheduling,12,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Add calculated energy loss at total particle's energy loss",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:18,energy,energy,18,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,2,['energy'],['energy']
Energy Efficiency,"// Add insert edges first. Experimentally, for the particular case of two; // blocks that can be merged, with a single successor and single predecessor; // respectively, it is beneficial to have all insert updates first. Deleting; // edges first may lead to unreachable blocks, followed by inserting edges; // making the blocks reachable again. Such DT updates lead to high compile; // times. We add inserts before deletes here to reduce compile time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:431,reduce,reduce,431,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Add instructions to the SchedGroup bottom up starting from RIter.; // PipelineInstrs is a set of instructions that should not be added to the; // SchedGroup even when the other conditions for adding it are satisfied.; // RIter will be added to the SchedGroup as well, and dependencies will be; // added so that RIter will always be scheduled at the end of the group.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:335,schedul,scheduled,335,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:326,schedul,scheduling,326,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Add reduced value cost, if resized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:7,reduce,reduced,7,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Add the PowerPC intrinsic headers (<resource>/include/ppc_wrappers),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AIX.cpp:11,Power,PowerPC,11,interpreter/llvm-project/clang/lib/Driver/ToolChains/AIX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AIX.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// Add the argument to the list to be allocated once we know the size of the; // aggregate. Store the type's required alignment as extra info for later: in; // the [N x i64] case all trace has been removed by the time we actually get; // to do allocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMCallingConv.cpp:38,allocate,allocated,38,interpreter/llvm-project/llvm/lib/Target/ARM/ARMCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMCallingConv.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Add the argument to the list to be allocated once we know the size of the; // block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp:38,allocate,allocated,38,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp,2,['allocate'],['allocated']
Energy Efficiency,// Add the common symbols to a list. We'll allocate them all below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:43,allocate,allocate,43,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Add the components of RHS to this instance. Instead of calculating; // the final value here, we keep track of the numerator and denominator; // separately, to reduce floating point error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Support.h:162,reduce,reduce,162,interpreter/llvm-project/llvm/include/llvm/MCA/Support.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Support.h,1,['reduce'],['reduce']
Energy Efficiency,// Add the instruction after the scheduled instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:33,schedul,scheduled,33,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Add the instruction before the scheduled instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:34,schedul,scheduled,34,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Add the nested pass manager with the appropriate adaptor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp:52,adapt,adaptor,52,interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,5,['adapt'],['adaptor']
Energy Efficiency,// Add the objects that we need to allocate to our working set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:35,allocate,allocate,35,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Add the primary loop simplification pipeline.; // FIXME: Currently this is split into two loop pass pipelines because we run; // some function passes in between them. These can and should be removed; // and/or replaced by scheduling the loop pass equivalents in the correct; // positions. But those equivalent passes aren't powerful enough yet.; // Specifically, `SimplifyCFGPass` and `InstCombinePass` are currently still; // used. We have `LoopSimplifyCFGPass` which isn't yet powerful enough yet to; // fully replace `SimplifyCFGPass`, and the closest to the other we have is; // `LoopInstSimplify`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:225,schedul,scheduling,225,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,6,"['power', 'schedul']","['powerful', 'scheduling']"
Energy Efficiency,// Add the scheduling boundary if it's not block end.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:11,schedul,scheduling,11,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Add the unique query tag as TNamed object to the input list; // so that it is available in TSelectors for monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:109,monitor,monitoring,109,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,3,['monitor'],['monitoring']
Energy Efficiency,"// Add this particle's energy loss at the total; // energy loss into the detector",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:23,energy,energy,23,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,2,['energy'],['energy']
Energy Efficiency,"// Add to global list (we will add to the monitor list after; // finalizing the server startup)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:42,monitor,monitor,42,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['monitor'],['monitor']
Energy Efficiency,"// Adding I to a packet that has J.; // Regmasks are not reflected in the scheduling dependency graph, so; // we need to check them manually. This code assumes that regmasks only; // occur on calls, and the problematic case is when we add an instruction; // defining a register R to a packet that has a call that clobbers R via; // a regmask. Those cannot be packetized together, because the call will; // be executed last. That's also a reson why it is ok to add a call; // clobbering R to a packet that defines R.; // Look for regmasks in J.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:74,schedul,scheduling,74,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Adding a power-of-two or zero to the same power-of-two or zero yields; // either the original power-of-two, a larger power-of-two or zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:12,power,power-of-two,12,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,4,['power'],['power-of-two']
Energy Efficiency,"// Address of page containing P, assuming page_size is a power of 2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/PlatformPosix.cpp:57,power,power,57,interpreter/cling/lib/Utils/PlatformPosix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/PlatformPosix.cpp,1,['power'],['power']
Energy Efficiency,"// Address stored in the TOC entry. This is related to code model and the ABI; // we are currently using. For now we only handle 64-bit Linux LE. PowerPC; // only supports small, medium and large code model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp:146,Power,PowerPC,146,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCInstructionSelector.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// Adjust number of parallel live ranges.; // Heuristic is simple - node with no data successors reduces; // number of live ranges. All others, increase it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp:97,reduce,reduces,97,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,1,['reduce'],['reduces']
Energy Efficiency,// Adjust stack pointer: ESP -= numbytes.; // Windows and cygwin/mingw require a prologue helper routine when allocating; // more than 4K bytes on the stack. Windows uses __chkstk and cygwin/mingw; // uses __alloca. __alloca and the 32-bit version of __chkstk will probe the; // stack and adjust the stack pointer in one go. The 64-bit version of; // __chkstk is only responsible for probing the stack. The 64-bit prologue is; // responsible for adjusting the stack pointer. Touching the stack at 4K; // increments is necessary to ensure that the guard pages used by the OS; // virtual memory manager are allocated in correct sequence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:605,allocate,allocated,605,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Adjust the alignment for fixed-length SVE vectors. This is important; // for non-power-of-2 vector lengths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:84,power,power-of-,84,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['power'],['power-of-']
Energy Efficiency,// Adjust the computations below when the phi and the loop definition; // are scheduled in different stages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:78,schedul,scheduled,78,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Adjust the function prologue to enable split stacks. This currently only; // supports android and linux.; //; // The ABI of the segmented stack prologue is a little arbitrarily chosen, but; // must be well defined in order to allow for consistent implementations of the; // __morestack helper function. The ABI is also not a normal ABI in that it; // doesn't follow the normal calling conventions because this allows the; // prologue of each function to be optimized further.; //; // Currently, the ABI looks like (when calling __morestack); //; // * r4 holds the minimum stack size requested for this function call; // * r5 holds the stack size of the arguments to the function; // * the beginning of the function is 3 instructions after the call to; // __morestack; //; // Implementations of __morestack should use r4 to allocate a new stack, r5 to; // place the arguments on to the new stack, and the 3-instruction knowledge to; // jump directly to the body of the function when working on the new stack.; //; // An old (and possibly no longer compatible) implementation of __morestack for; // ARM can be found at [1].; //; // [1] - https://github.com/mozilla/rust/blob/86efd9/src/rt/arch/arm/morestack.S",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:826,allocate,allocate,826,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Adjust the number of Phis needed depending on the number of prologs left,; // and the distance from where the Phi is first scheduled. The number of; // Phis cannot exceed the number of prolog stages. Each stage can; // potentially define two values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:126,schedul,scheduled,126,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// After looking at the parent chain, look for referenced DIEs. Because of; // the LIFO worklist we need to schedule that work before any subsequent; // items are added to the worklist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:108,schedul,schedule,108,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// After reverting schedule, debug instrs will now be at the end of the block; // and RegionEnd will point to the first debug instr. Increment RegionEnd; // pass debug instrs to the actual end of the scheduling region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:19,schedul,schedule,19,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"// After scheduling is done, improve low latency placements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h:9,schedul,scheduling,9,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,1,['schedul'],['scheduling']
Energy Efficiency,"// After scheduling the definition of a VRegCycle, clear the isVRegCycle flag of; // CopyFromReg operands. We should no longer penalize other uses of this VReg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:9,schedul,scheduling,9,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// After the first and second level caches, I see two common sorts of; // behavior: 1) a lot of searched FileID's are ""near"" the cached file; // location or are ""near"" the cached expansion location. 2) others are just; // completely random and may be a very long way away.; //; // To handle this, we do a linear search for up to 8 steps to catch #1 quickly; // then we fall back to a less cache efficient, but more scalable, binary; // search to find the location.; // See if this is near the file point - worst case we start scanning from the; // most newly created FileID.; // LessIndex - This is the lower bound of the range that we're searching.; // We know that the offset corresponding to the FileID is less than; // SLocOffset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:395,efficient,efficient,395,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// After the first item has been allocated, the rest are packed as tightly as; // possible. (E.g. an incoming i64 would have starting Align of 8, but we'll; // be allocating a bunch of i32 slots).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMCallingConv.cpp:33,allocate,allocated,33,interpreter/llvm-project/llvm/lib/Target/ARM/ARMCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMCallingConv.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Again, should reuse the now enlarged, thread-local heap-allocated buffer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/test/TErrorTests.cxx:59,allocate,allocated,59,core/base/test/TErrorTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/test/TErrorTests.cxx,1,['allocate'],['allocated']
Energy Efficiency,// Aggressivly try to reduce register pressure in the unclustered high RP; // stage. Temporarily increase occupancy target in the region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:22,reduce,reduce,22,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Alias columns (columns of projected fields) don't contribute to the storage consumption. Count them; // but don't add the the page sizes to the overall volume.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptorFmt.cxx:79,consumption,consumption,79,tree/ntuple/v7/src/RNTupleDescriptorFmt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptorFmt.cxx,1,['consumption'],['consumption']
Energy Efficiency,// Aligned read to sanity check that the buffer was allocated with at least 8b; // alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp:52,allocate,allocated,52,interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Alignment is always a power of 2, so the GCD will be a power of 2,; // which means we get to do this crazy thing instead of Euclid's.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:25,power,power,25,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,['power'],['power']
Energy Efficiency,// Alignment must be a power of two; make sure of that.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:23,power,power,23,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,2,['power'],['power']
Energy Efficiency,// Alignment of the variable (power of 2).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h:30,power,power,30,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h,1,['power'],['power']
Energy Efficiency,// Alignment power-of-two before extending operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:13,power,power-of-two,13,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,1,['power'],['power-of-two']
Energy Efficiency,// Alignment should be a power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/Hexagon.cpp:25,power,power,25,interpreter/llvm-project/clang/lib/CodeGen/Targets/Hexagon.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/Hexagon.cpp,1,['power'],['power']
Energy Efficiency,// All DIEValues are allocated through this allocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:21,allocate,allocated,21,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,1,['allocate'],['allocated']
Energy Efficiency,// All VFs in the TLI are powers of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp:26,power,powers,26,interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp,1,['power'],['powers']
Energy Efficiency,// All blocks must be scheduled before any instructions are inserted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:22,schedul,scheduled,22,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// All code for this class below this point is needed because of the; // temporary implicit conversion to uint64_t. The operator overloads are; // needed because otherwise the conversion of the parent class; // UnivariateLinearPolyBase -> TypeSize is ambiguous.; // TODO: Remove the implicit conversion.; // Casts to a uint64_t if this is a fixed-width size.; //; // This interface is deprecated and will be removed in a future version; // of LLVM in favour of upgrading uses that rely on this implicit conversion; // to uint64_t. Calls to functions that return a TypeSize should use the; // proper interfaces to TypeSize.; // In practice this is mostly calls to MVT/EVT::getSizeInBits().; //; // To determine how to upgrade the code:; //; // if (<algorithm works for both scalable and fixed-width vectors>); // use getKnownMinValue(); // else if (<algorithm works only for fixed-width vectors>) {; // if <algorithm can be adapted for both scalable and fixed-width vectors>; // update the algorithm and use getKnownMinValue(); // else; // bail out early for scalable vectors and use getFixedValue(); // },MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h:923,adapt,adapted,923,interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h,1,['adapt'],['adapted']
Energy Efficiency,// All getCopyFromReg ops must precede any getMemcpys to prevent the; // scheduler clobbering a register before it has been copied.; // The stages are:; // 1. CopyFromReg (and load) arg & vararg registers.; // 2. Chain CopyFromReg nodes into a TokenFactor.; // 3. Memcpy 'byVal' args & push final InVals.; // 4. Chain mem ops nodes into a TokenFactor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp:73,schedul,scheduler,73,interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp,2,['schedul'],['scheduler']
Energy Efficiency,// All kernel frames have been allocated. Calculate and record the; // addresses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:31,allocate,allocated,31,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['allocate'],['allocated']
Energy Efficiency,// All nodes that are possible to schedule are stored in the Available set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:34,schedul,schedule,34,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// All other SGPRs must be allocated on the default stack, so reset the; // stack ID.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp:27,allocate,allocated,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,// All pending members have now been allocated,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp:37,allocate,allocated,37,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp,3,['allocate'],['allocated']
Energy Efficiency,// All preds scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:13,schedul,scheduled,13,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,2,['schedul'],['scheduled']
Energy Efficiency,// All stack variables are considered to have undefined values; // upon creation. All heap allocated blocks are considered to; // have undefined values as well unless they are explicitly bound; // to specific values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:91,allocate,allocated,91,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,1,['allocate'],['allocated']
Energy Efficiency,// All three of these are optional. The first variable is allocated at; // zero. They are allocated by AMDGPUMachineFunction as one block.; // Layout:; //{; // module.lds; // alignment padding; // kernel instance; // alignment padding; // dynamic lds variables; //},MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:58,allocate,allocated,58,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// AllocaHolder - Object to track all of the blocks of memory allocated by; // alloca. When the function returns, this object is popped off the execution; // stack, which causes the dtor to be run, which frees all the alloca'd memory.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.h:62,allocate,allocated,62,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.h,1,['allocate'],['allocated']
Energy Efficiency,"// Allocate BIG list of cells",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:3,Allocate,Allocate,3,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,2,['Allocate'],['Allocate']
Energy Efficiency,// Allocate Formulas using Arena rather than calling this function directly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Formula.h:3,Allocate,Allocate,3,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Formula.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Formula.h,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate NumBytes-4 bytes on stack in case of isEAXAlive.; // We'll also use 4 already allocated bytes for EAX.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,// Allocate StackSize bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,2,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate TheTable of the same size as RHS's TheTable, and set the; // sentinel appropriately (and NumBuckets).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate WebAssembly locals for each non-aggregate component of the; // allocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a GOT Entry,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a block for storage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp,2,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a block of Size bytes on the stack and probe it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a buffer of the right number of characters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a full-sized argument for the 64-bit ABI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate a half-sized argument for the 64-bit ABI.; //; // This is used when passing { float, int } structs by value in registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a holding buffer for a sequence of tokens and introduce it into; // the token stream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a lazy-save buffer object of size SVL.B * SVL.B (worst-case),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a matrix big enough for longest names.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/UnicodeNameToCodepoint.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Support/UnicodeNameToCodepoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/UnicodeNameToCodepoint.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate a new CGBitFieldInfo object to describe this access.; //; // FIXME: This is incredibly wasteful, these should be uniqued or part of some; // layout object. However, this is blocked on other cleanups to the; // Objective-C code, so for now we just live with allocating a bunch of these; // objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a new MachineSDNode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a new Reg Mask and copy Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a new ScheduleData for the instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,"['Allocate', 'Schedul']","['Allocate', 'ScheduleData']"
Energy Efficiency,// Allocate a new block of memory and place the bitfield in it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate a new block, transferring over pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpState.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/AST/Interp/InterpState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpState.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a new canonical template specialization type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a new container with a capacity for n elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h:3,Allocate,Allocate,3,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a new item with space for the string at the end and a null; // terminator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a new module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a new node and set the attributes to Attrs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate a new node, mark it as root, and process its calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a new node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a new register for the remat.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a new stack object for this spill location...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,2,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate a slab of memory upfront, if required. This is used if; // we want to test small code models.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a spill slot for EBP if we have a base pointer and EH funclets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate a stack slot for it, so we can point the debugger to it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a stack slot like for any local variable to guarantee optimal; // debug info at -O0. The mem2reg pass will eliminate it when optimizing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a struct at the beginning of this function,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate a target...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/TargetSelect.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/TargetSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/TargetSelect.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate a weak_ptr on the heap, return a pointer to it. The user is responsible for deleting this weak_ptr.; // This function is meant to be used by RInterface's methods that book code for jitting.; // The problem it solves is that we generate code to be lazily jitted with the addresses of certain objects in them,; // and we need to check those objects are still alive when the generated code is finally jitted and executed.; // So we pass addresses to weak_ptrs allocated on the heap to the jitted code, which is then responsible for; // the deletion of the weak_ptr object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:3,Allocate,Allocate,3,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,// Allocate all RVV locals and spills,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate all SVE locals and spills,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate an additional TPIDR2 object on the stack (16 bytes),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate an extra 8 bytes worth of storage, which ensures that the; // resulting pointer will still be 8-byte aligned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate an object to read into.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:3,Allocate,Allocate,3,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,2,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate and fill reordered covI matrix in 2x2 block structure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx:3,Allocate,Allocate,3,roofit/roofitcore/src/RooMultiVarGaussian.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate and fill work buffer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx:3,Allocate,Allocate,3,roofit/roofitcore/src/RooFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx,4,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate and initialize the memory block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:3,Allocate,Allocate,3,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate and initialize two array-of-arrays for the live-in and live-out; // machine values. The outer dimension is the block number; while the inner; // dimension is a LocIdx from MLocTracker.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate and initialize weight array",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:3,Allocate,Allocate,3,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate and initialize weight array if necessary",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:3,Allocate,Allocate,3,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate and return a new state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate argument on the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate array of sampling size plus optional buffer zones",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:3,Allocate,Allocate,3,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate arrays",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/buildLikelihood.cxx:3,Allocate,Allocate,3,roofit/roofitcore/src/TestStatistics/buildLikelihood.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/buildLikelihood.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate bucket if does not exist yet",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTCharToGlyphIndexMap.h:3,Allocate,Allocate,3,graf3d/ftgl/inc/FTCharToGlyphIndexMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTCharToGlyphIndexMap.h,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate buckets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate buffer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:3,Allocate,Allocate,3,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,2,['Allocate'],['Allocate']
Energy Efficiency,// Allocate by adjusting by the negative of what the record holder tracked; // it tracked a positive offset in a downward growing stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCFrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/ARC/ARCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCFrameLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate candidates and find bases for Add instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate candidates and find bases for GetElementPtr instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate candidates and find bases for Mul instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate coefficients array",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:3,Allocate,Allocate,3,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate column info array",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/fitsio/src/TFITS.cxx:3,Allocate,Allocate,3,graf2d/fitsio/src/TFITS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/fitsio/src/TFITS.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate common symbols,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate coordinate buffer size after number of function dimensions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinIntegrator.cxx:3,Allocate,Allocate,3,roofit/roofitcore/src/RooBinIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinIntegrator.cxx,4,['Allocate'],['Allocate']
Energy Efficiency,// Allocate definition DIE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate early clobbers and livethrough operands first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate enough memory to hold the type...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate external info struct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,4,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate extra memory for the string and copy it.; // FIXME: This is incorrect, Operands are owned by unique_ptr with a default; // deleter which will destroy them by simply using ""delete"", not correctly; // calling operator delete on this extra memory after calling the dtor; // explicitly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate global and split ranges in long->short order. Long ranges that; // don't fit should be spilled (or split) ASAP so they don't create; // interference. Mark a bit to prioritize global above local ranges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate head group if it is not allocated yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,"// Allocate int register and shadow next int register. If first; // available register is Mips::A1 or Mips::A3, shadow it too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate local structures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate low registers first, so we can select more 16-bit instructions.; // We also (in ignoreCSRForAllocationOrder) override the default behaviour; // with regards to callee-saved registers, because pushing extra registers is; // much cheaper (in terms of code size) than using high registers. After; // that, we allocate r12 (doesn't need to be saved), lr (saving it means we; // can return with the pop, don't need an extra ""bx lr"") and then the rest of; // the high registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,2,"['Allocate', 'allocate']","['Allocate', 'allocate']"
Energy Efficiency,"// Allocate memory for a MacroArgs object with the lexer tokens at the end,; // and construct the MacroArgs object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate memory for a local.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/EvalEmitter.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/AST/Interp/EvalEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/EvalEmitter.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate memory for stubs and pointers in one call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate memory for the array.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate memory for the decompressed filenames.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate memory for the section,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,2,['Allocate'],['Allocate']
Energy Efficiency,// Allocate memory for the setjmp buffer. This needs to be kept; // live throughout the try and catch blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate memory if needed,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate memory to store the parameter and the block metadata.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate new Ensemble on demand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate new array the first time we see a new target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate new entries&hashes arrays.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate new group.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate new group. Put allocated group into the \p AtomicGroup if; // it is empty. If \p AtomicGroup is filled by another thread then; // put allocated group into the end of groups list.; // \returns true if allocated group is put into the \p AtomicGroup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,4,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,// Allocate new literal reg,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ControlFlowFinalizer.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ControlFlowFinalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ControlFlowFinalizer.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate new nested-name-specifier location information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate new nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,2,['Allocate'],['Allocate']
Energy Efficiency,// Allocate next group if necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate no GOT entries for use in the given section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate on the heap for easier move.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate one extra bucket, set it to look filled so the iterators stop at; // end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringMap.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Support/StringMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringMap.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate one slab for the whole thing (to make sure everything is; // in-range), then partition into standard and finalization blocks.; //; // FIXME: Make two separate allocations in the future to reduce; // fragmentation: finalization segments will usually be a single page, and; // standard segments are likely to be more than one page. Where multiple; // allocations are in-flight at once (likely) the current approach will leave; // a lot of single-page holes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp,2,"['Allocate', 'reduce']","['Allocate', 'reduce']"
Energy Efficiency,"// Allocate original local ranges in linear instruction order. Since they; // are singly defined, this produces optimal coloring in the absence of; // global interference and other constraints.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate our own console handle, to prevent redirection from; // stealing it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/StreamReaderWin.cpp:3,Allocate,Allocate,3,core/textinput/src/textinput/StreamReaderWin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/StreamReaderWin.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate out-of-line storage. FIXME: Use an explicit alignment; // parameter in C++17 mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate part of an AAPCS HFA or HVA. We assume that each member of the HA; // has InConsecutiveRegs set, and that the last member also has; // InConsecutiveRegsLast set. We must process all members of the HA before; // we can allocate it, as we need to know the total number of registers that; // will be needed in order to (attempt to) allocate a contiguous block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMCallingConv.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMCallingConv.cpp,3,"['Allocate', 'allocate']","['Allocate', 'allocate']"
Energy Efficiency,// Allocate persistent storage for the file name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate pre-loaded kernel arguemtns. Arguments to be preloading must be; // sequential starting from the first argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate resources (i.e. 4 bytes) for constant extender. If succeeded,; // return true, otherwise, return false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate shadow area for Win64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,2,['Allocate'],['Allocate']
Energy Efficiency,// Allocate shadow area for Win64.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,2,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate slots for each physical register, plus one for a special register; // to track the virtual resource of a calling sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate slots.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate some space to put the new indices in,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate some vectors for storing the live ins and live outs. Large.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate something of this value type repeatedly until we get assigned a; // location in memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate space for 5 lists (Vars, Inits, Updates, Finals), 2 expressions; // (Step and CalcStep), list of used expression + step.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,2,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space for a single Use*,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/IR/User.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space for all virtual registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate space for computed loop bounds as expected by the ""init"" function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,3,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space for data to be serialized out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space for every unsafe static AllocaInst on the unsafe stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space for exactly zero operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate space for highest quality (LOD) meshes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCylinder.cxx:3,Allocate,Allocate,3,graf3d/gl/src/TGLCylinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCylinder.cxx,4,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space for locals before setjmp so that memory can be collected; // if parse exits prematurely (via longjmp).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space for nontemporal variables + private references.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space for private variables and initializer expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,2,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate space for the MemoryBuffer, the data and the name. It is important; // that MemoryBuffer and data are aligned so PointerIntPair works with them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space for the callee saves (if any).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate space for the new sub-branch offsets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:3,Allocate,Allocate,3,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space for the rest of the frame including SVE locals. Align the; // stack as necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space for the result token. This is guaranteed to be enough for; // the two tokens.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space for the size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate space for the temporary values we need either on the stack, if; // it will fit, or on the heap if it won't.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space for the variable to be globalized,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space for this VLA object to be globalized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate space for twice as many bits as the original significand, plus one; // extra bit for the addition to overflow into.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space for vector and generate alloc instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate space in stack, copy environment bits into it and use this; // memory in SET_FPENV_MEM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space on the stack at the same time as saving LR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/XCore/XCoreFrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/XCore/XCoreFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/XCore/XCoreFrameLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space on the stack if necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate space on the stack if needed; // sub %sp,StackSize,%sp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate space to read the profile annotation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate space to store the segments. They cannot be more than the; // number of triangles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraph2DPainter.cxx:3,Allocate,Allocate,3,hist/histpainter/src/TGraph2DPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraph2DPainter.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate special input registers that are initialized per-wave.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate special inputs passed in VGPRs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate special inputs passed in user SGPRs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,2,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate spill slots for WWM reserved VGPRs.; // For chain functions, we only need to do this if we have calls to; // llvm.amdgcn.cs.chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate stack slot for stride register,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerTileCopy.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerTileCopy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerTileCopy.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate stack slot for tile register,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerTileCopy.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerTileCopy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerTileCopy.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate statically the array of pointers to value profile nodes for; // the current function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate storage for bindings and stash them away.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate storage for the string.; // The byte length does not include the null terminator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,8,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate target machine. First, check whether the user has explicitly; // specified an architecture to compile for. If so we have to look it up by; // name, because it might be a backend that has no mapping to a target triple.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/TargetRegistry.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/MC/TargetRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/TargetRegistry.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate temporary space to store the integral and compute integral",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:3,Allocate,Allocate,3,hist/hist/src/TH2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx,2,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate the (non-canonical) template specialization type, but don't; // try to unique it: these types typically have location information that; // we don't unique and don't want to lose.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate the DeclStmt using the BumpPtrAllocator. It will get; // automatically freed with the CFG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate the EH registration node first if one is present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate the X3D viewer buffer with sizes if any",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/TViewerX3D.cxx:3,Allocate,Allocate,3,graf3d/x3d/src/TViewerX3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/TViewerX3D.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate the array of Uses,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/IR/User.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate the copy of the PartialDiagnostic via the ASTContext's; // BumpPtrAllocator, rather than the ASTContext itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate the frame index for frame pointer save area.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,3,['Allocate'],['Allocate']
Energy Efficiency,// Allocate the frame index for the base pointer save area.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate the frame.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate the full stack space for a promoted (and split) argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate the generational 'most recent' cache now, if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h:3,Allocate,Allocate,3,interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate the local block,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,2,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate the mask array for the node out of the BumpPtrAllocator, since; // SDNode doesn't have access to it. This memory will be ""leaked"" when; // the node is deallocated, but recovered when the NodeAllocator is released.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate the memory from the ASTContext.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTVector.h:3,Allocate,Allocate,3,interpreter/llvm-project/clang/include/clang/AST/ASTVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTVector.h,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate the memory from the BumpPtrAllocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Support/BumpVector.h:3,Allocate,Allocate,3,interpreter/llvm-project/clang/include/clang/Analysis/Support/BumpVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Support/BumpVector.h,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate the necessary space in fRowIndex and fColIndex",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixTSparse.cxx:3,Allocate,Allocate,3,math/matrix/src/TMatrixTSparse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixTSparse.cxx,2,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate the necessary space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TEmulatedCollectionProxy.cxx:3,Allocate,Allocate,3,io/io/src/TEmulatedCollectionProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TEmulatedCollectionProxy.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate the new buffer and copy the old data into it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TypeLocBuilder.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/Sema/TypeLocBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TypeLocBuilder.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate the nonvolatile CR spill slot iff the function uses CR 2, 3, or 4.; // For 64-bit SVR4, and all flavors of AIX we create a FixedStack; // object at the offset of the CR-save slot in the linkage area. The actual; // save and restore of the condition register will be created as part of the; // prologue and epilogue insertion, but the FixedStack object is needed to; // keep the CalleSavedInfo valid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate the preserved area first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,2,['Allocate'],['Allocate']
Energy Efficiency,// Allocate the required MBBs and add to parent function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate the reserved argument area. It seems strange to do this from the; // caller side but removing it breaks the frame size calculation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate the same number of UTF-16 code units as UTF-8 code units. Encoding; // as UTF-16 should always require the same amount or less code units than the; // UTF-8 encoding. Allocate one extra byte for the null terminator though,; // so that someone calling DstUTF16.data() gets a null terminated string.; // We resize down later so we don't have to worry that this over allocates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTFWrapper.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Support/ConvertUTFWrapper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTFWrapper.cpp,3,"['Allocate', 'allocate']","['Allocate', 'allocates']"
Energy Efficiency,// Allocate the space for the fixup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate the temporary array(s).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate the vararg register save area.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate tile register first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate to a register if possible, or else a stack slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,2,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate transfer array",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFunctor.cxx:3,Allocate,Allocate,3,roofit/roofitcore/src/RooFunctor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFunctor.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate undef operands. This is a separate step because in a situation; // like ` = OP undef %X, %X` both operands need the same register assign; // so we should perform the normal assignment first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate user-defined register classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate v and tt arrays",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:3,Allocate,Allocate,3,hist/histpainter/src/TPainter3dAlgorithms.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx,4,['Allocate'],['Allocate']
Energy Efficiency,// Allocate virtreg defs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate virtreg uses and insert reloads as necessary.; // Implicit MOs can get moved/removed by useVirtReg(), so loop multiple; // times to ensure no operand is missed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate work buffer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx:3,Allocate,Allocate,3,roofit/roofitcore/src/RooFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate working memory for debug object in read-only segment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Allocate workspace for numerical integration engine",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRombergIntegrator.cxx:3,Allocate,Allocate,3,roofit/roofitcore/src/RooRombergIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRombergIntegrator.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocate. We don't need to update the call graph node because we're; // going to recompute it from scratch after splitting.; // FIXME: pass the required alignment,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:3,Allocate,Allocate,3,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Allocated a register - Stop the search.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:3,Allocate,Allocated,3,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,1,['Allocate'],['Allocated']
Energy Efficiency,"// Allocated at zero, recorded once on construction, not once per; // kernel",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:3,Allocate,Allocated,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['Allocate'],['Allocated']
Energy Efficiency,"// Allocates new empty cell and return its index",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/inc/TFoam.h:3,Allocate,Allocates,3,math/foam/inc/TFoam.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/inc/TFoam.h,2,['Allocate'],['Allocates']
Energy Efficiency,// Allocates scratch memory on the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:3,Allocate,Allocates,3,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,1,['Allocate'],['Allocates']
Energy Efficiency,// Allocates the concrete syntax `Tree` according to its `NodeKind`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Synthesis.cpp:3,Allocate,Allocates,3,interpreter/llvm-project/clang/lib/Tooling/Syntax/Synthesis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Synthesis.cpp,1,['Allocate'],['Allocates']
Energy Efficiency,"// Allocating an FGR32 also allocates the super-register AFGR64, and; // ABI rules require us to skip the corresponding GPR32 pair.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:28,allocate,allocates,28,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,1,['allocate'],['allocates']
Energy Efficiency,"// Allocating an FGR32 also allocates the super-register AFGR64, and; // ABI rules require us to skip the corresponding GPR32.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:28,allocate,allocates,28,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,1,['allocate'],['allocates']
Energy Efficiency,"// Allocation type assigned to an allocation reached by a given context.; // More can be added, now this is cold, notcold and hot.; // Values should be powers of two so that they can be ORed, in particular to; // track allocations that have different behavior with different calling; // contexts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:152,power,powers,152,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['power'],['powers']
Energy Efficiency,// Allocations this large can't be represented in packed unwind (and; // usually don't fit the canonical form anyway because we need to use; // __chkstk to allocate the stack space).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:156,allocate,allocate,156,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Allocator used for allocating UAFoldingSetNodes. This handles deletion of; // all allocated nodes in one fell swoop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h:85,allocate,allocated,85,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,1,['allocate'],['allocated']
Energy Efficiency,// Allow additional implicit operands. This allows a fixup done by the post; // RA scheduler where the main implicit operand is killed and implicit-defs; // are added for sub-registers that remain live after this instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:83,schedul,scheduler,83,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// Allow the scheduler to disable register pressure tracking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:13,schedul,scheduler,13,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduler']
Energy Efficiency,"// Allow the scheduler to force top-down or bottom-up scheduling. If neither; // is true, the scheduler runs in both directions and converges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:13,schedul,scheduler,13,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,3,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,// Allow the scheduler to run before SIWholeQuadMode inserts exec manipulation; // instructions that cause scheduling barriers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:13,schedul,scheduler,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,2,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,// Already has space allocated?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:21,allocate,allocated,21,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,2,['allocate'],['allocated']
Energy Efficiency,// Also allow power of 2 integer types that have at least 8 bits and fit in; // a register. These types are common in frontend languages and targets; // usually support loads of these types.; // TODO: We could relax this to any integer that fits in a register and rely; // on ABI alignment and padding in the table to allow the load to be widened.; // Or we could widen the constants and truncate the load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:14,power,power,14,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['power'],['power']
Energy Efficiency,"// Although a conservatively allocatable node can be allocated to a register,; // spilling it may provide a lower cost solution. Assert here that spilling; // is done by choice, not because there were no register available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h:53,allocate,allocated,53,interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h,1,['allocate'],['allocated']
Energy Efficiency,"// Although we create ADJCALLSTACKDOWN and ADJCALLSTACKUP; // as scheduling fences, we skip creating fences if we already; // have existing ADJCALLSTACKDOWN/UP to avoid nesting,; // which causes verification error with -verify-machineinstrs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:65,schedul,scheduling,65,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Always allocate at least one byte.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:10,allocate,allocate,10,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Always allocate this last since it is a synthetic preload.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:10,allocate,allocate,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Always conservatively report any backpressure events if the dispatch logic; // was stalled due to unavailable scheduler resources.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/ExecuteStage.cpp:113,schedul,scheduler,113,interpreter/llvm-project/llvm/lib/MCA/Stages/ExecuteStage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/ExecuteStage.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Always convert switches to br_tables unless there is only one case, which; // is equivalent to a simple branch. This reduces code size for wasm, and we; // defer possible jump table optimizations to the VM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:120,reduce,reduces,120,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Always force inlining of any function that uses an LDS global address. This; // is something of a workaround because we don't have a way of supporting LDS; // objects defined in functions. LDS is always allocated by a kernel, and it; // is difficult to manage LDS usage if a function may be used by multiple; // kernels.; //; // OpenCL doesn't allow declaring LDS in non-kernels, so in practice this; // should only appear when IPO passes manages to move LDs defined in a kernel; // into a single user function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAlwaysInlinePass.cpp:206,allocate,allocated,206,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAlwaysInlinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAlwaysInlinePass.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Always reduce a huge region with half of the elements, except; // when user sets this number explicitly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:10,reduce,reduce,10,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Always register a new attribute to make sure we clean up the allocated; // memory properly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:64,allocate,allocated,64,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['allocate'],['allocated']
Energy Efficiency,"// Always return false here, as this function only makes sure that the first; // unallocated register has an even register number and does not actually; // allocate a register for the current argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:156,allocate,allocate,156,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Always return false here, as this function only makes sure that the first; // unallocated register has an odd register number and does not actually; // allocate a register for the current argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:155,allocate,allocate,155,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Always return false here, as this function only makes sure that the two f64; // values a ppc_fp128 value is split into are both passed in registers or both; // passed on the stack and does not actually allocate a register for the; // current argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:205,allocate,allocate,205,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Always take the highest-numbered type index. This copes with an interesting; // case for chained AST writing where we schedule writing the type and then,; // later, deserialize the type from another AST. In this case, we want to; // keep the higher-numbered entry so that we can properly write it out to; // the AST file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:121,schedul,schedule,121,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Always use TOC on AIX. Map the global address operand to be a reference; // to the TOC entry we will synthesize later. 'TOCEntry' is a label used to; // reference the storage allocated in the TOC which contains the address of; // 'MOSymbol'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:178,allocate,allocated,178,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,2,['allocate'],['allocated']
Energy Efficiency,// Always use the TargetLowering default scheduler.; // FIXME: This will use the vliw scheduler which is probably just hurting; // compiler time and will be removed eventually anyway.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:41,schedul,scheduler,41,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,2,['schedul'],['scheduler']
Energy Efficiency,"// Amount may be scalar immediate, in which case create a splat vector.; // Funnel shifts amounts are treated as modulo and types are all power-of-2 so; // we only care about the lowest log2 bits anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:138,power,power-of-,138,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,3,['power'],['power-of-']
Energy Efficiency,"// An SCC up to the size of 2, can be reduced to an entry (the last node),; // and a possible additional node. Therefore, it is already in order, and; // there is no need to add it to the work-list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:38,reduce,reduced,38,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// An adaptive kernel estimation pdf on the same data without mirroring option; // for comparison",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:6,adapt,adaptive,6,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['adapt'],['adaptive']
Energy Efficiency,"// An argument is passed either completely in registers or completely in; // memory. Since there are not enough registers left, current argument; // and all other unprocessed arguments should be passed in memory.; // However we still need to return `ABIArgInfo::getDirect()` other than; // `ABIInfo::getNaturalAlignIndirect(Ty)`, otherwise an extra stack slot; // will be allocated, so the stack frame layout will be incompatible with; // avr-gcc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/AVR.cpp:372,allocate,allocated,372,interpreter/llvm-project/clang/lib/CodeGen/Targets/AVR.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/AVR.cpp,1,['allocate'],['allocated']
Energy Efficiency,// An error margin is necessary because of poor performance of the generic RP; // tracker and can be adjusted up for tuning heuristics to try and more; // aggressively reduce register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:168,reduce,reduce,168,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['reduce'],['reduce']
Energy Efficiency,// An instruction scheduled in stage 0 and is used after the loop; // requires a phi in the epilog for the last definition from either; // the kernel or prolog.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:18,schedul,scheduled,18,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// An instruction scheduler typically runs on unbundled instructions, however; // other passes may query the latency of a bundled instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:18,schedul,scheduler,18,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// Anchor the vtable of SchedulerStrategy and DefaultSchedulerStrategy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/Scheduler.cpp:24,Schedul,SchedulerStrategy,24,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/Scheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/Scheduler.cpp,1,['Schedul'],['SchedulerStrategy']
Energy Efficiency,// And can our users be adapted?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:24,adapt,adapted,24,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['adapt'],['adapted']
Energy Efficiency,// And can the operands be adapted?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:27,adapt,adapted,27,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['adapt'],['adapted']
Energy Efficiency,"// And turn add(add(A, reduce(B)), add(C, reduce(D))) ->; // add(add(add(A, C), reduce(B)), reduce(D))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:23,reduce,reduce,23,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,4,['reduce'],['reduce']
Energy Efficiency,// And we are allowed to modify the block and the target block of the; // conditional branch is the direct successor of this block:; //; // bcc l1; // bra l2; // l1:; // ...; // l2:; //; // we change it to this if allowed:; //; // bncc l2; // l1:; // ...; // l2:; //; // Which is a bit more efficient.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp:291,efficient,efficient,291,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// And, adapt users.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:8,adapt,adapt,8,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['adapt'],['adapt']
Energy Efficiency,"// Android ARM/AArch64 use max-page-size=4096 to reduce VMA usage. Note, lld; // from 11 onwards default max-page-size to 65536 for both ARM and AArch64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:49,reduce,reduce,49,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Another trick. If this is a power 2 + 2/4/8, we can use a shift followed; // by a single LEA.; // First check if this a sum of two power of 2s because that's easy. Then; // count how many zeros are up to the first bit.; // TODO: We can do this even without LEA at a cost of two shifts and an add.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:31,power,power,31,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['power'],['power']
Energy Efficiency,// AntiDepBreakMode - Type of anti-dependence breaking that should; // be performed before post-RA scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:99,schedul,scheduling,99,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,1,['schedul'],['scheduling']
Energy Efficiency,"// Any SCCs reduced are now already in the list of child loops, so simply; // add them all to the worklist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp:12,reduce,reduced,12,interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Any SCCs reduced are now already in the list of top-level loops, so simply; // add them all to the worklist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp:12,reduce,reduced,12,interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Any bits known to already be 0 need not be cleared again, which can help; // reduce the size of the immediate to one supported by the instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:80,reduce,reduce,80,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Any calls/references made by this function will be marked exported; // later, in ComputeCrossModuleImport, after import decisions are; // complete, which is more efficient than adding them here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:165,efficient,efficient,165,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Any legal vector type can be splatted more efficiently than; // loading/spilling from memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:46,efficient,efficiently,46,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Any references made by this variable will be marked exported; // later, in ComputeCrossModuleImport, after import decisions are; // complete, which is more efficient than adding them here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:159,efficient,efficient,159,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Any register which was defined within the previous scheduling region; // may have been rescheduled and its lifetime may overlap with registers; // in ways not reflected in our current liveness state. For each such; // register, adjust the liveness state to be conservatively correct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:54,schedul,scheduling,54,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Append a copy of the command-line definition adapted to use the same; // format as in the input file to be able to reuse; // parseNumericSubstitutionBlock.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:48,adapt,adapted,48,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['adapt'],['adapted']
Energy Efficiency,"// Apply DeMorgan's law to (and/or (xor X, 1), (xor Y, 1)) if X and Y are 0/1.; // Legalizing setcc can introduce xors like this. Doing this transform reduces; // the number of xors and may allow the xor to fold into a branch condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:151,reduce,reduces,151,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['reduce'],['reduces']
Energy Efficiency,// Are all operands of a build vector constant powers of two?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:47,power,powers,47,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['power'],['powers']
Energy Efficiency,// Are the buffers identical? Common case: Handle this efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp:55,efficient,efficiently,55,interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Argument InsertPt is an instruction where vector code for some other; // tree entry (one that shares one or more scalars with TE) is going to be; // generated. This lambda returns true if insertion point of vector code; // for the TE dominates that point (otherwise dependency is the other way; // around). The other node is not limited to be of a gather kind. Gather; // nodes are not scheduled and their vector code is inserted before their; // first user. If user is PHI, that is supposed to be at the end of a; // predecessor block. Otherwise it is the last instruction among scalars of; // the user node. So, instead of checking dependency between instructions; // themselves, we check dependency between their insertion points for vector; // code (since each scalar instruction ends up as a lane of a vector; // instruction).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:389,schedul,scheduled,389,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Argument to subroutine allocated on stack,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:26,allocate,allocated,26,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,1,['allocate'],['allocated']
Energy Efficiency,"// Arguments marked with the ""byval"" attribute are implicitly copied without; // using an alloca instruction. To produce redzones for those arguments, we; // copy them a second time into memory allocated with an alloca instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:194,allocate,allocated,194,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// As described in hasher_push_cv() below, we do ""lazy merging"", delaying; // merges until right before the next CV is about to be added. This is; // different from the reference implementation. Another difference is that we; // aren't always merging 1 chunk at a time. Instead, each CV might represent; // any power-of-two number of chunks, as long as the smaller-above-larger stack; // order is maintained. Instead of the ""count the trailing 0-bits"" algorithm; // described in the spec, we use a ""count the total number of 1-bits"" variant; // that doesn't require us to retain the subtree size of the CV on top of the; // stack. The principle is the same: each CV that should remain in the stack is; // represented by a 1-bit in the total number of chunks (or bytes) so far.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:311,power,power-of-two,311,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['power'],['power-of-two']
Energy Efficiency,"// As we did not continue breaking the line, RemainingTokenColumns is; // known to fit after ContentStartColumn. Adapt ContentStartColumn to; // the position at which we want to format the next line if we do; // actually reflow.; // When we reflow, we need to add a space between the end of the current; // line and the next line's start column.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:113,Adapt,Adapt,113,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['Adapt'],['Adapt']
Energy Efficiency,// Assemble the power of 2 part.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:16,power,power,16,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['power'],['power']
Energy Efficiency,// Assemble the trailing non-power-of-2 part.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:29,power,power-of-,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['power'],['power-of-']
Energy Efficiency,// Assign the value to the allocated register,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:27,allocate,allocated,27,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Assignment to powers vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:17,power,powers,17,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['power'],['powers']
Energy Efficiency,// Assume issue width 1 without a schedule model.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:34,schedul,schedule,34,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,2,['schedul'],['schedule']
Energy Efficiency,// Assume that C allocation functions allocate arrays to avoid false; // positives.; // TODO: Add heuristics to distinguish alloc calls that allocates single; // objecs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp:38,allocate,allocate,38,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,2,['allocate'],"['allocate', 'allocates']"
Energy Efficiency,// Assume that we'll have at least some spill slots allocated.; // FIXME: This is a total SWAG number. We should run some statistics; // and pick a real one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp:52,allocate,allocated,52,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,2,['allocate'],['allocated']
Energy Efficiency,// Assume the attribute allocates before any known GDS globals.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.cpp:24,allocate,allocates,24,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.cpp,1,['allocate'],['allocates']
Energy Efficiency,// Assume the caller has allocated sizeOfPublic bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GSIStreamBuilder.cpp:25,allocate,allocated,25,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GSIStreamBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GSIStreamBuilder.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Assumes power of 2 memory size. Subtargets that have only naturally-aligned; // memory access need to perform additional legalization here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:11,power,power,11,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,1,['power'],['power']
Energy Efficiency,"// At -O0, fast-regalloc cannot cope with the live vregs necessary to; // implement atomicrmw without spilling. If the target address is also on the; // stack and close enough to the spill slot, this can lead to a situation; // where the monitor always gets cleared and the atomic operation can never; // succeed. So at -O0 lower this operation to a CAS loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:238,monitor,monitor,238,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['monitor'],['monitor']
Energy Efficiency,"// At -O0, fast-regalloc cannot cope with the live vregs necessary to; // implement atomicrmw without spilling. If the target address is also on the; // stack and close enough to the spill slot, this can lead to a situation; // where the monitor always gets cleared and the atomic operation can never; // succeed. So at -O0 lower this operation to a CAS loop. Also worthwhile if; // we have a single CAS instruction that can replace the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:238,monitor,monitor,238,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['monitor'],['monitor']
Energy Efficiency,"// At -O0, fast-regalloc cannot cope with the live vregs necessary to; // implement atomicrmw without spilling. If the target address is also on; // the stack and close enough to the spill slot, this can lead to a; // situation where the monitor always gets cleared and the atomic operation; // can never succeed. So at -O0 lower this operation to a CAS loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:238,monitor,monitor,238,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['monitor'],['monitor']
Energy Efficiency,"// At -O0, fast-regalloc cannot cope with the live vregs necessary to; // implement cmpxchg without spilling. If the address being exchanged is also; // on the stack and close enough to the spill slot, this can lead to a; // situation where the monitor always gets cleared and the atomic operation; // can never succeed. So at -O0 we need a late-expanded pseudo-inst instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:245,monitor,monitor,245,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['monitor'],['monitor']
Energy Efficiency,"// At O0 and O1 we only run the always inliner which is more efficient. At; // higher optimization levels we run the normal inliner.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp:61,efficient,efficient,61,interpreter/cling/lib/Interpreter/BackendPasses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp,1,['efficient'],['efficient']
Energy Efficiency,// At any optimization level above -O0 we use the Machine Scheduler and not; // the default Post RA List Scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:58,Schedul,Scheduler,58,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,2,['Schedul'],['Scheduler']
Energy Efficiency,"// At the end of the preheader, prepare for calling the ""init"" function by; // storing the current loop bounds into the allocated space. A canonical loop; // always iterates from 0 to trip-count with step 1. Note that ""init"" expects; // and produces an inclusive upper bound.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:120,allocate,allocated,120,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,2,['allocate'],['allocated']
Energy Efficiency,// At this point all of the scheduled instructions are between FirstMI; // and the end of the block. Kill from the first non-phi to FirstMI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:28,schedul,scheduled,28,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// At this point we could remove all type test assume sequences, as they; // were originally inserted for WPD. However, we can keep these in the; // code stream for later analysis (e.g. to help drive more efficient ICP; // sequences). They will eventually be removed by a second LowerTypeTests; // invocation that cleans them up. In order to do this correctly, the first; // LowerTypeTests invocation needs to know that they have ""Unknown"" type; // test resolution, so that they aren't treated as Unsat and lowered to; // False, which will break any uses on assumes. Below we remove any type; // test assumes that will not be treated as Unknown by LTT.; // The type test assumes will be treated by LTT as Unsat if the type id is; // not used on a global (in which case it has no entry in the TypeIdMap).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:205,efficient,efficient,205,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// At this point we've already allocated all spilled SGPRs to VGPRs if we; // can. Any remaining SGPR spills will go to memory, so move them back to the; // default stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:31,allocate,allocated,31,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// At this point, we have split the I's block to allow one lane in wavefront; // to update the precomputed reduced value. Also, completed the codegen for; // new control flow i.e. iterative loop which perform reduction and scan using; // ComputeLoop and ComputeEnd.; // For the new control flow, we need to move branch instruction i.e.; // terminator created during SplitBlockAndInsertIfThen from I's block to; // ComputeEnd block. We also need to set up predecessor to next block when; // single lane done updating the final reduced value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp:107,reduce,reduced,107,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,2,['reduce'],['reduced']
Energy Efficiency,"// At this point, we have to lower this constraint to something else, so we; // lower it to an ""r"" or ""w"". However, by doing this we will force the result; // to be in register, while the X constraint is much more permissive.; //; // Although we are correct (we are free to emit anything, without; // constraints), we might break use cases that would expect us to be more; // efficient and emit something else.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:376,efficient,efficient,376,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['efficient'],['efficient']
Energy Efficiency,"// At this point, we know that the original region doesn't contain the leaking; // when the actual leak happens. It means that it can be confusing for the; // user to see such description in the message.; //; // Let's consider the following example:; // Object *Original = allocate(...);; // Object *New = Original;; // Original = allocate(...);; // Original->release();; //; // Complaining about a leaking object ""stored into Original"" might cause a; // rightful confusion because 'Original' is actually released.; // We should complain about 'New' instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:273,allocate,allocate,273,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// Attempt to canonicalize SGT/UGT -> SGE/UGE compares with constant which; // reduces the number of EFLAGs bit reads (the GE conditions don't read ZF),; // this may translate to less uops depending on uarch implementation. The; // equivalent for SLE/ULE -> SLT/ULT isn't likely to happen as we already; // canonicalize to that CondCode.; // NOTE: Only do this if incrementing the constant doesn't increase the bit; // encoding size - so it must either already be a i8 or i32 immediate, or it; // shrinks down to that. We don't do this for any i64's to avoid additional; // constant materializations.; // TODO: Can we move this to TranslateX86CC to handle jumps/branches too?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:79,reduce,reduces,79,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Attempt to fold BITOP(MOVMSK(X),MOVMSK(Y)) -> MOVMSK(BITOP(X,Y)); // to reduce XMM->GPR traffic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:75,reduce,reduce,75,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Attempt to match a '*_extend_vector_inreg' shuffle, we just search for; // power-of-2 extensions as they are the most likely.; // FIXME: should try Scale == NumElts case too,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:78,power,power-of-,78,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['power'],['power-of-']
Energy Efficiency,// Attempt to reduce the array element to a single constant if necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp:14,reduce,reduce,14,interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Attempt to revert scheduling for this region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:21,schedul,scheduling,21,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['schedul'],['scheduling']
Energy Efficiency,"// Attempts to reduce ADDIU into ADDIUR1SP instruction,; // returns true on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,reduce,reduce,15,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Attempts to reduce ADDIU into ADDIUSP instruction,; // returns true on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,reduce,reduce,15,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Attempts to reduce LBU/LHU instruction into LBU16/LHU16,; // returns true on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,reduce,reduce,15,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Attempts to reduce LW/SW instruction into LWSP/SWSP,; // returns true on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,reduce,reduce,15,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Attempts to reduce SB/SH instruction into SB16/SH16,; // returns true on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,reduce,reduce,15,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Attempts to reduce XOR into XOR16 instruction,; // returns true on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,reduce,reduce,15,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Attempts to reduce arithmetic instructions, returns true on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,reduce,reduce,15,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Attempts to reduce two LW/SW instructions into LWP/SWP instruction,; // returns true on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,reduce,reduce,15,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Attempts to reduce two MOVE instructions into MOVEP instruction,; // returns true on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,reduce,reduce,15,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Author: Enrico Guiraud, Enric Tejedor, Danilo Piparo CERN 04/2021; // Implementation adapted from from llvm::SmallVector.; // See /math/vecops/ARCHITECTURE.md for more information.; /*************************************************************************; * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:88,adapt,adapted,88,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,2,['adapt'],['adapted']
Energy Efficiency,"// Author: Giulio Eulisse CERN 2/2018; /*************************************************************************; * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; // clang-format off; /** \class ROOT::RDF::RArrowDS; \ingroup dataframe; \brief RDataFrame data source class to interface with Apache Arrow. The RArrowDS implements a proxy RDataSource to be able to use Apache Arrow; tables with RDataFrame. A RDataFrame that adapts an arrow::Table class can be constructed using the factory method; ROOT::RDF::FromArrow, which accepts one parameter:; 1. An arrow::Table smart pointer. The types of the columns are derived from the types in the associated; arrow::Schema. */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx:656,adapt,adapts,656,tree/dataframe/src/RArrowDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx,1,['adapt'],['adapts']
Energy Efficiency,"// Authors: Stephan Hageboeck, CERN; Andrea Sciandra, SCIPP-UCSC/Atlas; Nov 2020; /*****************************************************************************; * RooFit; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2020, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; * \class RooBinSamplingPdf; * The RooBinSamplingPdf is supposed to be used as an adapter between a continuous PDF; * and a binned distribution.; * When RooFit is used to fit binned data, and the PDF is continuous, it takes the probability density; * at the bin centre as a proxy for the probability averaged (integrated) over the entire bin. This is; * correct only if the second derivative of the function vanishes, though. This is shown in the plots; * below.; *; * For PDFs that have larger curvatures, the RooBinSamplingPdf can be used. It integrates the PDF in each; * bin using an adaptive integrator. This usually requires 21 times more function evaluations, but significantly; * reduces biases due to better sampling of the PDF. The integrator can be accessed from the outside; * using integrator(). This can be used to change the integration rules, so less/more function evaluations are; * performed. The target precision of the integrator can be set in the constructor.; *; *; * ### How to use it; * There are two ways to use this class:; * - Manually wrap a PDF:; * ```; * RooBinSamplingPdf binSampler(""<name>"", ""title"", <binned observable of PDF>, <original PDF> [, <precision for integrator>]);; * binSampler.fitTo(data);; * ```; * When a PDF is wrapped with a RooBinSam",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:799,adapt,adapter,799,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,1,['adapt'],['adapter']
Energy Efficiency,// Automatic variable allocated on stack,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:22,allocate,allocated,22,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,1,['allocate'],['allocated']
Energy Efficiency,"// Avoid causing spills. If register pressure is high, schedule for; // register pressure reduction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:55,schedul,schedule,55,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:27,consumption,consumption,27,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,10,"['consumption', 'schedul']","['consumption', 'schedule']"
Energy Efficiency,// Avoid duplicate scheduling of the block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,schedul,scheduling,19,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Avoid increasing the max critical pressure in the scheduled region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:53,schedul,scheduled,53,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,3,['schedul'],['scheduled']
Energy Efficiency,"// Avoid prescheduling copies to virtual registers, which don't behave; // like other nodes from the perspective of scheduling heuristics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:116,schedul,scheduling,116,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Avoid prescheduling to copies from virtual registers, which don't behave; // like other nodes from the perspective of scheduling heuristics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:121,schedul,scheduling,121,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Avoid scheduling the def-side copy before other successors. Otherwise,; // we could introduce another physreg interference on the copy and; // continue inserting copies indefinitely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:9,schedul,scheduling,9,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Avoid setting up the register pressure tracker for small regions to save; // compile time. As a rough heuristic, only track pressure when the number of; // schedulable instructions exceeds half the integer register file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:159,schedul,schedulable,159,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['schedulable']
Energy Efficiency,"// Avoid types that are padded when being allocated as scalars, while; // being packed together in a vector (such as i1).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,allocate,allocated,42,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// B flavor and rho charge (we do not use the integrated weights)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx:20,charge,charge,20,roofit/roofit/src/RooNonCPEigenDecay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx,1,['charge'],['charge']
Energy Efficiency,"// BB:; // ... [Till the alloca]; // If stacklet is not large enough, jump to mallocMBB; //; // bumpMBB:; // Allocate by subtracting from RSP; // Jump to continueMBB; //; // mallocMBB:; // Allocate by call to runtime; //; // continueMBB:; // ...; // [rest of original BB]; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:109,Allocate,Allocate,109,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['Allocate'],['Allocate']
Energy Efficiency,// BSB scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:7,schedul,scheduling,7,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// BUILD_VECTOR was lowered into an IMPLICIT_DEF + 4 INSERT_SUBREG; // that adds a 128 bits reg copy when going through TwoAddressInstructions; // pass. We want to avoid 128 bits copies as much as possible because they; // can't be bundled by our scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelDAGToDAG.cpp:247,schedul,scheduler,247,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelDAGToDAG.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// Backing storage for the allocated nodes in each graph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp:27,allocate,allocated,27,interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Bail immediately if we don't have LV or LIS available. We use them to find; // kills efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:88,efficient,efficiently,88,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,2,['efficient'],['efficiently']
Energy Efficiency,// Bail off when there is no schedule model to query.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,schedul,schedule,29,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['schedule']
Energy Efficiency,"// Bail out on strange types. It is possible to handle some of these patterns; // even with non-power-of-2 sizes, but it is not a likely scenario.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:96,power,power-of-,96,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['power'],['power-of-']
Energy Efficiency,"// Base class for analog meter widget",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGSpeedo.h:25,meter,meter,25,gui/gui/inc/TGSpeedo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGSpeedo.h,1,['meter'],['meter']
Energy Efficiency,// Base class for classes that report changes to the IR.; // It presents an interface for such classes and provides calls; // on various events as the new pass manager transforms the IR.; // It also provides filtering of information based on hidden options; // specifying which functions are interesting.; // Calls are made for the following events/queries:; // 1. The initial IR processed.; // 2. To get the representation of the IR (of type \p T).; // 3. When a pass does not change the IR.; // 4. When a pass changes the IR (given both before and after representations; // of type \p T).; // 5. When an IR is invalidated.; // 6. When a pass is run on an IR that is not interesting (based on options).; // 7. When a pass is ignored (pass manager or adapter pass).; // 8. To compare two IR representations (of type \p T).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/StandardInstrumentations.h:751,adapt,adapter,751,interpreter/llvm-project/llvm/include/llvm/Passes/StandardInstrumentations.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/StandardInstrumentations.h,1,['adapt'],['adapter']
Energy Efficiency,// Base class for simple reducers that don't much care about the context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h:25,reduce,reducers,25,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,1,['reduce'],['reducers']
Energy Efficiency,"// Base types with sizes that aren't a power of two don't work; // with the layout rules for MS structs. This isn't an issue in; // MSVC itself since there are no such base data types there.; // On e.g. x86_32 mingw and linux, long double is 12 bytes though.; // Any structs involving that data type obviously can't be ABI; // compatible with MSVC regardless of how it is laid out.; // Since ms_struct can be mass enabled (via a pragma or via the; // -mms-bitfields command line parameter), this can trigger for; // structs that don't actually need MSVC compatibility, so we; // need to be able to sidestep the ms_struct layout for these types.; // Since the combination of -mms-bitfields together with structs; // like max_align_t (which contains a long double) for mingw is; // quite common (and GCC handles it silently), just handle it; // silently there. For other targets that have ms_struct enabled; // (most probably via a pragma or attribute), trigger a diagnostic; // that defaults to an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:39,power,power,39,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['power'],['power']
Energy Efficiency,"// BasePointerAddr + Offset = Alignment * Q for some integer Q.; // So we can say that the maximum power of two which is a divisor of; // gcd(Offset, Alignment) is an alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:99,power,power,99,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,2,['power'],['power']
Energy Efficiency,"// Based on Lemma 2.5 from [2], after insertion of (From,To), v is affected; // iff depth(NCD)+1 < depth(v) && a path P from To to v exists where every; // w on P s.t. depth(v) <= depth(w); //; // This reduces to a widest path problem (maximizing the depth of the; // minimum vertex in the path) which can be solved by a modified version of; // Dijkstra with a bucket queue (named depth-based search in [2]).; // To is in the path, so depth(NCD)+1 < depth(v) <= depth(To). Nothing; // affected if this does not hold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:202,reduce,reduces,202,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,1,['reduce'],['reduces']
Energy Efficiency,"// Be greedy: keep accumulating stores as long as they are to adjacent; // memory locations, and as long as the total number of bytes stored; // does not exceed the limit (MaxSize).; // Keep track of when the total size covered is a power of 2, since; // this is a size a single store can cover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:233,power,power,233,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,1,['power'],['power']
Energy Efficiency,// Be really careful about hoisting call operands above previous calls.; // Only allows it if it would reduce register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:103,reduce,reduce,103,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Because allocsize only tells us how many bytes are allocated, we're not; // really allowed to assume anything, so we use MallocLike.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:54,allocate,allocated,54,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Before selecting ISD::OR node to AArch64::BFM, see if an AArch64::ORR; // with shifted operand is more efficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:106,efficient,efficient,106,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Before we start introducing relocations, we want to tweak the IR a bit to; // avoid unfortunate code generation effects. The main example is that we; // want to try to make sure the comparison feeding a branch is after any; // safepoints. Otherwise, we end up with a comparison of pre-relocation; // values feeding a branch after relocation. This is semantically correct,; // but results in extra register pressure since both the pre-relocation and; // post-relocation copies must be available in registers. For code without; // relocations this is handled elsewhere, but teaching the scheduler to; // reverse the transform we're about to do would be slightly complex.; // Note: This may extend the live range of the inputs to the icmp and thus; // increase the liveset of any statepoint we move over. This is profitable; // as long as all statepoints are in rare blocks. If we had in-register; // lowering for live values this would be a much safer transform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:588,schedul,scheduler,588,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Below here directly pass binnedPdf instead of PROD(binnedPdf,constraints) as constraints are evaluated; // elsewhere anyway and omitting them reduces model complexity and associated handling/cloning times",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/buildLikelihood.cxx:145,reduce,reduces,145,roofit/roofitcore/src/TestStatistics/buildLikelihood.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/buildLikelihood.cxx,1,['reduce'],['reduces']
Energy Efficiency,"// Besides the SSE4A subtarget exception above, only aligned stores are; // available nontemporaly on any other subtarget. And only stores with a size; // of 4..32 bytes (powers of 2, only) are permitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:171,power,powers,171,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['power'],['powers']
Energy Efficiency,// Best scheduling cost.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:8,schedul,scheduling,8,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,1,['schedul'],['scheduling']
Energy Efficiency,// Binary Op helper for select operations where the expression can be; // efficiently reorganized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:74,efficient,efficiently,74,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,1,['efficient'],['efficiently']
Energy Efficiency,"// Bit-twiddling to test for a power of 2: for x > 0, x & (x-1) is zero if; // and only if x is a power of 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:31,power,power,31,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,2,['power'],['power']
Energy Efficiency,// Bitset[0 .. MAX_STAGES-1] ... iterations needed; // [LAST_IS_USE] : last reference to register in schedule is a use; // [SEEN_AS_LIVE] : Normal pressure algorithm believes register is live,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:101,schedul,schedule,101,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Block allocate the next chunk",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/UTF8.cpp:9,allocate,allocate,9,interpreter/cling/lib/Utils/UTF8.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/UTF8.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Block counter. Used to distinguish different pieces of memory allocated by; // alloca at the same call site.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h:65,allocate,allocated,65,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h,1,['allocate'],['allocated']
Energy Efficiency,// Blue Green Yellow,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:8,Green,Green,8,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Green'],['Green']
Energy Efficiency,"// Blue Green Yellow",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx:8,Green,Green,8,core/base/src/TColor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx,1,['Green'],['Green']
Energy Efficiency,"// Bools are reduced to ints during evaluation, but for; // diagnostic purposes we want to print them as; // true or false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:13,reduce,reduced,13,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Borrowed from Arm Target; // We would like to restrict this hazard recognizer to only; // post-RA scheduling; we can tell that we're post-RA because we don't; // track VRegLiveness.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:101,schedul,scheduling,101,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Both expressions have locations, though they may not have corresponding; // values. In that case, we create a fresh value at this point. Note that if; // two branches both do this, they will not share the value, but it at least; // allows for local reasoning about the value. To avoid the above, we would; // need *lazy* value allocation.; // FIXME: allocate values lazily, instead of just creating a fresh value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:353,allocate,allocate,353,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Both of them must be power-of-two, and the constant from setcc is bigger.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:24,power,power-of-two,24,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// Both operands are odd multiples of 2^Pow_2:; //; // gcd(a, b) = gcd(|a - b| / 2^i, min(a, b)); //; // This is a modified version of Stein's algorithm, taking advantage of; // efficient countTrailingZeros().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:178,efficient,efficient,178,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Bottom up scheduling : predX must comes first,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineScheduler.cpp:13,schedul,scheduling,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Break the block into scheduling regions [I, RegionEnd). RegionEnd; // points to the scheduling boundary at the bottom of the region. The DAG; // does not include RegionEnd, but the region does (i.e. the next; // RegionEnd is above the previous RegionBegin). If the current block has; // no terminator then RegionEnd == MBB->end() for the bottom region.; //; // All the regions of MBB are first found and stored in MBBRegions, which; // will be processed (MBB) top-down if initialized with true.; //; // The Scheduler may insert instructions during either schedule() or; // exitRegion(), even for empty regions. So the local iterators 'I' and; // 'RegionEnd' are invalid across these calls. Instructions must not be; // added to other regions than the current one without updating MBBRegions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:24,schedul,scheduling,24,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,4,"['Schedul', 'schedul']","['Scheduler', 'schedule', 'scheduling']"
Energy Efficiency,"// Build IV <= PrevUB or IV < PrevUB + 1 for unsigned IV to be used in; // parallel for is in combination with a distribute directive with; // schedule(static, 1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:143,schedul,schedule,143,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Build MemorySSA using a batch alias analysis. This reuses the internal; // state that AA collects during an alias()/getModRefInfo() call. This is; // safe because there are no CFG changes while building MemorySSA and can; // significantly reduce the time spent by the compiler in AA, because we will; // make queries about all the instructions in the Function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:242,reduce,reduce,242,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Build a new global with the combined contents of the referenced globals.; // This global is a struct whose even-indexed elements contain the original; // contents of the referenced globals and whose odd-indexed elements contain; // any padding required to align the next element to the next power of 2 plus; // any additional padding required to meet its alignment requirements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:294,power,power,294,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['power'],['power']
Energy Efficiency,"// Build a vector of arrays of bytes covering, for each target, a slice of the; // used region (see AccumBitVector::BytesUsed in; // llvm/Transforms/IPO/WholeProgramDevirt.h) starting at MinByte. Effectively,; // this aligns the used regions to start at MinByte.; //; // In this example, A, B and C are vtables, # is a byte already allocated for; // a virtual function pointer, AAAA... (etc.) are the used regions for the; // vtables and Offset(X) is the value computed for the Offset variable below; // for X.; //; // Offset(A); // | |; // |MinByte; // A: ################AAAAAAAA|AAAAAAAA; // B: ########BBBBBBBBBBBBBBBB|BBBB; // C: ########################|CCCCCCCCCCCCCCCC; // | Offset(B) |; //; // This code produces the slices of A, B and C that appear after the divider; // at MinByte.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:332,allocate,allocated,332,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Build expression: UB = min(UB, LastIteration); // It is necessary for CodeGen of directives with static scheduling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:107,schedul,scheduling,107,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Build sdiv by power-of-2 with conditional move instructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:17,power,power-of-,17,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['power'],['power-of-']
Energy Efficiency,"// Build set of defined column names to find later in all column names; // the defined columns more efficiently",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RInterfaceBase.cxx:100,efficient,efficiently,100,tree/dataframe/src/RInterfaceBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RInterfaceBase.cxx,1,['efficient'],['efficiently']
Energy Efficiency,"// Build the bad char heuristic table, with uint8_t to reduce cache thrashing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringRef.cpp:55,reduce,reduce,55,interpreter/llvm-project/llvm/lib/Support/StringRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringRef.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Build the scheduling graph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:13,schedul,scheduling,13,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,5,['schedul'],['scheduling']
Energy Efficiency,"// Build the shadow stack entry at the very start of the function.; // Calculate amount of space we will need for all arguments. If we have no; // args, allocate a single pointer so we still have a valid pointer to the; // argument array that we can pass to runtime, even if it will be unused.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:153,allocate,allocate,153,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Build up an AttributeList from the attributes we've been given by the; // reducer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:77,reduce,reducer,77,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['reduce'],['reducer']
Energy Efficiency,// Bump the cycle count for issue group constraints.; // This must be done after NextCycle has been adjust for all other stalls.; // Calling bumpCycle(X) will reduce CurrMOps by one issue group and set; // currCycle to X.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:159,reduce,reduce,159,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// By convention, initialization parameters of multiple base classes are grouped; // by target base class. Here, we disambiguate and put in ""sentinel"" parameters; // that allow the dispatcher to propagate them.; // Three options supported:; // 0. empty args: default constructor call; // 1. fNumBases tuples, each handed to individual constructors; // 2. less than fNumBases, assuming (void) for the missing base constructors; // 3. normal arguments, going to the first base only; // TODO: this way of forwarding is expensive as the loop is external to this call;; // it would be more efficient to have the argument handling happen beforehand",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPConstructor.cxx:585,efficient,efficient,585,bindings/pyroot/cppyy/CPyCppyy/src/CPPConstructor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPConstructor.cxx,1,['efficient'],['efficient']
Energy Efficiency,"// By default, a dependency-breaking zero-idiom is expected to be optimized; // at register renaming stage. That means, no physical register is allocated; // to the instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/DispatchStage.cpp:144,allocate,allocated,144,interpreter/llvm-project/llvm/lib/MCA/Stages/DispatchStage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/DispatchStage.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// By default, assume nontemporal memory loads are available for loads that; // are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:118,power,power,118,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,1,['power'],['power']
Energy Efficiency,"// By default, assume nontemporal memory stores are available for stores; // that are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:120,power,power,120,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,1,['power'],['power']
Energy Efficiency,"// By default, use the Source scheduling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:30,schedul,scheduling,30,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// By introducing PREPARE_PROBED_ALLOCA_NEGSIZE_OPT, ActualNegSizeReg; // and NegSizeReg will be allocated in the same phyreg to avoid; // redundant copy when NegSizeReg has only one use which is current MI and; // will be replaced by PREPARE_PROBED_ALLOCA then.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:97,allocate,allocated,97,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Byval parameters hand the function a pointer directly into the stack area; // we want to reuse during a tail call. Working around this *is* possible (see; // X86) but less efficient and uglier in LowerCall.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:175,efficient,efficient,175,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Byval parameters hand the function a pointer directly into the stack area; // we want to reuse during a tail call. Working around this *is* possible; // but less efficient and uglier in LowerCall.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:165,efficient,efficient,165,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// C r e a t e 1 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; // Create adaptive kernel estimation pdf. In this configuration the input data; // is mirrored over the boundaries to minimize edge effects in distribution; // that do not fall to zero towards the edges",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:138,adapt,adaptive,138,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['adapt'],['adaptive']
Energy Efficiency,"// C r e a t e 2 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; // Create 2D adaptive kernel estimation pdf with mirroring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:141,adapt,adaptive,141,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['adapt'],['adaptive']
Energy Efficiency,"// C++ [expr.new]p19:; //; // If the new-expression begins with a unary :: operator, the; // deallocation function's name is looked up in the global; // scope. Otherwise, if the allocated type is a class type T or an; // array thereof, the deallocation function's name is looked up in; // the scope of T. If this lookup fails to find the name, or if; // the allocated type is not a class type or array thereof, the; // deallocation function's name is looked up in the global scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:178,allocate,allocated,178,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// C++ [expr.new]p8:; // If the allocated type is a non-array type, the allocation; // function's name is operator new and the deallocation function's; // name is operator delete. If the allocated type is an array; // type, the allocation function's name is operator new[] and the; // deallocation function's name is operator delete[].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,allocate,allocated,32,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// C++11 [basic.stc.dynamic.allocation]p4:; // If an allocation function declared with a non-throwing; // exception-specification fails to allocate storage, it shall return; // a null pointer. Any other allocation function that fails to allocate; // storage shall indicate failure only by throwing an exception [...]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:139,allocate,allocate,139,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// C++17 [expr.new]p13:; // If no matching function is found and the allocated object type has; // new-extended alignment, the alignment argument is removed from the; // argument list, and overload resolution is performed again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:69,allocate,allocated,69,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// C++1z [expr.new]p9:; // If the new-expression begins with a unary :: operator, the allocation; // function's name is looked up in the global scope. Otherwise, if the; // allocated type is a class type T or array thereof, the allocation; // function's name is looked up in the scope of T.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:173,allocate,allocated,173,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// C++1z [over.match.class.deduct]p1:; // Initialization and overload resolution are performed as described in; // [dcl.init] and [over.match.ctor], [over.match.copy], or [over.match.list]; // (as appropriate for the type of initialization performed) for an object; // of a hypothetical class type, where the selected functions and function; // templates are considered to be the constructors of that class type; //; // Since we know we're initializing a class type of a type unrelated to that; // of the initializer, this reduces to something fairly reasonable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:523,reduce,reduces,523,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// C++2a [basic.stc.dynamic.allocation]p2:; // An allocation function attempts to allocate the requested amount of; // storage. [...] If the request succeeds, the value returned by a; // replaceable allocation function is a [...] pointer value p0 different; // from any previously returned value p1 [...]; //; // However, this particular information is being added in codegen,; // because there is an opt-out switch for it (-fno-assume-sane-operator-new); // C++2a [basic.stc.dynamic.allocation]p2:; // An allocation function attempts to allocate the requested amount of; // storage. If it is successful, it returns the address of the start of a; // block of storage whose length in bytes is at least as large as the; // requested size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:82,allocate,allocate,82,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// C11 6.10.3.4/3:; // all pragma unary operator expressions within [a completely; // macro-replaced preprocessing token sequence] are [...] processed [after; // rescanning is complete]; //; // This means that we execute _Pragma operators in two cases:; //; // 1) on token sequences that would otherwise be produced as the output of; // phase 4 of preprocessing, and; // 2) on token sequences formed as the macro-replaced token sequence of a; // macro argument; //; // Case #2 appears to be a wording bug: only _Pragmas that would survive to; // the end of phase 4 should actually be executed. Discussion on the WG14; // mailing list suggests that a _Pragma operator is notionally checked early,; // but only pragmas that survive to the end of phase 4 should be executed.; //; // In Case #2, we check the syntax now, but then put the tokens back into the; // token stream for later consumption.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:882,consumption,consumption,882,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['consumption'],['consumption']
Energy Efficiency,// C2 - Y <u C -> (Y | (C - 1)) == C2; // iff (C2 & (C - 1)) == C - 1 and C is a power of 2,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:81,power,power,81,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power']
Energy Efficiency,// C2 - Y >u C -> (Y | C) != C2; // iff C2 & C == C and C + 1 is a power of 2,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:67,power,power,67,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power']
Energy Efficiency,// CP microcode requires the kernel descriptor to be allocated on 64 byte; // alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp:53,allocate,allocated,53,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// CR save area offset. We map each of the nonvolatile CR fields; // to the slot for CR2, which is the first of the nonvolatile CR; // fields to be assigned, so that we only allocate one save slot.; // See PPCRegisterInfo::hasReservedSpillSlot() for more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:174,allocate,allocate,174,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// CSDB hints are scheduling barriers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:18,schedul,scheduling,18,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// CXXNewExpr is followed by several optional trailing objects.; // They are in order:; //; // * An optional ""Stmt *"" for the array size expression.; // Present if and ony if isArray().; //; // * An optional ""Stmt *"" for the init expression.; // Present if and only if hasInitializer().; //; // * An array of getNumPlacementArgs() ""Stmt *"" for the placement new; // arguments, if any.; //; // * An optional SourceRange for the range covering the parenthesized type-id; // if the allocated type was expressed as a parenthesized type-id.; // Present if and only if isParenTypeId().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:479,allocate,allocated,479,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['allocate'],['allocated']
Energy Efficiency,"// Cache for the BitTracker's cell map. Map lookup has a logarithmic; // complexity, this class will memoize the lookup results to reduce; // the access time for repeated lookups of the same cell.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:131,reduce,reduce,131,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Cache of mapping from node ids (for RefNodes) to the containing; // basic blocks. Not computing it each time for each node reduces; // the liveness calculation time by a large fraction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFLiveness.h:126,reduce,reduces,126,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFLiveness.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFLiveness.h,1,['reduce'],['reduces']
Energy Efficiency,// Cache of pre-allocated worklists for data-recursion walk of Stmts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h:16,allocate,allocated,16,interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h,1,['allocate'],['allocated']
Energy Efficiency,"// Cache the Pass ID here in case the pass manager finds this pass is; // redundant with ones already scheduled / available, and deletes it.; // Fundamentally, once we add the pass to the manager, we no longer own it; // and shouldn't reference it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:102,schedul,scheduled,102,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Cache the critical resources ID in this scheduled zone.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:43,schedul,scheduled,43,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduled']
Energy Efficiency,// Cache the list of excess pressure sets in this region. This will also track; // the max pressure in the scheduled code for these sets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:107,schedul,scheduled,107,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Cache used frame indexes during statepoint re-write to re-use them in; // processing next statepoint instruction.; // Two strategies. One is to preserve the size of spill slot while another one; // extends the size of spill slots to reduce the number of them, causing; // the less total frame size. But unspill will have ""implicit"" any extend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:236,reduce,reduce,236,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Calculate BFI lazily (it's only used to query ProfileSummaryInfo). This; // reduces compile-time significantly. TODO: When we *do* use BFI, we should; // be able to salvage its domtrees instead of recomputing them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:79,reduce,reduces,79,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,1,['reduce'],['reduces']
Energy Efficiency,// Calculate Contribution of each live BB.; // Allocate BB states for live blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:47,Allocate,Allocate,47,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Calculate domtrees lazily. This reduces compile-time significantly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:35,reduce,reduces,35,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Calculate final offset.; // - There is no need to change the offset if the frame object is one of the; // following: an outgoing argument, pointer to a dynamically allocated; // stack space or a $gp restore location,; // - If the frame object is any of the following, its offset must be adjusted; // by adding the size of the stack:; // incoming argument, callee-saved register location or local variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:167,allocate,allocated,167,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Calculate final offset.; // - There is no need to change the offset if the frame object; // is one of the; // following: an outgoing argument, pointer to a dynamically allocated; // stack space or a $gp restore location,; // - If the frame object is any of the following,; // its offset must be adjusted; // by adding the size of the stack:; // incoming argument, callee-saved register location or local variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp:171,allocate,allocated,171,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Calculate how many times the same operand from the same loop is included; // into this power.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:90,power,power,90,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['power'],['power']
Energy Efficiency,"// Calculate powers with exponents 1, 2, 4, 8 etc. and include those of them; // that are needed into the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:13,power,powers,13,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['power'],['powers']
Energy Efficiency,// Calculate sections for constant pool entries. We collect entries to go into; // the same section together to reduce amount of section switch statements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:112,reduce,reduce,112,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Calculate the amount of stack space that we need to allocate to store; // byval and variadic arguments that are passed in registers.; // We need to know this before we allocate the first byval or variadic; // argument, as they will be allocated a stack slot below the CFA (Canonical; // Frame Address, the stack pointer at entry to the function).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:55,allocate,allocate,55,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,3,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,// Calculate the total stack frame size.; // Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:72,allocate,allocate,72,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Calculates frame size required for current printf expansion and allocates; // space on printf buffer. Printf frame includes following contents; // [ ControlDWord , format string/Hash , Arguments (each aligned to 8 byte) ]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:67,allocate,allocates,67,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,1,['allocate'],['allocates']
Energy Efficiency,"// Call __kmpc_dispatch_init(; // ident_t *loc, kmp_int32 tid, kmp_int32 schedule,; // kmp_int[32|64] lower, kmp_int[32|64] upper,; // kmp_int[32|64] stride, kmp_int[32|64] chunk);; // If the Chunk was not specified in the clause - use default value 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:73,schedul,schedule,73,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Call get Workers; // if we are not idle the scheduler will just enqueue the query and; // send a resume message later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:47,schedul,scheduler,47,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['schedul'],['scheduler']
Energy Efficiency,"// Call reduce_function(GlobalReduceList, ReduceList)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:42,Reduce,ReduceList,42,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['Reduce'],['ReduceList']
Energy Efficiency,"// Call reduce_function(ReduceList, GlobalReduceList)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:24,Reduce,ReduceList,24,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['Reduce'],['ReduceList']
Energy Efficiency,"// Callback: Learning rate scheduler",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx:27,schedul,scheduler,27,tmva/pymva/src/MethodPyKeras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx,1,['schedul'],['scheduler']
Energy Efficiency,// Called during post-RA scheduling when FeatureUseMISched is not set,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:25,schedul,scheduling,25,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Called during:; // - pre-RA scheduling and post-RA scheduling,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:31,schedul,scheduling,31,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,2,['schedul'],['scheduling']
Energy Efficiency,// Called during:; // - pre-RA scheduling; // - post-RA scheduling when FeatureUseMISched is set,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:31,schedul,scheduling,31,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,2,['schedul'],['scheduling']
Energy Efficiency,"// Calls are not scheduling boundaries before register allocation, but; // post-ra we don't gain anything by scheduling across calls since we; // don't need to worry about register pressure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:17,schedul,scheduling,17,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,2,['schedul'],['scheduling']
Energy Efficiency,"// Calls are scheduled in their preceding cycle, so don't conflict with; // hazards from instructions after the call. EmitNode will reset the; // scoreboard state before emitting the call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:13,schedul,scheduled,13,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:13,schedul,scheduled,13,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,6,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,// Calls into a routine in libgcc to allocate more space from the heap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:37,allocate,allocate,37,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Can our users be adapted?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:20,adapt,adapted,20,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['adapt'],['adapted']
Energy Efficiency,// Can we legally schedule inc at the desired point?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:18,schedul,schedule,18,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Can't schedule a loop without a valid MII.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:9,schedul,schedule,9,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Canonicalize checking for a power-of-2-or-zero value:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:31,power,power-of-,31,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power-of-']
Energy Efficiency,// Canonicalize fshr as fshl to reduce pattern-matching.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:32,reduce,reduce,32,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Canonicalize mul by power of 2 to the RHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:23,power,power,23,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,1,['power'],['power']
Energy Efficiency,// Canonicalize mul by power-of-2 to the RHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:23,power,power-of-,23,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,1,['power'],['power-of-']
Energy Efficiency,// Canonicalize power-of-2 value to the RHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:16,power,power-of-,16,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,1,['power'],['power-of-']
Energy Efficiency,// Canonicalize:; // (X +/- Y) & Y --> ~X & Y when Y is a power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:58,power,power,58,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['power'],['power']
Energy Efficiency,"// Case of zero-size realloc. Historically 'realloc(ptr, 0)' is treated as; // 'free(ptr)' and the returned value from 'realloc(ptr, 0)' is not; // tracked. Add zero-reallocated Sym to the state to catch references; // to zero-allocated memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:227,allocate,allocated,227,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Cases that can simply never be deallocated; // *) Constants aren't allocated per se, thus not deallocated either.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:70,allocate,allocated,70,interpreter/llvm-project/llvm/lib/IR/Value.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Catch this common potential error here; // We have to set kRawSize (unless already done) to allocate buffer space; // before kRaw can be filled",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoShape.cxx:95,allocate,allocate,95,geom/geom/src/TGeoShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoShape.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// Change background of fTestButton to green",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx:39,green,green,39,test/guitest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx,1,['green'],['green']
Energy Efficiency,"// Change size and alignment of the allocated slot. If there are multiple; // objects sharing the same slot, then make sure the size and alignment; // are large enough for all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:36,allocate,allocated,36,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Charge in units of e0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveTrack.h:3,Charge,Charge,3,graf3d/eve/inc/TEveTrack.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveTrack.h,2,['Charge'],['Charge']
Energy Efficiency,"// Charge of the track.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveVSDStructs.h:3,Charge,Charge,3,graf3d/eve/inc/TEveVSDStructs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveVSDStructs.h,2,['Charge'],['Charge']
Energy Efficiency,"// Charge of tracked particle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveTrackPropagator.h:3,Charge,Charge,3,graf3d/eve/inc/TEveTrackPropagator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveTrackPropagator.h,2,['Charge'],['Charge']
Energy Efficiency,// Check -misched-topdown/bottomup can force or unforce scheduling direction.; // e.g. -misched-bottomup=false allows scheduling in both directions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:56,schedul,scheduling,56,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['scheduling']
Energy Efficiency,// Check allocate clauses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:9,allocate,allocate,9,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Check both offsets (or masks for MIMG) can be combined and fit in the; // reduced range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp:77,reduce,reduced,77,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Check each char to see if it is an opening bracket,; // if so, check for its closing one and color them green.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/Getline_color.cxx:107,green,green,107,core/textinput/src/Getline_color.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/Getline_color.cxx,1,['green'],['green']
Energy Efficiency,"// Check for SSSE3 which lets us lower all v16i8 shuffles much more directly; // with PSHUFB. It is important to do this before we attempt to generate any; // blends but after all of the single-input lowerings. If the single input; // lowerings can find an instruction sequence that is faster than a PSHUFB, we; // want to preserve that and we can DAG combine any longer sequences into; // a PSHUFB in the end. But once we start blending from multiple inputs,; // the complexity of DAG combining bad patterns back into PSHUFB is too high,; // and there are *very* few patterns that would actually be faster than the; // PSHUFB approach because of its ability to zero lanes.; //; // If the mask is a binary compaction, we can more efficiently perform this; // as a PACKUS(AND(),AND()) - which is quicker than UNPACK(PSHUFB(),PSHUFB()).; //; // FIXME: The only exceptions to the above are blends which are exact; // interleavings with direct instructions supporting them. We currently don't; // handle those well here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:730,efficient,efficiently,730,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// Check for a splat of a constant or for a non uniform vector of constants; // and check if the constant(s) are all powers of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:117,power,powers,117,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,1,['power'],['powers']
Energy Efficiency,// Check for alignment specifed in an 'omp allocate' directive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:43,allocate,allocate,43,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Check for already-allocated regs in this block,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:21,allocate,allocated,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,1,['allocate'],['allocated']
Energy Efficiency,"// Check for case 1, where there are multiple CMOVs with the same condition; // first. Of the two cases of multiple CMOV lowerings, case 1 reduces the; // number of jumps the most.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:139,reduce,reduces,139,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,2,['reduce'],['reduces']
Energy Efficiency,// Check for either a dependence (latency) or resource (hazard) stall.; //; // Note: The ScheduleHazardRecognizer interface requires a non-const SU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:89,Schedul,ScheduleHazardRecognizer,89,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['Schedul'],['ScheduleHazardRecognizer']
Energy Efficiency,// Check for explicit enable/disable of post-ra scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:48,schedul,scheduling,48,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Check for powers of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ScaledNumber.cpp:13,power,powers,13,interpreter/llvm-project/llvm/lib/Support/ScaledNumber.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ScaledNumber.cpp,1,['power'],['powers']
Energy Efficiency,"// Check if LPM contains any loop pass and if it does not, returns an adaptor; // in loop-nest mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:70,adapt,adaptor,70,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,1,['adapt'],['adaptor']
Energy Efficiency,// Check if V is a power of 2 or NOT power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:19,power,power,19,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['power'],['power']
Energy Efficiency,// Check if V is some power of 2 pattern known to be non-zero,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,power,power,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power']
Energy Efficiency,// Check if \p FI is allocated for any SGPR spill to a VGPR lane during PEI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h:21,allocate,allocated,21,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,1,['allocate'],['allocated']
Energy Efficiency,"// Check if a call and subsequent A2_tfrpi instructions should maintain; // scheduling affinity. We are looking for the TFRI to be consumed in; // the next instruction. This should help reduce the instances of; // double register pairs being allocated and scheduled before a call; // when not used until after the call. This situation is exacerbated; // by the fact that we allocate the pair from the callee saves list,; // leading to excess spills and restores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:76,schedul,scheduling,76,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,5,"['allocate', 'reduce', 'schedul']","['allocate', 'allocated', 'reduce', 'scheduled', 'scheduling']"
Energy Efficiency,"// Check if alignment and size of a call to aligned_alloc is valid,; // that is alignment is a power-of-2 and the size is a multiple of the; // alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:95,power,power-of-,95,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['power'],['power-of-']
Energy Efficiency,"// Check if either the dest or source is local. If it's live across a back; // edge, it's not local. Note that if both vregs are live across the back; // edge, we cannot successfully contrain the copy without cyclic scheduling.; // If both the copy's source and dest are local live intervals, then we; // should treat the dest as the global for the purpose of adding; // constraints. This adds edges from source's other uses to the copy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:216,schedul,scheduling,216,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Check if final instruction is reduced outside of current block,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:33,reduce,reduced,33,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Check if further redraws are needed and schedule them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx:43,schedul,schedule,43,graf3d/gl/src/TGLViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx,1,['schedul'],['schedule']
Energy Efficiency,// Check if it is an induction variable and always power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:51,power,power,51,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['power'],['power']
Energy Efficiency,// Check if the Phi has already been scheduled in a prolog stage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:37,schedul,scheduled,37,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Check if the Phi has already been scheduled, but the loop instruction; // is either another Phi, or doesn't occur in the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:37,schedul,scheduled,37,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Check if the first argument is improperly allocated. If so, issue a; // warning because that's likely to be bad news.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:45,allocate,allocated,45,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Check if the first argument is stack allocated. If so, issue a warning; // because that's likely to be bad news.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:40,allocate,allocated,40,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Check if the generated schedule is valid. This function checks if; // an instruction that uses a physical register is scheduled in a; // different stage than the definition. The pipeliner does not handle; // physical register values that may cross a basic block boundary.; // Furthermore, if a physical def/use pair is assigned to the same; // cycle, orderDependence does not guarantee def/use ordering, so that; // case should be considered invalid. (The test checks for both; // earlier and same-cycle use to be more robust.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:26,schedul,schedule,26,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,// Check if the load/store are clusterable according to the PowerPC; // specification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:60,Power,PowerPC,60,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// Check if the loop directive is actually a doacross loop directive. In this; // case choose static, 1 schedule.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:104,schedul,schedule,104,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Check if the memory location being freed is the actual location; // allocated, or an offset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:71,allocate,allocated,71,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Check if the new offsets fit in the reduced 8-bit range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp:39,reduce,reduced,39,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Check if the scheduler should penalize instructions that are available to; // early due to a zero-latency dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:16,schedul,scheduler,16,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Check if the scheduling model provides extra information about the machine; // processor. If so, then use that information to set the reorder buffer size; // and the maximum number of instructions retired per cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RetireControlUnit.cpp:16,schedul,scheduling,16,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RetireControlUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RetireControlUnit.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Check if the vXi32 operands can be shrunk into a smaller datatype.; // This should match the codegen from reduceVMULWidth.; // TODO: Make this generic (!ST->SSE41 || ST->isPMULLDSlow()).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:109,reduce,reduceVMULWidth,109,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['reduce'],['reduceVMULWidth']
Energy Efficiency,"// Check if there is a global monitor-per-packet setting",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPerfStats.cxx:30,monitor,monitor-per-packet,30,proof/proofplayer/src/TPerfStats.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPerfStats.cxx,1,['monitor'],['monitor-per-packet']
Energy Efficiency,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:388,schedul,schedule,388,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Check if this is a legal PowerPC vector type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.cpp:28,Power,PowerPC,28,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCLegalizerInfo.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// Check if two chained conditionals could be converted into SSAT or USAT.; //; // SSAT can replace a set of two conditional selectors that bound a number to an; // interval of type [k, ~k] when k + 1 is a power of 2. Here are some examples:; //; // x < -k ? -k : (x > k ? k : x); // x < -k ? -k : (x < k ? x : k); // x > -k ? (x > k ? k : x) : -k; // x < k ? (x < -k ? -k : x) : k; // etc.; //; // LLVM canonicalizes these to either a min(max()) or a max(min()); // pattern. This function tries to match one of these and will return a SSAT; // node if successful.; //; // USAT works similarily to SSAT but bounds on the interval [0, k] where k + 1; // is a power of 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:206,power,power,206,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['power'],['power']
Energy Efficiency,"// Check if we can 'Add' the histogram to an existing one; this is more efficient; // then using Merge",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:72,efficient,efficient,72,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['efficient'],['efficient']
Energy Efficiency,"// Check if we can reuse an existing Phi. This occurs when a Phi; // references another Phi, and the other Phi is scheduled in an; // earlier stage. We can try to reuse an existing Phi up until the last; // stage of the current Phi.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:114,schedul,scheduled,114,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Check if we have a scheduling model for instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp:22,schedul,scheduling,22,interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Check if we need to rename a Phi that has been eliminated due to; // scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:72,schedul,scheduling,72,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Check if we need to rename any uses that occurs after the loop. The; // register to replace depends on whether the Phi is scheduled in the; // epilog.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:125,schedul,scheduled,125,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Check if we should prefer a vector store that will become a .new version.; // The .new store uses different resources than a normal store, and the; // packetizer will not generate the .new if the regular store does not have; // resources available (even if the .new version does). To help, the schedule; // attempts to schedule the .new as soon as possible in the packet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:297,schedul,schedule,297,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,2,['schedul'],['schedule']
Energy Efficiency,"// Check nbr of destinations and cluster types.; // FIXME: This works, but doesn't seem very efficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:93,efficient,efficient,93,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Check non-power-of-2 loads/stores for legal vector element types with; // NEON. Non-power-of-2 memory ops will get broken down to a set of; // operations on smaller power-of-2 ops, including ld1/st1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:13,power,power-of-,13,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,3,['power'],['power-of-']
Energy Efficiency,"// Check per packet monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPerfStats.cxx:20,monitor,monitoring,20,proof/proofplayer/src/TPerfStats.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPerfStats.cxx,1,['monitor'],['monitoring']
Energy Efficiency,// Check register pressure change; // by scheduling a block with these LiveIn and LiveOut.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h:41,schedul,scheduling,41,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,1,['schedul'],['scheduling']
Energy Efficiency,// Check result of scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:19,schedul,scheduling,19,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['schedul'],['scheduling']
Energy Efficiency,// Check that all of the users of the scalars that we want to vectorize are; // schedulable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:80,schedul,schedulable,80,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['schedulable']
Energy Efficiency,// Check that all schedulable entities got scheduled,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,schedul,schedulable,18,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['schedul'],"['schedulable', 'scheduled']"
Energy Efficiency,// Check that no comment class has a non-trival destructor. They are allocated; // with a BumpPtrAllocator and therefore their destructor is not executed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp:69,allocate,allocated,69,interpreter/llvm-project/clang/lib/AST/Comment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Check that no statement / expression class has a non-trival destructor.; // Statements and expressions are allocated with the BumpPtrAllocator from; // ASTContext and therefore their destructor is not executed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Stmt.cpp:110,allocate,allocated,110,interpreter/llvm-project/clang/lib/AST/Stmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Stmt.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Check that no type class has a non-trival destructor. Types are; // allocated with the BumpPtrAllocator from ASTContext and therefore; // their destructor is not executed.; //; // FIXME: ConstantArrayType is not trivially destructible because of its; // APInt member. It should be replaced in favor of ASTContext allocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:71,allocate,allocated,71,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Check that post-RA scheduling is enabled for this target.; // This may upgrade the AntiDepMode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:22,schedul,scheduling,22,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Check that switch cases are powers of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:31,power,powers,31,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['power'],['powers']
Energy Efficiency,// Check that the number is a power of two by making sure that only the; // integer bit is set in the significand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:30,power,power,30,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['power'],['power']
Energy Efficiency,// Check that we don't have same operands. No need to reorder if operands; // are just perfect diamond or shuffled diamond match. Do not do it only; // for possible broadcasts or non-power of 2 number of scalars (just for; // now).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:183,power,power,183,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['power'],['power']
Energy Efficiency,"// Check the grouping cost. For a node that must begin / end a; // group, it is positive if it would do so prematurely, or negative; // if it would fit naturally into the schedule.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:171,schedul,schedule,171,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Check the number of buckets. It should be a power of two, and there; // should be enough space in the file for all of them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:47,power,power,47,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,1,['power'],['power']
Energy Efficiency,// Check the results of scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:24,schedul,scheduling,24,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Check the schedule and allow static schedule in SPMD mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:13,schedul,schedule,13,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,2,['schedul'],['schedule']
Energy Efficiency,// Check the temporary vector is the correct size. If this fails then; // getTypeToTransformTo() probably returned a type whose size (in bits); // isn't a power-of-2 factor of the requested type size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:155,power,power-of-,155,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['power'],['power-of-']
Energy Efficiency,// Check to see if the scheduler cares about latencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:23,schedul,scheduler,23,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,3,['schedul'],['scheduler']
Energy Efficiency,"// Check to see if we already have this constant.; //; // FIXME, this could be made much more efficient for large constant pools.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:94,efficient,efficient,94,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,2,['efficient'],['efficient']
Energy Efficiency,"// Check to see if we can DCE the instruction. We do this already here to; // reduce the number of uses and thus allow other folds to trigger.; // Note that eraseInstFromFunction() may push additional instructions on; // the deferred worklist, so this will DCE whole instruction chains.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:78,reduce,reduce,78,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Check type identity of candidate signatures. For each argument, check whether it; // reduces the list of candidates to > 0 elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocParser.cxx:88,reduce,reduces,88,html/src/TDocParser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocParser.cxx,1,['reduce'],['reduces']
Energy Efficiency,// Check whether a compaction lowering can be done. This handles shuffles; // which take every Nth element for some even N. See the helper function for; // details.; //; // We special case these as they can be particularly efficiently handled with; // the PACKUSB instruction on x86 and they show up in common patterns of; // rearranging bytes to truncate wide elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:223,efficient,efficiently,223,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Check whether the frame pointer register is allocated. If so, make sure it; // is spilled to the correct offset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:47,allocate,allocated,47,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Check whether we can widen this to an i16 shuffle by duplicating bytes.; // Notably, this handles splat and partial-splat shuffles more efficiently.; // However, it only makes sense if the pre-duplication shuffle simplifies; // things significantly. Currently, this means we need to be able to; // express the pre-duplication shuffle as an i16 shuffle.; //; // FIXME: We should check for other patterns which can be widened into an; // i16 shuffle as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:139,efficient,efficiently,139,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Check which files have been staged, this can be replaced by a bulk command,; // once it exists in the xrdclient; // For real time monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSelVerifyDataSet.cxx:133,monitor,monitoring,133,proof/proof/src/TSelVerifyDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSelVerifyDataSet.cxx,1,['monitor'],['monitoring']
Energy Efficiency,// Checking whether we should reduce the load width.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:30,reduce,reduce,30,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Checks if the operands of the \p TreeN instruction are also reduction; // operations or should be treated as reduced values or an extra argument,; // which is not part of the reduction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:112,reduce,reduced,112,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Checks that statically prove correct new value consumption,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:50,consumption,consumption,50,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,1,['consumption'],['consumption']
Energy Efficiency,// Child address ranges are encoded as relative to the first; // address in the Ranges for this object. This keeps the offsets; // small and allows for efficient encoding using ULEB offsets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/InlineInfo.cpp:152,efficient,efficient,152,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/InlineInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/InlineInfo.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Choose to insert in Node or in subtree of Node.; // Don't hoist to EHPad because we may not find a proper place to insert; // in EHPad.; // If the total frequency of InsertPts is the same as the frequency of the; // target Node, and InsertPts contains more than one nodes, choose hoisting; // to reduce code size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:299,reduce,reduce,299,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Chosen as 2 so as to be cheap, but still to have enough power to fold; // a select, so the ""clamp"" idiom (of a min followed by a max) will be caught.; // To catch this, we need to fold a compare and a select, hence '2' being the; // minimum reasonable default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:59,power,power,59,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['power'],['power']
Energy Efficiency,// Clamp the little scalar to s8-s256 and make it a power of 2. It's not; // worth considering the multiples of 64 since 2*192 and 2*384 are not; // valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:52,power,power,52,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['power'],['power']
Energy Efficiency,"// Clang emits call of __read_pipe_2 or __read_pipe_4 for OpenCL read_pipe; // builtin, with appended type size and alignment arguments, where 2 or 4; // indicates the original number of arguments. The library has optimized version; // of __read_pipe_2/__read_pipe_4 when the type size and alignment has the same; // power of 2 value. This function transforms __read_pipe_2 to __read_pipe_2_N; // for such cases where N is the size in bytes of the type (N = 1, 2, 4, 8, ...,; // 128). The same for __read_pipe_4, write_pipe_2, and write_pipe_4.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp:317,power,power,317,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,1,['power'],['power']
Energy Efficiency,// Class has 3 additional tail allocated arrays:; // 1. List of helper expressions for proper generation of assignment operation; // required for copyin clause. This list represents sources.; // 2. List of helper expressions for proper generation of assignment operation; // required for copyin clause. This list represents destinations.; // 3. List of helper expressions that represents assignment operation:; // \code; // DstExprs = SrcExprs;; // \endcode; // Required for proper codegen of propagation of master's thread values of; // threadprivate variables to local instances of that variables in other; // implicit threads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:31,allocate,allocated,31,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['allocate'],['allocated']
Energy Efficiency,// Classify instructions into groups to enable fine tuned control over the; // scheduler. These groups may be more specific than current SchedModel; // instruction classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:79,schedul,scheduler,79,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Clean Entry-to-LastInstruction table. It can be affected after scheduling,; // need to rebuild it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:66,schedul,scheduling,66,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Clean up the memory we allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:26,allocate,allocated,26,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Cleanup action for allocate support.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:22,allocate,allocate,22,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Cleanup allocated memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:11,allocate,allocated,11,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// Cleanup the monitor and the server socket",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:15,monitor,monitor,15,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,3,['monitor'],['monitor']
Energy Efficiency,"// Clear match to reduce lScope (kSTDBOTH -> kSTDOUT or kSTDERR)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp:18,reduce,reduce,18,interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Clear out the vector, but don't free the memory contents. This; // reduces malloc() traffic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp:70,reduce,reduces,70,interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Clear the assigned values and stack memory. We leave the registers marked; // as allocated so that future queries don't return the same registers, i.e.; // when i64 and f64 are both passed in GPRs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:84,allocate,allocated,84,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Clear the scheduler's SUnit DAG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:13,schedul,scheduler,13,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// Clip to a power 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:13,power,power,13,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power']
Energy Efficiency,// Cluster certain nodes which should be scheduled together.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:41,schedul,scheduled,41,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Cluster loads by adding MVT::Glue outputs and inputs. This also; // ensure they are scheduled in order of increasing addresses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:87,schedul,scheduled,87,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Cluster the load/store only when they have the same opcode, and they are; // clusterable opcode according to PowerPC specification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:112,Power,PowerPC,112,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// Coalescing could have a negative impact on scheduling, so try to limit; // to some reasonable extent. Only consider coalescing segments, when one; // of them does not cross basic block boundaries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:46,schedul,scheduling,46,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Code adapted from scheduleDAG.cpp; // Does a topological sort over the SUs.; // Both TopDown and BottomUp,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:8,adapt,adapted,8,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,2,"['adapt', 'schedul']","['adapted', 'scheduleDAG']"
Energy Efficiency,// Collect all scheduling regions. The actual scheduling is performed in; // GCNScheduleDAGMILive::finalizeSchedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:15,schedul,scheduling,15,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,2,['schedul'],['scheduling']
Energy Efficiency,"// Collect buckets of comparable addresses used by loads and stores for chain; // commoning. With chain commoning, we reuse offsets between the chains, so; // the register pressure will be reduced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:189,reduce,reduced,189,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Collect which entities point to the allocated memory, and could be; // responsible for deallocating it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:39,allocate,allocated,39,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Combinations of the above attributes that are relevant to instruction; // decode. Although other combinations are possible, they can be reduced to; // these without affecting the ultimately decoded instruction.; // Class name Rank Rationale for rank assignment",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/X86DisassemblerDecoderCommon.h:139,reduce,reduced,139,interpreter/llvm-project/llvm/include/llvm/Support/X86DisassemblerDecoderCommon.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/X86DisassemblerDecoderCommon.h,1,['reduce'],['reduced']
Energy Efficiency,"// Combine GA + Constant -> GA+Offset, but only if GA is not used elsewhere; // and the root node itself is not used more than twice. This reduces the; // amount of additional constant extenders introduced by this optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:139,reduce,reduces,139,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Commit allocated register changes. This is mostly necessary because too; // many things rely on the use lists of the physical registers, such as the; // verifier. This is only necessary with allocators which use LiveIntervals,; // since FastRegAlloc does the replacements itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:10,allocate,allocated,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Common symbols which are defined and allocated,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:40,allocate,allocated,40,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['allocate'],['allocated']
Energy Efficiency,"// Commoning chain will reduce the register pressure, so we don't consider about; // the PHI nodes number.; // But commoning chain will increase the addi/add number in the loop and also; // increase loop ILP. Maximum chain number should be same with hardware; // IssueWidth, because we won't benefit from ILP if the parallel chains number; // is bigger than IssueWidth. We assume there are 2 chains in one bucket, so; // there would be 4 buckets at most on P9(IssueWidth is 8).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:24,reduce,reduce,24,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Communicate that the task reduced a chunk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp:29,reduce,reduced,29,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Compare the AdaptiveIntegratorMultiDim and; // TF1::IntegralMultiple performance and results; // Compares time performance; // for different dimensions; // draws a graph; //; // Author: David Gonzalez Maline; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testIntegrationMultiDim.cxx:15,Adapt,AdaptiveIntegratorMultiDim,15,math/mathcore/test/testIntegrationMultiDim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testIntegrationMultiDim.cxx,1,['Adapt'],['AdaptiveIntegratorMultiDim']
Energy Efficiency,"// Comparing the address of MI isn't sufficient, because machineinstrs may; // be allocated to the same address across functions.; // If this is a new LastFn instruction, bump the counter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:82,allocate,allocated,82,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Complete schedule that will try to minimize reg pressure and; // low latencies, and will fill liveins and liveouts.; // Needs all MIs to be grouped between BeginBlock and EndBlock.; // The MIs can be moved after the scheduling,; // it is just used to allow correct track of live registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h:12,schedul,schedule,12,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,// Compute DFSResult for use in scheduling heuristics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:32,schedul,scheduling,32,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduling']
Energy Efficiency,"// Compute a reduction order for the graph by iteratively applying PBQP; // reduction rules. Locally optimal rules are applied whenever possible (R0,; // R1, R2). If no locally-optimal rules apply then any conservatively; // allocatable node is reduced. Finally, if no conservatively allocatable; // node exists then the node with the lowest spill-cost:degree ratio is; // selected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h:245,reduce,reduced,245,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h,1,['reduce'],['reduced']
Energy Efficiency,// Compute all the scheduling dependencies between nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:19,schedul,scheduling,19,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Compute energy loss in detector's material; // cf Bethe Bloch formula",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:11,energy,energy,11,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,1,['energy'],['energy']
Energy Efficiency,// Compute statistics about the memory allocated for identifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp:39,allocate,allocated,39,interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Compute the fall through gains when move NewTop before OldTop.; //; // In following diagram, edges marked as ""-"" are reduced fallthrough, edges; // marked as ""+"" are increased fallthrough, this function computes; //; // SUM(increased fallthrough) - SUM(decreased fallthrough); //; // |; // | -; // V; // --->OldTop; // | .; // | .; // +| . +; // | Pred --->; // | |-; // | V; // --- NewTop <---; // |-; // V; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:120,reduce,reduced,120,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Compute the high known-0 bits by multiplying the unsigned max of each side.; // Conservatively, M active bits * N active bits results in M + N bits in the; // result. But if we know a value is a power-of-2 for example, then this; // computes one more leading zero.; // TODO: This could be generalized to number of sign bits (negative numbers).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/KnownBits.cpp:198,power,power-of-,198,interpreter/llvm-project/llvm/lib/Support/KnownBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/KnownBits.cpp,1,['power'],['power-of-']
Energy Efficiency,// Compute the number of reduced taken branches if Pred falls through to BB; // instead of another successor. Then compare it with threshold.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:25,reduce,reduced,25,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Compute the ordering we will process the inputs: the rough heuristic here; // is to sort them per size so that the largest module get schedule as soon as; // possible. This is purely a compile-time optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:137,schedul,schedule,137,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Compute the required allocation space for each different type of sections; // (code, read-only data, read-write data) assuming that all sections are; // allocated with the max alignment. Note that we cannot compute with the; // individual alignments of the sections, because then the required size; // depends on the order, in which the sections are allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:156,allocate,allocated,156,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// Compute the schedule time for the instruction, which is based; // upon the scheduled time for any predecessors/successors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:15,schedul,schedule,15,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"// ComputeHash - Compute a hash value for X, using TempID to; // compute a temporary ID if necessary. The default implementation; // just calls Profile and does a regular hash computation.; // Implementations can override this to provide more efficient; // implementations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:243,efficient,efficient,243,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,1,['efficient'],['efficient']
Energy Efficiency,// Computes the idealized ProcRes Unit pressure. This is the expected; // distribution if the CPU scheduler can distribute the load as evenly as; // possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.h:98,schedul,scheduler,98,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.h,1,['schedul'],['scheduler']
Energy Efficiency,"// Computing 2nd power",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:17,power,power,17,hist/hist/src/TGraphSmooth.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx,3,['power'],['power']
Energy Efficiency,"// Conditions only allowing a 't' are those with no set bit except; // the lowest-order one that indicates the end of the sequence. In; // other words, powers of 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:152,power,powers,152,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['power'],['powers']
Energy Efficiency,"// Conditions under which the scheduler should eagerly advance the cycle:; // (1) No available instructions; // (2) All pipelines full, so available instructions must have hazards.; //; // If HazardRec is disabled, the cycle was pre-advanced before calling; // ReleasePredecessors. In that case, IssueCount should remain 0.; //; // Check AvailableQueue after ReleasePredecessors in case of zero latency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:30,schedul,scheduler,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// Consider change to reg pressure from scheduling; // this SU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp:40,schedul,scheduling,40,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Consider different header search and diagnostic options to create; // different modules. This avoids the unsound aliasing of module PCMs.; //; // TODO: Implement diagnostic bucketing to reduce the impact of strict; // context hashing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:189,reduce,reduce,189,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Consider initializing the array by copying from a global. For this to be; // more efficient than per-element initialization, the size of the elements; // with explicit initializers should be large enough.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:85,efficient,efficient,85,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Consider inline asm to not be a solo instruction by default.; // Inline asm will be put in a packet temporarily, but then it will be; // removed, and placed outside of the packet (before or after, depending; // on dependencies). This is to reduce the impact of inline asm as a; // ""packet splitting"" instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:243,reduce,reduce,243,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Consider replacing all frame index operands that reference; // an object allocated in the local block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:76,allocate,allocated,76,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Consists of a counter measuring a specific event and associated validation; // counters measuring execution conditions. All counters in a group are part; // of a single event group and are thus scheduled on and off the CPU as a single; // unit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h:197,schedul,scheduled,197,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h,1,['schedul'],['scheduled']
Energy Efficiency,"// Constant ISD::SRA can be performed efficiently on vXi16 vectors as we; // can replace with ISD::MULHS, creating scale factor from (NumEltBits - Amt).; // TODO: Special case handling for shift by 0/1, really we can afford either; // of these cases in pre-SSE41/XOP/AVX512 but not both.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,efficient,efficiently,38,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// Constant ISD::SRA/SRL can be performed efficiently on vXi8 vectors as we; // extend to vXi16 to perform a MUL scale effectively as a MUL_LOHI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:42,efficient,efficiently,42,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Constant ISD::SRL can be performed efficiently on vXi16 vectors as we; // can replace with ISD::MULHU, creating scale factor from (NumEltBits - Amt).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,efficient,efficiently,38,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// Constant vXi16 funnel shifts can be efficiently handled by default.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:39,efficient,efficiently,39,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// Constant values for the r_type field in a PowerPC architecture; // llvm::MachO::relocation_info or llvm::MachO::scattered_relocation_info; // structure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:45,Power,PowerPC,45,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,1,['Power'],['PowerPC']
Energy Efficiency,"// Constants are uniqued within LLVM. A ConstantExpr referring to a LDS; // global may have uses from multiple different functions as a result.; // This pass specialises LDS variables with respect to the kernel that; // allocates them.; // This is semantically equivalent to (the unimplemented as slow):; // for (auto &F : M.functions()); // for (auto &BB : F); // for (auto &I : BB); // for (Use &Op : I.operands()); // if (constantExprUsesLDS(Op)); // replaceConstantExprInFunction(I, Op);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:220,allocate,allocates,220,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['allocate'],['allocates']
Energy Efficiency,// Constants can't be pointers to dynamically allocated memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:46,allocate,allocated,46,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Constrain the register classes if converted from a vector opcode. The; // allocated regs are in an FP reg-class per previous check above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:77,allocate,allocated,77,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Construct a pass manager to run the LoopPass backedge logic. We; // need the pass manager to handle scheduling all the loop passes; // appropriately. Doing this by hand is painful and just not worth messing; // with for the moment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:103,schedul,scheduling,103,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Construct a switch statement where the condition is a check on the; // scheduling class identifier. There is a `case` for every variant class; // defined by the processor models of this target.; // Each `case` implements a number of rules to resolve (i.e. to transition from); // a variant scheduling class to another scheduling class. Rules are; // described by instances of CodeGenSchedTransition. Note that transitions may; // not be valid for all processors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp:74,schedul,scheduling,74,interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,3,['schedul'],['scheduling']
Energy Efficiency,"// Construct an fmuladd intrinsic to represent a fused mul-add of MulOp and; // Addend. Use negMul and negAdd to negate the first operand of the Mul or; // the add operand respectively. This allows fmuladd to represent a*b-c, or; // c-a*b. Patterns in LLVM should catch the negated forms and translate them to; // efficient operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:314,efficient,efficient,314,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Construct nrho acceptance sets in rho = [0,1] given ntot trials; // and put the results in already-allocated x_l and x_r.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiencyHelper.h:102,allocate,allocated,102,hist/hist/src/TEfficiencyHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiencyHelper.h,1,['allocate'],['allocated']
Energy Efficiency,// Construct the function info. We co-allocate the ArgInfos.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:38,allocate,allocate,38,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Constructor where func and model; //; // 'func' = func(xprime); // 'model' = model(xprime); //; // and; // 'xprime' is the RRV that should be connected to func and model; // (i.e. the variable that will be integrated over); // 'x' is RRV that represents the value at which the convolution is calculated; // (this variable should _not_ be connected to func and model); //; // this function returns RCBB[x',x] = f[x']*g[x-x'], i.e. the substiturion g[x'] --> g[x-x']; // is taken care internally; //; // The integral of this binding over its 1st arg yields the convolution (f (x) g)[x]; //; // allocate memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooConvIntegrandBinding.cxx:595,allocate,allocate,595,roofit/roofitcore/src/RooConvIntegrandBinding.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooConvIntegrandBinding.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// Consume a sequence of spelled tokens that didn't expand to anything.; // In the simplest case, skips spelled tokens until finding one that produced; // the NextExpanded token, and creates an empty mapping for them.; // If Drain is provided, skips remaining tokens from that file instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:225,Drain,Drain,225,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,1,['Drain'],['Drain']
Energy Efficiency,"// Contains a memory block after the class, used for type source information,; // allocated by ASTContext.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:82,allocate,allocated,82,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['allocate'],['allocated']
Energy Efficiency,"// Context for efficient generation of a dataset from a RooProdPdf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooProdGenContext.h:15,efficient,efficient,15,roofit/roofitcore/inc/RooProdGenContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooProdGenContext.h,1,['efficient'],['efficient']
Energy Efficiency,"// Context for efficiently generating a dataset from a RooSimultaneous PDF",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooSimGenContext.h:15,efficient,efficiently,15,roofit/roofitcore/inc/RooSimGenContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooSimGenContext.h,2,['efficient'],['efficiently']
Energy Efficiency,"// Convert a strict mode transition to a pseudo transition.; // This still pre-allocates registers to prevent clobbering,; // but avoids any EXEC mask changes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:79,allocate,allocates,79,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['allocate'],['allocates']
Energy Efficiency,// Convert callee-save register save/restore instruction to do stack pointer; // decrement/increment to allocate/deallocate the callee-save stack area by; // converting store/load to use pre/post increment version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:104,allocate,allocate,104,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Convert integer SPLAT_VECTOR to VMV_V_X_VL and floating-point; // SPLAT_VECTOR to VFMV_V_F_VL to reduce isel burden.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:100,reduce,reduce,100,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Convert map by label to map by index for more efficient internal use",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCompositeDataStore.cxx:49,efficient,efficient,49,roofit/roofitcore/src/RooCompositeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCompositeDataStore.cxx,1,['efficient'],['efficient']
Energy Efficiency,"// Convert shuffles that are directly supported on NEON to target-specific; // DAG nodes, instead of keeping them as shuffles and matching them again; // during code selection. This is more efficient and avoids the possibility; // of inconsistencies between legalization and selection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:190,efficient,efficient,190,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Convert shuffles that are directly supported on NEON to target-specific; // DAG nodes, instead of keeping them as shuffles and matching them again; // during code selection. This is more efficient and avoids the possibility; // of inconsistencies between legalization and selection.; // FIXME: floating-point vectors should be canonicalized to integer vectors; // of the same time so that they get CSEd properly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:190,efficient,efficient,190,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Convert to vector for efficient cross referencing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:25,efficient,efficient,25,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Converts the given 32-bit operation to a i64 operation with signed extension; // semantic to reduce the signed extension instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:96,reduce,reduce,96,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Copied and adapted from GlobalDCE.cpp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp:14,adapt,adapted,14,interpreter/cling/lib/Interpreter/DeclUnloader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp,1,['adapt'],['adapted']
Energy Efficiency,"// Copied and adapted from: ASTReaderDecl.cpp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp:14,adapt,adapted,14,interpreter/cling/lib/Interpreter/DeclUnloader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp,1,['adapt'],['adapted']
Energy Efficiency,// Copy any newly inserted live intervals into the list of regs to; // allocate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:71,allocate,allocate,71,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Copy predecessor edges from SUb to SUa to avoid the SUnits that; // SUb dependent on scheduled in-between SUb and SUa. Successor edges; // do not need to be copied from SUa to SUb since no one will depend; // on stores.; // Notice that, we don't need to care about the memory dependency as; // we won't try to cluster them if they have any memory dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:88,schedul,scheduled,88,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Copy spatial coordinates, and set energy = sqrt(mass^2 + spatial^2)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h:37,energy,energy,37,math/physics/inc/TLorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h,1,['energy'],['energy']
Energy Efficiency,"// Copy the integer registers that have not been used for argument passing; // to the argument register save area. For O32, the save area is allocated; // in the caller's stack frame, while for N32/64, it is allocated in the; // callee's stack frame.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:141,allocate,allocated,141,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// Copy the iterator source, into dest. dest should contain should contain the location of memory arena of size fgIteratorSize.; // If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement); // Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollectionProxyInfo.h:300,allocate,allocated,300,core/cont/inc/TCollectionProxyInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollectionProxyInfo.h,1,['allocate'],['allocated']
Energy Efficiency,"// Copy the object to parameter save area if it can not be entirely passed ; // by registers.; // FIXME: we only need to copy the parts which need to be passed in; // parameter save area. For the parts passed by registers, we don't need; // to copy them to the stack although we need to allocate space for them; // in parameter save area.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:287,allocate,allocate,287,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Copy the powers to working arrays",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:12,power,powers,12,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['power'],['powers']
Energy Efficiency,// Correct live-in information. Is used by post-RA scheduler; // The live-in to LayoutSucc is now all values live-in to; // JumpAroundTarget.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCFGOptimizer.cpp:51,schedul,scheduler,51,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCFGOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCFGOptimizer.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Cost functions used by SystemZPostRASchedStrategy while; // evaluating candidates.; /// Return the cost of decoder grouping for SU. If SU must start a; /// new decoder group, this is negative if this fits the schedule or; /// positive if it would mean ending a group prematurely. For normal; /// instructions this returns 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:212,schedul,schedule,212,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,1,['schedul'],['schedule']
Energy Efficiency,"// Could inserting the [W|D]LSTP cause some unintended affects? In a perfect; // world the [w|d]lstp instruction would be last instruction in the preheader; // and so it would only affect instructions within the loop body. But due to; // scheduling, and/or the logic in this pass (above), the insertion point can; // be moved earlier. So if the Loop Start isn't the last instruction in the; // preheader, and if the initial element count is smaller than the vector; // width, the Loop Start instruction will immediately generate one or more; // false lane mask which can, incorrectly, affect the proceeding MVE; // instructions in the preheader.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:238,schedul,scheduling,238,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Count common powers of 2 and remove all other powers of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:16,power,powers,16,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,2,['power'],['powers']
Energy Efficiency,// Count critical resources in the scheduled region required by SU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:35,schedul,scheduled,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduled']
Energy Efficiency,// Count each resource consumption and divide it by the number of units.; // ResMII is the max value among them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:23,consumption,consumption,23,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['consumption'],['consumption']
Energy Efficiency,// Count of the iterations of the main loop of the solver. This spans *all*; // calls to the underlying solver across the life of this object. It is; // reduced with every (non-trivial) call to the solver.; //; // We give control over the abstract count of iterations instead of concrete; // measurements like CPU cycles or time to ensure deterministic results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/WatchedLiteralsSolver.h:153,reduce,reduced,153,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/WatchedLiteralsSolver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/WatchedLiteralsSolver.h,1,['reduce'],['reduced']
Energy Efficiency,// Count scheduled resources that have been executed. Resources are; // considered executed if they become ready in the time that it takes to; // saturate any resource including the one in question. Counts are scaled; // for direct comparison with other resources. Counts can be compared with; // MOps * getMicroOpFactor and Latency * getLatencyFactor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:9,schedul,scheduled,9,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduled']
Energy Efficiency,"// Count the number of PHI nodes that will need to be updated (converted; // to MUX). Those can be later converted to predicated instructions, so; // they aren't always adding extra cost.; // KLUDGE: Also, count the number of predicate register definitions in; // each block. The scheduler may increase the pressure of these and cause; // expensive spills (e.g. bitmnp01).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:280,schedul,scheduler,280,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// Count vectorized reduced values to exclude them from final reduction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:20,reduce,reduced,20,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Cppyy::CallO allocates and constructs a string, so it must be properly destroyed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Executors.cxx:16,allocate,allocates,16,bindings/pyroot/cppyy/CPyCppyy/src/Executors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Executors.cxx,1,['allocate'],['allocates']
Energy Efficiency,"// Crash is expected, so disable crash report and symbolization to reduce; // output and avoid potentially slow symbolization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/not/not.cpp:67,reduce,reduce,67,interpreter/llvm-project/llvm/utils/not/not.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/not/not.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Create 2D adaptive kernel estimation pdf with mirroring and double bandwidth",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:13,adapt,adaptive,13,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['adapt'],['adaptive']
Energy Efficiency,"// Create a ConstantArray containing the address of each Variable within the; // kernel corresponding to LDSVarsToConstantGEP, or poison if that kernel; // does not allocate it; // TODO: Drop the ptrtoint conversion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:165,allocate,allocate,165,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Create a ResourceTracker to track JIT'd memory allocated to our; // anonymous expression -- that way we can free it after executing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:50,allocate,allocated,50,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,8,['allocate'],['allocated']
Energy Efficiency,// Create a buffer of RVV objects to allocate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:37,allocate,allocate,37,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Create a buffer of SVE objects to allocate and sort it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:37,allocate,allocate,37,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Create a bundle so these instructions won't be re-ordered by the; // post-RA scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:80,schedul,scheduler,80,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Create a dot new machine instruction to see if resources can be; // allocated. If not, bail out now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:71,allocate,allocated,71,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Create a dummy section for the ifunc stubs. It will be actually; // allocated in finalizeLoad() below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:71,allocate,allocated,71,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Create a dynamic lds variable with a name associated with the passed; // function that has the maximum alignment of any dynamic lds variable; // reachable from this kernel. Dynamic LDS is allocated after the static LDS; // allocation, possibly after alignment padding. The representative variable; // created here has the maximum alignment of any other dynamic variable; // reachable by that kernel. All dynamic LDS variables are allocated at the; // same address in each kernel in order to provide the documented aliasing; // semantics. Setting the alignment here allows this IR pass to accurately; // predict the exact constant at which it will be allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:191,allocate,allocated,191,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,3,['allocate'],['allocated']
Energy Efficiency,"// Create a io_uring instance that can hold at least `entriesHint` submission entries. The actual; // queue depth is rounded up to the next power of 2. Throws an exception if ring setup fails.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RIoUring.hxx:140,power,power,140,io/io/inc/ROOT/RIoUring.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RIoUring.hxx,1,['power'],['power']
Energy Efficiency,// Create a local thread-private variable to host the Reduce list; // from a remote lane.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:54,Reduce,Reduce,54,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Create a map of ""Register -> vector of <SlotIndex, DBG_VALUE>"".; // The SlotIndex is the slot index of the next non-debug instruction or the end; // of a BB, because DBG_VALUE's don't have slot index themselves.; // Adapted from RegisterCoalescer::buildVRegToDbgValueMap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp:219,Adapt,Adapted,219,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp,1,['Adapt'],['Adapted']
Energy Efficiency,"// Create a monitor and add the socket to it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:12,monitor,monitor,12,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,3,['monitor'],['monitor']
Energy Efficiency,"// Create a new Record representing the synthesized register. This record; // is only for consumption by CodeGenRegister, it is not added to the; // RecordKeeper.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:90,consumption,consumption,90,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['consumption'],['consumption']
Energy Efficiency,// Create a splat vector with the new value and compare this to the vector; // we want to reduce.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:90,reduce,reduce,90,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Create a stack object covering all stack doublewords occupied; // by the argument. If the argument is (fully or partially) on; // the stack, or if the argument is fully in registers but the; // caller has allocated the parameter save anyway, we can refer; // directly to the caller's stack frame. Otherwise, create a; // local copy in our own frame.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:208,allocate,allocated,208,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Create a struct to hold the ModuleScopeVariables; // Replace all uses of those variables from non-kernel functions with the; // new struct instance Replace only the uses from kernel functions that will; // allocate this instance. That is a space optimisation - kernels that use a; // subset of the module scope struct and do not need to allocate it for; // indirect calls will only allocate the subset they use (they do so as part; // of the per-kernel lowering).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:209,allocate,allocate,209,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,3,['allocate'],['allocate']
Energy Efficiency,// Create an UnwindHelp object.; // The UnwindHelp object is allocated at the start of the fixed object area,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:61,allocate,allocated,61,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Create an analysis class that is derived from `DataflowAnalysis`. This is an; // SFINAE adapter that allows us to call two different variants of constructor; // (either with or without the optional `Environment` parameter).; // FIXME: Make all classes derived from `DataflowAnalysis` take an `Environment`; // parameter in their constructor so that we can get rid of this abomination.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h:91,adapt,adapter,91,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h,1,['adapt'],['adapter']
Energy Efficiency,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:572,schedul,scheduled,572,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,3,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,// Create context for a subexpression that occurs in a position that; // should be reduced lazily. (e.g. code body).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h:83,reduce,reduced,83,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,1,['reduce'],['reduced']
Energy Efficiency,"// Create following instructions and multiple basic blocks.; //; // thisBB:; // brge.l.t %sp, %sl, sinkBB; // syscallBB:; // ld %s61, 0x18(, %tp) // load param area; // or %s62, 0, %s0 // spill the value of %s0; // lea %s63, 0x13b // syscall # of grow; // shm.l %s63, 0x0(%s61) // store syscall # at addr:0; // shm.l %sl, 0x8(%s61) // store old limit at addr:8; // shm.l %sp, 0x10(%s61) // store new limit at addr:16; // monc // call monitor; // or %s0, 0, %s62 // restore the value of %s0; // sinkBB:; // Create new MBB",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp:434,monitor,monitor,434,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp,1,['monitor'],['monitor']
Energy Efficiency,"// Create function stubs for both PLT and GOT references, regardless of; // whether the GOT reference is to data or code. The stub contains the; // full address of the symbol, as needed by GOT references, and the; // executable part only adds an overhead of 8 bytes.; //; // We could try to conserve space by allocating the code and data; // parts of the stub separately. However, as things stand, we allocate; // a stub for every relocation, so using a GOT in JIT code should be; // no less space efficient than using an explicit constant pool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:401,allocate,allocate,401,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,2,"['allocate', 'efficient']","['allocate', 'efficient']"
Energy Efficiency,"// Create globals to stand in for byte arrays and masks. These never actually; // get initialized, we RAUW and erase them later in allocateByteArrays() once; // we know the offset and mask to use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:131,allocate,allocateByteArrays,131,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['allocate'],['allocateByteArrays']
Energy Efficiency,"// Create stack allocated handle (__tgt_async_info) at the beginning of the; // function. Used for storing information of the async transfer, allowing to; // wait on it later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:16,allocate,allocated,16,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Create the canvas colors early so they are allocated before; // any color table expensive bitmaps get allocated in GUI routines (like; // creation of XPM bitmaps).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:46,allocate,allocated,46,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,4,['allocate'],['allocated']
Energy Efficiency,"// Create the new global variable. The contents of the allocated memory is; // undefined initially, so initialize with an undef value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:55,allocate,allocated,55,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Create the register. The code to initialize it is inserted later,; // by the M68kGlobalBaseReg pass (below).; //; // NOTE; // Normally M68k uses A5 register as global base pointer but this will; // create unnecessary spill if we use less then 4 registers in code; since A5; // is callee-save anyway we could try to allocate caller-save first and if; // lucky get one, otherwise it does not really matter which callee-save to; // use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp:318,allocate,allocate,318,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Creating RooKeysPdf and RooNDKeysPdf with adaptive kernel and no; // mirroring for both weighted and unweighted datasets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooKeysPdf.cxx:45,adapt,adaptive,45,roofit/roofit/test/testRooKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooKeysPdf.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// Creation of histogram for particle's energy loss",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/RootShower.cxx:40,energy,energy,40,test/RootShower/RootShower.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/RootShower.cxx,1,['energy'],['energy']
Energy Efficiency,"// Critical Energy for current material (in MeV)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.h:12,Energy,Energy,12,test/RootShower/MyDetector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.h,1,['Energy'],['Energy']
Energy Efficiency,// Critical resource consumption of the best candidate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:21,consumption,consumption,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['consumption'],['consumption']
Energy Efficiency,// Currently we only catch the situation when compare gets scheduled; // before preceding call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:59,schedul,scheduled,59,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Currently, the default schedule it static.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:26,schedul,schedule,26,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Custom PPC PostRA specific scheduling here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:30,schedul,scheduling,30,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Custom lower scalar memory access, up to 8 bytes, for:; // - non-power-of-2 MemSizes; // - unaligned 2 or 8 byte MemSizes for MIPS32r5 and older",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:68,power,power-of-,68,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,1,['power'],['power-of-']
Energy Efficiency,"// D is a power-of-two if D0 is one. This includes INT_MIN.; // If all divisors are power-of-two, we will prefer to avoid the fold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:10,power,power-of-two,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,['power'],['power-of-two']
Energy Efficiency,"// D is a power-of-two if D0 is one.; // If all divisors are power-of-two, we will prefer to avoid the fold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:10,power,power-of-two,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,['power'],['power-of-two']
Energy Efficiency,// D1. [Normalize.] Set d = b / (v[n-1] + 1) and multiply all the digits of; // u and v by d. Note that we have taken Knuth's advice here to use a power; // of 2 value for d such that d * v[n-1] >= b/2 (b is the base). A power of; // 2 allows us to shift instead of multiply and it is easy to determine the; // shift amount from the leading zeros. We are basically normalizing the u; // and v so that its high bits are shifted to the top of v's range without; // overflow. Note that this can require an extra word in u so that u must; // be of length m+n+1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:147,power,power,147,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,2,['power'],['power']
Energy Efficiency,// DAG SUnits are stored using original region's order; // so just use SUnits as the restoring schedule,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp:95,schedul,schedule,95,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,1,['schedul'],['schedule']
Energy Efficiency,// DSB and ISB also are scheduling barriers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:24,schedul,scheduling,24,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// D_SELECT substitutes two SELECT nodes that goes one after another and; // have the same condition operand. On machines which don't have; // conditional-move instruction, it reduces unnecessary branch instructions; // which are result of using two diamond patterns that are result of two; // SELECT pseudo instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:176,reduce,reduces,176,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// De-activate monitor (will be activated in Collect)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:15,monitor,monitor,15,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['monitor'],['monitor']
Energy Efficiency,"// Deallocate character arrays allocated for variable-length array columns",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/fitsio/src/TFITS.cxx:31,allocate,allocated,31,graf2d/fitsio/src/TFITS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/fitsio/src/TFITS.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// Debug info is never a scheduling boundary. It's necessary to be explicit; // due to the special treatment of IT instructions below, otherwise a; // dbg_value followed by an IT will result in the IT instruction being; // considered a scheduling hazard, which is wrong. It should be the actual; // instruction preceding the dbg_value instruction(s), just like it is; // when debug info is not present.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:25,schedul,scheduling,25,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,4,['schedul'],['scheduling']
Energy Efficiency,"// Debug value instruction is permitted to use undefined vregs.; // This is a performance measure to skip the overhead of immediately; // pruning unused debug operands. The final undef substitution occurs; // when debug values are allocated in LDVImpl::handleDebugValue, so; // these verifications always apply after this pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:231,allocate,allocated,231,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['allocate'],['allocated']
Energy Efficiency,// DeclInfo is also allocated with a BumpPtrAllocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp:20,allocate,allocated,20,interpreter/llvm-project/clang/lib/AST/Comment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Decreases by one the number of used scheduler queue slots of every; // buffered resource in the Buffers set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:39,schedul,scheduler,39,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,1,['schedul'],['scheduler']
Energy Efficiency,// Default behaviour for schedule clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:25,schedul,schedule,25,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Defer the first tick to end of the current frame; see d3/d3#1576.; // Note the transition may be canceled after start and before the first tick!; // Note this must be scheduled before the start event; see d3/d3-transition#16!; // Assuming this is successful, subsequent callbacks go straight to tick.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:170,schedul,scheduled,170,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['schedul'],['scheduled']
Energy Efficiency,"// Defer to normal argument lowering for now. It's reasonably; // efficient. Consider doing something like ARM to handle the; // case where all args fit in registers, no varargs, no float; // or vector args.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:66,efficient,efficient,66,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Define alternate numeric integrator configuration for bin integration; // We expect bin contents to very only very slowly so a non-adaptive; // Gauss-Kronrod integrator is expected to perform well (if RooFitMore is available)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooXYChi2Var.cxx:134,adapt,adaptive,134,roofit/roofitcore/src/RooXYChi2Var.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooXYChi2Var.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// Define how to hold a class type object, such as a string.; // Originally this code inherited from std::vector. In transitioning to a new; // API for command line options we should change this. The new implementation; // of this list_storage specialization implements the minimum subset of the; // std::vector API required for all the current clients.; //; // FIXME: Reduce this API to a more narrow subset of std::vector; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:369,Reduce,Reduce,369,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,1,['Reduce'],['Reduce']
Energy Efficiency,"// Define the root of the tree for user-accessible memory. C and C++; // give special powers to char and certain similar types. However,; // these special powers only cover user-accessible memory, and doesn't; // include things like vtables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp:86,power,powers,86,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,2,['power'],['powers']
Energy Efficiency,"// Defines an interface used to traverse SExprs. Traversals have been made as; // generic as possible, and are intended to handle any kind of pass over the; // AST, e.g. visitors, copying, non-destructive rewriting, destructive; // (in-place) rewriting, hashing, typing, etc.; //; // Traversals implement the functional notion of a ""fold"" operation on SExprs.; // Each SExpr class provides a traverse method, which does the following:; // * e->traverse(v):; // // compute a result r_i for each subexpression e_i; // for (i = 1..n) r_i = v.traverse(e_i);; // // combine results into a result for e, where X is the class of e; // return v.reduceX(*e, r_1, .. r_n).; //; // A visitor can control the traversal by overriding the following methods:; // * v.traverse(e):; // return v.traverseByCase(e), which returns v.traverseX(e); // * v.traverseX(e): (X is the class of e); // return e->traverse(v).; // * v.reduceX(*e, r_1, .. r_n):; // compute a result for a node of type X; //; // The reduceX methods control the kind of traversal (visitor, copy, etc.).; // They are defined in derived classes.; //; // Class R defines the basic interface types (R_SExpr).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h:637,reduce,reduceX,637,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,3,['reduce'],['reduceX']
Energy Efficiency,// Defines symbolic names for the PowerPC instructions.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:34,Power,PowerPC,34,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,1,['Power'],['PowerPC']
Energy Efficiency,// Deinterleave complex vector outside of loop so that it can be finally; // reduced,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:77,reduce,reduced,77,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Delete FileEntry objects corresponding to content caches. Since the actual; // content cache objects are bump pointer allocated, we just have to run the; // dtors, but we call the deallocate method for completeness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:121,allocate,allocated,121,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Delete allocated objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/Getline.cxx:10,allocate,allocated,10,core/textinput/src/Getline.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/Getline.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// Delete code list array, if allocated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAICRegistry.cxx:30,allocate,allocated,30,roofit/roofitcore/src/RooAICRegistry.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAICRegistry.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// Delete objects from directory list, this in turn, recursively closes all; // sub-directories (that were allocated on the heap); // if this dir contains subdirs, we must use the slow option for Delete!; // we must avoid ""slow"" as much as possible, in particular Delete(""slow""); // with a large number of objects (eg >10^5) would take for ever.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx:107,allocate,allocated,107,core/base/src/TDirectory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx,2,['allocate'],['allocated']
Energy Efficiency,"// Delete the instructions backwards, as it has a reduced likelihood of having; // to update as many def-use and use-def chains. Start after the terminator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:50,reduce,reduced,50,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Delete the instructions backwards, as it has a reduced likelihood of; // having to update as many def-use and use-def chains.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:50,reduce,reduced,50,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,2,['reduce'],['reduced']
Energy Efficiency,"// Delete the instructions backwards, as it has a reduced likelihood of; // having to update as many def-use and use-def chains.; //; // Because we add to ToRemove during fusion we can't guarantee that defs; // are before uses. Change uses to poison temporarily as these should get; // removed as well.; //; // For verification, we keep track of where we changed uses to poison in; // PoisonedInsts and then check that we in fact remove them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:50,reduce,reduced,50,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Depth is expected to be a power-of-2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:29,power,power-of-,29,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,1,['power'],['power-of-']
Energy Efficiency,// Depth threshold above which we can efficiently use variable mask shuffles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,efficient,efficiently,38,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Destroy an array of pointers to not-pre-allocated objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:43,allocate,allocated,43,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// Destroy an array of pre-allocated objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:27,allocate,allocated,27,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// Destroy old elements: useless work for trivial types, but in case the element type's constructor; // allocates memory we need to release it here to avoid memleaks (e.g. if this is an RVec<RVec<int>>)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:104,allocate,allocates,104,tree/ntuple/v7/src/RField.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx,1,['allocate'],['allocates']
Energy Efficiency,// Detach schedule from SUnits and interleave it with debug values.; // Returned schedule becomes independent of DAG state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp:10,schedul,schedule,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,2,['schedul'],['schedule']
Energy Efficiency,// Detect the distribute schedule kind and chunk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:25,schedul,schedule,25,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Detect the loop schedule kind and chunk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:19,schedul,schedule,19,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Determine if it's worth trying to allocate this reg, given the; // CostPerUseLimit; // TODO: this is a heuristic component we could consider learning, too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:37,allocate,allocate,37,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,1,['allocate'],['allocate']
Energy Efficiency,// Determine more-or-less what the proposed schedule (reversed) is going to; // be; it might not be quite the same because the within-cycle ordering; // created by SMSchedule depends upon changes to help with address offsets and; // the like.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:44,schedul,schedule,44,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Determine the CPU to schedule for.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:24,schedul,schedule,24,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Determine the longest nop which can be efficiently decoded for the given; // target cpu. 15-bytes is the longest single NOP instruction, but some; // platforms can't decode the longest forms efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp:42,efficient,efficiently,42,interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,2,['efficient'],['efficiently']
Energy Efficiency,// Determine the size of the remaining vector we need to reduce.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:57,reduce,reduce,57,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,2,['reduce'],['reduce']
Energy Efficiency,"// Determine whether this is a lambda closure type, so that we can; // allocate the appropriate DefinitionData structure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:71,allocate,allocate,71,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Determine which values will be loop-carried after the schedule is; // applied,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:57,schedul,schedule,57,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// DiagProd returns the product of matrix diagonal elements in d1 and d2. d1; // is a mantissa and d2 an exponent for powers of 2. This is why we are; // using this specific formula to validate the method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/test/testMatrixTDecomp.cxx:118,power,powers,118,math/matrix/test/testMatrixTDecomp.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/test/testMatrixTDecomp.cxx,1,['power'],['powers']
Energy Efficiency,// Didn't find the reg.; // Mark the register and any aliases as allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:65,allocate,allocated,65,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,2,['allocate'],['allocated']
Energy Efficiency,// Disallow vcc_hi allocation in wave32. It may be allocated but most likely; // will result in bugs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:51,allocate,allocated,51,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Distinguish if we are called from scheduler or hazard recognizer,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.h:37,schedul,scheduler,37,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.h,1,['schedul'],['scheduler']
Energy Efficiency,"// Division must be by power-of-2, but not the minimum signed value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:23,power,power-of-,23,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['power'],['power-of-']
Energy Efficiency,"// Divisor must be a power of two.; // If OrZero is false, cannot guarantee induction variable is non-zero after; // division, same for Shr, unless it is exact division.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:21,power,power,21,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['power'],['power']
Energy Efficiency,"// Do a first pass over the arguments to determine whether the ABI; // guarantees that our caller has allocated the parameter save area; // on its stack frame. In the ELFv1 ABI, this is always the case;; // in the ELFv2 ABI, it is true if this is a vararg function or if; // any parameter is located in a stack slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:102,allocate,allocated,102,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Do a multibyte AVR shift. Insert shift instructions and put the output; // registers in the Regs array.; // Because AVR does not have a normal shift instruction (only a single bit shift; // instruction), we have to emulate this behavior with other instructions.; // It first tries large steps (moving registers around) and then smaller steps; // like single bit shifts.; // Large shifts actually reduce the number of shifted registers, so the below; // algorithms have to work independently of the number of registers that are; // shifted.; // For more information and background, see this blogpost:; // https://aykevl.nl/2021/02/avr-bitshift",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:399,reduce,reduce,399,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Do alignment, specialized to power of 2 and for signed ints,; // avoiding having to do a C-style cast from uint_64t to int when; // using alignTo from include/llvm/Support/MathExtras.h.; // FIXME: Move this function to include/MathExtras.h?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:32,power,power,32,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,1,['power'],['power']
Energy Efficiency,"// Do backward checking.; // For all cases above, we need a backward checking to filter out edges that; // are not 'strongly' biased.; // BB Pred; // \ /; // Succ; // We select edge BB->Succ if; // freq(BB->Succ) > freq(Succ) * HotProb; // i.e. freq(BB->Succ) > freq(BB->Succ) * HotProb + freq(Pred->Succ) *; // HotProb; // i.e. freq((BB->Succ) * (1 - HotProb) > freq(Pred->Succ) * HotProb; // Case 1 is covered too, because the first equation reduces to:; // prob(BB->Succ) > HotProb. (freq(Succ) = freq(BB) for a triangle)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:444,reduce,reduces,444,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Do final scheduling after all other optimizations, to get an; // optimal input for the decoder (branch relaxation must happen; // after block placement).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:12,schedul,scheduling,12,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Do not allocate any new DIE if definition DIE is already met.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:10,allocate,allocate,10,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Do not allocate the buffer yet, in case of IMT we only need it once the task is started.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:10,allocate,allocate,10,tree/ntuple/v7/src/RPageSinkBuf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx,1,['allocate'],['allocate']
Energy Efficiency,// Do not attempt to relax schedule even more if we are already spilling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:27,schedul,schedule,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Do not capture schedule-clause expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:18,schedul,schedule-clause,18,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['schedul'],['schedule-clause']
Energy Efficiency,"// Do not generate pre-inc forms for specific loads that feed scalar_to_vector; // instructions because we can fold these into a more efficient instruction; // instead, (such as LXSD).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:134,efficient,efficient,134,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Do not increase size of registers beyond dword, we would need to allocate; // adjacent registers and constraint regalloc more than needed.; // Always allow dword coalescing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:68,allocate,allocate,68,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Do not let this transformation reduce the number of volatile loads.; // Be conservative for atomics for the moment; // TODO: This does appear to be legal for unordered atomics (see D66309),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:34,reduce,reduce,34,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Do not remove the paste operator if it is the one before __VA_OPT__; // (and we are still processing tokens within VA_OPT). We handle the case; // of removing the paste operator if __VA_OPT__ reduces to the notional; // placemarker above when we encounter the closing paren of VA_OPT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:195,reduce,reduces,195,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['reduce'],['reduces']
Energy Efficiency,// Do not schedule this analysis. Lower level analysis; // passes are run on the fly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:10,schedul,schedule,10,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Do not tail call opt if any parameters need to be passed indirectly.; // Since long doubles (fp128) and i128 are larger than 2*XLEN, they are; // passed indirectly. So the address of the value will be passed in a; // register, or if not available, then the address is put on the stack. In; // order to pass indirectly, space on the stack often needs to be allocated; // in order to store the value. In this case the CCInfo.getNextStackOffset(); // != 0 check is not enough and we need to check if any CCValAssign ArgsLocs; // are passed CCValAssign::Indirect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:359,allocate,allocated,359,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Do not tail call opt if the stack is used to pass parameters.; // 64-bit targets have a slightly higher limit since the ABI requires; // to allocate some space even when all the parameters fit inside registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:143,allocate,allocate,143,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Do not untrack ValueAsMetadata references for DIArgLists, as they have; // already been more efficiently untracked above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp:96,efficient,efficiently,96,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Do not use WillCreateCycle, it assumes SD scheduling.; // If Pred is reachable from Succ, then the edge creates a cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:45,schedul,scheduling,45,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Do not use resize() + shrink_to_fit() to free memory occupied by dies.; // shrink_to_fit() is a *non-binding* request to reduce capacity() to size().; // It depends on the implementation whether the request is fulfilled.; // Create a new vector with a small capacity and assign it to the DieArray to; // have previous contents freed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp:124,reduce,reduce,124,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Do not waste time on a node that is already scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:47,schedul,scheduled,47,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,2,['schedul'],['scheduled']
Energy Efficiency,"// Do nothing. We want the LOOP setup instruction to stay in the *old*; // preheader, so we can use BDZ in the prologs to adapt the loop trip count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:122,adapt,adapt,122,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['adapt'],['adapt']
Energy Efficiency,"// Do the ""real"" scheduling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,schedul,scheduling,17,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Do the equivalent of PP.getSpelling(Tok) except for the parts that would; // allocate memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:80,allocate,allocate,80,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Do we need to allocate a new node?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:17,allocate,allocate,17,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['allocate'],['allocate']
Energy Efficiency,"// Don't add a zero-latency instruction to the Ready queue.; // A zero-latency instruction doesn't consume any scheduler resources. That is; // because it doesn't need to be executed, and it is often removed at register; // renaming stage. For example, register-register moves are often optimized at; // register renaming stage by simply updating register aliases. On some; // targets, zero-idiom instructions (for example: a xor that clears the value; // of a register) are treated specially, and are often eliminated at register; // renaming stage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/Scheduler.cpp:111,schedul,scheduler,111,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/Scheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/Scheduler.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// Don't add the same reg twice (Hints_MRI may contain multiple virtual; // registers allocated to the same physreg).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:86,allocate,allocated,86,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Don't allocate the incoming reg save area.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:9,allocate,allocate,9,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Don't allocate the new LocNo until it is needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:9,allocate,allocate,9,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Don't attempt to combine non power of 2 loads or unaligned loads when; // subtarget doesn't support them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp:32,power,power,32,interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp,1,['power'],['power']
Energy Efficiency,"// Don't attempt to schedule around any instruction that defines; // a stack-oriented pointer, as it's unlikely to be profitable. This; // saves compile time, because it doesn't require every single; // stack slot reference to depend on the instruction that does the; // modification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:20,schedul,schedule,20,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Don't attempt to schedule around any instruction that defines; // a stack-oriented pointer, as it's unlikely to be profitable. This; // saves compile time, because it doesn't require every single; // stack slot reference to depend on the instruction that does the; // modification.; // Calls don't actually change the stack pointer, even if they have imp-defs.; // No ARM calling conventions change the stack pointer. (X86 calling; // conventions sometimes do).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:20,schedul,schedule,20,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Don't bother creating a non-power-2 sextload, it will likely be broken up; // anyway for most targets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:31,power,power-,31,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['power'],['power-']
Energy Efficiency,// Don't bother maintaining accurate LiveIntervals for registers which were; // already allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:88,allocate,allocated,88,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Don't bother to actually allocate the result if we're just trying to; // determine whether it would be valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:28,allocate,allocate,28,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Don't bother trying to improve ILP in lower RP regions if occupancy has not; // been dropped. All regions will have already been scheduled with the ideal; // occupancy targets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:132,schedul,scheduled,132,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Don't break ""store (load float*)"" pattern, this pattern will be combined; // to ""store (load int32)"" in later InstCombine pass. See function; // combineLoadToOperationType. On PowerPC, loading a float point takes more; // cycles than loading a 32 bit integer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:179,Power,PowerPC,179,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// Don't break FMA, PowerPC prefers FMA.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,Power,PowerPC,20,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// Don't call the normal error handler. It may allocate memory. Directly write; // an OOM to stderr and abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp:47,allocate,allocate,47,interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Don't generate reassociations for the base register of a value that; // may generate a post-increment operator. The reason is that the; // reassociations cause extra base+register formula to be created,; // and possibly chosen, but the post-increment is more efficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:262,efficient,efficient,262,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Don't go into unreachable blocks. They may contain instructions with; // dependency cycles which confuse the final scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:118,schedul,scheduling,118,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Don't produce extloads from sub 32-bit types. SI doesn't have scalar; // extloads, so doing one requires using a buffer_load. In cases where we; // still couldn't use a scalar load, using the wider load shouldn't really; // hurt anything.; // If the old size already had to be an extload, there's no harm in continuing; // to reduce the width.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:329,reduce,reduce,329,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Don't reduce bundled instructions or pseudo operations,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:9,reduce,reduce,9,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Don't reduce load width if it would prevent us from combining a shift into; // the offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:9,reduce,reduce,9,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Don't report a type mismatch if there is no actual mismatch, only a; // type missing, to reduce noise:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:92,reduce,reduce,92,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Don't set the probability of taking the edge from latch to loop header; // to less than 1:1 ratio (meaning Weight should not be lower than; // SubWeight), as this could significantly reduce the loop's hotness,; // which would be incorrect in the case of underestimating the trip count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:186,reduce,reduce,186,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Don't touch opaque constants. Also, ignore zero and power-of-2; // multiplies. Those will get folded later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:55,power,power-of-,55,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,"// Don't track allocated autorelease pools, as it is okay to prematurely; // exit a method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:15,allocate,allocated,15,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Don't use the allocation hints for ISAFuture.; // The WACC registers used in ISAFuture are unlike the ACC registers on; // Power 10 and so this logic to register allocation hints does not apply.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:126,Power,Power,126,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,1,['Power'],['Power']
Energy Efficiency,"// Don't write comments to BMI to reduce the size of BMI.; // If language services (e.g., clangd) want such abilities,; // we can offer a special option then.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:34,reduce,reduce,34,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Double (and, for targets supporting AIX `power` alignment, long double) and; // long long should be naturally aligned (despite requiring less alignment) if; // possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:44,power,power,44,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['power'],['power']
Energy Efficiency,// Drain the WorkList to recursively process any new implicit defs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ProcessImplicitDefs.cpp:3,Drain,Drain,3,interpreter/llvm-project/llvm/lib/CodeGen/ProcessImplicitDefs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ProcessImplicitDefs.cpp,1,['Drain'],['Drain']
Energy Efficiency,// DstReg has an earlyclobber so the register allocator will allocate them in; // separate registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:61,allocate,allocate,61,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,2,['allocate'],['allocate']
Energy Efficiency,// Dump the schedule before we invalidate and remap all its instructions.; // Stash it in a string so we can print it if we found an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:12,schedul,schedule,12,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Duplicate V into Data as byte vector to reduce number of; // writes done. As such, do endian conversion here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:43,reduce,reduce,43,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// During context-sensitive analysis, a struct may be allocated in one; // function, but its field accessed in a function lower in the stack than; // the allocation. Since we only collect fields used in the function where; // the allocation occurs, we can't apply that filter when performing; // context-sensitive analysis. But, this only applies to storage locations,; // since field access it not allowed to fail. In contrast, field *values*; // don't need this allowance, since the API allows for uninitialized fields.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp:54,allocate,allocated,54,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// During macro pre-expansion, check the syntax now but put the tokens back; // into the token stream for later consumption. Same as Handle_Pragma.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:112,consumption,consumption,112,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['consumption'],['consumption']
Energy Efficiency,"// During scheduling, the NodeId field of SDNode is used to map SDNodes; // to their associated SUnits by holding SUnits table indices. A value; // of -1 means the SDNode does not yet have an associated SUnit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:10,schedul,scheduling,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// During the 'Deep' part of the search we will call GetClassSharedLibsForModule; // (when module are enabled) which might end up calling AutoParsing but; // that should only be for the cases where the library has no generated pcm; // and in that case a rootmap should be available.; // This avoids a very costly operation (for generally no gain) but reduce the; // quality of the search (i.e. bad in case of library with no pcm and no rootmap; // file).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:351,reduce,reduce,351,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// During the traversal of the debug information sections, we created the; // logical lines representing the disassembled instructions from the text; // section and the logical lines representing the line records from the; // debug line section. Using the ranges associated with the logical scopes,; // we will allocate those logical lines to their logical scopes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVBinaryReader.cpp:311,allocate,allocate,311,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVBinaryReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVBinaryReader.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Dynamic scheduling of the outer loop (dynamic, guided, auto, runtime).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:11,schedul,scheduling,11,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// E points to the start of the padding bytes.; // E + Addend points to the instruction to be aligned by removing padding.; // Alignment is the smallest power of 2 strictly greater than Addend.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp:153,power,power,153,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp,1,['power'],['power']
Energy Efficiency,// ENDBR instructions should not be scheduled around.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:36,schedul,scheduled,36,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Each processor resource is associated with a so-called processor resource; // mask. This vector allows to correlate processor resource IDs with processor; // resource masks. There is exactly one element per each processor resource; // declared by the scheduling model.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:254,schedul,scheduling,254,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,2,['schedul'],['scheduling']
Energy Efficiency,"// Each region at MinOccupancy will have their own list of trivially; // rematerializable instructions we can remat to reduce RP. The list maps an; // instruction to the position we should remat before, usually the MI using; // the rematerializable instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:119,reduce,reduce,119,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['reduce'],['reduce']
Energy Efficiency,"// Each tail call may have to adjust the stack by a different amount, so; // this information must travel along with the operation for eventual; // consumption by emitEpilogue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:148,consumption,consumption,148,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['consumption'],['consumption']
Energy Efficiency,"// Early exit if no callee saved registers are modified!; // Now that we know which registers need to be saved and restored, allocate; // stack slots for them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:125,allocate,allocate,125,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Early exit if there is no need to allocate on the stack,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp:37,allocate,allocate,37,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,2,['allocate'],['allocate']
Energy Efficiency,// Early exit if there is no need to allocate space in the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:37,allocate,allocate,37,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Early exit if we exhaust the possible powers of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:41,power,powers,41,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['powers']
Energy Efficiency,// Early return if there is no virtual register to be allocated to a; // physical register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:54,allocate,allocated,54,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Early-exit if the big chunk couldn't be a power-of-two number of runs; // EORed with another single run.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp:45,power,power-of-two,45,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// Easy work scheduling: one file per slot. We skip empty files (files without entries).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:13,schedul,scheduling,13,tree/dataframe/src/RNTupleDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx,1,['schedul'],['scheduling']
Energy Efficiency,// Edges to all callees in the profiled call stacks.; // TODO: Should this be a map (from Callee node) for more efficient lookup?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:112,efficient,efficient,112,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Edges to all callers in the profiled call stacks.; // TODO: Should this be a map (from Caller node) for more efficient lookup?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:112,efficient,efficient,112,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Efficiently ignore non-fp insts!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:3,Efficient,Efficiently,3,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,1,['Efficient'],['Efficiently']
Energy Efficiency,"// Elements of composite types usually have back to the type, creating; // uniquing cycles. Distinct nodes are more efficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:116,efficient,efficient,116,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Emit ""IV = LB"" (in case of static schedule, we have already calculated new; // LB for loop condition and emitted it above).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:37,schedul,schedule,37,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Emit a call to the new function, passing in: *pointer to struct (if; // aggregating parameters), or plan inputs and allocated memory for outputs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:119,allocate,allocated,119,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Emit code to correctly handle reused reduced values, if required.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:40,reduce,reduced,40,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Emit following codes. It is not possible to insert multiple; // BasicBlocks in PEI pass, so we emit two pseudo instructions here.; //; // EXTEND_STACK // pseudo instrcution; // EXTEND_STACK_GUARD // pseudo instrcution; //; // EXTEND_STACK pseudo will be converted by ExpandPostRA pass into; // following instructions with multiple basic blocks later.; //; // thisBB:; // brge.l.t %sp, %sl, sinkBB; // syscallBB:; // ld %s61, 0x18(, %tp) // load param area; // or %s62, 0, %s0 // spill the value of %s0; // lea %s63, 0x13b // syscall # of grow; // shm.l %s63, 0x0(%s61) // store syscall # at addr:0; // shm.l %sl, 0x8(%s61) // store old limit at addr:8; // shm.l %sp, 0x10(%s61) // store new limit at addr:16; // monc // call monitor; // or %s0, 0, %s62 // restore the value of %s0; // sinkBB:; //; // EXTEND_STACK_GUARD pseudo will be simply eliminated by ExpandPostRA; // pass. This pseudo is required to be at the next of EXTEND_STACK; // pseudo in order to protect iteration loop in ExpandPostRA.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:728,monitor,monitor,728,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,1,['monitor'],['monitor']
Energy Efficiency,"// Emit outer loop.; // Same behavior as a OMPForOuterLoop, except that schedule cannot be; // dynamic; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:72,schedul,schedule,72,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Emit outer loop.; //; // OpenMP [2.7.1, Loop Construct, Description, table 2-1]; // When schedule(dynamic,chunk_size) is specified, the iterations are; // distributed to threads in the team in chunks as the threads request them.; // Each thread executes a chunk of iterations, then requests another chunk,; // until no chunks remain to be distributed. Each chunk contains chunk_size; // iterations, except for the last chunk to be distributed, which may have; // fewer iterations. When no chunk_size is specified, it defaults to 1.; //; // When schedule(guided,chunk_size) is specified, the iterations are assigned; // to threads in the team in chunks as the executing threads request them.; // Each thread executes a chunk of iterations, then requests another chunk,; // until no chunks remain to be assigned. For a chunk_size of 1, the size of; // each chunk is proportional to the number of unassigned iterations divided; // by the number of threads in the team, decreasing to 1. For a chunk_size; // with value k (greater than 1), the size of each chunk is determined in the; // same way, with the restriction that the chunks do not contain fewer than k; // iterations (except for the last chunk to be assigned, which may have fewer; // than k iterations).; //; // When schedule(auto) is specified, the decision regarding scheduling is; // delegated to the compiler and/or runtime system. The programmer gives the; // implementation the freedom to choose any possible mapping of iterations to; // threads in the team.; //; // When schedule(runtime) is specified, the decision regarding scheduling is; // deferred until run time, and the schedule and chunk size are taken from the; // run-sched-var ICV. If the ICV is set to auto, the schedule is; // implementation defined; //; // while(__kmpc_dispatch_next(&LB, &UB)) {; // idx = LB;; // while (idx <= UB) { BODY; ++idx;; // __kmpc_dispatch_fini_(4|8)[u](); // For ordered loops only.; // } // inner loop; // }; //; // OpenMP [2.7.1, Loop Cons",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:92,schedul,schedule,92,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,2,['schedul'],['schedule']
Energy Efficiency,"// Emit the ST_F16_PSEDUO instruction to store a f16 value from an MSA; // register.; //; // STF16 MSA128F16:$wd, mem_simm10:$addr; // =>; // copy_u.h $rtemp,$wd[0]; // sh $rtemp, $addr; //; // Safety: We can't use st.h & co as they would over write the memory after; // the destination. It would require half floats be allocated 16 bytes(!) of; // space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:320,allocate,allocated,320,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Emit the crash stack trace to a SmallString, put it where the system crash; // handling will find it, and also send it to stderr.; //; // The SmallString is fairly large in the hope that we don't allocate (we're; // handling a fatal signal, something is already pretty wrong, allocation; // might not work). Further, we don't use a magic static in case that's also; // borked. We leak any allocation that does occur because the program is about; // to die anyways. This is technically racy if we were handling two fatal; // signals, however if we're in that situation a race is the least of our; // worries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/PrettyStackTrace.cpp:199,allocate,allocate,199,interpreter/llvm-project/llvm/lib/Support/PrettyStackTrace.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/PrettyStackTrace.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Emit the function descriptor. This is a virtual function to allow targets; // to emit their specific function descriptor. Right now it is only used by; // the AIX target. The PowerPC 64-bit V1 ELF target also uses function; // descriptors and should be converted to use this hook as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:178,Power,PowerPC,178,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// Emit the scheduler model pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp:12,schedul,scheduler,12,interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Emit the static match table; unused classes get initialized to 0 which is; // guaranteed to be InvalidMatchClass.; //; // FIXME: We can reduce the size of this table very easily. First, we change; // it so that store the kinds in separate bit-fields for each index, which; // only needs to be the max width used for classes at that index (we also need; // to reject based on this during classification). If we then make sure to; // order the match kinds appropriately (putting mnemonics last), then we; // should only end up using a few bits for each class, especially the ones; // following the mnemonic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:139,reduce,reduce,139,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// EmitGlobalVariable - This method emits the specified global variable to the; // address specified in GlobalAddresses, or allocates new memory if it's not; // already in the map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:124,allocate,allocates,124,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,1,['allocate'],['allocates']
Energy Efficiency,// EmitSchedule - Emit the machine code in scheduled order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:43,schedul,scheduled,43,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Enable partial unrolling and runtime unrolling, but reduce the; // threshold. This partially unrolls small loops which are often; // unrolled by the PTX to SASS compiler and unrolling earlier can be; // beneficial.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:55,reduce,reduce,55,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Enabling ShouldTrackLaneMasks crashes the SI Machine Scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:56,Schedul,Scheduler,56,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['Schedul'],['Scheduler']
Energy Efficiency,// Enabling both top down and bottom up scheduling seems to give us less; // register spills than just using one of these approaches on its own.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:40,schedul,scheduling,40,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Enabling fragment coalescing reduces compiler run time when instruction; // referencing is enabled. However, it may cause LiveDebugVariables to create; // incorrect locations. Since instruction-referencing mode effectively; // bypasses LiveDebugVariables we only enable coalescing if the cl::opt flag; // has not been explicitly set and instruction-referencing is turned on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:32,reduce,reduces,32,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['reduce'],['reduces']
Energy Efficiency,// Encoding related methods of string should not fail when lossless; // encodings are used. Using lossless encodings is so frequent that ignoring; // this class of methods reduced the emitted diagnostics by about 30% on; // some projects (and all of that was false positives).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:172,reduce,reduced,172,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// End NS Internal; //////////////////////////////////////////////////////////////////////////; /// \brief Class constructor.; /// If the scheduler is active (e.g. because another TThreadExecutor is in flight, or ROOT::EnableImplicitMT() was; /// called), work with the current pool of threads.; /// If not, initialize the pool of threads, spawning nThreads. nThreads' default value, 0, initializes the; /// pool with as many logical threads as are available in the system (see NLogicalCores in RTaskArenaWrapper.cxx).; ///; /// At construction time, TThreadExecutor automatically enables ROOT's thread-safety locks as per calling; /// ROOT::EnableThreadSafety().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TThreadExecutor.cxx:138,schedul,scheduler,138,core/imt/src/TThreadExecutor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TThreadExecutor.cxx,1,['schedul'],['scheduler']
Energy Efficiency,"// Energy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/TParticle.h:3,Energy,Energy,3,montecarlo/eg/inc/TParticle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/TParticle.h,1,['Energy'],['Energy']
Energy Efficiency,"// Energy in eV",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/NdbMTReactionXS.h:3,Energy,Energy,3,test/periodic/NdbMTReactionXS.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/NdbMTReactionXS.h,1,['Energy'],['Energy']
Energy Efficiency,// Enqueue the allocated type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:15,allocate,allocated,15,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Ensure MaxVF is a power of 2; the dependence distance bound may not be.; // Note that both WidestRegister and WidestType may not be a powers of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:21,power,power,21,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['power'],"['power', 'powers']"
Energy Efficiency,// Ensure that any moving of objects within the allocated map is done before; // we process them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,allocate,allocated,48,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Ensure that any moving of objects within the allocated map is; // done before we process them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,allocate,allocated,48,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Ensure that commutative instructions that only differ by a permutation; // of their operands get the same value number by sorting the operand value; // numbers. Since all commutative instructions have two operands it is more; // efficient to sort by hand rather than using, say, std::sort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:232,efficient,efficient,232,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,2,['efficient'],['efficient']
Energy Efficiency,"// Ensure that commutative instructions that only differ by a permutation; // of their operands get the same value number by sorting the operand value; // numbers. Since commutative operands are the 1st two operands it is more; // efficient to sort by hand rather than using, say, std::sort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:231,efficient,efficient,231,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Ensure the reduction size is a power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp:34,power,power,34,interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp,1,['power'],['power']
Energy Efficiency,// Ensure we call the destructor so we release any memory allocated in the; // sets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:58,allocate,allocated,58,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Entry point for the schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h:23,schedul,schedule,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,1,['schedul'],['schedule']
Energy Efficiency,// Enum CutOffStage to keep a track whether the register allocation failed; // because of the cutoffs encountered in last chance recoloring.; // Note: This is used as bitmask. New value should be next power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:201,power,power,201,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,1,['power'],['power']
Energy Efficiency,"// Equals - Test if the profile for X would match ID, using TempID; // to compute a temporary ID if necessary. The default implementation; // just calls Profile and does a regular comparison. Implementations; // can override this to provide more efficient implementations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:246,efficient,efficient,246,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,1,['efficient'],['efficient']
Energy Efficiency,"// Erase all the elements in the later stages. Only one iteration should; // remain in the scheduled list, and it contains all the instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:91,schedul,scheduled,91,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Erase groups where every store is a full HVX vector. The reason is that; // aligning predicated stores generates complex code that may be less; // efficient than a sequence of unaligned vector stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:150,efficient,efficient,150,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Erase old expression graph, which was replaced by the reduced expression; // graph.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:57,reduce,reduced,57,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Estimate the number of operations the below transform will turn a; // constant multiply into. The number is approximately equal to the minimal; // number of powers of two that constant can be broken down to by adding; // or subtracting them.; //; // If we have taken more than 12[1] / 8[2] steps to attempt the; // optimization for a native sized value, it is more than likely that this; // optimization will make things worse.; //; // [1] MIPS64 requires 6 instructions at most to materialize any constant,; // multiplication requires at least 4 cycles, but another cycle (or two); // to retrieve the result from the HI/LO registers.; //; // [2] For MIPS32, more than 8 steps is expensive as the constant could be; // materialized in 2 instructions, multiplication requires at least 4; // cycles, but another cycle (or two) to retrieve the result from the; // HI/LO registers.; //; // TODO:; // - MaxSteps needs to consider the `VT` of the constant for the current; // target.; // - Consider to perform this optimization after type legalization.; // That allows to remove a workaround for types not supported natively.; // - Take in account `-Os, -Oz` flags because this optimization; // increases code size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:160,power,powers,160,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['power'],['powers']
Energy Efficiency,"// Evaluates an XRay record and performs accounting on it.; //; // If the record is an ENTER record it pushes the FuncID and TSC onto a; // structure representing the call stack for that function.; // If the record is an EXIT record it checks computes computes the ammount of; // time the function took to complete and then stores that information in an; // edge of the graph. If there is no matching ENTER record the function tries; // to recover by assuming that there were EXIT records which were missed, for; // example caused by tail call elimination and if the option is enabled then; // then tries to recover from this.; //; // This function will also error if the records are out of order, as the trace; // is expected to be sorted.; //; // The graph generated has an immaginary root for functions called by no-one at; // FuncId 0.; //; // FIXME: Refactor this and account subcommand to reduce code duplication.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.cpp:895,reduce,reduce,895,interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Even if we find a schedule, make sure the schedule doesn't exceed the; // allowable number of stages. We keep trying if this happens.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:21,schedul,schedule,21,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['schedul'],['schedule']
Energy Efficiency,// Evenly distribute registers among MEMCPY operations to reduce register; // pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp:58,reduce,reduce,58,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Events generated by the Scheduler when buffered resources are; // consumed/freed for an instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h:27,Schedul,Scheduler,27,interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,1,['Schedul'],['Scheduler']
Energy Efficiency,// Events generated by the Scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h:27,Schedul,Scheduler,27,interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,1,['Schedul'],['Scheduler']
Energy Efficiency,"// Eventually this can be improved by recognizing that the pixel; // buffer passed to CVPixelBufferCreateWithBytes is released via; // a callback and doing full IPA to make sure this is done correctly.; // Note that it's passed as a 'void *', so it's hard to annotate.; // FIXME: This function also has an out parameter that returns an; // allocated object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:340,allocate,allocated,340,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Every funclet allocates enough stack space for the largest outgoing call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:17,allocate,allocates,17,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['allocate'],['allocates']
Energy Efficiency,"// Every vector variant of a SIMD-enabled function has a vector length (VLEN).; // If OpenMP clause ""simdlen"" is used, the VLEN is the value of the argument; // of that clause. The VLEN value must be power of 2.; // In other case the notion of the function`s ""characteristic data type"" (CDT); // is used to compute the vector length.; // CDT is defined in the following order:; // a) For non-void function, the CDT is the return type.; // b) If the function has any non-uniform, non-linear parameters, then the; // CDT is the type of the first such parameter.; // c) If the CDT determined by a) or b) above is struct, union, or class; // type which is pass-by-value (except for the type that maps to the; // built-in complex data type), the characteristic data type is int.; // d) If none of the above three cases is applicable, the CDT is int.; // The VLEN is then determined based on the CDT and the size of vector; // register of that ISA for which current vector version is generated. The; // VLEN is computed using the formula below:; // VLEN = sizeof(vector_register) / sizeof(CDT),; // where vector register size specified in section 3.2.1 Registers and the; // Stack Frame of original AMD64 ABI document.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:200,power,power,200,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['power'],['power']
Energy Efficiency,"// Everything we care about has been handled now, reduce to the canonical; // unqualified base type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:50,reduce,reduce,50,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Exact power of 2,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:9,power,power,9,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,1,['power'],['power']
Energy Efficiency,"// Examines the loop nesting of the Src and Dst; // instructions and establishes their shared loops. Sets the variables; // CommonLevels, SrcLevels, and MaxLevels.; // The source and destination instructions needn't be contained in the same; // loop. The routine establishNestingLevels finds the level of most deeply; // nested loop that contains them both, CommonLevels. An instruction that's; // not contained in a loop is at level = 0. MaxLevels is equal to the level; // of the source plus the level of the destination, minus CommonLevels.; // This lets us allocate vectors MaxLevels in length, with room for every; // distinct loop referenced in both the source and destination subscripts.; // The variable SrcLevels is the nesting depth of the source instruction.; // It's used to help calculate distinct loops referenced by the destination.; // Here's the map from loops to levels:; // 0 - unused; // 1 - outermost common loop; // ... - other common loops; // CommonLevels - innermost common loop; // ... - loops containing Src but not Dst; // SrcLevels - innermost loop containing Src but not Dst; // ... - loops containing Dst but not Src; // MaxLevels - innermost loops containing Dst but not Src; // Consider the follow code fragment:; // for (a = ...) {; // for (b = ...) {; // for (c = ...) {; // for (d = ...) {; // A[] = ...;; // }; // }; // for (e = ...) {; // for (f = ...) {; // for (g = ...) {; // ... = A[];; // }; // }; // }; // }; // }; // If we're looking at the possibility of a dependence between the store; // to A (the Src) and the load from A (the Dst), we'll note that they; // have 2 loops in common, so CommonLevels will equal 2 and the direction; // vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; // A map from loop names to loop numbers would look like; // a - 1; // b - 2 = CommonLevels; // c - 3; // d - 4 = SrcLevels; // e - 5; // f - 6; // g - 7 = MaxLevels",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:561,allocate,allocate,561,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Example for; // Org:; // %Org = ... (Scheduled at Stage#0, NumPhi = 2); //; // Prolog0 (Stage0):; // %Clone0 = ...; // Prolog1 (Stage1):; // %Clone1 = ...; // Kernel (Stage2):; // %Phi0 = Phi %Clone1, Prolog1, %Clone2, Kernel; // %Phi1 = Phi %Clone0, Prolog1, %Phi0, Kernel; // %Clone2 = ...; // Epilog0 (Stage3):; // %Phi2 = Phi %Clone1, Prolog1, %Clone2, Kernel; // %Phi3 = Phi %Clone0, Prolog1, %Phi0, Kernel; // Epilog1 (Stage4):; // %Phi4 = Phi %Clone0, Prolog0, %Phi2, Epilog0; //; // VRMap = {0: %Clone0, 1: %Clone1, 2: %Clone2}; // VRMapPhi (after Kernel) = {0: %Phi1, 1: %Phi0}; // VRMapPhi (after Epilog0) = {0: %Phi3, 1: %Phi2}",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:40,Schedul,Scheduled,40,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['Schedul'],['Scheduled']
Energy Efficiency,"// Excitation energy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/NdbMTDir.h:14,energy,energy,14,test/periodic/NdbMTDir.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/NdbMTDir.h,1,['energy'],['energy']
Energy Efficiency,"// Exclude the fake form of fneg (fsub -0.0, x) because that is likely to be; // reduced to the unary fneg when it is visited, and we probably want to deal; // with fneg in a target-specific way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:81,reduce,reduced,81,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Execute the actual scheduling loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:22,schedul,scheduling,22,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,2,['schedul'],['scheduling']
Energy Efficiency,"// Exit early by inverting the condition, which help reduce indentations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:53,reduce,reduce,53,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Expand a power-of-2 comparison based on ctpop,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:12,power,power-of-,12,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,// Expand a power-of-2-or-zero comparison based on ctpop:; // (ctpop x) u< 2 -> (x & x-1) == 0; // (ctpop x) u> 1 -> (x & x-1) != 0,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:12,power,power-of-,12,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,// Expand pseudo instructions before second scheduling pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:44,schedul,scheduling,44,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['schedul'],['scheduling']
Energy Efficiency,// Expand some pseudo instructions into multiple instructions to allow; // proper scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:82,schedul,scheduling,82,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Expand some pseudo instructions to allow proper scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp:51,schedul,scheduling,51,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Expand the calculation of X pow N in the following manner:; // Let N = P1 + P2 + ... + PK, where all P are powers of 2. Then:; // X pow N = (X pow P1) * (X pow P2) * ... * (X pow PK).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:110,power,powers,110,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['power'],['powers']
Energy Efficiency,"// Expand the exmap if needed, to reduce collisions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:34,reduce,reduce,34,hist/hist/src/THnBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// Experimental option to eagerly invalidate more analyses. This has the; // potential to decrease max memory usage in exchange for more compile time.; // This may affect codegen due to either passes using analyses only when; // cached, or invalidating and recalculating an analysis that was; // stale/imprecise but still valid. Currently this invalidates all function; // analyses after various module->function or cgscc->function adaptors in the; // default pipelines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:432,adapt,adaptors,432,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,1,['adapt'],['adaptors']
Energy Efficiency,// Explicit operation to reduce precision. Reduce the value to half precision; // and promote it back to the legal type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp:25,reduce,reduce,25,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp,4,"['Reduce', 'reduce']","['Reduce', 'reduce']"
Energy Efficiency,// Exposed for resource monitoring & error feedback via renderer.info:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:24,monitor,monitoring,24,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['monitor'],['monitoring']
Energy Efficiency,// Extend the lifetime of the callback. We delayed this until here; // to avoid allocations in the hot path (which is where no typo correction; // occurs). Note that CorrectionCandidateCallback is polymorphic and; // initially stack-allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:233,allocate,allocated,233,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Extraction of vXi1 elements are now efficiently handled by MOVMSK.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:39,efficient,efficiently,39,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// F is a runtime function that allocates or frees memory, check; // AAHeapToStack and AAHeapToShared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:32,allocate,allocates,32,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['allocate'],['allocates']
Energy Efficiency,// FIXME (note copied from Lanai): This appears to be overallocating. Needs; // investigation. Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp:122,allocate,allocate,122,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// FIXME : Should not reduce the fine granulated debug options to a simple.; // -g",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalCUDADeviceCompiler.cpp:22,reduce,reduce,22,interpreter/cling/lib/Interpreter/IncrementalCUDADeviceCompiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalCUDADeviceCompiler.cpp,1,['reduce'],['reduce']
Energy Efficiency,// FIXME Can we use a less constrained schedule?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:39,schedul,schedule,39,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// FIXME We would like an efficient form for this, so we don't have to do a; // lot of extra uniquing. This fixme is originally from X86",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kMCInstLower.cpp:26,efficient,efficient,26,interpreter/llvm-project/llvm/lib/Target/M68k/M68kMCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kMCInstLower.cpp,1,['efficient'],['efficient']
Energy Efficiency,// FIXME here we leak `NamedChain` which is allocated before,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:44,allocate,allocated,44,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// FIXME: Accept a LLVMContext as well, e.g. the one that was used for the; // particular module in Interpreter, CIFactory or BackendPasses (would be; // more efficient)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.h:159,efficient,efficient,159,interpreter/cling/lib/Interpreter/IncrementalJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.h,1,['efficient'],['efficient']
Energy Efficiency,"// FIXME: Add handling for tail padding in vectors. Vectors don't; // have padding between or inside elements, but the total amount of; // data can be less than the allocated size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:165,allocate,allocated,165,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// FIXME: After copying the source-location information, should we free; // our (temporary) buffer and adopt the ASTContext-allocated memory?; // Doing so would optimize repeated calls to getWithLocInContext().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp:124,allocate,allocated,124,interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// FIXME: All of these Opcode-specific if's are needed for compatibility; // with GAS' behaviour. However, they may not generate the most efficient; // code in some circumstances.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:138,efficient,efficient,138,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['efficient'],['efficient']
Energy Efficiency,// FIXME: Arbitrary limit to reduce compile time cost.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:29,reduce,reduce,29,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,2,['reduce'],['reduce']
Energy Efficiency,// FIXME: Can we use a less constrained schedule?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:40,schedul,schedule,40,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['schedul'],['schedule']
Energy Efficiency,// FIXME: Consider if reducing the size of this enum (having Partition and; // Named modules only) then representing interface/implementation separately; // is more efficient.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h:165,efficient,efficient,165,interpreter/llvm-project/clang/include/clang/Basic/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h,1,['efficient'],['efficient']
Energy Efficiency,"// FIXME: Current only handle those Comdat groups that only containing one; // function.; // (1) For a Comdat group containing multiple functions, we need to have a; // unique postfix based on the hashes for each function. There is a; // non-trivial code refactoring to do this efficiently.; // (2) Variables can not be renamed, so we can not rename Comdat function in a; // group including global vars.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:278,efficient,efficiently,278,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// FIXME: Currently the DataLayout string carries a ""preferred alignment""; // for types. As the DataLayout is module/global, this should likely be; // sunk down to an FTTI element that is queried rather than a global; // preference.; /// Layout alignment element.; ///; /// Stores the alignment data associated with a given type bit width.; ///; /// \note The unusual order of elements in the structure attempts to reduce; /// padding and make the structure slightly more cache friendly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h:415,reduce,reduce,415,interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,1,['reduce'],['reduce']
Energy Efficiency,// FIXME: Currently we allocate EC each time because we don't have; // access to the set representation on which to call clear(). Should; // consider adding a clear() method to the EquivalenceClasses class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:23,allocate,allocate,23,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// FIXME: Do not modify node height. It may interfere with; // backtracking. Instead add a ""ready cycle"" to SUnit. Before scheduling the; // node its ready cycle can aid heuristics, and after scheduling it can; // indicate the scheduled cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:122,schedul,scheduling,122,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,3,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,"// FIXME: Do we need/want a pre-alloc pass like ARM has to try to keep loads and; // stores near one another? Note: The pre-RA instruction scheduler already has; // hooks to try and schedule pairable loads/stores together to improve pairing; // opportunities. Thus, pre-RA pairing pass may not be worth the effort.; // FIXME: When pairing store instructions it's very possible for this pass to; // hoist a store with a KILL marker above another use (without a KILL marker).; // The resulting IR is invalid, but nothing uses the KILL markers after this; // pass, so it's never caused a problem in practice.; /// createAArch64LoadStoreOptimizationPass - returns an instance of the; /// load / store optimization pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:139,schedul,scheduler,139,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,2,['schedul'],"['schedule', 'scheduler']"
Energy Efficiency,// FIXME: Don't allocate storage for these except in the first declaration; // of a virtual destructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:16,allocate,allocate,16,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['allocate'],['allocate']
Energy Efficiency,// FIXME: Fixing non-power-of-2 before clamp is workaround for; // narrowScalar limitation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:21,power,power-of-,21,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,2,['power'],['power-of-']
Energy Efficiency,"// FIXME: GH63562; // Arrays allocate an APValue per element.; // We use the number of constexpr steps as a proxy for the maximum size; // of arrays to avoid exhausting the system resources, as initialization; // of each element is likely to take some number of steps anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:29,allocate,allocate,29,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// FIXME: Given that the length of SVE vectors is not necessarily a power of; // two, we'd need to align every object dynamically at runtime if the; // alignment is larger than 16. This is not yet supported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:68,power,power,68,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['power'],['power']
Energy Efficiency,// FIXME: Handle the enum constant without prefix qualifiers (`a = Green`); // when renaming an unscoped enum declaration with a new namespace.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:67,Green,Green,67,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,1,['Green'],['Green']
Energy Efficiency,"// FIXME: Handle whitespace between '_T', '(', '""...""', and ')'.; // FIXME: Store Prefix and Suffix (or PrefixLength and SuffixLength to; // reduce the overhead) for each FormatToken, which is a string, so that we; // don't run multiple checks here on the hot path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:141,reduce,reduce,141,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['reduce'],['reduce']
Energy Efficiency,// FIXME: Handle widened to power of 2 results better. This ends; // up scalarizing.; // FIXME: 3 element stores scalarized on SI; // Split if it's too large for the address space.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:28,power,power,28,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['power'],['power']
Energy Efficiency,"// FIXME: Have Ops be (ValueEntry, Multiplicity) pairs, simplifying this.; // Compute the sum of powers of simplifiable factors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:97,power,powers,97,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['power'],['powers']
Energy Efficiency,// FIXME: I believe that this could use copy_if if the Inst reference could; // be adapted into a pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:83,adapt,adapted,83,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['adapt'],['adapted']
Energy Efficiency,"// FIXME: I think for bottom up scheduling, the register pressure is cached; // and can be retrieved by DAG->getPressureDif(SU).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:32,schedul,scheduling,32,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// FIXME: If we wanted to, we could allocate all of these in one big array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h:36,allocate,allocate,36,interpreter/llvm-project/clang/include/clang/AST/Stmt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h,1,['allocate'],['allocate']
Energy Efficiency,// FIXME: Implement efficiently multiplication by a constant,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:20,efficient,efficiently,20,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// FIXME: In some cases, VLDRS can be changed to a VLD1DUPd32 which defines; // the full D-register by loading the same value to both lanes. The; // instruction is micro-coded with 2 uops, so don't do this until we can; // properly schedule micro-coded instructions. The dispatcher stalls cause; // too big regressions.; // Insert the dependency-breaking FCONSTD before MI.; // 96 is the encoding of 0.5, but the actual value doesn't matter here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:232,schedul,schedule,232,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['schedul'],['schedule']
Energy Efficiency,// FIXME: Injecting into the DAGISel pipeline seems to cause issues with; // analyses needing to be re-run. This can result in being unable to; // schedule passes (particularly with 'Function Alias Analysis; // Results'). It's not entirely clear why but AFAICT this seems to be; // due to one FunctionPassManager not being able to use analyses from a; // previous one. As we're injecting a ModulePass we break the usual; // pass manager into two. GlobalISel with the fallback path disabled; // and -run-pass seem to be unaffected. The majority of GlobalISel; // testing uses -run-pass so this probably isn't too bad.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:147,schedul,schedule,147,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,1,['schedul'],['schedule']
Energy Efficiency,// FIXME: Is division-by-2 the correct step? Should we assert that the; // register size is a power-of-2?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:94,power,power-of-,94,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['power'],['power-of-']
Energy Efficiency,"// FIXME: It might be nice if there's a way to walk location expressions; // without trying to resolve the address ranges - it'd be a more efficient; // API (since the API is currently unnecessarily resolving addresses for; // this use case which only wants to validate the expressions themselves) &; // then the expressions could be validated even if the addresses can't be; // resolved.; // That sort of API would probably look like a callback ""for each; // expression"" with some way to lazily resolve the address ranges when; // needed (& then the existing API used here could be built on top of that -; // using the callback API to build the data structure and return it).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp:139,efficient,efficient,139,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,1,['efficient'],['efficient']
Energy Efficiency,// FIXME: It would be more efficient to teach Twine to tell us its size and; // then add a routine there to fill in an allocated char* with the contents; // of the string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:27,efficient,efficient,27,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,2,"['allocate', 'efficient']","['allocated', 'efficient']"
Energy Efficiency,// FIXME: It's slightly wasteful to allocate two TemplateArguments for this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:36,allocate,allocate,36,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['allocate'],['allocate']
Energy Efficiency,// FIXME: Leaving this as-is until we have POWER9 scheduling info,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:50,schedul,scheduling,50,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// FIXME: Maybe we can expand it in 'PowerPC Expand Atomic' pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:37,Power,PowerPC,37,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// FIXME: Nodes such as CopyFromReg probably should not advance the current; // cycle. Otherwise, we can wrongly mask real stalls. If the non-machine node; // has predecessors the cycle will be advanced when they are scheduled.; // But given the crude nature of modeling latency though such nodes, we; // currently need to treat these nodes like real instructions.; // if (!SU->getNode() || !SU->getNode()->isMachineOpcode()) return;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:217,schedul,scheduled,217,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// FIXME: Normalize the instruction register count to match the; // NumPhysRegs value. This is a highly unusual case, and is not expected; // to occur. This normalization is hiding an inconsistency in either the; // scheduling model or in the value that the user might have specified; // for NumPhysRegs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp:216,schedul,scheduling,216,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// FIXME: On the non-embedded POWER architectures, only some of the record; // forms are fast, and we should use only the fast ones.; // The defining instruction has a record form (or is already a record; // form). It is possible, however, that we'll need to reverse the condition; // code of the users.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:30,POWER,POWER,30,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['POWER'],['POWER']
Energy Efficiency,// FIXME: Only calculate this if CanBreakBefore is true once static; // initializers etc. are sorted out.; // FIXME: Move magic numbers to a better place.; // Reduce penalty for aligning ObjC method arguments using the colon; // alignment as this is the canonical way (still prefer fitting everything; // into one line if possible). Trying to fit a whole expression into one; // line should not force other line breaks (e.g. when ObjC method; // expression is a part of other expression).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:159,Reduce,Reduce,159,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// FIXME: Reduce the code duplication across these collector classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/LinkdefReader.cxx:10,Reduce,Reduce,10,core/dictgen/src/LinkdefReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/LinkdefReader.cxx,1,['Reduce'],['Reduce']
Energy Efficiency,// FIXME: Reduce the malloc traffic here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp:10,Reduce,Reduce,10,interpreter/llvm-project/clang/lib/AST/APValue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// FIXME: Reduce the number of SymbolStringPtrs here. See; // https://github.com/llvm/llvm-project/issues/55576.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:10,Reduce,Reduce,10,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// FIXME: Reduce to Core.Rtypes.h.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:10,Reduce,Reduce,10,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['Reduce'],['Reduce']
Energy Efficiency,// FIXME: Reduce unit test case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:10,Reduce,Reduce,10,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// FIXME: ReduceOperandsSkip has similar function, except it uses larger numbers; // for more reduced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/ReducerWorkItem.cpp:10,Reduce,ReduceOperandsSkip,10,interpreter/llvm-project/llvm/tools/llvm-reduce/ReducerWorkItem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/ReducerWorkItem.cpp,2,"['Reduce', 'reduce']","['ReduceOperandsSkip', 'reduced']"
Energy Efficiency,// FIXME: Refactor this and the account subcommand to reduce code; // duplication,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.cpp:54,reduce,reduce,54,interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// FIXME: Right now, the parser always allows any available; // instruction, so the .machine directive is not useful.; // In the wild, any/push/pop/ppc64/altivec/power[4-9] are seen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:162,power,power,162,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,1,['power'],['power']
Energy Efficiency,"// FIXME: See ScheduleDAGSDNodes::EmitCopyFromReg. For now, scheduler; // emits a copy from the physical register to a virtual register unless; // it requires a cross class copy (cost < 0). That means we are only; // treating ""expensive to copy"" register dependency as physical register; // dependency. This may change in the future though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:14,Schedul,ScheduleDAGSDNodes,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,2,"['Schedul', 'schedul']","['ScheduleDAGSDNodes', 'scheduler']"
Energy Efficiency,// FIXME: Should allocate from normal heap so that we can free this later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:17,allocate,allocate,17,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,3,['allocate'],['allocate']
Energy Efficiency,"// FIXME: Since post-ra scheduler operates on bundles, the CPSR kill; // marker is only on the BUNDLE instruction. Process the BUNDLE; // instruction as we finish with the bundled instruction to work around; // the inconsistency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:24,schedul,scheduler,24,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// FIXME: Sink this into allocateSpecialInputSGPRs,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:25,allocate,allocateSpecialInputSGPRs,25,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['allocate'],['allocateSpecialInputSGPRs']
Energy Efficiency,"// FIXME: Strictly speaking MFHC1 only reads the top 32-bits however, we; // claim to read the whole 64-bits as part of a white lie used to; // temporarily work around a widespread bug in the -mfp64 support.; // The problem is that none of the 32-bit fpu ops mention the fact; // that they clobber the upper 32-bits of the 64-bit FPR. Fixing that; // requires a major overhaul of the FPU implementation which can't; // be done right now due to time constraints.; // MFHC1 is one of two instructions that are affected since they are; // the only instructions that don't read the lower 32-bits.; // We therefore pretend that it reads the bottom 32-bits to; // artificially create a dependency and prevent the scheduler; // changing the behaviour of the code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:707,schedul,scheduler,707,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// FIXME: The .addReg(DstReg) is a white lie used to temporarily work; // around a widespread bug in the -mfp64 support.; // The problem is that none of the 32-bit fpu ops mention the fact; // that they clobber the upper 32-bits of the 64-bit FPR. Fixing that; // requires a major overhaul of the FPU implementation which can't; // be done right now due to time constraints.; // MTHC1 is one of two instructions that are affected since they are; // the only instructions that don't read the lower 32-bits.; // We therefore pretend that it reads the bottom 32-bits to; // artificially create a dependency and prevent the scheduler; // changing the behaviour of the code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:620,schedul,scheduler,620,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// FIXME: The ScheduleDAG currently loses information about which of a; // node's values is consumed by each dependence. Consequently, if the node; // defines multiple register classes, we don't know which to pressurize; // here. Instead the following loop consumes the register defs in an; // arbitrary order. At least it handles the common case of clustered loads; // to the same class. For precise liveness, each SDep needs to indicate the; // result number. But that tightly couples the ScheduleDAG with the; // SelectionDAG making updates tricky. A simpler hack would be to attach a; // value type or register class to SDep.; //; // The most important aspect of register tracking is balancing the increase; // here with the reduction further below. Note that this SU may use multiple; // defs in PredSU. The can't be determined here, but we've already; // compensated by reducing NumRegDefsLeft in PredSU during; // ScheduleDAGSDNodes::AddSchedEdges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:14,Schedul,ScheduleDAG,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,3,['Schedul'],"['ScheduleDAG', 'ScheduleDAGSDNodes']"
Energy Efficiency,"// FIXME: The below just finds *a* unused register. Maybe code could be; // optimized more if this looks for the register that isn't used for the; // longest time around this place, to enable more scheduling freedom. Not; // sure if that would actually result in a big performance difference; // though. Maybe RegisterScavenger::findSurvivorBackwards has some logic; // already to do this - but it's unclear if that could easily be used here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:197,schedul,scheduling,197,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// FIXME: The loop above only tries to split in halves. But if the input; // vector for example is <3 x i16> it wouldn't be able to detect a; // SplatBitSize of 16. No idea if that is a design flaw currently limiting; // optimizations. I guess that back in the days when this helper was created; // vectors normally was power-of-2 sized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:320,power,power-of-,320,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['power'],['power-of-']
Energy Efficiency,"// FIXME: The scheduler currently can't handle values larger than 16. But; // the values can actually go up to 32 for floating-point load/store; // multiple (VLDMIA etc.). Also, the way this code is reasoning about memory; // operations isn't right; we could end up with ""extra"" memory operands for; // various reasons, like tail merge merging two memory operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:14,schedul,scheduler,14,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// FIXME: This appears to be overallocating. Needs investigation.; // Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:97,allocate,allocate,97,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// FIXME: This behaves strangely. If, for example, you have 32 load + stores,; // the first 16 loads will be interleaved with the stores, and the next 16 will; // be clustered as expected. It should really split into 2 16 store batches.; //; // Loads are clustered until this returns false, rather than trying to schedule; // groups of stores. This also means we have to deal with saying different; // address space loads should be clustered, and ones which might cause bank; // conflicts.; //; // This might be deprecated so it might not be worth that much effort to fix.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:313,schedul,schedule,313,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['schedul'],['schedule']
Energy Efficiency,// FIXME: This can be made more efficient.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:32,efficient,efficient,32,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,1,['efficient'],['efficient']
Energy Efficiency,// FIXME: This is not very efficient.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:27,efficient,efficient,27,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['efficient'],['efficient']
Energy Efficiency,// FIXME: This is not very efficient.; // Encode return type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:27,efficient,efficient,27,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['efficient'],['efficient']
Energy Efficiency,// FIXME: This isn't right for vectors with non-byte-sized or; // non-power-of-two sized elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:70,power,power-of-two,70,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// FIXME: Unfortunately, to make sure this is as efficient as possible we; // need extra binary constructors from particular types. We can't rely on; // the compiler to be smart enough to fold operator+()/concat() down to the; // right thing. Yet.; /// Construct as the concatenation of a C string and a StringRef.; /*implicit*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:49,efficient,efficient,49,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,1,['efficient'],['efficient']
Energy Efficiency,"// FIXME: Use something more efficient than normal lookup for using; // directives. In C++, using directives are looked up more than anything else.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:29,efficient,efficient,29,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// FIXME: Use the directory info to prune this, before doing the stat syscall.; // FIXME: This will reduce the # syscalls.; // Check to see if the file exists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:100,reduce,reduce,100,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// FIXME: Warn about failure to get the streamer info here?; //; // We may have allocated an object last time we were called.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:80,allocate,allocated,80,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['allocate'],['allocated']
Energy Efficiency,// FIXME: We don't support non-power-of-2-sized vectors for now. Ideally; // we could break down into LHS/RHS like LegalizeDAG does.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:31,power,power-of-,31,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['power'],['power-of-']
Energy Efficiency,// FIXME: We don't support non-power-of-2-sized vectors for now.; // Ideally we could break down into LHS/RHS like LegalizeDAG does.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:31,power,power-of-,31,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['power'],['power-of-']
Energy Efficiency,// FIXME: We potentially allocate here even if ConvertRHS is false.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,allocate,allocate,25,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['allocate'],['allocate']
Energy Efficiency,// FIXME: We should attach the query as we go: This provides a result in a; // single pass in the common case where all symbols have already reached the; // required state. The query could be detached again in the 'fail' method on; // IPLS. Phase 2 would be reduced to collecting and dispatching the MUs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:258,reduce,reduced,258,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// FIXME: We should invent a VMEMCPY pseudo-instruction that lowers to; // VLDM/VSTM and make this code emit it when appropriate. This would reduce; // pressure on the general purpose registers. However this seems harder to map; // onto the register allocator's view of the world.; // The number of MEMCPY pseudo-instructions to emit. We use up to; // MaxLoadsInLDM registers per mcopy, which will get lowered into ldm/stm; // later on. This is a lower bound on the number of MEMCPY operations we must; // emit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp:141,reduce,reduce,141,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSelectionDAGInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// FIXME: We would like an efficient form for this, so we don't have to do a; // lot of extra uniquing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MCInstLower.cpp:27,efficient,efficient,27,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MCInstLower.cpp,4,['efficient'],['efficient']
Energy Efficiency,"// FIXME: We would like an efficient form for this, so we don't have to do; // a lot of extra uniquing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:27,efficient,efficient,27,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// FIXME: We would like an efficient form for this, so we; // don't have to do a lot of extra uniquing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:27,efficient,efficient,27,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// FIXME: We're missing a way to go back from LLT to llvm::Type to query the; // datalayout for the preferred alignment. Also there should be a target hook; // for this to allow targets to reduce the alignment and ignore the; // datalayout. e.g. AMDGPU should always use a 4-byte alignment, regardless of; // the type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:189,reduce,reduce,189,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// FIXME: handle 32-bit mode; // 15-bytes is the longest single NOP instruction, but 10-bytes is; // commonly the longest that can be efficiently decoded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:134,efficient,efficiently,134,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// FIXME: in-function stack adjustment for calls is limited to 24-bits; // because there's no guaranteed temporary register available.; //; // ADD/SUB (immediate) has only LSL #0 and LSL #12 available.; // 1) For offset <= 12-bit, we use LSL #0; // 2) For 12-bit <= offset <= 24-bit, we use two instructions. One uses; // LSL #0, and the other uses LSL #12.; //; // Most call frames will be allocated at the start of a function so; // this is OK, but it is a limitation that needs dealing with.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:391,allocate,allocated,391,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// FIXME: it would be nice to make CI scheduling boundary, although in; // practice it does not matter much.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp:38,schedul,scheduling,38,interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// FIXME: should check if immediate value is a power of two or a integer; // between 0 and 32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:47,power,power,47,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,1,['power'],['power']
Energy Efficiency,// FIXME:; // c) Check that immediates of R_MIPS_GOT16/R_MIPS_LO16 relocations; // do not exceed 16-bit.; // d) Use R_MIPS_GOT_PAGE/R_MIPS_GOT_OFST relocations instead; // of R_MIPS_GOT_DISP in appropriate cases to reduce number; // of GOT entries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:215,reduce,reduce,215,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// FIXME:; /// Returns a string corresponding to the specified PowerPC subtarget. e.g.:; /// ""_P8"" for Power8, ""_P9"" for Power9. The string is used as a suffix while; /// generating subtarget-specific MASSV library functions. Current support; /// includes minimum subtarget Power8 for Linux and Power7 for AIX.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp:63,Power,PowerPC,63,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// FP control word may be set only from data in memory. So we need to allocate; // stack space to save/load FP control word.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:70,allocate,allocate,70,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Factor in the number of conditional branches reduced from jump; // threading. Assume that lowering the switch block is implemented by; // using binary search, hence the LogBase2().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:48,reduce,reduced,48,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Factor which can be used to tune the smoothing.; // It is used as multiplicative factor for the fixed and adaptive bandwidth.; // A value < 1 will reproduce better the tails but oversmooth the peak; // while a factor > 1 will overestimate the tail",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:109,adapt,adaptive,109,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// Fail to decompose: ""reduce"" the problem to the ""$x + 0"" case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:23,reduce,reduce,23,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Fake stack allocator (asan_fake_stack.h) has 11 size classes; // for every power of 2 from kMinStackMallocSize to kMaxAsanStackMallocSizeClass,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:78,power,power,78,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['power'],['power']
Energy Efficiency,"// Fast memory allocation and translation between node id and node address.; // This is really the same idea as the one underlying the ""bump pointer; // allocator"", the difference being in the translation. A node id is; // composed of two components: the index of the block in which it was; // allocated, and the index within the block. With the default settings,; // where the number of nodes per block is 4096, the node id (minus 1) is:; //; // bit position: 11 0; // +----------------------------+--------------+; // | Index of the block |Index in block|; // +----------------------------+--------------+; //; // The actual node id is the above plus 1, to avoid creating a node id of 0.; //; // This method significantly improved the build time, compared to using maps; // (std::unordered_map or DenseMap) to translate between pointers and ids.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:294,allocate,allocated,294,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,1,['allocate'],['allocated']
Energy Efficiency,"// Fast path the common cases so we can avoid the conservative computation; // below, which in common cases allocates ""large"" APSInt values, which are; // slow.; // If the element size is a power of 2, we can directly compute the additional; // number of addressing bits beyond those required for the element count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:108,allocate,allocates,108,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,2,"['allocate', 'power']","['allocates', 'power']"
Energy Efficiency,// Fast qualifiers are those that can be allocated directly; // on a QualType object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:41,allocate,allocated,41,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['allocate'],['allocated']
Energy Efficiency,// Fast suboptimal list scheduling,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:24,schedul,scheduling,24,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['schedul'],['scheduling']
Energy Efficiency,// Fields except for BestSchedule are supposed to reflect current IR state; // `const` fields are to emphasize they shouldn't change for any schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.h:141,schedul,schedule,141,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.h,1,['schedul'],['schedule']
Energy Efficiency,// File numbers start with 1 and/or after any file numbers; // allocated by inline-assembler .file directives.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:63,allocate,allocated,63,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Fill LiveRegsConsumers for regs that were already; // defined before scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:72,schedul,scheduling,72,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Fill gUser and free allocated memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:23,allocate,allocated,23,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// Fill histogram for particle's energy loss",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/RootShower.cxx:33,energy,energy,33,test/RootShower/RootShower.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/RootShower.cxx,2,['energy'],['energy']
Energy Efficiency,// Fill in any extra bytes we allocated for padding,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:30,allocate,allocated,30,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Fill information for monitoring and stop it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:24,monitor,monitoring,24,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['monitor'],['monitoring']
Energy Efficiency,// Fill some stats to help scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:27,schedul,scheduling,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Fill the rest of the mask with the unused elements of ExtVec in hopes; // that it will result in a permutation of ExtVec's elements. It's still; // fine if it doesn't (e.g. if undefs are present, or elements are; // repeated), but permutations can always be done efficiently via vdelta; // and vrdelta.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:266,efficient,efficiently,266,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// Filter external-to-external case to reduce LBR trace size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp:39,reduce,reduce,39,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Filter out broken stack sample. We may not have complete frame info; // if sample end up in prolog/epilog, the result is dangling context not; // connected to entry point. This should be relatively rare thus not much; // impact on overall profile quality. However we do want to filter them; // out to reduce the number of different calling contexts. One instance; // of such case - when sample landed in prolog/epilog, somehow stack; // walking will be broken in an unexpected way that higher frames will be; // missing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp:304,reduce,reduce,304,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,1,['reduce'],['reduce']
Energy Efficiency,// FilterClass - It's used to reduce the search space only to the; // instructions that define the kind of relationship modeled by; // this InstrMapping object/record.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenMapTable.cpp:30,reduce,reduce,30,interpreter/llvm-project/llvm/utils/TableGen/CodeGenMapTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenMapTable.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Filtering is not implemented a very efficient way to keep it simple, but the; // implementation ensures that the performance drop is opt-in. Only when filters are; // used there is a performance loss.; // The intended use case of filtering is for debugging, when highest performance; // does not matter. Filtering is only every attempted if the message passes the; // threshold level.; // Filtering is very fast when the filter is empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPrint.cxx:39,efficient,efficient,39,math/minuit2/src/MnPrint.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPrint.cxx,1,['efficient'],['efficient']
Energy Efficiency,"// Finalise allocation, allocate empty ranges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:24,allocate,allocate,24,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Finalize state after finishing a scheduling pass on the function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:36,schedul,scheduling,36,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['schedul'],['scheduling']
Energy Efficiency,// Finally block which will branch to unwindResumeBlock if; // exception is not caught. Initializes/allocates stack locations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:100,allocate,allocates,100,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,1,['allocate'],['allocates']
Energy Efficiency,"// Finally, do the actual predication for all predicatable blocks. A couple; // of notes here:; // 1) We don't bother to constant fold dominated exits with identical exit; // counts; that's simply a form of CSE/equality propagation and we leave; // it for dedicated passes.; // 2) We insert the comparison at the branch. Hoisting introduces additional; // legality constraints and we leave that to dedicated logic. We want to; // predicate even if we can't insert a loop invariant expression as; // peeling or unrolling will likely reduce the cost of the otherwise loop; // varying check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:532,reduce,reduce,532,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Find IdxVal modulo ElemsPerChunk. Since ElemsPerChunk is a power of 2; // this can be done with a mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:62,power,power,62,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power']
Energy Efficiency,"// Find a register matching \p RC from \p LiveUnits which is unused and; // available throughout the function. On failure, returns AMDGPU::NoRegister.; // TODO: Rewrite the loop here to iterate over MCRegUnits instead of; // MCRegisters. This should reduce the number of iterations and avoid redundant; // checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:250,reduce,reduce,250,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Find a solution to a fully reduced graph by backpropagation.; //; // Given a graph and a reduction order, pop each node from the reduction; // order and greedily compute a minimum solution based on the node costs, and; // the dependent costs due to previously solved nodes.; //; // Note - This does not return the graph to its original (pre-reduction); // state: the existing solvers destructively alter the node and edge; // costs. Given that, the backpropagate function doesn't attempt to; // replace the edges either, but leaves the graph in its reduced; // state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h:30,reduce,reduced,30,interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h,2,['reduce'],['reduced']
Energy Efficiency,// Find already scheduled copies with a single physreg dependence and move; // them just above the scheduled instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:16,schedul,scheduled,16,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['scheduled']
Energy Efficiency,// Find potential errors in the scheduling information given measurements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h:32,schedul,scheduling,32,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h,1,['schedul'],['scheduling']
Energy Efficiency,// Find scheduling regions and schedule / packetize each region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600Packetizer.cpp:8,schedul,scheduling,8,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600Packetizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600Packetizer.cpp,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,// Find the first non-boundary starting from the end of the last; // scheduling region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:69,schedul,scheduling,69,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Find the largest power of 2 that MulConstVal is a multiple of,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:20,power,power,20,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['power'],['power']
Energy Efficiency,"// Find the last instruction. The common case should be that BB has been; // scheduled, and the last instruction is VL.back(). So we start with; // VL.back() and iterate over schedule data until we reach the end of the; // bundle. The end of the bundle is marked by null ScheduleData.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:77,schedul,scheduled,77,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,3,"['Schedul', 'schedul']","['ScheduleData', 'schedule', 'scheduled']"
Energy Efficiency,"// Find the next power of 2 width, rounding up to a byte.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:17,power,power,17,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power']
Energy Efficiency,// Find the next power-of-2 >= ItinDepth,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:17,power,power-of-,17,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,1,['power'],['power-of-']
Energy Efficiency,"// Find the regs killed by MI, and find regmasks of preserved regs.; // Max out the number of statically allocated elements in `DeadRegs`, as this; // prevents fallback to std::set::count() operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:105,allocate,allocated,105,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Find the replacement text for inserting braces and quotes and line breaks.; // We don't create an allocated string concatenated from parts here because it; // has to outlive the BreakableStringliteral object. The brace replacements; // include a quote so that WhitespaceManager can tell it apart from whitespace; // replacements between the string and surrounding tokens.; // The option is not implemented in JavaScript.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:101,allocate,allocated,101,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Find the smaller repetition size of the two possible logical immediates by; // counting the number of runs of one-bits within the BigSize-bit value. Both; // sizes may be the same. The EOR may add one or subtract one from the; // power-of-two count that can be represented by a logical immediate, or it; // may be left unchanged.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp:233,power,power-of-two,233,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp,1,['power'],['power-of-two']
Energy Efficiency,// Find the smallest power of two bitwidth that's sufficient to hold Instr's; // operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:21,power,power,21,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,1,['power'],['power']
Energy Efficiency,// Find the smallest power of two bitwidth that's sufficient to hold Instr's; // operands.; // What is the smallest bit width that can accommodate the entire value ranges; // of both of the operands?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:21,power,power,21,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,1,['power'],['power']
Energy Efficiency,"// Find the smallest power-2 type that is legal for this vector size and; // operation, given the original type size and the number of known sign/zero; // bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:21,power,power-,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['power'],['power-']
Energy Efficiency,// Find up to Lat independent scalar instructions as early as; // possible such that they can be scheduled after this MFMA.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:97,schedul,scheduled,97,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Finding the minimal(chain_number + reusable_offset_number) is a complicated; // algorithmic problem.; // For now, the algorithm used here is simply adjusted to handle the case for; // manually unrolling cases.; // FIXME: use a more powerful algorithm to find minimal sum of chain_number and; // reusable_offset_number for one base with multiple offsets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:235,power,powerful,235,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['power'],['powerful']
Energy Efficiency,// Finds or allocates the provided BitVector in the cache and retrieves it's; // unique instance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:12,allocate,allocates,12,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,1,['allocate'],['allocates']
Energy Efficiency,// Finds the location where the leaking object is allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.h:50,allocate,allocated,50,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.h,1,['allocate'],['allocated']
Energy Efficiency,// Finish by looking for child DIEs. Because of the LIFO worklist we need; // to schedule that work before any subsequent items are added to the; // worklist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:81,schedul,schedule,81,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,1,['schedul'],['schedule']
Energy Efficiency,// First after last register allocated for current parameter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:29,allocate,allocated,29,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,1,['allocate'],['allocated']
Energy Efficiency,"// First allocate an aliasing scope for each pointer checking group.; //; // While traversing through the checking groups in the loop, also create a; // reverse map from pointers to the pointer checking group they were assigned; // to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp:9,allocate,allocate,9,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp,1,['allocate'],['allocate']
Energy Efficiency,// First allocate registers for the empty intervals.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:9,allocate,allocate,9,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// First compute the nearest common dominator of all forward non-fallthrough; // predecessors so that we minimize the time that the BLOCK is on the stack,; // which reduces overall stack height.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:165,reduce,reduces,165,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// First page is reserved for perf_event_mmap_page. Data buffer starts on; // the next page, so we allocate one more page.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp:99,allocate,allocate,99,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// First promote to a power-of-two size, then expand if necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:22,power,power-of-two,22,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['power'],['power-of-two']
Energy Efficiency,// First register allocated for current parameter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:18,allocate,allocated,18,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,1,['allocate'],['allocated']
Energy Efficiency,"// First register for byval parameter is the first register that wasn't; // allocated before this method call, so it would be ""reg"".; // If parameter is small enough to be saved in range [reg, r4), then; // the end (first after last) register would be reg + param-size-in-regs,; // else parameter would be splitted between registers and stack,; // end register would be r4 in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:76,allocate,allocated,76,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// First step, find the switch case that is being branched to. We can do this; // efficiently by scanning the SwitchCase list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:82,efficient,efficiently,82,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// First, check if ParentMacroStack is not empty which means we are currently; // dealing with a parent statement which was expanded from a macro.; // If this parent statement was expanded from the same macros as this; // statement, we reduce the initial complexity of this statement to zero.; // This causes that a group of statements that were generated by a single; // macro expansion will only increase the total complexity by one.; // Note: This is not the final complexity of this statement as we still; // add the complexity of the child statements to the complexity value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:236,reduce,reduce,236,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// First, examine the IF candidates for register VR whose removable-regis-; // ter sets are empty. This means that a given candidate will not help eli-; // minate any registers, but since ""insert"" is not a constant-extendable; // instruction, using such a candidate may reduce code size if the defini-; // tion of VR is constant-extended.; // If there exists a candidate with a non-empty set, the ones with empty; // sets will not be used and can be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:270,reduce,reduce,270,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// First, reduce the source down to 128-bit, applying BinOp to lo/hi.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:10,reduce,reduce,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// FirstSPAdjustAmount is chosen as (2048 - StackAlign) because 2048 will; // cause sp = sp + 2048 in the epilogue to be split into multiple; // instructions. Offsets smaller than 2048 can fit in a single load/store; // instruction, and we have to stick with the stack alignment.; // So (2048 - StackAlign) will satisfy the stack alignment.; //; // FIXME: This place may seem odd. When using multiple ADDI instructions to; // adjust the stack in Prologue, and there are no callee-saved registers, we; // can take advantage of the logic of split sp ajustment to reduce code; // changes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:561,reduce,reduce,561,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Flag bits ""flags"" field of the Html widget:; //; // REDRAW_PENDING An idle handler has already been queued to; // call the TGHtml::Redraw() method.; //; // GOT_FOCUS This widget currently has input focus.; //; // HSCROLL Horizontal scrollbar position needs to be; // recomputed.; //; // VSCROLL Vertical scrollbar position needs to be; // recomputed.; //; // RELAYOUT We need to reposition every element on the; // virtual canvas. (This happens, for example,; // when the size of the widget changes and we; // need to recompute the line breaks.); //; // RESIZE_ELEMENTS We need to recompute the size of every element.; // This happens, for example, when the fonts; // change.; //; // REDRAW_FOCUS We need to repaint the focus highlight border.; //; // REDRAW_TEXT Everything in the clipping window needs to be redrawn.; //; // STYLER_RUNNING There is a call to HtmlAddStyle() in process.; // Used to prevent a recursive call to HtmlAddStyle().; //; // INSERT_FLASHING True if there is a timer scheduled that will toggle; // the state of the insertion cursor.; //; // REDRAW_IMAGES One or more TGHtmlImageMarkup objects have their; // redrawNeeded flag set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:996,schedul,scheduled,996,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,1,['schedul'],['scheduled']
Energy Efficiency,"// Floating types are special. They are primitives, but need their; // destructor called, since they might allocate memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.cpp:107,allocate,allocate,107,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Flush the local value map before starting each instruction.; // This improves locality and debugging, and can reduce spills.; // Reuse of values across IR instructions is relatively uncommon.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp:113,reduce,reduce,113,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Fold AND into a TBZ/TBNZ if constant operand is power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:51,power,power,51,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['power'],['power']
Energy Efficiency,"// Fold and/or of setcc's to double CMOV:; // (CMOV F, T, ((cc1 | cc2) != 0)) -> (CMOV (CMOV F, T, cc1), T, cc2); // (CMOV F, T, ((cc1 & cc2) != 0)) -> (CMOV (CMOV T, F, !cc1), F, !cc2); //; // This combine lets us generate:; // cmovcc1 (jcc1 if we don't have CMOV); // cmovcc2 (same); // instead of:; // setcc1; // setcc2; // and/or; // cmovne (jne if we don't have CMOV); // When we can't use the CMOV instruction, it might increase branch; // mispredicts.; // When we can use CMOV, or when there is no mispredict, this improves; // throughput and reduces register pressure.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:550,reduce,reduces,550,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:427,Power,PowerPC,427,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// Folding fadd (fmul x, y), (fmul x, y) -> fma x, y, (fmul x, y) is never; // beneficial. It does not reduce latency. It increases register pressure. It; // replaces an fadd with an fma which is a more complex instruction, so is; // likely to have a larger encoding, use more functional units, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:103,reduce,reduce,103,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// For 64-bit PowerPC, prefer the more compact relative encodings.; // This trades 32 bits per jump table entry for one or two instructions; // on the jump site.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:14,Power,PowerPC,14,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// For 64-bit, since we have so many registers, use the ILP scheduler.; // For 32-bit, use the register pressure specific scheduling.; // For Atom, always use ILP scheduling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:60,schedul,scheduler,60,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,"// For AVX2, we sometimes want to combine; // (vector_shuffle <mask> (concat_vectors t1, undef); // (concat_vectors t2, undef)); // Into:; // (vector_shuffle <mask> (concat_vectors t1, t2), undef); // Since the latter can be efficiently lowered with VPERMD/VPERMQ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:225,efficient,efficiently,225,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// For Arm64EC thunks, allocate 32 extra bytes at the bottom of the stack; // for the shadow store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:23,allocate,allocate,23,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// For EH funclets, only allocate enough space for outgoing calls. Save the; // NumBytes value that we would've used for the parent frame.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:25,allocate,allocate,25,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:1129,allocate,allocate,1129,interpreter/llvm-project/llvm/tools/lli/lli.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// For NSPanel (which subclasses NSWindow), allocated objects are not; // self-owned.; // FIXME: For now we don't track NSPanels. object for the same reason; // as for NSWindow objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:44,allocate,allocated,44,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// For NSWindow, allocated objects are (initially) self-owned.; // FIXME: For now we opt for false negatives with NSWindow, as these objects; // self-own themselves. However, they only do this once they are displayed.; // Thus, we need to track an NSWindow's display status.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:17,allocate,allocated,17,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// For ObjC library calls which return their argument, replace uses of the; // argument with uses of the call return value, if it dominates the use. This; // reduces register pressure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:158,reduce,reduces,158,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// For P7 and P8, floating-point instructions have a 6-cycle latency and; // there are two execution units, so unroll by 12x for latency hiding.; // FIXME: the same for P9 as previous gen until POWER9 scheduling is ready; // FIXME: the same for P10 as previous gen until POWER10 scheduling is ready; // Assume that future is the same as the others.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:201,schedul,scheduling,201,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,2,['schedul'],['scheduling']
Energy Efficiency,"// For PROOF-Lite we redirect this output to a the open log file so that the; // memory monitor can pick these messages up",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:88,monitor,monitor,88,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['monitor'],['monitor']
Energy Efficiency,"// For PowerPC, we need to deal with alignment of stack arguments -; // they are mostly aligned to 8 bytes, but vectors and i128 arrays; // are aligned to 16 bytes, byvals can be aligned to 8 or 16 bytes,; // For that reason, we compute current offset from stack pointer (which is; // always properly aligned), and offset for the first vararg, then subtract; // them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:7,Power,PowerPC,7,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// For Swift's purposes, this is always just the store size of the type; // rounded up to a power of 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp:92,power,power,92,interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,1,['power'],['power']
Energy Efficiency,"// For Thumb2 and -Os, prefer scheduling CPSR setting instruction close to; // its uses. Instructions which are otherwise scheduled between them may; // incur a code size penalty (not able to use the CPSR setting 16-bit; // instructions).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:30,schedul,scheduling,30,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,2,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,"// For WinCFI, if optimizing for size, prefer to not combine the stack bump; // (to force a stp with predecrement) to match the packed unwind format,; // provided that there actually are any callee saved registers to merge the; // decrement with.; // This is potentially marginally slower, but allows using the packed; // unwind format for functions that both have a local area and callee saved; // registers. Using the packed unwind format notably reduces the size of; // the unwind info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:449,reduce,reduces,449,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// For X86, we need to sort Registers and RegisterTuples together to list; // new registers and register tuples at a later position. So that we can; // reduce unnecessary iterations on unsupported registers in LiveVariables.; // TODO: Remove this logic when migrate from LiveVariables to LiveIntervals; // completely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:152,reduce,reduce,152,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// For __atomic_is_lock_free(sizeof(_Atomic(T))), if the size is a power; // of two less than or equal to the maximum inline atomic width, we know it; // is lock-free. If the size isn't a power of two, or greater than the; // maximum alignment where we promote atomics, we know it is not lock-free; // (at least not in the sense of atomic_is_lock_free). Otherwise,; // the answer can only be determined at runtime; for example, 16-byte; // atomics have lock-free implementations on some, but not all,; // x86-64 processors.; // Check power-of-two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:67,power,power,67,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,3,['power'],"['power', 'power-of-two']"
Energy Efficiency,// For a tentative schedule LIS isn't updated yet but livemask should; // remain the same on any schedule. Subreg defs can be reordered but they; // all must dominate uses anyway.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.cpp:19,schedul,schedule,19,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.cpp,2,['schedul'],['schedule']
Energy Efficiency,"// For a vmla we are trying to match a larger pattern:; // ExtA = sext/zext A; // ExtB = sext/zext B; // Mul = mul ExtA, ExtB; // vecreduce.add Mul; // There might also be en extra extend between the mul and the addreduce, so; // long as the bitwidth is high enough to make them equivalent (for example; // original v8i16 might be mul at v8i32 and the reduce happens at v8i64).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:352,reduce,reduce,352,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// For additions and multiplications, traverse add/mul chains for which we; // can potentially create a single SCEV, to reduce the number of; // get{Add,Mul}Expr calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:120,reduce,reduce,120,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// For all selected reductions, remove all parts except those in the first; // iteration (and the PHI). Replace outside uses of the reduced value with uses; // of the first-iteration reduced value (in other words, reroll the selected; // reductions).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:132,reduce,reduced,132,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,2,['reduce'],['reduced']
Energy Efficiency,"// For an expanded parameter pack, record the number of expansion types here; // so that it's easier for deserialization to allocate the right amount of; // memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:124,allocate,allocate,124,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// For any C or C++ program, this should always be; // false, since it is illegal to have a function; // where the first argument is variadic. Therefore; // the first fixed argument should already have; // allocated GPR1 either through shadowing it or; // using it for parameter passing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:206,allocate,allocated,206,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,1,['allocate'],['allocated']
Energy Efficiency,"// For atomic sub, perform scan with add operation and allow one lane to; // subtract the reduced value later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp:90,reduce,reduced,90,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,// For bottom-up scheduling add the cycles needed for the current operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:17,schedul,scheduling,17,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// For convenience, we store the block array contiguously. This is because; // if someone calls setStreamMap(), it is more convenient to be able to call; // it with an ArrayRef instead of setting up a StreamRef. Since the; // DirectoryStream is cached in the class and thus lives for the life of the; // class, we can be guaranteed that readArray() will return a stable; // reference, even if it has to allocate from its internal pool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFile.cpp:403,allocate,allocate,403,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFile.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// For each gadget edge, make cuts that guarantee the gadget will be; // mitigated. A computationally efficient way to achieve this is to either:; // (a) cut all egress CFG edges from the gadget source, or; // (b) cut all ingress CFG edges to the gadget sink.; //; // Moreover, the algorithm tries not to make a cut into a loop by preferring; // to make a (b)-type cut if the gadget source resides at a greater loop depth; // than the gadget sink, or an (a)-type cut otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:102,efficient,efficient,102,interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp,1,['efficient'],['efficient']
Energy Efficiency,// For each live out vreg reduce the pressure change associated with other; // uses of the same vreg below the live-out reaching def.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:26,reduce,reduce,26,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// For each of the SUnits in the scheduling block, try to fuse the instr in; // it with one in its predecessors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:33,schedul,scheduling,33,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// For each of the bases sort the pointers by Offset and check if any of the; // base become consecutively allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:107,allocate,allocated,107,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// For each of the output shuffles, we try to sort all the first vector; // elements to the beginning, followed by the second array elements at the; // end. If the binops are legalized to smaller vectors, this may reduce total; // number of binops. We compute the ReconstructMask mask needed to convert; // back to the original lane order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:214,reduce,reduce,214,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// For each register file definition, construct a CodeGenRegisterFile object; // and add it to the appropriate scheduling model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp:111,schedul,scheduling,111,interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// For each remaining function, try to reduce that function's attributes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:39,reduce,reduce,39,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// For each symbol, we want to check its address and size; // if it's a function and write the information to the perf; // map file, otherwise we just ignore the symbol and any; // related errors. This implementation is adapted from LLVM:; // llvm/src/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/PerfJITEventListener.cpp:220,adapt,adapted,220,interpreter/cling/lib/Interpreter/PerfJITEventListener.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/PerfJITEventListener.cpp,1,['adapt'],['adapted']
Energy Efficiency,"// For each user defined register file, allocate a RegisterMappingTracker; // object. The size of every register file, as well as the mapping between; // register files and register classes is specified via tablegen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp:40,allocate,allocate,40,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// For efficient traversal, it's better to start from the end as most; // of the instrumented edges are at the end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:7,efficient,efficient,7,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// For extension loads, it may not be more efficient to chop up the vector; // and then extend it. Instead, we unroll the load and build a new vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:43,efficient,efficient,43,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// For extra ""safety"", allocate the buffers on the heap to avoid corrupting the stack should anything go wrong.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/test/ZipTest.cxx:23,allocate,allocate,23,core/zip/test/ZipTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/test/ZipTest.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// For extractions we just need to shuffle the element to index 0, which; // should be very cheap (assume cost = 1). For insertions we need to shuffle; // the elements to its destination. In both cases we must handle the; // subvector move(s).; // If the vector type is already less than 128-bits then don't reduce it.; // TODO: Under what circumstances should we shuffle using the full width?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:308,reduce,reduce,308,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,// For floating point real operands we can directly pass the scalar form; // to the binary operator emission and potentially get more efficient code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp:134,efficient,efficient,134,interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// For general purpose register loads, harden the registers loaded into.; // For other loads, harden the address loaded from.; // Masking the loaded value is expected to result in less performance; // overhead, as the load can still execute speculatively in comparison to; // when the address loaded from gets masked. However, masking is only; // easy to do efficiently on GPR registers, so for loads into non-GPR; // registers (e.g. floating point loads), mask the address loaded from.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:358,efficient,efficiently,358,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// For general targets, the prologue can grow when VFPs are allocated with; // stride 4 (more vpush instructions). But WatchOS uses a compact unwind; // format which it's more important to get right.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:60,allocate,allocated,60,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// For i64 source, we need to add the appropriate power of 2 if the input; // was negative. We must be careful to do the computation in x87 extended; // precision, not in SSE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:50,power,power,50,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power']
Energy Efficiency,"// For inlined functions, the inlined instance has been already processed; // (all its information is contained in the Symbols section).; // 'Element' points to the created 'abstract' (out-of-line) function.; // Use the parent scope information to allocate it to the correct scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp:248,allocate,allocate,248,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// For instruction that requires multiple iterations, make sure that; // the dependent instruction is not scheduled past the definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:106,schedul,scheduled,106,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// For local functions or discardable functions without comdats, check; // whether this makes the callee trivially dead. In that case, we can drop; // the body of the function eagerly which may reduce the number of callers; // of other functions to one, changing inline cost thresholds. Non-local; // discardable functions with comdats are checked later on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:194,reduce,reduce,194,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// For local functions, check whether this makes the callee trivially; // dead. In that case, we can drop the body of the function eagerly; // which may reduce the number of callers of other functions to one,; // changing inline cost thresholds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp:153,reduce,reduce,153,interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ModuleInliner.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// For loops that are acyclic path limited, aggressively schedule for; // latency. Within an single cycle, whenever CurrMOps > 0, allow normal; // heuristics to take precedence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:57,schedul,schedule,57,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['schedule']
Energy Efficiency,"// For most Thumb2 cases we just generate the 3 operand form and reduce; // it in processInstruction(), but the 3 operand form of ADD (t2ADDrr); // won't accept SP or PC so we do the transformation here taking care; // with immediate range in the 'add sp, sp #imm' case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:65,reduce,reduce,65,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// For most of the platforms we support, native and natural are the same.; // With XL, native is the same as power, natural means something else.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:109,power,power,109,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,1,['power'],['power']
Energy Efficiency,// For moveLowLatencies. After all Scheduling variants are tested.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h:35,Schedul,Scheduling,35,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,1,['Schedul'],['Scheduling']
Energy Efficiency,"// For ms_struct, allocate the entire storage unit --- unless this; // is a zero-width bitfield, in which case just use a size of 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:18,allocate,allocate,18,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// For negative multiply amounts, only allow MulAmt2 to be a power of 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:61,power,power,61,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power']
Energy Efficiency,"// For nilpotent operations or addition there may be no operands, for example; // because the expression was ""X xor X"" or consisted of 2^Bitwidth additions:; // in both cases the weight reduces to 0 causing the value to be skipped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:186,reduce,reduces,186,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// For non power-of-2 types, they will very likely be legalized into multiple; // loads. Don't bother trying to match them into extending loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:11,power,power-of-,11,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['power'],['power-of-']
Energy Efficiency,// For non-AVX512 if the Mask is of 16bit elements in lane then try to split; // since after split we get a more efficient code than vblend by using; // vpunpcklwd and vpunpckhwd instrs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:113,efficient,efficient,113,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,// For non-AVX512 if the Mask is of 16bit elements in lane then try to split; // since after split we get a more efficient code using vpunpcklwd and; // vpunpckhwd instrs than vblend.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:113,efficient,efficient,113,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// For non-array operator new, we only want to allocate one element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:47,allocate,allocate,47,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// For non-power-of-two values, effectively round the value up to the; // nearest power of two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:11,power,power-of-two,11,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['power'],"['power', 'power-of-two']"
Energy Efficiency,"// For non-zero-width bitfields in ms_struct structs, allocate a new; // storage unit if necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:54,allocate,allocate,54,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// For now TBufferXML would force use to allocate the data buffer each time and copy into the real thing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:41,allocate,allocate,41,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,2,['allocate'],['allocate']
Energy Efficiency,// For now we only need to fix up placeholder for register pressure reduce; // patterns.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:68,reduce,reduce,68,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// For now, allocate the base register(s) within the basic block; // where they're used, and don't try to keep them around outside; // of that. It may be beneficial to try sharing them more broadly; // than that, but the increased register pressure makes that a; // tricky thing to balance. Investigate if re-materializing these; // becomes an issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:12,allocate,allocate,12,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// For other empty lines, if we do have a decoration, adapt it to not; // contain a trailing whitespace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:54,adapt,adapt,54,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['adapt'],['adapt']
Energy Efficiency,// For power-of-two jumptable entry sizes convert multiplication to a shift.; // This transformation needs to be done here since otherwise the MIPS; // backend will end up emitting a three instruction multiply sequence; // instead of a single shift and MSP430 will call a runtime function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:7,power,power-of-two,7,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['power'],['power-of-two']
Energy Efficiency,// For power-of-two multiplications we can use a simpler shift expansion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:7,power,power-of-two,7,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// For pre-SSSE3 targets, if we are shuffling vXi8 elts then ISD::ROTL,; // expanded to OR(SRL,SHL), will be more efficient, but if they can; // widen to vXi16 or more then existing lowering should will be better.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:114,efficient,efficient,114,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// For pre-regalloc scheduling, create instructions corresponding to the; // SDNode and any glued SDNodes and append them to the block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:20,schedul,scheduling,20,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// For radixes of power-of-two values, the bits required is accurately and; // easily computed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:18,power,power-of-two,18,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// For real time monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx:17,monitor,monitoring,17,proof/proof/src/TDataSetManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx,3,['monitor'],['monitoring']
Energy Efficiency,"// For reserved resources, record the highest cycle using the resource.; // For top-down scheduling, this is the cycle in which we schedule this; // instruction plus the number of cycles the operations reserves the; // resource. For bottom-up is it simply the instruction's cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:89,schedul,scheduling,89,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"// For static unchunked schedules generate:; //; // 1. For distribute alone, codegen; // while (idx <= UB) {; // BODY;; // ++idx;; // }; //; // 2. When combined with 'for' (e.g. as in 'distribute parallel for'); // while (idx <= UB) {; // <CodeGen rest of pragma>(LB, UB);; // idx += ST;; // }; //; // For static chunk one schedule generate:; //; // while (IV <= GlobalUB) {; // <CodeGen rest of pragma>(LB, UB);; // LB += ST;; // UB += ST;; // UB = min(UB, GlobalUB);; // IV = LB;; // }; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:24,schedul,schedules,24,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,2,['schedul'],"['schedule', 'schedules']"
Energy Efficiency,"// For the 32-bit SVR4 ABI we follow the layout of the va_list struct.; // We suppose the given va_list is already allocated.; //; // typedef struct {; // char gpr; /* index into the array of 8 GPRs; // * stored in the register save area; // * gpr=0 corresponds to r3,; // * gpr=1 to r4, etc.; // */; // char fpr; /* index into the array of 8 FPRs; // * stored in the register save area; // * fpr=0 corresponds to f1,; // * fpr=1 to f2, etc.; // */; // char *overflow_arg_area;; // /* location on stack that holds; // * the next overflow argument; // */; // char *reg_save_area;; // /* where r3:r10 and f1:f8 (if saved); // * are stored; // */; // } va_list[1];",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:115,allocate,allocated,115,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// For the bit field use a power-of-2 type with at least 8 bits to avoid; // creating unnecessary illegal types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:27,power,power-of-,27,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['power'],['power-of-']
Energy Efficiency,"// For the page reads, we rely on the I/O scheduler to define the read requests",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:42,schedul,scheduler,42,tree/ntuple/v7/src/RPageStorageFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx,1,['schedul'],['scheduler']
Energy Efficiency,"// For the real scheduling we use a more sophisticated ready-list: it is; // sorted by the original instruction location. This lets the final schedule; // be as close as possible to the original instruction order.; // WARNING: If changing this order causes a correctness issue, that means; // there is some missing dependence edge in the schedule data graph.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:16,schedul,scheduling,16,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,3,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"// For the users of the source value being used for compare instruction, if; // the number of signed predicate is greater than unsigned predicate, we; // prefer to use SIGN_EXTEND.; //; // With this optimization, we would be able to reduce some redundant sign or; // zero extension instruction, and eventually more machine CSE opportunities; // can be exposed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp:233,reduce,reduce,233,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// For typed comparisons, not a valid schedule",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h:38,schedul,schedule,38,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,1,['schedul'],['schedule']
Energy Efficiency,// For unchunked static schedule generate:; //; // while (idx <= UB) {; // BODY;; // ++idx;; // }; //; // For static schedule with chunk one:; //; // while (IV <= PrevUB) {; // BODY;; // IV += ST;; // },MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:24,schedul,schedule,24,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,2,['schedul'],['schedule']
Energy Efficiency,"// For unsigned, try to reduce it to corresponding signed comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:24,reduce,reduce,24,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['reduce'],['reduce']
Energy Efficiency,// For use with PostRAScheduling: get the anti-dependence breaking that should; // be performed before post-RA scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:111,schedul,scheduling,111,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,2,['schedul'],['scheduling']
Energy Efficiency,// For use with PostRAScheduling: get the minimum optimization level needed; // to enable post-RA scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:98,schedul,scheduling,98,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,1,['schedul'],['scheduling']
Energy Efficiency,"// For vector and __float128 (which is represents the ""vector"" section; // in 2.2.4.1), shadow two even GPRs (skipping the odd one if it is next; // in the allocation order). To check if the GPR is even, the specific; // condition checks if the register allocated is odd, because the even; // physical registers are odd values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:254,allocate,allocated,254,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// For vector types, we assume that the best way to adapt the number; // of elements is to the next larger number of elements type for which; // the vector type is legal, unless there is no such type. In that case,; // legalize towards a vector type with a smaller number of elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp:52,adapt,adapt,52,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegacyLegalizerInfo.cpp,1,['adapt'],['adapt']
Energy Efficiency,"// For zero sized allocations, we give up.; // Since we can't reduce further",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:62,reduce,reduce,62,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Force cast these types to uint64 to reduce the number of overloads of; // `__clang_Interpreter_SetValueNoAlloc`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:39,reduce,reduce,39,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Force the current node to be scheduled before the node that; // requires the physical reg dep.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:32,schedul,scheduled,32,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// ForwardingMM - Adapter to connect MCJIT to Orc's Remote; // memory manager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h:18,Adapt,Adapter,18,interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h,1,['Adapt'],['Adapter']
Energy Efficiency,// Free all of the memory allocated to the map. Command line options may only; // be processed once!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp:26,allocate,allocated,26,interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Free root and leafs of all blocks to enable scheduling inside them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:47,schedul,scheduling,47,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Free the pre-allocated worklists for data-recursion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h:16,allocate,allocated,16,interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h,1,['allocate'],['allocated']
Energy Efficiency,"// From AMD64 ABI document:; // For calls that may call functions that use varargs or stdargs; // (prototype-less calls or calls to functions containing ellipsis (...) in; // the declaration) %al is used as hidden argument to specify the number; // of SSE registers used. The contents of %al do not need to match exactly; // the number of registers, but must be an ubound on the number of SSE; // registers used and is in the range 0 - 8 inclusive.; // Count the number of XMM registers allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:487,allocate,allocated,487,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// From the MS_Symbol_Type.pdf documentation (S_BPREL32):; // This symbol specifies symbols that are allocated on the stack for a; // procedure. For C and C++, these include the actual function parameters; // and the local non-static variables of functions.; // However, the offset for 'this' comes as a negative value.; // Symbol was created as 'variable'; determine its real kind.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp:101,allocate,allocated,101,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// From the range of values we could use for BaseOff, choose the one that; // is aligned to the highest power of two, to maximise the chance that; // the same offset can be reused for other load/store pairs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp:104,power,power,104,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,2,['power'],['power']
Energy Efficiency,"// Fully-aligned, power-of-2 sizes no larger than the inline; // width will be inlined as lock-free operations.; // Note: we do not need to check alignment since _Atomic(T) is always; // appropriately-aligned in clang.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:18,power,power-of-,18,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,1,['power'],['power-of-']
Energy Efficiency,// FuncInfo->InsertPt is passed by reference and set to the end of the; // scheduled instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:75,schedul,scheduled,75,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Function arguments for ReduceFunction,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:26,Reduce,ReduceFunction,26,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['Reduce'],['ReduceFunction']
Energy Efficiency,"// Function pointers in the 64-bit SVR4 ABI do not point to the function; // entry point, but to the function descriptor (the function entry point; // address is part of the function descriptor though).; // The function descriptor is a three doubleword structure with the; // following fields: function entry point, TOC base address and; // environment pointer.; // Thus for a call through a function pointer, the following actions need; // to be performed:; // 1. Save the TOC of the caller in the TOC save area of its stack; // frame (this is done in LowerCall_Darwin() or LowerCall_64SVR4()).; // 2. Load the address of the function entry point from the function; // descriptor.; // 3. Load the TOC of the callee from the function descriptor into r2.; // 4. Load the environment pointer from the function descriptor into; // r11.; // 5. Branch to the function entry point address.; // 6. On return of the callee, the TOC of the caller needs to be; // restored (this is done in FinishCall()).; //; // The loads are scheduled at the beginning of the call sequence, and the; // register copies are flagged together to ensure that no other; // operations can be scheduled in between. E.g. without flagging the; // copies together, a TOC access in the caller could be scheduled between; // the assignment of the callee TOC and the branch to the callee, which leads; // to incorrect code.; // Start by loading the function address from the descriptor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1017,schedul,scheduled,1017,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,3,['schedul'],['scheduled']
Energy Efficiency,// Functions having BP need to emit prologue and epilogue to allocate local; // buffer on the stack even if the function is a leaf function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:61,allocate,allocate,61,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Further reduce number of conforming protocols. If protocol P1 is in the list; // protocol P2 (P2<P1>), No need to include P1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:11,reduce,reduce,11,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Future CPU should include all of the features of Power 10 as well as any; // additional features (yet to be determined) specific to it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:52,Power,Power,52,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,1,['Power'],['Power']
Energy Efficiency,"// GATHER4 instructions use dmask in a different fashion compared to; // other MIMG instructions. The only useful DMASK values are; // 1=red, 2=green, 4=blue, 8=alpha. (e.g. 1 returns; // (red,red,red,red) etc.) The ISA document doesn't mention; // this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:144,green,green,144,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['green'],['green']
Energy Efficiency,// GCNSchedStrategy applies multiple scheduling stages to a function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:37,schedul,scheduling,37,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['schedul'],['scheduling']
Energy Efficiency,// GNU attribute tags for PowerPC ABI,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:26,Power,PowerPC,26,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// GNU attribute values for PowerPC float ABI, as combination of two parts",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:28,Power,PowerPC,28,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// Gaussian Multivariate distribution; // assume passed arrays are of correct dimensions; // use gsl_matrix_view to avoid copying the data and allocate the arrays; // covmat will return",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRndmEngines.cxx:143,allocate,allocate,143,math/mathmore/src/GSLRndmEngines.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRndmEngines.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// General purpose self-adapting Monte Carlo event generator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/inc/TFoam.h:24,adapt,adapting,24,math/foam/inc/TFoam.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/inc/TFoam.h,1,['adapt'],['adapting']
Energy Efficiency,// Generate !llvm.loop.parallel metadata for loads and stores for loops; // with dynamic/guided scheduling and without ordered clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:96,schedul,scheduling,96,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Generate PowerPC target-specific entries for scalar math functions; // that are available in IBM MASS (scalar) library.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:12,Power,PowerPC,12,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// Generate a tree of scalar operations to reduce the critical path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:43,reduce,reduce,43,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Generate the schedule as a ModuloSchedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:16,schedul,schedule,16,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Generates the following sequence for function entry:; // st %fp,-4[*%sp] !push old FP; // add %sp,8,%fp !generate new FP; // sub %sp,0x4,%sp !allocate stack space (as needed)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:145,allocate,allocate,145,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Generic stall events generated by the Scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h:41,Schedul,Scheduler,41,interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,1,['Schedul'],['Scheduler']
Energy Efficiency,// GenericScheduler::tryCandidate end; // Add powerpc specific heuristic only when TryCand isn't selected or; // selected as node order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:46,power,powerpc,46,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,1,['power'],['powerpc']
Energy Efficiency,// Get all scratch SGPRs allocated to copy/restore the SGPR spills.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h:25,allocate,allocated,25,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,1,['allocate'],['allocated']
Energy Efficiency,// Get an iterator into the processor resources consumed by this; // scheduling class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:69,schedul,scheduling,69,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,1,['schedul'],['scheduling']
Energy Efficiency,// Get estimation for interleaved load/store operations and strided load.; // \p Indices contains indices for strided load.; // \p Factor - the factor of interleaving.; // AVX-512 provides 3-src shuffles that significantly reduces the cost.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:223,reduce,reduces,223,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Get momentum and energy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h:20,energy,energy,20,math/physics/inc/TLorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h,1,['energy'],['energy']
Energy Efficiency,"// Get monitor object from the plugin manager",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPerfStats.cxx:7,monitor,monitor,7,proof/proofplayer/src/TPerfStats.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPerfStats.cxx,1,['monitor'],['monitor']
Energy Efficiency,// Get real RP for the region if it hasn't be calculated before. After the; // initial schedule stage real RP will be collected after scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:87,schedul,schedule,87,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"// Get rid of our branches, note that this will also release; // any memory allocated by TBranchElement::SetAddress().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:76,allocate,allocated,76,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// Get the constant out of the ICmp, if there is one.; // Only try this when exactly 1 operand is a constant (if both operands; // are constant, the icmp should eventually simplify). Otherwise, we may; // invert the transform that reduces set bits and infinite-loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:231,reduce,reduces,231,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['reduce'],['reduces']
Energy Efficiency,// Get the default scheduler set by the target for this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:19,schedul,scheduler,19,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// Get the definition's scheduling class descriptor from this machine model.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:24,schedul,scheduling,24,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Get the frequency for checking memory consumption and logging information",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:41,consumption,consumption,41,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['consumption'],['consumption']
Energy Efficiency,// Get the machine model's scheduling class for STPQi.; // Bypass TargetSchedule's SchedClass resolution since we only have an opcode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StorePairSuppress.cpp:27,schedul,scheduling,27,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StorePairSuppress.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StorePairSuppress.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Get the number of bytes allocated from the FrameInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:27,allocate,allocated,27,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Get the number of bytes to allocate from the FrameInfo,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp:30,allocate,allocate,30,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp,3,['allocate'],['allocate']
Energy Efficiency,// Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp:30,allocate,allocate,30,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,8,['allocate'],['allocate']
Energy Efficiency,// Get the number of bytes to allocate from the FrameInfo.; // This number of bytes is already aligned to ABI stack alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:30,allocate,allocate,30,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Get the number of parameters in the function prototype, if any.; // We will allocate space for max(Args.size(), NumParams) arguments; // in the call expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:79,allocate,allocate,79,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Get the postRA scheduler set by the target for this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:18,schedul,scheduler,18,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// Get the scheduling class of the requested instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp:11,schedul,scheduling,11,interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,2,['schedul'],['scheduling']
Energy Efficiency,// Get the scratch SGPR if allocated to save/restore \p Reg.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h:27,allocate,allocated,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,1,['allocate'],['allocated']
Energy Efficiency,// Get the size of our stack frame to be allocated ...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:41,allocate,allocated,41,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Get to the caller-allocated home save location. Add 8 to account; // for the return address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:21,allocate,allocated,21,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Get total allocated size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp:13,allocate,allocated,13,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// GetN() returns the number of allocated cells if any.; // GetN() > 0 shows how many cells; // can be available via GetP() method.; // GetN() == 0 then GetP() must return 0 as well",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/inc/TPoints3DABC.h:32,allocate,allocated,32,graf3d/g3d/inc/TPoints3DABC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/inc/TPoints3DABC.h,1,['allocate'],['allocated']
Energy Efficiency,"// Gets the adaptive weights (bandwidths) for TKernel internal computation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:12,adapt,adaptive,12,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// Give reasonable starting point for pre-fit errors by setting it to the; // absolute sigma Mostly useful for pre-fit plotting.; // Note: in commit 2129c4d920 ""[HF] Reduce verbosity of HistFactory.""; // from 2020, there was a check added to do this only for Gaussian; // constrained parameters and for Poisson constrained parameters if they; // are stat errors without any justification. In the ROOT 6.30; // development cycle, this check got removed again to cause less surprise; // to the user.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryImpl.cxx:166,Reduce,Reduce,166,roofit/histfactory/src/HistFactoryImpl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryImpl.cxx,1,['Reduce'],['Reduce']
Energy Efficiency,"// Given a floating point store from an extracted vector, with an integer; // VGETLANE that already exists, store the existing VGETLANEu directly. This can; // help reduce fp register pressure, doesn't require the fp extract and allows; // use of more integer post-inc stores not available with vstr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:165,reduce,reduce,165,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Given a scalable vector type and an index into it, returns the type for the; // smallest subvector that the index fits in. This can be used to reduce LMUL; // for operations like vslidedown.; //; // E.g. With Zvl128b, index 3 in a nxv4i32 fits within the first nxv2i32.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:146,reduce,reduce,146,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Given a set of n intervals, construct a data structure so that; // we can efficiently retrieve all intervals overlapping another; // interval or point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h:77,efficient,efficiently,77,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,1,['efficient'],['efficiently']
Energy Efficiency,"// Given an 'ISD::OR' node that is going to be selected as BFM, analyze; // the operands and select it to AArch64::ORR with shifted registers if; // that's more efficient. Returns true iff selection to AArch64::ORR happens.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:161,efficient,efficient,161,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Given an expression for the (constant) alignment, AlignSCEV, and an; // expression for the displacement between a pointer and the aligned address,; // DiffSCEV, compute the alignment of the displaced pointer if it can be reduced; // to a constant. Using SCEV to compute alignment handles the case where; // DiffSCEV is a recurrence with constant start such that the aligned offset; // is constant. e.g. {16,+,32} % 32 -> 16.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:224,reduce,reduced,224,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Given some input larger than one chunk, return the number of bytes that; // should go in the left subtree. This is the largest power-of-2 number of; // chunks that leaves at least 1 byte for the right subtree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:130,power,power-of-,130,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['power'],['power-of-']
Energy Efficiency,"// Given something like this:; //; // %x = ...Something...; // %one = G_CONSTANT i64 1; // %zero = G_CONSTANT i64 0; // %and = G_AND %x, %one; // %cmp = G_ICMP intpred(ne), %and, %zero; // %cmp_trunc = G_TRUNC %cmp; // G_BRCOND %cmp_trunc, %bb.3; //; // We want to try and fold the AND into the G_BRCOND and produce either a; // TBNZ (when we have intpred(ne)) or a TBZ (when we have intpred(eq)).; //; // In this case, we'd get; //; // TBNZ %x %bb.3; //; // Check if the AND has a constant on its RHS which we can use as a mask.; // If it's a power of 2, then it's the same as checking a specific bit.; // (e.g, ANDing with 8 == ANDing with 000...100 == testing if bit 3 is set)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:544,power,power,544,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['power'],['power']
Energy Efficiency,"// Given:; // (icmp eq/ne (and X, C0), (shift X, C1)); // or; // (icmp eq/ne X, (rotate X, CPow2)); // If C0 is a mask or shifted mask and the shift amt (C1) isolates the; // remaining bits (i.e something like `(x64 & UINT32_MAX) == (x64 >> 32)`); // Do we prefer the shift to be shift-right, shift-left, or rotate.; // Note: Its only valid to convert the rotate version to the shift version iff; // the shift-amt (`C1`) is a power of 2 (including 0).; // If ShiftOpc (current Opcode) is returned, do nothing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:426,power,power,426,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['power'],['power']
Energy Efficiency,// Global mapping from mangled symbol names to resolutions.; // Make this an optional to guard against accessing after it has been reset; // (to reduce memory after we're done with it).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h:145,reduce,reduce,145,interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,1,['reduce'],['reduce']
Energy Efficiency,"// Global variables always exist, so they always exist during the lifetime; // of each other and all allocas. Global variables themselves usually have; // non-overlapping storage, but since their addresses are constants, the; // case involving two globals does not reach here and is instead handled in; // constant folding.; //; // Two different allocas usually have different addresses...; //; // However, if there's an @llvm.stackrestore dynamically in between two; // allocas, they may have the same address. It's tempting to reduce the; // scope of the problem by only looking at *static* allocas here. That would; // cover the majority of allocas while significantly reducing the likelihood; // of having an @llvm.stackrestore pop up in the middle. However, it's not; // actually impossible for an @llvm.stackrestore to pop up in the middle of; // an entry block. Also, if we have a block that's not attached to a; // function, we can't tell if it's ""static"" under the current definition.; // Theoretically, this problem could be fixed by creating a new kind of; // instruction kind specifically for static allocas. Such a new instruction; // could be required to be at the top of the entry block, thus preventing it; // from being subject to a @llvm.stackrestore. Instcombine could even; // convert regular allocas into these special allocas. It'd be nifty.; // However, until then, this problem remains open.; //; // So, we'll assume that two non-empty allocas have different addresses; // for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:529,reduce,reduce,529,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Glue operand is already scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:27,schedul,scheduled,27,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Glue user must be scheduled together with the glue operand. So other; // users of the glue operand must be treated as its users.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:21,schedul,scheduled,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Go back to the normal schedule since we need a valid point; // of instantiation:; // Assertion failed: (Loc.isValid() &&; // ""point of instantiation must be valid!""),; // function setPointOfInstantiation, file DeclTemplate.h,; // line 1520.; // Which can happen here because the simple name maybe a; // typedef to a template (for example std::string).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:25,schedul,schedule,25,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Go back to the normal schedule since we need a valid point; // of instantiation:; // Assertion failed: (Loc.isValid() &&; // ""point of instantiation must be valid!""),; // function setPointOfInstantiation, file DeclTemplate.h,; // line 1520.; // Which can happen here because the simple name maybe a; // typedef to a template (for example std::string).; // break;; // the next code executed must be the TransactionRAII below",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:25,schedul,schedule,25,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Go through all uses of this alloca and check whether all accesses to the; // allocated object are statically known to be memory safe and, hence, the; // object can be placed on the safe stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:80,allocate,allocated,80,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Got a power of 2. So, the amount we'll shift is the log base-2 of that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:9,power,power,9,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['power'],['power']
Energy Efficiency,"// Grab the list of decls to emit. If EmitGlobalDefinition schedules more; // work, it will not interfere with this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:59,schedul,schedules,59,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['schedul'],['schedules']
Energy Efficiency,// Green Brown Terrain,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,Green,Green,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Green'],['Green']
Energy Efficiency,"// Green Brown Terrain",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx:3,Green,Green,3,core/base/src/TColor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx,1,['Green'],['Green']
Energy Efficiency,// Green Pink,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,Green,Green,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Green'],['Green']
Energy Efficiency,"// Green Pink",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx:3,Green,Green,3,core/base/src/TColor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx,1,['Green'],['Green']
Energy Efficiency,// Green Red Violet,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,Green,Green,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Green'],['Green']
Energy Efficiency,"// Green Red Violet",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx:3,Green,Green,3,core/base/src/TColor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx,1,['Green'],['Green']
Energy Efficiency,"// Green scene bounding box",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx:3,Green,Green,3,graf3d/gl/src/TGLViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx,1,['Green'],['Green']
Energy Efficiency,// Group of section allocations to be allocated together in the executor. The; // RemoteCodeAddr will stand in as the id of the group for deallocation; // purposes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.h:38,allocate,allocated,38,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.h,1,['allocate'],['allocated']
Energy Efficiency,// Groups the instructions to a bundle (which is then a single scheduling entity); // and schedules instructions until the bundle gets ready.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:63,schedul,scheduling,63,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['schedul'],"['schedules', 'scheduling']"
Energy Efficiency,// Grow allocated space if needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTVector.h:8,allocate,allocated,8,interpreter/llvm-project/clang/include/clang/AST/ASTVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTVector.h,2,['allocate'],['allocated']
Energy Efficiency,"// Grow the stack and update the stack pointer link, then determine the; // address of new allocated space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:91,allocate,allocated,91,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// H1 analysis over HTTP: adaptive packetizer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:26,adapt,adaptive,26,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// HIP uses an extern unsized array in local address space for dynamically; // allocated shared memory. In that case, we have to disable the promotion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp:79,allocate,allocated,79,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp,1,['allocate'],['allocated']
Energy Efficiency,// HIP uses an unsized array `extern __shared__ T s[]` or similar; // zero-sized type in other languages to declare the dynamic shared; // memory which size is not known at the compile time. They will be; // allocated by the runtime and placed directly after the static; // allocated ones. They all share the same offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:208,allocate,allocated,208,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,4,['allocate'],['allocated']
Energy Efficiency,"// Handle a special case. If the 2 extracts are identical, adjust the; // formulas to account for that. The extra use charge allows for either the; // CSE'd pattern or an unoptimized form with identical values:; // opcode (extelt V, C), (extelt V, C) --> extelt (opcode V, V), C",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:118,charge,charge,118,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['charge'],['charge']
Energy Efficiency,"// Handle materializing integer constants into a register. This is not; // automatically generated for PowerPC, so must be explicitly created here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:103,Power,PowerPC,103,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// Handle multiple gc.relocates of the same input efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:50,efficient,efficiently,50,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// Handle some special cases efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypesGeneric.cpp:29,efficient,efficiently,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypesGeneric.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypesGeneric.cpp,2,['efficient'],['efficiently']
Energy Efficiency,// Handle the default exit if necessary.; // FIXME: It'd be great if we could merge this with the loop below but LLVM's; // ranges aren't quite powerful enough yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:144,power,powerful,144,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['power'],['powerful']
Energy Efficiency,// Handle the non-qualified case efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:33,efficient,efficiently,33,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Handle the really simple, really trivial case efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:49,efficient,efficiently,49,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// Handle the simple case efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:26,efficient,efficiently,26,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Handle the simple, trivial case efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:35,efficient,efficiently,35,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Handle the simple, trivial, case efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:36,efficient,efficiently,36,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// Handle the simplest case efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:28,efficient,efficiently,28,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// HandleByVal - Allocate a stack slot large enough to pass an argument by; // value. The size and alignment information of the argument is encoded in its; // parameter attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:17,Allocate,Allocate,17,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,1,['Allocate'],['Allocate']
Energy Efficiency,// Hardware resources that are managed by this scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:47,schedul,scheduler,47,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,1,['schedul'],['scheduler']
Energy Efficiency,"// Hash histogram shows statistics of how efficient the hash was for the; // dynamic symbol table. The table shows the number of hash buckets for; // different lengths of chains as an absolute number and percentage of the; // total buckets, and the cumulative coverage of symbols for each set of; // buckets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:42,efficient,efficient,42,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Hash size is not a power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:22,power,power,22,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['power'],['power']
Energy Efficiency,"// Having FP implies allocframe. Allocframe will store extra 8 bytes:; // FP/LR. If the base register is used to access an object across these; // 8 bytes, then the offset will need to be adjusted by 8.; //; // After allocframe:; // HexagonISelLowering adds 8 to ---+; // the offsets of all stack-based |; // arguments (*) |; // |; // getObjectOffset < 0 0 8 getObjectOffset >= 8; // ------------------------+-----+------------------------> increasing; // <local objects> |FP/LR| <input arguments> addresses; // -----------------+------+-----+------------------------>; // | |; // SP/AP point --+ +-- FP points here (**); // somewhere on; // this side of FP/LR; //; // (*) See LowerFormalArguments. The FP/LR is assumed to be present.; // (**) *FP == old-FP. FP+0..7 are the bytes of FP/LR.; // The lowering assumes that FP/LR is present, and so the offsets of; // the formal arguments start at 8. If FP/LR is not there we need to; // reduce the offset by 8.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:935,reduce,reduce,935,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Having only one phase of training to reduce the test time.; // TString training1(""LearningRate=1e-2,Optimizer="" + optimizerStr +; // "",Momentum=0.9,Repetitions=1,""; // ""ConvergenceSteps=20,BatchSize=256,TestRepetitions=10,""; // ""WeightDecay=1e-4,Regularization=L2,""; // ""DropConfig=0.0+0.0+0.0+0.0,Multithreading=True"");; // TString training2(""LearningRate=1e-3,Optimizer="" + optimizerStr +; // "",Momentum=0.9,Repetitions=1,""; // ""ConvergenceSteps=20,BatchSize=256,TestRepetitions=10,""; // ""WeightDecay=1e-4,Regularization=L2,""; // ""DropConfig=0.0+0.0+0.0+0.0,Multithreading=True"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLOptimization.h:40,reduce,reduce,40,tmva/tmva/test/DNN/TestMethodDLOptimization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLOptimization.h,1,['reduce'],['reduce']
Energy Efficiency,// Helper for determining whether a value is a power-2 constant scalar or a; // vector of such elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:47,power,power-,47,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['power'],['power-']
Energy Efficiency,// Helper function template to reduce amount of boilerplate code for; // opcode selection.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:31,reduce,reduce,31,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Helper lambda to apply additional subregister substitutions to a known; // instruction/operand pair. Adds new (fake) substitutions so that we can; // record the subregister. FIXME: this isn't very space efficient if multiple; // values are tracked back through the same copies; cache something later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:206,efficient,efficient,206,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Here we ""fuse"" clusters together if the number of clusters is too big with respect to; // the number of slots, otherwise we can incur in an overhead which is big enough; // to make parallelisation detrimental to performance.; // For example, this is the case when, following a merging of many small files, a file; // contains a tree with many entries and with clusters of just a few entries each.; // Another problematic case is a high number of slots (e.g. 256) coupled with a high number; // of files (e.g. 1000 files): the large amount of files might result in a large amount; // of tasks, but the elevated concurrency level makes the little synchronization required by; // task initialization very expensive. In this case it's better to simply process fewer, larger tasks.; // Cluster-merging can help reduce the number of tasks down to a minumum of one task per file.; //; // The criterion according to which we fuse clusters together is to have around; // TTreeProcessorMT::GetTasksPerWorkerHint() clusters per slot.; // Concretely, for each file we will cap the number of tasks to ceil(GetTasksPerWorkerHint() * nWorkers / nFiles).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMT.cxx:809,reduce,reduce,809,tree/treeplayer/src/TTreeProcessorMT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMT.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// Here we retain a mapping from the GUID to canonical symbol name; // instead of adding it to the frame object directly to reduce memory; // overhead. This is because there can be many unique frames,; // particularly for callsite frames.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp:124,reduce,reduce,124,interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Here we shrink the arrays allocated like this:; // fExpr = new TString[gMAXOP];; // fConst = new Double_t[gMAXCONST];; // fParams = new Double_t[gMAXPAR];; // fNames = new TString[gMAXPAR];; // fOper = new Int_t[gMAXOP];; // fParams and fNames may be already 0, so we have to check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:29,allocate,allocated,29,hist/hist/src/TFormula_v5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// Here, we have a pattern like:; //; // (sra (shl val, NN), MM); // or; // (srl (shl val, NN), MM); //; // If MM >= NN, we can efficiently optimize this with bfe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:128,efficient,efficiently,128,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// Heuristic to decide the most efficient encoding.; // A ULEB can encode 7 1-bits per byte.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:32,efficient,efficient,32,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// HighLatency is the expected latency of ""very high latency"" operations.; // See TargetInstrInfo::isHighLatencyDef().; // By default, this is set to an arbitrarily high number of cycles; // likely to have some impact on scheduling heuristics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:221,schedul,scheduling,221,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['schedul'],['scheduling']
Energy Efficiency,"// Hit position.; // Float_t charge; probably specific.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveVSDStructs.h:29,charge,charge,29,graf3d/eve/inc/TEveVSDStructs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveVSDStructs.h,2,['charge'],['charge']
Energy Efficiency,// Hold all compressed instructions. Divided into groups with same opcodes; // to make the search more efficient,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86CompressEVEXTablesEmitter.cpp:103,efficient,efficient,103,interpreter/llvm-project/llvm/utils/TableGen/X86CompressEVEXTablesEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86CompressEVEXTablesEmitter.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Holds allocation information in a space efficient format where frames are; // represented using unique identifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h:43,efficient,efficient,43,interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,1,['efficient'],['efficient']
Energy Efficiency,"// Horizontal adds can use the 'addv' instruction. We model the cost of these; // instructions as twice a normal vector add, plus 1 for each legalization; // step (LT.first). This is the only arithmetic vector reduction operation for; // which we have an instruction.; // OR, XOR and AND costs should match the codegen from:; // OR: llvm/test/CodeGen/AArch64/reduce-or.ll; // XOR: llvm/test/CodeGen/AArch64/reduce-xor.ll; // AND: llvm/test/CodeGen/AArch64/reduce-and.ll",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:359,reduce,reduce-or,359,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,3,['reduce'],"['reduce-and', 'reduce-or', 'reduce-xor']"
Energy Efficiency,// How many SUs does it block from scheduling?; // Look at all of the successors of this node.; // Count the number of nodes that; // this node is the sole unscheduled node for.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:35,schedul,scheduling,35,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// How many bytes are in the ABI-defined, caller-allocated part of; // a stack frame.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCTargetDesc.h:49,allocate,allocated,49,interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCTargetDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCTargetDesc.h,1,['allocate'],['allocated']
Energy Efficiency,// How many bytes do we want to allocate here?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,allocate,allocate,32,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['allocate'],['allocate']
Energy Efficiency,// How many registers becomes live when the node is scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:52,schedul,scheduled,52,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,['schedul'],['scheduled']
Energy Efficiency,"// However, if the mask contains undef's, we have to enumerate possible tuples; // and pick one. There are bounds on replication factor: [1, mask size]; // (where RF=1 is an identity shuffle, RF=mask size is a broadcast shuffle); // Additionally, mask size is a replication factor multiplied by vector size,; // which further significantly reduces the search space.; // Before doing that, let's perform basic correctness checking first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:340,reduce,reduces,340,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Hung off uses use a single Use* before the User, while other subclasses; // use a Use[] allocated prior to the user.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp:91,allocate,allocated,91,interpreter/llvm-project/llvm/lib/IR/User.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// I'm ready to destroy any objects allocated by; // SetAddress() by my branches. If I have clones,; // tell them to zero their pointers to this shared; // memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:36,allocate,allocated,36,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// ICMP_EQ(AND(X,C),C) -> SRA(SHL(X,LOG2(C)),BW-1) iff C is power-of-2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:60,power,power-of-,60,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,// INCLUDED BELOW #include <gsl/gsl_integration.h>; /* Workspace for adaptive integrators */; // WVE MOVED TO HEAD OF FILE; /* Definition of an integration rule */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx:69,adapt,adaptive,69,roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,1,['adapt'],['adaptive']
Energy Efficiency,// Icon and cursor IDs are allocated starting from 1 and increasing for; // each icon/cursor dumped. This maintains the current ID to be allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.h:27,allocate,allocated,27,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.h,2,['allocate'],['allocated']
Energy Efficiency,// Identify instructions using metadata that needs adaptation,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:51,adapt,adaptation,51,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,2,['adapt'],['adaptation']
Energy Efficiency,"// If (i - i') is a power of 2, Bump = -sext/trunc(S) << log(i' - i).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:20,power,power,20,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,1,['power'],['power']
Energy Efficiency,"// If (i' - i) is a power of 2, Bump = sext/trunc(S) << log(i' - i).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:20,power,power,20,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,1,['power'],['power']
Energy Efficiency,"// If -slab-address is passed, require -slab-allocate and -noexec",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:45,allocate,allocate,45,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If -slab-allocate is passed, check that we're not trying to use it in; // -oop-executor or -oop-executor-connect mode.; //; // FIXME: Remove once we enable remote slab allocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:12,allocate,allocate,12,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If .set directive is supported, use it to reduce the number of; // relocations the assembler will generate for differences between; // local labels. This is only safe when the symbols are in the same; // section so we are restricting it to jumptable references.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp:45,reduce,reduce,45,interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If BB was duplicated into LPred, it is now scheduled. But because it was; // removed, markChainSuccessors won't be called for its chain. Instead we; // call markBlockSuccessors for LPred to achieve the same effect. This must go; // at the end because repeating the tail duplication can increase the number; // of unscheduled predecessors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:46,schedul,scheduled,46,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// If C is a negative power-of-2 (high-bit mask):; // (trunc X) u< C --> (X & C) != C (are any masked-high-bits clear?),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:22,power,power-of-,22,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power-of-']
Energy Efficiency,// If C is a power-of-2:; // (C << X) >u 0x8000 --> false; // (C << X) <=u 0x8000 --> true,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:13,power,power-of-,13,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['power'],['power-of-']
Energy Efficiency,// If C is not-of-power-of-2 (one clear bit):; // (trunc X) u> C --> (X & (C+1)) == C+1 (are all masked-high-bits set?),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:18,power,power-of-,18,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power-of-']
Energy Efficiency,// If C2 is a power-of-2 and C is not:; // (C2 << X) == C --> false; // (C2 << X) != C --> true,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:14,power,power-of-,14,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['power'],['power-of-']
Energy Efficiency,"// If CI can be saved in some target, like replaced inside hardware loop; // in PowerPC, no need to generate initial formulae for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:80,Power,PowerPC,80,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// If CM is the Carmichael number then a weight W satisfying W >= CM+Bitwidth; // can be replaced with W-CM. That's because x^W=x^(W-CM) for every Bitwidth; // bit number x, since either x is odd in which case x^CM = 1, or x is even in; // which case both x^W and x^(W - CM) are zero. By subtracting off multiples; // of CM like this weights can always be reduced to the range [0, CM+Bitwidth); // which by a happy accident means that they can always be represented using; // Bitwidth bits.; // TODO: Reduce the weight by exploiting nsw/nuw? (Could do much better than; // the Carmichael number).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:356,reduce,reduced,356,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,2,"['Reduce', 'reduce']","['Reduce', 'reduced']"
Energy Efficiency,// If DebugDiv > 0 then only schedule MBB with (ID % DebugDiv) == DebugMod,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:29,schedul,schedule,29,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,2,['schedul'],['schedule']
Energy Efficiency,"// If EltSize is a power of 2 then:; //; // (a) (Pos == 0 ? 0 : EltSize - Pos) == (EltSize - Pos) & (EltSize - 1); // (b) Neg == Neg & (EltSize - 1) whenever Neg is in [0, EltSize).; //; // So if EltSize is a power of 2 and Neg is (and Neg', EltSize-1), we check; // for the stronger condition:; //; // Neg & (EltSize - 1) == (EltSize - Pos) & (EltSize - 1) [A]; //; // for all Neg and Pos. Since Neg & (EltSize - 1) == Neg' & (EltSize - 1); // we can just replace Neg with Neg' for the rest of the function.; //; // In other cases we check for the even stronger condition:; //; // Neg == EltSize - Pos [B]; //; // for all Neg and Pos. Note that the (or ...) then invokes undefined; // behavior if Pos == 0 (and consequently Neg == EltSize).; //; // We could actually use [A] whenever EltSize is a power of 2, but the; // only extra cases that it would match are those uninteresting ones; // where Neg and Pos are never in range at the same time. E.g. for; // EltSize == 32, using [A] would allow a Neg of the form (sub 64, Pos); // as well as (sub 32, Pos), but:; //; // (or (shift1 X, (sub 64, Pos)), (shift2 X, Pos)); //; // always invokes undefined behavior for 32-bit X.; //; // Below, Mask == EltSize - 1 when using [A] and is all-ones otherwise.; // This allows us to peek through any operations that only affect Mask's; // un-demanded bits.; //; // NOTE: We can only do this when matching operations which won't modify the; // least Log2(EltSize) significant bits and not a general funnel shift.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,power,power,19,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,3,['power'],['power']
Energy Efficiency,"// If FrameSize <= TLI.getStackProbeSize(MF), as POWER ABI requires backchain; // pointer is always stored at SP, we will get a free probe due to an essential; // STU(X) instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:49,POWER,POWER,49,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['POWER'],['POWER']
Energy Efficiency,"// If GPR2 and GPR3 are available, then we may pass vararg in R2Q.; // If only GPR3 is available, we need to set custom handling to copy; // hi bits into GPR3.; // Either way, we allocate on the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:179,allocate,allocate,179,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,1,['allocate'],['allocate']
Energy Efficiency,"// If HazardRec is disabled, and each inst counts as one cycle, then; // advance CurCycle before ReleasePredecessors to avoid useless pushes to; // PendingQueue for schedulers that implement HasReadyFilter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:165,schedul,schedulers,165,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['schedulers']
Energy Efficiency,"// If ICMP(AND(LHS,MASK),MASK) - reduce using AND splits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:33,reduce,reduce,33,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If L >= 0 then I `ult` L <=> I >= 0 && I `slt` L; //; // To prove L >= 0 we use isKnownNonNegative whereas to prove I >= 0 we use; // isKnownPredicate. isKnownPredicate is more powerful, but also more; // expensive; and using isKnownNonNegative(RHS) is sufficient for most of the; // interesting cases seen in practice. We can consider ""upgrading"" L >= 0 to; // use isKnownPredicate later if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:180,power,powerful,180,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['power'],['powerful']
Energy Efficiency,"// If LoadSU has already been scheduled, we should clone it but; // this would negate the benefit to unfolding so just return SU.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:30,schedul,scheduled,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// If N has no uses, it is dead. Make sure to revisit all N's operands once; // N is deleted from the DAG, since they too may now be dead or may have a; // reduced number of uses, allowing other xforms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:156,reduce,reduced,156,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// If NewSU has already been scheduled, we need to clone it, but this; // negates the benefit to unfolding so just return SU.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:29,schedul,scheduled,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// If NumRegs > 1 && Glue is used then the use of the last CopyToReg is; // flagged to it. That is the CopyToReg nodes and the user are considered; // a single scheduling unit. If we create a TokenFactor and return it as; // chain, then the TokenFactor is both a predecessor (operand) of the; // user as well as a successor (the TF operands are flagged to the user).; // c1, f1 = CopyToReg; // c2, f2 = CopyToReg; // c3 = TokenFactor c1, c2; // ...; // = op c3, ..., f2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:160,schedul,scheduling,160,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// If PredND is FrameSetup, we should not pre-scheduled the node,; // or else, when bottom up scheduling, ADJCALLSTACKDOWN and; // ADJCALLSTACKUP may hold CallResource too long and make other; // calls can't be scheduled. If there's no other available node; // to schedule, the schedular will try to rename the register by; // creating copy to avoid the conflict which will fail because; // CallResource is not a real physical register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:46,schedul,scheduled,46,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,5,['schedul'],"['schedular', 'schedule', 'scheduled', 'scheduling']"
Energy Efficiency,"// If R9 was already assigned it means that we are after the fourth element; // and because this is not an HVA / Vector type, we need to allocate; // shadow XMM register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:137,allocate,allocate,137,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If RP is not reduced in the unclustered reschedule stage, revert to the; // old schedule.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:16,reduce,reduced,16,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,2,"['reduce', 'schedul']","['reduced', 'schedule']"
Energy Efficiency,"// If Reg is current live, then mark that it can't be renamed as; // we don't know the extent of its live-range anymore (now that it; // has been scheduled). If it is not live but was defined in the; // previous schedule region, then set its def index to the most; // conservative location (i.e. the beginning of the previous; // schedule region).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:146,schedul,scheduled,146,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,3,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"// If Reg is currently live, then mark that it can't be renamed as; // we don't know the extent of its live-range anymore (now that it; // has been scheduled).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:148,schedul,scheduled,148,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// If Root use can somehow reach N through a path that doesn't contain; // U then folding N would create a cycle. e.g. In the following; // diagram, Root can reach N through X. If N is folded into Root, then; // X is both a predecessor and a successor of U.; //; // [N*] //; // ^ ^ //; // / \ //; // [U*] [X]? //; // ^ ^ //; // \ / //; // \ / //; // [Root*] //; //; // * indicates nodes to be folded together.; //; // If Root produces glue, then it gets (even more) interesting. Since it; // will be ""glued"" together with its glue use in the scheduler, we need to; // check if it might reach N.; //; // [N*] //; // ^ ^ //; // / \ //; // [U*] [X]? //; // ^ ^ //; // \ \ //; // \ | //; // [Root*] | //; // ^ | //; // f | //; // | / //; // [Y] / //; // ^ / //; // f / //; // | / //; // [GU] //; //; // If GU (glue use) indirectly reaches N (the load), and Root folds N; // (call it Fold), then X is a predecessor of GU and a successor of; // Fold. But since Fold and GU are glued together, this will create; // a cycle in the scheduling graph.; // If the node has glue, walk down the graph to the ""lowest"" node in the; // glueged set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:542,schedul,scheduler,542,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,2,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,"// If SU does not have a register def, schedule it close to its uses; // because it does not lengthen any live ranges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:39,schedul,schedule,39,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,3,['schedul'],['schedule']
Energy Efficiency,"// If SU does not have a register use, i.e. it doesn't produce a value; // that would be consumed (e.g. store), then it terminates a chain of; // computation. Give it a large SethiUllman number so it will be; // scheduled right before its predecessors that it doesn't lengthen; // their live ranges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:212,schedul,scheduled,212,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,['schedul'],['scheduled']
Energy Efficiency,"// If Size is really big, allocate a separate slab for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:26,allocate,allocate,26,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,1,['allocate'],['allocate']
Energy Efficiency,"// If To is also scheduled to be replaced, find what its ultimate; // replacement is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:17,schedul,scheduled,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// If a VMLA.F is followed by an VADD.F or VMUL.F with no RAW hazard, the; // VADD.F or VMUL.F will stall 4 cycles before issue. The 4 cycle stall; // preserves the in-order retirement of the instructions.; // Look at the next few instructions, if *most* of them can cause hazards,; // then the scheduler can't *fix* this, we'd better break up the VMLA.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp:295,schedul,scheduler,295,interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// If a fully qualified arg is different from the unqualified arg,; // allocate new type in the AST.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp:71,allocate,allocate,71,interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// If a function is marked as arm_locally_streaming, then the runtime value of; // vscale in the prologue/epilogue is different the runtime value of vscale; // in the function's body. To avoid having to consider multiple vscales,; // we can use `addsvl` to allocate any scalable stack-slots, which under; // most circumstances will be only locals, not callee-save slots.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:257,allocate,allocate,257,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If a register from this partition is used in a fixed instruction,; // and there is also a register in this partition that is used in; // a loop phi node, then decrease the splitting profit as this can; // confuse the modulo scheduler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:227,schedul,scheduler,227,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// If a schedule is found, check if it is a valid schedule too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:8,schedul,schedule,8,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['schedul'],['schedule']
Energy Efficiency,"// If a schedule is found, ensure non-pipelined instructions are in stage 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:8,schedul,schedule,8,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// If a schedule was found and the option is enabled, check if the schedule; // might generate additional register spills/fills.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:8,schedul,schedule,8,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['schedul'],['schedule']
Energy Efficiency,// If a string table is allocated we don't want to mess with it. That would; // mean altering the memory image. There are no special link types or; // anything so we can just use a Section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp:24,allocate,allocated,24,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If a trip multiple is huge (>=2^32), the trip count is still divisible by; // the greatest power of 2 divisor less than 2^32.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:94,power,power,94,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['power'],['power']
Energy Efficiency,"// If a value has been allocated, add it to the set for tracking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:23,allocate,allocated,23,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If all of the reduced values are constant, the vector cost is 0, since; // the reduction value can be calculated at the compile time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,reduce,reduced,17,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// If all registers are allocated, then all varargs must be passed on the; // stack and we don't need to save any argregs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp:24,allocate,allocated,24,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp,4,['allocate'],['allocated']
Energy Efficiency,"// If all the Operands of BUILD_VECTOR extract from same; // vector, then split the vector efficiently based on the maximum; // vector access index and adjust the VectorMask and; // VecIn accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,efficient,efficiently,91,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp:38,schedul,scheduled,38,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,2,['schedul'],['scheduled']
Energy Efficiency,"// If all the node's successors are scheduled, this node is ready; // to be scheduled. Ignore the special EntrySU node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:36,schedul,scheduled,36,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,4,['schedul'],['scheduled']
Energy Efficiency,"// If all the regs are reserved, return raw RegPressureSetLimit.; // One example is VRSAVERC in PowerPC.; // Avoid returning zero, getRegPressureSetLimit(Idx) assumes computePSetLimit; // return non-zero value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:96,Power,PowerPC,96,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// If all variables have reached their maximum power, then we; // break out of the loop",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:47,power,power,47,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['power'],['power']
Energy Efficiency,"// If an array has more than SSPBufferSize bytes of allocated space, then we; // emit stack protectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:52,allocate,allocated,52,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If any element has the present modifier, then make sure the runtime; // doesn't attempt to allocate the struct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:94,allocate,allocate,94,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If any of the arguments is passed indirectly, it must be SVE, so the; // 'getBytesInStackArgArea' is not sufficient to determine whether we need to; // allocate space on the stack. That is why we determine this explicitly here; // the call cannot be a tailcall.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:155,allocate,allocate,155,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If any of the destination registers in the bundle of copies alias any of; // the source registers, try to schedule the instructions to avoid any; // clobbering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:109,schedul,schedule,109,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// If any subunits are used by the instruction, report that the; // subunits of the resource group are available at the first cycle; // in which the unit is available, effectively removing the group; // record from hazarding and basing the hazarding decisions on the; // subunit records. Otherwise, choose the first available instance; // from among the subunits. Specifications which assign cycles to; // both the subunits and the group or which use an unbuffered; // group with buffered subunits will appear to schedule; // strangely. In the first case, the additional cycles for the; // group will be ignored. In the second, the group will be; // ignored entirely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:513,schedul,schedule,513,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// If both X and Y are bswap/bitreverse, the transform reduces the number; // of instructions even if there's multiuse.; // If only one operand is bswap/bitreverse, we need to ensure the operand; // have only one use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:55,reduce,reduces,55,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// If bottom of block BB has only one successor OldTop, in most cases it is; // profitable to move it before OldTop, except the following case:; //; // -->OldTop<-; // | . |; // | . |; // | . |; // ---Pred |; // | |; // BB-----; //; // If BB is moved before OldTop, Pred needs a taken branch to BB, and it can't; // layout the other successor below it, so it can't reduce taken branch.; // In this case we keep its original layout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:365,reduce,reduce,365,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If c is power of 2, return (shl x, log2(c)).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:11,power,power,11,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['power'],['power']
Energy Efficiency,// If compounding and duplexing didn't reduce the size below; // 4 or less we have a packet that is too big.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:39,reduce,reduce,39,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If data set contains more rows than needed, make reduced copy first",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:52,reduce,reduced,52,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,2,['reduce'],['reduced']
Energy Efficiency,"// If desugaring happened allocate new type in the AST.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:26,allocate,allocate,26,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,5,['allocate'],['allocate']
Energy Efficiency,"// If either Q has a single candidate that provides the least increase in; // Excess pressure, we can immediately schedule from that Q.; //; // RegionCriticalPSets summarizes the pressure within the scheduled region and; // affects picking from either Q. If scheduling in one direction must; // increase pressure for one of the excess PSets, then schedule in that; // direction first to provide more freedom in the other direction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:114,schedul,schedule,114,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,4,['schedul'],"['schedule', 'scheduled', 'scheduling']"
Energy Efficiency,"// If either node is scheduling for latency, sort them by height/depth; // and latency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:21,schedul,scheduling,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// If either node is scheduling for latency, sort them by height/depth; // and latency.; // If neither instruction stalls (!LStall && !RStall) and HazardRecognizer; // is enabled, grouping instructions by cycle, then its height is already; // covered so only its depth matters. We also reach this point if both stall; // but have the same height.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNILPSched.cpp:21,schedul,scheduling,21,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNILPSched.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNILPSched.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// If evaluation error printing is disabled, we don't need to collect the; // errors and only need to count them. This significantly reduces the; // performance overhead when having evaluation errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizer.cxx:133,reduce,reduces,133,roofit/roofitcore/src/RooMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizer.cxx,1,['reduce'],['reduces']
Energy Efficiency,"// If every element is an all-sign value, see if we can use TESTP/MOVMSK; // to more efficiently extract the sign bits and compare that.; // TODO: Handle TESTC with comparison inversion.; // TODO: Can we remove SimplifyMultipleUseDemandedBits and rely on; // TESTP/MOVMSK combines to make sure its never worse than PTEST?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:85,efficient,efficiently,85,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// If function acquires its own stack frame, then it is not a XPLeaf routine.; // At the time this function is called, only slots for local variables are; // allocated, so this is a very rough estimate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:158,allocate,allocated,158,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// If i8 V is a power of two or zero:; // ZeroBits: 1 1 1 0 1 1 1 1; // ~ZeroBits: 0 0 0 1 0 0 0 0,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:16,power,power,16,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['power'],['power']
Energy Efficiency,"// If it is an array and it was allocated by the leaf itself,; // let's make sure it is large enough for the incoming data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:32,allocate,allocated,32,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// If it's a non-power-of-2 vector, its size is already a power-of-2,; // so make sure to widen it explicitly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.cpp:17,power,power-of-,17,interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.cpp,2,['power'],['power-of-']
Energy Efficiency,"// If it's a parameter type, the normal ABI rule is that arguments larger; // than 8 bytes are passed indirectly. GCC follows it. We follow it too,; // even though it isn't particularly efficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:186,efficient,efficient,186,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// If it's ambiguous, it should be illegal to call operator delete[]; // on this thing, so it doesn't matter if we allocate extra space or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:115,allocate,allocate,115,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If it's not already specified, allocate memory for the global.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:34,allocate,allocate,34,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,1,['allocate'],['allocate']
Energy Efficiency,// If necessary allocate a register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:16,allocate,allocate,16,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If necessary, allocate the global offset table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:17,allocate,allocate,17,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If no throughput value was calculated, assume that we can execute at the; // maximum issue width scaled by number of micro-ops for the schedule class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp:138,schedul,schedule,138,interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// If not allocated in the object address space, this object will be in; // linear memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp:10,allocate,allocated,10,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If not loading a power-of-2 number of bits, expand as two loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:20,power,power-of-,20,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['power'],['power-of-']
Energy Efficiency,"// If not storing a power-of-2 number of bits, expand as two stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:20,power,power-of-,20,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['power'],['power-of-']
Energy Efficiency,"// If not, can we find an appropriate subtype in the original allocated type?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:62,allocate,allocated,62,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If not, is this expression something we can't reduce any further?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:49,reduce,reduce,49,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If one reduces the caller size while the other doesn't, then return; // true iff P1 reduces the caller size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:10,reduce,reduces,10,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,2,['reduce'],['reduces']
Energy Efficiency,"// If one side of the equality comparison must come from a noalias call; // (meaning a system memory allocation function), and the other side must; // come from a pointer that cannot overlap with dynamically-allocated; // memory within the lifetime of the current function (allocas, byval; // arguments, globals), then determine the comparison result here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:208,allocate,allocated,208,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If power is even:; // powi(-x, p) -> powi(x, p); // powi(fabs(x), p) -> powi(x, p); // powi(copysign(x, y), p) -> powi(x, p)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:6,power,power,6,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['power'],['power']
Energy Efficiency,// If ran into the whole component - allocate the space for the whole; // record.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:37,allocate,allocate,37,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If resources are available for it, multiply the; // chance of scheduling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:65,schedul,scheduling,65,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,4,['schedul'],['scheduling']
Energy Efficiency,"// If scheduling an SU that must begin a new decoder group, move on; // to next group.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:6,schedul,scheduling,6,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// If scheduling one of the node will cause a pipeline stall, delay it.; // If scheduling either one of the node will cause a pipeline stall, sort; // them according to their height.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:6,schedul,scheduling,6,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,['schedul'],['scheduling']
Energy Efficiency,"// If so, we can queue them all as live in loads. We don't have an; // efficient way to tell which on is first in the block and don't want to; // scan large blocks, so just add all loads as live ins.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:71,efficient,efficient,71,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// If space has not been reserved for a call frame, ADJCALLSTACKDOWN and; // ADJCALLSTACKUP must be converted to instructions manipulating the stack; // pointer. This is necessary when there is a variable length stack; // allocation (e.g. alloca), which means it's not possible to allocate; // space for outgoing arguments from within the function prologue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp:281,allocate,allocate,281,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,3,['allocate'],['allocate']
Energy Efficiency,"// If specified then alignment must be a ""small"" power of two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:49,power,power,49,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,1,['power'],['power']
Energy Efficiency,"// If splitting the underlying data structure can reduce the offset of a; // GEP, collect the GEP. Skip the GEPs that are the new bases of; // previously split data structures.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:50,reduce,reduce,50,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If sufficiently aligned we can scalarize stores of constant vectors of; // any power-of-two size up to XLen bits, provided that they aren't too; // expensive to materialize.; // vsetivli zero, 2, e8, m1, ta, ma; // vmv.v.i v8, 4; // vse64.v v8, (a0); // ->; // li a1, 1028; // sh a1, 0(a0)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:82,power,power-of-two,82,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// If the (non-volatile) load only has one use, we can rewrite this to a; // load from a GEP. This reduces the size of the load. If a load is used; // only by extractvalue instructions then this either must have been; // optimized before, or it is a struct with padding, in which case we; // don't want to do the transformation as it loses padding knowledge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:99,reduce,reduces,99,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// If the LHS and RHS of the ADC node are zero, then it can't overflow and; // the result is either zero or one (depending on the input carry bit).; // Strength reduce this down to a ""set on carry"" aka SETCC_CARRY&1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:161,reduce,reduce,161,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If the Low and High values are themselves loop-variant, then we may want; // to expand the range to include those covered by the outer loop as well.; // There is a trade-off here with the advantage being that creating checks; // using the expanded range permits the runtime memory checks to be hoisted; // out of the outer loop. This reduces the cost of entering the inner loop,; // which can be significant for low trip counts. The disadvantage is that; // there is a chance we may now never enter the vectorized inner loop,; // whereas using a restricted range check could have allowed us to enter at; // least once. This is why the behaviour is not currently the default and is; // controlled by the parameter 'HoistRuntimeChecks'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:337,reduce,reduces,337,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// If the Phi has been scheduled, use the new name for rewriting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:23,schedul,scheduled,23,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// If the Phi hasn't been scheduled, then use the initial Phi operand; // value. Otherwise, use the scheduled version of the instruction. This; // is a little complicated when a Phi references another Phi.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:26,schedul,scheduled,26,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,2,['schedul'],['scheduled']
Energy Efficiency,"// If the SUnit has other dependencies on the SUnit that it; // anti-depends on, don't bother breaking the anti-dependency; // since those edges would prevent such units from being; // scheduled past each other regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:185,schedul,scheduled,185,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// If the SUnit has other dependencies on the SUnit that; // it anti-depends on, don't bother breaking the; // anti-dependency since those edges would prevent such; // units from being scheduled past each other; // regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:185,schedul,scheduled,185,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// If the SVal represents a structure, try to mass-taint all values within the; // structure. For now it only works efficiently on lazy compound values that; // were conjured during a conservative evaluation of a function - either as; // return values of functions that return structures or arrays by value, or as; // values of structures or arrays passed into the function by reference,; // directly or through pointer aliasing. Such lazy compound values are; // characterized by having exactly one binding in their captured store within; // their parent region, which is a conjured symbol default-bound to the base; // region of the parent region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp:116,efficient,efficiently,116,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// If the ZExt can be lowered to a single ZExt to the next power-of-2 and; // the remaining ZExt folded into the user, don't use tbl lowering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:59,power,power-of-,59,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,"// If the address is the result of an add, we will utilize the fact that the; // address calculation includes an implicit add. However, we can reduce; // register pressure if we do not materialize a constant just for use as the; // index register. We only get rid of the add if it is not an add of a; // value and a 16-bit signed constant and both have a single use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:143,reduce,reduce,143,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['reduce'],['reduce']
Energy Efficiency,"// If the alignment is not a power of 2, round up to the next power of 2.; // This happens for non-power-of-2 length vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:29,power,power,29,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,3,['power'],"['power', 'power-of-']"
Energy Efficiency,// If the allocated symbol is null do not report.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:10,allocate,allocated,10,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,// If the amount of scratch memory to eliminate exceeds our ability to allocate; // it into registers we gain nothing by aggressively inlining functions for that; // heuristic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:71,allocate,allocate,71,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If the argument points to something that's not a symbolic region, it; // can be:; // - unknown (cannot reason about it); // - undefined (already reported by other checker); // - constant (null - should not be tracked,; // other constant will generate a compiler warning); // - goto (should be reported by other checker); // The call return value symbol should stay alive for as long as the; // allocated value symbol, since our diagnostics depend on the value; // returned by the call. Ex: Data should only be freed if noErr was; // returned during allocation.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:397,allocate,allocated,397,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If the block has the only successor then live-ins of that successor are; // live-outs of the current block. We can reuse calculated live set if the; // successor will be sent to scheduling past current block.; // However, due to the bug in LiveInterval analysis it may happen that two; // predecessors of the same successor block have different lane bitmasks for; // a live-out register. Workaround that by sticking to one-to-one relationship; // i.e. one predecessor with one successor block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:181,schedul,scheduling,181,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// If the cache was allocated, free it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:20,allocate,allocated,20,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,// If the caller is a recursive function then we don't want to inline; // functions which allocate a lot of stack space because it would increase; // the caller stack usage dramatically.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:90,allocate,allocate,90,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If the case number of suspended switch instruction is reduced to; // 1, then it is simplified to CmpInst in llvm::ConstantFoldTerminator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:57,reduce,reduced,57,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// If the column range is already uncompressed we don't need to allocate any new buffer, so we don't; // bother reserving memory for them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:64,allocate,allocate,64,tree/ntuple/v7/src/RNTupleMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// If the constant difference overflows, then instsimplify should reduce the; // min/max to the add or C1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:66,reduce,reduce,66,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If the displacement is not an exact multiple, but the remainder is a; // constant, then return this remainder (but only if it is a power of 2).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:134,power,power,134,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,1,['power'],['power']
Energy Efficiency,"// If the divisor is a select-of-constants, try to constant fold all div ops:; // C / (select Cond, TrueC, FalseC) --> select Cond, (C / TrueC), (C / FalseC); // TODO: Adapt simplifyDivRemOfSelectWithZeroOp to allow this and other folds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:168,Adapt,Adapt,168,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['Adapt'],['Adapt']
Energy Efficiency,"// If the divisor is a select-of-constants, try to constant fold all rem ops:; // C % (select Cond, TrueC, FalseC) --> select Cond, (C % TrueC), (C % FalseC); // TODO: Adapt simplifyDivRemOfSelectWithZeroOp to allow this and other folds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:168,Adapt,Adapt,168,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['Adapt'],['Adapt']
Energy Efficiency,"// If the edge from this terminator to a successor dominates that successor,; // store a map from each block in its dominator subtree to it. This lets us; // tell when cloning for a particular successor if a block is dominated by; // some *other* successor with a single data structure. We use this to; // significantly reduce cloning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:320,reduce,reduce,320,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If the edge is not an instruction, or it is different from the main; // reduction opcode or has too many uses - possible reduced value.; // Also, do not try to reduce const values, if the operation is not; // foldable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:124,reduce,reduced,124,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"// If the element width is not a power of 2, round it up; // to the next one. Do this for widths not exceeding 32.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:33,power,power,33,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['power'],['power']
Energy Efficiency,"// If the following two conditions are met:; //; // 1. mask B covers only a single bit that's not covered by mask D, that is,; // (B & (B ^ D)) is a power of 2 (in other words, B minus the intersection of; // B and D has only one bit set) and,; //; // 2. RHS (and E) indicates that the rest of B's bits are zero (in other; // words, the intersection of B and D is zero), that is, ((B & D) & E) == 0; //; // then that single bit in B must be one and thus the whole expression can be; // folded to; // (A & (B | D)) == (B & (B ^ D)) | E.; //; // For example,; // (icmp ne (A & 12), 0) & (icmp eq (A & 7), 1) -> (icmp eq (A & 15), 9); // (icmp ne (A & 15), 0) & (icmp eq (A & 7), 0) -> (icmp eq (A & 15), 8)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:149,power,power,149,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['power'],['power']
Energy Efficiency,"// If the font has previously been allocated, but the ""fontValid"" bitmap; // shows it is no longer valid, then mark it for freeing later. We use; // a policy of allocate-before-free because xclass' font cache operates; // much more efficiently that way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx:35,allocate,allocated,35,gui/guihtml/src/TGHtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx,3,"['allocate', 'efficient']","['allocate-before-free', 'allocated', 'efficiently']"
Energy Efficiency,"// If the global is being linked for an indirect symbol, it may have already; // been scheduled to satisfy a regular symbol. Similarly, a global being linked; // for a regular symbol may have already been scheduled for an indirect; // symbol. Check for these cases by looking in the other value map and; // confirming the same value has been scheduled. If there is an entry in the; // ValueMap but the value is different, it means that the value already had a; // definition in the destination module (linkonce for instance), but we need a; // new definition for the indirect symbol (""New"" will be different).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:86,schedul,scheduled,86,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,3,['schedul'],['scheduled']
Energy Efficiency,"// If the group has now filled all of its slots, or if we're using a special; // group-terminating nop, the group is complete.; // FIXME: the same for P9 as previous gen until POWER9 scheduling is ready",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:183,schedul,scheduling,183,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// If the immediate value is too big for the immoffset field, put only bits; // that would normally fit in the immoffset field. The remaining value that; // is copied/added for the voffset field is a large power of 2, and it; // stands more chance of being CSEd with the copy/add for another similar; // load/store.; // However, do not do that rounding down if that is a negative; // number, as it appears to be illegal to have a negative offset in the; // vgpr, even if adding the immediate offset makes it positive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:206,power,power,206,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,3,['power'],['power']
Energy Efficiency,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:125,schedul,scheduled,125,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,3,['schedul'],"['scheduled', 'scheduler']"
Energy Efficiency,"// If the instruction's allocated size doesn't equal it's type size, it; // requires padding and will be scalarized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,allocate,allocated,24,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['allocate'],['allocated']
Energy Efficiency,// If the kernel accesses a variable that is going to be stored in the; // module instance through a call then that kernel needs to allocate the; // module instance,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:132,allocate,allocate,132,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['allocate'],['allocate']
Energy Efficiency,// If the left-shift isn't masked out then the only way this is a bswap is; // if all bits beyond the low 8 are 0. In that case the entire pattern; // reduces to a left shift anyway: leave it for other parts of the combiner.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:151,reduce,reduces,151,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// If the list of values does not have power-of-2 elements, append copies; // of the sign bit to it, to make the size be 2^n.; // The reason for this is that the values will be joined in pairs, because; // otherwise the shuffles will result in convoluted code. With pairwise; // joins, the shuffles will hopefully be folded into a perfect shuffle.; // The output will need to be sign-extended to a type with element width; // being a power-of-2 anyways.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:39,power,power-of-,39,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,2,['power'],['power-of-']
Energy Efficiency,"// If the load and store are consecutive, use the loadInst location to; // reduce register pressure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:75,reduce,reduce,75,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If the load contains vectors, build the vector using concat vector.; // All of the vectors used to load are power-of-2, and the scalar loads can be; // combined to make a power-of-2 vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:111,power,power-of-,111,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,2,['power'],['power-of-']
Energy Efficiency,"// If the loop contains a convergent operation, the prelude we'd add; // to do the first few instructions before we hit the unrolled loop; // is unsafe -- it adds a control-flow dependency to the convergent; // operation. Therefore restrict remainder loop (try unrolling without).; //; // TODO: This is quite conservative. In practice, convergent_op(); // is likely to be called unconditionally in the loop. In this; // case, the program would be ill-formed (on most architectures); // unless n were the same on all threads in a thread group.; // Assuming n is the same on all threads, any kind of unrolling is; // safe. But currently llvm's notion of convergence isn't powerful; // enough to express this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:670,power,powerful,670,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['power'],['powerful']
Energy Efficiency,"// If the mask chooses an element from operand 1, reduce it to choose from the; // corresponding element of operand 0. Undef mask elements are unchanged.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:50,reduce,reduce,50,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If the next token is obviously a // or /* */ comment, skip it efficiently; // too (without going through the big switch stmt).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:65,efficient,efficiently,65,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// If the normalization in the plot is right, the reduced chi-square of the; // the plot will be good (i.e. less than one) as the data was directly; // sampled from the model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAddPdf.cxx:50,reduce,reduced,50,roofit/roofitcore/test/testRooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAddPdf.cxx,1,['reduce'],['reduced']
Energy Efficiency,"// If the number of signbits allows, see if we can lower as a <N x i8>.; // Our main goal here is to reduce LMUL (and thus work) required to; // build the constant, but we will also narrow if the resulting; // narrow vector is known to materialize cheaply.; // TODO: We really should be costing the smaller vector. There are; // profitable cases this misses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:101,reduce,reduce,101,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If the offset is 0 and the AfterCSR pop is not actually trying to; // allocate more stack for arguments (in space that an untimely interrupt; // may clobber), convert it to a post-index ldp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:73,allocate,allocate,73,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If the original load and store to xmm/ymm were consecutive; // then the partial copies were also created in; // a consecutive order to reduce register pressure,; // and the location of the last load is before the last store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:138,reduce,reduce,138,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If the other operand also isn't the same as the destination, we; // can't reduce.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:77,reduce,reduce,77,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If the other operand is a 8-bit immediate we should fold the immediate; // instead. This reduces code size.; // e.g.; // movl 4(%esp), %eax; // addl $4, %eax; // vs.; // movl $4, %eax; // addl 4(%esp), %eax; // The former is 2 bytes shorter. In case where the increment is 1, then; // the saving can be 4 bytes (by using incl %eax).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:92,reduce,reduces,92,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['reduce'],['reduces']
Energy Efficiency,// If the packet contains a potential dot cur instruction. This is; // used for the scheduling priority function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:84,schedul,scheduling,84,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,1,['schedul'],['scheduling']
Energy Efficiency,"// If the page was not yet allocated, allocate it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:27,allocate,allocated,27,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// If the pattern matches, truncate the inputs to the narrower type and; // use the sadd_with_overflow intrinsic to efficiently compute both the; // result and the overflow bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:116,efficient,efficiently,116,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// If the phi is not used by anything else, we can just adapt it when; // replacing the instruction; if it is, we'll have to duplicate it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:56,adapt,adapt,56,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,1,['adapt'],['adapt']
Energy Efficiency,"// If the physreg has no defs anywhere, it's just an ambient register; // and we can freely move its uses. Alternatively, if it's allocatable,; // it could get allocated to something with a def during allocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:160,allocate,allocated,160,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// If the physreg has no defs anywhere, it's just an ambient register; // and we can freely move its uses. Alternatively, if it's allocatable,; // it could get allocated to something with a def during allocation.; // However, if the physreg is known to always be caller saved/restored; // then this use is safe to hoist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp:160,allocate,allocated,160,interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// If the physreg is at the boundary, defer it. Otherwise schedule it; // immediately to free the dependent. We can hoist the copy later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:58,schedul,schedule,58,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// If the pointer is allocated or escaped, but we are now trying to free it,; // check that the call to free is proper.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:21,allocate,allocated,21,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If the private variable is a local variable with lvalue ref type,; // allocate the pointer instead of the pointee type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:73,allocate,allocate,73,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If the promoted type is legal, we can convert this to:; // 1. ANY_EXTEND iN to iM; // 2. SHL by M-N; // 3. [US][ADD|SUB|SHL]SAT; // 4. L/ASHR by M-N; // Else it is more efficient to convert this to a min and a max; // operation in the higher precision arithmetic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:172,efficient,efficient,172,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['efficient'],['efficient']
Energy Efficiency,// If the register is marked as shadow allocated - assign to it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:39,allocate,allocated,39,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,1,['allocate'],['allocated']
Energy Efficiency,// If the register is not marked as allocated - assign to it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:36,allocate,allocated,36,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If the remaining bits don't fit in 12 bits, we might be able to reduce the; // shift amount in order to use LUI which will zero the lower 12 bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:67,reduce,reduce,67,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If the requested bitfield extends beyond the most significant bit,; // the extra bits are treated as 0s. To emulate this behavior, reduce; // the number of requested bits, and make the extract unsigned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:134,reduce,reduce,134,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If the runtime memory checks are being created inside an outer loop; // we should find out if these checks are outer loop invariant. If so,; // the checks will likely be hoisted out and so the effective cost will; // reduce according to the outer loop trip count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:220,reduce,reduce,220,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If the scalar value 'I' is going to be re-inserted into a vector, then try; // to create an extract to that same element. The extract/insert can be; // reduced to a ""select shuffle"".; // TODO: If we add a larger pattern match that starts from an insert, this; // probably becomes unnecessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:155,reduce,reduced,155,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['reduce'],['reduced']
Energy Efficiency,// If the scheduling region got new instructions at the lower end (or it; // is a new region for the first bundle). This makes it necessary to; // recalculate all dependencies.; // Otherwise the compiler may crash trying to incorrectly calculate; // dependencies and emit instruction in the wrong order at the actual; // scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:10,schedul,scheduling,10,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['schedul'],['scheduling']
Energy Efficiency,"// If the sealed page is smaller than the maximum size (with compression), allocate what is needed and copy the; // sealed page content to save memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:75,allocate,allocate,75,tree/ntuple/v7/src/RPageSinkBuf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// If the shifted constant is a power-of-2, test the shift amount directly:; // (ShiftValC >> Y) >u C --> X <u (LZ(C) - LZ(ShiftValC)); // (ShiftValC >> Y) <u C --> X >=u (LZ(C-1) - LZ(ShiftValC))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:32,power,power-of-,32,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power-of-']
Energy Efficiency,// If the shuffle mask is repeated in each 128-bit lane we can use more; // efficient instructions that mirror the shuffles across the four 128-bit; // lanes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:76,efficient,efficient,76,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,// If the shuffle mask is repeated in each 128-bit lane we can use more; // efficient instructions that mirror the shuffles across the two 128-bit; // lanes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:76,efficient,efficient,76,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// If the shuffle mask is repeated in each 128-bit lane, we have many more; // options to efficiently lower the shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:90,efficient,efficiently,90,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['efficient'],['efficiently']
Energy Efficiency,"// If the signed type can represent all values of the unsigned type, it; // wins. Because we are dealing with 2's complement and types that are; // powers of two larger than each other, this is always safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:148,power,powers,148,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,['power'],['powers']
Energy Efficiency,"// If the size of the type doesn't exceed the platform's max; // atomic promotion width, make the size and alignment more; // favorable to atomic operations:; // Round the size up to a power of 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:185,power,power,185,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['power'],['power']
Energy Efficiency,"// If the source register is SP, try to reduce to tADDrSPi, otherwise; // it's a normal reduce.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:40,reduce,reduce,40,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,2,['reduce'],['reduce']
Energy Efficiency,"// If the stack pointer has a surprising value, we do not understand this; // stack usage scheme. (Perhaps the target allocates new stack regions on; // demand for us.) Don't try to guess what's going on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Stack.cpp:118,allocate,allocates,118,interpreter/llvm-project/clang/lib/Basic/Stack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Stack.cpp,1,['allocate'],['allocates']
Energy Efficiency,"// If the stack was realigned, the frame pointer is set in order to allow; // SP to be restored, so we need another base register to record the stack; // after realignment.; // |--------------------------| -- <-- FP; // | callee-allocated save | | <----|; // | area for register varargs| | |; // |--------------------------| | |; // | callee-saved registers | | |; // |--------------------------| -- |; // | realignment (the size of | | |; // | this area is not counted | | |; // | in MFI.getStackSize()) | | |; // |--------------------------| -- |-- MFI.getStackSize(); // | RVV alignment padding | | |; // | (not counted in | | |; // | MFI.getStackSize() but | | |; // | counted in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | RVV objects | | |; // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | padding before RVV | | |; // | (not counted in | | |; // | MFI.getStackSize() or in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | scalar local variables | | <----'; // |--------------------------| -- <-- BP (if var sized objects present); // | VarSize objects | |; // |--------------------------| -- <-- SP",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:229,allocate,allocated,229,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If the state is not SCHEDULED, then we previously errored on start.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:23,SCHEDUL,SCHEDULED,23,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['SCHEDUL'],['SCHEDULED']
Energy Efficiency,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:355,power,power,355,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['power'],['power']
Energy Efficiency,"// If the tailcall address may be in a register, then make sure it's; // possible to register allocate for it. In 32-bit, the call address can; // only target EAX, EDX, or ECX since the tail call must be scheduled after; // callee-saved registers are restored. These happen to be the same; // registers used to pass 'inreg' arguments so watch out for those.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:94,allocate,allocate,94,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,2,"['allocate', 'schedul']","['allocate', 'scheduled']"
Energy Efficiency,"// If the tailcall address may be in a register, then make sure it's; // possible to register allocate for it. The call address can; // only target %A0 or %A1 since the tail call must be scheduled after; // callee-saved registers are restored. These happen to be the same; // registers used to pass 'inreg' arguments so watch out for those.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:94,allocate,allocate,94,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,2,"['allocate', 'schedul']","['allocate', 'scheduled']"
Energy Efficiency,"// If the target didn't lower this, lower it to '__sync_synchronize()' call; // FIXME: handle ""fence singlethread"" more efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:120,efficient,efficiently,120,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// If the target has spilled this register to another register, we don't; // need to allocate a stack slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:85,allocate,allocate,85,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If the target is not powerpc, map the coal sections to the non-coal; // sections.; //; // ""__TEXT/__textcoal_nt"" => section ""__TEXT/__text""; // ""__TEXT/__const_coal"" => section ""__TEXT/__const""; // ""__DATA/__datacoal_nt"" => section ""__DATA/__data""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectFileInfo.cpp:24,power,powerpc,24,interpreter/llvm-project/llvm/lib/MC/MCObjectFileInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectFileInfo.cpp,1,['power'],['powerpc']
Energy Efficiency,"// If the target support VNNI, leave it to ISel to combine reduce operation; // to VNNI instruction.; // TODO: we can support transforming reduce to VNNI intrinsic for across block; // in this pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp:59,reduce,reduce,59,interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp,2,['reduce'],['reduce']
Energy Efficiency,"// If the target supports an 'and-not' or 'and-complement' logic operation,; // try to use that to make a comparison operation more efficient.; // But don't do this transform if the mask is a single bit because there are; // more efficient ways to deal with that case (for example, 'bt' on x86 or; // 'rlwinm' on PPC).; // Bail out if the compare operand that we want to turn into a zero is; // already a zero (otherwise, infinite loop).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:132,efficient,efficient,132,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,['efficient'],['efficient']
Energy Efficiency,"// If the top bit of the nearest power-of-2 is zero, this value is; // positive. It could be treated as either signed or unsigned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:33,power,power-of-,33,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['power'],['power-of-']
Energy Efficiency,"// If the type of the inline asm call site return value is different but has; // same size as the type of the asm output bitcast it. One example of this; // is for vectors with different width / number of elements. This can; // happen for register classes that can contain multiple different value; // types. The preg or vreg allocated may not have the same VT as was; // expected.; //; // This can also happen for a return value that disagrees with the register; // class it is put in, eg. a double in a general-purpose register on a; // 32-bit machine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:326,allocate,allocated,326,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If the types involved are powers of 2, we can generate intermediate vector; // ops, before generating a final reduction operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:29,power,powers,29,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['power'],['powers']
Energy Efficiency,"// If the used several times in the allocate directive, the same allocator; // must be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:36,allocate,allocate,36,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If the values are PHIs in the same block, we can do a more precise as well; // as efficient check: just check for relations between the values on; // corresponding edges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp:85,efficient,efficient,85,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// If the values are PHIs in the same block, we can do a more precise; // as well as efficient check: just check for aliases between the values; // on corresponding edges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:85,efficient,efficient,85,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// If the vector element width is a whole number of bytes, test if its legal; // to BSWAP shuffle the bytes and then perform the BITREVERSE on the byte; // vector. This greatly reduces the number of bit shifts necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:177,reduce,reduces,177,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// If there are a sufficient number of reduction values, reduce; // to a nearby power-of-2. We can safely generate oversized; // vectors and rely on the backend to split them to legal sizes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:57,reduce,reduce,57,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,"['power', 'reduce']","['power-of-', 'reduce']"
Energy Efficiency,"// If there are any AST files to merge, create a frontend action; // adaptor to perform the merge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:69,adapt,adaptor,69,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,1,['adapt'],['adaptor']
Energy Efficiency,"// If there are fixed sized objects that are preallocated in the local area,; // non-fixed objects can't be allocated right at the start of local area.; // Adjust 'Offset' to point to the end of last fixed sized preallocated; // object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:108,allocate,allocated,108,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If there are fixed sized objects that are preallocated in the local area,; // non-fixed objects can't be allocated right at the start of local area.; // We currently don't support filling in holes in between fixed sized; // objects, so we adjust 'Offset' to point to the end of last fixed sized; // preallocated object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp:108,allocate,allocated,108,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If there are more high registers that need pushing than low registers; // available, push some more low registers so that we can use fewer push; // instructions. This might not reduce RegDeficit all the way to zero,; // because we can only guarantee that r4-r6 are available, but r8-r11 may; // need saving.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:180,reduce,reduce,180,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If there are no NANs to deal with, then these are reduced to a; // single MIN** or MAX** instruction instead of the MIN/CMP/SELECT that we; // assume is used in the non-fast case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:53,reduce,reduced,53,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['reduce'],['reduced']
Energy Efficiency,// If there are non-empty intervals allocate them using pbqp.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:36,allocate,allocate,36,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If there are register pressure issues, then we remove the value added for; // the instruction being available. The rationale is that we really don't; // want to schedule an instruction that causes a spill.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:164,schedul,schedule,164,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['schedul'],['schedule']
Energy Efficiency,// If there aren't enough stubs available then allocate some more.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCIndirectionUtils.cpp:47,allocate,allocate,47,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCIndirectionUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCIndirectionUtils.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If there is a brace-initializer or C++20 parenthesized initializer, cannot; // allocate fewer elements than inits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp:82,allocate,allocate,82,interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If there is a brace-initializer, we cannot allocate fewer elements than; // there are initializers. If we do, that's treated like an overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp:46,allocate,allocate,46,interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If there is a dynamic LDS variable associated with this function F, every; // further dynamic LDS instance (allocated by calling setDynLDSAlign) must; // map to the same address. This holds because no LDS is allocated after the; // lowering pass if there are dynamic LDS variables present.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.cpp:111,allocate,allocated,111,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// If there is a pending allocation from the same reservation right before; // this block, store it's index in PendingMem, to be able to update the; // pending region if part of this block is allocated, rather than having to; // create a new one",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h:192,allocate,allocated,192,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,1,['allocate'],['allocated']
Energy Efficiency,"// If there is no CNT instruction available, GPR popcount can; // be more efficiently lowered to the following sequence that uses; // AdvSIMD registers/instructions as long as the copies to/from; // the AdvSIMD registers are cheap.; // FMOV D0, X0 // copy 64-bit int to vector, high bits zero'd; // CNT V0.8B, V0.8B // 8xbyte pop-counts; // ADDV B0, V0.8B // sum 8xbyte pop-counts; // UMOV X0, V0.B[0] // copy byte result back to integer reg",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:74,efficient,efficiently,74,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// If there is no Count that is modulo of TripCount, set Count to; // largest power-of-two factor that satisfies the threshold limit.; // As we'll create fixup loop, do the type of unrolling only if; // remainder loop is allowed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:78,power,power-of-two,78,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// If there is one more use of regB later in the same MBB, consider; // re-schedule it before this MI if it's legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:75,schedul,schedule,75,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// If there is one more use of regB later in the same MBB, consider; // re-schedule this MI below it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:75,schedul,schedule,75,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// If there's a virtual register allocated and initialized for this; // value, use it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:33,allocate,allocated,33,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If these are identical non-return blocks with no successors, merge them.; // Such blocks are typically cold calls to noreturn functions like abort, and; // are unlikely to become a fallthrough target after machine block placement.; // Tail merging these blocks is unlikely to create additional unconditional; // branches, and will reduce the size of this cold code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:334,reduce,reduce,334,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If they both reduce the caller size, pick the one with the smaller; // cost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:16,reduce,reduce,16,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,1,['reduce'],['reduce']
Energy Efficiency,// If this a GPR ZEXT that we want to just reduce down into a copy.; // The sizes will be mismatched with the source < 32b but that's ok.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:43,reduce,reduce,43,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If this branch is likely to be folded into the comparison to form a; // CB(N)Z, then removing it won't reduce code size at all, because that will; // just replace the CB(N)Z with a CMP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:106,reduce,reduce,106,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,// If this can be scheduled don't bother duplicating and just return,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:18,schedul,scheduled,18,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// If this causes an SCC to split apart into multiple smaller SCCs, there; // is a subtle risk we need to prepare for. Other transformations may; // expose an ""infinite inlining"" opportunity later, and because of the SCC; // mutation, we will revisit this function and potentially re-inline. If we; // do, and that re-inlining also has the potentially to mutate the SCC; // structure, the infinite inlining problem can manifest through infinite; // SCC splits and merges. To avoid this, we capture the originating caller; // node and the SCC containing the call edge. This is a slight over; // approximation of the possible inlining decisions that must be avoided,; // but is relatively efficient to store. We use C != OldC to know when; // a new SCC is generated and the original SCC may be generated via merge; // in later iterations.; //; // It is also possible that even if no new SCC is generated; // (i.e., C == OldC), the original SCC could be split and then merged; // into the same one as itself. and the original SCC will be added into; // UR.CWorklist again, we want to catch such cases too.; //; // FIXME: This seems like a very heavyweight way of retaining the inline; // history, we should look for a more efficient way of tracking it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:687,efficient,efficient,687,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,2,['efficient'],['efficient']
Energy Efficiency,"// If this happens, we want to determine a sensible culprit of this.; // Intuitively, watching the chain of member expressions from right to; // left, we start with the required alignment (as required by the field; // type) but some packed attribute in that chain has reduced the alignment.; // It may happen that another packed structure increases it again. But if; // we are here such increase has not been enough. So pointing the first; // FieldDecl that either is packed or else its RecordDecl is,; // seems reasonable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:268,reduce,reduced,268,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// If this has a fixed position, we still should allocate the register in the; // CCInfo state. Technically we could get away with this for values passed; // outside of the normal argument range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:49,allocate,allocate,49,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// If this instruction accesses memory make sure it doesn't access beyond; // the bounds of the allocated object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:96,allocate,allocated,96,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If this is a case we can't handle, return null and let the default; // expansion code take care of it. If we CAN select this case, and if it; // selects to a single instruction, return Op. Otherwise, if we can codegen; // this case more efficiently than a constant pool load, lower it to the; // sequence of ops that should be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:240,efficient,efficiently,240,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// If this is a constraint for a specific physical register, but the type of; // the operand requires more than one register to be passed, we allocate the; // required amount of physical registers, starting from the selected physical; // register.; // For this, first retrieve a register iterator for the given register class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:142,allocate,allocate,142,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If this is a fixed sized alloca in the entry block of the function,; // allocate it statically on the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:75,allocate,allocate,75,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If this is a linked PE/COFF file, then we have to skip over the null byte; // that is allocated in the .lprfn$A section in the LLVM profiling runtime.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp:89,allocate,allocated,89,interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If this is a linked PE/COFF file, then we have to skip over the null byte; // that is allocated in the .lprfn$A section in the LLVM profiling runtime.; // If the name section is .lprfcovnames, it doesn't have the null byte at the; // beginning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp:89,allocate,allocated,89,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If this is a module entry function, we can also sanity check against; // the static frame. Strictly it would be better to check against the; // attribute, i.e. that the variable is within the always-allocated; // section, and not within some other non-absolute-address object; // allocated here, but the extra error detection is minimal and we would; // have to pass the Function around or cache the attribute value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.cpp:202,allocate,allocated,202,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// If this is a multiply by a power of two, emit this as a shift left.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp:30,power,power,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,1,['power'],['power']
Energy Efficiency,"// If this is a multiply by a power of two, turn it into a shl; // immediately. This is a very common case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:30,power,power,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['power'],['power']
Energy Efficiency,// If this is a no-alloc section then copy the block content into; // memory allocated on the Graph's allocator (if it hasn't been; // already).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h:77,allocate,allocated,77,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h,1,['allocate'],['allocated']
Energy Efficiency,"// If this is a srem by a powers-of-two (including INT_MIN), avoid the fold; // since it can be best implemented as a bit test.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:26,power,powers-of-two,26,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['power'],['powers-of-two']
Energy Efficiency,"// If this is a truncation of a denormal number, and the target semantics; // has larger exponent range than the source semantics (this can happen; // when truncating from PowerPC double-double to double format), the; // right shift could lose result mantissa bits. Adjust exponent instead; // of performing excessive shift.; // Also do a similar trick in case shifting denormal would produce zero; // significand as this case isn't handled correctly by normalize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:172,Power,PowerPC,172,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// If this is a urem by a powers-of-two, avoid the fold since it can be; // best implemented as a bit test.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:26,power,powers-of-two,26,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['power'],['powers-of-two']
Energy Efficiency,"// If this is an 'and R, 1234' where the operation is AND/OR and the RHS is; // a constant without a predicate fn that has more than one bit set, handle; // this as a special case. This is usually for targets that have special; // handling of certain large constants (e.g. alpha with it's 8/16/32-bit; // handling stuff). Using these instructions is often far more efficient; // than materializing the constant. Unfortunately, both the instcombiner; // and the dag combiner can often infer that bits are dead, and thus drop; // them from the mask in the dag. For example, it might turn 'AND X, 255'; // into 'AND X, 254' if it knows the low bit is set. Emit code that checks; // to handle this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp:365,efficient,efficient,365,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// If this is an exact power of two, return the exponent while ignoring the; // sign bit. If it's not an exact power of 2, return INT_MIN",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:23,power,power,23,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,2,['power'],['power']
Energy Efficiency,"// If this is an exact power of two, return the exponent. If it's not an exact; // power of 2, return INT_MIN",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:23,power,power,23,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,2,['power'],['power']
Energy Efficiency,"// If this is an instruction with a load folded into it, try unfolding; // the load, e.g. avoid this:; // movq %rdx, %rcx; // addq (%rax), %rcx; // in favor of this:; // movq (%rax), %rcx; // addq %rdx, %rcx; // because it's preferable to schedule a load than a register copy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:239,schedul,schedule,239,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// If this is an invoke in a 32-bit function using a funclet-based; // personality, assume the function clobbers all registers. If an exception; // is thrown, the runtime will not restore CSRs.; // FIXME: Model this more precisely so that we can register allocate across; // the normal edge and spill and fill across the exceptional edge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:255,allocate,allocate,255,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If this is checking if all elements of a vector compare are set or not,; // invert the casted vector equality compare and test if all compare; // elements are clear or not. Compare against zero is generally easier for; // analysis and codegen.; // icmp eq/ne (bitcast (not X) to iN), -1 --> icmp eq/ne (bitcast X to iN), 0; // Example: are all elements equal? --> are zero elements not equal?; // TODO: Try harder to reduce compare of 2 freely invertible operands?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:420,reduce,reduce,420,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If this is the first FPd op, it should be scheduled high.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:45,schedul,scheduled,45,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// If this is the first line of a token, we need to inform Whitespace Manager; // about it: either adapt the whitespace range preceding it, or mark it as an; // untouchable token.; // This happens for instance here:; // // line 1 \; // // line 2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:99,adapt,adapt,99,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['adapt'],['adapt']
Energy Efficiency,"// If this is the first part of an i64 arg,; // the allocated register must be either A0 or A2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:52,allocate,allocated,52,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If this lookup fails to find the name, or if the allocated type is not; // a class type, the allocation function's name is looked up in the; // global scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:52,allocate,allocated,52,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If this method returns true, handling of the scheduling regions; // themselves (in case of a scheduling boundary in MBB) will be done; // beginning with the topmost region of MBB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:48,schedul,scheduling,48,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['schedul'],['scheduling']
Energy Efficiency,"// If this node would clobber any ""live"" register, then it's not ready.; //; // If SU is the currently live definition of the same register that it uses,; // then we are free to schedule it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:178,schedul,schedule,178,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// If this polynomial has no terms it's a uniform distribution, and a uniform; // pdf is a reducer node because it doesn't depend on the observables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooPolynomial.h:91,reduce,reducer,91,roofit/roofit/inc/RooPolynomial.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooPolynomial.h,1,['reduce'],['reducer']
Energy Efficiency,"// If this resource is already used in this sequence, add the current; // entry's cycles so that the same resource appears to be used; // serially, rather than multiple parallel uses. This is important for; // in-order machine where the resource consumption is a hazard.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp:246,consumption,consumption,246,interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,1,['consumption'],['consumption']
Energy Efficiency,"// If this value has only one use, that use is a kill. This is a; // conservative approximation. InstrEmitter does trivial coalescing; // with CopyFromReg nodes, so don't emit kill flags for them.; // Avoid kill flags on Schedule cloned nodes, since there will be; // multiple uses.; // Tied operands are never killed, so we need to check that. And that; // means we need to determine the index of the operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp:221,Schedul,Schedule,221,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,"// If this vector has been allocated on the heap, re-use it if cheap. If it; // would require more copying, just delete it and we'll steal the other; // side.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h:27,allocate,allocated,27,interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h,1,['allocate'],['allocated']
Energy Efficiency,"// If this was a call to a global replaceable allocation function that does; // not take an alignment argument, the allocator is known to produce; // storage that's suitably aligned for any object that fits, up to a known; // threshold. Otherwise assume it's suitably aligned for the allocated type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp:284,allocate,allocated,284,interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,1,['allocate'],['allocated']
Energy Efficiency,// If this was a specialization we should take into account its template; // arguments. This helps to reduce collisions coming when visiting template; // specialization types (eg. when processing type template arguments).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:102,reduce,reduce,102,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If this wasn't grown from the inline copy, grow the allocated space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SmallVector.cpp:55,allocate,allocated,55,interpreter/llvm-project/llvm/lib/Support/SmallVector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SmallVector.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If this wasn't grown from the inline copy, grow the allocated space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/src/RVec.cxx:55,allocate,allocated,55,math/vecops/src/RVec.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/src/RVec.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// If true, an LLVM IR value might point to this object.; // Normally, spill slots and fixed-offset objects don't alias IR-accessible; // objects, but there are exceptions (on PowerPC, for example, some byval; // arguments have ABI-prescribed offsets).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:176,Power,PowerPC,176,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,1,['Power'],['PowerPC']
Energy Efficiency,"// If two instructions increase the pressure of different register sets; // by the same amount, the generic scheduler will prefer to schedule the; // instruction that increases the set with the least amount of registers,; // which in our case would be SGPRs. This is rarely what we want, so; // when we report excess/critical register pressure, we do it either; // only for VGPRs or only for SGPRs.; // FIXME: Better heuristics to determine whether to prefer SGPRs or VGPRs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:108,schedul,scheduler,108,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,2,['schedul'],"['schedule', 'scheduler']"
Energy Efficiency,"// If upper bound loop trip count (TC) is known at compile time there is no; // point in choosing VF greater than TC (as done in the loop below). Select; // maximum power of two which doesn't exceed TC. If MaxVectorElementCount is; // scalable, we only fall back on a fixed VF when the TC is less than or; // equal to the known number of lanes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:165,power,power,165,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['power'],['power']
Energy Efficiency,"// If we added default parameter, allocate new type in the AST.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:34,allocate,allocate,34,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// If we are moving a pair of loads / stores, see if it makes sense; // to try to allocate a pair of registers that can form register pairs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:82,allocate,allocate,82,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If we are not in ""HazardRecognizerMode"" and therefore not being run from; // the scheduler, track possible stalls from hazards but don't insert noops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:84,schedul,scheduler,84,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// If we are reporting a leak of the object that was allocated with alloc,; // mark its init method as interesting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:53,allocate,allocated,53,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If we are returning a field of the allocated struct or an array element,; // the callee could still free the memory.; // TODO: This logic should be a part of generic symbol escape callback.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:38,allocate,allocated,38,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If we are sign extending a wide vector without SSE4.1, its better to reduce; // the vmul width instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:72,reduce,reduce,72,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If we are storing a vector that we are currently building, let; // `scalarizeVectorStore()` handle this more efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:112,efficient,efficiently,112,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// If we are using the small code model, we can reduce size of jump table; // entry to 4 bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:48,reduce,reduce,48,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If we are zero/sign extending two steps without SSE4.1, its better to; // reduce the vmul width instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:77,reduce,reduce,77,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If we can compute the condition, there's no need for a select.; // Like the above fold, we are attempting to reduce compile-time cost by; // putting this fold here with limitations rather than in InstSimplify.; // The motivation for this call into value tracking is to take advantage of; // the assumption cache, so make sure that is populated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:112,reduce,reduce,112,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If we can emit an efficient shift operation, do so now. Check to see if; // the RHS is a constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:21,efficient,efficient,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['efficient'],['efficient']
Energy Efficiency,// If we can modify the code and it ends in something like:; //; // jCC L1; // jmp L2; // L1:; // ...; // L2:; //; // Then we can change this to:; //; // jnCC L2; // L1:; // ...; // L2:; //; // Which is a bit more efficient.; // We conditionally jump to the fall-through block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRInstrInfo.cpp:214,efficient,efficient,214,interpreter/llvm-project/llvm/lib/Target/AVR/AVRInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRInstrInfo.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// If we can shrink the constant mask below 8-bits or 32-bits, then this; // transform should reduce code size. It may also enable secondary transforms; // from improved known-bits analysis or instruction selection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:94,reduce,reduce,94,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If we can't construct the EVL mask efficiently, it's better to unroll.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:38,efficient,efficiently,38,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// If we couldn't allocate a register from spilling, there is probably some; // invalid inline assembly. The base class will report it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:18,allocate,allocate,18,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If we crash while trying to print the stack trace, we still want the system; // crash handling to have some partial information. That'll work out as long; // as the SmallString doesn't allocate. If it does allocate then the system; // crash handling will see some garbage because the inline buffer now contains; // a pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/PrettyStackTrace.cpp:188,allocate,allocate,188,interpreter/llvm-project/llvm/lib/Support/PrettyStackTrace.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/PrettyStackTrace.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// If we crossed over an fpm page, we actually need to allocate 2 extra; // blocks for each FPM group crossed and mark both blocks from the group as; // used. FPM blocks are marked as allocated regardless of whether or not; // they ultimately describe the status of blocks in the file. This means; // that not only are extraneous blocks at the end of the main FPM marked as; // allocated, but also blocks from the alternate FPM are always marked as; // allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MSFBuilder.cpp:55,allocate,allocate,55,interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MSFBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MSFBuilder.cpp,4,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// If we did not return early, then the scheduler is ready for execution.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/ExecuteStage.cpp:40,schedul,scheduler,40,interpreter/llvm-project/llvm/lib/MCA/Stages/ExecuteStage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/ExecuteStage.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// If we don't demand all elements, then attempt to combine to a simpler; // shuffle.; // We need to convert the depth to something combineX86ShufflesRecursively; // can handle - so pretend its Depth == 0 again, and reduce the max depth; // to match. This prevents combineX86ShuffleChain from returning a; // combined shuffle that's the same as the original root, causing an; // infinite loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:216,reduce,reduce,216,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If we don't have VSX on the subtarget, don't do anything.; // Also, on Power 9 the load and store ops preserve element order and so; // the swaps are not required.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:74,Power,Power,74,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,1,['Power'],['Power']
Energy Efficiency,"// If we don't have a run yet, or don't live within the previous run's; // allocated storage then we allocate some storage and start a new run.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp:75,allocate,allocated,75,interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// If we don't have enough room because this specific allocation is huge,; // just allocate a new rope piece for it alone.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:83,allocate,allocate,83,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If we failed to allocate memory for this global, return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:19,allocate,allocate,19,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If we find a cycle containing all nodes originally in this RefSCC then; // the removal hasn't changed the structure at all. This is an important; // special case, and we can directly exit the entire routine more; // efficiently as soon as we discover it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:219,efficient,efficiently,219,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// If we found a node to schedule, do it now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp:25,schedul,schedule,25,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,1,['schedul'],['schedule']
Energy Efficiency,// If we found a node to schedule...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:25,schedul,schedule,25,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// If we found a tombstone, we want to reuse the tombstone instead of an; // empty bucket. This reduces probing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringMap.cpp:96,reduce,reduces,96,interpreter/llvm-project/llvm/lib/Support/StringMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringMap.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// If we found bad indices but no other errors, try doing another pass and see; // if we can resolve the indices that weren't in the map on the first pass.; // This may require multiple passes, but we should always make progress. MASM; // is the only known CodeView producer that makes type streams that aren't; // topologically sorted. The standard library contains MASM-produced objects,; // so this is important to handle correctly, but we don't have to be too; // efficient. MASM type streams are usually very small.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp:468,efficient,efficient,468,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// If we generate code for the target device, we need to allocate; // struct for aggregate params in the device default alloca address space.; // OpenMP runtime requires that the params of the extracted functions are; // passed as zero address space pointers. This flag ensures that extracted; // function arguments are declared in zero address space",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:57,allocate,allocate,57,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If we generate code for the target device, we need to allocate; // struct for aggregate params in the device default alloca address space.; // OpenMP runtime requires that the params of the extracted functions are; // passed as zero address space pointers. This flag ensures that; // CodeExtractor generates correct code for extracted functions; // which are used by OpenMP runtime.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:57,allocate,allocate,57,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If we happen to be doing an i64 load or store into a stack slot that has; // less than a 4-byte alignment, then the frame-index elimination may need to; // use an indexed load or store instruction (because the offset may not be a; // multiple of 4). The extra register needed to hold the offset comes from the; // register scavenger, and it is possible that the scavenger will need to use; // an emergency spill slot. As a result, we need to make sure that a spill slot; // is allocated when doing an i64 load/store into a less-than-4-byte-aligned; // stack slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:480,allocate,allocated,480,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// If we have 4 or fewer lanes we can cheaply shuffle the element into; // the desired position. Otherwise it is more efficient to do a vector; // shift left. We know that we can do a vector shift left because all; // the inputs are zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:118,efficient,efficient,118,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// If we have AVX2 with it's powerful shift operations, then it's also good.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:29,power,powerful,29,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['powerful']
Energy Efficiency,"// If we have a combined directive that combines 'distribute', 'for' or; // 'simd' we need to be able to access the bounds of the schedule of the; // enclosing region. E.g. in 'distribute parallel for' the bounds obtained; // by scheduling 'distribute' have to be passed to the schedule of 'for'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:130,schedul,schedule,130,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,3,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"// If we have a constant shift amount, the non-SSE41 path is best as; // avoiding bitcasts make it easier to constant fold and reduce to PBLENDW.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:127,reduce,reduce,127,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If we have a forward declaration for a class template instantiation,; // we want to ignore it if it was produced/induced by the call to; // findScope, however we can not distinguish those from the; // instantiation induce by 'soft' use (and thus also induce by the; // same underlying code paths); // ['soft' use = use not requiring a complete definition]; // So to reduce the amount of disruption to the existing code we; // would just ignore those for STL collection, for which we really; // need to have the compiled collection proxy (and thus the TClass; // bootstrap).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:369,reduce,reduce,369,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// If we have a full vector allocated, try to re-use it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h:28,allocate,allocated,28,interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h,1,['allocate'],['allocated']
Energy Efficiency,"// If we have a move immediate and all successors have been assigned, bias; // towards scheduling this later. Make sure all register defs are to; // physical registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:87,schedul,scheduling,87,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// If we have a non-preferred node, push it back onto the available list.; // If we did not find a preferred node, then schedule this first; // non-preferred node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:120,schedul,schedule,120,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// If we have a non-splat but still powers-of-2 mask, AVX1 can use pmulld; // and AVX2 can use vpsllv{dq}. 8-bit lacks a proper shift or multiply.; // 16-bit lacks a proper blendv.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,power,powers-of-,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['powers-of-']
Energy Efficiency,"// If we have a per operand scheduling model, check if this def is writing; // an unbuffered resource. If so, it treated like an in-order cpu.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:28,schedul,scheduling,28,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// If we have a truncating store or an extending load with a data size larger; // than 32-bits, we need to reduce to a 32-bit type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:107,reduce,reduce,107,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If we have already scheduled the physreg produce/consumer, immediately; // schedule the copy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:22,schedul,scheduled,22,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"// If we have an inalloc alloca instruction, it needs to be scheduled; // after any preceeding stacksave. We also need to prevent any alloca; // from reordering above a preceeding stackrestore.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,schedul,scheduled,60,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// If we have an inalloca argument, all stack space has already been allocated; // for us and be right at the top of the stack. We don't support multiple; // arguments passed in memory when using inalloca.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:69,allocate,allocated,69,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// If we have any vulnerable SVE stack objects then the stack protector; // needs to be placed at the top of the SVE stack area, as the SVE locals; // are placed above the other locals, so we allocate it as if it were a; // scalable vector.; // FIXME: It may be worthwhile having a specific interface for this rather; // than doing it here in finalizeLowering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:192,allocate,allocate,192,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If we have less than 16 loads in a row, and the offsets are within 64; // bytes, then schedule together.; // A cacheline is 64 bytes (for global memory).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:89,schedul,schedule,89,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// If we have stack realignment and VLAs, we have no pointer to use to; // access the stack. If we have stack realignment, and a large call frame,; // we have no place to allocate the emergency spill slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp:171,allocate,allocate,171,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If we have to grow to have enough elements, destroy the current elements.; // This allows us to avoid copying them during the grow.; // FIXME: don't do this if they're efficiently moveable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:171,efficient,efficiently,171,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['efficient'],['efficiently']
Energy Efficiency,"// If we have to grow to have enough elements, destroy the current elements.; // This allows us to avoid copying them during the grow.; // FIXME: this may not actually make any sense if we can efficiently move; // elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:193,efficient,efficiently,193,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['efficient'],['efficiently']
Energy Efficiency,"// If we have to grow to have enough elements, destroy the current elements.; // This allows us to avoid copying them during the grow.; // From the original LLVM implementation:; // FIXME: don't do this if they're efficiently moveable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:214,efficient,efficiently,214,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['efficient'],['efficiently']
Energy Efficiency,"// If we have to grow to have enough elements, destroy the current elements.; // This allows us to avoid copying them during the grow.; // From the original LLVM implementation:; // FIXME: this may not actually make any sense if we can efficiently move; // elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:236,efficient,efficiently,236,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['efficient'],['efficiently']
Energy Efficiency,"// If we haven't found an efficient lowering, try splitting a 128-bit vector; // into two 64-bit vectors; we might discover a better way to lower it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:26,efficient,efficient,26,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// If we haven't scheduled anything yet, then we aren't latency limited.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:17,schedul,scheduled,17,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// If we haven't seen any uses in this scheduling region, create a; // dependence edge to ExitSU to model the live-out latency. This is required; // for vreg defs with no in-region use, and prefetches with no vreg def.; //; // FIXME: NumDataSuccs would be more precise than NumSuccs here. This; // check currently relies on being called before adding chain deps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:39,schedul,scheduling,39,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// If we know that only one bit of the LHS of the icmp can be set and we; // have an equality comparison with zero or a power of 2, we can transform; // the icmp and sext into bitwise/integer operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:120,power,power,120,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['power'],['power']
Energy Efficiency,"// If we know that the sign argument is negative, reduce to FNABS:; // copysign Mag, -Sign --> fneg (fabs Mag)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:50,reduce,reduce,50,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If we know that the sign argument is positive, reduce to FABS:; // copysign Mag, +Sign --> fabs Mag",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:50,reduce,reduce,50,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If we know the exact VLEN, see if we can use the constant encoding; // for the VLMAX instead. This reduces register pressure slightly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:102,reduce,reduces,102,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// If we know the power is <= 0, can't introduce inf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:18,power,power,18,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['power'],['power']
Energy Efficiency,"// If we know the power is >= 0, can't introduce subnormal or zero",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:18,power,power,18,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['power'],['power']
Energy Efficiency,"// If we know the sign bits of both operands are zero, strength reduce to a; // udiv instead. Handles (X&15) /s 4 -> X&15 >> 2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:64,reduce,reduce,64,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If we know the sign bits of both operands are zero, strength reduce to a; // urem instead. Handles (X & 0x0FFFFFFF) %s 16 -> X&15",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:64,reduce,reduce,64,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If we match against a materialization-side-effects only symbol; // then make sure it is weakly-referenced. Otherwise bail out with; // an error.; // FIXME: Use a ""materialization-side-effects-only symbols must be; // weakly referenced"" specific error here to reduce confusion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:262,reduce,reduce,262,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,2,['reduce'],['reduce']
Energy Efficiency,"// If we need a base pointer, set it up here. It's whatever the value of the; // stack pointer is at this point. Any variable size objects will be allocated; // after this, so we can still use the base pointer to reference locals.; //; // FIXME: Clarify FrameSetup flags here.; // Note: Use emitFrameOffset() like above for FP if the FrameSetup flag is; // needed.; // For funclets the BP belongs to the containing function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:147,allocate,allocated,147,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If we need a base pointer, set it up here. It's whatever the value of; // the stack pointer is at this point. Any variable size objects will be; // allocated after this, so we can still use the base pointer to reference; // the incoming arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:151,allocate,allocated,151,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If we need a base pointer, set it up here. It's whatever the value; // of the stack pointer is at this point. Any variable size objects; // will be allocated after this, so we can still use the base pointer; // to reference locals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:151,allocate,allocated,151,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,3,['allocate'],['allocated']
Energy Efficiency,"// If we need a base pointer, set it up here. It's whatever the value; // of the stack pointer is at this point. Any variable size objects; // will be allocated after this, so we can still use the base pointer; // to reference locals.; // FIXME: Clarify FrameSetup flags here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:151,allocate,allocated,151,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If we need a stack protector, we need to make sure that; // LocalStackSlotPass didn't already allocate a slot for it.; // If we are told to use the LocalStackAllocationBlock, the stack protector; // is expected to be already pre-allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:97,allocate,allocate,97,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// If we need to allocate a font, first construct the font name then; // allocate it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx:17,allocate,allocate,17,gui/guihtml/src/TGHtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx,2,['allocate'],['allocate']
Energy Efficiency,// If we need to extend the stack it is more efficient to use entsp / retsp.; // We force the LR to be saved so these instructions are used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/XCore/XCoreFrameLowering.cpp:45,efficient,efficient,45,interpreter/llvm-project/llvm/lib/Target/XCore/XCoreFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/XCore/XCoreFrameLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// If we never found a common pointer, allocate one now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:39,allocate,allocate,39,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,1,['allocate'],['allocate']
Energy Efficiency,// If we reduced the testcase replace it,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp:9,reduce,reduced,9,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// If we still couldn't find a reasonable default alignment, fall back; // to a simple heuristic that the alignment is the first power of two; // greater-or-equal to the store size of the type. This is a reasonable; // approximation of reality, and if the user wanted something less; // less conservative, they should have specified it explicitly in the data; // layout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:129,power,power,129,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,1,['power'],['power']
Energy Efficiency,"// If we updated the node in place, reset the node ID. To the isel,; // this should be just like a newly allocated machine node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:105,allocate,allocated,105,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// If we want to be smarter, look at all uses of each global, to try to; // discover all sets of globals used together, and how many times each of; // these sets occurred.; //; // Keep this reasonably efficient, by having an append-only list of all sets; // discovered so far (UsedGlobalSet), and mapping each ""together-ness"" unit of; // code (currently, a Function) to the set of globals seen so far that are; // used together in that unit (GlobalUsesByFunction).; //; // When we look at the Nth global, we know that any new set is either:; // - the singleton set {N}, containing this global only, or; // - the union of {N} and a previously-discovered set, containing some; // combination of the previous N-1 globals.; // Using that knowledge, when looking at the Nth global, we can keep:; // - a reference to the singleton set {N} (CurGVOnlySetIdx); // - a list mapping each previous set to its union with {N} (EncounteredUGS),; // if it actually occurs.; // We keep track of the sets of globals used together ""close enough"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:201,efficient,efficient,201,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// If we were working with infinite precision arithmetic then the combined; // weight would be LHS + RHS. But we are using finite precision arithmetic,; // and the APInt sum LHS + RHS may not be correct if it wraps (it is correct; // for nilpotent operations and addition, but not for idempotent operations; // and multiplication), so it is important to correctly reduce the combined; // weight back into range if wrapping would be wrong.; // If RHS is zero then the weight didn't change.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:364,reduce,reduce,364,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If we will reduce the # stores (according to this heuristic), do the; // transformation. This encourages merging 4 x i8 -> i32 and 2 x i16 -> i32; // etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:14,reduce,reduce,14,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// If we won't spill this, we don't need to check for previously allocated; // stack slots.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:65,allocate,allocated,65,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If we're an intermediate component of the split, we can just attempt to; // allocate a register directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:79,allocate,allocate,79,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If we're checking the return value, allocate space for a pointer to a; // precise source location of the checked return statement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:39,allocate,allocate,39,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If we're discarding a construct expression, we still need; // to allocate a variable and call the constructor and destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:68,allocate,allocate,68,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If we're growing, we have to allocate new Blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MSFBuilder.cpp:32,allocate,allocate,32,interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MSFBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MSFBuilder.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// If we're in the middle of scheduling a call, don't begin scheduling; // another call. Also, don't allow any physical registers to be live across; // the call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:29,schedul,scheduling,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,['schedul'],['scheduling']
Energy Efficiency,"// If we're not inside a conditional branch, then the cleanup will; // dominate and we can do the easier (and more efficient) thing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp:115,efficient,efficient,115,interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// If we're scheduling a lowered CALLSEQ_END, find the corresponding; // CALLSEQ_BEGIN. Inject an artificial physical register dependence between; // these nodes, to prevent other calls from being interscheduled with them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:12,schedul,scheduling,12,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// If we're tracking CR bits, we need to be careful that we don't have:; // zext(binary-ops(trunc(x), trunc(y))); // or; // zext(binary-ops(binary-ops(trunc(x), trunc(y)), ...); // such that we're unnecessarily moving things into CR bits that can more; // efficiently stay in GPRs. Note that if we're not certain that the high; // bits are set as required by the final extension, we still may need to do; // some masking to get the proper behavior.; // This same functionality is important on PPC64 when dealing with; // 32-to-64-bit extensions; these occur often when 32-bit values are used as; // the return values of functions. Because it is so similar, it is handled; // here as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:256,efficient,efficiently,256,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// If we're using a special group-terminating nop, then we need only one.; // FIXME: the same for P9 as previous gen until POWER9 scheduling is ready",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:130,schedul,scheduling,130,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// If we've allocated a new parameter variable for the first time, store; // its type and value to be retrieved after codegen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:12,allocate,allocated,12,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// If we've already allocated a uselist, stop here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp:20,allocate,allocated,20,interpreter/llvm-project/llvm/lib/IR/Function.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Ignore any symbols coming from sections that don't have runtime; // allocated memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/SymbolizableObjectFile.cpp:71,allocate,allocated,71,interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/SymbolizableObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/SymbolizableObjectFile.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Ignore non-variant scheduling classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp:22,schedul,scheduling,22,interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Ignore parents that don't guarantee consumption.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ParentMap.cpp:39,consumption,consumption,39,interpreter/llvm-project/clang/lib/AST/ParentMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ParentMap.cpp,1,['consumption'],['consumption']
Energy Efficiency,// Ignore saturated arcs (cycleCount has been reduced to 0) and visited; // blocks. Ignore self arcs to guard against bad input (.gcno has no; // self arcs).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/GCOV.cpp:46,reduce,reduced,46,interpreter/llvm-project/llvm/lib/ProfileData/GCOV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/GCOV.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Ignore this variant scheduling class no transitions use any meaningful; // MCSchedPredicate definitions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp:23,schedul,scheduling,23,interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Ignore unrelated casts in STL allocate() since the allocator must cast; // from void* to T* before object initialization completes. Don't match on the; // namespace because not all allocators are in std::,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:33,allocate,allocate,33,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Ignore up to the ""unscaled candidates"" number of unswitch candidates; // when calculating the power-of-two scaling of the cost. The main idea; // with this control is to allow a small number of unswitches to happen; // and rely more on siblings multiplier (see below) when the number; // of candidates is small.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:97,power,power-of-two,97,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['power'],['power-of-two']
Energy Efficiency,// Implement a IGLP scheduling strategy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:20,schedul,scheduling,20,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Implementation file for class; // AdaptiveIntegratorMultiDim; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx:37,Adapt,AdaptiveIntegratorMultiDim,37,math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,1,['Adapt'],['AdaptiveIntegratorMultiDim']
Energy Efficiency,"// Implementation note:; //; // A positive value of autoflush determines the size (in number of entries) of; // a cluster of baskets.; //; // If the value of autoflush is changed over time (this happens in; // particular when the TTree results from fast merging many trees),; // we record the values of fAutoFlush in the data members:; // fClusterRangeEnd and fClusterSize.; // In the code we refer to a range of entries where the size of the; // cluster of baskets is the same (i.e the value of AutoFlush was; // constant) is called a ClusterRange.; //; // The 2 arrays (fClusterRangeEnd and fClusterSize) have fNClusterRange; // active (used) values and have fMaxClusterRange allocated entries.; //; // fClusterRangeEnd contains the last entries number of a cluster range.; // In particular this means that the 'next' cluster starts at fClusterRangeEnd[]+1; // fClusterSize contains the size in number of entries of all the cluster; // within the given range.; // The last range (and the only one if fNClusterRange is zero) start at; // fNClusterRange[fNClusterRange-1]+1 and ends at the end of the TTree. The; // size of the cluster in this range is given by the value of fAutoFlush.; //; // For example printing the beginning and end of each the ranges can be done by:; //; // Printf(""%-16s %-16s %-16s %5s"",; // ""Cluster Range #"", ""Entry Start"", ""Last Entry"", ""Size"");; // Int_t index= 0;; // Long64_t clusterRangeStart = 0;; // if (fNClusterRange) {; // for( ; index < fNClusterRange; ++index) {; // Printf(""%-16d %-16lld %-16lld %5lld"",; // index, clusterRangeStart, fClusterRangeEnd[index], fClusterSize[index]);; // clusterRangeStart = fClusterRangeEnd[index] + 1;; // }; // }; // Printf(""%-16d %-16lld %-16lld %5lld"",; // index, prevEntry, fEntries - 1, fAutoFlush);; //; // Note: We store the entry number corresponding to the end of the cluster; // rather than its start in order to avoid using the array if the cluster; // size never varies (If there is only one value of AutoFlush for th",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:678,allocate,allocated,678,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// Implementation notes:; // 1) LOCK prefix creates a full read/write reordering barrier for memory; // operations issued by the current processor. As such, the location; // referenced is not relevant for the ordering properties of the instruction.; // See: Intel® 64 and IA-32 ArchitecturesSoftware Developer’s Manual,; // 8.2.3.9 Loads and Stores Are Not Reordered with Locked Instructions; // 2) Using an immediate operand appears to be the best encoding choice; // here since it doesn't require an extra register.; // 3) OR appears to be very slightly faster than ADD. (Though, the difference; // is small enough it might just be measurement noise.); // 4) When choosing offsets, there are several contributing factors:; // a) If there's no redzone, we default to TOS. (We could allocate a cache; // line aligned stack object to improve this case.); // b) To minimize our chances of introducing a false dependence, we prefer; // to offset the stack usage from TOS slightly.; // c) To minimize concerns about cross thread stack usage - in particular,; // the idiomatic MyThreadPool.run([&StackVars]() {...}) pattern which; // captures state in the TOS frame and accesses it from many threads -; // we want to use an offset such that the offset is in a distinct cache; // line from the TOS frame.; //; // For a general discussion of the tradeoffs and benchmark results, see:; // https://shipilev.net/blog/2014/on-the-fence-with-dependencies/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:783,allocate,allocate,783,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Implements the hardware dispatch logic.; //; // This class is responsible for the dispatch stage, in which instructions are; // dispatched in groups to the Scheduler. An instruction can be dispatched if; // the following conditions are met:; // 1) There are enough entries in the reorder buffer (see class; // RetireControlUnit) to write the opcodes associated with the instruction.; // 2) There are enough physical registers to rename output register operands.; // 3) There are enough entries available in the used buffered resource(s).; //; // The number of micro opcodes that can be dispatched in one cycle is limited by; // the value of field 'DispatchWidth'. A ""dynamic dispatch stall"" occurs when; // processor resources are not available. Dispatch stall events are counted; // during the entire execution of the code, and displayed by the performance; // report when flag '-dispatch-stats' is specified.; //; // If the number of micro opcodes exceedes DispatchWidth, then the instruction; // is dispatched in multiple cycles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/DispatchStage.h:159,Schedul,Scheduler,159,interpreter/llvm-project/llvm/include/llvm/MCA/Stages/DispatchStage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/DispatchStage.h,1,['Schedul'],['Scheduler']
Energy Efficiency,"// Import first, then allocate memory and copy if there was no error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:22,allocate,allocate,22,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// In 64BIT mode BUILD_VECTOR nodes that are not constant splats of up to; // 32-bits can be lowered to VSX instructions under certain conditions.; // Without VSX, there is no pattern more efficient than expanding the node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:189,efficient,efficient,189,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// In ARC, infer 'retaining' for the allocated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:37,allocate,allocated,37,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// In Armv6-M, this sequence will generate a branch without corrupting; // any registers. We use two stack words; in the second, we construct the; // address we'll pop into pc, and the first is used to save and restore; // r0 which we use as a temporary register.; //; // To support position-independent use cases, the offset of the target; // function is stored as a relative offset (which will expand into an; // R_ARM_REL32 relocation in ELF, and presumably the equivalent in other; // object file types), and added to pc after we load it. (The alternative; // B.W is automatically pc-relative.); //; // There are five 16-bit Thumb instructions here, so the .balign 4 adds a; // sixth halfword of padding, and then the offset consumes a further 4; // bytes, for a total of 16, which is very convenient since entries in; // this jump table need to have power-of-two size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:855,power,power-of-two,855,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// In C++, objects can sometimes be allocated into the tail padding; // of a base-class subobject. We decide whether that's possible; // during class layout, so here we can just trust the layout results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:36,allocate,allocated,36,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// In C, the macro 'true' from stdbool.h will evaluate to '1'; To reduce; // false positives where the user is demonstrating they intend to use the; // bit-field as a Boolean, check to see if the value is 1 and we're assigning; // to a one-bit bit-field to see if the value came from a macro named 'true'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:66,reduce,reduce,66,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// In GHC calling convention C stack space, including the ABI-defined; // 160-byte base area, is (de)allocated by GHC itself. This stack space may; // be used by LLVM as spill slots for the tail recursive GHC functions. Thus; // do not allocate stack space here, too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:101,allocate,allocated,101,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// In MI, we only need low 32 bits of SrcMI, just consider about low 32; // bit of SrcMI mask. Note that in APInt, lowerest bit is at index 0,; // while in PowerPC ISA, lowerest bit is at index 63.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:156,Power,PowerPC,156,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:48,reduce,reduced,48,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// In OptimizeIndividualCalls, we have strength reduced all optimizable; // objc_retainBlocks to objc_retains. Thus at this point any; // objc_retainBlocks that we see are not optimizable. We need to break since; // a retain can be a potential use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:48,reduce,reduced,48,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// In Thumb1 the scheduler may need to schedule a cross-copy between GPRS and CPSR; // but this is not always possible there, so allow the Scheduler to clone tADCS and tSBCS; // even if they have glue.; // FIXME. Actually implement the cross-copy where it is possible (post v6); // because these copies entail more spilling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1InstrInfo.cpp:17,schedul,scheduler,17,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1InstrInfo.cpp,3,"['Schedul', 'schedul']","['Scheduler', 'schedule', 'scheduler']"
Energy Efficiency,"// In Vectorcall Calling convention, additional shadow stack can be; // created on top of the basic 32 bytes of win64.; // It can happen if the fifth or sixth argument is vector type or HVA.; // At that case for each argument a shadow stack of 8 bytes is allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:255,allocate,allocated,255,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// In a first step, we coalesce the read requests and calculate the cluster buffer size.; // In a second step, we'll fix-up the memory destinations for the read calls given the; // address of the allocated buffer. We must not touch, however, the read requests from previous; // calls to PrepareSingleCluster()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:196,allocate,allocated,196,tree/ntuple/v7/src/RPageStorageFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// In addition to 4 E[ABCD] registers implied by encoding, CMPXCHG8B; // requires a memory operand. If it happens that current architecture is; // i686 and for current function we need a base pointer; // - which is ESI for i686 - register allocator would not be able to; // allocate registers for an address in form of X(%reg, %reg, Y); // - there never would be enough unreserved registers during regalloc; // (without the need for base ptr the only option would be X(%edi, %esi, Y).; // We are giving a hand to register allocator by precomputing the address in; // a new vreg using LEA.; // If it is not i686 or there is no base pointer - nothing to do here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:274,allocate,allocate,274,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// In an x86 interrupt, remove the offset we added to account for the return; // address from any stack object allocated in the caller's frame. Interrupts; // do not have a standard return address. Fixed objects in the current frame,; // such as SSE register spills, should not get this treatment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:111,allocate,allocated,111,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// In any cycle where we can't schedule any instructions, we must; // stall or emit a noop, depending on the target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:31,schedul,schedule,31,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// In big-endian mode we must adjust the pointer when the load size is smaller; // than the argument slot size. We must also reduce the known alignment to; // match. For example in the N64 ABI, we must add 4 bytes to the offset to get; // the correct half of the slot, and reduce the alignment from 8 (slot; // alignment) down to 4 (type alignment).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:125,reduce,reduce,125,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,2,['reduce'],['reduce']
Energy Efficiency,"// In case of renaming an enum declaration, we have to explicitly handle; // unscoped enum constants referenced in expressions (e.g.; // ""auto r = ns1::ns2::Green"" where Green is an enum constant of an unscoped; // enum decl ""ns1::ns2::Color"") as these enum constants cannot be caught by; // TypeLoc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:157,Green,Green,157,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,2,['Green'],['Green']
Energy Efficiency,"// In case the execution needs TLS storage, we define a very small TLS memory; // area here that will be used in allocateTLSSection().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp:113,allocate,allocateTLSSection,113,interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp,1,['allocate'],['allocateTLSSection']
Energy Efficiency,"// In general, AST matchers cannot match calls to macros. However, we can; // simulate such matches if the macro definition has identifiable elements that; // themselves can be matched. In that case, we can match on those elements and; // then check that the match occurs within an expansion of the desired; // macro. The more uncommon the identified elements, the more efficient this; // process will be.; //; // We use this approach to implement the derived matchers gtestAssert and; // gtestExpect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp:370,efficient,efficient,370,interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// In general, when both constants are non-zero, we would need an offset to; // replace the select. This would require more instructions than we started; // with. But there's one special-case that we handle here because it can; // simplify/reduce the instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:240,reduce,reduce,240,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// In most cases TID / wavefrontsize is uniform.; //; // However, if a kernel has uneven dimesions we can have a value of; // workitem-id-x divided by the wavefrontsize non-uniform. For example; // dimensions (65, 2) will have workitems with address (64, 0) and (0, 1); // packed into a same wave which gives 1 and 0 after the division by 64; // respectively.; //; // FIXME: limit it to 1D kernels only, although that shall be possible; // to perform this optimization is the size of the X dimension is a power; // of 2, we just do not currently have infrastructure to query it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:505,power,power,505,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,1,['power'],['power']
Energy Efficiency,"// In order to coalesce close-by pages, we collect the sizes of the gaps between pages on disk. We then order; // the gaps by size, sum them up and find a cutoff for the largest gap that we tolerate when coalescing pages.; // The size of the cutoff is given by the fraction of extra bytes we are willing to read in order to reduce; // the number of read requests. We thus schedule the lowest number of requests given a tolerable fraction; // of extra bytes.; // TODO(jblomer): Eventually we may want to select the parameter at runtime according to link latency and speed,; // memory consumption, device block size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:324,reduce,reduce,324,tree/ntuple/v7/src/RPageStorageFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx,3,"['consumption', 'reduce', 'schedul']","['consumption', 'reduce', 'schedule']"
Energy Efficiency,"// In order to have valid types, all of the inputs must be extended from the; // same source type and all of the inputs must be any or zero extend.; // Scalar sizes must be a power of two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:175,power,power,175,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['power'],['power']
Energy Efficiency,"// In order to reduce live set of statepoint we might choose to rematerialize; // some values instead of relocating them. This is purely an optimization and; // does not influence correctness.; // First try rematerialization at uses, then after statepoints.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:15,reduce,reduce,15,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// In order to reduce the noise in the diagnostics generated by this checker,; // some framework and programming style based heuristics are used. These; // heuristics are for Cocoa APIs which have NS prefix.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:15,reduce,reduce,15,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// In our cost analysis above, we assume that each addrec consumes exactly; // one register, and arrange to have increments inserted just before the; // latch to maximimize the chance this is true. However, if we reused; // existing IVs, we now need to move the increments to match our; // expectations. Otherwise, our cost modeling results in us having a; // chosen a non-optimal result for the actual schedule. (And yes, this; // scheduling decision does impact later codegen.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:403,schedul,schedule,403,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"// In practice, applying X2_Y_X1 merging almost never provides benefits;; // thus, we exclude it from consideration to reduce the search space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:119,reduce,reduce,119,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// In some cases, we scan the use-list of an instruction for an AND;; // that AND is in the same BB, but may not be scheduled before the; // corresponding TST. In that case, bail out.; //; // FIXME: We could try to reschedule the AND.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:116,schedul,scheduled,116,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// In the ELFv2 ABI, we are not required to save all CR fields.; // If only one CR field is clobbered, it is more efficient to use; // mfocrf to selectively save just that field, because mfocrf has short; // latency compares to mfcr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:114,efficient,efficient,114,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:315,schedul,scheduling,315,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,3,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,"// In the epilog, a map lookup is needed to get the value from the kernel,; // or previous epilog block. How is does this depends on if the; // instruction is scheduled in the previous block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:159,schedul,scheduled,159,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// In the epilog, we may need to look back one stage to get the correct; // Phi name, because the epilog and prolog blocks execute the same stage.; // The correct name is from the previous block only when the Phi has; // been completely scheduled prior to the epilog, and Phi value is not; // needed in multiple stages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:237,schedul,scheduled,237,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// In the failing case, where we don't execute the store-conditional, the; // target might want to balance out the load-linked with a dedicated; // instruction (e.g., on ARM, clearing the exclusive monitor).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:198,monitor,monitor,198,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,1,['monitor'],['monitor']
Energy Efficiency,"// In the old ELFv1 ABI,; // the prolog code of the callee may store up to 8 GPR argument registers to; // the stack, allowing va_start to index over them in memory if its varargs.; // Because we cannot tell if this is needed on the caller side, we have to; // conservatively assume that it is needed. As such, make sure we have at; // least enough stack space for the caller to store the 8 GPRs.; // In the ELFv2 ABI, we allocate the parameter area iff a callee; // really requires memory operands, e.g. a vararg function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:422,allocate,allocate,422,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// In the past, when Minuit2 was not the default minimizer yet, there was; // also a check that the number of invalid NLL evaluations was reduced with; // the error recovery:; //; // EXPECT_LT(fitResultNew->numInvalidNLL(), fitResultOld->numInvalidNLL());; //; // However, Minuit2 takes less evaluations to realize that the minimization; // without error recovery is hopeless, resulting in less invalid NLL; // evaluations when the error recovery is off. Hence, the comparison is not; // meaningful and was commended out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:138,reduce,reduced,138,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,1,['reduce'],['reduced']
