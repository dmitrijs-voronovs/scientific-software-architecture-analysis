quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance," efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Process we read only 2 branches; auto b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; auto b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... Here the entry is processed; ~~~; ### Custom event loop. #### Always using the same two branches. In this example, exactly two branches are always used: those need to be; prefetched.; ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1, true); //<<< add branch1 and branch2 to the cache; T->AddBranchToCache(b2, true); //<<<; T->StopCacheLearningPhase(); //<<< we do not need the system to guess anything; for (auto i : TSeqL(nentries)) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; ... Here the entry is processed; }; ~~~; #### Always using at least the same two branches. In this example, two branches are always used: in addition, some analysis; functions are invoked and those may trigger the reading of other branches which; are a priori not known.; There is no point in prefetching branches that will be used very rarely: we can; rely on the system to cache the right branches.; ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesiz",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:8897,cache,cachesize,8897,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,4,"['Load', 'cache']","['LoadTree', 'cache', 'cachesize']"
Performance," extentions. It will; * then try to interpret that extention as a face number, and try and; * find the file with extention stripped off.; * If file was found function will atempt to read it using FreeType; * library. If requested face is not available in the font - face 0 will; * be used.; * On success all the font's glyphs will be rendered and cached, and; * needed font geometry info collected.; * When FreeType Library is not available that function does nothing.; *********/; /****f* libAfterImage/asfont/open_X11_font(); * NAME; * open_X11_font(); * SYNOPSIS; * ASFont *open_X11_font( ASFontManager *fontman,; * const char *font_string);; * INPUTS; * fontman - pointer to previously created ASFontManager. Needed for; * connection X Server.; * font_string - name of the font as recognized by Xlib.; * RETURN VALUE; * pointer to Opened ASFont structure, containing all the glyphs of the; * font, as well as other relevant info. On failure returns NULL.; * DESCRIPTION; * open_X11_font() attempts to load and query font using Xlib calls.; * On success it goes thgroughthe codemap of the font and renders all; * the glyphs available. Glyphs then gets transfered to the client's; * memory and encoded using RLE compression. At this time smoothing; * filters are applied on glyph pixmaps, if its size exceeds threshold.; * TODO; * implement proper XFontSet support, when used with I18N enabled.; *********/; /****f* libAfterImage/asfont/get_asfont(); * NAME; * get_asfont(); * SYNOPSIS; * ASFont *get_asfont( ASFontManager *fontman,; * const char *font_string,; * int face_no, int size,; * ASFontType type );; * INPUTS; * fontman - pointer to previously created ASFontManager. Needed for; * connection to FreeType library, path to search fonts; * in, and X Server connection.; * font_string - font name or filename of the file containing font's data.; * face_no - number of face within the font file; * size - font size in points. Applicable only to scalable fonts,; * such as TrueType.; * type - s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h:2030,load,load,2030,graf2d/asimage/src/libAfterImage/asfont.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h,1,['load'],['load']
Performance," files marked as 'non-staged'; /// are ignored; /// and 'csopt' controls if an actual check on the staged status (via TFileStager) is done; /// 0 check that the file is staged using TFileStager; /// 1 do not hard check the staged status; /// (example: use fopt = -101 to check the staged status of all the files, or fopt = 110; /// to re-check the stage status of all the files marked as staged); ///; /// If 'dbg' is true, some information about the ongoing operations is reguraly; /// printed; this can be useful when processing very large datasets, an operation; /// which can take a very long time.; ///; /// The int 'sopt' controls what is done on the selected files (this is effective only; /// if ropt is 0 or 2 - see below):; /// -1 no action (fopt = 2 and sopt = -1 touches all staged files); /// 0 do the full process: open the files and fill the meta-information; /// in the TFileInfo object, including the end-point URL; /// 1 only locate the files, by updating the end-point URL (uses TFileStager::Locate; /// which is must faster of an TFile::Open); /// 2 issue a stage request on the files; ///; /// The int 'ropt' controls which actions are performed:; /// 0 do the full process: get list of files to process and process them; /// 1 get the list of files to be scanned and return it in flist; /// 2 process the files in flist (according to sopt); /// When defined flist is under the responsability the caller.; ///; /// If avgsz > 0 it is used for the final update of the dataset global counters.; ///; /// If 'mss' is defined use it to initialize the stager (instead of the Url in the; /// TFileInfo objects); ///; /// If maxfiles > 0, select for processing a maximum of 'filesmax' files (but if fopt is 1 or 2; /// all files marked as 'staged' are still open or touched); ///; /// Return code; /// 1 dataset was not changed; /// 2 dataset was changed; ///; /// The number of touched, opened and disappeared files are returned in the respective; /// variables, if these are defined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx:1955,perform,performed,1955,proof/proof/src/TDataSetManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx,1,['perform'],['performed']
Performance," for future use; * gamma - gamma value to be used to correct image; * compression - compression level of the resulting ASImage; * ... - NULL terminated list of strings, representing; * arbitrary number of directories to be searched each.; * RETURN VALUE; * Pointer to ASImage structure holding image data on success.; * NULL on failure; * DESCRIPTION; * file2ASImage will attempt to interpret filename in the following way:; * 1)It will try to find file using unmodified filename in all the; * provided search paths.; * 2)It will attempt to append .gz and then .Z to the filename and; * find such file in all the provided search paths.; * 3)If filename ends with extension consisting of digits only - it will; * attempt to find file with this extension stripped off. On success; * this extension will be used to load subimage from the file with that; * number. Subimages are supported only for XCF, GIF, BMP, ICO and CUR; * files.; * After the file is found file2ASImage() attempts to detect file format,; * and if it is known it will load it into new ASImage structure.; * EXAMPLE; * asview.c: ASView.2; *********/; /****f* libAfterImage/import/get_asimage(); * NAME; * get_asimage() - increment reference counter if file is already loaded,; * or load image from file.; * SYNOPSIS; * ASImage *get_asimage( ASImageManager* imageman, const char *file,; * ASFlagType what, unsigned int compression );; * INPUTS; * imageman - pointer to valid ASVisual structure.; * file - root window ID for the destination screen.; * what - full image file's name with path.; * compression -; * RETURN VALUE; * Pointer to ASImage structure holding image data on success.; * NULL on failure; * DESCRIPTION; * get_asimage will attempt check with the ASImageManager's list of load; * images, and if image with requested filename already exists - it will; * increment its reference count and return its pointer.; * Otherwise it will call file2ASImage() to load image from file. It will; * use PATH and gamma values from th",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h:1336,load,load,1336,graf2d/asimage/src/libAfterImage/import.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h,1,['load'],['load']
Performance," for specific trees. Placing entry lists in the current directory; allows calling them as a part of a TTreeFormula expression, so if the user wants; to extract a sublist from a TChain entry list via the GetEntryList() or some other; function, they have to add it to the current directory to be able to use it in; TTreeFormula expressions. ## TEntryList and TEventList. TTree::SetEventList() and TChain::SetEventList() transform a TEventList into a TEntryList; See comments to those functions for more details. ## Types of entry lists; There are two types of entry lists:. #### 1.; for a TTree (fBlocks data member is non-zero); Entry numbers are stored in TEntryListBlocks, which, in their turn, are stored; in the TObjArray fBlocks. The range of the entry numbers is cut into intervals; of kBlockSize entries (currently 64000), so that the first block contains; information which entries out of the first 64000 pass the selection, the second; block - which entries out of the 64000-127999 interval pass the selection, etc.; Some blocks, obviously, might be empty. The internal representation of entry; numbers in the blocks is described in the TEntryListBlock class description, and; this representation might be changed by calling OptimizeStorage() function; (when the list is filled via the Enter() function, this is done automatically,; except for the last block).; Individual entry lists can be merged (functions Merge() and Add()); to make an entry list for a TChain of corresponding TTrees.; Begin_Macro; entrylist_figure1.C; End_Macro. #### 2.; for a TChain (fLists data member is non-zero); It contains a TList of sub-lists (TEntryList objects, corresponding to each TTree); Trees and lists are matched by the TTree name and its file name (full path).; All sub-lists are returned by the GetLists() function and individual lists are; returned by GetEntryList() function. Such lists are no different from the lists for; TTrees, described above.; Begin_Macro; entrylist_figure2.C; End_Macro. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:5362,Optimiz,OptimizeStorage,5362,tree/tree/src/TEntryList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx,1,['Optimiz'],['OptimizeStorage']
Performance," genreflex | Use genreflex rather than rootcint to generate the dictionary.; /// par | Create a PAR file with the minimal set of code needed to read the content of the ROOT file. The name of the PAR file is basename(dirname), with extension '.par' enforced; the PAR file will be created at dirname(dirname).; ///; /// If, in addition to one of the 3 above options, the option ""+"" is specified,; /// the function will generate:; /// - a script called MAKEP to build the shared lib; /// - a dirnameLinkDef.h file; /// - rootcint will be run to generate a dirnameProjectDict.cxx file; /// - dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; /// - a shared lib dirname.so will be created.; /// If the option ""++"" is specified, the generated shared lib is dynamically; /// linked with the current executable module.; /// If the option ""+"" and ""nocompile"" are specified, the utility files are generated; /// as in the option ""+"" but they are not executed.; /// Example:; /// file.MakeProject(""demo"",""*"",""recreate++"");; /// - creates a new directory demo unless it already exist; /// - clear the previous directory content; /// - generate the xxx.h files for all classes xxx found in this file; /// and not yet known to the CINT dictionary.; /// - creates the build script MAKEP; /// - creates a LinkDef.h file; /// - runs rootcint generating demoProjectDict.cxx; /// - compiles demoProjectDict.cxx into demoProjectDict.o; /// - generates a shared lib demo.so; /// - dynamically links the shared lib demo.so to the executable; /// If only the option ""+"" had been specified, one can still link the; /// shared lib to the current executable module with:; ///; /// gSystem->load(""demo/demo.so"");; ///; /// The following feature is not yet enabled:; /// One can restrict the list of classes to be generated by using expressions like:; ///; /// classes = ""Ali*"" generate code only for classes starting with Ali; /// classes = ""myClass"" generate code for class MyClass only.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:3658,load,load,3658,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['load'],['load']
Performance," https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of MemorySanitizer, a detector of uninitialized; /// reads.; ///; /// The algorithm of the tool is similar to Memcheck; /// (http://goo.gl/QKbem). We associate a few shadow bits with every; /// byte of the application memory, poison the shadow of the malloc-ed; /// or alloca-ed memory, load the shadow bits on every memory read,; /// propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisoned).; ///; /// Every module initializer should call __msan_init to ensure that the; /// shadow memory is ready. On error, __msan_warning is called. Since; /// parameters and ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:1195,optimiz,optimizations,1195,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['optimiz'],['optimizations']
Performance," immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum; otherwise, returns 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1677,perform,perform,1677,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,1,['perform'],['perform']
Performance," in a 32 or 64-bit; /// register. These are represented with the VCC bank. During selection, we need; /// to be able to unambiguously go back from a register class to a register; /// bank. To distinguish whether an SGPR should use the SGPR or VCC register; /// bank, we need to know the use context type. An SGPR s1 value always means a; /// VCC bank value, otherwise it will be the SGPR bank. A scalar compare sets; /// SCC, which is a 1-bit unaddressable register. This will need to be copied to; /// a 32-bit virtual register. Taken together, this means we need to adjust the; /// type of boolean operations to be regbank legal. All SALU booleans need to be; /// widened to 32-bits, and all VALU booleans need to be s1 values.; ///; /// A noteworthy exception to the s1-means-vcc rule is for legalization artifact; /// casts. G_TRUNC s1 results, and G_SEXT/G_ZEXT/G_ANYEXT sources are never vcc; /// bank. A non-boolean source (such as a truncate from a 1-bit load from; /// memory) will require a copy to the VCC bank which will require clearing the; /// high bits and inserting a compare.; ///; /// \par Constant bus restriction; ///; /// VALU instructions have a limitation known as the constant bus; /// restriction. Most VALU instructions can use SGPR operands, but may read at; /// most 1 SGPR or constant literal value (this to 2 in gfx10 for most; /// instructions). This is one unique SGPR, so the same SGPR may be used for; /// multiple operands. From a register bank perspective, any combination of; /// operands should be legal as an SGPR, but this is contextually dependent on; /// the SGPR operands all being the same register. There is therefore optimal to; /// choose the SGPR with the most uses to minimize the number of copies.; ///; /// We avoid trying to solve this problem in RegBankSelect. Any VALU G_*; /// operation should have its source operands all mapped to VGPRs (except for; /// VCC), inserting copies from any SGPR operands. This the most trivial legal; /// mapping. ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:2504,load,load,2504,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['load'],['load']
Performance," in the dataset. |; | GetDefinedColumnNames() | Get the names of all the defined columns. |; | GetFilterNames() | Return the names of all filters in the computation graph. |; | GetNRuns() | Return the number of event loops run by this RDataFrame instance so far. |; | GetNSlots() | Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). |; | SaveGraph() | Store the computation graph of an RDataFrame in [DOT format (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) for easy inspection. See the [relevant section](\ref representgraph) for details. |. \anchor introduction; ## Introduction; Users define their analysis as a sequence of operations to be performed on the dataframe object; the framework; takes care of the management of the loop over entries as well as low-level details such as I/O and parallelization.; RDataFrame provides methods to perform most common operations required by ROOT analyses;; at the same time, users can just as easily specify custom code that will be executed in the event loop. RDataFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:. 1. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df014__CSVDataSource_8C.html), [SQLite files](https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html), [RNTuples](https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well. 2. Transform the dataframe by:. - [Applying filters](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset. - [Creating custom columns](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:11665,perform,perform,11665,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['perform'],['perform']
Performance," in two-dimensional coincidence spectra are; ///; /// - non-sensitivity to noise, i.e., only statistically relevant peaks should be identified; /// - non-sensitivity of the algorithm to continuous background; /// - non-sensitivity to one-fold coincidences (coincidences peak - background in both dimensions) and their crossings; /// - ability to identify peaks close to the edges of the spectrum region. Usually peak finders fail to detect them; /// - resolution, decomposition of doublets and multiplets. The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma; ///; /// #### References:; ///; /// [1] M.A. Mariscotti: A method for identification of peaks in the presence of; /// background and its application to spectrum analysis. NIM 50 (1967), 309-320.; ///; /// [2] M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.:Identification; /// of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); /// 108-125.; ///; /// [3] Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; /// (1996), 451.; ///; /// ### Examples of peak searching method; ///; /// SearchHighRes function provides users with the possibility; /// to vary the input parameters and with the access to the output deconvolved data; /// in the destination spectrum. Based on the output data one can tune the; /// parameters.; ///; /// ### Example 8 - Src.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Src.C; /// End_Macro; ///; /// ### Example 9 - Src2.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Src2.C; /// End_Macro; ///; /// ### Example 10 - Src3.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Src3.C; /// End_Macro; ///; /// ### Example 11 - Src4.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Src4.C; /// End_Macro; ///; /// ### Example 12 - Src5.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Src5.C; /// End_Macro",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:2978,tune,tune,2978,hist/spectrum/src/TSpectrum2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx,1,['tune'],['tune']
Performance," including. In addition to provide the API for function minimization (via ROOT::Math::Minimizer::Minimize) the Minimizer class provides:; - the interface for setting the function to be minimized. The objective function passed to the Minimizer must implement the multi-dimensional generic interface; ROOT::Math::IBaseFunctionMultiDim. If the function provides gradient calculation (e.g. implementing the ROOT::Math::IGradientFunctionMultiDim interface); the gradient will be used by the Minimizer class, when needed. There are convenient classes for the users to wrap their own functions in this required interface for minimization.; These are the `ROOT::Math::Functor` class and the `ROOT::Math::GradFunctor` class for wrapping functions providing both evaluation and gradient. Some methods, like Fumili, Fumili2 and GSLMultiFit are; specialized method for least-square and also likelihood minimizations. They require then that the given function implements in addition; the `ROOT::Math::FitMethodFunction` interface.; - The interface for setting the initial values for the function variables (which are the parameters in; of the model function in case of solving for fitting) and specifying their limits.; - The interface to set and retrieve basic minimization parameters. These parameter are controlled by the class `ROOT::Math::MinimizerOptions`.; When no parameters are specified the default ones are used. Specific Minimizer options can also be passed via the `MinimizerOptions` class.; For the list of the available option parameter one must look at the documentation of the corresponding derived class.; - The interface to retrieve the result of minimization ( minimum X values, function value, gradient, error on the minimum, etc...); - The interface to perform a Scan, Hesse or a Contour plot (for the minimizers that support this, i.e. Minuit and Minuit2). An example on how to use this interface is the tutorial NumericalMinimization.C in the tutorials/fit directory. @ingroup MultiMin; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h:3827,perform,perform,3827,math/mathcore/inc/Math/Minimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h,1,['perform'],['perform']
Performance," input a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo->Fit(func, ""S"");; /// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full covariance matrix; /// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; /// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; /// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1309,multi-thread,multi-threading,1309,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['multi-thread'],['multi-threading']
Performance," is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTreeCache::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; - TTreeCache::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries.; - A 'cached' TChain switches over to a new file. \anchor cachemisses; ## Self-optimization in presence of cache misses. The TTreeCache can optimize its behavior on a cache miss. When; miss optimization is enabled (see the SetOptimizeMisses method),; it tracks all branches utilized after the learning phase which caused a cache; miss.; When one cache miss occurs, all the utilized branches are be prefetched; for that event. This optimization utilizes the observation that infrequently; accessed branches are often accessed together.; An example scenario where such behavior is desirable, is an analysis where; a set of collections are read only for a few events in which a certain; condition is respected, e.g. a trigger fired. ### Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase; by at most a factor two in the case of cache miss.; Additionally, on the first miss of an event, we must iterate through all the; ""active branches"" for the miss cache and find the correct basket.; This can be potentially a CPU-expensive operation compared to, e.g., the; latency of a SSD. This is why the miss cache is currently disabled by default. \anchor examples; ## Example usages of TTreeCache. A few use cases are discussed below. A cache may be created with automatic; sizing when a TTree is used:. In some applications, e.g. central processing workflows of experiments, the list; of branches to r",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:5094,optimiz,optimization,5094,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['optimiz'],['optimization']
Performance," its size exceeds threshold.; * TODO; * implement proper XFontSet support, when used with I18N enabled.; *********/; /****f* libAfterImage/asfont/get_asfont(); * NAME; * get_asfont(); * SYNOPSIS; * ASFont *get_asfont( ASFontManager *fontman,; * const char *font_string,; * int face_no, int size,; * ASFontType type );; * INPUTS; * fontman - pointer to previously created ASFontManager. Needed for; * connection to FreeType library, path to search fonts; * in, and X Server connection.; * font_string - font name or filename of the file containing font's data.; * face_no - number of face within the font file; * size - font size in points. Applicable only to scalable fonts,; * such as TrueType.; * type - specifies the type of the font, or GuessWho for; * autodetection.; * RETURN VALUE; * pointer to Opened ASFont structure, containing all the glyphs of the; * font, as well as other relevant info. On failure returns NULL.; * DESCRIPTION; * This function provides unified interface to font loading. It performs; * search in ASFontManager's list to see if this specific font has been; * loaded already, and if so - returns pointer to relevant structure.; * Otherwise it tryes to load font as FreeType font first, and then; * Xlib font, unless exact font type is specifyed.; *********/; /****f* libAfterImage/asfont/release_font(); * NAME; * release_font(); * SYNOPSIS; * void release_font( ASFont *font );; * INPUTS; * font - pointer to the valid ASFont structure containing loaded font.; * RETURN VALUE; * returns current reference count. -1 means that object has been; * destroyed.; * DESCRIPTION; * This function will decrement reference count on loaded font and if; * reference count will be less then 0 ( meaning that release_font() has; * been called more times then get_asfont() ) it will close the font,; * remove it from ASFontManager's list, destroy all the glyphs and; * generally free everything else used by ASFont.; * Otherwise font will remain in memory for faster reuse.; *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h:3323,perform,performs,3323,graf2d/asimage/src/libAfterImage/asfont.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h,5,"['load', 'perform']","['load', 'loaded', 'performs']"
Performance," license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file lowers exception-related instructions and setjmp/longjmp function; /// calls to use Emscripten's library functions. The pass uses JavaScript's try; /// and catch mechanism in case of Emscripten EH/SjLj and Wasm EH intrinsics in; /// case of Emscripten SjLJ.; ///; /// * Emscripten exception handling; /// This pass lowers invokes and landingpads into library functions in JS glue; /// code. Invokes are lowered into function wrappers called invoke wrappers that; /// exist in JS side, which wraps the original function call with JS try-catch.; /// If an exception occurred, cxa_throw() function in JS side sets some; /// variables (see below) so we can check whether an exception occurred from; /// wasm code and handle it appropriately.; ///; /// * Emscripten setjmp-longjmp handling; /// This pass lowers setjmp to a reasonably-performant approach for emscripten.; /// The idea is that each block with a setjmp is broken up into two parts: the; /// part containing setjmp and the part right after the setjmp. The latter part; /// is either reached from the setjmp, or later from a longjmp. To handle the; /// longjmp, all calls that might longjmp are also called using invoke wrappers; /// and thus JS / try-catch. JS longjmp() function also sets some variables so; /// we can check / whether a longjmp occurred from wasm code. Each block with a; /// function call that might longjmp is also split up after the longjmp call.; /// After the longjmp call, we check whether a longjmp occurred, and if it did,; /// which setjmp it corresponds to, and jump to the right post-setjmp block.; /// We assume setjmp-longjmp handling always run after EH handling, which means; /// we don't expect any exception-related instructions when SjLj runs.; /// FIXME Currently this scheme does not support indirect cal",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:1236,perform,performant,1236,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,1,['perform'],['performant']
Performance," longjmpable function calls will be converted to an invoke that will; /// unwind to this catchpad in case a longjmp occurs. Within the catchpad, we; /// test the thrown values using testSetjmp function as we do for Emscripten; /// SjLj. The main difference is, in Emscripten SjLj, we need to transform every; /// longjmpable callsite into a sequence of code including testSetjmp() call; in; /// Wasm SjLj we do the testing in only one place, in this catchpad.; ///; /// After testing calling testSetjmp(), if the longjmp does not correspond to; /// one of the setjmps within the current function, it rethrows the longjmp; /// by calling __wasm_longjmp(). If it corresponds to one of setjmps in the; /// function, we jump to the beginning of the function, which contains a switch; /// to each post-setjmp BB. Again, in Emscripten SjLj, this switch is added for; /// every longjmpable callsite; in Wasm SjLj we do this only once at the top of; /// the function. (after setjmpTable/setjmpTableSize initialization); ///; /// The below is the pseudocode for what we have described; ///; /// entry:; /// Initialize setjmpTable and setjmpTableSize; ///; /// setjmp.dispatch:; /// switch %label {; /// label 1: goto post-setjmp BB 1; /// label 2: goto post-setjmp BB 2; /// ...; /// default: goto splitted next BB; /// }; /// ...; ///; /// bb:; /// invoke void @foo() ;; foo is a longjmpable function; /// to label %next unwind label %catch.dispatch.longjmp; /// ...; ///; /// catch.dispatch.longjmp:; /// %0 = catchswitch within none [label %catch.longjmp] unwind to caller; ///; /// catch.longjmp:; /// %longjmp.args = wasm.catch() ;; struct __WasmLongjmpArgs; /// %env = load 'env' field from __WasmLongjmpArgs; /// %val = load 'val' field from __WasmLongjmpArgs; /// %label = testSetjmp(mem[%env], setjmpTable, setjmpTableSize);; /// if (%label == 0); /// __wasm_longjmp(%env, %val); /// catchret to %setjmp.dispatch; ///; ///===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:11146,load,load,11146,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,2,['load'],['load']
Performance," not be implemented as one; // of the AArch64 conditional branches that do not use the flags as input; // (CB(N)Z and TB(N)Z). This is implemented by ensuring in the instruction; // selectors to not produce these instructions when speculation hardening; // is enabled. This pass will assert if it does encounter such an instruction.; // - On function call boundaries, the miss-speculation state is transferred from; // the taint register X16 to be encoded in the SP register as value 0.; //; // For the aspect of automatically hardening loads, using the taint register,; // (a.k.a. speculative load hardening, see; // https://llvm.org/docs/SpeculativeLoadHardening.html), the following; // implementation choices are made for AArch64:; // - Many of the optimizations described at; // https://llvm.org/docs/SpeculativeLoadHardening.html to harden fewer; // loads haven't been implemented yet - but for some of them there are; // FIXMEs in the code.; // - loads that load into general purpose (X or W) registers get hardened by; // masking the loaded data. For loads that load into other registers, the; // address loaded from gets hardened. It is expected that hardening the; // loaded data may be more efficient; but masking data in registers other; // than X or W is not easy and may result in being slower than just; // hardening the X address register loaded from.; // - On AArch64, CSDB instructions are inserted between the masking of the; // register and its first use, to ensure there's no non-control-flow; // speculation that might undermine the hardening mechanism.; //; // Future extensions/improvements could be:; // - Implement this functionality using full speculation barriers, akin to the; // x86-slh-lfence option. This may be more useful for the intrinsics-based; // approach than for the SLH approach to masking.; // Note that this pass already inserts the full speculation barriers if the; // function for some niche reason makes use of X16/W16.; // - no indirect branch mispredict",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:4455,load,loads,4455,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,3,['load'],"['load', 'loaded', 'loads']"
Performance," not match real offsets in the running; // kernel. During BPF program load LDX and STX instructions; // referring to the fields of these types are rewritten so that; // offsets match real offsets. For this rewrite to happen field; // offsets have to be encoded as immediate operands of the; // instructions.; //; // See kernel/bpf/verifier.c:convert_ctx_access function in the; // Linux kernel source tree for details.; //; // (b) Pointers to context parameters of BPF programs must not be; // modified before access.; //; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for cases (a) and (b) to work the sequence %x-%y above has; // to be preserved by the IR passes.; //; // However, several optimization passes might sink `load` instruction; // or hoist `getelementptr` instruction so that the instructions are; // no longer in sequence. Examples of such passes are:; // SimplifyCFGPass, InstCombinePass, GVNPass.; // After such modification the verifier would reject the BPF program.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic functi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:1882,load,load,1882,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,1,['load'],['load']
Performance," of TTrees with several; hundred or thousand branches. When writing, this does not generate a performance problem because branch; buffers are always written sequentially and, thanks to OS optimisations,; content is flushed to the output file when a few MBytes of data are available.; On the other hand, when reading, one may hit performance problems because of; latencies e.g imposed by network.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second. The TreeCache tries to prefetch all the buffers for the selected branches; in order to transfer a few multi-Megabytes large buffers instead of many; multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to; be read in increasing order such that the file is read sequentially. Systems like xrootd, dCache or httpd take advantage of the TTreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. ### Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all; entries such that not all branch buffers are read. \anchor description; ## General Description; This class acts as a file cache, registering automatically the baskets from; the branches being processed via direct manipulation of TTrees or with tools; such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame; when in the learning phase. The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. The usage of a TTreeCache can considerably improve the runtime performance at; the price of a modest investment in memory, in particular when the TTree is; accessed remotely, e.g. via a high latency network. For each TTree being processed a TTreeCache o",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:2203,cache,cache,2203,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance," of a rotation is a rotation about the same axis but of opposite angle, thus if Q is a unit quaternion,; \f$ Q = cos(\frac{f}{2}) + sin(\frac{f}{2}).u = Q|_r + Q|_V\f$ , then :; \f$ Q^{-1} =cos(-\frac{f}{2}) + sin(-\frac{f}{2}).u = cos(\frac{f}{2}) - sin(\frac{f}{2}).u = Q|_r -Q|_V \f$ is its inverse quaternion. One verifies that :; \f$ Q.Q^{-1} = Q^{-1}.Q = Q|_r*Q|_r + Q|_V*Q|_V + Q|_r*Q|_V -Q|_r*Q|_V + Q|_VXQ|_V = Q\leq|_r + Q\leq|_V = 1 \f$. The rotation of a vector V by the rotation described by a unit quaternion Q is obtained by the following operation :; \f$ V' = Q*V*Q^{-1} \f$, considering V as a quaternion whose real part is null. #### Numeric computation considerations :. Numerically, the quaternion multiplication involves 12 additions and 16 multiplications.; It is therefore faster than 3x3 matrixes multiplication involving 18 additions and 27 multiplications. On the contrary, rotation of a vector by the above formula ( \f$ Q*V*Q^{-1} \f$ ) involves 18 additions; and 24 multiplications, whereas multiplication of a 3-vector by a 3x3 matrix involves only 6 additions; and 9 multiplications. When dealing with numerous composition of space rotation, it is therefore faster to use quaternion product. On the other hand if a huge set of vectors must be rotated by a given quaternion, it is more optimized to convert the quaternion into a rotation matrix once, and then use that later to rotate the set of vectors. #### More information :. http://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation. http://en.wikipedia.org/wiki/Quaternion. This Class represents all quaternions (unit or non-unit); It possesses a Normalize() method to make a given quaternion unit; The Rotate(TVector3&) and Rotation(TVector3&) methods can be used even for a non-unit quaternion, in that case, the proper normalization is applied to perform the rotation. A TRotation constructor exists than takes a quaternion for parameter (even non-unit), in that cas the proper normalisation is applied.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TQuaternion.cxx:3979,optimiz,optimized,3979,math/physics/src/TQuaternion.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TQuaternion.cxx,2,"['optimiz', 'perform']","['optimized', 'perform']"
Performance," of the species; in the control variable \f$x\f$, within the above defined statistical uncertainties. ### Illustrations. To illustrate the technique, one considers an example derived from the analysis where; \f$\hbox {$_s$}{\cal P}lots\f$; have been first used (charmless B decays). One is dealing with a data; sample in which two species are present: the first is termed signal and; the second background. A maximum Likelihood fit is performed to obtain; the two yields \f$N_1\f$ and \f$N_2\f$ . The fit relies on two discriminating; variables collectively denoted \f$y\f$ which are chosen within three possible; variables denoted \f${m_{\rm ES}}\f$ , \f$\Delta E\f$ and \f${\cal F}\f$.; The variable which is not incorporated in \f$y\f$ is used as the control variable; \f$x\f$ . The six distributions of the three variables are assumed to be the ones; depicted in Fig. 1. \image html splot_pdfmesNIM.png Figure 1 width=800. Distributions of the three discriminating variables available to perform the Likelihood fit:; \f${m_{\rm ES}}\f$ , \f$\Delta E\f$ , \f${\cal F}\f$ .; Among the three variables, two are used to perform the fit while one is; kept out of the fit to serve the purpose of a control variable. The; three distributions on the top (resp. bottom) of the figure correspond; to the signal (resp. background). The unit of the vertical axis is; chosen such that it indicates the number of entries per bin, if one; slices the histograms in 25 bins. A data sample being built through a Monte Carlo simulation based on the; distributions shown in Fig.; 1,; one obtains the three distributions of Fig. 2.; Whereas the distribution of \f$\Delta E\f$ clearly indicates the presence of the signal,; the distribution of \f${m_{\rm ES}}\f$ and \f${\cal F}\f$ are less obviously populated by signal. \image html splot_genfiTOTNIM.png Figure 2 width=800. Distributions of the three discriminating variables for signal plus; background. The three distributions are the ones obtained from a data; sam",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/splot/src/TSPlot.cxx:7198,perform,perform,7198,math/splot/src/TSPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/splot/src/TSPlot.cxx,1,['perform'],['perform']
Performance," only. - bool TSelector::Notify(). This method is called at the first entry; of a new file in a chain. - bool TSelector::Process(Long64_t entry). This method is called; to process an entry. It is the user's responsibility to read; the corresponding entry in memory (may be just a partial read).; Once the entry is in memory one can apply a selection and if the; entry is selected histograms can be filled. Processing stops; when this function returns false. This function combines the; next two functions in one, avoiding to have to maintain state; in the class to communicate between these two functions.; See WARNING below about entry.; This method is used by PROOF. - bool TSelector::ProcessCut(Long64_t entry). This method is called; before processing entry. It is the user's responsibility to read; the corresponding entry in memory (may be just a partial read).; The function returns true if the entry must be processed,; false otherwise. This method is obsolete, use Process().; See WARNING below about entry. - void TSelector::ProcessFill(Long64_t entry). This method is called; for all selected entries. User fills histograms in this function.; This method is obsolete, use Process().; See WARNING below about entry. - void TSelector::SlaveTerminate(). This method is called at the end of; the loop on all PROOF worker nodes. In local mode this method is; called on the client too. - void TSelector::Terminate(). This method is called at the end of; the loop on all entries. When using PROOF Terminate() is call on; the client only. Typically one performs the fits on the produced; histograms or write the histograms to file in this method. __WARNING when a selector is used with a TChain:__. in the Process, ProcessCut, ProcessFill function, you must use; the pointer to the current Tree to call `GetEntry(entry)`.; entry is always the local entry number in the current tree.; Assuming that fChain is the pointer to the TChain being processed,; use `fChain->GetTree()->GetEntry(entry);`; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:2676,perform,performs,2676,tree/tree/src/TSelector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx,1,['perform'],['performs']
Performance," opened. In general, using this instead of GetEntries will avoid; /// opening all files in the chain which could be very costly for very; /// large number of files stored at a remote location.; ///; /// The logic depends on whether the dataset is a TTree or a TChain. In the; /// first case, it simply returns the total number of entries in the tree. In; /// the latter case, it depends on which point of the processing of the chain; /// this function is called. During most of the chain processing, this; /// function will return TTree::kMaxEntries. When the chain arrives at the; /// last file, then the function will return the accumulated total number of; /// entries in the whole chain. A notable use case where this function; /// becomes quite useful is when writing the following for loop to traverse; /// the entries in the dataset:; ///; /// \code{.cpp}; /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; /// // Do something with the event in the dataset; /// }; /// \endcode; ///; /// In the example above, independently on whether the dataset is a TTree or; /// a TChain, the GetEntriesFast call will provide the correct stopping; /// condition for the loop (i.e. the total number of entries). In the TChain; /// case, calling GetEntries instead would open all the files in the chain; /// upfront which could be costly.; ///; /// The functionality offered by this method can also be seen when used in; /// conjunction with LoadTree. For a call like <tt> LoadTree(ievent) </tt>,; /// the condition <tt> ievent < dataset.GetEntriesFast() </tt> is only; /// satisfied if \p ievent is strictly smaller than the total number of; /// entries in the dataset. In fact, even when the dataset is a TChain, the; /// first time LoadTree is called with an entry number that belongs to the; /// last file of the chain, this will update the internal data member of the; /// class so that the next call to GetEntriesFast returns the total number; /// of entries in the dataset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:1712,Load,LoadTree,1712,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,3,['Load'],['LoadTree']
Performance," optional gzip encoding. Add; 16 to windowBits to write a simple gzip header and trailer around the; compressed data instead of a zlib wrapper. The gzip header will have no; file name, no extra data, no comment, no modification time (set to zero),; no header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but; is slow and reduces compression ratio; memLevel=9 uses maximum memory; for optimal speed. The default value is 8. See zconf.h for total memory; usage as a function of windowBits and memLevel. The strategy parameter is used to tune the compression algorithm. Use the; value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a; filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no; string match), or Z_RLE to limit match distances to one (run-length; encoding). Filtered data consists mostly of small values with a somewhat; random distribution. In this case, the compression algorithm is tuned to; compress them better. The effect of Z_FILTERED is to force more Huffman; coding and less string matching; it is somewhat intermediate between; Z_DEFAULT and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as; Z_HUFFMAN_ONLY, but give better compression for PNG image data. The strategy; parameter only affects the compression ratio but not the correctness of the; compressed output even if it is not set appropriately. Z_FIXED prevents the; use of dynamic Huffman codes, allowing for a simpler decoder for special; applications. deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid; method). msg is set to null if there is no error message. deflateInit2 does; not perform any compression: this will be done by deflate().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:2615,tune,tuned,2615,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,2,"['perform', 'tune']","['perform', 'tuned']"
Performance," phase is started or restarted when:; - TTree automatically creates a cache.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTreeCache::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; - TTreeCache::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries.; - A 'cached' TChain switches over to a new file. \anchor cachemisses; ## Self-optimization in presence of cache misses. The TTreeCache can optimize its behavior on a cache miss. When; miss optimization is enabled (see the SetOptimizeMisses method),; it tracks all branches utilized after the learning phase which caused a cache; miss.; When one cache miss occurs, all the utilized branches are be prefetched; for that event. This optimization utilizes the observation that infrequently; accessed branches are often accessed together.; An example scenario where such behavior is desirable, is an analysis where; a set of collections are read only for a few events in which a certain; condition is respected, e.g. a trigger fired. ### Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase; by at most a factor two in the case of cache miss.; Additionally, on the first miss of an event, we must iterate through all the; ""active branches"" for the miss cache and find the correct basket.; This can be potentially a CPU-expensive operation compared to, e.g., the; latency of a SSD. This is why the miss cache is currently disabled by default. \anchor examples; ## Example usages of TTreeCache. A few use cases are discussed below. A cache may be created with automatic; sizing when a TTree is used:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:5009,cache,cache,5009,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance," potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via a TPad; repaint at present), and thus collect these objects if the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. ## Physical IDs. TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0). ~~~ {.cpp}; virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); ~~~. If you use the first (simple) case a viewer using logical/physical pairs; will generate IDs for each physical object internally. In the second you; can specify a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical objects no longer of interest as part of scene rebuilds. ## Child Objects. In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. ## Recycling TBuffer3D. Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualViewer3D.cxx:10601,cache,cache,10601,core/base/src/TVirtualViewer3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualViewer3D.cxx,1,['cache'],['cache']
Performance," preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br i1 %39, label %res_block, label %loadbb3; /// loadbb3: ; preds = %loadbb2; /// %40 = bitcast i32* %buffer2 to i8*; /// %41 = bitcast i32* %buffer1 to i8*; /// %42 = getelementptr i8, i8* %41, i8 14; /// %43 = getelementptr i8, i8* %40, i8 14; /// %44 = load i8, i8* %42; /// %45 = load i8, i8* %43; /// %46 = zext i8 %44 to i32; /// %47 = zext i8 %45 to i32; /// %48 = sub i32 %46, %47; /// br label %endblock; /// endblock: ; preds = %res_block,; /// %loadbb3; /// %phi.res = phi i32 [ %48, %loadbb3 ], [ %11, %res_block ]; /// ret i32 %phi.res",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:2533,load,load,2533,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,2,['load'],['load']
Performance," present.; ~~~{.cpp}; // use ""b1"" and ""b2"" as default columns; RDataFrame d1(""myTree"", ""file.root"", {""b1"",""b2""});; auto h = d1.Filter([](int b1, int b2) { return b1 > b2; }) // will act on ""b1"" and ""b2""; .Histo1D(); // will act on ""b1"". // just one default column this time; RDataFrame d2(""myTree"", ""file.root"", {""b1""});; auto min = d2.Filter([](double b2) { return b2 > 0; }, {""b2""}) // we can still specify non-default column lists; .Min(); // returns the minimum value of ""b1"" for the filtered entries; ~~~. \anchor helper-cols; ### Special helper columns: rdfentry_ and rdfslot_; Every instance of RDataFrame is created with two special columns called `rdfentry_` and `rdfslot_`. The `rdfentry_`; column is of type `ULong64_t` and it holds the current entry number while `rdfslot_` is an `unsigned int`; holding the index of the current data processing slot.; For backwards compatibility reasons, the names `tdfentry_` and `tdfslot_` are also accepted.; These columns are ignored by operations such as [Cache](classROOT_1_1RDF_1_1RInterface.html#aaaa0a7bb8eb21315d8daa08c3e25f6c9); or [Snapshot](classROOT_1_1RDF_1_1RInterface.html#a233b7723e498967f4340705d2c4db7f8). \warning Note that in multi-thread event loops the values of `rdfentry_` _do not_ correspond to what would be the entry numbers; of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order. \anchor jitting; ### Just-in-time compilation: column type inference and explicit declaration of column types; C++ is a statically typed language: all types must be known at compile-time. This includes the types of the TTree; branches we want to work on. For filters, defined columns and some of the actions, **column types are deduced from the; signature** of the relevant filter function/temporary column expression/action function:; ~~~{.cpp}; // here b1 is deduced to be `int` and b2 to be `double`; df.Filter([](int x, double y) { return x > 0 && y < 0.; }, {""b1"", ""b2""});; ~~~; If we",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:64516,Cache,Cache,64516,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['Cache'],['Cache']
Performance," produce these instructions when speculation hardening; // is enabled. This pass will assert if it does encounter such an instruction.; // - On function call boundaries, the miss-speculation state is transferred from; // the taint register X16 to be encoded in the SP register as value 0.; //; // For the aspect of automatically hardening loads, using the taint register,; // (a.k.a. speculative load hardening, see; // https://llvm.org/docs/SpeculativeLoadHardening.html), the following; // implementation choices are made for AArch64:; // - Many of the optimizations described at; // https://llvm.org/docs/SpeculativeLoadHardening.html to harden fewer; // loads haven't been implemented yet - but for some of them there are; // FIXMEs in the code.; // - loads that load into general purpose (X or W) registers get hardened by; // masking the loaded data. For loads that load into other registers, the; // address loaded from gets hardened. It is expected that hardening the; // loaded data may be more efficient; but masking data in registers other; // than X or W is not easy and may result in being slower than just; // hardening the X address register loaded from.; // - On AArch64, CSDB instructions are inserted between the masking of the; // register and its first use, to ensure there's no non-control-flow; // speculation that might undermine the hardening mechanism.; //; // Future extensions/improvements could be:; // - Implement this functionality using full speculation barriers, akin to the; // x86-slh-lfence option. This may be more useful for the intrinsics-based; // approach than for the SLH approach to masking.; // Note that this pass already inserts the full speculation barriers if the; // function for some niche reason makes use of X16/W16.; // - no indirect branch misprediction gets protected/instrumented; but this; // could be done for some indirect branches, such as switch jump tables.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:4679,load,loaded,4679,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,2,['load'],['loaded']
Performance," program optimization of virtual calls in cases; // where we know (via !type metadata) that the list of callees is fixed. This; // includes the following:; // - Single implementation devirtualization: if a virtual call has a single; // possible callee, replace all calls with a direct call to that callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that participate in the link.; // The pass computes a resolution for each virtual call and stores it in the; // type identifier summary.; // - Import phase: this is run during the thin backends over the individual; // modules. The pass applies the resolut",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1287,optimiz,optimization,1287,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['optimiz'],['optimization']
Performance," rather than to the graphs themselves. At the; // end of the bootstrap process the deferred actions are attached to a final; // ""complete-bootstrap"" graph that causes them to be run.; //; // The bootstrap steps are as follows:; //; // 1. Request the graph containing the mach header. This graph is guaranteed; // not to have any metadata so the fact that the registration functions; // are not available yet is not a problem.; //; // 2. Look up the registration functions and discard the results. This will; // trigger linking of the graph containing these functions, and; // consequently any graphs that it depends on. We do not use the lookup; // result to find the addresses of the functions requested (as described; // above the lookup will return too late for that), instead we capture the; // addresses in a post-allocation pass injected by the platform runtime; // during bootstrap only.; //; // 3. During bootstrap the MachOPlatformPlugin keeps a count of the number of; // graphs being linked (potentially concurrently), and we block until all; // of these graphs have completed linking. This is to avoid a race on the; // deferred-actions vector: the lookup for the runtime registration; // functions may return while some functions (those that are being; // incidentally linked in, but aren't reachable via the runtime functions); // are still being linked, and we need to capture any allocation actions; // for this incidental code before we proceed.; //; // 4. Once all active links are complete we transfer the deferred actions to; // a newly added CompleteBootstrap graph and then request a symbol from; // the CompleteBootstrap graph to trigger materialization. This will cause; // all deferred actions to be run, and once this lookup returns we can; // proceed.; //; // 5. Finally, we associate runtime support methods in MachOPlatform with; // the corresponding jit-dispatch tag variables in the ORC runtime to make; // the support methods callable. The bootstrap is now complete.; /",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:2169,concurren,concurrently,2169,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,1,['concurren'],['concurrently']
Performance," safely used whenever; /// the type is encountered.; ///; /// A Recursive entry will have all of its sub-members expanded as fully as; /// possible. The type itself is recursive and it may contain other types which; /// are recursive. The Recursive encoding must not be used during the expansion; /// of a recursive type's recursive branch. For simplicity the code uses; /// IncompleteCount to reject all usage of Recursive encodings for member types.; ///; /// An Incomplete entry is always a RecordType and only encodes its; /// identifier e.g. ""s(S){}"". Incomplete 'StubEnc' entries are ephemeral and; /// are placed into the cache during type expansion as a means to identify and; /// handle recursive inclusion of types as sub-members. If there is recursion; /// the entry becomes IncompleteUsed.; ///; /// During the expansion of a RecordType's members:; ///; /// If the cache contains a NonRecursive encoding for the member type, the; /// cached encoding is used;; ///; /// If the cache contains a Recursive encoding for the member type, the; /// cached encoding is 'Swapped' out, as it may be incorrect, and...; ///; /// If the member is a RecordType, an Incomplete encoding is placed into the; /// cache to break potential recursive inclusion of itself as a sub-member;; ///; /// Once a member RecordType has been expanded, its temporary incomplete; /// entry is removed from the cache. If a Recursive encoding was swapped out; /// it is swapped back in;; ///; /// If an incomplete entry is used to expand a sub-member, the incomplete; /// entry is marked as IncompleteUsed. The cache keeps count of how many; /// IncompleteUsed entries it currently contains in IncompleteUsedCount;; ///; /// If a member's encoding is found to be a NonRecursive or Recursive viz:; /// IncompleteUsedCount==0, the member's encoding is added to the cache.; /// Else the member is part of a recursive type and thus the recursion has; /// been exited too soon for the encoding to be correct for the member.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:1940,cache,cache,1940,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,4,['cache'],['cache']
Performance," similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias ana",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:2169,load,loads,2169,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,5,['load'],"['load', 'loads']"
Performance," the 4th parameter, the two operands; /// element-wise. The result is written to the first operand.; ///; /// Different reduction algorithms are implemented in different; /// runtime functions, all calling 'shuffleReduceFn' to perform; /// the essential reduction step. Therefore, based on the 4th; /// parameter, this function behaves slightly differently to; /// cooperate with the runtime to ensure correctness under; /// different circumstances.; ///; /// 'InterWarpCpyFn' is a pointer to a function that transfers; /// reduced variables across warps. It tunnels, through CUDA; /// shared memory, the thread-private data of type 'ReduceData'; /// from lane 0 of each warp to a lane in the first warp.; /// 4. Call the OpenMP runtime on the GPU to reduce across teams.; /// The last team writes the global reduced value to memory.; ///; /// ret = __kmpc_nvptx_teams_reduce_nowait(...,; /// reduceData, shuffleReduceFn, interWarpCpyFn,; /// scratchpadCopyFn, loadAndReduceFn); ///; /// 'scratchpadCopyFn' is a helper that stores reduced; /// data from the team master to a scratchpad array in; /// global memory.; ///; /// 'loadAndReduceFn' is a helper that loads data from; /// the scratchpad array and reduces it with the input; /// operand.; ///; /// These compiler generated functions hide address; /// calculation and alignment information from the runtime.; /// 5. if ret == 1:; /// The team master of the last team stores the reduced; /// result to the globals in memory.; /// foo += reduceData.foo; bar *= reduceData.bar; ///; ///; /// Warp Reduction Algorithms; ///; /// On the warp level, we have three algorithms implemented in the; /// OpenMP runtime depending on the number of active lanes:; ///; /// Full Warp Reduction; ///; /// The reduce algorithm within a warp where all lanes are active; /// is implemented in the runtime as follows:; ///; /// full_warp_reduce(void *reduce_data,; /// kmp_ShuffleReductFctPtr ShuffleReduceFn) {; /// for (int offset = WARPSIZE/2; offset > 0; offs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:3985,load,loadAndReduceFn,3985,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['load'],['loadAndReduceFn']
Performance," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1805,perform,perform,1805,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,2,['perform'],"['perform', 'performed']"
Performance," the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is the LLVM loop vectorizer. This pass modifies 'vectorizable' loops; // and generates target-independent LLVM-IR.; // The vectorizer uses the TargetTransformInfo analysis to estimate the costs; // of instructions in order to estimate the profitability of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has three parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:1089,perform,performs,1089,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['perform'],['performs']
Performance," the RResultPtr is constructed before the event loop is started.; /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; /// * `void InitTask(TTreeReader *, unsigned int slot)`: each working thread shall call this method during the event; /// loop, before processing a batch of entries. The pointer passed as argument, if not null, will point to the TTreeReader; /// that RDataFrame has set up to read the task's batch of entries. It is passed to the helper to allow certain advanced optimizations; /// it should not usually serve any purpose for the Helper. This method is often no-op for simple helpers.; /// * `void Exec(unsigned int slot, ColumnTypes...columnValues)`: each working thread shall call this method; /// during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value:; /// this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of; /// the requested columns for the particular entry being processed.; /// * `void Finalize()`: this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; /// * `std::string GetActionName()`: it returns a string identifier for this type of action that RDataFrame will use in; /// diagnostics, SaveGraph(), etc.; ///; /// ### Optional methods; ///; /// If these methods are implemented they enable extra functionality as per the description below.; ///; /// * `Result_t &PartialUpdate(unsigned int slot)`: if present, it must return the value of the partial result of this action for the given 'slot'.; /// Different threads might call this method concurrently, but will do so with different 'slot' numbers.; /// RDataFram",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:2709,concurren,concurrently,2709,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['concurren'],['concurrently']
Performance," the column value is actually read from the dataset: RDataFrame detects type mismatches. The same would; happen if we swapped the order of ""b1"" and ""b2"" in the column list passed to Filter(). Certain actions, on the other hand, do not take a function as argument (e.g. Histo1D()), so we cannot deduce the type of; the column at compile-time. In this case **RDataFrame infers the type of the column** from the TTree itself. This; is why we never needed to specify the column types for all actions in the above snippets. When the column type is not a common one such as `int`, `double`, `char` or `float` it is nonetheless good practice to; specify it as a template parameter to the action itself, like this:; ~~~{.cpp}; df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; ~~~. Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal. When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:. ~~~{.cpp}; // this throws an error (note the typo); df.Define(""x"", ""0"").Filter(""x = 0"");; ~~~. \anchor generic-actions; ### User-defined custom actions; RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; time, it allows users to inject their own action code to perform arbitrarily complex data reductions. #### Implementing custom actions with Book(). Through the Book() method, users can implement a custom action and have access to the same features; that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; event loop, or the possibility to return a lazy RResultPtr t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:66735,perform,performance,66735,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['perform'],['performance']
Performance," the creation of custom streams, mixing multiple tables and bit sources. A key property to keep in mind is that encoding and decoding are done **in reverse direction**.; So the first symbol you will encode is the last you will decode, like a LIFO stack. You will need a few variables to track your CStream. They are :. FSE_CTable ct; // Provided by FSE_buildCTable(); BIT_CStream_t bitStream; // bitStream tracking structure; FSE_CState_t state; // State tracking structure (can have several). The first thing to do is to init bitStream and state.; size_t errorCode = BIT_initCStream(&bitStream, dstBuffer, maxDstSize);; FSE_initCState(&state, ct);. Note that BIT_initCStream() can produce an error code, so its result should be tested, using FSE_isError();; You can then encode your input data, byte after byte.; FSE_encodeSymbol() outputs a maximum of 'tableLog' bits at a time.; Remember decoding will be done in reverse direction.; FSE_encodeByte(&bitStream, &state, symbol);. At any time, you can also add any bit sequence.; Note : maximum allowed nbBits is 25, for compatibility with 32-bits decoders; BIT_addBits(&bitStream, bitField, nbBits);. The above methods don't commit data to memory, they just store it into local register, for speed.; Local register size is 64-bits on 64-bits systems, 32-bits on 32-bits systems (size_t).; Writing data to memory is a manual operation, performed by the flushBits function.; BIT_flushBits(&bitStream);. Your last FSE encoding operation shall be to flush your last state value(s).; FSE_flushState(&bitStream, &state);. Finally, you must close the bitStream.; The function returns the size of CStream in bytes.; If data couldn't fit into dstBuffer, it will return a 0 ( == not compressible); If there is an error, it returns an errorCode (which can be tested using FSE_isError()).; size_t size = BIT_closeCStream(&bitStream);; */; /* *****************************************; * FSE symbol decompression API; *******************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:1471,perform,performed,1471,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['perform'],['performed']
Performance," the dependents of the top-level PDF: these are; functions with potentially non-trivial Jacobian terms themselves.; \note Therefore, no explicit attempt should be made to normalize the; function output in evaluate(). In particular, normalisation constants; can be omitted to speed up the function evaluations, and included later; in the integration of the PDF (see below), which is rarely called in; comparison to the `evaluate()` function. In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters, and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead, the choice of normalization is always specified each time a; normalized value is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; the help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform an entirely numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e., no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; common, etc). #### Implementing analytical integrals; To implement analytical integrals, two functions must be implemented. First,. ```; Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet); ```; should return the analytical integrals that are supported. `integSet`; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to `anaIntSet`, and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. ```; double analyticalIntegral(Int_t code); ```. implements the actual analytical ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:2799,perform,perform,2799,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['perform'],['perform']
Performance," the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +------------------------+ |; // \ | \ /; // +------ block 5 -----+ \---------------; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +---------------------+; //; // During optimization, however, it can happen that an instruction; // computing an address in ""b3"" (for example, a loop-invariant GEP) is; // hoisted up out of the loop from block 4 to block 2. [Note that; // this is not an actual load from the stack, only an instruction that; // computes the address to be loaded]. If this happens, there is now a; // path leading from the first use of b3 to the return instruction; // that does not encounter the b3 LIFETIME_END, hence b3's lifetime is; // now larger than if we were computing live intervals strictly based; // on lifetime markers. In the example above, this lengthened lifetime; // would mean that it would appear illegal to overlap b3 with b2.; //; // To deal with this such cases, the code in ::collectMarkers() below; // tries to identify ""degenerate"" slots -- those slots where on a single; // forward pass through the CFG we encounter a first reference to slot; // K before we hit the slot K lifetime start marker. For such slots,; // we fall back on using the lifetime start marker as the beginning of; // the variable's lifetime. NB: with this implementation, slots can; // appear degenerate in cases where there is unstructured control flow:; //; // if (q) goto mid;; // if (x > 9) {; // int b",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:9311,load,load,9311,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,2,['load'],"['load', 'loaded']"
Performance," the learning phase. In the examples below, portions of analysis code are shown.; The few statements involving the TreeCache are marked with `//<<<`. ### ROOT::RDataFrame and TTreeReader Examples. If you use RDataFrame or TTreeReader, the system will automatically cache the; best set of branches: no action is required by the user. ### TTree::Draw Example. The TreeCache is automatically used by TTree::Draw. The method knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also inferred automatically. ### TTree::Process and TSelectors Examples. The user must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case only a subset of the events is processed to avoid wasteful caching. #### Reading all branches. ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; ~~~. #### Reading a subset of all branches. In the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Process we read only 2 branches; auto b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; auto b2 = T->GetBranch(""branc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:7482,cache,cachesize,7482,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,3,['cache'],"['cache', 'cachesize']"
Performance," the reading of ROOT datasets. # A cache to speed-up the reading of ROOT datasets. ## Table of Contents; - [Motivation](\ref motivation); - [General Description](\ref description); - [Changes in behaviour](\ref changesbehaviour); - [Self-optimization](\ref cachemisses); - [Examples of usage](\ref examples); - [Check performance and stats](\ref checkPerf). \anchor motivation; ## Motivation: why having a cache is needed?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of TTrees with several; hundred or thousand branches. When writing, this does not generate a performance problem because branch; buffers are always written sequentially and, thanks to OS optimisations,; content is flushed to the output file when a few MBytes of data are available.; On the other hand, when reading, one may hit performance problems because of; latencies e.g imposed by network.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second. The TreeCache tries to prefetch all the buffers for the selected branches; in order to transfer a few multi-Megabytes large buffers instead of many; multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to; be read in increasing order such that the file is read sequentially. Systems like xrootd, dCache or httpd take advantage of the TTreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. ### Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all; entries such that not all branch b",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:1479,perform,performance,1479,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['perform'],['performance']
Performance," threads internally, if enabled.; // The 6th argument allows the user to specify the compression algorithm:; // - 1 - zlib.; // - 2 - LZMA.; // - 3 - ""old ROOT algorithm"" A variant of zlib; do not use, kept for; // backwards compatability.; // - 4 - LZ4.; // In this example, one loops over nevent events.; // The branch ""event"" is created at the first event.; // The branch address is set for all other events.; // For each event, the event header is filled and ntrack tracks; // are generated and added to the TClonesArray list.; // For each event the event histogram is saved as well as the list; // of all tracks.; //; // The two TRefArray contain only references to the original tracks owned by; // the TClonesArray fTracks.; //; // The number of events can be given as the first argument to the program.; // By default 400 events are generated.; // The compression option can be activated/deactivated via the second argument.; //; // Additionally, if the environment ENABLE_TTREEPERFSTATS is set, then detailed; // statistics about IO performance will be reported.; //; // ---Running/Linking instructions----; // This program consists of the following files and procedures.; // - Event.h event class description; // - Event.C event class implementation; // - MainEvent.C the main program to demo this class might be used (this file); // - EventCint.C the CINT dictionary for the event and Track classes; // this file is automatically generated by rootcint (see Makefile),; // when the class definition in Event.h is modified.; //; // ---Analyzing the Event.root file with the interactive root; // example of a simple session; // Root > TFile f(""Event.root""); // Root > T.Draw(""fNtrack"") //histogram the number of tracks per event; // Root > T.Draw(""fPx"") //histogram fPx for all tracks in all events; // Root > T.Draw(""fXfirst:fYfirst"",""fNtrack>600""); // //scatter-plot for x versus y of first point of each track; // Root > T.Draw(""fH.GetRMS()"") //histogram of the RMS of the event histogram; /",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/MainEvent.cxx:3185,perform,performance,3185,test/MainEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/MainEvent.cxx,1,['perform'],['performance']
Performance," to OS optimisations,; content is flushed to the output file when a few MBytes of data are available.; On the other hand, when reading, one may hit performance problems because of; latencies e.g imposed by network.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second. The TreeCache tries to prefetch all the buffers for the selected branches; in order to transfer a few multi-Megabytes large buffers instead of many; multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to; be read in increasing order such that the file is read sequentially. Systems like xrootd, dCache or httpd take advantage of the TTreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. ### Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all; entries such that not all branch buffers are read. \anchor description; ## General Description; This class acts as a file cache, registering automatically the baskets from; the branches being processed via direct manipulation of TTrees or with tools; such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame; when in the learning phase. The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. The usage of a TTreeCache can considerably improve the runtime performance at; the price of a modest investment in memory, in particular when the TTree is; accessed remotely, e.g. via a high latency network. For each TTree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted.; The user can change the size of the cache with the TTree::SetCacheSize",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:2350,perform,performance,2350,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['perform'],['performance']
Performance," to facilitate the; // communication with other non ROOT applications. Currently; // writing and reading XML files is limited to ROOT applications.; // It is our intention to develop a simple reader independent; // of the ROOT libraries that could be used as an example for; // real applications. One of possible approach with code generation; // is implemented in TXMLPlayer class.; //; // The XML format should be used only for small data volumes,; // typically histogram files, pictures, geometries, calibrations.; // The XML file is built in memory before being dumped to disk.; //; // Like for normal ROOT files, XML files use the same I/O mechanism; // exploiting the ROOT/CINT dictionary. Any class having a dictionary; // can be saved in XML format.; //; // This first implementation does not support subdirectories; // or Trees.; //; // The shared library libRXML.so may be loaded dynamically; // via gSystem->Load(""libRXML""). This library is automatically; // loaded by the plugin manager as soon as a XML file is created; // via, eg; // TFile::Open(""file.xml"",""recreate"");; // TFile::Open returns a TXMLFile object. When a XML file is open in write mode,; // one can use the normal TObject::Write to write an object in the file.; // Alternatively one can use the new functions TDirectoryFile::WriteObject and; // TDirectoryFile::WriteObjectAny to write a TObject* or any class not deriving; // from TObject.; //; // example of a session saving a histogram to a XML file; // =====================================================; // TFile *f = TFile::Open(""Example.xml"",""recreate"");; // TH1F *h = new TH1F(""h"",""test"",1000,-2,2);; // h->FillRandom(""gaus"");; // h->Write();; // delete f;; //; // example of a session reading the histogram from the file; // ========================================================; // TFile *f = TFile::Open(""Example.xml"");; // TH1F *h = (TH1F*)f->Get(""h"");; // h->Draw();; //; // A new option in the canvas ""File"" menu is available to save; // a TCanvas as a ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/xml/src/TXMLFile.cxx:1564,load,loaded,1564,io/xml/src/TXMLFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/xml/src/TXMLFile.cxx,1,['load'],['loaded']
Performance," to prevent a; /// forbidden slot hazard, offset of some branches may go out of range. In that; /// case it is necessary to check again if there is some branch that needs; /// expansion. On the other hand, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce haza",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:1955,load,load,1955,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,1,['load'],['load']
Performance," value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a location, and emit; /// DBG_VALUE instructions specifying those locations. Variable locations may; /// be dropped in this process due to the desired variable value not being; /// resident in any machine location, or because there is no PHI value in any; /// location that accurately represents the desired value. The building of; /// location lists for each block is left to DbgEntityHistoryCalculator.; ///; /// This pass is kept efficient because the size of the first SSA problem; /// is proportional to the working-set size of the function, which the compiler; /// tries to keep small. (It's also proportional to the number of blocks).; /// Additionally, we repeatedly perform the second SSA problem analysis with; /// only the variables and blocks in a single lexical scope, exploiting their; /// locality.; ///; /// ### Terminology; ///; /// A machine location is a register or spill slot, a value is something that's; /// defined by an instruction or PHI node, while a variable value is the value; /// assigned to a variable. A variable location is a machine location, that must; /// contain the appropriate variable value. A value that is a PHI node is; /// occasionally called an mphi.; ///; /// The first SSA problem is the ""machine value location"" problem,; /// because we're determining which machine locations contain which values.; /// The ""locations"" are constant: what's unknown is what value they contain.; ///; /// The second SSA problem (the one for variables) is the ""variable value; /// problem"", because it's determining what values a variable has, rather than; /// what location those values are placed in.; ///; /// TODO:; /// Overlapping fragments; /// Entry values; /// Add back DEBUG statements for",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3175,perform,perform,3175,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['perform'],['perform']
Performance," when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of; memory for a sliding window when Z_FINISH is used. If a preset dictionary is needed after this call (see inflateSetDictionary; below), inflate sets strm->adler to the Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its computed adler32; checksum is equal to that saved by the compressor and returns Z_STREAM_END; only if the checksum is correct. inflate() can decompress and check either zlib-wrapped or gzip-wrapped; deflate data. The header type is detected automatically, if requested when; initializing with inflateInit2(). Any information contained in the gzip; header is not retained, so applications that need that information should; instead use raw inflate, see inflateInit2() below, or inflateBack() and; perform their own processing of the gzip header and trailer. When processing; gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output; producted so far. The CRC-32 is checked against the gzip trailer. inflate() returns Z_OK if some progress has been made (more input processed; or more output produced), Z_STREAM_END if the end of the compressed data has; been reached and all uncompressed output has been produced, Z_NEED_DICT if a; preset dictionary is needed at this point, Z_DATA_ERROR if the input data was; corrupted (input stream not conforming to the zlib format or incorrect check; value), Z_STREAM_ERROR if the stream structure was inconsistent (for example; next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,; Z_BUF_ERROR if no progress is possible or if there was not enough room in the; output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and; inflate() ca",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:5787,perform,perform,5787,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['perform'],['perform']
Performance," will; * send with 'send_back_task_result_from_worker' and 'update_state': the first; * part of the message must always be the 'Job''s ID, stored in 'Job::id'.; * The rest of the message, i.e. the actual data to be sent, is completely up; * to the implementation. Note that on the receiving end, i.e. in the; * implementation of 'receive_task_result_on_master', one will get the whole; * message, but the 'Job' ID part will already have been identified in the; * 'JobManager', so one needn't worry about it further inside; * 'Job::receive_task_result_on_master' (it is already routed to the correct; * 'Job'). The same goes for the receiving end of 'update_state', except that; * update_state is routed from the 'worker_loop', not the 'JobManager'.; *; * A second rule applies to 'update_state' messages: the second part must be; * a state identifier. This identifier will also be sent along with tasks to; * the queue. When a worker then takes a task from the queue, it can check; * whether it has already updated its state to what is expected to be there; * for the task at hand. If not, it should wait for the new state to arrive; * over the state subscription socket. Note: it is the implementer's task to; * actually update 'Job::state_id_' inside 'Job::update_state()'!; *; * ## Implementers notes; *; * The type of result from each task is strongly dependent on the Job at hand; * and so Job does not provide a default results member. It is up to the; * inheriting class to implement this in the above functions. We would have; * liked a template parameter task_result_t, so that we could also provide a; * default ""boilerplate"" calculate function to show a typical Job use-case of; * all the above infrastructure. This is not trivial, because the JobManager; * has to keep a list of Job pointers, so if there would be different template; * instantiations of Jobs, this would complicate this list.; *; * A typical Job implementation will have an evaluation function that is; * called from the ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Job.cxx:2138,queue,queue,2138,roofit/multiprocess/src/Job.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Job.cxx,1,['queue'],['queue']
Performance,""""""" cppyy_backend loader; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/loader.py:18,load,loader,18,bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/loader.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/loader.py,1,['load'],['loader']
Performance,""""""". <div id=""{jsDivId}"" style=""width: {jsCanvasWidth}px; height: {jsCanvasHeight}px; position: relative"">; </div>. <script>. function display_{jsDivId}(Core) {{; let obj = Core.parse({jsonContent});; Core.settings.HandleKeys = false;; Core.draw(""{jsDivId}"", obj, ""{jsDrawOptions}"");; }}. function script_load_{jsDivId}(src, on_error) {{; let script = document.createElement('script');; script.src = src;; script.onload = function() {{ display_{jsDivId}(JSROOT); }};; script.onerror = function() {{ script.remove(); on_error(); }};; document.head.appendChild(script);; }}. if (typeof requirejs !== 'undefined') {{. // We are in jupyter notebooks, use require.js which should be configured already; requirejs.config({{; paths: {{ 'JSRootCore' : [ 'build/jsroot', 'https://root.cern/js/7.7.4/build/jsroot', 'https://jsroot.gsi.de/7.7.4/build/jsroot' ] }}; }})(['JSRootCore'], function(Core) {{; display_{jsDivId}(Core);; }});. }} else if (typeof JSROOT !== 'undefined') {{. // JSROOT already loaded, just use it; display_{jsDivId}(JSROOT);. }} else {{. // We are in jupyterlab without require.js, directly loading jsroot; // Jupyterlab might be installed in a different base_url so we need to know it.; try {{; var base_url = JSON.parse(document.getElementById('jupyter-config-data').innerHTML).baseUrl;; }} catch(_) {{; var base_url = '/';; }}. // Try loading a local version of requirejs and fallback to cdn if not possible.; script_load_{jsDivId}(base_url + 'static/build/jsroot.js', function(){{; console.error('Fail to load JSROOT locally, please check your jupyter_notebook_config.py file');; script_load_{jsDivId}('https://root.cern/js/7.7.4/build/jsroot.js', function(){{; document.getElementById(""{jsDivId}"").innerHTML = ""Failed to load JSROOT"";; }});; }});; }}. </script>; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/jupyroot/python/JupyROOT/helpers/utils.py:990,load,loaded,990,bindings/jupyroot/python/JupyROOT/helpers/utils.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/jupyroot/python/JupyROOT/helpers/utils.py,5,['load'],"['load', 'loaded', 'loading']"
Performance,"""""""; # Load results of the analyzes from a given output folder.; # - info is the SingleRunInfo object; # - delete_empty specifies if the empty plist files should be deleted. """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:7,Load,Load,7,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,1,['Load'],['Load']
Performance,"""""""; <html>; <title>{}</title>; <meta charset=""utf-8"" />; <head>; <link rel='stylesheet' type='text/css' href='style.css'>; <script type=""text/javascript"">; /* Simple helper to show/hide the expanded message of a remark. */; function toggleExpandedMessage(e) {{; var FullTextElems = e.parentElement.parentElement.getElementsByClassName(""full-info"");; if (!FullTextElems || FullTextElems.length < 1) {{; return false;; }}; var FullText = FullTextElems[0];; if (FullText.style.display == 'none') {{; e.innerHTML = '-';; FullText.style.display = 'block';; }} else {{; e.innerHTML = '+';; FullText.style.display = 'none';; }}; }}; </script>; </head>; <body>; <div class=""centered"">; <table class=""source"">; <thead>; <tr>; <th style=""width: 2%"">Line</td>; <th style=""width: 3%"">Hotness</td>; <th style=""width: 10%"">Optimization</td>; <th style=""width: 70%"">Source</td>; <th style=""width: 15%"">Inline Context</td>; </tr>; </thead>; <tbody>""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt-viewer/opt-viewer.py:810,Optimiz,Optimization,810,interpreter/llvm-project/llvm/tools/opt-viewer/opt-viewer.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt-viewer/opt-viewer.py,1,['Optimiz'],['Optimization']
Performance,"""""""; A class that can be used to portably generate formatted output to; a terminal. `TerminalController` defines a set of instance variables whose; values are initialized to the control sequence necessary to; perform a given action. These can be simply included in normal; output to the terminal:. >>> term = TerminalController(); >>> print('This is '+term.GREEN+'green'+term.NORMAL). Alternatively, the `render()` method can used, which replaces; '${action}' with the string required to perform 'action':. >>> term = TerminalController(); >>> print(term.render('This is ${GREEN}green${NORMAL}')). If the terminal doesn't support a given action, then the value of; the corresponding instance variable will be set to ''. As a; result, the above code will still work on terminals that do not; support color, except that their output will not be colored.; Also, this means that you can test whether the terminal supports a; given action by simply testing the truth value of the; corresponding instance variable:. >>> term = TerminalController(); >>> if term.CLEAR_SCREEN:; ... print('This terminal supports clearning the screen.'). Finally, if the width and height of the terminal are known, then; they will be stored in the `COLS` and `LINES` attributes.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/ProgressBar.py:209,perform,perform,209,interpreter/llvm-project/llvm/utils/lit/lit/ProgressBar.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/ProgressBar.py,2,['perform'],['perform']
Performance,"""""""; Adds info about friend trees to the input chain. Also aligns the; starting and ending entry of the friend chain cache to those of the; main chain.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py:117,cache,cache,117,bindings/experimental/distrdf/python/DistRDF/HeadNode.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py,2,['cache'],['cache']
Performance,"""""""; Apply substitutions to the script. Allow full regular expression syntax.; Replace each matching occurrence of regular expression pattern a with; substitution b in line ln. If a substitution expands into another substitution, it is expanded; recursively until the line has no more expandable substitutions. If; the line can still can be substituted after being substituted; `recursion_limit` times, it is an error. If the `recursion_limit` is; `None` (the default), no recursive substitution is performed at all.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:499,perform,performed,499,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['perform'],['performed']
Performance,"""""""; CmpRuns - A simple tool for comparing two static analyzer runs to determine; which reports have been added, removed, or changed. This is designed to support automated testing using the static analyzer, from; two perspectives:; 1. To monitor changes in the static analyzer's reports on real code bases,; for regression testing. 2. For use by end users who want to integrate regular static analyzer testing; into a buildbot like environment. Usage:. # Load the results of both runs, to obtain lists of the corresponding; # AnalysisDiagnostic objects.; #; resultsA = load_results_from_single_run(singleRunInfoA, delete_empty); resultsB = load_results_from_single_run(singleRunInfoB, delete_empty). # Generate a relation from diagnostics in run A to diagnostics in run B; # to obtain a list of triples (a, b, confidence).; diff = compare_results(resultsA, resultsB). """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:455,Load,Load,455,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,1,['Load'],['Load']
Performance,"""""""; Custom loader for modules under the ROOT namespace.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/__init__.py:12,load,loader,12,bindings/pyroot/pythonizations/python/ROOT/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/__init__.py,1,['load'],['loader']
Performance,"""""""; Executes an RDataFrame computation graph on a distributed backend. The needed ingredients are:. - A collection of logical ranges in which the dataset is split. Each; range is going to be assigned to a distributed task.; - A representation of the computation graph that the task needs to; execute.; - A way to generate an RDataFrame instance starting from the logical; range of the task.; - Optionally, some setup code to be run at the beginning of each task. These are used as inputs to a generic mapper function. Results from the; various mappers are then reduced and the final results are retrieved in; the local session. These are properly handled to perform extra checks,; depending on the data source. Finally, the local user-facing nodes are; filled with the values that were computed distributedly so that they; can be accessed in the application like with local RDataFrame.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py:659,perform,perform,659,bindings/experimental/distrdf/python/DistRDF/HeadNode.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py,1,['perform'],['perform']
Performance,"""""""; Generate a template for the RBatchGenerator based on the given; RDataFrame and columns. Args:; file_name (str): name of the root file.; tree_name (str): name of the tree in the root file.; columns (list[str]): Columns that should be loaded.; Defaults to loading all columns; in the given RDataFrame; max_vec_sizes (list[int]): The length of each vector based column. Returns:; template (str): Template for the RBatchGenerator; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py:238,load,loaded,238,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,2,['load'],"['loaded', 'loading']"
Performance,"""""""; Given the path to a test in the test suite, generates the Lit tests associated; to that path. There can be zero, one or more tests. For example, some testing; formats allow expanding a single path in the test suite into multiple Lit tests; (e.g. they are generated on the fly). Note that this method is only used when Lit needs to actually perform test; discovery, which is not the case for configs with standalone tests.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/formats/base.py:345,perform,perform,345,interpreter/llvm-project/llvm/utils/lit/lit/formats/base.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/formats/base.py,1,['perform'],['perform']
Performance,"""""""; LLDB Formatters for LLVM data types. Load into LLDB with 'command script import /path/to/lldbDataFormatters.py'; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lldbDataFormatters.py:42,Load,Load,42,interpreter/llvm-project/llvm/utils/lldbDataFormatters.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lldbDataFormatters.py,1,['Load'],['Load']
Performance,"""""""; Perform initial setup steps common to every mapper function.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Base.py:5,Perform,Perform,5,bindings/experimental/distrdf/python/DistRDF/Backends/Base.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Base.py,1,['Perform'],['Perform']
Performance,"""""""; Performs map-reduce using Dask framework. Args:; ranges (list): A list of ranges to be processed.; mapper (function): A function that runs the computational graph; and returns a list of values. reducer (function): A function that merges two lists that were; returned by the mapper. Returns:; list: A list representing the values of action nodes returned; after computation (Map-Reduce).; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py:5,Perform,Performs,5,bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,1,['Perform'],['Performs']
Performance,"""""""; Performs map-reduce using Spark framework. Args:; mapper (function): A function that runs the computational graph; and returns a list of values. reducer (function): A function that merges two lists that were; returned by the mapper. Returns:; list: A list representing the values of action nodes returned; after computation (Map-Reduce).; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Spark/Backend.py:5,Perform,Performs,5,bindings/experimental/distrdf/python/DistRDF/Backends/Spark/Backend.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Spark/Backend.py,1,['Perform'],['Performs']
Performance,"""""""; Performs real-time map-reduce using Dask framework, retrieving the partial results ; as soon as they are available, allowing real-time data representation. Args:; ranges (list): A list of ranges to be processed. mapper (function): A function that runs the computational graph; and returns a list of values. reducer (function): A function that merges two lists that were; returned by the mapper. drawables_info_dict (dict): A dictionary where keys are plot object IDs ; and values are tuples containing optional callback functions, ; index of the plot object, and operation name. Returns:; merged_results (TaskResult): The merged result of the computation.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py:5,Perform,Performs,5,bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,1,['Perform'],['Performs']
Performance,"""""""; Reduction function of the ROOT facade to customize the (pickle); serialization step. Defines the ingredients needed for a correct serialization of the; facade, that is a function that imports a Python module and the name of; that module, which corresponds to this facade's __name__ attribute. This; method helps serialization tools like `cloudpickle`, especially used in; distributed environments, that always need to include information about; the ROOT module in the serialization step. For example, the following; snippet would not work without this method::. import ROOT; import cloudpickle. def foo():; return ROOT.TH1F(). cloudpickle.loads(cloudpickle.dumps(foo)). In particular, it would raise::. TypeError: cannot pickle 'ROOTFacade' object; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_facade.py:644,load,loads,644,bindings/pyroot/pythonizations/python/ROOT/_facade.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_facade.py,1,['load'],['loads']
Performance,"""""""; Remove the computation graph identified by the input argument from the; cache.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py:77,cache,cache,77,bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,1,['cache'],['cache']
Performance,"""""""; Retrieves the concrete RDataFrame operation to be performed by; querying the 'parent_rdf_node'. Forces lazyness on any operation, so; they can be all chained before triggering the actual computation. Returns; both the call to the RDataFrame operation and the operation itself, which; are then needed when creating the list of result promises to return from; the mapper task.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/ComputationGraphGenerator.py:55,perform,performed,55,bindings/experimental/distrdf/python/DistRDF/ComputationGraphGenerator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/ComputationGraphGenerator.py,1,['perform'],['performed']
Performance,"""""""; Return two Tensorflow Datasets based on the given ROOT file and tree; The first generator returns training batches, while the second generator; returns validation batches. Args:; tree_name (str): Name of the tree in the ROOT file; file_name (str): Path to the ROOT file; batch_size (int): Size of the returned chunks.; chunk_size (int):; The size of the chunks loaded from the ROOT file. Higher chunk size; results in better randomization, but also higher memory usage.; columns (list[str], optional):; Columns to be returned. If not given, all columns are used.; filters (list[str], optional):; Filters to apply. If not given, no filters are applied.; max_vec_sizes (list[int], optional):; Size of each column that consists of vectors.; Required when using vector based columns; target (str, optional):; Column that is used as target.; weights (str, optional):; Column used to weight events.; Can only be used when a target is given; validation_split (float, optional):; The ratio of batches being kept for validation.; Value has to be from 0.0 to 1.0. Defaults to 0.0.; max_chunks (int, optional):; The number of chunks that should be loaded for an epoch.; If not given, the whole file is used; shuffle (bool):; randomize the training batches every epoch. Defaults to True. Returns:; Tuple[TrainRBatchGenerator, ValidationRBatchGenerator]:; Two generators are returned. One used to load training batches,; and one to load validation batches. NOTE: the validation batches; are loaded during the training. Before training, the validation; generator will return no batches.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py:366,load,loaded,366,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,10,['load'],"['load', 'loaded']"
Performance,"""""""; Return two batch generators based on the given ROOT file and tree.; The first generator returns training batches, while the second generator; returns validation batches. Args:; tree_name (str): Name of the tree in the ROOT file; file_name (str): Path to the ROOT file; batch_size (int): Size of the returned chunks.; chunk_size (int):; The size of the chunks loaded from the ROOT file. Higher chunk size; results in better randomization, but also higher memory usage.; columns (list[str], optional):; Columns to be returned. If not given, all columns are used.; filters (list[str], optional):; Filters to apply. If not given, no filters are applied.; max_vec_sizes (list[int], optional):; Size of each column that consists of vectors.; Required when using vector based columns; target (str, optional):; Column that is used as target.; weights (str, optional):; Column used to weight events.; Can only be used when a target is given; validation_split (float, optional):; The ratio of batches being kept for validation.; Value has to be from 0.0 to 1.0. Defaults to 0.0.; max_chunks (int, optional):; The number of chunks that should be loaded for an epoch.; If not given, the whole file is used; shuffle (bool):; randomize the training batches every epoch. Defaults to True. Returns:; Tuple[TrainRBatchGenerator, ValidationRBatchGenerator]:; Two generators are returned. One used to load training batches,; and one to load validation batches. NOTE: the validation batches; are loaded during the training. Before training, the validation; generator will return no batches.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py:364,load,loaded,364,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,5,['load'],"['load', 'loaded']"
Performance,"""""""; Run all tests of this class sequentially.; The tests of this class rely on the current directory, which can be changed; unpredictably if they are run concurrently.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/tcontext_contextmanager.py:155,concurren,concurrently,155,bindings/pyroot/pythonizations/test/tcontext_contextmanager.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/tcontext_contextmanager.py,1,['concurren'],['concurrently']
Performance,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:162,perform,performance,162,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,2,"['Perform', 'perform']","['Performance', 'performance']"
Performance,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:719,Cache,CachedSource,719,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,9,['Cache'],['CachedSource']
Performance,"""""""; TDirectoryFile inherits from TDirectory the pythonized attr syntax (__getattr__); and WriteObject method.; On the other side, the Get() method is pythonised only in TDirectoryFile.; Thus, the situation is now the following:. 1) __getattr__ : TDirectory --> TDirectoryFile --> TFile; 1.1) caches the returned object for future attempts; 1.2) raises AttributeError if object not found. 2) Get() : TDirectoryFile --> TFile; 2.1) does not cache the returned object; 2.2 returns nullptr if object not found; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tdirectoryfile.py:293,cache,caches,293,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tdirectoryfile.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tdirectoryfile.py,2,['cache'],"['cache', 'caches']"
Performance,"""""""; Test libraries loaded after importing ROOT; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/import_load_libs.py:20,load,loaded,20,bindings/pyroot/pythonizations/test/import_load_libs.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/import_load_libs.py,1,['load'],['loaded']
Performance,"""""""; Test which libraries are loaded during importing ROOT; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/import_load_libs.py:30,load,loaded,30,bindings/pyroot/pythonizations/test/import_load_libs.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/import_load_libs.py,1,['load'],['loaded']
Performance,"""""""; This script:; - Builds clang with user-defined flags; - Uses that clang to build an instrumented clang, which can be used to collect; PGO samples; - Builds a user-defined set of sources (default: clang) to act as a; ""benchmark"" to generate a PGO profile; - Builds clang once more with the PGO profile generated above. This is a total of four clean builds of clang (by default). This may take a; while. :). This scripts duplicates https://llvm.org/docs/AdvancedBuilds.html#multi-stage-pgo; Eventually, it will be updated to instead call the cmake cache mentioned there.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/collect_and_build_with_pgo.py:551,cache,cache,551,interpreter/llvm-project/llvm/utils/collect_and_build_with_pgo.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/collect_and_build_with_pgo.py,1,['cache'],['cache']
Performance,"""""""; Trigger the computation graph. The list of actions to be performed is retrieved by calling; generate_computation_graph. Afterwards, the C++ RDF computation graph is; triggered through the `ROOT::Internal::RDF::TriggerRun` function with; the GIL released. Args:; graph: A representation of the computation graph. starting_node: The node where the generation of the; computation graph is started. Either an actual RDataFrame or the; result of a Range operation (in case of empty data source). range_id: The id of the current range. Needed to assign a; file name to a partial Snapshot if it was requested. Returns:; list: A list of objects that can be either used as or converted into; mergeable values.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/ComputationGraphGenerator.py:62,perform,performed,62,bindings/experimental/distrdf/python/DistRDF/ComputationGraphGenerator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/ComputationGraphGenerator.py,1,['perform'],['performed']
Performance,"""""""; Trigger the execution of multiple RDataFrame computation graphs on a certain; distributed backend. If the backend doesn't support multiple job; submissions concurrently, the distributed computation graphs will be; executed sequentially. Args:; proxies(list): List of action proxies that should be triggered. Only; actions belonging to different RDataFrame graphs will be; triggered to avoid useless calls. Return:; (int): The number of unique computation graphs executed by this call. Example:. @code{.py}; import ROOT; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; RunGraphs = ROOT.RDF.Experimental.Distributed.RunGraphs. # Create 3 different dataframes and book an histogram on each one; histoproxies = [; RDataFrame(100); .Define(""x"", ""rdfentry_""); .Histo1D((""name"", ""title"", 10, 0, 100), ""x""); for _ in range(4); ]. # Execute the 3 computation graphs; n_graphs_run = RunGraphs(histoproxies); # Retrieve all the histograms in one go; histos = [histoproxy.GetValue() for histoproxy in histoproxies]; @endcode. """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/__init__.py:161,concurren,concurrently,161,bindings/experimental/distrdf/python/DistRDF/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/__init__.py,1,['concurren'],['concurrently']
Performance,"""""""; When performing a distributed Snapshot we return an object holding the name; of the dataset and the path to the partial snapshot. We can directly return; the object, no extra work needed.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Utils.py:10,perform,performing,10,bindings/experimental/distrdf/python/DistRDF/Backends/Utils.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Utils.py,1,['perform'],['performing']
Performance,"""""""; load_from_path(path, litConfig). Load the configuration module at the provided path into the given config; object.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestingConfig.py:38,Load,Load,38,interpreter/llvm-project/llvm/utils/lit/lit/TestingConfig.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestingConfig.py,1,['Load'],['Load']
Performance,"""""""; namespace RefTest {; class DotVector{; private:; std::vector<long>* a;; std::vector<long>* b;. public:; long g = 0;; long *res = &g;; DotVector(std::vector<long>* i, std::vector<long>* j) : a(i), b(j) {}. long self_dot_product() {; long result = 0;; size_t size = a->size(); // Cache the vector size; const long* data_a = a->data();; const long* data_b = b->data();. for (size_t i = 0; i < size; ++i) {; result += data_a[i] * data_b[i];; }; return result;; }. long dot_product(const std::vector<long>& vec1, const std::vector<long>& vec2) {; long result = 0;; for (size_t i = 0; i < vec1.size(); ++i) {; result += vec1[i] * vec2[i];; }; return result;; }; };; }""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_numba.py:283,Cache,Cache,283,bindings/pyroot/cppyy/cppyy/test/test_numba.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_numba.py,1,['Cache'],['Cache']
Performance,"""""""; template <typename Enum>; struct my_iter_enum {; struct iterator {; using value_type = Enum;; using difference_type = ptrdiff_t;; using reference = const Enum&;; using pointer = const Enum*;; using iterator_category = std::input_iterator_tag;. iterator(Enum value) : cur(value) {}. reference operator*() { return cur; }; pointer operator->() { return &cur; }; bool operator==(const iterator& other) { return cur == other.cur; }; bool operator!=(const iterator& other) { return !(*this == other); }; iterator& operator++() { if (cur != Enum::Unknown) cur = static_cast<Enum>(static_cast<std::underlying_type_t<Enum>>(cur) + 1); return *this; }; iterator operator++(int) { iterator other = *this; ++(*this); return other; }. private:; Enum cur;; int TODO_why_is_this_placeholder_needed; // JIT error? Too aggressive optimization?; };. iterator begin() {; return iterator(Enum::Black);; }. iterator end() {; return iterator(Enum::Unknown);; }; };. enum class MyColorEnum : char {; Black = 1,; Blue,; Red,; Yellow,; Unknown; };""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_regression.py:819,optimiz,optimization,819,bindings/pyroot/cppyy/cppyy/test/test_regression.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_regression.py,1,['optimiz'],['optimization']
Performance,"""""""Check CFC - Check Compile Flow Consistency. This is a compiler wrapper for testing that code generation is consistent with; different compilation processes. It checks that code is not unduly affected by; compiler options or other changes which should not have side effects. To use:; -Ensure that the compiler under test (i.e. clang, clang++) is on the PATH; -On Linux copy this script to the name of the compiler; e.g. cp check_cfc.py clang && cp check_cfc.py clang++; -On Windows use setup.py to generate check_cfc.exe and copy that to clang.exe; and clang++.exe; -Enable the desired checks in check_cfc.cfg (in the same directory as the; wrapper); e.g.; [Checks]; dash_g_no_change = true; dash_s_no_change = false. -The wrapper can be run using its absolute path or added to PATH before the; compiler under test; e.g. export PATH=<path to check_cfc>:$PATH; -Compile as normal. The wrapper intercepts normal -c compiles and will return; non-zero if the check fails.; e.g.; $ clang -c test.cpp; Code difference detected with -g; --- /tmp/tmp5nv893.o; +++ /tmp/tmp6Vwjnc.o; @@ -1 +1 @@; - 0: 48 8b 05 51 0b 20 00 mov 0x200b51(%rip),%rax; + 0: 48 39 3d 51 0b 20 00 cmp %rdi,0x200b51(%rip). -To run LNT with Check CFC specify the absolute path to the wrapper to the --cc; and --cxx options; e.g.; lnt runtest nt --cc <path to check_cfc>/clang \\; --cxx <path to check_cfc>/clang++ ... To add a new check:; -Create a new subclass of WrapperCheck; -Implement the perform_check() method. This should perform the alternate compile; and do the comparison.; -Add the new check to check_cfc.cfg. The check has the same name as the; subclass.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:1497,perform,perform,1497,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,1,['perform'],['perform']
Performance,"""""""Clear the caches in between tests.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/test_graph_caching.py:13,cache,caches,13,bindings/experimental/distrdf/test/backend/test_graph_caching.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/test_graph_caching.py,1,['cache'],['caches']
Performance,"""""""Explicitly load a shared library.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py:14,load,load,14,bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py,1,['load'],['load']
Performance,"""""""Extract IR for training. Extract IR for training, either from a compile_commands.json file produced by; cmake, or a linker parameter list file. Only run with; 'python compiler_opt/tools/extract_ir.py ...'. The compilation is assumed to have been performed with clang, using; -fembed-bitcode=all passed to cc1 (i.e. pass clang -Xclang=-fembed-bitcode=all). In a distributed ThinLTO case, the compilation is assumed to have been performed; specifying -mllvm -lto-embed-bitcode=post-merge-pre-opt. In a local ThinLTO case, the compilation is assumedto have been performed; specifying -Wl,--save-temps=import -Wl,--thinlto-emit-index-files. To change the logging verbosity, pass an integer representing the desired; verbosity to the --verbosity flag. Use 0 for all logs, status information,; and detailed debug information, -1 for solely warnings, and -2 to not produce; any output.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/mlgo-utils/mlgo/corpus/extract_ir.py:249,perform,performed,249,interpreter/llvm-project/llvm/utils/mlgo-utils/mlgo/corpus/extract_ir.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/mlgo-utils/mlgo/corpus/extract_ir.py,3,['perform'],['performed']
Performance,"""""""Extracts all specified object files into the corpus directory. Args:; objs: A list of TrainingIRExtractor Objects that represent the object files; to extract bitcode/commands from.; num_workers: The number of parallel processes to spawn to run the; extraction.; llvm_objcopy_path: The path to the llvm-objcopy to use for dumping sections.; cmd_filter: A regular expression that is used to select for compilations; performed with specific flags. If you want to include all compilations,; set this to None.; thinlto_build: Whether or not this is a ThinLTO build, and if so, the type.; Set this to None if the build was not done with ThinLTO.; cmd_section_name: The name of the command line section created by the; bitcode embedding.; bitcode_section_name: The name of the bitcode section created by the; bitcode embedding.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/mlgo-utils/mlgo/corpus/extract_ir_lib.py:417,perform,performed,417,interpreter/llvm-project/llvm/utils/mlgo-utils/mlgo/corpus/extract_ir_lib.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/mlgo-utils/mlgo/corpus/extract_ir_lib.py,1,['perform'],['performed']
Performance,"""""""Generate HTML output to visualize optimization records from the YAML files; generated with -fsave-optimization-record and -fdiagnostics-show-hotness. The tools requires PyYAML and Pygments Python packages.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt-viewer/opt-viewer.py:37,optimiz,optimization,37,interpreter/llvm-project/llvm/tools/opt-viewer/opt-viewer.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt-viewer/opt-viewer.py,2,['optimiz'],"['optimization', 'optimization-record']"
Performance,"""""""Generate statistics about optimization records from the YAML files; generated with -fsave-optimization-record and -fdiagnostics-show-hotness. The tools requires PyYAML and Pygments Python packages.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt-viewer/opt-stats.py:29,optimiz,optimization,29,interpreter/llvm-project/llvm/tools/opt-viewer/opt-stats.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt-viewer/opt-stats.py,2,['optimiz'],"['optimization', 'optimization-record']"
Performance,"""""""Get the code that do_execute should use, taking into account; the code from any cached cells. Returns the code to compile and the arguments to use to do so. >>> k._previous_code = """"; >>> k._previous_magic = {}; >>> k.get_code_and_args(""""); ('', []); >>> k.get_code_and_args(""%args 1\\nSome code""); ('Some code', ['1']); >>> k.get_code_and_args(""%args 2\\nSome more code""); ('Some code\\nSome more code', ['2']); >>> k.get_code_and_args(""%reset\\n%args 3 4\\nSome new code""); ('Some new code', ['3', '4']); >>> k.get_code_and_args(""%reset\\nSome new code""); ('Some new code', []); """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_kernel/kernel.py:83,cache,cached,83,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_kernel/kernel.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_kernel/kernel.py,1,['cache'],['cached']
Performance,"""""""If this is the first run, search for llvm-tblgen.; Otherwise return the cached path to it.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_kernel/kernel.py:75,cache,cached,75,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_kernel/kernel.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_kernel/kernel.py,1,['cache'],['cached']
Performance,"""""""Injection of TDirectory.__getitem__ that raises AttributeError on failure. Method that is assigned to TDirectory.__getitem__. It relies on Get to; obtain the object from the TDirectory and adds on top:; - Raising an AttributeError if the object does not exist; - Caching the result of a successful get for future re-attempts.; Once cached, the same object is retrieved every time.; This pythonisation is inherited by TDirectoryFile and TFile. Example:; ```; myfile.mydir.mysubdir.myHist.Draw(); ```; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tdirectory.py:335,cache,cached,335,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tdirectory.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tdirectory.py,1,['cache'],['cached']
Performance,"""""""Kernel using llvm-tblgen inside jupyter. All input is treated as TableGen unless the first non whitespace character; is ""%"" in which case it is a ""magic"" line. The supported cell magic is:; * %args - to set the arguments passed to llvm-tblgen.; * %reset - to reset the cached code and magic state.; * %noreset - to not reset the cached code and magic state; (useful when you have changed the default to always; reset the cache). These are ""cell magic"" meaning it applies to the whole cell. Therefore; it must be the first line, or part of a run of magic lines starting; from the first line. The following are global magic (that applies to all cells going; forward):; * %config - to change the behaviour of the kernel overall, including; changing defaults for things like resets. Global magic must be written in the same way as cell magic. ```tablgen; %args; %reset; %args --print-records --print-detailed-records; class Stuff {; string Name;; }. def a_thing : Stuff {}; ```. """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_kernel/kernel.py:272,cache,cached,272,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_kernel/kernel.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_kernel/kernel.py,3,['cache'],"['cache', 'cached']"
Performance,"""""""Load (and JIT) header file <header> into Cling.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py:3,Load,Load,3,bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py,2,['Load'],['Load']
Performance,"""""""Loading external checkers using the clang plugin interface.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:3,Load,Loading,3,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,1,['Load'],['Loading']
Performance,"""""""Loads cmake options from a file to a dictionary""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/.github/workflows/root-ci-config/build_utils.py:3,Load,Loads,3,.github/workflows/root-ci-config/build_utils.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/.github/workflows/root-ci-config/build_utils.py,1,['Load'],['Loads']
Performance,"""""""Numba-JITing of a method that performs scalar addition to a std::vector initialised through pointers """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_numba.py:33,perform,performs,33,bindings/pyroot/cppyy/cppyy/test/test_numba.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_numba.py,1,['perform'],['performs']
Performance,"""""""Override this to perform the modified compilation and required; checks.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:20,perform,perform,20,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,1,['perform'],['perform']
Performance,"""""""Perform cross translation unit (ctu) analysis (both collect; and analyze phases) using default <ctu-dir> for temporary output.; At the end of the analysis, the temporary directory is removed.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:3,Perform,Perform,3,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,1,['Perform'],['Perform']
Performance,"""""""Perform only the analyze phase of ctu. <ctu-dir> should be; present and will not be removed after analysis.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:3,Perform,Perform,3,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,1,['Perform'],['Perform']
Performance,"""""""Perform only the collect phase of ctu.; Keep <ctu-dir> for further use.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:3,Perform,Perform,3,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,1,['Perform'],['Perform']
Performance,"""""""Read-out the RDataFrame as a collection of numpy arrays. The values of the dataframe are read out as numpy array of the respective type; if the type is a fundamental type such as float or int. If the type of the column; is a complex type, such as your custom class or a std::array, the returned numpy; array contains Python objects of this type interpreted via PyROOT. Be aware that reading out custom types is much less performant than reading out; fundamental types, such as int or float, which are supported directly by numpy. The reading is performed in multiple threads if the implicit multi-threading of; ROOT is enabled. Note that this is an instant action of the RDataFrame graph and will trigger the; event-loop. Parameters:; columns: If None return all branches as columns, otherwise specify names in iterable.; exclude: Exclude branches from selection.; lazy: Determines whether this action is instant (False, default) or lazy (True). Returns:; dict or AsNumpyResult: if instant (default), dict with column names as keys and; 1D numpy arrays with content as values; if lazy, AsNumpyResult containing; the result pointers obtained from the Take actions.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_rdataframe.py:424,perform,performant,424,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_rdataframe.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_rdataframe.py,3,"['multi-thread', 'perform']","['multi-threading', 'performant', 'performed']"
Performance,"""""""Return true if we should reset the cache, based on the default; setting and the current cell's magic %reset and/or %noreset. >>> k._cell_reset = False; >>> k.should_reset({}); False; >>> k.should_reset({'reset': [], 'noreset': []}); Traceback (most recent call last):; ...; TableGenKernelException: %reset and %noreset in the same cell is not allowed. Use only one, or neither.; >>> k.should_reset({'reset': []}); True; >>> k.should_reset({'noreset': []}); False; >>> k._cell_reset = True; >>> k.should_reset({}); True; >>> k.should_reset({'reset': [], 'noreset': []}); Traceback (most recent call last):; ...; TableGenKernelException: %reset and %noreset in the same cell is not allowed. Use only one, or neither.; >>> k.should_reset({'reset': []}); True; >>> k.should_reset({'noreset': []}); False; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_kernel/kernel.py:38,cache,cache,38,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_kernel/kernel.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_kernel/kernel.py,1,['cache'],['cache']
Performance,"""""""Specify absolute or relative path Clang pcm file to be loaded; The pcm file (module) produced by this invocation of rootcling; will not include any of the declarations already included in the; pcm files loaded via -m. There can be more than one -m; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling-argparse.py:58,load,loaded,58,core/dictgen/src/rootcling-argparse.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling-argparse.py,2,['load'],['loaded']
Performance,"""""""Specify libraries needed by the header files parsed; This feature is used by ACliC (the automatic library generator).; Rootcling will read the content of xxx.in for a list of rootmap files (see; rlibmap). Rootcling will read these files and use them to deduce a list of; libraries that are needed to properly link and load this dictionary. This; list of libraries is saved in the first line of the file xxx.out; the; remaining lines contains the list of classes for which this run of; rootcling produced a dictionary; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling-argparse.py:321,load,load,321,core/dictgen/src/rootcling-argparse.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling-argparse.py,1,['load'],['load']
Performance,"""""""Start the loading of batches and Yield the results. Yields:; Union[np.NDArray, torch.Tensor]: A batch of data; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py:13,load,loading,13,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,1,['load'],['loading']
Performance,"""""""Start the loading of training batches""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py:13,load,loading,13,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,1,['load'],['loading']
Performance,"""""""Stop the loading of batches""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py:12,load,loading,12,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,1,['load'],['loading']
Performance,"""""""Test failure to load dictionary""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_fragile.py:19,load,load,19,bindings/pyroot/cppyy/cppyy/test/test_fragile.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_fragile.py,1,['load'],['load']
Performance,"""""""Test whether loading a dictionary twice results in the same object""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_pythonify.py:16,load,loading,16,bindings/pyroot/cppyy/cppyy/test/test_pythonify.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_pythonify.py,1,['load'],['loading']
Performance,"""""""The cache is used to Snapshot data.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/test_graph_caching.py:7,cache,cache,7,bindings/experimental/distrdf/test/backend/test_graph_caching.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/test_graph_caching.py,1,['cache'],['cache']
Performance,"""""""The cache is used to count entries of a TChain.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/test_graph_caching.py:7,cache,cache,7,bindings/experimental/distrdf/test/backend/test_graph_caching.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/test_graph_caching.py,1,['cache'],['cache']
Performance,"""""""The cache is used to count entries of a TTree.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/test_graph_caching.py:7,cache,cache,7,bindings/experimental/distrdf/test/backend/test_graph_caching.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/test_graph_caching.py,1,['cache'],['cache']
Performance,"""""""The cache is used to count entries with an empty source.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/test_graph_caching.py:7,cache,cache,7,bindings/experimental/distrdf/test/backend/test_graph_caching.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/test_graph_caching.py,1,['cache'],['cache']
Performance,"""""""The caches are used with multiple executions.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/test_graph_caching.py:7,cache,caches,7,bindings/experimental/distrdf/test/backend/test_graph_caching.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/test_graph_caching.py,1,['cache'],['caches']
Performance,"""""""Wrapper around the Cpp RBatchGenerator. Args:; tree_name (str): Name of the tree in the ROOT file; file_name (str): Path to the ROOT file; batch_size (int): Size of the returned chunks.; chunk_size (int):; The size of the chunks loaded from the ROOT file. Higher chunk; size results in better randomization, but higher memory usage.; columns (list[str], optional):; Columns to be returned. If not given, all columns are used.; filters (list[str], optional):; Filters to apply during loading. If not given, no filters; are applied.; max_vec_sizes (dict[std, int], optional):; Size of each column that consists of vectors.; Required when using vector based columns.; vec_padding (int):; Value to pad vectors with if the vector is smaller; than the given max vector length. Defaults is 0; target (str, optional): Column that is used as target.; weights (str, optional):; Column used to weight events.; Can only be used when a target is given.; validation_split (float, optional):; The ratio of batches being kept for validation.; Value has to be between 0 and 1. Defaults to 0.0.; max_chunks (int, optional):; The number of chunks that should be loaded for an epoch.; If not given, the whole file is used.; shuffle (bool):; Batches consist of random events and are shuffled every epoch.; Defaults to True.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py:232,load,loaded,232,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,3,['load'],"['loaded', 'loading']"
Performance,"""""""Writes a corpus_manifest.json containing all necessary information about; the corpus. Args:; thinlto_build: Whether or not the build was done with ThinLTO and if so,; what kind of ThinLTO. Set this to none if the build was not performed with; ThinLTO.; relative_output_paths: The relative (to the corpus directory) output paths; of all the bitcode files that should be placed in the corpus manifest; output_dir: The corpus directory where the corpus manifest should be; placed.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/mlgo-utils/mlgo/corpus/extract_ir_lib.py:230,perform,performed,230,interpreter/llvm-project/llvm/utils/mlgo-utils/mlgo/corpus/extract_ir_lib.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/mlgo-utils/mlgo/corpus/extract_ir_lib.py,1,['perform'],['performed']
Performance,"""""""\; <script language=""javascript"" type=""text/javascript"">; function load(url) {; if (window.XMLHttpRequest) {; req = new XMLHttpRequest();; } else if (window.ActiveXObject) {; req = new ActiveXObject(""Microsoft.XMLHTTP"");; }; if (req != undefined) {; req.open(""GET"", url, true);; req.send("""");; }; }; </script>""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py:70,load,load,70,interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,1,['load'],['load']
Performance,"""""""\; namespace Numba {{; /*; * C++ wrapper function around the jitted Python wrapping which calls the jitted Python callable; */; {RETURN_TYPE} {FUNC_NAME}({INPUT_SIGNATURE}) {{; // Create a function pointer from the jitted Python wrapper; const auto funcptr = reinterpret_cast<{FUNC_PTR_TYPE}>({FUNC_PTR});; // Perform conversion of RVec<bool>; {VECBOOL_CONVERSION}; // Return the result; {RETURN_OP}; }}; }}""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_numbadeclare.py:313,Perform,Perform,313,bindings/pyroot/pythonizations/python/ROOT/_numbadeclare.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_numbadeclare.py,1,['Perform'],['Perform']
Performance,"""""""finish() - Finish this config object, after loading is complete.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestingConfig.py:47,load,loading,47,interpreter/llvm-project/llvm/utils/lit/lit/TestingConfig.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestingConfig.py,1,['load'],['loading']
Performance,"""""""getTestSuite(item, litConfig, cache) -> (suite, relative_path). Find the test suite containing @arg item. @retval (None, ...) - Indicates no test suite contains @arg item.; @retval (suite, relative_path) - The suite that @arg item is in, and its; relative path inside that suite.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/discovery.py:33,cache,cache,33,interpreter/llvm-project/llvm/utils/lit/lit/discovery.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/discovery.py,1,['cache'],['cache']
Performance,"""""""load_config(config, path) - Load a config object from an alternate; path.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/LitConfig.py:31,Load,Load,31,interpreter/llvm-project/llvm/utils/lit/lit/LitConfig.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/LitConfig.py,1,['Load'],['Load']
Performance,"# --- Perform extended ML fit of composite PDF to toy data ---",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/rs601_HLFactoryexample.py:6,Perform,Perform,6,tutorials/roostats/rs601_HLFactoryexample.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/rs601_HLFactoryexample.py,1,['Perform'],['Perform']
Performance,"# ----- Evaluate and compare performance of all configured MVAs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_RNN_Classification.py:29,perform,performance,29,tutorials/tmva/TMVA_RNN_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_RNN_Classification.py,1,['perform'],['performance']
Performance,"# A TFile might be storing references to objects retrieved by the user in; # a cache. Make sure the cache is cleaned at exit time rather than having; # to wait for the garbage collector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tfile.py:79,cache,cache,79,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tfile.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tfile.py,2,['cache'],['cache']
Performance,"# A cache of the furthest-back position in any block list of the first; # instance of each block, indexed by the block itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/update_mca_test_checks.py:4,cache,cache,4,interpreter/llvm-project/llvm/utils/update_mca_test_checks.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/update_mca_test_checks.py,1,['cache'],['cache']
Performance,"# A first order correction to estimated parameter errors in an; # (unbinned) ML fit can be obtained by calculating the; # covariance matrix as; #; # V' = V C-1 V; #; # where V is the covariance matrix calculated from a fit; # to -logL = - sum [ w_i log f(x_i) ] and C is the covariance; # matrix calculated from -logL' = -sum [ w_i^2 log f(x_i) ]; # (i.e. the weights are applied squared); #; # A fit in self mode can be performed as follows:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf403_weightedevts.py:421,perform,performed,421,tutorials/roofit/rf403_weightedevts.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf403_weightedevts.py,1,['perform'],['performed']
Performance,"# Alternatively, you can specify only the number of bins and the range if your; # binning is uniform. This is preferred over passing the full list of bin; # edges, because RooFit will know that the binning is uniform and do some; # optimizations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf409_NumPyPandasToRooFit.py:232,optimiz,optimizations,232,tutorials/roofit/rf409_NumPyPandasToRooFit.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf409_NumPyPandasToRooFit.py,1,['optimiz'],['optimizations']
Performance,# Avoid freeing our giant cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:26,cache,cache,26,interpreter/llvm-project/clang/utils/token-delta.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py,1,['cache'],['cache']
Performance,"# Build cache of commonly used python strings (the cache is python intern, so; # all strings are shared python-wide, not just in PyROOT).; # See: https://docs.python.org/3.2/library/sys.html?highlight=sys.intern#sys.intern",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/__init__.py:8,cache,cache,8,bindings/pyroot/pythonizations/python/ROOT/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/__init__.py,2,['cache'],['cache']
Performance,# Cache for doxygen urls we have already verified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/dump_ast_matchers.py:2,Cache,Cache,2,interpreter/llvm-project/clang/docs/tools/dump_ast_matchers.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/dump_ast_matchers.py,1,['Cache'],['Cache']
Performance,"# Calculate error using sampling method and visualize as dashed red line.; #; # In self method a number of curves is calculated with variations of the parameter values, sampled; # from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; # The error(x) is determined by calculating a central interval that capture N% of the variations; # for each value of x, N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; # is chosen to be such that at least 100 curves are expected to be outside the N% interval, is minimally; # 100 (e.g. Z=1.Ncurve=356, Z=2.Ncurve=2156)) Intervals from the sampling method can be asymmetric,; # and may perform better in the presence of strong correlations, may take; # (much) longer to calculate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf610_visualerror.py:690,perform,perform,690,tutorials/roofit/rf610_visualerror.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf610_visualerror.py,1,['perform'],['perform']
Performance,"# Check that the loaded libraries are white listed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/import_load_libs.py:17,load,loaded,17,bindings/pyroot/pythonizations/test/import_load_libs.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/import_load_libs.py,1,['load'],['loaded']
Performance,"# Cleanup the current execution artifacts from the caches on the workers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py:51,cache,caches,51,bindings/experimental/distrdf/python/DistRDF/HeadNode.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py,1,['cache'],['caches']
Performance,"# Configure convolution to construct a 2-D cache in (x,mean); # rather than a 1-d cache in mean that needs to be recalculated; # for each value of x",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf211_paramconv.py:43,cache,cache,43,tutorials/roofit/rf211_paramconv.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf211_paramconv.py,2,['cache'],['cache']
Performance,"# Construct loss function and Optimizer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/generatePyTorchModelClassification.py:30,Optimiz,Optimizer,30,tmva/pymva/test/generatePyTorchModelClassification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/generatePyTorchModelClassification.py,6,['Optimiz'],['Optimizer']
Performance,"# Context that activates and deactivates the loading thread of the Cpp class; # This ensures that the thread will always be deleted properly",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py:45,load,loading,45,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,1,['load'],['loading']
Performance,# Copy the cached source and apply any patches to the copy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:11,cache,cached,11,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,1,['cache'],['cached']
Performance,"# Create a ROOT dataframe for each dataset; # Note that we load the filenames from the external json file placed in the same folder than this script.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df105_WBosonAnalysis.py:59,load,load,59,tutorials/dataframe/df105_WBosonAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df105_WBosonAnalysis.py,3,['load'],['load']
Performance,"# Create manager; # ---------------------------; # Configure manager to perform binned extended likelihood fits (Binned=True, Extended=True) on data generated; # with a Poisson fluctuation on Nobs (Extended=True)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf803_mcstudy_addons2.py:72,perform,perform,72,tutorials/roofit/rf803_mcstudy_addons2.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf803_mcstudy_addons2.py,1,['perform'],['perform']
Performance,"# Create, save or load workspace with pdf; # -----------------------------------------------------------------------------------; #; # Mode = 0 : Create workspace for plain running (no integral caching); # Mode = 1 : Generate workspace with precalculated integral and store it on file; # Mode = 2 : Load previously stored workspace from file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf903_numintcache.py:18,load,load,18,tutorials/roofit/rf903_numintcache.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf903_numintcache.py,2,"['Load', 'load']","['Load', 'load']"
Performance,"# Define a new column with the invariant mass and perform final event selection",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df104_HiggsToTwoPhotons.py:50,perform,perform,50,tutorials/dataframe/df104_HiggsToTwoPhotons.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df104_HiggsToTwoPhotons.py,2,['perform'],['perform']
Performance,# Define a wrapper function which is marked 'optnone' to prevent; # interprocedural optimizations from deleting the test.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/shuffle_fuzz.py:84,optimiz,optimizations,84,interpreter/llvm-project/llvm/utils/shuffle_fuzz.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/shuffle_fuzz.py,1,['optimiz'],['optimizations']
Performance,"# Destroy member functions cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/hsimple.py:27,cache,cache,27,tutorials/pyroot/hsimple.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/hsimple.py,2,['cache'],['cache']
Performance,"# Enable Multi-threaded mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df106_HiggsToFourLeptons.py:9,Multi-thread,Multi-threaded,9,tutorials/dataframe/df106_HiggsToFourLeptons.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df106_HiggsToFourLeptons.py,1,['Multi-thread'],['Multi-threaded']
Performance,"# Enable multi-threading",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df102_NanoAODDimuonAnalysis.py:9,multi-thread,multi-threading,9,tutorials/dataframe/df102_NanoAODDimuonAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df102_NanoAODDimuonAnalysis.py,4,['multi-thread'],['multi-threading']
Performance,"# Enable thread safety for the whole mapper function. We need to do; # this since two tasks could be invoking the C++ interpreter; # simultaneously, given that this function will release the GIL; # before calling into C++ to run the event loop. Dask multi-threaded; # or even multi-process workers could trigger such a scenario.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Base.py:250,multi-thread,multi-threaded,250,bindings/experimental/distrdf/python/DistRDF/Backends/Base.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Base.py,1,['multi-thread'],['multi-threaded']
Performance,"# Encode reference value for parameters in workspace; # ---------------------------------------------------------------------------------------------------; # Define a parameter 'snapshot' in the p.d.f.; # Unlike a named set, parameter snapshot stores an independent set of values for; # a given set of variables in the workspace. The values can be stored and reloaded; # into the workspace variable objects using the loadSnapshot() and saveSnapshot(); # methods. A snapshot saves the value of each variable, errors that are stored; # with it as well as the 'Constant' flag that is used in fits to determine if a; # parameter is kept fixed or not.; # Do a dummy fit to a (supposedly) reference dataset here and store the results; # of that fit into a snapshot",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf510_wsnamedsets.py:418,load,loadSnapshot,418,tutorials/roofit/rf510_wsnamedsets.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf510_wsnamedsets.py,1,['load'],['loadSnapshot']
Performance,"# Evaluate pdf once to trigger filling of cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf903_numintcache.py:42,cache,cache,42,tutorials/roofit/rf903_numintcache.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf903_numintcache.py,1,['cache'],['cache']
Performance,"# Example of RooSimWSTool interface; # ------------------------------------------------------------------; # Introduce a flavour tagging category tagCat as observable with 4 states corresponding; # to 4 flavour tagging techniques with different performance that require different; # parameterizations of the fit model; #; # ROOT.RooSimWSTool operation:; # - Make 4 clones of model (for each tagCat) state, will gain an individual; # copy of parameters w, and biasC. The other parameters remain common; # - Make a simultaneous pdf of the 4 clones assigning each to the appropriate; # state of the tagCat index category; # ROOT.RooSimWSTool is interfaced as meta-type SIMCLONE in the factory. The $SplitParam(); # argument maps to the SplitParam() named argument in the; # ROOT.RooSimWSTool constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf513_wsfactory_tools.py:245,perform,performance,245,tutorials/roofit/rf513_wsfactory_tools.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf513_wsfactory_tools.py,1,['perform'],['performance']
Performance,"# FIXME: the blame cache could probably be made more effective still if; # instead of storing the requested base_revision in the cache, the last; # revision before the base revision this file/path got changed in gets; # stored. That way multiple project revisions for which this specific; # file/patch hasn't changed would get cache hits (instead of misses in; # the current implementation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/Reviewing/find_interesting_reviews.py:19,cache,cache,19,interpreter/llvm-project/llvm/utils/Reviewing/find_interesting_reviews.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/Reviewing/find_interesting_reviews.py,3,['cache'],['cache']
Performance,# Fetch the cached dependency data and check it against our formal ancestry; # data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/check_ninja_deps.py:12,cache,cached,12,interpreter/llvm-project/llvm/utils/check_ninja_deps.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/check_ninja_deps.py,1,['cache'],['cached']
Performance,"# Fill the cache with the future results",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/ComputationGraphGenerator.py:11,cache,cache,11,bindings/experimental/distrdf/python/DistRDF/ComputationGraphGenerator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/ComputationGraphGenerator.py,1,['cache'],['cache']
Performance,"# Fill the cache with the new RDataFrame",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py:11,cache,cache,11,bindings/experimental/distrdf/python/DistRDF/HeadNode.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py,2,['cache'],['cache']
Performance,"# Finally, you can perform any set of operations conveniently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/vecops/vo005_Combinations.py:19,perform,perform,19,tutorials/vecops/vo005_Combinations.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/vecops/vo005_Combinations.py,1,['perform'],['perform']
Performance,"# Fit full range; # -------------------------------------------; # Perform unbinned ML fit to data, full range; # IMPORTANT:; # The model needs to be copied when fitting with different ranges because; # the interpretation of the coefficients is tied to the fit range; # that's used in the first fit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf204a_extendedLikelihood.py:67,Perform,Perform,67,tutorials/roofit/rf204a_extendedLikelihood.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf204a_extendedLikelihood.py,1,['Perform'],['Perform']
Performance,"# Fit model to data; # ---------------------------------; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf606_nllerrorhandling.py:306,Perform,Perform,306,tutorials/roofit/rf606_nllerrorhandling.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf606_nllerrorhandling.py,1,['Perform'],['Perform']
Performance,"# Fit pdf to data, save fit result; # -------------------------------------------------------------; # Perform fit and save result",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf607_fitresult.py:103,Perform,Perform,103,tutorials/roofit/rf607_fitresult.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf607_fitresult.py,1,['Perform'],['Perform']
Performance,"# For speed, bind and cache the Fill member functions,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/hsimple.py:22,cache,cache,22,tutorials/pyroot/hsimple.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/hsimple.py,1,['cache'],['cache']
Performance,"# Get return value for loading the shared library.; # On succesful load the value will be 0.; # If the library does not exist or there was an error; # while loading, the value will be -1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Utils.py:23,load,loading,23,bindings/experimental/distrdf/python/DistRDF/Backends/Utils.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Utils.py,3,['load'],"['load', 'loading']"
Performance,"# Get with an argument loads a specific data point in row and returns; # a pointer to row argset. get() always returns the same pointer, unless; # an invalid row number is specified. In that case a null ptr is returned",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf402_datahandling.py:23,load,loads,23,tutorials/roofit/rf402_datahandling.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf402_datahandling.py,1,['load'],['loads']
Performance,"# Hard teardown: run part of the gROOT shutdown sequence.; # Running it here ensures that it is done before any ROOT libraries; # are off-loaded, with unspecified order of static object destruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/__init__.py:138,load,loaded,138,bindings/pyroot/pythonizations/python/ROOT/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/__init__.py,1,['load'],['loaded']
Performance,"# How we keep the NumPy arrays around as long as the RDataSource is alive:; #; # 1. Cache a container with references to the NumPy arrays in a global; # dictionary. Note that we use a copy of the original dict as the; # container, because otherwise the caller of _MakeNumpyDataFrame can; # invalidate our cache by mutating the np_dict after the call.; #; # 2. Together with the array data, store a deleter function to delete the; # cache element in the cache itself.; #; # 3. The C++ side gets a reference to the deleter function via; # std::function. Note that the C++ side can only get a non-owning; # reference to the Python function, which is the reason why we have to; # keep the deleter alive in the cache itself.; #; # 4. The RDataSource calls the deleter in its destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_rdataframe.py:84,Cache,Cache,84,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_rdataframe.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_rdataframe.py,5,"['Cache', 'cache']","['Cache', 'cache']"
Performance,"# However, if you want to compute operations on unique combinations of a; # single RVec, you can perform this as follows.; # Get the indices of unique triples for the given vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/vecops/vo005_Combinations.py:97,perform,perform,97,tutorials/vecops/vo005_Combinations.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/vecops/vo005_Combinations.py,1,['perform'],['perform']
Performance,"# If the .py version of rootlogon exists, the .C is ignored (the user can; # load the .C from the .py, if so desired).; # System logon, user logon, and local logon (skip Rint.Logon)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_facade.py:77,load,load,77,bindings/pyroot/pythonizations/python/ROOT/_facade.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_facade.py,1,['load'],['load']
Performance,"# If the we don't already have the cached source, run the project's; # download script to download it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:35,cache,cached,35,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,1,['cache'],['cached']
Performance,"# If this is a template, pythonize the instances. Note that in; # older cppyy, template instantiations are cached by; # fully-qualified name directly in the namespace, so they are; # covered by the code branch above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/__init__.py:107,cache,cached,107,bindings/pyroot/pythonizations/python/ROOT/_pythonization/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/__init__.py,1,['cache'],['cached']
Performance,"# Immediate pythonization should happen.; # Accesses classes are cached by cppyy using their class name as key in; # their namespace",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/pythonization_decorator.py:65,cache,cached,65,bindings/pyroot/pythonizations/test/pythonization_decorator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/pythonization_decorator.py,1,['cache'],['cached']
Performance,"# Immediate pythonization should happen.; # Instantiated templates are also tested because they are cached by; # cppyy using their fully-qualified name as key in their namespace",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/pythonization_decorator.py:100,cache,cached,100,bindings/pyroot/pythonizations/test/pythonization_decorator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/pythonization_decorator.py,1,['cache'],['cached']
Performance,"# It is important to have a double-ended queue because we need to; # traverse the nodes in different ways w.r.t. their insertion order.; # While pruning the graph, we need to check leaf nodes before their; # parents, so if a child is pruned then it also decrements the counter; # of children of its parent. Thus, we need a bottom-up traversal.; # While executing the graph in a task, we need to create the RDF nodes; # in the order the user requested them, e.g. starting from the; # RDataFrame itself, then calling its direct children, their children; # and so on. Thus, we need a top-down traversal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py:41,queue,queue,41,bindings/experimental/distrdf/python/DistRDF/HeadNode.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py,1,['queue'],['queue']
Performance,"# It may be that the interpreter (wether python or pypy-c) was not linked; # with C++; force its loading before doing anything else (note that not; # linking with C++ spells trouble anyway for any C++ libraries ...)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/_stdcpp_fix.py:97,load,loading,97,bindings/pyroot/cppyy/cppyy/python/cppyy/_stdcpp_fix.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/_stdcpp_fix.py,1,['load'],['loading']
Performance,"# Let's first define a new C++ class. In this tutorial, we will see how we can; # ""pythonize"" this class, i.e. how we can add some extra behaviour to it to; # make it more pythonic or easier to use from Python.; #; # Note: In this example, the class is defined dynamically for demonstration; # purposes, but it could also be a C++ class defined in some library or header.; # For more information about loading C++ user code to be used from Python with; # PyROOT, please see:; # https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/pyroot002_pythonizationDecorator.py:402,load,loading,402,tutorials/pyroot/pyroot002_pythonizationDecorator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/pyroot002_pythonizationDecorator.py,2,['load'],"['loading', 'loading-user-libraries-and-just-in-time-compilation-jitting']"
Performance,"# Load CMake options from .github/workflows/root-ci-config/buildconfig/[platform].txt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/.github/workflows/root-ci-config/build_root.py:2,Load,Load,2,.github/workflows/root-ci-config/build_root.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/.github/workflows/root-ci-config/build_root.py,1,['Load'],['Load']
Performance,# Load all of the input files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py:2,Load,Load,2,interpreter/llvm-project/clang/utils/perf-training/perf-helper.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py,1,['Load'],['Load']
Performance,"# Load data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/tmva101_Training.py:2,Load,Load,2,tutorials/tmva/tmva101_Training.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/tmva101_Training.py,12,['Load'],['Load']
Performance,"# Load dataset, filter the required events and define the training variables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/tmva100_DataPreparation.py:2,Load,Load,2,tutorials/tmva/tmva100_DataPreparation.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/tmva100_DataPreparation.py,1,['Load'],['Load']
Performance,# Load json file to retrieve results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/formats/googletest.py:2,Load,Load,2,interpreter/llvm-project/llvm/utils/lit/lit/formats/googletest.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/formats/googletest.py,1,['Load'],['Load']
Performance,"# Load preexisting workspace from file in mode==2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf903_numintcache.py:2,Load,Load,2,tutorials/roofit/rf903_numintcache.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf903_numintcache.py,1,['Load'],['Load']
Performance,# Load the config script data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestingConfig.py:2,Load,Load,2,interpreter/llvm-project/llvm/utils/lit/lit/TestingConfig.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestingConfig.py,1,['Load'],['Load']
Performance,# Load the tests from the inputs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/discovery.py:2,Load,Load,2,interpreter/llvm-project/llvm/utils/lit/lit/discovery.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/discovery.py,1,['Load'],['Load']
Performance,"# Load trained model",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/tmva102_Testing.py:2,Load,Load,2,tutorials/tmva/tmva102_Testing.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/tmva102_Testing.py,1,['Load'],['Load']
Performance,"# Make sure we don't do any redundant pythonization, e.g. if we; # use a version of cppyy that caches both in the namespace and; # in the _instantiations attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/__init__.py:95,cache,caches,95,bindings/pyroot/pythonizations/python/ROOT/_pythonization/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/__init__.py,1,['cache'],['caches']
Performance,"# Mode = 0 : Run plain fit (slow); # Mode = 1 : Generate workspace with precalculated integral and store it on file (prepare for accelerated running); # Mode = 2 : Run fit from previously stored workspace including cached; # integrals (fast, run in mode=1 first); # Create, save or load workspace with pdf; # -----------------------------------------------------------------------------------; # Make/load workspace, here in mode 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf903_numintcache.py:215,cache,cached,215,tutorials/roofit/rf903_numintcache.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf903_numintcache.py,3,"['cache', 'load']","['cached', 'load']"
Performance,"# Now the event loop on the cached dataset is triggered by accessing the histogram.; # This event triggers the loop on the `df` data frame lazily.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df019_Cache.py:28,cache,cached,28,tutorials/dataframe/df019_Cache.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df019_Cache.py,1,['cache'],['cached']
Performance,"# Now we want to plot 2 quarters of a ring with radii .5 and 1.; # Note how the cuts are performed on RVecs, comparing them with integers and; # among themselves.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df016_vecOps.py:89,perform,performed,89,tutorials/dataframe/df016_vecOps.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df016_vecOps.py,1,['perform'],['performed']
Performance,"# Operations on the dataframe; # We now review some *actions* which can be performed on the data frame.; # Actions can be divided into instant actions (e. g. Foreach()) and lazy; # actions (e. g. Count()), depending on whether they trigger the event ; # loop immediately or only when one of the results is accessed for the ; # first time. Actions that return ""something"" either return their result ; # wrapped in a RResultPtr or in a RDataFrame.; # But first of all, let us we define now our cut-flow with two strings.; # Filters can be expressed as strings. The content must be C++ code. The; # name of the variables must be the name of the branches. The code is; # just-in-time compiled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df001_introduction.py:75,perform,performed,75,tutorials/dataframe/df001_introduction.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df001_introduction.py,1,['perform'],['performed']
Performance,"# Optimize binary compression",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/cpt.py:2,Optimiz,Optimize,2,interpreter/cling/tools/packaging/cpt.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/cpt.py,1,['Optimiz'],['Optimize']
Performance,"# Otherwise, SetBranchAddress is expecting a pointer to the address of; # the object, and the pointer needs to stay alive. Therefore, we create; # a container for the pointer and cache it in the original cppyy proxy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_ttree.py:179,cache,cache,179,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_ttree.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_ttree.py,1,['cache'],['cache']
Performance,"# Otherwise, copy the current config and load the local configuration; # file into it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/discovery.py:41,load,load,41,interpreter/llvm-project/llvm/utils/lit/lit/discovery.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/discovery.py,1,['load'],['load']
Performance,"# Otherwise, load from the nested test suite, if present.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/discovery.py:13,load,load,13,interpreter/llvm-project/llvm/utils/lit/lit/discovery.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/discovery.py,1,['load'],['load']
Performance,"# Perform a fit to generate some tracing messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf506_msgservice.py:2,Perform,Perform,2,tutorials/roofit/rf506_msgservice.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf506_msgservice.py,2,['Perform'],['Perform']
Performance,"# Perform a fit:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf612_recoverFromInvalidParameters.py:2,Perform,Perform,2,tutorials/roofit/rf612_recoverFromInvalidParameters.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf612_recoverFromInvalidParameters.py,1,['Perform'],['Perform']
Performance,"# Perform a simultaneous fit; # ---------------------------------------------------; # Perform simultaneous fit of model to data and model_ctl to data_ctl",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf501_simultaneouspdf.py:2,Perform,Perform,2,tutorials/roofit/rf501_simultaneouspdf.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf501_simultaneouspdf.py,2,['Perform'],['Perform']
Performance,"# Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf606_nllerrorhandling.py:2,Perform,Perform,2,tutorials/roofit/rf606_nllerrorhandling.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf606_nllerrorhandling.py,1,['Perform'],['Perform']
Performance,"# Perform any extra checks that may be needed according to the; # type of the head node",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py:2,Perform,Perform,2,bindings/experimental/distrdf/python/DistRDF/HeadNode.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py,1,['Perform'],['Perform']
Performance,"# Perform chi2 fit to X +/- dX and Y +/- dY values; # ---------------------------------------------------------------------------------------; # Make fit function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf609_xychi2fit.py:2,Perform,Perform,2,tutorials/roofit/rf609_xychi2fit.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf609_xychi2fit.py,1,['Perform'],['Perform']
Performance,"# Perform chi2 fit to binned weighted dataset using sum-of-weights errors; #; # NB: Within the usual approximations of a chi2 fit, chi2 fit to weighted; # data using sum-of-weights-squared errors does give correct error; # estimates",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf403_weightedevts.py:2,Perform,Perform,2,tutorials/roofit/rf403_weightedevts.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf403_weightedevts.py,1,['Perform'],['Perform']
Performance,"# Perform fit and save fit result",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf610_visualerror.py:2,Perform,Perform,2,tutorials/roofit/rf610_visualerror.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf610_visualerror.py,1,['Perform'],['Perform']
Performance,"# Perform fit in SideBand2 region (ROOT.RooAddPdf coefficients will be; # interpreted in full range)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf312_multirangefit.py:2,Perform,Perform,2,tutorials/roofit/rf312_multirangefit.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf312_multirangefit.py,1,['Perform'],['Perform']
Performance,"# Perform fits in individual sideband regions; # -------------------------------------------------------------------------------------; # Perform fit in SideBand1 region (ROOT.RooAddPdf coefficients will be; # interpreted in full range)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf312_multirangefit.py:2,Perform,Perform,2,tutorials/roofit/rf312_multirangefit.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf312_multirangefit.py,2,['Perform'],['Perform']
Performance,"# Perform fits in joint sideband regions; # -----------------------------------------------------------------------------; # Now perform fit to joint 'L-shaped' sideband region 'SB1|SB2'; # (ROOT.RooAddPdf coefficients will be interpreted in full range)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf312_multirangefit.py:2,Perform,Perform,2,tutorials/roofit/rf312_multirangefit.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf312_multirangefit.py,2,"['Perform', 'perform']","['Perform', 'perform']"
Performance,"# Perform last minute fixes to the notebook, used for specific fixes needed by some tutorials",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/doxygen/converttonotebook.py:2,Perform,Perform,2,documentation/doxygen/converttonotebook.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/doxygen/converttonotebook.py,1,['Perform'],['Perform']
Performance,# Perform lit-like substitutions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UpdateTestChecks/common.py:2,Perform,Perform,2,interpreter/llvm-project/llvm/utils/UpdateTestChecks/common.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UpdateTestChecks/common.py,1,['Perform'],['Perform']
Performance,"# Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; # Use four processes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf603_multicpu.py:2,Perform,Perform,2,tutorials/roofit/rf603_multicpu.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf603_multicpu.py,1,['Perform'],['Perform']
Performance,"# Perform preselection of highly isolated leptons",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py:2,Perform,Perform,2,tutorials/dataframe/df107_SingleTopAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py,1,['Perform'],['Perform']
Performance,"# Perform preselection of jets",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py:2,Perform,Perform,2,tutorials/dataframe/df107_SingleTopAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py,1,['Perform'],['Perform']
Performance,# Perform test discovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/LitTestCase.py:2,Perform,Perform,2,interpreter/llvm-project/llvm/utils/lit/lit/LitTestCase.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/LitTestCase.py,1,['Perform'],['Perform']
Performance,"# Perform the fit using Minos to get the correct asymmetric uncertainties",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/histfactory/hf001_example.py:2,Perform,Perform,2,tutorials/histfactory/hf001_example.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/histfactory/hf001_example.py,1,['Perform'],['Perform']
Performance,"# Perform the plot",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/rs301_splot.py:2,Perform,Perform,2,tutorials/roostats/rs301_splot.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/rs301_splot.py,1,['Perform'],['Perform']
Performance,"# Perform the same type of error visualization on the background component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf610_visualerror.py:2,Perform,Perform,2,tutorials/roofit/rf610_visualerror.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf610_visualerror.py,1,['Perform'],['Perform']
Performance,"# Pretty printers for gdb; # \author: Stephan Hageboeck, CERN; # These pretty printers will make ROOT objects more readable when printed in gdb.; # If the pretty-printed output is not sufficient, one can always use ""print /r <object>""; # for raw printing.; #; # When a debug build is used, they will be installed next to the ROOT libraries.; # gdb will load them automatically if the auto-load-safe-path is set to ROOT's library directory.; # For this, one has to add `add-auto-load-safe-path <ROOT lib dir>` to .gdbinit; #; # If loaded successfully, typing `info pretty-printer` at the gdb prompt should list the; # printers registered at the end of this file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/gdbPrinters/libCore.so-gdb.py:353,load,load,353,misc/gdbPrinters/libCore.so-gdb.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/gdbPrinters/libCore.so-gdb.py,8,['load'],"['load', 'load-safe-path', 'loaded']"
Performance,"# Prevent potential optimization of the loop",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/rvec.py:20,optimiz,optimization,20,bindings/pyroot/pythonizations/test/rvec.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/rvec.py,1,['optimiz'],['optimization']
Performance,"# Print CMake cached config",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/.github/workflows/root-ci-config/build_root.py:14,cache,cached,14,.github/workflows/root-ci-config/build_root.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/.github/workflows/root-ci-config/build_root.py,1,['cache'],['cached']
Performance,"# Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; # The integrations corresponding to these projections are performed analytically; # by the MV Gaussian pdf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf608_fitresultaspdf.py:133,perform,performed,133,tutorials/roofit/rf608_fitresultaspdf.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf608_fitresultaspdf.py,1,['perform'],['performed']
Performance,"# Projection on x (always slow as 2D integral over Y, at fitted value of a; # is not cached)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf903_numintcache.py:85,cache,cached,85,tutorials/roofit/rf903_numintcache.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf903_numintcache.py,1,['cache'],['cached']
Performance,"# Retrieve values of the data and MC histograms in order to plot them.; # Draw cloned histograms to preserve graphics when original objects goes out of scope; # Note: GetValue() action operation is performed after all lazy actions of the RDF were defined first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df106_HiggsToFourLeptons.py:198,perform,performed,198,tutorials/dataframe/df106_HiggsToFourLeptons.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df106_HiggsToFourLeptons.py,1,['perform'],['performed']
Performance,# Return a cached dictionary for the arguments. The key for each entry is; # the argument key (e.g. 'Callee' for inlining remarks. The value is a; # list containing the value (e.g. for 'Callee' the function) and; # optionally a DebugLoc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt-viewer/optrecord.py:11,cache,cached,11,interpreter/llvm-project/llvm/tools/opt-viewer/optrecord.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt-viewer/optrecord.py,1,['cache'],['cached']
Performance,"# Return created or loaded workspace",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf903_numintcache.py:20,load,loaded,20,tutorials/roofit/rf903_numintcache.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf903_numintcache.py,1,['load'],['loaded']
Performance,"# Run the event loop and merge histograms of the respective processes; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df105_WBosonAnalysis.py:150,concurren,concurrently,150,tutorials/dataframe/df105_WBosonAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df105_WBosonAnalysis.py,3,['concurren'],['concurrently']
Performance,"# Run the event loop; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df104_HiggsToTwoPhotons.py:101,concurren,concurrently,101,tutorials/dataframe/df104_HiggsToTwoPhotons.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df104_HiggsToTwoPhotons.py,2,['concurren'],['concurrently']
Performance,"# RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df103_NanoAODHiggsAnalysis.py:79,concurren,concurrently,79,tutorials/dataframe/df103_NanoAODHiggsAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df103_NanoAODHiggsAnalysis.py,1,['concurren'],['concurrently']
Performance,"# Saving and loading from file; # -------------------------------------------------------; # Datasets can be persisted with ROOT I/O",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf402_datahandling.py:13,load,loading,13,tutorials/roofit/rf402_datahandling.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf402_datahandling.py,1,['load'],['loading']
Performance,"# Select events for the analysis and make histograms of the top mass; # Just-in-time compile custom helper function performing complex computations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py:116,perform,performing,116,tutorials/dataframe/df107_SingleTopAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py,1,['perform'],['performing']
Performance,"# Select events for the analysis; # Just-in-time compile custom helper function performing complex computations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df105_WBosonAnalysis.py:80,perform,performing,80,tutorials/dataframe/df105_WBosonAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df105_WBosonAnalysis.py,2,['perform'],['performing']
Performance,"# Set individual event weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeightExpression( ""weight"" );; # Apply additional cuts on the signal and background samples (can be different)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_CNN_Classification.py:233,load,loader,233,tutorials/tmva/TMVA_CNN_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_CNN_Classification.py,2,['load'],['loader']
Performance,"# Set loss and optimizer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/keras/ClassificationKeras.py:15,optimiz,optimizer,15,tutorials/tmva/keras/ClassificationKeras.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/keras/ClassificationKeras.py,4,['optimiz'],['optimizer']
Performance,"# Setup the connection to Spark; # First create a dictionary with keys representing Spark specific configuration; # parameters. In this tutorial we use the following configuration parameters:; #; # 1. spark.app.name: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; # Create a SparkConf object with all the desired Spark configuration parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/distrdf001_spark_connection.py:572,concurren,concurrent,572,tutorials/dataframe/distrdf001_spark_connection.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/distrdf001_spark_connection.py,1,['concurren'],['concurrent']
Performance,"# Setup toy study with model; # ---------------------------------------------------; # Perform toy study with internal constraint on f",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf804_mcstudy_constr.py:87,Perform,Perform,87,tutorials/roofit/rf804_mcstudy_constr.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf804_mcstudy_constr.py,1,['Perform'],['Perform']
Performance,"# Show plot of cached integral values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf903_numintcache.py:15,cache,cached,15,tutorials/roofit/rf903_numintcache.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf903_numintcache.py,1,['cache'],['cached']
Performance,"# Start from a fresh cache at each subtest iteration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/test_graph_caching.py:21,cache,cache,21,bindings/experimental/distrdf/test/backend/test_graph_caching.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/test_graph_caching.py,5,['cache'],['cache']
Performance,"# Submit all computation graphs concurrently from multiple Python threads.; # The submission is not computationally intensive",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/__init__.py:32,concurren,concurrently,32,bindings/experimental/distrdf/python/DistRDF/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/__init__.py,1,['concurren'],['concurrently']
Performance,"# TODO: namespaces aren't loaded (and thus not added to sys.modules); # with just the from ... import statement; actual use is needed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_fragile.py:26,load,loaded,26,bindings/pyroot/cppyy/cppyy/test/test_fragile.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_fragile.py,1,['load'],['loaded']
Performance,"# TODO: numba_extensions will load all extensions even if the package; # itself is not otherwise imported, just installed; in the case of cppyy,; # that is currently too heavy (and breaks on conda); #entry_points={; # 'numba_extensions': [; # 'init = cppyy.numba_ext:_init_extension',; # ],; #},",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/setup.py:30,load,load,30,bindings/pyroot/cppyy/cppyy/setup.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/setup.py,1,['load'],['load']
Performance,"# TODO: the following only works if something else has already; # loaded the headers associated with this template",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_templates.py:66,load,loaded,66,bindings/pyroot/cppyy/cppyy/test/test_templates.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_templates.py,1,['load'],['loaded']
Performance,"# TODO: the following relies on the fact that numba will first lower the; # field access, then immediately lower the call; and that the `val` loads; # the struct representing the C++ object. Neither need be stable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/numba_ext.py:142,load,loads,142,bindings/pyroot/cppyy/cppyy/python/cppyy/numba_ext.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/numba_ext.py,1,['load'],['loads']
Performance,"# TODO: this emits a warning: Maybe you need to load the corresponding shared library?; # cling JIT session error: Failed to materialize symbols: ... emplace_back; # Despite the warning, the result is correct; # spec.WithGlobalFriends([(""subTree1"", ""PYspecTestFile5.root""),; # (""subTree2"", ""PYspecTestFile6.root""),; # (""subTree"", ""PYspecTestFile4.root"")], ""friendChainN"")",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.py:48,load,load,48,tree/dataframe/test/dataframe_datasetspec.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.py,1,['load'],['load']
Performance,# TODO:; # - We could optimize based on the knowledge that when splitting a failed; # partition into two and one side checks out okay then we can deduce that; # the other partition must be a failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/abtest.py:22,optimiz,optimize,22,interpreter/llvm-project/llvm/utils/abtest.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/abtest.py,1,['optimiz'],['optimize']
Performance,"# The ROOT.RooClassFactory.makePdfInstance() function performs code writing, compiling, linking; # and object instantiation in one go and can serve as a straight; # replacement of ROOT.RooGenericPdf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf104_classfactory.py:54,perform,performs,54,tutorials/roofit/rf104_classfactory.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf104_classfactory.py,1,['perform'],['performs']
Performance,"# The basename for the epub file. It defaults to the project name.; #epub_basename = project; # The HTML theme for the epub output. Since the default themes are not optimized; # for small screen space, using the same theme for HTML and epub output is; # usually not wise. This defaults to 'epub', a theme designed to save visual; # space.; #epub_theme = 'epub'; # The language of the text. It defaults to the language option; # or 'en' if the language is not set.; #epub_language = ''; # The scheme of the identifier. Typical schemes are ISBN or URL.; #epub_scheme = ''; # The unique identifier of the text. This can be a ISBN number; # or the project homepage.; #epub_identifier = ''; # A unique identification for the text.; #epub_uid = ''; # A tuple containing the cover image and cover page html template filenames.; #epub_cover = (); # A sequence of (type, uri, title) tuples for the guide element of content.opf.; #epub_guide = (); # HTML files that should be inserted before the pages created by sphinx.; # The format is a list of tuples containing the path and title.; #epub_pre_files = []; # HTML files shat should be inserted after the pages created by sphinx.; # The format is a list of tuples containing the path and title.; #epub_post_files = []; # A list of files that should not be packed into the epub file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/conf.py:165,optimiz,optimized,165,bindings/pyroot/cppyy/cppyy/doc/source/conf.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/conf.py,1,['optimiz'],['optimized']
Performance,# The default cache reset behaviour. True means do not cache anything; # between cells.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_kernel/kernel.py:14,cache,cache,14,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_kernel/kernel.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_kernel/kernel.py,2,['cache'],['cache']
Performance,"# The global module index does not have RVec entities preloaded and; # gInterpreter.Declare is not allowed to load libROOTVecOps for RVec.; # Preload the library now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/numbadeclare.py:110,load,load,110,bindings/pyroot/pythonizations/test/numbadeclare.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/numbadeclare.py,1,['load'],['load']
Performance,"# The global module index does not have it preloaded and; # gInterpreter.Declare is not allowed to load libPhysics for; # TLorentzVector. Preload the library now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/rdataframe_asnumpy.py:99,load,load,99,bindings/pyroot/pythonizations/test/rdataframe_asnumpy.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/rdataframe_asnumpy.py,1,['load'],['load']
Performance,"# The inverse operation of the dictonary-related memory optimization in; # _reduce_memory_dict. E.g.; # (('DebugLoc', (('File', ...) ... ))) -> [{'DebugLoc': {'File': ...} ....}]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt-viewer/optrecord.py:56,optimiz,optimization,56,interpreter/llvm-project/llvm/tools/opt-viewer/optrecord.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt-viewer/optrecord.py,1,['optimiz'],['optimization']
Performance,"# The name of the directory containing the source code that will be analyzed.; # Each time a project is analyzed, a fresh copy of its CachedSource directory; # will be copied to the PatchedSource directory and then the local patches; # in PATCHFILE_NAME will be applied (if PATCHFILE_NAME exists).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:134,Cache,CachedSource,134,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,1,['Cache'],['CachedSource']
Performance,"# The name of the directory storing the cached project source. If this; # directory does not exist, the download script will be executed.; # That script should create the ""CachedSource"" directory and download the; # project source into it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:40,cache,cached,40,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,2,"['Cache', 'cache']","['CachedSource', 'cached']"
Performance,# The name of the patchfile specifying any changes that should be applied; # to the CachedSource before analyzing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:84,Cache,CachedSource,84,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,1,['Cache'],['CachedSource']
Performance,# There is no reason to cache successful tests because we will; # always reduce the changeset when we see one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:24,cache,cache,24,interpreter/llvm-project/clang/utils/token-delta.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py,1,['cache'],['cache']
Performance,"# There should be exactly one cached RDF and set of actions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/test_graph_caching.py:30,cache,cached,30,bindings/experimental/distrdf/test/backend/test_graph_caching.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/test_graph_caching.py,4,['cache'],['cached']
Performance,# This data is no longer needed but keeping it around causes awful; # performance problems while the test suites run.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/discovery.py:70,perform,performance,70,interpreter/llvm-project/llvm/utils/lit/lit/discovery.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/discovery.py,1,['perform'],['performance']
Performance,"# This is a private builtin parameter which can be used to perform; # translation of configuration paths. Specifically, this parameter; # can be set to a dictionary that the discovery process will consult; # when it finds a configuration it is about to load. If the given; # path is in the map, the value of that key is a path to the; # configuration to load instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/discovery.py:59,perform,perform,59,interpreter/llvm-project/llvm/utils/lit/lit/discovery.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/discovery.py,3,"['load', 'perform']","['load', 'perform']"
Performance,"# This is the way to force load of MathMore in Cling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/math/tStudent.py:27,load,load,27,tutorials/math/tStudent.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/math/tStudent.py,1,['load'],['load']
Performance,# This lock will be used to protect concurrent access; # to _procs and _doneKillPass,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:36,concurren,concurrent,36,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['concurren'],['concurrent']
Performance,"# This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf614_binned_fit_problems.py:425,perform,performance,425,tutorials/roofit/rf614_binned_fit_problems.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf614_binned_fit_problems.py,1,['perform'],['performance']
Performance,"# Try:; # - in the global namespace; # - in the ROOT namespace; # - in gROOT (ROOT lists such as list of files,; # memory mapped files, functions, geometries ecc.); # The first two attempts allow to lookup; # e.g. ROOT.ROOT.Math as ROOT.Math; # Note that hasattr caches the lookup for getattr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_facade.py:263,cache,caches,263,bindings/pyroot/pythonizations/python/ROOT/_facade.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_facade.py,1,['cache'],['caches']
Performance,# Tune logging level.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:2,Tune,Tune,2,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,1,['Tune'],['Tune']
Performance,"# Upgrade v3 to v4; # Load notebook string into json format, essentially creating a dictionary",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/doxygen/converttonotebook.py:22,Load,Load,22,documentation/doxygen/converttonotebook.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/doxygen/converttonotebook.py,1,['Load'],['Load']
Performance,"# WVE Add reduction by range; # Binned (RooDataHist) and unbinned datasets (RooDataSet) share; # many properties and inherit from a common abstract base class; # (RooAbsData), provides an interface for all operations; # that can be performed regardless of the data format",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf402_datahandling.py:232,perform,performed,232,tutorials/roofit/rf402_datahandling.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf402_datahandling.py,1,['perform'],['performed']
Performance,"# We cache the content of the dataset. Nothing has happened yet: the work to accomplish; # has been described.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df019_Cache.py:5,cache,cache,5,tutorials/dataframe/df019_Cache.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df019_Cache.py,1,['cache'],['cache']
Performance,# We did fetch all records. Mark the cache to contain all info since; # the start of time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/Reviewing/find_interesting_reviews.py:37,cache,cache,37,interpreter/llvm-project/llvm/utils/Reviewing/find_interesting_reviews.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/Reviewing/find_interesting_reviews.py,1,['cache'],['cache']
Performance,"# We found a test suite, create a new config for it and load it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/discovery.py:56,load,load,56,interpreter/llvm-project/llvm/utils/lit/lit/discovery.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/discovery.py,1,['load'],['load']
Performance,"# We're only interested in this dependency if it's a *generated*; # file, i.e. it is in our set of targets. Also, we must check that; # currtarget is actually a target we know about: the dependency; # cache is not cleared when build.ninja changes, so it can contain; # stale data from targets that existed only in past builds in the; # same directory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/check_ninja_deps.py:201,cache,cache,201,interpreter/llvm-project/llvm/utils/check_ninja_deps.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/check_ninja_deps.py,1,['cache'],['cache']
Performance,"# b/c cached",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_datatypes.py:6,cache,cached,6,bindings/pyroot/cppyy/cppyy/test/test_datatypes.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_datatypes.py,1,['cache'],['cached']
Performance,"# bool columns should be taken as unsigned chars, because NumPy stores; # bools in bytes - different from the std::vector<bool> returned by the; # action, which might do some space optimization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_rdataframe.py:181,optimiz,optimization,181,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_rdataframe.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_rdataframe.py,1,['optimiz'],['optimization']
Performance,"# cached lookup",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_pythonify.py:2,cache,cached,2,bindings/pyroot/cppyy/cppyy/test/test_pythonify.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_pythonify.py,1,['cache'],['cached']
Performance,"# check that object is not cached initially",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/tdirectoryfile_attrsyntax_get.py:27,cache,cached,27,bindings/pyroot/pythonizations/test/tdirectoryfile_attrsyntax_get.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/tdirectoryfile_attrsyntax_get.py,3,['cache'],['cached']
Performance,"# check that the cached value in is actually the object; # inside the directory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/tdirectory_attrsyntax.py:17,cache,cached,17,bindings/pyroot/pythonizations/test/tdirectory_attrsyntax.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/tdirectory_attrsyntax.py,1,['cache'],['cached']
Performance,"# different templates used to prevent memoization caches resolving calls",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_templates.py:50,cache,caches,50,bindings/pyroot/cppyy/cppyy/test/test_templates.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_templates.py,1,['cache'],['caches']
Performance,"# extra optimization flags for Cling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/setup.py:8,optimiz,optimization,8,bindings/pyroot/cppyy/cppyy-backend/cling/setup.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/setup.py,1,['optimiz'],['optimization']
Performance,"# failed ... load dependencies explicitly",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/loader.py:13,load,load,13,bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/loader.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/loader.py,1,['load'],['load']
Performance,"# first load and move the builtin cppyy module",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy_compat/__init__.py:8,load,load,8,bindings/pyroot/cppyy/cppyy/python/cppyy_compat/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy_compat/__init__.py,1,['load'],['load']
Performance,"# first load the dependency libraries of the backend, then pull in the; # libcppyy extension module",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/_cpython_cppyy.py:8,load,load,8,bindings/pyroot/cppyy/cppyy/python/cppyy/_cpython_cppyy.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/_cpython_cppyy.py,1,['load'],['load']
Performance,"# first load the dependency libraries of the backend, then; # pull in the built-in low-level cppyy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/_pypy_cppyy.py:8,load,load,8,bindings/pyroot/cppyy/cppyy/python/cppyy/_pypy_cppyy.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/_pypy_cppyy.py,1,['load'],['load']
Performance,"# for example: TCut mycutb = ""abs(var1)<0.5"";; # Tell the factory how to use the training and testing events; # If no numbers of events are given, half of the events in the tree are used; # for training, and the other half for testing:; # loader.PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; # It is possible also to specify the number of training and testing events,; # note we disable the computation of the correlation matrix of the input variables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_CNN_Classification.py:239,load,loader,239,tutorials/tmva/TMVA_CNN_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_CNN_Classification.py,1,['load'],['loader']
Performance,"# for example: TCut mycutb = ""abs(var1)<0.5"";; # Tell the factory how to use the training and testing events; #; # If no numbers of events are given, half of the events in the tree are used; # for training, and the other half for testing:; # loader->PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; # To also specify the number of testing events, use:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_Higgs_Classification.py:242,load,loader,242,tutorials/tmva/TMVA_Higgs_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_Higgs_Classification.py,1,['load'],['loader']
Performance,"# for speed, bind and cache the Fill member functions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/hsum.py:22,cache,cache,22,tutorials/pyroot/hsum.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/hsum.py,1,['cache'],['cache']
Performance,"# get fresh (should not have been cached while incomplete)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_fragile.py:34,cache,cached,34,bindings/pyroot/cppyy/cppyy/test/test_fragile.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_fragile.py,1,['cache'],['cached']
Performance,"# ignore EEXIST, which may occur during a race condition",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/util.py:42,race condition,race condition,42,interpreter/llvm-project/llvm/utils/lit/lit/util.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/util.py,1,['race condition'],['race condition']
Performance,"# load",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_templates.py:2,load,load,2,bindings/pyroot/cppyy/cppyy/test/test_templates.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_templates.py,2,['load'],['load']
Performance,"# load a shared library",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py:2,load,load,2,bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py,1,['load'],['load']
Performance,"# load all libs and autoparse",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_misc.py:2,load,load,2,tree/dataframe/test/dataframe_misc.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_misc.py,1,['load'],['load']
Performance,"# load and jit a C header file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py:2,load,load,2,bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py,1,['load'],['load']
Performance,"# load and jit a header file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py:2,load,load,2,bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py,1,['load'],['load']
Performance,"# load bin center coordinates in internal buffer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf402_datahandling.py:2,load,load,2,tutorials/roofit/rf402_datahandling.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf402_datahandling.py,1,['load'],['load']
Performance,"# load libcppyy_backend",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/loader.py:2,load,load,2,bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/loader.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/loader.py,1,['load'],['load']
Performance,"# make sure cached values are actually looked up",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_doc_features.py:12,cache,cached,12,bindings/pyroot/cppyy/cppyy/test/test_doc_features.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_doc_features.py,1,['cache'],['cached']
Performance,"# normal load, allowing for user overrides of LD_LIBRARY_PATH",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/loader.py:9,load,load,9,bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/loader.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/loader.py,1,['load'],['load']
Performance,"# now locate and load the pip cppyy module",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy_compat/__init__.py:17,load,load,17,bindings/pyroot/cppyy/cppyy/python/cppyy_compat/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy_compat/__init__.py,1,['load'],['load']
Performance,"# only cached for global functions and in principle should; # not be needed anymore ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_advancedcpp.py:7,cache,cached,7,bindings/pyroot/cppyy/cppyy/test/test_advancedcpp.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_advancedcpp.py,1,['cache'],['cached']
Performance,"# perform now global fit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/fit/combinedFit.py:2,perform,perform,2,tutorials/fit/combinedFit.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/fit/combinedFit.py,1,['perform'],['perform']
Performance,"# print ""CACHE MISS""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ClangDataFormat.py:9,CACHE,CACHE,9,interpreter/llvm-project/clang/utils/ClangDataFormat.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ClangDataFormat.py,1,['CACHE'],['CACHE']
Performance,"# pythonization of tuple; TODO: placed here for convenience, but a custom case; # for tuples on each platform can be made much more performant ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py:132,perform,performant,132,bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/__init__.py,1,['perform'],['performant']
Performance,"# re.compile() has a built-in LRU cache with 512 entries. In some; # test suites lit ends up thrashing that cache, which made e.g.; # check-llvm run 50% slower. Use an explicit, unbounded cache; # to prevent that from happening. Since lit is fairly; # short-lived, since the set of substitutions is fairly small, and; # since thrashing has such bad consequences, not bounding the cache; # seems reasonable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:34,cache,cache,34,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,4,['cache'],['cache']
Performance,"# return weight of last loaded coordinates; # Reduce the 2-dimensional binned dataset to a 1-dimensional binned dataset; #; # All reduce() methods are interfaced in RooAbsData. All reduction techniques; # demonstrated on unbinned datasets can be applied to binned datasets as; # well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf402_datahandling.py:24,load,loaded,24,tutorials/roofit/rf402_datahandling.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf402_datahandling.py,1,['load'],['loaded']
Performance,"# run if loaded as script",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/zdemo.py:9,load,loaded,9,tutorials/pyroot/zdemo.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/zdemo.py,1,['load'],['loaded']
Performance,"# some older versions can be fixed up through a compatibility; # module on the python side; load it, if available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/_pypy_cppyy.py:92,load,load,92,bindings/pyroot/cppyy/cppyy/python/cppyy/_pypy_cppyy.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/_pypy_cppyy.py,1,['load'],['load']
Performance,"# the C++ object, b/c through a proxy, is always accessed by pointer; it is represented; # as a pointer to POD to allow indexing by Numba for data member type checking, but the; # address offsetting for loading data member values is independent (see get(), below),; # so the exact layout need not match a POD; # TODO: this doesn't work for real PODs, b/c those are unpacked into their elements and; # passed through registers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/numba_ext.py:203,load,loading,203,bindings/pyroot/cppyy/cppyy/python/cppyy/numba_ext.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/numba_ext.py,1,['load'],['loading']
Performance,"# the following ensures proper build/installation order, after which the normal; # install through setup.py picks up their wheels from the cache (TODO: note the; # duplication here with setup.py; find a better way)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/installer/cppyy_monkey_patch.py:139,cache,cache,139,bindings/pyroot/cppyy/cppyy/installer/cppyy_monkey_patch.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/installer/cppyy_monkey_patch.py,1,['cache'],['cache']
Performance,"# training2 = ROOT.TString(""LearningRate=1e-3,Momentum=0.9""; # ""ConvergenceSteps=10,BatchSize=128,TestRepetitions=1,""; # ""MaxEpochs=20,WeightDecay=1e-4,Regularization=None,""; # ""Optimizer=SGD,DropConfig=0.0+0.0+0.0+0.""); # General Options.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_Higgs_Classification.py:178,Optimiz,Optimizer,178,tutorials/tmva/TMVA_Higgs_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_Higgs_Classification.py,1,['Optimiz'],['Optimizer']
Performance,"# typing package doesn't have a separate type for Queue, but has a generic stub; # We still want to have a type-safe checked project queue, for this reason,; # we specify generic type for mypy.; #; # It is a common workaround for this situation:; # https://mypy.readthedocs.io/en/stable/common_issues.html#using-classes-that-are-generic-in-stubs-but-not-at-runtime",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:50,Queue,Queue,50,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,2,"['Queue', 'queue']","['Queue', 'queue']"
Performance,"# use option TF1 if too slow (plot.Draw(""tf1""); # if requested perform also an hypothesis test for the significance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/StandardProfileLikelihoodDemo.py:63,perform,perform,63,tutorials/roostats/StandardProfileLikelihoodDemo.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/StandardProfileLikelihoodDemo.py,1,['perform'],['perform']
Performance,"#!/usr/bin/env python; #; # Given a previous good compile narrow down miscompiles.; # Expects two directories named ""before"" and ""after"" each containing a set of; # assembly or object files where the ""after"" version is assumed to be broken.; # You also have to provide a script called ""link_test"". It is called with a; # list of files which should be linked together and result tested. ""link_test""; # should returns with exitcode 0 if the linking and testing succeeded.; #; # If a response file is provided, only the object files that are listed in the; # file are inspected. In addition, the ""link_test"" is called with a temporary; # response file representing one iteration of bisection.; #; # abtest.py operates by taking all files from the ""before"" directory and; # in each step replacing one of them with a file from the ""bad"" directory.; #; # Additionally you can perform the same steps with a single .s file. In this; # mode functions are identified by "" -- Begin function FunctionName"" and; # "" -- End function"" markers. The abtest.py then takes all; # function from the file in the ""before"" directory and replaces one function; # with the corresponding function from the ""bad"" file in each step.; #; # Example usage to identify miscompiled files:; # 1. Create a link_test script, make it executable. Simple Example:; # clang ""$@"" -o /tmp/test && /tmp/test || echo ""PROBLEM""; # 2. Run the script to figure out which files are miscompiled:; # > ./abtest.py; # somefile.s: ok; # someotherfile.s: skipped: same content; # anotherfile.s: failed: './link_test' exitcode != 0; # ...; # Example usage to identify miscompiled functions inside a file:; # 3. Run the tests on a single file (assuming before/file.s and; # after/file.s exist); # > ./abtest.py file.s; # funcname1 [0/XX]: ok; # funcname2 [1/XX]: ok; # funcname3 [2/XX]: skipped: same content; # funcname4 [3/XX]: failed: './link_test' exitcode != 0; # ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/abtest.py:870,perform,perform,870,interpreter/llvm-project/llvm/utils/abtest.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/abtest.py,1,['perform'],['perform']
Performance,"## Basic initialization of FOAM invoked by the user. Mandatory!; ///; /// This method starts the process of the cell build-up.; /// User must invoke Initialize with two arguments or Initialize without arguments.; /// This is done BEFORE generating first MC event and AFTER allocating FOAM object; /// and resetting (optionally) its internal parameters/switches.; /// The overall operational scheme of the FOAM is the following:; ///; /// \image html foam_schema2.png width=600; ///; /// ### This method invokes several other methods:; ///; /// InitCells initializes memory storage for cells and begins exploration process; /// from the root cell. The empty cells are allocated/filled using CellFill.; /// The procedure Grow which loops over cells, picks up the cell with the biggest; /// ``driver integral'', see Computer Physics Communications 152 152 (2003) 55 for explanations,; /// with the help of PeekMax procedure. The chosen cell is split using Divide.; /// Subsequently, the procedure Explore called by the Divide; /// (and by InitCells for the root cell) does the most important; /// job in the FOAM object build-up: it performs a small MC run for each; /// newly allocated daughter cell.; /// Explore calculates how profitable the future split of the cell will be; /// and defines the optimal cell division geometry with the help of Carver or Varedu; /// procedures, for maximum weight or variance optimization respectively.; /// All essential results of the exploration are written into; /// the explored cell object. At the very end of the foam build-up,; /// Finally, MakeActiveList is invoked to create a list of pointers to; /// all active cells, for the purpose of the quick access during the MC generation.; /// The procedure Explore employs MakeAlpha to generate random coordinates; /// inside a given cell with the uniform distribution.; /// The above sequence of the procedure calls is depicted in the following figure:; ///; /// \image html foam_Initialize_schema.png width=600",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:1217,perform,performs,1217,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,2,"['optimiz', 'perform']","['optimization', 'performs']"
Performance,"## Create TMVA Factory; # Create the Factory class. Later you can choose the methods; # whose performance you'd like to investigate.; # The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to pass; # - The first argument is the base of the name of all the output; # weight files in the directory weight/ that will be created with the; # method parameters; # - The second argument is the output file for the training results; # - The third argument is a string option defining some general configuration for the TMVA session.; # For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in the; # option string; # - note that we disable any pre-transformation of the input variables and we avoid computing correlations between; # input variables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_CNN_Classification.py:94,perform,performance,94,tutorials/tmva/TMVA_CNN_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_CNN_Classification.py,1,['perform'],['performance']
Performance,"## Creates the input variable histogram and perform the transformations if necessary; # @param dl DataLoader object; # @param className string Signal/Background; # @param variableName string containing the variable name; # @param numBin for creating the histogram; # @param processTrfs string containing the list of transformations to be used on input variable; eg. ""I;N;D;P;U;G,D""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/JsMVA/DataLoader.py:44,perform,perform,44,bindings/pyroot/pythonizations/python/ROOT/JsMVA/DataLoader.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/JsMVA/DataLoader.py,1,['perform'],['perform']
Performance,"## Declare Factory; # Create the Factory class. Later you can choose the methods; # whose performance you'd like to investigate.; # The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to; # pass; # - The first argument is the base of the name of all the output; # weightfiles in the directory weight/ that will be created with the; # method parameters; # - The second argument is the output file for the training results; #; # - The third argument is a string option defining some general configuration for the TMVA session.; # For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in; # the option string; # // Creating the factory object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_RNN_Classification.py:90,perform,performance,90,tutorials/tmva/TMVA_RNN_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_RNN_Classification.py,1,['perform'],['performance']
Performance,"## Graphical interface for booking DNN; # @param self object pointer; # @param loader the DataLoader object; # @param title classifier title",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/JsMVA/Factory.py:79,load,loader,79,bindings/pyroot/pythonizations/python/ROOT/JsMVA/Factory.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/JsMVA/Factory.py,1,['load'],['loader']
Performance,"## This function captures objects which are declared in noteboko cell. It's used to capture factory and data loader objects.; # @param args classes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/JsMVA/JPyInterface.py:109,load,loader,109,bindings/pyroot/pythonizations/python/ROOT/JsMVA/JPyInterface.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/JsMVA/JPyInterface.py,1,['load'],['loader']
Performance,"## \file; ## \ingroup tutorial_dataframe; ## \notebook -draw; ## An example of complex analysis with RDataFrame: reconstructing the Higgs boson.; ##; ## This tutorial is a simplified but yet complex example of an analysis reconstructing the Higgs boson decaying to two Z; ## bosons from events with four leptons. The data and simulated events are taken from CERN OpenData representing a; ## subset of the data recorded in 2012 with the CMS detector at the LHC. The tutorials follows the Higgs to four leptons; ## analysis published on CERN Open Data portal ([10.7483/OPENDATA.CMS.JKB8.RR42](http://opendata.cern.ch/record/5500)).; ## The resulting plots show the invariant mass of the selected four lepton systems in different decay modes (four muons,; ## four electrons and two of each kind) and in a combined plot indicating the decay of the Higgs boson with a mass of; ## about 125 GeV.; ##; ## The following steps are performed for each sample with data and simulated events in order to reconstruct the Higgs; ## boson from the selected muons and electrons:; ## 1. Select interesting events with multiple cuts on event properties, e.g., number of leptons, kinematics of the; ## leptons and quality of the tracks.; ## 2. Reconstruct two Z bosons of which only one on the mass shell from the selected events and apply additional cuts on; ## the reconstructed objects.; ## 3. Reconstruct the Higgs boson from the remaining Z boson candidates and calculate its invariant mass.; ##; ## Another aim of this version of the tutorial is to show a way to blend C++ and Python code. All the functions that; ## make computations on data to define new columns or filter existing ones in a precise way, better suited to be written; ## in C++, have been moved to a header that is then declared to the ROOT C++ interpreter. The functions that instead; ## create nodes of the computational graph (e.g. Filter, Define) remain inside the main Python script.; ##; ## The tutorial has the fast mode enabled by default,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df103_NanoAODHiggsAnalysis.py:922,perform,performed,922,tutorials/dataframe/df103_NanoAODHiggsAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df103_NanoAODHiggsAnalysis.py,1,['perform'],['performed']
Performance,"## \file; ## \ingroup tutorial_dataframe; ## \notebook -draw; ## Cache a processed RDataFrame in memory for further usage.; ##; ## This tutorial shows how the content of a data frame can be cached in memory; ## in form of a dataframe. The content of the columns is stored in memory in; ## contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation; ## is performed.; ##; ## Creating a cached data frame storing all of its content deserialised and uncompressed; ## in memory is particularly useful when dealing with datasets of a moderate size; ## (small enough to fit the RAM) over which several explorative loops need to be; ## performed as fast as possible. In addition, caching can be useful when no file; ## on disk needs to be created as a side effect of checkpointing part of the analysis.; ##; ## All steps in the caching are lazy, i.e. the cached data frame is actually filled; ## only when the event loop is triggered on it.; ##; ## \macro_code; ## \macro_image; ##; ## \date June 2018; ## \author Danilo Piparo (CERN)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df019_Cache.py:65,Cache,Cache,65,tutorials/dataframe/df019_Cache.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df019_Cache.py,6,"['Cache', 'cache', 'perform']","['Cache', 'cached', 'performed']"
Performance,"## \file; ## \ingroup tutorial_roofit; ## \notebook -js; ## Performing a simple fit with RooLagrangianMorphFunc; ##; ## \macro_image; ## \macro_code; ## \macro_output; ##; ## \date January 2022; ## \author Rahul Balasubramanian",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf712_lagrangianmorphfit.py:60,Perform,Performing,60,tutorials/roofit/rf712_lagrangianmorphfit.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf712_lagrangianmorphfit.py,1,['Perform'],['Performing']
Performance,"## \file; ## \ingroup tutorial_roofit; ## \notebook -js; ## This tutorial explains the concept of global observables in RooFit, and; ## showcases how their values can be stored either in the model or in the; ## dataset.; ##; ## ### Introduction; ##; ## Note: in this tutorial, we are multiplying the likelihood with an additional; ## likelihood to constrain the parameters with auxiliary measurements. This is; ## different from the `rf604_constraints` tutorial, where the likelihood is; ## multiplied with a Bayesian prior to constrain the parameters.; ##; ##; ## With RooFit, you usually optimize some model parameters `p` to maximize the; ## likelihood `L` given the per-event or per-bin observations `x`:; ##; ## \f[ L( x | p ) \f]; ##; ## Often, the parameters are constrained with some prior likelihood `C`, which; ## doesn't depend on the observables `x`:; ##; ## \f[ L'( x | p ) = L( x | p ) * C( p ) \f]; ##; ## Usually, these constraint terms depend on some auxiliary measurements of; ## other observables `g`. The constraint term is then the likelihood of the; ## so-called global observables:; ##; ## \f[ L'( x | p ) = L( x | p ) * C( g | p ) \f]; ##; ## For example, think of a model where the true luminosity `lumi` is a; ## nuisance parameter that is constrained by an auxiliary measurement; ## `lumi_obs` with uncertainty `lumi_obs_sigma`:; ##; ## \f[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi_obs | lumi, lumi_obs_sigma) \f]; ##; ## As a Gaussian is symmetric under exchange of the observable and the mean; ## parameter, you can also sometimes find this equivalent but less conventional; ## formulation for Gaussian constraints:; ##; ## \f[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi | lumi_obs, lumi_obs_sigma) \f]; ##; ## If you wanted to constrain a parameter that represents event counts, you; ## would use a Poissonian constraint, e.g.:; ##; ## \f[ L'(data | mu, count) = L(data | mu, count) * \text{Poisson}(count_obs | count) \f]; ##; ## Un",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf613_global_observables.py:590,optimiz,optimize,590,tutorials/roofit/rf613_global_observables.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf613_global_observables.py,1,['optimiz'],['optimize']
Performance,"## \file; ## \ingroup tutorial_roofit; ## \notebook -nodraw; ## Multidimensional models: performing fits in multiple (disjoint) ranges in one or more dimensions; ##; ## \macro_code; ## \macro_output; ##; ## \date February 2018; ## \authors Clemens Lange, Wouter Verkerke (C++ version)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf312_multirangefit.py:89,perform,performing,89,tutorials/roofit/rf312_multirangefit.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf312_multirangefit.py,1,['perform'],['performing']
Performance,"## \file; ## \ingroup tutorial_roofit; ## \notebook -nodraw; ## This macro demonstrates how to set up a fit in two ranges for plain; ## likelihoods and extended likelihoods.; ##; ## ### 1. Shape fits (plain likelihood); ##; ## If you fit a non-extended pdf in two ranges, e.g. `pdf.fitTo(data,Range=""Range1,Range2"")`,; ## it will fit the shapes in the two selected ranges and also take into account the relative; ## predicted yields in those ranges.; ##; ## This is useful for example to represent a full-range fit, but with a; ## blinded signal region inside it.; ##; ##; ## ### 2. Shape+rate fits (extended likelihood); ##; ## If your pdf is extended, i.e. measuring both the distribution in the observable as well; ## as the event count in the fitted region, some intervention is needed to make fits in ranges; ## work in a way that corresponds to intuition.; ##; ## If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence; ## the expected event count will converge to a number that is smaller than what's visible in a plot.; ## In such cases, it is often preferred to interpret the extended term with respect to the full range; ## that's plotted, i.e., apply a correction to the extended likelihood term in such a way; ## that the interpretation of the expected event count remains that of the full range. This can; ## be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the; ## fitted range) in the Poisson term that represents the extended likelihood term.; ##; ## If an extended likelihood fit is performed over *two* sub-ranges, this correction is; ## even more important: without it, each component likelihood would have a different interpretation; ## of the expected event count (each corresponding to the count in its own region), and a joint; ## fit of these regions with different interpretations of the same model parameter results; ## in a number that is not easily interpreted.; ##; ## If both re",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf204b_extendedLikelihood_rangedFit.py:892,perform,performed,892,tutorials/roofit/rf204b_extendedLikelihood_rangedFit.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf204b_extendedLikelihood_rangedFit.py,1,['perform'],['performed']
Performance,"## \file; ## \ingroup tutorial_roofit; ## \notebook; ## Convolution in cyclical angular observables theta, and; ## construction of p.d.f in terms of transformed angular; ## coordinates, e.g. cos(theta), the convolution; ## is performed in theta rather than cos(theta); ##; ## (require ROOT to be compiled with --enable-fftw3); ##; ## pdf(theta) = ROOT.T(theta) (x) gauss(theta); ## pdf(cosTheta) = ROOT.T(acos(cosTheta)) (x) gauss(acos(cosTheta)); ##; ## \macro_image; ## \macro_code; ## \macro_output; ##; ## \date February 2018; ## \authors Clemens Lange, Wouter Verkerke (C version)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf210_angularconv.py:226,perform,performed,226,tutorials/roofit/rf210_angularconv.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf210_angularconv.py,1,['perform'],['performed']
Performance,"## \file; ## \ingroup tutorial_roofit; ## \notebook; ## Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting; ##; ## \macro_image; ## \macro_code; ## \macro_output; ##; ## \date February 2018; ## \authors Clemens Lange, Wouter Verkerke (C++ version)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf801_mcstudy.py:110,perform,perform,110,tutorials/roofit/rf801_mcstudy.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf801_mcstudy.py,1,['perform'],['perform']
Performance,"## \file; ## \ingroup tutorial_tmva; ## \notebook; ## Classification example of TMVA based on public Higgs UCI dataset; ##; ## The UCI data set is a public HIGGS data set , see http://archive.ics.uci.edu/ml/datasets/HIGGS; ## used in this paper: Baldi, P., P. Sadowski, and D. Whiteson. “Searching for Exotic Particles in High-energy Physics; ## with Deep Learning.” Nature Communications 5 (July 2, 2014).; ##; ## \macro_image; ## \macro_output; ## \macro_code; ##; ## \author Harshal Shende; ## Declare Factory; ## Create the Factory class. Later you can choose the methods; ## whose performance you'd like to investigate.; ## The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to pass; ## - The first argument is the base of the name of all the output; ## weightfiles in the directory weight/ that will be created with the; ## method parameters; ## - The second argument is the output file for the training results; ## - The third argument is a string option defining some general configuration for the TMVA session. For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in the option string",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_Higgs_Classification.py:586,perform,performance,586,tutorials/tmva/TMVA_Higgs_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_Higgs_Classification.py,1,['perform'],['performance']
Performance,"## macro for performing a classification using a Recurrent Neural Network; ## @param use_type; ## use_type = 0 use Simple RNN network; ## use_type = 1 use LSTM network; ## use_type = 2 use GRU; ## use_type = 3 build 3 different networks with RNN, LSTM and GRU",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_RNN_Classification.py:13,perform,performing,13,tutorials/tmva/TMVA_RNN_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_RNN_Classification.py,1,['perform'],['performing']
Performance,"### 3.Accessing the fit results. #### 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods. #### 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. ### 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points and setting the fitting function.; Note, that standard errors on parameters are not computed!. */; ////////////////////////////////////////////////////////////////////////////////; ///default c-tor, input data is stored; ///If you don't want to store the input data,; ///run the function StoreData(kFALSE) after constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearFitter.cxx:6696,perform,perform,6696,math/minuit/src/TLinearFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearFitter.cxx,1,['perform'],['perform']
Performance,"#)root/test:$name: $:$id: stressFit.cxx,v 1.15 2002/10/25 10:47:51 rdm exp $; // Authors: Rene Brun, Eddy Offermann April 2006; //*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*//; // //; // Function Minimization Examples, Fred James //; // //; // from the //; // Proceedings of the 1972 CERN Computing and Data Processing School //; // Pertisau, Austria, 10-24 September, 1972 (CERN 72-21) //; // //; // Here a collection of test problems is assembled which were found to be //; // useful in verifying and comparing minimization routines. Many of these //; // are standard functions upon which it has become conventional to try all //; // new methods, quoting the performance in the publication of the algorithm //; // //; // Each test will produce one line (Test OK or Test FAILED) . At the end of //; // the test a table is printed showing the global results Real Time and //; // Cpu Time. One single number (ROOTMARKS) is also calculated showing the //; // relative performance of your machine compared to a reference machine //; // a Pentium IV 2.4 Ghz) with 512 MBytes of memory and 120 GBytes IDE disk. //; // //; // In the main routine the fitter can be chosen through TVirtualFitter : //; // - Minuit //; // - Minuit2 //; // - Fumili //; //; // To run the test, do, eg; // root -b -q stressFit.cxx; // root -b -q ""stressFit.cxx(\""Minuit2\"")""; // root -b -q ""stressFit.cxx+(\""Minuit2\"")""; // //; // The verbosity can be set through the global parameter gVerbose : //; // -1: off 1: on //; // The tolerance on the parameter deviation from the minimum can be set //; // through gAbsTolerance . //; // //; // An example of output when all the tests run OK is shown below: //; // ******************************************************************* //; // * Minimization - S T R E S S suite * //; // ******************************************************************* //; // ******************************************************************* //; // * Starting S T R E ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressFit.cxx:1003,perform,performance,1003,test/stressFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressFit.cxx,1,['perform'],['performance']
Performance,"#; # Load any customisations.; #",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/bindings_utils.py:5,Load,Load,5,bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/bindings_utils.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/bindings_utils.py,1,['Load'],['Load']
Performance,"#; # Load pythonizations; #",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/pkg_templates/initializor.py:5,Load,Load,5,bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/pkg_templates/initializor.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/pkg_templates/initializor.py,1,['Load'],['Load']
Performance,"#; # Load the given libclang.; #",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/_cppyy_generator.py:5,Load,Load,5,bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/_cppyy_generator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/_cppyy_generator.py,1,['Load'],['Load']
Performance,"#; # Load the library.; #",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/bindings_utils.py:5,Load,Load,5,bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/bindings_utils.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/bindings_utils.py,2,['Load'],['Load']
Performance,"#Construct loss function and optimizer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/generatePyTorchModels.py:29,optimiz,optimizer,29,tmva/pymva/test/generatePyTorchModels.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/generatePyTorchModels.py,3,['optimiz'],['optimizer']
Performance,"$ \\phi \\f$ between \\f$\\textbf{w}_L\\f$ and \\f$\\textbf{D}\\f$"". ## Test 2; Let \f$\textbf{D}\f$ be the data vector to be fitted. As illustrated in; figure 1, the \f$L^{\mbox{th}}\f$ function \f$\textbf{w}_L\f$; will contribute significantly to the reduction of \f$ S\f$, if the angle; \f$\phi^\prime\f$ between \f$\textbf{w}_L\f$ and \f$\textbf{D}\f$ is smaller than; an upper limit \f$ \phi \f$, defined by the user (MultiDimFit::SetMaxAngle). However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of \f$ S\f$ are chosen first; (TMultiDimFit::TestFunction). In case \f$ \phi \f$ isn't defined, an alternative method of; performing this second test is used: The \f$L^{\mbox{th}}\f$; function \f$\textbf{f}_L\f$ is accepted if (refer also to equation (13)); \f[; \Delta S_L > \frac{S_{L-1}}{L_{max}-L}; \f]; where \f$ S_{L-1}\f$ is the sum of the \f$ L-1\f$ first residuals from the; \f$ L-1\f$ functions previously accepted; and \f$ L_{max}\f$ is the total number; of functions allowed in the final expression of the fit (defined by; user). From this we see, that by restricting \f$ L_{max}\f$ -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting. The more coefficients we evaluate, the more the sum of squares of; residuals \f$ S\f$ will be reduced. We can evaluate \f$ S\f$ before inverting; \f$\mathsf{B}\f$ as shown below. ## Coefficients and Coefficient Errors; Having found a parameterization, that is the \f$ F_l\f$'s and \f$ L\f$, that; minimizes \f$ S\f$, we still need to determine the coefficients; \f$ c_l\f$. However, it's a feature of how we choose the significant; functions, that the evaluation of the \f$ c_l\f$'s becomes trivial [5]. To derive; \f$\mathbf{c}\f$, we first note that; equation (4) c",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:11254,perform,performing,11254,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['perform'],['performing']
Performance,"$Id$; // Author: M.Gheata; /*************************************************************************; * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TGeoVolumeEditor; \ingroup Geometry_builder. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; split vertically by a shutter:. - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from `<Daughters>` category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the slicing step is set to 0 - meaning that only the number; of slice",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geombuilder/src/TGeoVolumeEditor.cxx:982,perform,performed,982,geom/geombuilder/src/TGeoVolumeEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geombuilder/src/TGeoVolumeEditor.cxx,1,['perform'],['performed']
Performance,"$_s$}{\cal P}lots\f$,; one recovers the data sample distribution in \f$x\f$, and summing up the number of events; entering in a \f$\hbox{$_s$}{\cal P}lot\f$ for a given species, one recovers the yield of the; species, as provided by the fit.; The property 4 is implemented in the TSPlot class as a check. - the sum of the statistical uncertainties per bin. \f[; \sigma[N_{\rm n}\ _s\tilde{\rm M}_{\rm n}(x) {\delta x}]~=~\sqrt{\sum_{e \subset {\delta x}} ({_s{\cal P}}_{\rm n})^2} ~. \tag{6}; \f]. reproduces the statistical uncertainty on the yield \f$N_{\rm n}\f$, as provided by the fit:; \f$\sigma[N_{\rm n}]\equiv\sqrt{\hbox{ V}_{{\rm n}{\rm n}}}\f$ .; Because of that and since the determination of the yields is optimal; when obtained using a Likelihood fit, one can conclude that the \f$\hbox{$_s$}{\cal P}lot\f$; technique is itself an optimal method to reconstruct distributions of control variables. ### Different steps followed by TSPlot. 1. A maximum Likelihood fit is performed to obtain the yields \f$N_i\f$; of the various species.The fit relies on discriminating variables \f$y\f$; uncorrelated with a control variable \f$x\f$:; the later is therefore totally absent from the fit. 2. The weights \f${_s{\cal P}}\f$ are calculated using Eq.; (2); where the covariance matrix is taken from Minuit. 3. Histograms of \f$x\f$ are filled by weighting the events with \f${_s{\cal P}}\f$ . 4. Error bars per bin are given by Eq. (6). The \f$\hbox {$_s$}{\cal P}lots\f$ reproduce the true distributions of the species; in the control variable \f$x\f$, within the above defined statistical uncertainties. ### Illustrations. To illustrate the technique, one considers an example derived from the analysis where; \f$\hbox {$_s$}{\cal P}lots\f$; have been first used (charmless B decays). One is dealing with a data; sample in which two species are present: the first is termed signal and; the second background. A maximum Likelihood fit is performed to obtain; the two yields \f$N_1\f$ and \f$N_",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/splot/src/TSPlot.cxx:5678,perform,performed,5678,math/splot/src/TSPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/splot/src/TSPlot.cxx,1,['perform'],['performed']
Performance,"'''#pragma cling optimize(2); #include ""gnn_encoder.hxx""; #include ""gnn_core.hxx""; #include ""gnn_decoder.hxx""; #include ""gnn_output_transform.hxx""'''",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_SOFIE_GNN.py:17,optimiz,optimize,17,tutorials/tmva/TMVA_SOFIE_GNN.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_SOFIE_GNN.py,1,['optimiz'],['optimize']
Performance,"'''; Completer which interfaces to the TTabCom of ROOT. It is activated; (deactivated) upon the load(unload) of the load of the extension. >>> comp = CppCompleter(); >>> comp.activate(); >>> for suggestion in comp._completeImpl(""TTreeF""):; ... print(suggestion); TTreeFormula; TTreeFormulaManager; TTreeFriendLeafIter; >>> garbage = ROOT.gInterpreter.ProcessLine(""TH1F* h""); >>> for suggestion in comp._completeImpl(""h->GetA""):; ... print(suggestion); h->GetArray; h->GetAsymmetry; h->GetAt; h->GetAxisColor; >>> garbage = ROOT.gInterpreter.ProcessLine(""TH1F aa""); >>> for suggestion in comp._completeImpl(""aa.Add(""):; ... print(suggestion.replace(""\\t"","" "")); <BLANKLINE>; Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Bool_t Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1) // *MENU*; Bool_t Add(const TH1* h1, Double_t c1 = 1); >>> for suggestion in comp._completeImpl(""TROOT::Is""):; ... print(suggestion); TROOT::IsA; TROOT::IsBatch; TROOT::IsBuilt; TROOT::IsDestructed; TROOT::IsEqual; TROOT::IsEscaped; TROOT::IsExecutingMacro; TROOT::IsFolder; TROOT::IsInterrupted; TROOT::IsLineProcessing; TROOT::IsModified; TROOT::IsOnHeap; TROOT::IsProofServ; TROOT::IsRootFile; TROOT::IsSortable; TROOT::IsWebDisplay; TROOT::IsWebDisplayBatch; TROOT::IsWritable; TROOT::IsZombie; >>> comp.deactivate(); >>> for suggestion in comp._completeImpl(""TG""):; ... print(suggestion); '''",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/jupyroot/python/JupyROOT/helpers/cppcompleter.py:96,load,load,96,bindings/jupyroot/python/JupyROOT/helpers/cppcompleter.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/jupyroot/python/JupyROOT/helpers/cppcompleter.py,2,['load'],['load']
Performance,"'''; Decorator for making Python callables accessible in C++ by just-in-time compilation; with numba and cling. The decorator takes the given Python callable and just-in-time compiles (jits); wrapper functions with the given C++ types for input and return types. Eventually,; the Python callable is accessible in the Numba namespace in C++. The implementation first jits with numba the Python callable. We support fundamental types and; ROOT::VecOps::RVecs thereof. Note that you can get the jitted Python callable by the attribute; numba_func. The C++ types are converted to the respective numba types and RVecs are accessible; in Python by numpy arrays. After jitting the actual Python callable, we jit another Python wrapper,; which converts the Python signature to a C-friendly signature. The wrapper code is accessible by; the attribute __py_wrapper__. Next, the Python wrapper is given to cling to jit a C++ wrapper function,; making the original Python callable accessible in C++. The wrapper code in C++ is accessible by; the attribute __cpp_wrapper__. Note that the callable is fully compiled without side-effects. The numba jitting uses the nopython; option which does not allow interaction with the Python interpreter. This means that you can use; the resulting function also safely in multi-threaded environments.; '''",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_numbadeclare.py:1297,multi-thread,multi-threaded,1297,bindings/pyroot/pythonizations/python/ROOT/_numbadeclare.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_numbadeclare.py,1,['multi-thread'],['multi-threaded']
Performance,"'''; License: LGPLv2+ or NCSA; Group: Development/Languages/Other; SOURCE0 : %{name}-%{version}.tar.bz2; URL: http://cling.web.cern.ch/; Vendor: Developed by The ROOT Team; CERN and Fermilab; Packager: Anirudha Bose <ani07nov@gmail.com>. BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root. %description; Cling is a new and interactive C++11 standard compliant interpreter built; on the top of Clang and LLVM compiler infrastructure. Its advantages over; the standard interpreters are that it has command line prompt and uses; Just In Time (JIT) compiler for compilation. Many of the developers; (e.g. Mono in their project called CSharpRepl) of such kind of software; applications name them interactive compilers. One of Cling's main goals is to provide contemporary, high-performance; alternative of the current C++ interpreter in the ROOT project - CINT. Cling; serves as a core component of the ROOT system for storing and analyzing the; data of the Large Hadron Collider (LHC) experiments. The; backward-compatibility with CINT is major priority during the development. %prep; %setup; mkdir -p $RPM_BUILD_DIR/%{name}-%{version}/usr/share/doc; mv $RPM_BUILD_DIR/%{name}-%{version}/bin/ $RPM_BUILD_DIR/%{name}-%{version}/usr; mv $RPM_BUILD_DIR/%{name}-%{version}/docs/* $RPM_BUILD_DIR/%{name}-%{version}/usr/share/doc/; mv $RPM_BUILD_DIR/%{name}-%{version}/lib/ $RPM_BUILD_DIR/%{name}-%{version}/usr; mv $RPM_BUILD_DIR/%{name}-%{version}/include/ $RPM_BUILD_DIR/%{name}-%{version}/usr; mv $RPM_BUILD_DIR/%{name}-%{version}/share/* $RPM_BUILD_DIR/%{name}-%{version}/usr/share. rm -Rf $RPM_BUILD_DIR/%{name}-%{version}/docs; rm -Rf $RPM_BUILD_DIR/%{name}-%{version}/share. if [ ${RPM_ARCH} = 'x86_64' ]; then; mv $RPM_BUILD_DIR/%{name}-%{version}/usr/lib $RPM_BUILD_DIR/%{name}-%{version}/usr/lib64; fi. %build; # Empty section. %install; rm -rf %{buildroot}; mkdir -p %{buildroot}. # in builddir; cp -a * %{buildroot}. %clean; rm -rf %{buildroot}. %files; %defattr(-,root,root,-); %{_bindir}/*",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/cpt.py:780,perform,performance,780,interpreter/cling/tools/packaging/cpt.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/cpt.py,1,['perform'],['performance']
Performance,"'''; Source: cling; Section: devel; Priority: optional; Maintainer: Cling Developer Team <cling-dev@cern.ch>; Uploaders: %s; Build-Depends: debhelper (>= 9.0.0); Standards-Version: 3.9.5; Homepage: http://cling.web.cern.ch/; Vcs-Git: http://root.cern.ch/git/cling.git; Vcs-Browser: http://root.cern.ch/gitweb?p=cling.git;a=summary. Package: cling; Priority: optional; Architecture: any; Depends: ${shlibs:Depends}, ${misc:Depends}; Description: interactive C++ interpreter; Cling is a new and interactive C++11 standard compliant interpreter built; on the top of Clang and LLVM compiler infrastructure. Its advantages over; the standard interpreters are that it has command line prompt and uses; Just In Time (JIT) compiler for compilation. Many of the developers; (e.g. Mono in their project called CSharpRepl) of such kind of software; applications name them interactive compilers.; .; One of Cling's main goals is to provide contemporary, high-performance; alternative of the current C++ interpreter in the ROOT project - CINT. Cling; serves as a core component of the ROOT system for storing and analyzing the; data of the Large Hadron Collider (LHC) experiments. The; backward-compatibility with CINT is major priority during the development.; '''",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/cpt.py:947,perform,performance,947,interpreter/cling/tools/packaging/cpt.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/cpt.py,1,['perform'],['performance']
Performance,'''Class to load JupyROOT Magics''',MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/jupyroot/python/JupyROOT/kernel/utils.py:12,load,load,12,bindings/jupyroot/python/JupyROOT/kernel/utils.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/jupyroot/python/JupyROOT/kernel/utils.py,1,['load'],['load']
Performance,"'''FIXME!; This function is a workaround. On osx, it is impossible to link against; libzmq.so, among the others. The error is known and is; ""ld: can't link with bundle (MH_BUNDLE) only dylibs (MH_DYLIB)""; We cannot at the moment force Aclic to change the linker command in order; to exclude these libraries, so we launch a second root session to compile; the library, which we then load.; '''",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/jupyroot/python/JupyROOT/helpers/utils.py:382,load,load,382,bindings/jupyroot/python/JupyROOT/helpers/utils.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/jupyroot/python/JupyROOT/helpers/utils.py,1,['load'],['load']
Performance,"'url'.; /// If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; /// sequentially in the specified order until a successful open.; /// If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; /// will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; /// etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; /// for regular expressions that will be checked) and as last a local file will; /// be tried.; /// Before opening a file via TNetFile a check is made to see if the URL; /// specifies a local file. If that is the case the file will be opened; /// via a normal TFile. To force the opening of a local file via a; /// TNetFile use either TNetFile directly or specify as host ""localhost"".; /// The netopt argument is only used by TNetFile. For the meaning of the; /// options and other arguments see the constructors of the individual; /// file classes. In case of error, it returns a nullptr.; ///; /// For TFile implementations supporting asynchronous file open, see; /// TFile::AsyncOpen(...), it is possible to request a timeout with the; /// option <b>`TIMEOUT=<secs>`</b>: the timeout must be specified in seconds and; /// it will be internally checked with granularity of one millisec.; /// For remote files there is the option: <b>CACHEREAD</b> opens an existing; /// file for reading through the file cache. The file will be downloaded to; /// the cache and opened from there. If the download fails, it will be opened remotely.; /// The file will be downloaded to the directory specified by SetCacheFileDir().; ///; /// *The caller is responsible for deleting the pointer.*; /// In READ mode, a nullptr is returned if the file does not exist or cannot be opened.; /// In CREATE mode, a nullptr is returned if the file already exists or cannot be created.; /// In RECREATE mode, a nullptr is returned if the file can not be created.; /// In UPDATE mode, a nullptr is returned if the file cannot be created or opened.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:1741,CACHE,CACHEREAD,1741,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,3,"['CACHE', 'cache']","['CACHEREAD', 'cache']"
Performance,"(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; where `slot` will be a number between 0 and `GetNSlots() - 1`.; In other words, within a slot, computation runs sequentially and events are processed sequentially.; Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; will never receive the same slot at the same time.; This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot(). ### Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run d",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:49571,concurren,concurrently,49571,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['concurren'],['concurrently']
Performance,"(bounding box and tessellation vertexes) are in local or master (world frame).; fLocalMaster is a standard 4x4 translation matrix (OpenGL column major ordering); for placing the object into the 3D master frame. If fLocalFrame is kFALSE, fLocalMaster should contain an identity matrix. This; is set by default, and can be reset using SetLocalMasterIdentity() function. ### Logical & Physical Objects. There are two cases of object addition:. - Add this object as a single independent entity in the world reference frame.; - Add a physical placement (copy) of this logical object (described in local reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can also perform internal GL specific caching with considerable performance gains; in these cases. For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; ~~~ {.cpp}; PreferLocalFrame(); ~~~. If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements. For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object. As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable o",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualViewer3D.cxx:7649,cache,cached,7649,core/base/src/TVirtualViewer3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualViewer3D.cxx,1,['cache'],['cached']
Performance,"(file, 0);; /// ~~~; /// If 'option' contains the word 'fast' the merge will be done without; /// unzipping or unstreaming the baskets (i.e., a direct copy of the raw; /// bytes on disk).; ///; /// When 'fast' is specified, 'option' can also contains a; /// sorting order for the baskets in the output file.; ///; /// There is currently 3 supported sorting order:; /// ~~~ {.cpp}; /// SortBasketsByOffset (the default); /// SortBasketsByBranch; /// SortBasketsByEntry; /// ~~~; /// When using SortBasketsByOffset the baskets are written in; /// the output file in the same order as in the original file; /// (i.e. the basket are sorted on their offset in the original; /// file; Usually this also means that the baskets are sorted; /// on the index/number of the _last_ entry they contain); ///; /// When using SortBasketsByBranch all the baskets of each; /// individual branches are stored contiguously. This tends to; /// optimize reading speed when reading a small number (1->5) of; /// branches, since all their baskets will be clustered together; /// instead of being spread across the file. However it might; /// decrease the performance when reading more branches (or the full; /// entry).; ///; /// When using SortBasketsByEntry the baskets with the lowest; /// starting entry are written first. (i.e. the baskets are; /// sorted on the index/number of the first entry they contain).; /// This means that on the file the baskets will be in the order; /// in which they will be needed when reading the whole tree; /// sequentially.; ///; /// ## IMPORTANT Note 1: AUTOMATIC FILE OVERFLOW; ///; /// When merging many files, it may happen that the resulting file; /// reaches a size > TTree::fgMaxTreeSize (default = 100 GBytes).; /// In this case the current file is automatically closed and a new; /// file started. If the name of the merged file was ""merged.root"",; /// the subsequent files will be named ""merged_1.root"", ""merged_2.root"",; /// etc. fgMaxTreeSize may be modified via the static",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:2424,optimiz,optimize,2424,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['optimiz'],['optimize']
Performance,"). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:2306,optimiz,optimizations,2306,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,1,['optimiz'],['optimizations']
Performance,").; *; * The pristine longest_match() function is sketched bellow (strip the; * then-clause of the ""#ifdef UNALIGNED_OK""-directive); *; * ------------------------------------------------------------; * uInt longest_match(...) {; * ...; * do {; * match = s->window + cur_match; //s0; * if (*(ushf*)(match+best_len-1) != scan_end || //s1; * *(ushf*)match != scan_start) continue; //s2; * ...; *; * do {; * } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&; * *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&; * *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&; * *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&; * scan < strend); //s3; *; * ...; * } while(cond); //s4; *; * -------------------------------------------------------------; *; * The change include:; *; * 1) The hottest statements of the function is: s0, s1 and s4. Pull them; * together to form a new loop. The benefit is two-fold:; *; * o. Ease the compiler to yield good code layout: the conditional-branch; * corresponding to s1 and its biased target s4 become very close (likely,; * fit in the same cache-line), hence improving instruction-fetching; * efficiency.; *; * o. Ease the compiler to promote ""s->window"" into register. ""s->window""; * is loop-invariant; it is supposed to be promoted into register and keep; * the value throughout the entire loop. However, there are many such; * loop-invariant, and x86-family has small register file; ""s->window"" is; * likely to be chosen as register-allocation victim such that its value; * is reloaded from memory in every single iteration. By forming a new loop,; * ""s->window"" is loop-invariant of that newly created tight loop. It is; * lot easier for compiler to promote this quantity to register and keep; * its value throughout the entire small loop.; *; * 2) Transfrom s3 such that it examines sizeof(long)-byte-match at a time.; * This is done by:; * ------------------------------------------------; * v1 = load from ""scan"" by sizeof(long) bytes; * v2 = load from ""match"" by sizeof(lnog) bytes; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate_cf.c:1140,cache,cache-line,1140,builtins/zlib/deflate_cf.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate_cf.c,1,['cache'],['cache-line']
Performance,"); ///; /// For example with Event.root, if; /// ~~~ {.cpp}; /// Double_t somePx = fTracks.fPx[2];; /// ~~~; /// is executed by one of the method of the skeleton,; /// somePx will updated with the current value of fPx of the 3rd track.; ///; /// Both macrofilename and the optional cutfilename are expected to be; /// the name of source files which contain at least a free standing; /// function with the signature:; /// ~~~ {.cpp}; /// x_t macrofilename(); // i.e function with the same name as the file; /// ~~~; /// and; /// ~~~ {.cpp}; /// y_t cutfilename(); // i.e function with the same name as the file; /// ~~~; /// x_t and y_t needs to be types that can convert respectively to a double; /// and a bool (because the skeleton uses:; ///; /// if (cutfilename()) htemp->Fill(macrofilename());; ///; /// These two functions are run in a context such that the branch names are; /// available as local variables of the correct (read-only) type.; ///; /// Note that if you use the same 'variable' twice, it is more efficient; /// to 'cache' the value. For example:; /// ~~~ {.cpp}; /// Int_t n = fEventNumber; // Read fEventNumber; /// if (n<10 || n>10) { ... }; /// ~~~; /// is more efficient than; /// ~~~ {.cpp}; /// if (fEventNumber<10 || fEventNumber>10); /// ~~~; /// Also, optionally, the generated selector will also call methods named; /// macrofilename_methodname in each of 6 main selector methods if the method; /// macrofilename_methodname exist (Where macrofilename is stripped of its; /// extension).; ///; /// Concretely, with the script named h1analysisProxy.C,; ///; /// - The method calls the method (if it exist); /// - Begin -> void h1analysisProxy_Begin(TTree*);; /// - SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; /// - Notify -> bool h1analysisProxy_Notify();; /// - Process -> bool h1analysisProxy_Process(Long64_t);; /// - SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; /// - Terminate -> void h1analysisProxy_Terminate();; ///; /// If a file name ma",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2776,cache,cache,2776,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['cache'],['cache']
Performance,");; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }; End_Macro. \since **ROOT version 6.07/03:**. A second rendering technique is also available with the COL2 and COLZ2 options. These options provide potential performance improvements compared to the standard; COL option. The performance comparison of the COL2 to the COL option depends on; the histogram and the size of the rendering region in the current pad. In general,; a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; faster with the COL option. However, for larger histograms (approx. more than 100 bins per axis); that are not sparse, the COL2 option will provide up to 20 times performance improvements.; For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; faster with the COL2 option. The COL2 option will also scale its performance based on the size of the; pixmap the histogram image is being rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; bins with zero content. The COL2 and COLZ2 options color these bins the color of zero. COL2 option renders the histogram as a bitmap. Therefore it cannot be saved in vector; graphics file format like PostScript or PDF (an empty image will be generated). It can; be saved only in bitmap files like PNG format for instance. \anchor HP140; ### The CANDLE and VIOLIN options. The mechanism behind Candle plots and Violin plots is very similar. Because of this they are; implemented in the same class TCandle. The keywords CANDLE or VIOLIN will initiate the drawing of; the corresponding plots. Followed by the keyword the user can select a plot direction (X or V for; vertical projections, or Y or H for horizontal projections) and/or predefined definitions; (1-6 for candles, ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:41760,optimiz,optimized,41760,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['optimiz'],['optimized']
Performance,"* DESCRIPTION; * open_X11_font() attempts to load and query font using Xlib calls.; * On success it goes thgroughthe codemap of the font and renders all; * the glyphs available. Glyphs then gets transfered to the client's; * memory and encoded using RLE compression. At this time smoothing; * filters are applied on glyph pixmaps, if its size exceeds threshold.; * TODO; * implement proper XFontSet support, when used with I18N enabled.; *********/; /****f* libAfterImage/asfont/get_asfont(); * NAME; * get_asfont(); * SYNOPSIS; * ASFont *get_asfont( ASFontManager *fontman,; * const char *font_string,; * int face_no, int size,; * ASFontType type );; * INPUTS; * fontman - pointer to previously created ASFontManager. Needed for; * connection to FreeType library, path to search fonts; * in, and X Server connection.; * font_string - font name or filename of the file containing font's data.; * face_no - number of face within the font file; * size - font size in points. Applicable only to scalable fonts,; * such as TrueType.; * type - specifies the type of the font, or GuessWho for; * autodetection.; * RETURN VALUE; * pointer to Opened ASFont structure, containing all the glyphs of the; * font, as well as other relevant info. On failure returns NULL.; * DESCRIPTION; * This function provides unified interface to font loading. It performs; * search in ASFontManager's list to see if this specific font has been; * loaded already, and if so - returns pointer to relevant structure.; * Otherwise it tryes to load font as FreeType font first, and then; * Xlib font, unless exact font type is specifyed.; *********/; /****f* libAfterImage/asfont/release_font(); * NAME; * release_font(); * SYNOPSIS; * void release_font( ASFont *font );; * INPUTS; * font - pointer to the valid ASFont structure containing loaded font.; * RETURN VALUE; * returns current reference count. -1 means that object has been; * destroyed.; * DESCRIPTION; * This function will decrement reference count on loaded font and",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h:2977,scalab,scalable,2977,graf2d/asimage/src/libAfterImage/asfont.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h,1,['scalab'],['scalable']
Performance,"* x.lo ^= (x.lo >> 13) | (x.hi << (32 - 13));; * x.hi ^= (x.hi >> 13);; *; * The first one is significantly faster than the second, simply because the; * shift is larger than 32. This means:; * - All the bits we need are in the upper 32 bits, so we can ignore the lower; * 32 bits in the shift.; * - The shift result will always fit in the lower 32 bits, and therefore,; * we can ignore the upper 32 bits in the xor.; *; * Thanks to this optimization, XXH3 only requires these features to be efficient:; *; * - Usable unaligned access; * - A 32-bit or 64-bit ALU; * - If 32-bit, a decent ADC instruction; * - A 32 or 64-bit multiply with a 64-bit result; * - For the 128-bit variant, a decent byteswap helps short inputs.; *; * The first two are already required by XXH32, and almost all 32-bit and 64-bit; * platforms which can run XXH32 can run XXH3 efficiently.; *; * Thumb-1, the classic 16-bit only subset of ARM's instruction set, is one; * notable exception.; *; * First of all, Thumb-1 lacks support for the UMULL instruction which; * performs the important long multiply. This means numerous __aeabi_lmul; * calls.; *; * Second of all, the 8 functional registers are just not enough.; * Setup for __aeabi_lmul, byteshift loads, pointers, and all arithmetic need; * Lo registers, and this shuffling results in thousands more MOVs than A32.; *; * A32 and T32 don't have this limitation. They can access all 14 registers,; * do a 32->64 multiply with UMULL, and the flexible operand allowing free; * shifts is helpful, too.; *; * Therefore, we do a quick sanity check.; *; * If compiling Thumb-1 for a target which supports ARM instructions, we will; * emit a warning, as it is not a ""sane"" platform to compile for.; *; * Usually, if this happens, it is because of an accident and you probably need; * to specify -march, as you likely meant to compile for a newer architecture.; *; * Credit: large sections of the vectorial and asm source code paths; * have been contributed by @easyaspi314; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:1697,perform,performs,1697,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,"['load', 'perform']","['loads', 'performs']"
Performance,"**********************************************************************. Copyright 1987, 1998 The Open Group. All Rights Reserved. The above copyright notice and this permission notice shall be included in; all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN; AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Except as contained in this notice, the name of The Open Group shall not be; used in advertising or otherwise to promote the sale, use or other dealings; in this Software without prior written authorization from The Open Group. Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts. All Rights Reserved. Permission to use, copy, modify, and distribute this software and its; documentation for any purpose and without fee is hereby granted,; provided that the above copyright notice appear in all copies and that; both that copyright notice and this permission notice appear in; supporting documentation, and that the name of Digital not be; used in advertising or publicity pertaining to distribution of the; software without specific, written prior permission. DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING; ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL; DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR; ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,; WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,; ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS; SOFTWARE. ************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPolyUtils.c:2336,PERFORM,PERFORMANCE,2336,graf2d/asimage/src/TASPolyUtils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPolyUtils.c,1,['PERFORM'],['PERFORMANCE']
Performance,"*****************************************/; /*! \class TMVA::MethodCuts; \ingroup TMVA. Multivariate optimisation of signal efficiency for given background; efficiency, applying rectangular minimum and maximum requirements. Also implemented is a ""decorrelate/diagonalized cuts approach"",; which improves over the uncorrelated cuts approach by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix. Other optimisation criteria, such as maximising the signal significance-; squared, \f$ \frac{S^2}{(S+B)} \f$, with S and B being the signal and background yields,; correspond to a particular point in the optimised background rejection; versus signal efficiency curve. This working point requires the knowledge; of the expected yields, which is not the case in general. Note also that; for rare signals, Poissonian statistics should be used, which modifies; the significance criterion. The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand). Technically, optimisation is achieved in TMVA by two methods:. 1. Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges. 2. A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results. Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima. The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway. **Decorrelated (",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCuts.cxx:2180,perform,performed,2180,tmva/tmva/src/MethodCuts.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCuts.cxx,1,['perform'],['performed']
Performance,"***************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /* \class TGedEditor; \ingroup ged. The main class of ROOT graphics editor. It manages the appearance; of objects editors according to the selected object in the canvas; (an object became selected after the user click on it using the; left-mouse button). Every object editor provides an object specific GUI and follows a; simple naming convention: it has as a name the object class name; concatenated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TGedEditor.cxx:1687,load,loaded,1687,gui/ged/src/TGedEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TGedEditor.cxx,2,"['cache', 'load']","['cached', 'loaded']"
Performance,"******************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction is correctly matched during instruction selection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:1089,load,load,1089,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,5,['load'],['load']
Performance,"*************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooMCStudy.cxx; \class RooMCStudy; \ingroup Roofitcore. Helper class to facilitate Monte Carlo studies; such as 'goodness-of-fit' studies, that involve fitting a PDF; to multiple toy Monte Carlo sets. These may be generated from either same PDF; or from a different PDF with similar parameters. Given a fit and a generator PDF (they might be identical), RooMCStudy can produce; toyMC samples and/or fit these.; It accumulates the post-fit parameters of each iteration in a dataset. These can be; retrieved using fitParams() or fitParDataSet(). This dataset additionally contains the; variables; - NLL: The value of the negative log-likelihood for each run.; - ngen: The number of events generated for each run. Additional plotting routines simplify the task of plotting; the distribution of the minimized likelihood, the fitted parameter values,; fitted error and pull distribution. RooMCStudy provides the option to insert add-in modules; that modify the generate-and-fit cycle and allow to perform; extra steps in the cycle. Output of these modules can be stored; alongside the fit results in the aggregate results dataset.; These study modules should derive from the class RooAbsMCStudyModule. Check the RooFit tutorials; - rf801_mcstudy.C; - rf802_mcstudy_addons.C; - rf803_mcstudy_addons2.C; - rf804_mcstudy_constr.C; for usage examples.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCStudy.cxx:1698,perform,perform,1698,roofit/roofitcore/src/RooMCStudy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCStudy.cxx,1,['perform'],['perform']
Performance,"**********************/; /** \class TGeoCompositeShape; \ingroup Shapes_classes. Composite shapes are Boolean combinations of two or more shape; components. The supported Boolean operations are union (+), intersection; (\*) and subtraction(-). Composite shapes derive from the base; **`TGeoShape`** class, therefore providing all shape features:; computation of bounding box, finding if a given point is inside or; outside the combination, as well as computing the distance to; entering/exiting. They can be directly used for creating volumes or used; in the definition of other composite shapes. Composite shapes are provided in order to complement and extend the set; of basic shape primitives. They have a binary tree internal structure,; therefore all shape-related geometry queries are signals propagated from; top level down to the final leaves, while the provided answers are; assembled and interpreted back at top. This `CSG`; `(composite solid geometry)` hierarchy is effective for small number of; components, while performance drops dramatically for large structures.; Building a complete geometry in this style is virtually possible but; highly not recommended. #### The Structure of Composite Shapes. A composite shape can always be looked as the result of a Boolean; operation between only two shape components. All information identifying; these two components as well as their positions with respect to the; frame of the composite is represented by an object called Boolean node.; A composite shape has a pointer to such a Boolean node. Since the shape; components may also be composites, they will also contain binary Boolean; nodes branching out other two shapes in the hierarchy. Any such branch; ends-up when the final leaves are no longer composite shapes, but basic; primitives. The figure shows the composite shapes structure. \image html geom_composite_shape001.png ""The composite shapes structure"" width=600px. Suppose that A, B, C and D represent basic shapes, we will illus",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCompositeShape.cxx:1417,perform,performance,1417,geom/geom/src/TGeoCompositeShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCompositeShape.cxx,1,['perform'],['performance']
Performance,"**********************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : SeparationBase *; * *; * *; * Description: An interface to different separation criteria used in various *; * training algorithms, as there are: *; * *; * There are two things: the Separation Index, and the Separation Gain *; * Separation Index: *; * Measure of the ""purity"" of a sample. If all elements (events) in the *; * sample belong to the same class (e.g. signal or backgr), than the *; * separation index is 0 (meaning 100% purity (or 0% purity as it is *; * symmetric. The index becomes maximal, for perfectly mixed samples *; * eg. purity=50% , N_signal = N_bkg *; * *; * Separation Gain: *; * the measure of how the quality of separation of the sample increases *; * by splitting the sample e.g. into a ""left-node"" and a ""right-node"" *; * (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right) *; * this is then the quality criterion which is optimized for when trying *; * to increase the information in the system (making the best selection *; * *; * Authors (alphabetical): *; * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; * *; * Copyright (c) 2005: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * Heidelberg U., Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; /*! \class TMVA::SeparationBase; \ingroup TMVA; An interface to calculate the ""SeparationGain"" for different; separation criteria used in various training algorithms. There are two things: the Separation Index, and the Separation Gain; Separation Index:; Measure of the ""purity"" of a sample. If all ele",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SeparationBase.cxx:1138,optimiz,optimized,1138,tmva/tmva/src/SeparationBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SeparationBase.cxx,1,['optimiz'],['optimized']
Performance,"*********; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; //////////////////////////////////////////////////////////////////////////////; /// \class RooFormulaVar; ///; /// A RooFormulaVar is a generic implementation of a real-valued object,; /// which takes a RooArgList of servers and a C++ expression string defining how; /// its value should be calculated from the given list of servers.; /// RooFormulaVar uses a RooFormula object to perform the expression evaluation.; ///; /// If RooAbsPdf objects are supplied to RooFormulaVar as servers, their; /// raw (unnormalized) values will be evaluated. Use RooGenericPdf, which; /// constructs generic PDF functions, to access their properly normalized; /// values.; ///; /// The string expression can be any valid TFormula expression referring to the; /// listed servers either by name or by their ordinal list position. These three are; /// equivalent:; /// ```; /// RooFormulaVar(""gen"", ""x*y"", RooArgList(x,y)) // reference by name; /// RooFormulaVar(""gen"", ""@0*@1"", RooArgList(x,y)) // reference by ordinal with @; /// RooFormulaVar(""gen"", ""x[0]*x[1]"", RooArgList(x,y)) // TFormula-builtin reference by ordinal; /// ```; /// Note that `x[i]` is an expression reserved for TFormula. All variable references; /// are automatically converted to the TFormula-native format. If a variable with; /// the name `x` is given, the RooFormula interprets `x[i]` as a list position,; /// but",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFormulaVar.cxx:1076,perform,perform,1076,roofit/roofitcore/src/RooFormulaVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFormulaVar.cxx,1,['perform'],['perform']
Performance,"*****/; /** \class TGeoBBox; \ingroup Shapes_classes; \brief Box class. - [Building boxes](\ref GEOB00); - [Creation of boxes](\ref GEOB01); - [Divisions of boxes](\ref GEOB02). All shape primitives inherit from this, their; constructor filling automatically the parameters of the box that bounds; the given shape. Defined by 6 parameters :. ```; TGeoBBox(Double_t dx,Double_t dy,Double_t dz,Double_t *origin=0);; ```. - `fDX`, `fDY`, `fDZ` : half lengths on X, Y and Z axis; - `fOrigin[3]` : position of box origin. \anchor GEOB00; ### Building boxes. Normally a box has to be built only with 3 parameters: `DX,DY,DZ`; representing the half-lengths on X, Y and Z-axes. In this case, the; origin of the box will match the one of its reference frame and the box; will range from: `-DX` to `DX` on X-axis, from `-DY` to `DY` on Y and; from `-DZ` to `DZ` on Z. On the other hand, any other shape needs to; compute and store the parameters of their minimal bounding box. The; bounding boxes are essential to optimize navigation algorithms.; Therefore all other primitives derive from **`TGeoBBox`**. Since the; minimal bounding box is not necessary centered in the origin, any box; allows an origin translation `(Ox`,`Oy`,`Oz)`. All primitive; constructors automatically compute the bounding box parameters. Users; should be aware that building a translated box that will represent a; primitive shape by itself would affect any further positioning of other; shapes inside. Therefore it is highly recommendable to build; non-translated boxes as primitives and translate/rotate their; corresponding volumes only during positioning stage. \anchor GEOB01; #### Creation of boxes. ```; TGeoBBox *box = new TGeoBBox(""BOX"", 20, 30, 40);; ```. Begin_Macro; {; TCanvas *c = new TCanvas(""c"", ""c"",0,0,600,600);; new TGeoManager(""box"", ""poza1"");; TGeoMaterial *mat = new TGeoMaterial(""Al"", 26.98,13,2.7);; TGeoMedium *med = new TGeoMedium(""MED"",1,mat);; TGeoVolume *top = gGeoManager->MakeBox(""TOP"",med,100,100,100);;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBBox.cxx:1481,optimiz,optimize,1481,geom/geom/src/TGeoBBox.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBBox.cxx,1,['optimiz'],['optimize']
Performance,"**/; /* ************************************************************************; * XXH3 is a new hash algorithm featuring:; * - Improved speed for both small and large inputs; * - True 64-bit and 128-bit outputs; * - SIMD acceleration; * - Improved 32-bit viability; *; * Speed analysis methodology is explained here:; *; * https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html; *; * In general, expect XXH3 to run about ~2x faster on large inputs and >3x; * faster on small ones compared to XXH64, though exact differences depend on; * the platform.; *; * The algorithm is portable: Like XXH32 and XXH64, it generates the same hash; * on all platforms.; *; * It benefits greatly from SIMD and 64-bit arithmetic, but does not require it.; *; * Almost all 32-bit and 64-bit targets that can run XXH32 smoothly can run; * XXH3 at competitive speeds, even if XXH64 runs slowly. Further details are; * explained in the implementation.; *; * Optimized implementations are provided for AVX512, AVX2, SSE2, NEON, POWER8,; * ZVector and scalar targets. This can be controlled with the XXH_VECTOR macro.; *; * XXH3 offers 2 variants, _64bits and _128bits.; * When only 64 bits are needed, prefer calling the _64bits variant, as it; * reduces the amount of mixing, resulting in faster speed on small inputs.; *; * It's also generally simpler to manipulate a scalar return type than a struct.; *; * The 128-bit version adds additional strength, but it is slightly slower.; *; * The XXH3 algorithm is still in development.; * The results it produces may still change in future versions.; *; * Results produced by v0.7.x are not comparable with results from v0.7.y.; * However, the API is completely stable, and it can safely be used for; * ephemeral data (local sessions).; *; * Avoid storing values in long-term storage until the algorithm is finalized.; * XXH3's return values will be officially finalized upon reaching v0.8.0.; *; * After which, return values of XXH3 and XXH128 will no longer ch",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:1118,Optimiz,Optimized,1118,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['Optimiz'],['Optimized']
Performance,"*y-z*z; ~~~; It mag2 is negative mag = -Sqrt(-mag*mag). The member; functions are:. ~~~ {.cpp}; Double_t s, s2;; s = v1.Dot(v2); // scalar product; s = v1*v2; // scalar product; s2 = v.Mag2(); or s2 = v.M2();; s = v.Mag(); s = v.M();; ~~~. Since in case of momentum and energy the magnitude has the meaning of; invariant mass TLorentzVector provides the more meaningful aliases; M2() and M();; The member functions Beta() and Gamma() returns; beta and gamma = 1/Sqrt(1-beta*beta).; ### Lorentz boost; A boost in a general direction can be parameterised with three parameters; which can be taken as the components of a three vector b = (bx,by,bz).; With x = (x,y,z) and gamma = 1/Sqrt(1-beta*beta) (beta being the module of vector b),; an arbitrary active Lorentz boost transformation (from the rod frame; to the original frame) can be written as:. ~~~ {.cpp}; x = x' + (gamma-1)/(beta*beta) * (b*x') * b + gamma * t' * b; t = gamma (t'+ b*x').; ~~~. The member function Boost() performs a boost transformation; from the rod frame to the original frame. BoostVector() returns; a TVector3 of the spatial components divided by the time component:. ~~~ {.cpp}; TVector3 b;; v.Boost(bx,by,bz);; v.Boost(b);; b = v.BoostVector(); // b=(x/t,y/t,z/t); ~~~. ### Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. #### rotation around axes. ~~~ {.cpp}; v.RotateX(TMath::Pi()/2.);; v.RotateY(.5);; v.RotateZ(.99);; ~~~. #### rotation around an arbitrary axis; v.Rotate(TMath::Pi()/4., v1); // rotation around v1. #### transformation from rotated frame. ~~~ {.cpp}; v.RotateUz(direction); // direction must be a unit TVector3; ~~~. #### by TRotation (see TRotation). ~~~ {.cpp}; TRotation r;; v.Transform(r); or v *= r; // Attention v=M*v; ~~~. ### Misc. #### Angle between two vectors. ~~~ {.cpp}; Double_t a = v1.Angle(v2.Vect()); // get angle between v1 and v2; ~~~. #### Light-cone components; Member functions Plus() and Minus() return the positive; and negat",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TLorentzVector.cxx:5525,perform,performs,5525,math/physics/src/TLorentzVector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TLorentzVector.cxx,1,['perform'],['performs']
Performance,"+-------+---------+------------+---------+----------+; // | 2 | 0 | 0 | 4 | 12 / 8 | 2 | 6 / 8 | yes |; // +----------+-----+-----+-------+---------+------------+---------+----------+; // | 2 | 0 | 0 | 2 | 6 / 4 | 2 | 6 / 8 | no |; // +----------+-----+-----+-------+---------+------------+---------+----------+; // | 1 | 0 | 1 | 2 | 6 / 2 | 1 | 3 / 2 | yes |; // +----------+-----+-----+-------+---------+------------+---------+----------+; //; // Some cases are of questionable benefit, like the one marked with ""yes?""; // above: fewer intrinsics and fewer vaddr and fewer total transfers between SP; // and TX, but higher vdata. We start by erring on the side of converting these; // to MSAA_LOAD.; //; // clang-format off; //; // This pass will combine intrinsics such as (not neccessarily consecutive):; // call float @llvm.amdgcn.image.load.2dmsaa.f32.i32(i32 1, i32 %s, i32 %t, i32 0, <8 x i32> %rsrc, i32 0, i32 0); // call float @llvm.amdgcn.image.load.2dmsaa.f32.i32(i32 1, i32 %s, i32 %t, i32 1, <8 x i32> %rsrc, i32 0, i32 0); // call float @llvm.amdgcn.image.load.2dmsaa.f32.i32(i32 1, i32 %s, i32 %t, i32 2, <8 x i32> %rsrc, i32 0, i32 0); // call float @llvm.amdgcn.image.load.2dmsaa.f32.i32(i32 1, i32 %s, i32 %t, i32 3, <8 x i32> %rsrc, i32 0, i32 0); // ==>; // call <4 x float> @llvm.amdgcn.image.msaa.load.2dmsaa.v4f32.i32(i32 1, i32 %s, i32 %t, i32 0, <8 x i32> %rsrc, i32 0, i32 0); //; // clang-format on; //; // Future improvements:; //; // - We may occasionally not want to do the combine if it increases the maximum; // register pressure.; //; // - Ensure clausing when multiple MSAA_LOAD are generated.; //; // Note: Even though the image_msaa_load intrinsic already exists on gfx10, this; // combine only applies to gfx11, due to a limitation in gfx10: the gfx10; // IMAGE_MSAA_LOAD only works correctly with single-channel texture formats, and; // we don't know the format at compile time.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUImageIntrinsicOptimizer.cpp:2431,load,load,2431,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUImageIntrinsicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUImageIntrinsicOptimizer.cpp,3,['load'],['load']
Performance,", Switzerland *; * Joerg Stelzer <Joerg.Stelzer@cern.ch> - CERN, Switzerland *; * Peter Speckmayer <Peter.Speckmayer@cern.ch> - CERN, Switzerland *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; * Jan Therhaag <Jan.Therhaag@cern.ch> - U of Bonn, Germany *; * Eckhard v. Toerne <evt@uni-bonn.de> - U of Bonn, Germany *; * *; * Copyright (c) 2005-2011: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; * *; **********************************************************************************/; /*! \class TMVA::MethodBase; \ingroup TMVA. Virtual base Class for all MVA method. MethodBase hosts several specific evaluation methods. The kind of MVA that provides optimal performance in an analysis strongly; depends on the particular application. The evaluation factory provides a; number of numerical benchmark results to directly assess the performance; of the MVA training on the independent test sample. These are:. - The _signal efficiency_ at three representative background efficiencies; (which is 1 &minus; rejection).; - The _significance_ of an MVA estimator, defined by the difference; between the MVA mean values for signal and background, divided by the; quadratic sum of their root mean squares.; - The _separation_ of an MVA _x_, defined by the integral; \f[; \frac{1}{2} \int \frac{(S(x) - B(x))^2}{(S(x) + B(x))} dx; \f]; where; \f$ S(x) \f$ and \f$ B(x) \f$ are the signal and background distributions,; respectively. The separation is zero for identical signal and background MVA; shapes, and it is one for disjunctive shapes.; - The average, \f$ \int x \mu (S(x)) dx \f$, of the signal \f$ \mu_{transform} \f$.; The \f$ \mu_{transform} \f$ of an MVA denotes the transfo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:1488,perform,performance,1488,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,1,['perform'],['performance']
Performance,", file search methods, message output, generic types.; * However effort has been made to allow for standalone configuration as; * well. If libAfterBase is not found at compilation time - libAfterImage; * will use extract from libAfterBase included with libAfterImage.; *; * SEE ALSO; * Examples; * API Reference; *; * TODO; * Implement support for Targa and PCX image format and maybe some other; * formats as well.; *; * Implement complete support for I18N internationalization.; *; * Implement color<->pixel conversion for all colordepths.; *; * AUTHOR; * Sasha Vasko <sasha at aftercode dot net>; *********/; /****h* libAfterImage/Examples; * EXAMPLE; * ASView - image loading from the file and displaying in window.; * ASScale - image loading from file and scaling to arbitrary size.; * ASTile - image loading from file, tiling and tinting to arbitrary; * size and color.; * ASMerge - imgae loading and merging with another image.; * ASGrad - mutlipoint gradient drawing.; * ASFlip - image loading from file and rotation.; * ASText - trexturized semitransparent antialised text drawing.; *; * SEE ALSO; * API Reference; ******/; /****h* libAfterImage/API Reference; * CHILDREN; * Headers :; * ascmap.h asfont.h asimage.h asvisual.h blender.h export.h; * import.h transform.h ximage.h; * Structures :; * ColorPair; * ASScanline; * ASVisual; * ASImage; * ASImageManager; * ASImageBevel; * ASImageDecoder; * ASImageOutput; * ASImageLayer; * ASGradient; * ASFontManager; * ASFont; * ASGlyph; * ASGlyphRange; * ASColormap; * ASImageExportParams; * ASVectorPalette; *; * Functions :; * ASScanline handling:; * 	 prepare_scanline(), free_scanline(); *; * ASVisual initialization :; * 	 query_screen_visual(), setup_truecolor_visual(),; * 	 setup_pseudo_visual(), setup_as_colormap(),; * create_asvisual(), create_asvisual_for_id(),; * 	 destroy_asvisual(); *; * ASVisual encoding/decoding :; * 	 visual2visual_prop(), visual_prop2visual(); *; * ASVisual convenience functions :; * 	 create_visual_window",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterimage.h:6204,load,loading,6204,graf2d/asimage/src/libAfterImage/afterimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterimage.h,1,['load'],['loading']
Performance,", how to build a shared library (a good; /// default will be provided). The most common change, namely where to find; /// header files, will be available through the function; /// TSystem::SetIncludePath().; /// A good default will be provided so that a typical user session should be at; /// most:; /// ~~~ {.cpp}; /// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; /// -I$HOME/mypackage/include"");; /// root[2] .x myfunc.C++(10,20);; /// ~~~; /// The user may sometimes try to compile a script before it has loaded all the; /// needed shared libraries. In this case we want to be helpful and output a; /// list of the unresolved symbols. So if the loading of the created shared; /// library fails, we will try to build a executable that contains the; /// script. The linker should then output a list of missing symbols.; ///; /// To support this we provide a TSystem::SetMakeExe() function, that sets the; /// directive telling how to create an executable. The loader will need; /// to be informed of all the libraries available. The information about; /// the libraries that has been loaded by .L and TSystem::Load() is accessible; /// to the script compiler. However, the information about; /// the libraries that have been selected at link time by the application; /// builder (like the root libraries for root.exe) are not available and need; /// to be explicitly listed in fLinkedLibs (either by default or by a call to; /// TSystem::SetLinkedLibs()).; ///; /// To simplify customization we could also add to the .rootrc support for the; /// variables; /// ~~~ {.cpp}; /// Unix.*.Root.IncludePath: -I$ROOTSYS/include; /// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; ///; /// Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; /// WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; /// ~~~; /// And also support for MakeSharedLibs() and MakeExe().; ///; /// (the ... have to be replaced by the actual values and are here only to; /// shorten this comment).; ///; /// Note th",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:4665,load,loader,4665,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['load'],['loader']
Performance,", i.e.; /// \f[; /// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; /// \f]; ///; /// The actual integration calculation is only performed when the return object is evaluated. The name; /// of the integral object is automatically constructed from the name of the input function, the variables; /// it integrates and the range integrates over. The default strategy to calculate the running integrals is; ///; /// - If the integrand (this object) supports analytical integration, construct an integral object; /// that calculate the running integrals value by calculating the analytical integral each; /// time the running integral object is evaluated; ///; /// - If the integrand (this object) requires numeric integration to construct the running integral; /// create an object of class RooNumRunningInt which first samples the entire function and integrates; /// the sampled function numerically. This method has superior performance as there is no need to; /// perform a full (numeric) integration for each evaluation of the running integral object, but; /// only when one of its parameters has changed.; ///; /// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; /// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); /// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; /// granularity for the scanning technique can be controlled with the ScanParameters technique; /// which allows to specify the number of samples to be taken, and to which order the resulting; /// running integral should be interpolated. The default values are 1000 samples and 2nd order; /// interpolation.; ///; /// The following named arguments are accepted; /// | | Effect on integral creation; /// |-|-------------------------------; /// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in addition_ to the integration observables; /// | `ScanParameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:1121,perform,performance,1121,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,2,['perform'],"['perform', 'performance']"
Performance,", the name of the; /// remainder state follows the syntax `""{State1;State2}""`, where `State1` and; /// `State2` are the state names of the two spitting categories.; ///; /// ## Splitting multiple PDFs; /// The examples so far deal with a single prototype PDF. It is also; /// possible to build with multiple prototype PDFs by specifying a; /// mapping between the prototype to use and the names of states of; /// a ""master"" splitting category. To specify these configurations,; /// an intermediate `MultiBuildConfig` must be composed with all; /// the necessary specifications. This, for example,; /// ```; /// RooSimWSTool::MultiBuildConfig mbc(""mc"");; /// mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c""));; /// mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d""));; /// ```; /// configures a build with two prototype PDFs \f$ G \f$ and \f$ F \f$.; /// Prototype \f$ G \f$ is used for state `""I""` of the master split category; /// `mc` and prototype \f$ F \f$ is used for states `""II""` and `""III""` of the; /// master split category `mc`. Furthermore, the parameters \f$ m,s \f$ of; /// prototype \f$ G \f$ are split; /// in category \f$ c \f$ while the parameter \f$ a \f$ of prototype \f$ F \f$ is split in; /// the product of the categories \f$ c \f$ and \f$ d \f$. The actual build is then; /// performed by passing the build configuration to RooSimWSTool, *e.g.*,; /// ```; /// wst.build(""MASTER"", mbc);; /// ```; /// By default, a specialisation is built for each permutation of; /// states of the splitting categories that are used. It is possible; /// to restrict the building of specialised PDFs to a subset of states; /// by adding a restriction on the number of states to build as follows:; /// ```; /// mbc.restrictBuild(""c"",""A,B"");; /// ```; /// The restrictBuild method can be called multiple times, but at most; /// once for each splitting category in use. For simple builds with a single; /// prototype, restriction can be specified with a Restrict() argument; /// on the build command line.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimWSTool.cxx:4206,perform,performed,4206,roofit/roofitcore/src/RooSimWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimWSTool.cxx,1,['perform'],['performed']
Performance,", under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a pass to prepare loops for ppc preferred addressing; // modes, leveraging different instruction form. (eg: DS/DQ form, D/DS form with; // update); // Additional PHIs are created for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like this:; //; // char *p;; // A1 = p + base1; // A2 = p + base1 + offset; // B1 = p + base2; // B2 = p + base2 + offs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:1310,load,load,1310,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['load'],['load']
Performance,",-1,""#pi"");; f->Draw();; }; End_Macro. \anchor GA11; ## Number of divisions optimisation. By default the number of divisions on axis is optimised to show a coherent; labelling of the main tick marks. The number of division (`ndiv`) is a; composite integer given by:. ` ndiv = N1 + 100*N2 + 10000*N3`. - `N1` = number of 1st divisions.; - `N2` = number of 2nd divisions.; - `N3` = number of 3rd divisions. by default the value of `N1`, `N2` and `N3` are maximum; values. After optimisation the real number of divisions will be smaller or; equal to these value. If one wants to bypass the optimisation, the option `""N""`; should be given when the `TGaxis` is created. The option `""I""`; also act on the number of division as it will force an integer labelling of; the axis. On an histogram pointer `h` the number of divisions can be set in different ways:. - Directly on the histogram. The following will set the number of division; to 510 on the X axis of `h`. To avoid optimization the number of divisions; should be negative (ie: -510);; ~~~ {.cpp}; h->SetNdivisions(510, ""X"");; ~~~; - On the axis itself:; ~~~ {.cpp}; h->GetXaxis()->SetNdivisions(510, kTRUE);; ~~~. The first parameter is the number of division. If it is negative of if the; second parameter is kFALSE then the number of divisions is not optimised.; And other signature is also allowed:; ~~~ {.cpp}; h->GetXaxis()->SetNdivisions(10, 5, 0, kTRUE);; ~~~; \anchor GA12; ## Maximum Number of Digits for the axis labels. The static method `TGaxis::SetMaxDigits` sets the maximum number of; digits permitted for the axis labels above which the notation with 10^N is used.; For example, to accept 6 digits number like 900000 on an axis call; `TGaxis::SetMaxDigits(6)`. The default value is 5.; `fgMaxDigits` must be greater than 0.; Warning: even when called on a particular TGaxis* instance, this static function; changes globally the number of digits for all axes (X, Y, ...) in the canvas.; If you want to change the maximum number of di",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TGaxis.cxx:11285,optimiz,optimization,11285,graf2d/graf/src/TGaxis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TGaxis.cxx,1,['optimiz'],['optimization']
Performance,",; * or if an event occurs on one of the pipes being polled, whichever; * happens earlier.; *; * Pipes is a vector of one or more PollEntries, which each list a pipe; * and events to poll for. If events is left empty (zero), all; * conditions are polled for, otherwise only the indicated ones. On; * return, the revents fields contain the events that occurred for each; * pipe; error Error, EndOfFile or Invalid events are always set,; * regardless of whether they were in the set of requested events.; *; * poll may block slightly longer than specified by timeout due to OS; * timer granularity and OS scheduling. Due to its implementation, the; * poll call can also return early if the remote end of the page sends; * a free page while polling (which is put on that pipe's freelist),; * while that pipe is polled for e.g Reading. The status of the pipe is; * indicated correctly in revents, and the caller can simply poll; * again. (The reason this is done this way is because it helps to; * replenish the pool of free pages and queue busy pages without; * blocking.); *; * Here's a piece of example code waiting on two pipes; if they become; * readable they are read:; * @code; * #include <unistd.h>; * #include <cstdlib>; * #include <string>; * #include <sstream>; * #include <iostream>; *; * #include ""BidirMMapPipe.h""; *; * // what to execute in the child; * int randomchild(BidirMMapPipe& pipe); * {; * ::srand48(::getpid());; * for (int i = 0; i < 5; ++i) {; * // sleep a random time between 0 and .9 seconds; * ::usleep(int(1e6 * ::drand48()));; * std::ostringstream buf;; * buf << ""child pid "" << ::getpid() << "" sends message "" << i;; * std::cout << ""[CHILD] : "" << buf.str() << std::endl;; * pipe << buf.str() << BidirMMapPipe::flush;; * if (!pipe) return -1;; * if (pipe.eof()) break;; * }; * // tell parent we're done; * pipe << """" << BidirMMapPipe::flush;; * // wait for parent to acknowledge; * std::string s;; * pipe >> s;; * pipe.close();; * return 0;; * }; *; * // function to spawn",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:1546,queue,queue,1546,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,1,['queue'],['queue']
Performance,"-*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that collect the Linker Optimization Hint (LOH).; // This pass should be run at the very end of the compilation flow, just before; // assembly printer.; // To be useful for the linker, the LOH must be printed into the assembly file.; //; // A LOH describes a sequence of instructions that may be optimized by the; // linker.; // This same sequence cannot be optimized by the compiler because some of; // the information will be known at link time.; // For instance, consider the following sequence:; // L1: adrp xA, sym@PAGE; // L2: add xB, xA, sym@PAGEOFF; // L3: ldr xC, [xB, #imm]; // This sequence can be turned into:; // A literal load if sym@PAGE + sym@PAGEOFF + #imm - address(L3) is < 1MB:; // L3: ldr xC, sym+#imm; // It may also be turned into either the following more efficient; // code sequences:; // - If sym@PAGEOFF + #imm fits the encoding space of L3.; // L1: adrp xA, sym@PAGE; // L3: ldr xC, [xB, sym@PAGEOFF + #imm]; // - If sym@PAGE + sym@PAGEOFF - address(L1) < 1MB:; // L1: adr xA, sym; // L3: ldr xC, [xB, #imm]; //; // To be valid a LOH must meet all the requirements needed by all the related; // possible linker transformations.; // For instance, using the running example, the constraints to emit; // "".loh AdrpAddLdr"" are:; // - L1, L2, and L3 instructions are of the expected type, i.e.,; // respectively ADRP, ADD (immediate), and LD.; // - The result of L1 is used only by L2.; // - The register argument (xA) used in the ADD instruction is defined; // only by L1.; // - The result of L2 is used only by L3.; // - The base address (xB) in L3 is defined only L2.; // - The ADRP in L1 and the ADD in L2 must reference the same s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp:1045,load,load,1045,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp,1,['load'],['load']
Performance,"----+; // | i386 | 64 | https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf |; // | i486 | 16 | ""four doublewords"" (doubleword = 32 bits, 4 bits * 32 bits = 16 bytes) https://en.wikichip.org/w/images/d/d3/i486_MICROPROCESSOR_HARDWARE_REFERENCE_MANUAL_%281990%29.pdf and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.4216&rep=rep1&type=pdf (page 29) |; // | i586/Pentium MMX | 32 | https://www.7-cpu.com/cpu/P-MMX.html |; // | i686/Pentium | 32 | https://www.7-cpu.com/cpu/P6.html |; // | Netburst/Pentium4 | 64 | https://www.7-cpu.com/cpu/P4-180.html |; // | Atom | 64 | https://www.7-cpu.com/cpu/Atom.html |; // | Westmere | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/sandy_bridge_(client) ""Cache Architecture"" |; // | Sandy Bridge | 64 | https://en.wikipedia.org/wiki/Sandy_Bridge and https://www.7-cpu.com/cpu/SandyBridge.html |; // | Ivy Bridge | 64 | https://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ and https://www.7-cpu.com/cpu/IvyBridge.html |; // | Haswell | 64 | https://www.7-cpu.com/cpu/Haswell.html |; // | Broadwell | 64 | https://www.7-cpu.com/cpu/Broadwell.html |; // | Skylake (including skylake-avx512) | 64 | https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html ""Cache Hierarchy"" |; // | Cascade Lake | 64 | https://www.nas.nasa.gov/hecc/support/kb/cascade-lake-processors_579.html ""Cache Hierarchy"" |; // | Skylake | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/kaby_lake ""Memory Hierarchy"" |; // | Ice Lake | 64 | https://www.7-cpu.com/cpu/Ice_Lake.html |; // | Knights Landing | 64 | https://software.intel.com/en-us/articles/intel-xeon-phi-processor-7200-family-memory-management-optimizations ""The Intel® Xeon Phi™ Processor Architecture"" |; // | Knights Mill | 64 | https://software.intel.com/sites/default/files/managed/9e/bc/64-ia-32-architectures-optimization-manual.pdf?countrylabel=Colombia ""2.5.5.2 L1 DCache "" |; // +-----------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:1547,cache,cache-replacement,1547,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,1,['cache'],['cache-replacement']
Performance,"-------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+; // | i386 | 64 | https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf |; // | i486 | 16 | ""four doublewords"" (doubleword = 32 bits, 4 bits * 32 bits = 16 bytes) https://en.wikichip.org/w/images/d/d3/i486_MICROPROCESSOR_HARDWARE_REFERENCE_MANUAL_%281990%29.pdf and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.4216&rep=rep1&type=pdf (page 29) |; // | i586/Pentium MMX | 32 | https://www.7-cpu.com/cpu/P-MMX.html |; // | i686/Pentium | 32 | https://www.7-cpu.com/cpu/P6.html |; // | Netburst/Pentium4 | 64 | https://www.7-cpu.com/cpu/P4-180.html |; // | Atom | 64 | https://www.7-cpu.com/cpu/Atom.html |; // | Westmere | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/sandy_bridge_(client) ""Cache Architecture"" |; // | Sandy Bridge | 64 | https://en.wikipedia.org/wiki/Sandy_Bridge and https://www.7-cpu.com/cpu/SandyBridge.html |; // | Ivy Bridge | 64 | https://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ and https://www.7-cpu.com/cpu/IvyBridge.html |; // | Haswell | 64 | https://www.7-cpu.com/cpu/Haswell.html |; // | Broadwell | 64 | https://www.7-cpu.com/cpu/Broadwell.html |; // | Skylake (including skylake-avx512) | 64 | https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html ""Cache Hierarchy"" |; // | Cascade Lake | 64 | https://www.nas.nasa.gov/hecc/support/kb/cascade-lake-processors_579.html ""Cache Hierarchy"" |; // | Skylake | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/kaby_lake ""Memory Hierarchy"" |; // | Ice Lake | 64 | https://www.7-cpu.com/cpu/Ice_Lake.html |; // | Knights Landing | 64 | https://software.intel.com/en-us/articles/intel-xeon-phi-processor-7200-family-memory-management-optimizations ""The Intel® Xeon Phi™ Processor Arch",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:1343,Cache,Cache,1343,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,1,['Cache'],['Cache']
Performance,"------------------------------------------------===//; //; // This pass abstracted struct/union member accesses in order to support; // compile-once run-everywhere (CO-RE). The CO-RE intends to compile the program; // which can run on different kernels. In particular, if bpf program tries to; // access a particular kernel data structure member, the details of the; // intermediate member access will be remembered so bpf loader can do; // necessary adjustment right before program loading.; //; // For example,; //; // struct s {; // int a;; // int b;; // };; // struct t {; // struct s c;; // int d;; // };; // struct t e;; //; // For the member access e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is introduced:; // uint32_t __builtin_preserve_field_info(member_access, info_kind); // In IR, a chain with two (or more) intrinsic calls will be generated:; // ...; // addr = preserve_struct_access_index(base, 1, 1) !struct s; // uint32_t result = bpf_preserve_field_info(addr, info_kind); //; // Suppose the info_kind is FI",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:1402,load,loader,1402,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,1,['load'],['loader']
Performance,"-----------------------------------------===//; //; // Stack Coloring reduces stack usage by merging stack slots when they; // can't be used together. For example, consider the following C program:; //; // void bar(char *, int);; // void foo(bool var) {; // A: {; // char z[4096];; // bar(z, 0);; // }; //; // char *p;; // char x[4096];; // char y[4096];; // if (var) {; // p = x;; // } else {; // bar(y, 1);; // p = y + 1024;; // }; // B:; // bar(p, 2);; // }; //; // Naively-compiled, this program would use 12k of stack space. However, the; // stack slot corresponding to `z` is always destroyed before either of the; // stack slots for `x` or `y` are used, and then `x` is only used if `var`; // is true, while `y` is only used if `var` is false. So in no time are 2; // of the stack slots used together, and therefore we can merge them,; // compiling the function using only a single 4k alloca:; //; // void foo(bool var) { // equivalent; // char x[4096];; // char *p;; // bar(x, 0);; // if (var) {; // p = x;; // } else {; // bar(x, 1);; // p = x + 1024;; // }; // bar(p, 2);; // }; //; // This is an important optimization if we want stack space to be under; // control in large functions, both open-coded ones and ones created by; // inlining.; //; // Implementation Notes:; // ---------------------; //; // An important part of the above reasoning is that `z` can't be accessed; // while the latter 2 calls to `bar` are running. This is justified because; // `z`'s lifetime is over after we exit from block `A:`, so any further; // accesses to it would be UB. The way we represent this information; // in LLVM is by having frontends delimit blocks with `lifetime.start`; // and `lifetime.end` intrinsics.; //; // The effect of these intrinsics seems to be as follows (maybe I should; // specify this in the reference?):; //; // L1) at start, each stack-slot is marked as *out-of-scope*, unless no; // lifetime intrinsic refers to that stack slot, in which case; // it is marked as *in-scope*.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:1256,optimiz,optimization,1256,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['optimiz'],['optimization']
Performance,"----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // TLDR: replaces llvm.preserve.static.offset + GEP + load / store; // with llvm.bpf.getelementptr.and.load / store; //; // This file implements BPFPreserveStaticOffsetPass transformation.; // This transformation address two BPF verifier specific issues:; //; // (a) Access to the fields of some structural types is allowed only; // using load and store instructions with static immediate offsets.; //; // Examples of such types are `struct __sk_buff` and `struct; // bpf_sock_ops`. This is so because offsets of the fields of; // these structures do not match real offsets in the running; // kernel. During BPF program load LDX and STX instructions; // referring to the fields of these types are rewritten so that; // offsets match real offsets. For this rewrite to happen field; // offsets have to be encoded as immediate operands of the; // instructions.; //; // See kernel/bpf/verifier.c:convert_ctx_access function in the; // Linux kernel source tree for details.; //; // (b) Pointers to context parameters of BPF programs must not be; // modified before access.; //; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for cases (a) and (b) to work the sequence %x-%y above h",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:1000,load,load,1000,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,1,['load'],['load']
Performance,"----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to con",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1129,optimiz,optimizations,1129,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['optimiz'],['optimizations']
Performance,"---------------------===//; //; // Overview:; // ---------; // Function Specialization is a transformation which propagates the constant; // parameters of a function call from the caller to the callee. It is part of; // the Inter-Procedural Sparse Conditional Constant Propagation (IPSCCP) pass.; // The transformation runs iteratively a number of times which is controlled; // by the option `funcspec-max-iters`. Running it multiple times is needed; // for specializing recursive functions, but also exposes new opportunities; // arising from specializations which return constant values or contain calls; // which can be specialized.; //; // Function Specialization supports propagating constant parameters like; // function pointers, literal constants and addresses of global variables.; // By propagating function pointers, indirect calls become direct calls. This; // exposes inlining opportunities which we would have otherwise missed. That's; // why function specialization is run before the inliner in the optimization; // pipeline; that is by design.; //; // Cost Model:; // -----------; // The cost model facilitates a utility for estimating the specialization bonus; // from propagating a constant argument. This is the InstCostVisitor, a class; // that inherits from the InstVisitor. The bonus itself is expressed as codesize; // and latency savings. Codesize savings means the amount of code that becomes; // dead in the specialization from propagating the constant, whereas latency; // savings represents the cycles we are saving from replacing instructions with; // constant values. The InstCostVisitor overrides a set of `visit*` methods to; // be able to handle different types of instructions. These attempt to constant-; // fold the instruction in which case a constant is returned and propagated; // further.; //; // Function pointers are not handled by the InstCostVisitor. They are treated; // separately as they could expose inlining opportunities via indirect call; // promoti",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h:1362,optimiz,optimization,1362,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h,1,['optimiz'],['optimization']
Performance,"---------------------===//; //; /// \file; /// Copies from VGPR to SGPR registers are illegal and the register coalescer; /// will sometimes generate these illegal copies in situations like this:; ///; /// Register Class <vsrc> is the union of <vgpr> and <sgpr>; ///; /// BB0:; /// %0 <sgpr> = SCALAR_INST; /// %1 <vsrc> = COPY %0 <sgpr>; /// ...; /// BRANCH %cond BB1, BB2; /// BB1:; /// %2 <vgpr> = VECTOR_INST; /// %3 <vsrc> = COPY %2 <vgpr>; /// BB2:; /// %4 <vsrc> = PHI %1 <vsrc>, <%bb.0>, %3 <vrsc>, <%bb.1>; /// %5 <vgpr> = VECTOR_INST %4 <vsrc>; ///; ///; /// The coalescer will begin at BB0 and eliminate its copy, then the resulting; /// code will look like this:; ///; /// BB0:; /// %0 <sgpr> = SCALAR_INST; /// ...; /// BRANCH %cond BB1, BB2; /// BB1:; /// %2 <vgpr> = VECTOR_INST; /// %3 <vsrc> = COPY %2 <vgpr>; /// BB2:; /// %4 <sgpr> = PHI %0 <sgpr>, <%bb.0>, %3 <vsrc>, <%bb.1>; /// %5 <vgpr> = VECTOR_INST %4 <sgpr>; ///; /// Now that the result of the PHI instruction is an SGPR, the register; /// allocator is now forced to constrain the register class of %3 to; /// <sgpr> so we end up with final code like this:; ///; /// BB0:; /// %0 <sgpr> = SCALAR_INST; /// ...; /// BRANCH %cond BB1, BB2; /// BB1:; /// %2 <vgpr> = VECTOR_INST; /// %3 <sgpr> = COPY %2 <vgpr>; /// BB2:; /// %4 <sgpr> = PHI %0 <sgpr>, <%bb.0>, %3 <sgpr>, <%bb.1>; /// %5 <vgpr> = VECTOR_INST %4 <sgpr>; ///; /// Now this code contains an illegal copy from a VGPR to an SGPR.; ///; /// In order to avoid this problem, this pass searches for PHI instructions; /// which define a <vsrc> register and constrains its definition class to; /// <vgpr> if the user of the PHI's definition register is a vector instruction.; /// If the PHI's definition class is constrained to <vgpr> then the coalescer; /// will be unable to perform the COPY removal from the above example which; /// ultimately led to the creation of an illegal COPY.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFixSGPRCopies.cpp:2157,perform,perform,2157,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFixSGPRCopies.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFixSGPRCopies.cpp,1,['perform'],['perform']
Performance,"-------------------===//; //; // The LoopPredication pass tries to convert loop variant range checks to loop; // invariant by widening checks across loop iterations. For example, it will; // convert; //; // for (i = 0; i < n; i++) {; // guard(i < len);; // ...; // }; //; // to; //; // for (i = 0; i < n; i++) {; // guard(n - 1 < len);; // ...; // }; //; // After this transformation the condition of the guard is loop invariant, so; // loop-unswitch can later unswitch the loop by this condition which basically; // predicates the loop by the widened condition:; //; // if (n - 1 < len); // for (i = 0; i < n; i++) {; // ...; // }; // else; // deoptimize; //; // It's tempting to rely on SCEV here, but it has proven to be problematic.; // Generally the facts SCEV provides about the increment step of add; // recurrences are true if the backedge of the loop is taken, which implicitly; // assumes that the guard doesn't fail. Using these facts to optimize the; // guard results in a circular logic where the guard is optimized under the; // assumption that it never fails.; //; // For example, in the loop below the induction variable will be marked as nuw; // basing on the guard. Basing on nuw the guard predicate will be considered; // monotonic. Given a monotonic condition it's tempting to replace the induction; // variable in the condition with its value on the last iteration. But this; // transformation is not correct, e.g. e = 4, b = 5 breaks the loop.; //; // for (int i = b; i != e; i++); // guard(i u< len); //; // One of the ways to reason about this problem is to use an inductive proof; // approach. Given the loop:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + Step; // guard(G(I));; // } while (B(I));; // }; //; // where B(x) and G(x) are predicates that map integers to booleans, we want a; // loop invariant expression M such the following program has the same semantics; // as the above:; //; // if (B(0)) {; // do {; // I = PHI(0, I.INC); // I.INC = I + ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:1299,optimiz,optimize,1299,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,2,['optimiz'],"['optimize', 'optimized']"
Performance,"-----------------; /// The core of the Dwarf linking logic.; ///; /// The generation of the dwarf information from the object files will be; /// driven by the selection of 'root DIEs', which are DIEs that; /// describe variables or functions that resolves to the corresponding; /// code section(and thus have entries in the Addresses map). All the debug; /// information that will be generated(the DIEs, but also the line; /// tables, ranges, ...) is derived from that set of root DIEs.; ///; /// The root DIEs are identified because they contain relocations that; /// points to code section(the low_pc for a function, the location for; /// a variable). These relocations are gathered as a very first step; /// when we start processing a object file by AddressesMap.; ///; /// The overall linking process looks like this:; ///; /// parrallel_for_each(ObjectFile) {; /// for_each (Compile Unit) {; /// 1. Load Clang modules.; /// }; ///; /// parrallel_for_each(Compile Unit) {; /// 1. Load input DWARF for Compile Unit.; /// 2. Report warnings for Clang modules.; /// 3. Analyze live DIEs and type names(if ODR deduplication is requested).; /// 4. Clone DIEs(Generate output DIEs and resulting DWARF tables).; /// The result is in an OutDebugInfoBytes, which is an ELF file; /// containing DWARF tables corresponding to the current compile unit.; /// 5. Cleanup Input and Output DIEs.; /// }; ///; /// Deallocate loaded Object file.; /// }; ///; /// if (ODR deduplication is requested); /// Generate an artificial compilation unit (""Type Table"": used to partially; /// generate DIEs at the clone stage).; ///; /// for_each (ObjectFile) {; /// for_each (Compile Unit) {; /// 1. Set offsets to Compile Units DWARF tables.; /// 2. Sort offsets/attributes/patches to have a predictable result.; /// 3. Patch size/offsets fields.; /// 4. Generate index tables.; /// 5. Move DWARF tables of compile units into the resulting file.; /// }; /// }; ///; /// Every compile unit is processed separately, visited on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h:1037,Load,Load,1037,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h,1,['Load'],['Load']
Performance,"----------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us to vectorize/parallelize; // both loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1591,load,load,1591,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['load'],['load']
Performance,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1486,Optimiz,Optimize,1486,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,6,"['Load', 'Optimiz', 'load']","['Loads', 'Optimize', 'load', 'loads']"
Performance,"-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push; // the children nodes to the queue via `static bool; // IsStructurallyEq",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:1121,queue,queue,1121,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,1,['queue'],['queue']
Performance,"-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing passes over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reac",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:1179,optimiz,optimizations,1179,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['optimiz'],['optimizations']
Performance,"-K Heidelberg, Germany *; * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; * *; * Copyright (c) 2005: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * LAPP, Annecy, France *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; /*! \class TMVA::MethodCFMlpANN; \ingroup TMVA. Interface to Clermond-Ferrand artificial neural network. The CFMlpANN belong to the class of Multilayer Perceptrons (MLP), which are; feed-forward networks according to the following propagation schema:. \image html tmva_mlp.png Schema for artificial neural network. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of <i>k</i> hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.). As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. The learning method used by the CFMlpANN is only stochastic.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCFMlpANN.cxx:2029,perform,performed,2029,tmva/tmva/src/MethodCFMlpANN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCFMlpANN.cxx,1,['perform'],['performed']
Performance,"-origins) and is; /// disabled by default.; ///; /// Origins are 4-byte values created and interpreted by the runtime library.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memory. Propagation of origins is basically a bunch of; /// ""select"" instructions that pick the origin of a dirty argument, if an; /// instruction has one.; ///; /// Every 4 aligned, consecutive bytes of application memory have one origin; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work v",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3535,perform,performance,3535,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['perform'],['performance']
Performance,". For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias analysis in codegen).; // Such transformation can have following benefits:; // (1) It can always extract constants in the indices of structure type.; // (2) After such Lowering, there are more optimization opportunities such as; // CSE, LICM and CGP.; //; // E.g. The following GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:3498,optimiz,optimization,3498,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,1,['optimiz'],['optimization']
Performance,". Multiple ones are possible; FSE_DTable* DTablePtr; // Decoding table, provided by FSE_buildDTable(). The first thing to do is to init the bitStream.; errorCode = BIT_initDStream(&DStream, srcBuffer, srcSize);. You should then retrieve your initial state(s); (in reverse flushing order if you have several ones) :; errorCode = FSE_initDState(&DState, &DStream, DTablePtr);. You can then decode your data, symbol after symbol.; For information the maximum number of bits read by FSE_decodeSymbol() is 'tableLog'.; Keep in mind that symbols are decoded in reverse order, like a LIFO stack (last in, first out).; unsigned char symbol = FSE_decodeSymbol(&DState, &DStream);. You can retrieve any bitfield you eventually stored into the bitStream (in reverse order); Note : maximum allowed nbBits is 25, for 32-bits compatibility; size_t bitField = BIT_readBits(&DStream, nbBits);. All above operations only read from local register (which size depends on size_t).; Refueling the register from memory is manually performed by the reload method.; endSignal = FSE_reloadDStream(&DStream);. BIT_reloadDStream() result tells if there is still some more data to read from DStream.; BIT_DStream_unfinished : there is still some data left into the DStream.; BIT_DStream_endOfBuffer : Dstream reached end of buffer. Its container may no longer be completely filled.; BIT_DStream_completed : Dstream reached its exact end, corresponding in general to decompression completed.; BIT_DStream_tooFar : Dstream went too far. Decompression result is corrupted. When reaching end of buffer (BIT_DStream_endOfBuffer), progress slowly, notably if you decode multiple symbols per loop,; to properly detect the exact end of stream.; After each decoded symbol, check if DStream is fully consumed using this simple test :; BIT_reloadDStream(&DStream) >= BIT_DStream_completed. When it's done, verify decompression is fully completed, by checking both DStream and the relevant states.; Checking if DStream has reached its end i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:1360,perform,performed,1360,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['perform'],['performed']
Performance,". Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like; ; \verbatim; class MyGenerator : public TGenerator ; { ; public: ; static MyGenerator* Instance() ; { ; if (!fgInstance) fgInstance = new MyGenerator; ; return fgInstance; ; } ; void GenerateEvent() { ... } ; void ImportParticles(TClonesArray* a, Option_t opt="""") {...} ; Int_t ImportParticles(Option_t opt="""") { ... } ; Int_t SetParameter(const char* name, Double_t val) { ... } ; Double_t GetParameter(const char* name) { ... } ; virtual ~MyGenerator() { ... } ; protected: ; MyGenerator() { ... } ; MyGenerator(const MyGenerator& o) { ... } ; MyGenerator& operator=(const MyGenerator& o) { ... } ; static MyGenerator* fgInstance; ; ClassDefOverride(MyGenerator,0); ; }; ; \endverbatim; ; Having multiple objects accessing the same common blocks is not ; safe. ; ; Concrete TGenerator classes can be loaded in scripts and subseqent- ; ly used in compiled code: ; ; \verbatim; // MyRun.h ; class MyRun : public TObject ; { ; public: ; static MyRun* Instance() { ... } ; void SetGenerator(TGenerator* g) { fGenerator = g; } ; void Run(Int_t n, Option_t* option="""") ; { ; TFile* file = TFile::Open(""file.root"",""RECREATE""); ; TTree* tree = new TTree(""T"",""T""); ; TClonesArray* p = new TClonesArray(""TParticles""); ; tree->Branch(""particles"", &p); ; for (Int_t event = 0; event < n; event++) { ; fGenerator->GenerateEvent(); ; fGenerator->ImportParticles(p,option); ; tree->Fill(); ; } ; file->Write(); ; file->Close(); ; } ; ... ; protected: ; TGenerator* fGenerator; ; ClassDefOverride(MyRun,0); ; }; ; ; // Config.C ; void Config() ; { ; MyRun* run = MyRun::Instance(); ; run->SetGenerator(MyGenerator::Instance()); ; } ; ; // main.cxx ; int ; main(int argc, char** argv) ; { ; TApplication app("""", 0, 0); ; gSystem->ProcessLine("".x Config.C""); ; MyRun::Instance()->Run(10); ; return 0; ; } ; \endverbatim; ; This is especially",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/src/TGenerator.cxx:2954,load,loaded,2954,montecarlo/eg/src/TGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/src/TGenerator.cxx,1,['load'],['loaded']
Performance,". The most common change, namely where to find; /// header files, will be available through the function; /// TSystem::SetIncludePath().; /// A good default will be provided so that a typical user session should be at; /// most:; /// ~~~ {.cpp}; /// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; /// -I$HOME/mypackage/include"");; /// root[2] .x myfunc.C++(10,20);; /// ~~~; /// The user may sometimes try to compile a script before it has loaded all the; /// needed shared libraries. In this case we want to be helpful and output a; /// list of the unresolved symbols. So if the loading of the created shared; /// library fails, we will try to build a executable that contains the; /// script. The linker should then output a list of missing symbols.; ///; /// To support this we provide a TSystem::SetMakeExe() function, that sets the; /// directive telling how to create an executable. The loader will need; /// to be informed of all the libraries available. The information about; /// the libraries that has been loaded by .L and TSystem::Load() is accessible; /// to the script compiler. However, the information about; /// the libraries that have been selected at link time by the application; /// builder (like the root libraries for root.exe) are not available and need; /// to be explicitly listed in fLinkedLibs (either by default or by a call to; /// TSystem::SetLinkedLibs()).; ///; /// To simplify customization we could also add to the .rootrc support for the; /// variables; /// ~~~ {.cpp}; /// Unix.*.Root.IncludePath: -I$ROOTSYS/include; /// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; ///; /// Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; /// WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; /// ~~~; /// And also support for MakeSharedLibs() and MakeExe().; ///; /// (the ... have to be replaced by the actual values and are here only to; /// shorten this comment).; ///; /// Note that the default behavior is to remove libraries when closing ROOT,; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:4789,load,loaded,4789,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['load'],['loaded']
Performance,".0.4 10004; * 1.0.4a-f 10005; * 1.0.5 (+ 2 patches) 10005; * 1.0.5a-d 10006; * 1.0.5e-r 10100 (not source compatible); * 1.0.5s-v 10006 (not binary compatible); * 1.0.6 (+ 3 patches) 10006 (still binary incompatible); * 1.0.6d-f 10007 (still binary incompatible); * 1.0.6g 10007; * 1.0.6h 10007 10.6h (testing xy.z so-numbering); * 1.0.6i 10007 10.6i; * 1.0.6j 10007 2.1.0.6j (incompatible with 1.0.0); * 1.0.7beta11-14 DLLNUM 10007 2.1.0.7beta11-14 (binary compatible); * 1.0.7beta15-18 1 10007 2.1.0.7beta15-18 (binary compatible); * 1.0.7rc1-2 1 10007 2.1.0.7rc1-2 (binary compatible); * 1.0.7 1 10007 (still compatible); * ...; * 1.0.69 10 10069 10.so.0.69[.0]; * ...; * 1.2.59 13 10259 12.so.0.59[.0]; * ...; * 1.4.20 14 10420 14.so.0.20[.0]; * ...; * 1.5.30 15 10530 15.so.15.30[.0]; * ...; * 1.6.40 16 10640 16.so.16.40[.0]; *; * Henceforth the source version will match the shared-library major and; * minor numbers; the shared-library major version number will be used for; * changes in backward compatibility, as it is intended.; * The PNG_LIBPNG_VER macro, which is not used within libpng but is; * available for applications, is an unsigned integer of the form XYYZZ; * corresponding to the source version X.Y.Z (leading zeros in Y and Z).; * Beta versions were given the previous public release number plus a; * letter, until version 1.0.6j; from then on they were given the upcoming; * public release number plus ""betaNN"" or ""rcNN"".; *; * Binary incompatibility exists only when applications make direct access; * to the info_ptr or png_ptr members through png.h, and the compiled; * application is loaded with a different version of the library.; *; * DLLNUM will change each time there are forward or backward changes; * in binary compatibility (e.g., when a new feature is added).; *; * See libpng.txt or libpng.3 for more information. The PNG specification; * is available as a W3C Recommendation and as an ISO/IEC Standard; see; * <https://www.w3.org/TR/2003/REC-PNG-20031110/>; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:10116,load,loaded,10116,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['load'],['loaded']
Performance,".; /// - Stride + data_format: Element Size * Index Stride (???); /// - Cache swizzle: ???; /// - Swizzle enable: SH_STATIC_MEM_CONFIG.SWIZZLE_ENABLE (must be 1 for; /// scratch); /// - Num records: Flat Scratch Work Item Size / Element Size (???); /// - Dst_sel_*: ???; /// - Num_format: ???; /// - Element_size: SH_STATIC_MEM_CONFIG.ELEMENT_SIZE (will be DWORD, must; /// agree with amd_kernel_code_t.privateElementSize); /// - Index_stride: SH_STATIC_MEM_CONFIG.INDEX_STRIDE (will be 64 as must; /// be number of wavefront lanes for scratch, must agree with; /// amd_kernel_code_t.wavefrontSize); /// - Add tid enable: 1; /// - ATC: from SH_MEM_CONFIG.PRIVATE_ATC,; /// - Hash_enable: ???; /// - Heap: ???; /// - Mtype: from SH_STATIC_MEM_CONFIG.PRIVATE_MTYPE; /// - Type: 0 (a buffer) (???); ///; /// Dispatch Ptr (enable_sgpr_dispatch_ptr):; /// Number of User SGPR registers: 2. 64 bit address of AQL dispatch packet; /// for kernel actually executing.; ///; /// Queue Ptr (enable_sgpr_queue_ptr):; /// Number of User SGPR registers: 2. 64 bit address of AmdQueue object for; /// AQL queue on which the dispatch packet was queued.; ///; /// Kernarg Segment Ptr (enable_sgpr_kernarg_segment_ptr):; /// Number of User SGPR registers: 2. 64 bit address of Kernarg segment. This; /// is directly copied from the kernargPtr in the dispatch packet. Having CP; /// load it once avoids loading it at the beginning of every wavefront.; ///; /// Dispatch Id (enable_sgpr_dispatch_id):; /// Number of User SGPR registers: 2. 64 bit Dispatch ID of the dispatch; /// packet being executed.; ///; /// Flat Scratch Init (enable_sgpr_flat_scratch_init):; /// Number of User SGPR registers: 2. This is 2 SGPRs.; ///; /// For CI/VI:; /// The first SGPR is a 32 bit byte offset from SH_MEM_HIDDEN_PRIVATE_BASE; /// to base of memory for scratch for this dispatch. This is the same offset; /// used in computing the Scratch Segment Buffer base address. The value of; /// Scratch Wave Offset must be added by the ke",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:2818,Queue,Queue,2818,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['Queue'],['Queue']
Performance,"/ ); //; // What you do inside of that function is up to you, but it will usually; // involve generating C++ code to the provided raw_ostream.; //; // The RecordKeeper is just a top-level container for an in-memory; // representation of the data encoded in the TableGen file. What a TableGen; // backend does is walk around that in-memory representation and generate; // stuff based on the information it contains.; //; // The in-memory representation is a node-graph (think of it like JSON but; // with a richer ontology of types), where the nodes are subclasses of; // Record. The methods `getClass`, `getDef` are the basic interface to; // access the node-graph. RecordKeeper also provides a handy method; // `getAllDerivedDefinitions`. Consult ""include/llvm/TableGen/Record.h"" for; // the exact interfaces provided by Record's and RecordKeeper.; //; // A common pattern for TableGen backends is for the EmitFoo function to; // instantiate a class which holds some context for the generation process,; // and then have most of the work happen in that class's methods. This; // pattern partly has historical roots in the previous TableGen backend API; // that involved a class and an invocation like `FooEmitter(RK).run(OS)`.; //; // Remember to wrap private things in an anonymous namespace. For most; // backends, this means that the EmitFoo function is the only thing not in; // the anonymous namespace.; // FIXME: Reorganize TableGen so that build dependencies can be more; // accurately expressed. Currently, touching any of the emitters (or; // anything that they transitively depend on) causes everything dependent; // on TableGen to be rebuilt (this includes all the targets!). Perhaps have; // a standalone TableGen binary and have the backends be loadable modules; // of some sort; then the dependency could be expressed as being on the; // module, and all the modules would have a common dependency on the; // TableGen binary with as few dependencies as possible on the rest of; // LLVM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/TableGenBackends.h:1889,load,loadable,1889,interpreter/llvm-project/llvm/utils/TableGen/TableGenBackends.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/TableGenBackends.h,1,['load'],['loadable']
Performance,"/ . When accessing the result of an VGPR load instruction, you have to wait; // for all the VGPR load instructions previous to the VGPR load instruction; // you are interested in to finish.; // . The less the register pressure, the best load latencies are hidden; //; // Moreover some specifities (like the fact a lot of instructions in the shader; // have few dependencies) makes the generic scheduler have some unpredictable; // behaviours. For example when register pressure becomes high, it can either; // manage to prevent register pressure from going too high, or it can; // increase register pressure even more than if it hadn't taken register; // pressure into account.; //; // Also some other bad behaviours are generated, like loading at the beginning; // of the shader a constant in VGPR you won't need until the end of the shader.; //; // The scheduling problem for SI can distinguish three main parts:; // . Hiding high latencies (texture sampling, etc); // . Hiding low latencies (SGPR constant loading, etc); // . Keeping register usage low for better latency hiding and general; // performance; //; // Some other things can also affect performance, but are hard to predict; // (cache usage, the fact the HW can issue several instructions from different; // wavefronts if different types, etc); //; // This scheduler tries to solve the scheduling problem by dividing it into; // simpler sub-problems. It divides the instructions into blocks, schedules; // locally inside the blocks where it takes care of low latencies, and then; // chooses the order of the blocks by taking care of high latencies.; // Dividing the instructions into blocks helps control keeping register; // usage low.; //; // First the instructions are put into blocks.; // We want the blocks help control register usage and hide high latencies; // later. To help control register usage, we typically want all local; // computations, when for example you create a result that can be consumed; // right away, to be co",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:1379,load,loading,1379,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['load'],['loading']
Performance,"/ //; // The editor uses a standard Search dialog. You can specify a forward //; // or backward search direction starting from the current cursor //; // location according to the selection made of a case sensitive mode //; // or not. The last search can be repeated by pressing F3. //; // //; // Text Font //; // //; // You can change the text font by selecting Edit menu / Set Font. //; // The Font Dialog pops up and shows the Name, Style, and Size of any //; // available font. The selected font sample is shown in the preview //; // area. //; // //; // Executing Macros //; // //; // You can execute the currently loaded macro in the editor by //; // selecting Tools menu / Execute Macro; by clicking on the //; // corresponding toolbar button, or by using Ctrl+F5 accelerator keys. //; // This is identical to the command "".x macro.C"" in the root prompt //; // command line. //; // //; // Compiling Macros //; // //; // The currently loaded macro can be compiled with ACLiC if you select //; // Tools menu / Compile Macro; by clicking on the corresponding //; // toolbar button, or by using Ctrl+F7 accelerator keys. //; // This is identical to the command "".L macro.C++"" in the root prompt //; // command line. //; // //; // Interrupting a Running Macro //; // //; // You can interrupt a running macro by selecting the Tools menu / //; // Interrupt; by clicking on the corresponding toolbar button, or by //; // using Shift+F5 accelerator keys. //; // //; // Interface to CINT Interpreter //; // //; // Any command entered in the Command combo box will be passed to //; // the CINT interpreter. This combo box will keep the commands history //; // and will allow you to re-execute the same commands during an editor //; // session. //; // //; // Keyboard Bindings //; // //; // The following table lists the keyboard shortcuts and accelerator //; // keys. //; // //; // Key: Action: //; // ==== ======= //; // //; // Up Move cursor up. //; // Shift+Up Move cursor up and extend selection. //; /",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootIDE/TGRootIDE.cxx:3399,load,loaded,3399,test/RootIDE/TGRootIDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootIDE/TGRootIDE.cxx,1,['load'],['loaded']
Performance,"/ One key requirement for this to work is that the conditional branch is; // followed by an execution of the CSEL instruction, where the CSEL; // instruction needs to use the same flags status as the conditional branch.; // This means that the conditional branches must not be implemented as one; // of the AArch64 conditional branches that do not use the flags as input; // (CB(N)Z and TB(N)Z). This is implemented by ensuring in the instruction; // selectors to not produce these instructions when speculation hardening; // is enabled. This pass will assert if it does encounter such an instruction.; // - On function call boundaries, the miss-speculation state is transferred from; // the taint register X16 to be encoded in the SP register as value 0.; //; // For the aspect of automatically hardening loads, using the taint register,; // (a.k.a. speculative load hardening, see; // https://llvm.org/docs/SpeculativeLoadHardening.html), the following; // implementation choices are made for AArch64:; // - Many of the optimizations described at; // https://llvm.org/docs/SpeculativeLoadHardening.html to harden fewer; // loads haven't been implemented yet - but for some of them there are; // FIXMEs in the code.; // - loads that load into general purpose (X or W) registers get hardened by; // masking the loaded data. For loads that load into other registers, the; // address loaded from gets hardened. It is expected that hardening the; // loaded data may be more efficient; but masking data in registers other; // than X or W is not easy and may result in being slower than just; // hardening the X address register loaded from.; // - On AArch64, CSDB instructions are inserted between the masking of the; // register and its first use, to ensure there's no non-control-flow; // speculation that might undermine the hardening mechanism.; //; // Future extensions/improvements could be:; // - Implement this functionality using full speculation barriers, akin to the; // x86-slh-lfence option.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:4254,optimiz,optimizations,4254,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,1,['optimiz'],['optimizations']
Performance,"/ The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; /// over the two sorted arrays a and b representing empirical distribution; /// functions. The for-loop handles 3 cases: when the next points to be; /// evaluated satisfy a>b, a<b, or a=b:; ///; /// ~~~ {.cpp}; /// for (Int_t i=0;i<na+nb;i++) {; /// if (a[ia-1] < b[ib-1]) {; /// rdiff -= sa;; /// ia++;; /// if (ia > na) {ok = kTRUE; break;}; /// } else if (a[ia-1] > b[ib-1]) {; /// rdiff += sb;; /// ib++;; /// if (ib > nb) {ok = kTRUE; break;}; /// } else {; /// rdiff += sb - sa;; /// ia++;; /// ib++;; /// if (ia > na) {ok = kTRUE; break;}; /// if (ib > nb) {ok = kTRUE; break;}; /// }; /// rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; /// }; /// ~~~; ///; /// For the last case, a=b, the algorithm advances each array by one index in an; /// attempt to move through the equality. However, this is incorrect when one or; /// the other of a or b (or both) have a repeated value, call it x. For the KS; /// statistic to be computed properly, rdiff needs to be calculated after all of; /// the a and b at x have been tallied (this is due to the definition of the; /// empirical distribution function; another way to convince yourself that the; /// old CERNLIB method is wrong is that it implies that the function defined as the; /// difference between a and b is multi-valued at x -- besides being ugly, this; /// would invalidate Kolmogorov's theorem).; ///; /// The solution is to just add while-loops into the equality-case handling to; /// perform the tally:; ///; /// ~~~ {.cpp}; /// } else {; /// double x = a[ia-1];; /// while(a[ia-1] == x && ia <= na) {; /// rdiff -= sa;; /// ia++;; /// }; /// while(b[ib-1] == x && ib <= nb) {; /// rdiff += sb;; /// ib++;; /// }; /// if (ia > na) {ok = kTRUE; break;}; /// if (ib > nb) {ok = kTRUE; break;}; /// }; /// ~~~; ///; /// ### Note:; /// A good description of the Kolmogorov test can be seen at:; /// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TMath.cxx:3251,perform,perform,3251,math/mathcore/src/TMath.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TMath.cxx,1,['perform'],['perform']
Performance,"/ inst_a; // inst_b; // DBG_VALUE %2, ""x"", ...; // %2 = ld ...; // %3 = ld ...; // The code below addresses this by moving the DBG_VALUE to the position; // immediately after the load.; // Example:; // After the code below:; // inst_a; // inst_b; // %2 = ld ...; // DBG_VALUE %2, ""x"", ...; // %3 = ld ...; // The algorithm works in two phases: First RescheduleOps() populates the; // RegisterMap with registers that were moved as keys, there is no value; // inserted. In the next phase, every MachineInstr in a basic block is; // iterated over. If it is a valid DBG_VALUE or DBG_VALUE_LIST and it uses one; // or more registers in the RegisterMap, the RegisterMap and InstrMap are; // populated with the MachineInstr. If the DBG_VALUE or DBG_VALUE_LIST; // describes debug information for a variable that already exists in the; // DbgValueSinkCandidates, the MachineInstr in the DbgValueSinkCandidates must; // be set to undef. If the current MachineInstr is a load that was moved,; // undef the corresponding DBG_VALUE or DBG_VALUE_LIST and clone it to below; // the load.; // To illustrate the above algorithm visually let's take this example.; // Before the Pre Register Allocation Load Store Pass:; // %2 = ld ...; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // %4 = ld ...; // After Pre Register Allocation Load Store Pass:; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // The algorithm below does the following:; // In the beginning, the RegisterMap will have been populated with the virtual; // registers %2, and %3, the DbgValueSinkCandidates and the InstrMap will be; // empty. DbgValueSinkCandidates = {}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap {}; // -> DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the first DBG_VALUE (denoted with ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:1340,load,load,1340,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,2,['load'],['load']
Performance,"/ platform ABI's struct-layout algorithm, with the high-level goal; // of duplicating MSVC's layout. For non-bitfields, this follows; // the standard algorithm. The basic bitfield layout rule is to; // allocate an entire unit of the bitfield's declared type; // (e.g. 'unsigned long'), then parcel it up among successive; // bitfields whose declared types have the same size, making a new; // unit as soon as the last can no longer store the whole value.; // Since it completely replaces the platform ABI's algorithm,; // settings like !useBitFieldTypeAlignment() do not apply.; // A zero-width bitfield forces the use of a new storage unit for; // later bitfields. In general, this occurs by rounding up the; // current size of the struct as if the algorithm were about to; // place a non-bitfield of the field's formal type. Usually this; // does not change the alignment of the struct itself, but it does; // on some targets (those that useZeroLengthBitfieldAlignment(),; // e.g. ARM). In ms_struct layout, zero-width bitfields are; // ignored unless they follow a non-zero-width bitfield.; // A field alignment restriction (e.g. from #pragma pack) or; // specification (e.g. from __attribute__((aligned))) changes the; // formal alignment of the field. For System V, this alters the; // required alignment of the notional storage unit that must contain; // the bitfield. For ms_struct, this only affects the placement of; // new storage units. In both cases, the effect of #pragma pack is; // ignored on zero-width bitfields.; // On System V, a packed field (e.g. from #pragma pack or; // __attribute__((packed))) always uses the next available bit; // offset.; // In an ms_struct struct, the alignment of a fundamental type is; // always equal to its size. This is necessary in order to mimic; // the i386 alignment rules on targets which might not fully align; // all types (e.g. Darwin PPC32, where alignof(long long) == 4).; // First, some simple bookkeeping to perform for ms_struct structs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3197,perform,perform,3197,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['perform'],['perform']
Performance,"/ right away, to be contained in a block. Block inputs and outputs would; // typically be important results that are needed in several locations of; // the shader. Since we do want blocks to help hide high latencies, we want; // the instructions inside the block to have a minimal set of dependencies; // on high latencies. It will make it easy to pick blocks to hide specific; // high latencies.; // The block creation algorithm is divided into several steps, and several; // variants can be tried during the scheduling process.; //; // Second the order of the instructions inside the blocks is chosen.; // At that step we do take into account only register usage and hiding; // low latency instructions; //; // Third the block order is chosen, there we try to hide high latencies; // and keep register usage low.; //; // After the third step, a pass is done to improve the hiding of low; // latencies.; //; // Actually when talking about 'low latency' or 'high latency' it includes; // both the latency to get the cache (or global mem) data go to the register,; // and the bandwidth limitations.; // Increasing the number of active wavefronts helps hide the former, but it; // doesn't solve the latter, thus why even if wavefront count is high, we have; // to try have as many instructions hiding high latencies as possible.; // The OpenCL doc says for example latency of 400 cycles for a global mem; // access, which is hidden by 10 instructions if the wavefront count is 10.; // Some figures taken from AMD docs:; // Both texture and constant L1 caches are 4-way associative with 64 bytes; // lines.; // Constant cache is shared with 4 CUs.; // For texture sampling, the address generation unit receives 4 texture; // addresses per cycle, thus we could expect texture sampling latency to be; // equivalent to 4 instructions in the very best case (a VGPR is 64 work items,; // instructions in a wavefront group are executed every 4 cycles),; // or 16 instructions if the other wavefronts associate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:3293,latency,latency,3293,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,4,"['cache', 'latency']","['cache', 'latency']"
Performance,"/* !G_VA_COPY */; /* inlining hassle. for compilers that don't allow the `inline' keyword,; * mostly because of strict ANSI C compliance or dumbness, we try to fall; * back to either `__inline__' or `__inline'.; * we define G_CAN_INLINE, if the compiler seems to be actually; * *capable* to do function inlining, in which case inline function bodys; * do make sense. we also define G_INLINE_FUNC to properly export the; * function prototypes if no inlining can be performed.; * inline function bodies have to be special cased with G_CAN_INLINE and a; * .c file specific macro to allow one compiled instance with extern linkage; * of the functions by defining G_IMPLEMENT_INLINES and the .c file macro.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutils.h:464,perform,performed,464,graf2d/win32gdk/gdk/src/glib/gutils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutils.h,1,['perform'],['performed']
Performance,/* !NO_CACHING */; /* 17. Static file - not cached */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:44,cache,cached,44,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['cache'],['cached']
Performance,"/* !USE_COMPILE_TIME_MASKS */; /* Use the appropriate mask to copy the required bits. In some cases; * the byte mask will be 0 or 0xff; optimize these cases. row_width is; * the number of pixels, but the code copies bytes, so it is necessary; * to special case the end.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:136,optimiz,optimize,136,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['optimiz'],['optimize']
Performance,"/* $OpenBSD: strlcat.c,v 1.11 2003/06/17 21:56:24 millert Exp $ */; /*; * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>; *; * Permission to use, copy, modify, and distribute this software for any; * purpose with or without fee is hereby granted, provided that the above; * copyright notice and this permission notice appear in all copies.; *; * THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES; * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF; * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR; * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES; * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN; * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF; * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/strlcat.c:835,PERFORM,PERFORMANCE,835,core/clib/src/strlcat.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/strlcat.c,1,['PERFORM'],['PERFORMANCE']
Performance,"/* $OpenBSD: strlcpy.c,v 1.8 2003/06/17 21:56:24 millert Exp $ */; /*; * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>; *; * Permission to use, copy, modify, and distribute this software for any; * purpose with or without fee is hereby granted, provided that the above; * copyright notice and this permission notice appear in all copies.; *; * THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES; * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF; * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR; * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES; * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN; * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF; * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/strlcpy.c:834,PERFORM,PERFORMANCE,834,core/clib/src/strlcpy.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/strlcpy.c,1,['PERFORM'],['PERFORMANCE']
Performance,/* 'E': PLUS 1 TOTAL 2+precision */; /* The following use of an unsigned temporary avoids ambiguities in; * the signed arithmetic on exp_b10 and permits GCC at least to do; * better optimization.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:182,optimiz,optimization,182,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['optimiz'],['optimization']
Performance,"/* 'uLong' is defined in zlib.h as unsigned long; this means that on some; * systems it is a 64-bit value. crc32, however, returns 32 bits so the; * following cast is safe. 'uInt' may be no more than 16 bits, so it is; * necessary to perform a loop here.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:234,perform,perform,234,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['perform'],['perform']
Performance,/* (Maybe) load the dictionary; * Skips loading the dictionary if it is < 8 bytes.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:11,load,load,11,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,2,['load'],"['load', 'loading']"
Performance,"/* ******************************************************************; * debug; * Part of FSE library; * Copyright (c) 2013-2020, Yann Collet, Facebook, Inc.; *; * You can contact the author at :; * - Source repository : https://github.com/Cyan4973/FiniteStateEntropy; *; * This source code is licensed under both the BSD-style license (found in the; * LICENSE file in the root directory of this source tree) and the GPLv2 (found; * in the COPYING file in the root directory of this source tree).; * You may select, at your option, one of the above-listed licenses.; ****************************************************************** */; /*; * The purpose of this header is to enable debug functions.; * They regroup assert(), DEBUGLOG() and RAWLOG() for run-time,; * and DEBUG_STATIC_ASSERT() for compile-time.; *; * By default, DEBUGLEVEL==0, which means run-time debug is disabled.; *; * Level 1 enables assert() only.; * Starting level 2, traces can be generated and pushed to stderr.; * The higher the level, the more verbose the traces.; *; * It's possible to dynamically adjust level using variable g_debug_level,; * which is only declared if DEBUGLEVEL>=2,; * and is a global variable, not multi-thread protected (use with care); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/debug.h:1198,multi-thread,multi-thread,1198,builtins/zstd/common/debug.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/debug.h,1,['multi-thread'],['multi-thread']
Performance,"/* **************************************************************; * Tuning parameters; ****************************************************************/; /*!MEMORY_USAGE :; * Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.); * Increasing memory usage improves compression ratio; * Reduced memory usage can improve speed, due to cache effect; * Recommended max value is 14, for 16KB, which nicely fits into Intel x86 L1 cache */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:380,cache,cache,380,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,2,['cache'],['cache']
Performance,"/* *************************************; * Tuning parameters; ***************************************/; /*!; * XXH_FORCE_MEMORY_ACCESS:; * By default, access to unaligned memory is controlled by `memcpy()`, which is; * safe and portable.; *; * Unfortunately, on some target/compiler combinations, the generated assembly; * is sub-optimal.; *; * The below switch allow selection of a different access method; * in the search for improved performance.; * Method 0 (default):; * Use `memcpy()`. Safe and portable. Default.; * Method 1:; * `__attribute__((packed))` statement. It depends on compiler extensions; * and is therefore not portable.; * This method is safe if your compiler supports it, and *generally* as; * fast or faster than `memcpy`.; * Method 2:; * Direct access via cast. This method doesn't depend on the compiler but; * violates the C standard.; * It can generate buggy code on targets which do not support unaligned; * memory accesses.; * But in some circumstances, it's the only known way to get the most; * performance (example: GCC + ARMv6); * Method 3:; * Byteshift. This can generate the best code on old compilers which don't; * inline small `memcpy()` calls, and it might also be faster on big-endian; * systems which lack a native byteswap instruction.; * See https://stackoverflow.com/a/32095106/646947 for details.; * Prefer these methods in priority order (0 > 1 > 2 > 3); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:438,perform,performance,438,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,['perform'],['performance']
Performance,"/* ****************************; * INLINE mode; ******************************/; /*!; * XXH_INLINE_ALL (and XXH_PRIVATE_API); * Use these build macros to inline xxhash into the target unit.; * Inlining improves performance on small inputs, especially when the length is; * expressed as a compile-time constant:; *; * https://fastcompression.blogspot.com/2018/03/xxhash-for-small-keys-impressive-power.html; *; * It also keeps xxHash symbols private to the unit, so they are not exported.; *; * Usage:; * #define XXH_INLINE_ALL; * #include ""xxhash.h""; *; * Do not compile and link xxhash.o as a separate object, as it is not useful.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:211,perform,performance,211,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['perform'],['performance']
Performance,"/* - When there is no dictionary : loadedDictEnd == 0.; In which case, the test (blockEndIdx > maxDist) is merely to avoid; overflowing next operation `newLowLimit = blockEndIdx - maxDist`.; - When there is a standard dictionary :; Index referential is copied from the dictionary,; which means it starts from 0.; In which case, loadedDictEnd == dictSize,; and it makes sense to compare `blockEndIdx > maxDist + dictSize`; since `blockEndIdx` also starts from zero.; - When there is an attached dictionary :; loadedDictEnd is expressed within the referential of the context,; so it can be directly compared against blockEndIdx.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h:35,load,loadedDictEnd,35,builtins/zstd/compress/zstd_compress_internal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h,3,['load'],['loadedDictEnd']
Performance,"/* -*- coding: utf-8 -*-; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; */; /**; * This file implements a shared library. This library can be pre-loaded by; * the dynamic linker of the Operating System (OS). It implements a few function; * related to process creation. By pre-load this library the executed process; * uses these functions instead of those from the standard library.; *; * The idea here is to inject a logic before call the real methods. The logic is; * to dump the call into a file. To call the real method this library is doing; * the job of the dynamic linker.; *; * The only input for the log writing is about the destination directory.; * This is passed as environment variable.; */; // NOLINTNEXTLINE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c:304,load,loaded,304,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c,2,['load'],"['load', 'loaded']"
Performance,/* -------- LoadENDF -------- */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/NdbMTReactionXS.cxx:12,Load,LoadENDF,12,test/periodic/NdbMTReactionXS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/NdbMTReactionXS.cxx,1,['Load'],['LoadENDF']
Performance,/* ------------------------------------------ */; /* ===== Multi-threaded compression ===== */; /* ------------------------------------------ */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c:59,Multi-thread,Multi-threaded,59,builtins/zstd/compress/zstdmt_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c,2,['Multi-thread'],['Multi-threaded']
Performance,"/* .. Scalar Arguments .. */; /* .. Array Arguments .. */; /* .. */; /* Purpose */; /* ======= */; /* DSPMV performs the matrix-vector operation */; /* y := alpha*A*x + beta*y, */; /* where alpha and beta are scalars, x and y are n element vectors and */; /* A is an n by n symmetric matrix, supplied in packed form. */; /* Parameters */; /* ========== */; /* UPLO - CHARACTER*1. */; /* On entry, UPLO specifies whether the Upper or Lower */; /* triangular part of the matrix A is supplied in the packed */; /* array AP as follows: */; /* UPLO = 'U' or 'u' The Upper triangular part of A is */; /* supplied in AP. */; /* UPLO = 'L' or 'l' The Lower triangular part of A is */; /* supplied in AP. */; /* Unchanged on exit. */; /* N - INTEGER. */; /* On entry, N specifies the order of the matrix A. */; /* N must be at least zero. */; /* Unchanged on exit. */; /* ALPHA - DOUBLE PRECISION. */; /* On entry, ALPHA specifies the scalar alpha. */; /* Unchanged on exit. */; /* AP - DOUBLE PRECISION array of DIMENSION at least */; /* ( ( n*( n + 1 ) )/2 ). */; /* Before entry with UPLO = 'U' or 'u', the array AP must */; /* contain the Upper triangular part of the symmetric matrix */; /* packed sequentially, column by column, so that AP( 1 ) */; /* contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) */; /* and a( 2, 2 ) respectively, and so on. */; /* Before entry with UPLO = 'L' or 'l', the array AP must */; /* contain the Lower triangular part of the symmetric matrix */; /* packed sequentially, column by column, so that AP( 1 ) */; /* contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 ) */; /* and a( 3, 1 ) respectively, and so on. */; /* Unchanged on exit. */; /* X - DOUBLE PRECISION array of dimension at least */; /* ( 1 + ( n - 1 )*abs( INCX ) ). */; /* Before entry, the incremented array X must contain the n */; /* element vector x. */; /* Unchanged on exit. */; /* INCX - INTEGER. */; /* On entry, INCX specifies the increment for the Elements of */; /* X. INCX must not ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/mndspmv.cxx:108,perform,performs,108,math/minuit2/src/mndspmv.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/mndspmv.cxx,1,['perform'],['performs']
Performance,"/* .. Scalar Arguments .. */; /* .. Array Arguments .. */; /* .. */; /* Purpose */; /* ======= */; /* DSPR performs the symmetric rank 1 operation */; /* A := alpha*x*x' + A, */; /* where alpha is a real scalar, x is an n element vector and A is an */; /* n by n symmetric matrix, supplied in packed form. */; /* Parameters */; /* ========== */; /* UPLO - CHARACTER*1. */; /* On entry, UPLO specifies whether the Upper or Lower */; /* triangular part of the matrix A is supplied in the packed */; /* array AP as follows: */; /* UPLO = 'U' or 'u' The Upper triangular part of A is */; /* supplied in AP. */; /* UPLO = 'L' or 'l' The Lower triangular part of A is */; /* supplied in AP. */; /* Unchanged on exit. */; /* N - INTEGER. */; /* On entry, N specifies the order of the matrix A. */; /* N must be at least zero. */; /* Unchanged on exit. */; /* ALPHA - DOUBLE PRECISION. */; /* On entry, ALPHA specifies the scalar alpha. */; /* Unchanged on exit. */; /* X - DOUBLE PRECISION array of dimension at least */; /* ( 1 + ( n - 1 )*abs( INCX ) ). */; /* Before entry, the incremented array X must contain the n */; /* element vector x. */; /* Unchanged on exit. */; /* INCX - INTEGER. */; /* On entry, INCX specifies the increment for the Elements of */; /* X. INCX must not be zero. */; /* Unchanged on exit. */; /* AP - DOUBLE PRECISION array of DIMENSION at least */; /* ( ( n*( n + 1 ) )/2 ). */; /* Before entry with UPLO = 'U' or 'u', the array AP must */; /* contain the Upper triangular part of the symmetric matrix */; /* packed sequentially, column by column, so that AP( 1 ) */; /* contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 ) */; /* and a( 2, 2 ) respectively, and so on. On exit, the array */; /* AP is overwritten by the Upper triangular part of the */; /* updated matrix. */; /* Before entry with UPLO = 'L' or 'l', the array AP must */; /* contain the Lower triangular part of the symmetric matrix */; /* packed sequentially, column by column, so that AP( 1 ) */; /* con",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/mndspr.cxx:107,perform,performs,107,math/minuit2/src/mndspr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/mndspr.cxx,1,['perform'],['performs']
Performance,"/* 0 means ""do not cache"". All values <0 are reserved; 		 * and may be used differently in the future. */; /* If a file should not be cached, do not only send; 		 * max-age=0, but also pragmas and Expires headers. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:19,cache,cache,19,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,2,['cache'],"['cache', 'cached']"
Performance,/* 1. Perform overflow correction if necessary. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_ldm.c:6,Perform,Perform,6,builtins/zstd/compress/zstd_ldm.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_ldm.c,1,['Perform'],['Perform']
Performance,"/* 10^exp_b10 */; /* First extract a base 10 exponent of the number,; * the calculation below rounds down when converting; * from base 2 to base 10 (multiply by log10(2) -; * 0.3010, but 77/256 is 0.3008, so exp_b10 needs to; * be increased. Note that the arithmetic shift; * performs a floor() unlike C arithmetic - using a; * C multiply would break the following for negative; * exponents.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:276,perform,performs,276,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['perform'],['performs']
Performance,/* 16. Static file - maybe cached */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:27,cache,cached,27,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['cache'],['cached']
Performance,"/* 2-pass strategy:; * this strategy makes a first pass over first block to collect statistics; * and seed next round's statistics with it.; * After 1st pass, function forgets everything, and starts a new block.; * Consequently, this can only work if no data has been previously loaded in tables,; * aka, no dictionary, no prefix, no ldm preprocessing.; * The compression ratio gain is generally small (~0.5% on first block),; * the cost is 2x cpu time on first block. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c:279,load,loaded,279,builtins/zstd/compress/zstd_opt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c,1,['load'],['loaded']
Performance,"/* 32-bit */; /*; * 32-bit optimized version, which is more readable.; *; * On 32-bit, it removes an ADC and delays a dependency between the two; * halves of m128.high64, but it generates an extra mask on 64-bit.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:27,optimiz,optimized,27,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['optimiz'],['optimized']
Performance,/* 8.9 Armv8.7-A load/store 64-byte intrinsics */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/arm_acle.h:17,load,load,17,interpreter/llvm-project/clang/lib/Headers/arm_acle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/arm_acle.h,1,['load'],['load']
Performance,"/* === XXH3 streaming === */; /*; * Malloc's a pointer that is always aligned to align.; *; * This must be freed with `XXH_alignedFree()`.; *; * malloc typically guarantees 16 byte alignment on 64-bit systems and 8 byte; * alignment on 32-bit. This isn't enough for the 32 byte aligned loads in AVX2; * or on 32-bit, the 16 byte aligned loads in SSE2 and NEON.; *; * This underalignment previously caused a rather obvious crash which went; * completely unnoticed due to XXH3_createState() not actually being tested.; * Credit to RedSpah for noticing this bug.; *; * The alignment is done manually: Functions like posix_memalign or _mm_malloc; * are avoided: To maintain portability, we would have to write a fallback; * like this anyways, and besides, testing for the existence of library; * functions without relying on external build tools is impossible.; *; * The method is simple: Overallocate, manually align, and store the offset; * to the original behind the returned pointer.; *; * Align must be a power of 2 and 8 <= align <= 128.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:286,load,loads,286,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,['load'],['loads']
Performance,"/* === experimental parameters === */; /* these parameters can be used with ZSTD_setParameter(); * they are not guaranteed to remain supported in the future */; /* Enables rsyncable mode,; * which makes compressed files more rsync friendly; * by adding periodic synchronization points to the compressed data.; * The target average block size is ZSTD_c_jobSize / 2.; * It's possible to modify the job size to increase or decrease; * the granularity of the synchronization point.; * Once the jobSize is smaller than the window size,; * it will result in compression ratio degradation.; * NOTE 1: rsyncable mode only works when multithreading is enabled.; * NOTE 2: rsyncable performs poorly in combination with long range mode,; * since it will decrease the effectiveness of synchronization points,; * though mileage may vary.; * NOTE 3: Rsyncable mode limits maximum compression speed to ~400 MB/s.; * If the selected compression level is already running significantly slower,; * the overall speed won't be significantly impacted.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:673,perform,performs,673,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['perform'],['performs']
Performance,"/* ==========================================; * Short keys; * ==========================================; * One of the shortcomings of XXH32 and XXH64 was that their performance was; * sub-optimal on short lengths. It used an iterative algorithm which strongly; * favored lengths that were a multiple of 4 or 8.; *; * Instead of iterating over individual inputs, we use a set of single shot; * functions which piece together a range of lengths and operate in constant time.; *; * Additionally, the number of multiplies has been significantly reduced. This; * reduces latency, especially when emulating 64-bit multiplies on 32-bit.; *; * Depending on the platform, this may or may not be faster than XXH32, but it; * is almost guaranteed to be faster than XXH64.; */; /*; * At very short lengths, there isn't enough input to fully hide secrets, or use; * the entire secret.; *; * There is also only a limited amount of mixing we can do before significantly; * impacting performance.; *; * Therefore, we use different sections of the secret and always mix two secret; * samples with an XOR. This should have no effect on performance on the; * seedless or withSeed variants because everything _should_ be constant folded; * by modern compilers.; *; * The XOR mixing hides individual parts of the secret and increases entropy.; *; * This adds an extra layer of strength for custom secrets.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:167,perform,performance,167,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,4,"['latency', 'perform']","['latency', 'performance']"
Performance,"/* ===========================================================================; * Compress as much as possible from the input stream, return the current; * block state.; * This function does not perform lazy evaluation of matches and inserts; * new strings in the dictionary only for unmatched strings or for short; * matches. It is used only for the fast compression options.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:195,perform,perform,195,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,3,['perform'],['perform']
Performance,"/* ===========================================================================; * Copy without compression as much as possible from the input stream, return; * the current block state.; * This function does not insert new strings in the dictionary since; * uncompressible data is probably not useful. This function is used; * only for the level=0 compression option.; * NOTE: this function should be optimized to avoid extra copying from; * window to pending_buf.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:400,optimiz,optimized,400,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,3,['optimiz'],['optimized']
Performance,"/* ===========================================================================; * Fill the window when the lookahead becomes insufficient.; * Updates strstart and lookahead, and sets state->eofile if end of input file.; *; * IN assertion: state->lookahead < MIN_LOOKAHEAD && strstart + state->lookahead > 0; * OUT assertions: at least one byte has been read, or state->eofile is set;; * file reads are performed for at least two bytes (required for the; * translate_eol option).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c:402,perform,performed,402,core/zip/src/ZDeflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c,1,['perform'],['performed']
Performance,"/* ===========================================================================; * Fill the window when the lookahead becomes insufficient.; * Updates strstart and lookahead.; *; * IN assertion: lookahead < MIN_LOOKAHEAD; * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD; * At least one byte has been read, or avail_in == 0; reads are; * performed for at least two bytes (required for the zip translate_eol; * option -- not supported here).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate_cf.c:344,perform,performed,344,builtins/zlib/deflate_cf.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate_cf.c,1,['perform'],['performed']
Performance,"/* ===========================================================================; * In-memory read function. As opposed to file_read(), this function; * does not perform end-of-line translation, and does not update the; * crc and input size.; * Note that the size of the entire input buffer is an unsigned long,; * but the size used in R__mem_read() is only an unsigned int. This makes a; * difference on 16 bit machines. R__mem_read() may be called several; * times for an in-memory compression.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Bits.c:160,perform,perform,160,core/zip/src/Bits.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Bits.c,2,['perform'],['perform']
Performance,/* ===========================================================================; * Processes a new input file and return its compressed length. This; * function does not perform lazy evaluationof matches and inserts; * new strings in the dictionary only for unmatched strings or for short; * matches. It is used only for the fast compression options.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c:169,perform,perform,169,core/zip/src/ZDeflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c,1,['perform'],['perform']
Performance,"/* ===========================================================================; Reads bytes from the compressed file until len-1 characters are; read, or a newline character is read and transferred to buf, or an; end-of-file condition is encountered. The string is then terminated; with a null character.; gzgets returns buf, or Z_NULL in case of error. The current implementation is not optimized at all.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/gzio.c:388,optimiz,optimized,388,graf2d/asimage/src/libAfterImage/zlib/gzio.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/gzio.c,1,['optimiz'],['optimized']
Performance,"/* @(#)root/x3d:$Id$ */; /* Author: Mark Spychalla*/; /*; Copyright 1992 Mark Spychalla. Permission to use, copy, modify, distribute, and sell this software and; its documentation for any purpose is hereby granted without fee,; provided that the above copyright notice appear in all copies and that; both that copyright notice and this permission notice appear in; supporting documentation, and that the name of Mark Spychalla not be used; in advertising or publicity pertaining to distribution of the software; without specific, written prior permission. Mark Spychalla makes no; representations about the suitability of this software for any purpose.; It is provided ""as is"" without express or implied warranty. Mark Spychalla disclaims all warranties with regard to this software,; including all implied warranties of merchantability and fitness, in no; event shall Mark Spychalla be liable for any special, indirect or; consequential damages or any damages whatsoever resulting from loss of use,; data or profits, whether in an action of contract, negligence or other; tortious action, arising out of or in connection with the use or performance; of this software.; */; /*. NOTE ON X3D CODING STYLE:. Don't think I usually code in the gerberized fashion that X3D demonstrates.; X3D was written for speed at any cost. My goal was to write the fastest 3D; object viewer that I could, period. Regular programs ought to be written; with different goals in mind such as:. 1) A program has excellent documentation that ANYONE can read.; 2) A program when released has no strange ""features"" or bugs.; 3) A program is robust and handles ALL extreme and unusual cases.; 4) A program is written in phases and modules with hard tests for each one.; 5) A program is written for any user who doesn't need special knowledge; to use the program.; 6) A program has well defined user requirements and functional specifications.; 7) A program is written with regard to future expansion and integreation; with other ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c:1138,perform,performance,1138,graf3d/x3d/src/x3d.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c,1,['perform'],['performance']
Performance,"/* A function which may be called *only* within png_process_data to stop the; * processing of any more data. The function returns the number of bytes; * remaining, excluding any that libpng has cached internally. A subsequent; * call to png_process_data must supply these bytes again. If the argument; * 'save' is set to true the routine will first save all the pending data and; * will always return 0.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:194,cache,cached,194,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['cache'],['cached']
Performance,/* ALTERNATIVE_QUEUE */; /* Worker threads take accepted socket from the queue */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:73,queue,queue,73,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,"/* ARM NEON optimizations are being controlled by the compiler settings,; * typically the target FPU. If the FPU has been set to NEON (-mfpu=neon; * with GCC) then the compiler will define __ARM_NEON__ and we can rely; * unconditionally on NEON instructions not crashing, otherwise we must; * disable use of NEON instructions.; *; * NOTE: at present these optimizations depend on 'ALIGNED_MEMORY', so they; * can only be turned on automatically if that is supported too. If; * PNG_ARM_NEON_OPT is set in CPPFLAGS (to >0) then arm/arm_init.c will fail; * to compile with an appropriate #error if ALIGNED_MEMORY has been turned; * off.; *; * Note that gcc-4.9 defines __ARM_NEON instead of the deprecated; * __ARM_NEON__, so we check both variants.; *; * To disable ARM_NEON optimizations entirely, and skip compiling the; * associated assembler code, pass --enable-arm-neon=no to configure; * or put -DPNG_ARM_NEON_OPT=0 in CPPFLAGS.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:12,optimiz,optimizations,12,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,3,['optimiz'],['optimizations']
Performance,/* Added in 1.5.4: cache of updated row bytes */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h:19,cache,cache,19,graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,1,['cache'],['cache']
Performance,"/* Added in libpng-1.6.0, a different check for the validity of a set of cHRM; * chunk chromaticities. Earlier checks used to simply look for the overflow; * condition (where the determinant of the matrix to solve for XYZ ends up zero; * because the chromaticity values are not all distinct.) Despite this it is; * theoretically possible to produce chromaticities that are apparently valid; * but that rapidly degrade to invalid, potentially crashing, sets because of; * arithmetic inaccuracies when calculations are performed on them. The new; * check is to round-trip xy -> XYZ -> xy and then check that the result is; * within a small percentage of the original.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:517,perform,performed,517,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['perform'],['performed']
Performance,/* Adding in 1.5.4: cache the above value in png_struct so that we can later; * check in png_rowbytes that the user buffer won't get overwritten. Note; * that the field is not always set - if png_read_update_info isn't called; * the application has to either not do any transforms or get the calculation; * right itself.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:20,cache,cache,20,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['cache'],['cache']
Performance,"/* Align the decompression loop to 32 + 16 bytes.; *; * zstd compiled with gcc-9 on an Intel i9-9900k shows 10% decompression; * speed swings based on the alignment of the decompression loop. This; * performance swing is caused by parts of the decompression loop falling; * out of the DSB. The entire decompression loop should fit in the DSB,; * when it can't we get much worse performance. You can measure if you've; * hit the good case or the bad case with this perf command for some; * compressed file test.zst:; *; * perf stat -e cycles -e instructions -e idq.all_dsb_cycles_any_uops \; * -e idq.all_mite_cycles_any_uops -- ./zstd -tq test.zst; *; * If you see most cycles served out of the MITE you've hit the bad case.; * If you see most cycles served out of the DSB you've hit the good case.; * If it is pretty even then you may be in an okay case.; *; * I've been able to reproduce this issue on the following CPUs:; * - Kabylake: Macbook Pro (15-inch, 2019) 2.4 GHz Intel Core i9; * Use Instruments->Counters to get DSB/MITE cycles.; * I never got performance swings, but I was able to; * go from the good case of mostly DSB to half of the; * cycles served from MITE.; * - Coffeelake: Intel i9-9900k; *; * I haven't been able to reproduce the instability or DSB misses on any; * of the following CPUS:; * - Haswell; * - Broadwell: Intel(R) Xeon(R) CPU E5-2680 v4 @ 2.40GH; * - Skylake; *; * If you are seeing performance stability this script can help test.; * It tests on 4 commits in zstd where I saw performance change.; *; * https://gist.github.com/terrelln/9889fc06a423fd5ca6e99351564473f4; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c:200,perform,performance,200,builtins/zstd/decompress/zstd_decompress_block.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c,5,['perform'],['performance']
Performance,"/* Allocate space for script.; * We need to put it in the permanent pool in case the application performs; * multiple compressions without changing the settings. To avoid a memory; * leak if jpeg_simple_progression is called repeatedly for the same JPEG; * object, we try to re-use previously allocated space, and we allocate; * enough space to handle YCbCr even if initially asked for grayscale.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c:97,perform,performs,97,graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,1,['perform'],['performs']
Performance,"/* Allow machine dependent optimization for post-increment or pre-increment.; Based on testing to date,; Pre-increment preferred for:; - PowerPC G3 (Adler); - MIPS R5000 (Randers-Pehrson); Post-increment preferred for:; - none; No measurable difference:; - Pentium III (Anderson); - M68060 (Nikl); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inffast.c:27,optimiz,optimization,27,builtins/zlib/inffast.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inffast.c,2,['optimiz'],['optimization']
Performance,/* An l-value of this type has to be passed to the APIs below to cache the; * values of the parameters to a formatted warning message.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:65,cache,cache,65,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['cache'],['cache']
Performance,"/* And simply copy these bytes. Some optimization is possible here,; * depending on the value of 'bytes_to_copy'. Special case the low; * byte counts, which we know to be frequent.; *; * Notice that these cases all 'return' rather than 'break' - this; * avoids an unnecessary test on whether to restore the last byte; * below.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:37,optimiz,optimization,37,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['optimiz'],['optimization']
Performance,"/* Any definitions using GPollFD or GPollFunc are primarily; * for Unix and not guaranteed to be the compatible on all; * operating systems on which GLib runs. Right now, the; * GLib does use these functions on Win32 as well, but interprets; * them in a fairly different way than on Unix. If you use; * these definitions, you are should be prepared to recode; * for different operating systems.; *; *; * On Win32, the fd in a GPollFD should be Win32 HANDLE (*not* a file; * descriptor as provided by the C runtime) that can be used by; * MsgWaitForMultipleObjects. This does *not* include file handles; * from CreateFile, SOCKETs, nor pipe handles. (But you can use; * WSAEventSelect to signal events when a SOCKET is readable).; *; * On Win32, fd can also be the special value G_WIN32_MSG_HANDLE to; * indicate polling for messages. These message queue GPollFDs should; * be added with the g_main_poll_win32_msg_add function.; *; * But note that G_WIN32_MSG_HANDLE GPollFDs should not be used by GDK; * (GTK) programs, as GDK itself wants to read messages and convert them; * to GDK events.; *; * So, unless you really know what you are doing, it's best not to try; * to use the main loop polling stuff for your own needs on; * Win32. It's really only written for the GIMP's needs so; * far.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.h:848,queue,queue,848,graf2d/win32gdk/gdk/src/glib/gmain.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.h,1,['queue'],['queue']
Performance,"/* Asyncronous Queues, can be used to communicate between threads; */; /* Get a new GAsyncQueue with the ref_count 1 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h:15,Queue,Queues,15,graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,1,['Queue'],['Queues']
Performance,"/* At this point the tag table can't be checked because it hasn't necessarily; * been loaded; however, various header fields can be checked. These checks; * are for values permitted by the PNG spec in an ICC profile; the PNG spec; * restricts the profiles that can be passed in an iCCP chunk (they must be; * appropriate to processing PNG data!); */; /* Data checks (could be skipped). These checks must be independent of the; * version number; however, the version number doesn't accommodate changes in; * the header fields (just the known tags and the interpretation of the; * data.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:86,load,loaded,86,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['load'],['loaded']
Performance,/* Attempt to load at least MIN_GET_BITS bits into get_buffer. */; /* (It is assumed that no request will be for more than that many bits.) */; /* We fail to do so only if we hit a marker or are forced to suspend. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c:14,load,load,14,graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,1,['load'],['load']
Performance,"/* Basic control structions. Read libpng-manual.txt or libpng.3 for more info.; *; * png_struct is the cache of information used while reading or writing a single; * PNG file. One of these is always required, although the simplified API; * (below) hides the creation and destruction of it.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:103,cache,cache,103,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['cache'],['cache']
Performance,"/* Because we can't have introduced any new blank space into the; * tokens (we didn't do any new expansions), we don't need to; * perform field splitting. If we were going to honor IFS or do any; * expansions, we would have to do field splitting on each word; * here. Also, if we were going to do any expansion we would need to; * remove any zero-length words that didn't contain quotes; * originally; but since there's no expansion we know all words have; * nonzero length, unless they contain quotes.; * ; * So, we simply remove quotes, and don't do any field splitting or; * empty word removal, since we know there was no way to introduce; * such things.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gshell.c:130,perform,perform,130,graf2d/win32gdk/gdk/src/glib/gshell.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gshell.c,1,['perform'],['perform']
Performance,"/* Bit Reverse Load */; /* ==========================================================================; Assembly Syntax: Return=instruction(); C Intrinsic Prototype: void Q6_bitrev_load_update_D(Word64 dst, Word64 *ptr, UWord32 Iu4); Instruction Type: InstructionType; Execution Slots: SLOT0123; ========================================================================== */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h:15,Load,Load,15,interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h,1,['Load'],['Load']
Performance,"/* Bit Test */; /// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns the ZF flag in the EFLAGS register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:78,perform,perform,78,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['perform'],['perform']
Performance,/* Bit buffer & DC state at start of MCU */; /* These fields are NOT loaded into local working state. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:69,load,loaded,69,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,1,['load'],['loaded']
Performance,"/* Both stages worked, load the next token. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:23,load,load,23,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['load'],['load']
Performance,"/* By default, don't do extra passes to optimize entropy coding */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c:40,optimiz,optimize,40,graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,1,['optimiz'],['optimize']
Performance,"/* C */; // The last IR basic block is reused, as an optimization, in three cases:; // A. the first VPBB reuses the loop pre-header BB - when PrevVPBB is null;; // B. when the current VPBB has a single (hierarchical) predecessor which; // is PrevVPBB and the latter has a single (hierarchical) successor which; // both are in the same non-replicator region; and; // C. when the current VPBB is an entry of a region replica - where PrevVPBB; // is the exiting VPBB of this region from a previous instance, or the; // predecessor of this region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:53,optimiz,optimization,53,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,1,['optimiz'],['optimization']
Performance,/* C23 7.20.1 Defines several macros for performing checked integer arithmetic*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdckdint.h:41,perform,performing,41,interpreter/llvm-project/clang/lib/Headers/stdckdint.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdckdint.h,1,['perform'],['performing']
Performance,/* Cache (32-bit pointer) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,1,['Cache'],['Cache']
Performance,"/* Cacheability support ops */; /// Moves integer data from a 256-bit integer vector to a 32-byte; /// aligned memory location. To minimize caching, the data is flagged as; /// non-temporal (unlikely to be used again soon).; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVNTDQ </c> instruction.; ///; /// \param __a; /// A pointer to a 32-byte aligned memory location that will receive the; /// integer values.; /// \param __b; /// A 256-bit integer vector containing the values to be moved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:3,Cache,Cacheability,3,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Cache'],['Cacheability']
Performance,/* Cached GIOFlag */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.h:3,Cache,Cached,3,graf2d/win32gdk/gdk/src/glib/giochannel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.h,1,['Cache'],['Cached']
Performance,/* Cached hash code of me_key. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,Cache,Cached,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['Cache'],['Cached']
Performance,/* CachedOnly */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Cache,CachedOnly,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['Cache'],['CachedOnly']
Performance,/* Caches; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gcache.h:3,Cache,Caches,3,graf2d/win32gdk/gdk/src/glib/gcache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gcache.h,1,['Cache'],['Caches']
Performance,/* Check for row_stride overflow. This check is not performed on the; * original PNG format because it may not occur in the output PNG format; * and libpng deals with the issues of reading the original.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:52,perform,performed,52,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['perform'],['performed']
Performance,"/* Circular Load */; /* ==========================================================================; Assembly Syntax: Return=instruction(); C Intrinsic Prototype: void Q6_circ_load_update_D(Word64 dst, Word64 *ptr, UWord32 incr, UWord32 bufsize, UWord32 K); Instruction Type: InstructionType; Execution Slots: SLOT0123; ========================================================================== */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h:12,Load,Load,12,interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h,1,['Load'],['Load']
Performance,"/* Colorspace support; structures used in png_struct, png_info and in internal; * functions to hold and communicate information about the color space.; *; * PNG_COLORSPACE_SUPPORTED is only required if the application will perform; * colorspace corrections, otherwise all the colorspace information can be; * skipped and the size of libpng can be reduced (significantly) by compiling; * out the colorspace support.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h:223,perform,perform,223,graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,1,['perform'],['perform']
Performance,"/* Compile time options.; * =====================; * In a multi-arch build the compiler may compile the code several times for the; * same object module, producing different binaries for different architectures.; * When this happens configure-time setting of the target host options cannot be; * done and this interferes with the handling of the ARM NEON optimizations, and; * possibly other similar optimizations. Put additional tests here; in general; * this is needed when the same option can be changed at both compile time and; * run time depending on the target OS (i.e. iOS vs Android.); *; * NOTE: symbol prefixing does not pass $(CFLAGS) to the preprocessor, because; * this is not possible with certain compilers (Oracle SUN OS CC), as a result; * it is necessary to ensure that all extern functions that *might* be used; * regardless of $(CFLAGS) get declared in this file. The test on __ARM_NEON__; * below is one example of this behavior because it is controlled by the; * presence or not of -mfpu=neon on the GCC command line, it is possible to do; * this in $(CC), e.g. ""CC=gcc -mfpu=neon"", but people who build libpng rarely; * do this.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:355,optimiz,optimizations,355,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,2,['optimiz'],['optimizations']
Performance,/* Condition variable for pushers to wait on when the queue is full */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:54,queue,queue,54,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,1,['queue'],['queue']
Performance,/* Condition variables for poppers to wait on when the queue is empty */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:55,queue,queue,55,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,1,['queue'],['queue']
Performance,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:15,load,load,15,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,4,['load'],"['load', 'loaded', 'loads']"
Performance,"/* Control the overlap size, as a fraction of window size.; * The overlap size is an amount of data reloaded from previous job at the beginning of a new job.; * It helps preserve compression ratio, while each job is compressed in parallel.; * This value is enforced only when nbWorkers >= 1.; * Larger values increase compression ratio, but decrease speed.; * Possible values range from 0 to 9 :; * - 0 means ""default"" : value will be determined by the library, depending on strategy; * - 1 means ""no overlap""; * - 9 means ""full overlap"", using a full window size.; * Each intermediate rank increases/decreases load size by a factor 2 :; * 9: full window; 8: w/2; 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default; * default value varies between 6 and 9, depending on strategy */; /* note : additional experimental parameters are also available; * within the experimental section of the API.; * At the time of this writing, they include :; * ZSTD_c_rsyncable; * ZSTD_c_format; * ZSTD_c_forceMaxWindow; * ZSTD_c_forceAttachDict; * ZSTD_c_literalCompressionMode; * ZSTD_c_targetCBlockSize; * ZSTD_c_srcSizeHint; * ZSTD_c_enableDedicatedDictSearch; * ZSTD_c_stableInBuffer; * ZSTD_c_stableOutBuffer; * ZSTD_c_blockDelimiters; * ZSTD_c_validateSequences; * Because they are not stable, it's necessary to define ZSTD_STATIC_LINKING_ONLY to access them.; * note : never ever use experimentalParam? names directly;; * also, the enums values themselves are unstable and can still change.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:611,load,load,611,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['load'],['load']
Performance,/* Copy socket from the queue and increment tail */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:24,queue,queue,24,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,/* Copy socket to the queue and increment head */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:22,queue,queue,22,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,/* Copy the mask before we shift the queue and destroy it */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:37,queue,queue,37,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,"/* Create a Lua state, load all standard libraries and the mg table */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:23,load,load,23,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['load'],['load']
Performance,"/* DEBUG */; /* ===========================================================================; * Fill the window when the lookahead becomes insufficient.; * Updates strstart and lookahead.; *; * IN assertion: lookahead < MIN_LOOKAHEAD; * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD; * At least one byte has been read, or avail_in == 0; reads are; * performed for at least two bytes (required for the zip translate_eol; * option -- not supported here).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:357,perform,performed,357,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,3,['perform'],['performed']
Performance,"/* DON'T set CS_<H,V>REDRAW. It causes total redraw; * on WM_SIZE and WM_MOVE. Flicker, Performance!; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkwindow-win32.c:88,Perform,Performance,88,graf2d/win32gdk/gdk/src/gdk/win32/gdkwindow-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkwindow-win32.c,1,['Perform'],['Performance']
Performance,/* D_MULTISCAN_FILES_SUPPORTED */; /*; * Initialize master decompression control and select active modules.; * This is performed at the start of jpeg_start_decompress.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c:119,perform,performed,119,graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c,1,['perform'],['performed']
Performance,"/* Decide what part of virtual array to access.; * Algorithm: if target address > current window, assume forward scan,; * load starting at target address. If target address < current window,; * assume backward scan, load so that target area is top of window.; * Note that when switching from forward write to forward read, will have; * start_row = 0, so the limiting case applies and we load from 0 anyway.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:122,load,load,122,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,6,['load'],['load']
Performance,/* Default to using aligned access optimizations and requiring alignment to a; * multiple of the data type size. Override in a compiler specific fashion; * if necessary by inserting tests here:; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:35,optimiz,optimizations,35,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['optimiz'],['optimizations']
Performance,"/* Define this symbol if your target allows access to unaligned data.; * This is not mandatory, just a speed optimization. The compressed; * output is strictly identical.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Tailor.h:109,optimiz,optimization,109,core/zip/src/Tailor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Tailor.h,1,['optimiz'],['optimization']
Performance,"/* Define to 1 if you want getc etc. to use unlocked I/O if available.; Unlocked I/O can improve performance in unithreaded apps, but it is not; safe for multithreaded apps. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/config.h:97,perform,performance,97,graf2d/win32gdk/gdk/src/iconv/config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/config.h,1,['perform'],['performance']
Performance,"/* Defining NO_FLUSH can cause inconsistent screen updates, but is useful; for performance evaluation. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkrgb.c:79,perform,performance,79,graf2d/win32gdk/gdk/src/gdk/gdkrgb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkrgb.c,1,['perform'],['performance']
Performance,"/* Definitions for speed-related optimizations. */; /* If your compiler supports inline functions, define INLINE; * as the inline keyword; otherwise define it as empty.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h:33,optimiz,optimizations,33,graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h,1,['optimiz'],['optimizations']
Performance,"/* Detect gray background and attempt to enable optimization for; * gray --> RGB case.; *; * Note: if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or; * RGB_ALPHA (in which case need_expand is superfluous anyway), the; * background color might actually be gray yet not be flagged as such.; * This is not a problem for the current code, which uses; * PNG_BACKGROUND_IS_GRAY only to decide when to do the; * png_do_gray_to_rgb() transformation.; *; * TODO: this code needs to be revised to avoid the complexity and; * interdependencies. The color type of the background should be recorded in; * png_set_background, along with the bit depth, then the code has a record; * of exactly what color space the background is currently in.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:48,optimiz,optimization,48,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['optimiz'],['optimization']
Performance,/* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 		 * to effectively fill up the underlying IP packet payload and; 		 * reduce the overhead of sending lots of small buffers. However; 		 * this hurts the server's throughput (ie. operations per second); 		 * when HTTP 1.1 persistent connections are used and the responses; 		 * are relatively small (eg. less than 1400 bytes).; 		 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:233,throughput,throughput,233,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['throughput'],['throughput']
Performance,/* Do Huffman optimization for a scan after the first one. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c:14,optimiz,optimization,14,graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,1,['optimiz'],['optimization']
Performance,/* Do a data-output pass. */; /* We need not repeat per-scan setup if prior optimization pass did it. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c:76,optimiz,optimization,76,graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,1,['optimiz'],['optimization']
Performance,"/* Drop the contents of buf[] accumulated so far, and instead; pass all queued chars to the fallback handler. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/loop_wchar.h:72,queue,queued,72,graf2d/win32gdk/gdk/src/iconv/loop_wchar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/loop_wchar.h,1,['queue'],['queued']
Performance,"/* Drop the contents of buf[] accumulated so far, and instead; pass all queued wide characters to the fallback handler. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/loop_wchar.h:72,queue,queued,72,graf2d/win32gdk/gdk/src/iconv/loop_wchar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/loop_wchar.h,1,['queue'],['queued']
Performance,"/* Each vertex defines an event for our sweep line. Start by inserting; * all the vertices in a priority queue. Events are processed in; * lexicographic order, ie.; *; *	e1 < e2 iff e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c:105,queue,queue,105,graf3d/eve7/glu/sweep.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c,1,['queue'],['queue']
Performance,/* Error: could not load JIT functions. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:20,load,load,20,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,1,['load'],['load']
Performance,/* FASTEST */; /* ---------------------------------------------------------------------------; * Optimized version for FASTEST only; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:97,Optimiz,Optimized,97,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,1,['Optimiz'],['Optimized']
Performance,/* FASTEST */; /* ---------------------------------------------------------------------------; * Optimized version for level == 1 or strategy == Z_RLE only; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/deflate.c:97,Optimiz,Optimized,97,graf2d/asimage/src/libAfterImage/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/deflate.c,1,['Optimiz'],['Optimized']
Performance,"/* FIFO's for event queue, and for events put back using; * gdk_event_put().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkprivate.h:20,queue,queue,20,graf2d/win32gdk/gdk/src/gdk/gdkprivate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkprivate.h,1,['queue'],['queue']
Performance,"/* FIXME: We have to #define this because ""sel"" must be a constant integer, and; Sema doesn't do any form of constant propagation yet. */; /// Loads one cache line of data from the specified address to a location; /// closer to the processor.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// void _mm_prefetch(const void *a, const int sel);; /// \endcode; ///; /// This intrinsic corresponds to the <c> PREFETCHNTA </c> instruction.; ///; /// \param a; /// A pointer to a memory location containing a cache line of data.; /// \param sel; /// A predefined integer constant specifying the type of prefetch; /// operation: \n; /// _MM_HINT_NTA: Move data using the non-temporal access (NTA) hint. The; /// PREFETCHNTA instruction will be generated. \n; /// _MM_HINT_T0: Move data using the T0 hint. The PREFETCHT0 instruction will; /// be generated. \n; /// _MM_HINT_T1: Move data using the T1 hint. The PREFETCHT1 instruction will; /// be generated. \n; /// _MM_HINT_T2: Move data using the T2 hint. The PREFETCHT2 instruction will; /// be generated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h:143,Load,Loads,143,interpreter/llvm-project/clang/lib/Headers/xmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h,3,"['Load', 'cache']","['Loads', 'cache']"
Performance,"/* FOR NOW we will skip cases where we encounter the cfit before the ufit - usually should eval the; ufit first; * else if (std::includes(key.begin(), key.end(), constPars.begin(), constPars.end())) {; // constPars are subset of key; // => key is a ufit of the cachedFit; // add all par names of key that aren't in constPars ... these are the poi; std::set<std::string> pois;; for (auto &&par: key) {; if (constPars.find(par) == constPars.end()) {; pois.insert(std::get<0>(par));; allpois.insert(std::get<0>(par));; }; }; if (!pois.empty()) {; std::cout << ""found cfit BEFORE ufit??"" << std::endl;; value.insert(pois);; }; } */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooHypoSpace.cxx:261,cache,cachedFit,261,roofit/xroofit/src/xRooHypoSpace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooHypoSpace.cxx,1,['cache'],['cachedFit']
Performance,/* FP Loads */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:6,Load,Loads,6,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,1,['Load'],['Loads']
Performance,"/* Following fields used only in progressive mode */; /* Mode flag: TRUE for optimization, FALSE for actual data output */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:77,optimiz,optimization,77,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,1,['optimiz'],['optimization']
Performance,/* Following flag is set for events on the event queue during; * translation and cleared afterwards.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkevents.c:49,queue,queue,49,graf2d/win32gdk/gdk/src/gdk/gdkevents.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkevents.c,2,['queue'],['queue']
Performance,"/* Following helper functions make it possible to compare XXH128_hast_t values.; * Since XXH128_hash_t is a structure, this capability is not offered by the language.; * Note: For better performance, these functions can be inlined using XXH_INLINE_ALL */; /*!; * XXH128_isEqual():; * Return: 1 if `h1` and `h2` are equal, 0 if they are not.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:187,perform,performance,187,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['perform'],['performance']
Performance,"/* For 80x86 and 680x0, an optimized version will be provided in match.asm or; * match.S. The code will be functionally equivalent.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:27,optimiz,optimized,27,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,2,['optimiz'],['optimized']
Performance,"/* For MMAP or BIG_MEM, the whole input file is already in memory; * so we must not perform sliding. We must however call file_read; * in order to compute the crc, update state->lookahead and possibly set state->eofile.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c:84,perform,perform,84,core/zip/src/ZDeflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c,1,['perform'],['perform']
Performance,"/* For MSDOS, OS/2 and 386 Unix, an optimized version is in match.asm or; * match.s. The code is functionally equivalent, so you can use the C version; * if desired. A 68000 version is in amiga/match_68.a -- this could be used; * with other 68000 based systems such as Macintosh with a little effort.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c:36,optimiz,optimized,36,core/zip/src/ZDeflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c,1,['optimiz'],['optimized']
Performance,"/* For almost-degenerate situations, the results are not reliable.; * Unless the floating-point arithmetic can be performed without; * rounding errors, *any* implementation will give incorrect results; * on some degenerate inputs, so the client must have some way to; * handle this situation.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/geom.c:114,perform,performed,114,graf3d/eve7/glu/geom.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/geom.c,1,['perform'],['performed']
Performance,"/* For better performances, we will use the ExtCreateRegion(); * function to create the region. This function take a RGNDATA; * structure on entry. We will add rectangles by amount of; * ALLOC_UNIT number in this structure.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkgc-win32.c:14,perform,performances,14,graf2d/win32gdk/gdk/src/gdk/win32/gdkgc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkgc-win32.c,1,['perform'],['performances']
Performance,"/* Force C2FLOGICAL to generate only the values for either .TRUE. or .FALSE.; SX/PowerStationFortran only have 0 and 1 defined.; Elsewhere, only needed if you want to do:; logical lvariable; if (lvariable .eq. .true.) then ! (1); instead of; if (lvariable .eqv. .true.) then ! (2); - (1) may not even be FORTRAN/77 and that Apollo's f77 and IBM's xlf; refuse to compile (1), so you are probably well advised to stay away from; (1) and from LOGICAL_STRICT.; - You pay a (slight) performance penalty for using LOGICAL_STRICT. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h:478,perform,performance,478,montecarlo/eg/inc/cfortran.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h,1,['perform'],['performance']
Performance,"/* Free the pool, immediate means, that all unprocessed items in the queue; * wont be processed, wait means, that the function doesn't return immediatly,; * but after all threads in the pool are ready processing items. immediate; * does however not mean, that threads are killed. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.h:69,queue,queue,69,graf2d/win32gdk/gdk/src/glib/gthreadpool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.h,1,['queue'],['queue']
Performance,"/* Frequency of inserting/looking up entries into the LDM hash table.; * Must be clamped between 0 and (ZSTD_WINDOWLOG_MAX - ZSTD_HASHLOG_MIN).; * Default is MAX(0, (windowLog - ldmHashLog)), optimizing hash table usage.; * Larger values improve compression speed.; * Deviating far from default value will likely result in a compression ratio decrease.; * Special: value 0 means ""automatically determine hashRateLog"". */; /* frame parameters */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:192,optimiz,optimizing,192,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['optimiz'],['optimizing']
Performance,"/* From Andreas Dilger e-mail to png-implement, 26 March 1998:; *; * In most cases, the ""simple transparency"" should be done prior to doing; * gray-to-RGB, or you will have to test 3x as many bytes to check if a; * pixel is transparent. You would also need to make sure that the; * transparency information is upgraded to RGB.; *; * To summarize, the current flow is:; * - Gray + simple transparency -> compare 1 or 2 gray bytes and composite; * with background ""in place"" if transparent,; * convert to RGB if necessary; * - Gray + alpha -> composite with gray background and remove alpha bytes,; * convert to RGB if necessary; *; * To support RGB backgrounds for gray images we need:; * - Gray + simple transparency -> convert to RGB + simple transparency,; * compare 3 or 6 bytes and composite with; * background ""in place"" if transparent; * (3x compare/pixel compared to doing; * composite with gray bkgrnd); * - Gray + alpha -> convert to RGB + alpha, composite with background and; * remove alpha bytes (3x float; * operations/pixel compared with composite; * on gray background); *; * Greg's change will do this. The reason it wasn't done before is for; * performance, as this increases the per-pixel operations. If we would check; * in advance if the background was gray or RGB, and position the gray-to-RGB; * transform appropriately, then it would save a lot of work/time.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:1162,perform,performance,1162,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['perform'],['performance']
Performance,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * GAsyncQueue: asynchronous queue implementation, based on Gqueue.; * Copyright (C) 2000 Sebastian Wilhelmi; University of Karlsruhe; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:163,queue,queue,163,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,1,['queue'],['queue']
Performance,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * GQueue: Double ended queue implementation, piggy backed on GList.; * Copyright (C) 1998 Tim Janik; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gqueue.c:158,queue,queue,158,graf2d/win32gdk/gdk/src/glib/gqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gqueue.c,1,['queue'],['queue']
Performance,/* Head of the socket queue */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:22,queue,queue,22,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,/* Here neither threads nor tasks are queued and we didn't; 	 * just return from a timed wait. We now wait for a limited; 	 * time at this pool for new tasks to avoid costly context; 	 * switches. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c:38,queue,queued,38,graf2d/win32gdk/gdk/src/glib/gthreadpool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c,1,['queue'],['queued']
Performance,/* Hook performed after every successful conversion of a Unicode character. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/iconv.h:8,perform,performed,8,graf2d/win32gdk/gdk/src/iconv/iconv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/iconv.h,1,['perform'],['performed']
Performance,/* Hook performed after every successful conversion of a wide character. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/iconv.h:8,perform,performed,8,graf2d/win32gdk/gdk/src/iconv/iconv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/iconv.h,1,['perform'],['performed']
Performance,"/* Horizontal mirroring of DCT blocks is accomplished by swapping; * pairs of blocks in-place. Within a DCT block, we perform horizontal; * mirroring by changing the signs of odd-numbered columns.; * Partial iMCUs at the right edge are left untouched.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/transupp.c:118,perform,perform,118,graf2d/asimage/src/libAfterImage/libjpeg/transupp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/transupp.c,1,['perform'],['perform']
Performance,"/* How the alpha channel is interpreted - this affects how the color channels; * of a PNG file are returned to the calling application when an alpha channel,; * or a tRNS chunk in a palette file, is present.; *; * This has no effect on the way pixels are written into a PNG output; * datastream. The color samples in a PNG datastream are never premultiplied; * with the alpha samples.; *; * The default is to return data according to the PNG specification: the alpha; * channel is a linear measure of the contribution of the pixel to the; * corresponding composited pixel, and the color channels are unassociated; * (not premultiplied). The gamma encoded color channels must be scaled; * according to the contribution and to do this it is necessary to undo; * the encoding, scale the color values, perform the composition and re-encode; * the values. This is the 'PNG' mode.; *; * The alternative is to 'associate' the alpha with the color information by; * storing color channel values that have been scaled by the alpha.; * image. These are the 'STANDARD', 'ASSOCIATED' or 'PREMULTIPLIED' modes; * (the latter being the two common names for associated alpha color channels).; *; * For the 'OPTIMIZED' mode, a pixel is treated as opaque only if the alpha; * value is equal to the maximum value.; *; * The final choice is to gamma encode the alpha channel as well. This is; * broken because, in practice, no implementation that uses this choice; * correctly undoes the encoding before handling alpha composition. Use this; * choice only if other serious errors in the software or hardware you use; * mandate it; the typical serious error is for dark halos to appear around; * opaque areas of the composited PNG image because of arithmetic overflow.; *; * The API function png_set_alpha_mode specifies which of these choices to use; * with an enumerated 'mode' value and the gamma of the required output:; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:798,perform,perform,798,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,2,"['OPTIMIZ', 'perform']","['OPTIMIZED', 'perform']"
Performance,/* Huffman code optimization pass */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c:16,optimiz,optimization,16,graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,1,['optimiz'],['optimization']
Performance,"/* I think there is an optimization opportunity here.; * Calling ZSTD_estimateSubBlockSize for every sequence can be wasteful; * since it recalculates estimate from scratch.; * For example, it would recount literal distribution and symbol codes everytime.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_superblock.c:23,optimiz,optimization,23,builtins/zstd/compress/zstd_compress_superblock.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_superblock.c,1,['optimiz'],['optimization']
Performance,"/* ITT_PLATFORM==ITT_PLATFORM_WIN */; /*; * Generally, functions are not inlined unless optimization is specified.; * For functions declared inline, this attribute inlines the function even; * if no optimization level was specified.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h:88,optimiz,optimization,88,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h,2,['optimiz'],['optimization']
Performance,"/* If SSL is loaded dynamically, dlopen/dlclose is required. */; /* Create substitutes for POSIX functions in Win32. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:13,load,loaded,13,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['load'],['loaded']
Performance,"/* If building or using zlib as a DLL, define ZLIB_DLL.; * This is not mandatory, but it offers a little performance increase.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zconf.h:105,perform,performance,105,builtins/zlib/zconf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zconf.h,3,['perform'],['performance']
Performance,"/* If gray -> RGB, do so now only if background is non-gray; else do later; * for performance reasons; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:82,perform,performance,82,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['perform'],['performance']
Performance,"/* If it wasn't, then it also wasn't high enough to overflow max; during the log-rebasing in the min-exponent check. Check that it; won't overflow min in either check, then perform the min-exponent; check. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:173,perform,perform,173,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['perform'],['perform']
Performance,/* If no alpha we can optimize. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:22,optimiz,optimize,22,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,2,['optimiz'],['optimize']
Performance,"/* If the intended queue size was 0, signal after finishing job */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:19,queue,queue,19,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,1,['queue'],['queue']
Performance,"/* If the queue is empty, wait. We're idle at this point. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:10,queue,queue,10,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,"/* If the queue is full, wait */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:10,queue,queue,10,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,"/* If the returned node is not new, there is no need to perform any other operation.; * This is a likely scenario when building the entire graph in which branches share; * some nodes. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilter.hxx:56,perform,perform,56,tree/dataframe/inc/ROOT/RDF/RFilter.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilter.hxx,3,['perform'],['perform']
Performance,"/* If there is a full cache-control option configured,0 use it */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:22,cache,cache-control,22,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['cache'],['cache-control']
Performance,"/* If we have at least one event , fetch the first event off the queue*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c:65,queue,queue,65,graf3d/x3d/src/x3d.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c,1,['queue'],['queue']
Performance,"/* If we have not seen this color before, find nearest colormap */; /* entry and update the cache */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:92,cache,cache,92,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['cache'],['cache']
Performance,"/* If we have not seen this color before, find nearest colormap entry */; /* and update the cache */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:92,cache,cache,92,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['cache'],['cache']
Performance,/* Ignore already loaded sections */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:18,load,loaded,18,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,1,['load'],['loaded']
Performance,/* In the cases where we are behind (i.e. right of) a potential boolean optimization \; this tree variable reading may have not been executed with instance==0 which would \; result in the branch being potentially not read in. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:72,optimiz,optimization,72,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['optimiz'],['optimization']
Performance,"/* In these cases, we will call LZ4_compress_fast_continue(),; * which needs an already reset context. Otherwise, we'll call a; * one-shot API. The non-continued APIs internally perform their own; * resets at the beginning of their calls, where they know what; * tableType they need the context to be in. So in that case this; * would be misguided / wasted work. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c:178,perform,perform,178,builtins/lz4/lz4frame.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c,1,['perform'],['perform']
Performance,/* Include all the code for the regular heap-based queue here. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/priorityq.c:51,queue,queue,51,graf3d/eve7/glu/priorityq.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/priorityq.c,1,['queue'],['queue']
Performance,/* Index into the cache with adjusted pixel value */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:18,cache,cache,18,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['cache'],['cache']
Performance,/* Indicates if the queue is empty */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:20,queue,queue,20,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,1,['queue'],['queue']
Performance,/* Indicates if the queue is shutting down */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:20,queue,queue,20,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,1,['queue'],['queue']
Performance,"/* Initial pass: will collect input data, and do either Huffman; * optimization or data output for the first scan.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c:67,optimiz,optimization,67,graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,1,['optimiz'],['optimization']
Performance,/* Initialize everything needed for the read. This includes modifying; * the palette.; */; /* For the moment 'png_init_palette_transformations' and; * 'png_init_rgb_transformations' only do some flag canceling optimizations.; * The intent is that these two routines should have palette or rgb operations; * extracted from 'png_init_read_transformations'.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:210,optimiz,optimizations,210,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['optimiz'],['optimizations']
Performance,/* Initialize the job queue.; * It needs one extra space since one space is wasted to differentiate; * empty and full queues.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:22,queue,queue,22,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,2,['queue'],"['queue', 'queues']"
Performance,/* Integer Loads */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:11,Load,Loads,11,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,1,['Load'],['Loads']
Performance,/* Inverse DCT (also performs dequantization) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jpegint.h:21,perform,performs,21,graf2d/asimage/src/libAfterImage/libjpeg/jpegint.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jpegint.h,1,['perform'],['performs']
Performance,/* Is the given gamma significantly different from sRGB? The test is the same; * one used in pngrtran.c when deciding whether to do gamma correction. The; * arithmetic optimizes the division by using the fact that the inverse of the; * file sRGB gamma is 2.2; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:168,optimiz,optimizes,168,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['optimiz'],['optimizes']
Performance,/* Issue a warning about this combination: because RGB_TO_GRAY is; * optimized to do the gamma transform if present yet do_background has; * to do the same thing if both options are set a; * double-gamma-correction happens. This is true in all versions of; * libpng to date.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:69,optimiz,optimized,69,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['optimiz'],['optimized']
Performance,"/* It is not obvious which comparison below gets optimized in such a way that; * signed overflow would change the result; looking through the code does not; * reveal any tests which have the form GCC complains about, so presumably the; * optimizer is moving an add or subtract into the 'if' somewhere.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:49,optimiz,optimized,49,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,2,['optimiz'],"['optimized', 'optimizer']"
Performance,"/* It isn't required but allows to generate better code, saving a function pointer load from the IAT and an indirect jump.*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:83,load,load,83,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,5,['load'],['load']
Performance,"/* It's quite normal to get these messages before we have; * had time to register the window in our lookup table, or; * when the window is being destroyed and we already have; * removed it. Repost the same message to our queue so that; * we will get it later when we are prepared.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkevents-win32.c:221,queue,queue,221,graf2d/win32gdk/gdk/src/gdk/win32/gdkevents-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkevents-win32.c,1,['queue'],['queue']
Performance,/* Just declare the optimization that will be used */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:20,optimiz,optimization,20,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['optimiz'],['optimization']
Performance,/* Last time throttled data was sent */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:13,throttle,throttled,13,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['throttle'],['throttled']
Performance,/* List *all* the possible optimizations here - this branch is required if; * the builder of libpng passes the definition of PNG_FILTER_OPTIMIZATIONS in; * CFLAGS in place of CPPFLAGS *and* uses symbol prefixing.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:27,optimiz,optimizations,27,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['optimiz'],['optimizations']
Performance,"/* Literals can only be 14, but hope compilers optimize if we copy by a register size */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:47,optimiz,optimize,47,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['optimiz'],['optimize']
Performance,/* Load */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TProtoClass.cxx:3,Load,Load,3,core/meta/src/TProtoClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TProtoClass.cxx,1,['Load'],['Load']
Performance,/* Load a DLL/Shared Object with a TLS/SSL implementation. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Load,Load,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Load'],['Load']
Performance,/* Load data into workspace */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctflt.c:3,Load,Load,3,graf2d/asimage/src/libAfterImage/libjpeg/jfdctflt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctflt.c,2,['Load'],['Load']
Performance,/* Load necessary entry points */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/glew.c:3,Load,Load,3,builtins/glew/src/glew.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/glew.c,2,['Load'],['Load']
Performance,/* Load registers with state in inflate() for speed */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c:3,Load,Load,3,builtins/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c,2,['Load'],['Load']
Performance,/* Load the file. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkdnd-win32.c:3,Load,Load,3,graf2d/win32gdk/gdk/src/gdk/win32/gdkdnd-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkdnd-win32.c,1,['Load'],['Load']
Performance,"/* Load the initial translation unit -- we do this without honoring remapped; * files, so that we have a way to test results after changing the source. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:3,Load,Load,3,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,1,['Load'],['Load']
Performance,/* Load the result from the saved state. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooQuasiRandomGenerator.cxx:3,Load,Load,3,roofit/roofitcore/src/RooQuasiRandomGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooQuasiRandomGenerator.cxx,1,['Load'],['Load']
Performance,"/* Load up input buffer and set eof flag if last data loaded -- return -1 on; error, 0 otherwise. Note that the eof flag is set when the end of the input; file is reached, even though there may be unused data in the buffer. Once; that data has been used, no more attempts will be made to read the file.; If strm->avail_in != 0, then the current data is moved to the beginning of; the input buffer, and then the remainder of the buffer is loaded with the; available data from the input file. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c:3,Load,Load,3,builtins/zlib/gzread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c,3,"['Load', 'load']","['Load', 'loaded']"
Performance,/* Load up the bit buffer to a depth of at least nbits */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c:3,Load,Load,3,graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,2,['Load'],['Load']
Performance,/* Load up working state */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:3,Load,Load,3,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,5,['Load'],['Load']
Performance,/* Load up working state ... flush_bits needs it */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:3,Load,Load,3,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,1,['Load'],['Load']
Performance,/* Load up working state.; * We can avoid loading/saving bitread state if in an EOB run.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c:3,Load,Load,3,graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,2,"['Load', 'load']","['Load', 'loading']"
Performance,/* Load/Store element size bits */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:3,Load,Load,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['Load'],['Load']
Performance,/* LoadObjects */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp:3,Load,LoadObjects,3,interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp,3,['Load'],['LoadObjects']
Performance,"/* Lock and unlock an GAsyncQueue, all functions lock the queue for; * themselves, but in certain cirumstances you want to hold the lock longer,; * thus you lock the queue, call the *_unlocked functions and unlock it again; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h:58,queue,queue,58,graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,2,['queue'],['queue']
Performance,/* Lock the mutex and wait for a non-empty queue or until shutdown */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:43,queue,queue,43,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,1,['queue'],['queue']
Performance,/* Logical */; /// Performs a bitwise AND of two 256-bit vectors of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VANDPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \returns A 256-bit vector of [4 x double] containing the bitwise AND of the; /// values between both operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:19,Perform,Performs,19,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Perform'],['Performs']
Performance,"/* Look for gzip header, set up for inflate or copy. state->x.have must be 0.; If this is the first time in, allocate required memory. state->how will be; left unchanged if there is no more input data available, will be set to COPY; if there is no gzip header and direct copying will be performed, or it will; be set to GZIP for decompression. If direct copying, then leftover input; data from the input buffer will be copied to the output buffer. In that; case, all further file reads will be directly to either the output buffer or; a user buffer. If decompressing, the inflate state will be initialized.; gz_look() will return 0 on success or -1 on failure. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c:287,perform,performed,287,builtins/zlib/gzread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c,1,['perform'],['performed']
Performance,"/* MAKEFIXED */; /*; Update the window with the last wsize (normally 32K) bytes written before; returning. If window does not exist yet, create it. This is only called; when a window is already in use, or when output has been written during this; inflate call, but the end of the deflate stream has not been reached yet.; It is also called to create a window for dictionary data when a dictionary; is loaded. Providing output buffers larger than 32K to inflate() should provide a speed; advantage, since only the last 32K of output is copied to the sliding window; upon return from inflate(), and since all distances after the first 32K of; output will fall in the output data, making match copies simpler and faster.; The advantage may be dependent on the size of the processor's data caches.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c:401,load,loaded,401,builtins/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c,4,"['cache', 'load']","['caches', 'loaded']"
Performance,/* MSC doesn't have __builtin_expect. Just ignore likely/unlikely and; hope the compiler optimizes for the best.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/adler32_cf.c:89,optimiz,optimizes,89,builtins/zlib/adler32_cf.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/adler32_cf.c,2,['optimiz'],['optimizes']
Performance,/* MSDN: ... enhances system performance. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkwindow-win32.c:29,perform,performance,29,graf2d/win32gdk/gdk/src/gdk/win32/gdkwindow-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkwindow-win32.c,1,['perform'],['performance']
Performance,/* Macros for inflateBack(): */; /* Load returned state from inflate_fast() */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/infback.c:36,Load,Load,36,builtins/zlib/infback.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/infback.c,2,['Load'],['Load']
Performance,/* Macros to declare and load/save bitread local variables. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c:25,load,load,25,graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,2,['load'],['load']
Performance,"/* Major TODO Items:; - Control dependent poison UB; - Strict mode - (i.e. must analyze every operand); - Poison through memory; - Function ABIs; - Full coverage of intrinsics, etc.. (ouch). Instructions w/Unclear Semantics:; - shufflevector - It would seem reasonable for an out of bounds mask element; to produce poison, but the LangRef does not state.; - all binary ops w/vector operands - The likely interpretation would be that; any element overflowing should produce poison for the entire result, but; the LangRef does not state.; - Floating point binary ops w/fmf flags other than (nnan, noinfs). It seems; strange that only certian flags should be documented as producing poison. Cases of clear poison semantics not yet implemented:; - Exact flags on ashr/lshr produce poison; - NSW/NUW flags on shl produce poison; - Inbounds flag on getelementptr produce poison; - fptosi/fptoui (out of bounds input) produce poison; - Scalable vector types for insertelement/extractelement; - Floating point binary ops w/fmf nnan/noinfs flags produce poison; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:929,Scalab,Scalable,929,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,1,['Scalab'],['Scalable']
Performance,/* Mark the queue as advanced */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:12,queue,queue,12,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,/* Master thread adds accepted socket to a queue */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:43,queue,queue,43,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,"/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */; /* Values for max_lazy_match, good_match and max_chain_length, depending on; * the desired pack level (0..9). The values given below have been tuned to; * exclude worst case performance for pathological files. Better values may be; * found for specific files.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:218,tune,tuned,218,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,2,"['perform', 'tune']","['performance', 'tuned']"
Performance,"/* Minimum amount of lookahead, except at the end of the input file.; * See deflate.c for comments about the MIN_MATCH+1.; */; /* Values for max_lazy_match, good_match and max_chain_length, depending on; * the desired pack level (0..9). The values given below have been tuned to; * exclude worst case performance for pathological files. Better values may be; * found for specific files.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/deflate.c:270,tune,tuned,270,graf2d/asimage/src/libAfterImage/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/deflate.c,2,"['perform', 'tune']","['performance', 'tuned']"
Performance,/* Move the queue forward len bytes */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:12,queue,queue,12,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,"/* NEON optimizations are to be at least considered by libpng, so enable the; * callbacks to do this.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:8,optimiz,optimizations,8,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['optimiz'],['optimizations']
Performance,"/* NOTE: Uncomment the following #define if you want to use the; * given formula for calculating the AC conditioning parameter Kx; * for spectral selection progressive coding in section G.1.3.2; * of the spec (Kx = Kmin + SRL (8 + Se - Kmin) 4).; * Although the spec and P&M authors claim that this ""has proven; * to give good results for 8 bit precision samples"", I'm not; * convinced yet that this is really beneficial.; * Early tests gave only very marginal compression enhancements; * (a few - around 5 or so - bytes even for very large files),; * which would turn out rather negative if we'd suppress the; * DAC (Define Arithmetic Conditioning) marker segments for; * the default parameters in the future.; * Note that currently the marker writing module emits 12-byte; * DAC segments for a full-component scan in a color image.; * This is not worth worrying about IMHO. However, since the; * spec defines the default values to be used if the tables; * are omitted (unlike Huffman tables, which are required; * anyway), one might optimize this behaviour in the future,; * and then it would be disadvantageous to use custom tables if; * they don't provide sufficient gain to exceed the DAC size.; *; * On the other hand, I'd consider it as a reasonable result; * that the conditioning has no significant influence on the; * compression performance. This means that the basic; * statistical model is already rather stable.; *; * Thus, at the moment, we use the default conditioning values; * anyway, and do not use the custom formula.; *; #define CALCULATE_SPECTRAL_CONDITIONING; */; /* IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than INT32.; * We assume that int right shift is unsigned if INT32 right shift is,; * which should be safe.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c:1035,optimiz,optimize,1035,graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,2,"['optimiz', 'perform']","['optimize', 'performance']"
Performance,"/* NOTE: determined by experiment using pngstest, this reflects some; * balance between the time to write the image once and the time to read; * it about 50 times. The speed-up in pngstest was about 10-20% of the; * total (user) time on a heavily loaded system.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c:247,load,loaded,247,graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,1,['load'],['loaded']
Performance,/* No of elements in socket queue */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:28,queue,queue,28,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,/* No thread is currently doing something (and nothing is left; * to process in the queue) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c:84,queue,queue,84,graf2d/win32gdk/gdk/src/glib/gthreadpool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c,1,['queue'],['queue']
Performance,/* No thread is waiting in the queue */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c:31,queue,queue,31,graf2d/win32gdk/gdk/src/glib/gthreadpool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c,1,['queue'],['queue']
Performance,"/* Not worth the cycles to check insufficient_data here,; * since we will not change the data anyway if we read zeroes.; */; /* Load up working state */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c:128,Load,Load,128,graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,1,['Load'],['Load']
Performance,"/* Note that the actions of the A table were performed inside the AA table.; VAX Ultrix vcc, and HP-UX cc, didn't evaluate arguments to functions left to; right, so we had to split the original table into the current robust two. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h:45,perform,performed,45,montecarlo/eg/inc/cfortran.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h,1,['perform'],['performed']
Performance,"/* Note that the cached value may be P_FILE too, but if it is then the; * gamma_to_linear member has been set.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:17,cache,cached,17,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['cache'],['cached']
Performance,"/* Note: although _rotl exists for minGW (GCC under windows), performance seems poor */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:62,perform,performance,62,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['perform'],['performance']
Performance,"/* Note: if you selected 12-bit data precision, it is dangerous to turn off; * ENTROPY_OPT_SUPPORTED. The standard Huffman tables are only good for 8-bit; * precision, so jchuff.c normally uses entropy optimization to compute; * usable tables for higher precision. If you don't want to do optimization,; * you'll have to supply different default Huffman tables.; * The exact same statements apply for progressive JPEG: the default tables; * don't work for progressive mode. (This may get fixed, however.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h:202,optimiz,optimization,202,graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h,2,['optimiz'],['optimization']
Performance,"/* Note: this enum and the behavior it controls are effectively internal; * implementation details of the compressor. They are expected to continue; * to evolve and should be considered only in the context of extremely; * advanced performance tuning.; *; * Zstd currently supports the use of a CDict in three ways:; *; * - The contents of the CDict can be copied into the working context. This; * means that the compression can search both the dictionary and input; * while operating on a single set of internal tables. This makes; * the compression faster per-byte of input. However, the initial copy of; * the CDict's tables incurs a fixed cost at the beginning of the; * compression. For small compressions (< 8 KB), that copy can dominate; * the cost of the compression.; *; * - The CDict's tables can be used in-place. In this model, compression is; * slower per input byte, because the compressor has to search two sets of; * tables. However, this model incurs no start-up cost (as long as the; * working context's tables can be reused). For small inputs, this can be; * faster than copying the CDict's tables.; *; * - The CDict's tables are not used at all, and instead we use the working; * context alone to reload the dictionary and use params based on the source; * size. See ZSTD_compress_insertDictionary() and ZSTD_compress_usingDict().; * This method is effective when the dictionary sizes are very small relative; * to the input size, and the input size is fairly large to begin with.; *; * Zstd has a simple internal heuristic that selects which strategy to use; * at the beginning of a compression. However, if experimentation shows that; * Zstd is making poor choices, it is possible to override that choice with; * this enum.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:231,perform,performance,231,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['perform'],['performance']
Performance,"/* Note: vec_sum2s could be used here, but on little-endian, vector; shifts are added that are not needed for this use-case.; A vector shift to correctly position the 32-bit integer results; (currently at [0] and [2]) to [1] and [3] would then need to be; swapped back again since the desired results are two 64-bit; integers ([1]|[0] and [3]|[2]). Thus, no shift is performed. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:367,perform,performed,367,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,1,['perform'],['performed']
Performance,/* Now this is what I'd call some highly tuned code! */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkrgb.c:41,tune,tuned,41,graf2d/win32gdk/gdk/src/gdk/gdkrgb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkrgb.c,1,['tune'],['tuned']
Performance,/* Number of steps : Only used for optimization : 0 means default (40) : Higher means more parameters checked */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zdict.h:35,optimiz,optimization,35,builtins/zstd/zdict.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zdict.h,2,['optimiz'],['optimization']
Performance,/* Number of threads : constraint: 0 < nbThreads : 1 means single-threaded : Only used for optimization : Ignored if ZSTD_MULTITHREAD is not defined */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zdict.h:91,optimiz,optimization,91,builtins/zstd/zdict.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zdict.h,2,['optimiz'],['optimization']
Performance,"/* OK, load c into get_buffer */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c:7,load,load,7,graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,1,['load'],['load']
Performance,"/* OPTIMIZATION: DO NOT MODIFY THIS FUNCTION, instead #define; * PNG_FILTER_OPTIMIZATIONS to a function that overrides the generic; * implementations. See png_init_filter_functions above.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:3,OPTIMIZ,OPTIMIZATION,3,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['OPTIMIZ'],['OPTIMIZATION']
Performance,"/* Obsolete streaming functions (since v1.7.0); * degraded functionality; do not use!; *; * In order to perform streaming compression, these functions depended on data; * that is no longer tracked in the state. They have been preserved as well as; * possible: using them will still produce a correct output. However, they don't; * actually retain any history between compression calls. The compression ratio; * achieved will therefore be no better than compressing each chunk; * independently.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:104,perform,perform,104,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['perform'],['perform']
Performance,"/* On aarch64, we disable this optimization for clang because on certain; * mobile chipsets, performance is reduced with clang. For information; * refer to https://github.com/lz4/lz4/pull/707 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:31,optimiz,optimization,31,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"/* On normal machines we can apply MEMCOPY() and MEMZERO() to sample arrays; * and coefficient-block arrays. This won't work on 80x86 because the arrays; * are FAR and we're assuming a small-pointer memory model. However, some; * DOS compilers provide far-pointer versions of memcpy() and memset() even; * in the small-model libraries. These will be used if USE_FMEM is defined.; * Otherwise, the routines below do it the hard way. (The performance cost; * is not all that great, because these routines aren't very heavily used.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jutils.c:437,perform,performance,437,graf2d/asimage/src/libAfterImage/libjpeg/jutils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jutils.c,1,['perform'],['performance']
Performance,/* Only check for SSE if the build configuration has been modified to; * enable SSE optimizations. This means that these optimizations will; * be off by default. See contrib/intel for more details.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:84,optimiz,optimizations,84,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,2,['optimiz'],['optimizations']
Performance,/* Only load extra positions for ZSTD_dtlm_full */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_double_fast.c:8,load,load,8,builtins/zstd/compress/zstd_double_fast.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_double_fast.c,2,['load'],['load']
Performance,"/* Opaque types. */; /**; * LLVM uses a polymorphic type hierarchy which C cannot represent, therefore; * parameters must be passed as base types. Despite the declared types, most; * of the functions provided operate only on branches of the type hierarchy.; * The declared parameter names are descriptive and specify which type is; * required. Additionally, each type hierarchy is documented along with the; * functions that operate upon it. For more detail, refer to LLVM's C++ code.; * If in doubt, refer to Core.cpp, which performs parameter downcasts in the; * form unwrap<RequiredType>(Param).; */; /**; * Used to pass regions of memory through LLVM interfaces.; *; * @see llvm::MemoryBuffer; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h:526,perform,performs,526,interpreter/llvm-project/llvm/include/llvm-c/Types.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h,1,['perform'],['performs']
Performance,/* OpenSSL without dynamic loading */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:27,load,loading,27,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['load'],['loading']
Performance,/* Optimization for best case */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c:3,Optimiz,Optimization,3,graf3d/x3d/src/x3d.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c,2,['Optimiz'],['Optimization']
Performance,/* Optimization for object completely visible */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c:3,Optimiz,Optimization,3,graf3d/x3d/src/x3d.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c,2,['Optimiz'],['Optimization']
Performance,/* Optimization of entropy coding parms? */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h:3,Optimiz,Optimization,3,graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h,1,['Optimiz'],['Optimization']
Performance,/* Optimize the CMF field in the zlib stream. The resultant zlib stream is; * still compliant to the stream specification.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c:3,Optimiz,Optimize,3,graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,1,['Optimiz'],['Optimize']
Performance,"/* Order size using quicksort. This implementation incorporates; * four optimizations discussed in Sedgewick:; *; * 1. Non-recursive, using an explicit stack of pointer that store the next; * array partition to sort. To save time, this maximum amount of space; * required to store an array of MAX_INT is allocated on the stack. Assuming; * a 32-bit integer, this needs only 32 * sizeof(stack_node) == 136 bits.; * Pretty cheap, actually.; *; * 2. Chose the pivot element using a median-of-three decision tree. This; * reduces the probability of selecting a bad pivot value and eliminates; * certain * extraneous comparisons.; *; * 3. Only quicksorts TOTAL_ELEMS / MAX_THRESH partitions, leaving insertion; * sort to order the MAX_THRESH items within each partition. This is a big; * win, since insertion sort is faster for small, mostly sorted array; * segments.; *; * 4. The larger of the two sub-partitions is always pushed onto the stack; * first, with the algorithm then concentrating on the smaller partition.; * This *guarantees* no more than log (n) stack size is needed (actually O(1); * in this case)!; */; /**; * g_qsort_with_data:; * @pbase: start of array to sort; * @total_elems: elements in the array; * @size: size of each element; * @compare_func: function to compare elements; * @user_data: data to pass to @compare_func; *; * This is just like the standard C qsort() function, but; * the comparison routine accepts a user data argument.; * ; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gqsort.c:72,optimiz,optimizations,72,graf2d/win32gdk/gdk/src/glib/gqsort.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gqsort.c,1,['optimiz'],['optimizations']
Performance,/* Other state at start of MCU */; /* These fields are NOT loaded into local working state. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c:59,load,loaded,59,graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,1,['load'],['loaded']
Performance,/* Outlined code is optimized code by definition. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:20,optimiz,optimized,20,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,2,['optimiz'],['optimized']
Performance,/* PA optimization */; /* follow current chain */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4hc.c:6,optimiz,optimization,6,builtins/lz4/lz4hc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4hc.c,1,['optimiz'],['optimization']
Performance,"/* PNG_GAMMA_THRESHOLD is the threshold for performing gamma; * correction as a difference of the overall transform from 1.0; *; * We want to compare the threshold with s*f - 1, if we get; * overflow here it is because of wacky gamma values so we; * turn on processing anyway.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:44,perform,performing,44,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['perform'],['performing']
Performance,"/* Percentage of samples used for training: Only used for optimization : the first nbSamples * splitPoint samples will be used to training, the last nbSamples * (1 - splitPoint) samples will be used for testing, 0 means default (0.75), 1.0 when all samples are used for both training and testing */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zdict.h:58,optimiz,optimization,58,builtins/zstd/zdict.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zdict.h,1,['optimiz'],['optimization']
Performance,"/* Percentage of samples used for training: Only used for optimization : the first nbSamples * splitPoint samples will be used to training, the last nbSamples * (1 - splitPoint) samples will be used for testing, 0 means default (1.0), 1.0 when all samples are used for both training and testing */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zdict.h:58,optimiz,optimization,58,builtins/zstd/zdict.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zdict.h,1,['optimiz'],['optimization']
Performance,/* Perform DCT for all non-dummy blocks in this iMCU row. Each call; * on forward_DCT processes a complete horizontal row of DCT blocks.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c:3,Perform,Perform,3,graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c,1,['Perform'],['Perform']
Performance,/* Perform a basic check on the keyword length here. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:3,Perform,Perform,3,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['Perform'],['Perform']
Performance,"/* Perform a partial read and decompress, producing 'avail_out' bytes and; * reading from the current chunk as required.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:3,Perform,Perform,3,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['Perform'],['Perform']
Performance,"/* Perform any dummy output passes, and set up for the final pass */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdapistd.c:3,Perform,Perform,3,graf2d/asimage/src/libAfterImage/libjpeg/jdapistd.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdapistd.c,1,['Perform'],['Perform']
Performance,"/* Perform any dummy output passes, and set up for the real pass */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdapistd.c:3,Perform,Perform,3,graf2d/asimage/src/libAfterImage/libjpeg/jdapistd.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdapistd.c,1,['Perform'],['Perform']
Performance,/* Perform any remaining passes */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcapimin.c:3,Perform,Perform,3,graf2d/asimage/src/libAfterImage/libjpeg/jcapimin.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcapimin.c,1,['Perform'],['Perform']
Performance,/* Perform extrapolation */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx:3,Perform,Perform,3,roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,1,['Perform'],['Perform']
Performance,/* Perform master selection of active modules */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcapistd.c:3,Perform,Perform,3,graf2d/asimage/src/libAfterImage/libjpeg/jcapistd.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcapistd.c,2,['Perform'],['Perform']
Performance,/* Perform median-cut to produce final box list */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:3,Perform,Perform,3,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['Perform'],['Perform']
Performance,"/* Perform serial step as early as possible, but after CCtx initialization */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c:3,Perform,Perform,3,builtins/zstd/compress/zstdmt_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c,1,['Perform'],['Perform']
Performance,/* Perform some simple filtering. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:3,Perform,Perform,3,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,1,['Perform'],['Perform']
Performance,/* Perform the DCT */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcdctmgr.c:3,Perform,Perform,3,graf2d/asimage/src/libAfterImage/libjpeg/jcdctmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcdctmgr.c,2,['Perform'],['Perform']
Performance,/* Perform the first integration */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx:3,Perform,Perform,3,roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,1,['Perform'],['Perform']
Performance,/* Performs intrapixel differencing */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c:3,Perform,Performs,3,graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,1,['Perform'],['Performs']
Performance,"/* Pointer to the beginning of the portion of the incoming websocket; 	 * message queue.; 	 * The original websocket upgrade request is never removed, so the queue; 	 * begins after it. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:82,queue,queue,82,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,2,['queue'],['queue']
Performance,/* Pop a job off the queue */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:21,queue,queue,21,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,1,['queue'],['queue']
Performance,"/* Pop data from the async queue, when no data is there, the thread is blocked; * until data arrives */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h:27,queue,queue,27,graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,1,['queue'],['queue']
Performance,/* Pop our optimization override from above */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:11,optimiz,optimization,11,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['optimiz'],['optimization']
Performance,"/* Prepare the reader to ignore all recognized chunks whose data will not; * be used, i.e., all chunks recognized by libpng except for those; * involved in basic image reading:; *; * IHDR, PLTE, IDAT, IEND; *; * Or image data handling:; *; * tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.; *; * This provides a small performance improvement and eliminates any; * potential vulnerability to security problems in the unused chunks.; *; * At present the iCCP chunk data isn't used, so iCCP chunk can be ignored; * too. This allows the simplified API to be compiled without iCCP support,; * however if the support is there the chunk is still checked to detect; * errors (which are unfortunately quite common.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:317,perform,performance,317,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['perform'],['performance']
Performance,/* Prepare to load new iMCU row using other xbuffer list */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c:14,load,load,14,graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c,1,['load'],['load']
Performance,"/* Prior to 1.5.4 these tests were performed from png_set_gamma, 1.5.4 adds; * png_set_alpha_mode and this is another source for a default file gamma so; * the test needs to be performed later - here. In addition prior to 1.5.4; * the tests were repeated for the PALETTE color type here - this is no; * longer necessary (and doesn't seem to have been necessary before.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:35,perform,performed,35,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,2,['perform'],['performed']
Performance,/* Protects client_socks or queue */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:28,queue,queue,28,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,/* Push data into the async queue. Must not be NULL */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h:28,queue,queue,28,graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,1,['queue'],['queue']
Performance,/* Put so socket structure into the queue */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:36,queue,queue,36,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,/* Queue information */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Queue,Queue,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Queue'],['Queue']
Performance,/* Queue length */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Queue,Queue,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Queue'],['Queue']
Performance,/* Queues; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gqueue.h:3,Queue,Queues,3,graf2d/win32gdk/gdk/src/glib/gqueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gqueue.h,1,['Queue'],['Queues']
Performance,"/* READ_GRAY_TO_RGB */; /* For indexed PNG data (PNG_COLOR_TYPE_PALETTE) many of the transformations; * can be performed directly on the palette, and some (such as rgb to gray); * can be optimized inside the palette. This is particularly true of the; * composite (background and alpha) stuff, which can be pretty much all done; * in the palette even if the result is expanded to RGB or gray afterward.; *; * NOTE: this is Not Yet Implemented, the code behaves as in 1.5.1 and; * earlier and the palette stuff is actually handled on the first row. This; * leads to the reported bug that the palette returned by png_get_PLTE is not; * updated.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:111,perform,performed,111,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,2,"['optimiz', 'perform']","['optimized', 'performed']"
Performance,/* Read frame payload from the first message in the queue into; 			 * data and advance the queue by moving the memory in place. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:52,queue,queue,52,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,2,['queue'],['queue']
Performance,/* Read from the socket into the next available location in the; 			 * message queue. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:79,queue,queue,79,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,/* Read the length and the chunk name.; * This must be performed in a single I/O call.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:55,perform,performed,55,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['perform'],['performed']
Performance,/* Read the server config to check how long a file may be cached.; 	 * The configuration is in seconds. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:58,cache,cached,58,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['cache'],['cached']
Performance,"/* Reads a module from the specified path, returning via the OutModule parameter; a module provider which performs lazy deserialization. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp:106,perform,performs,106,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp,1,['perform'],['performs']
Performance,"/* Ref and unref the GAsyncQueue. g_async_queue_unref_unlocked makes; * no sense, as after the unreffing the Queue might be gone and can't; * be unlocked. So you have a function to call, if you don't hold the; * lock (g_async_queue_unref) and one to call, when you already hold; * the lock (g_async_queue_unref_and_unlock). After that however, you; * don't hold the lock anymore and the Queue might in fact be; * destroyed, if you unrefed to zero */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h:109,Queue,Queue,109,graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,2,['Queue'],['Queue']
Performance,"/* Regardless of the error handling below the cached data (if any) can be; * freed now. Notice that the data is not freed if there is a png_error, but; * it will be freed by destroy_read_struct.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:46,cache,cached,46,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['cache'],['cached']
Performance,/* Remove any existing table; this copes with multiple calls to; * png_read_update_info. The warning is because building the gamma tables; * multiple times is a performance hit - it's harmless but the ability to; * call png_read_update_info() multiple times is new in 1.5.6 so it seems; * sensible to warn if the app introduces such a hit.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:161,perform,performance,161,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['perform'],['performance']
Performance,"/* Render a 24-bit RGB image in buf into the GdkImage, without dithering.; This assumes native byte ordering - what should really be done is to; check whether static_image->byte_order is consistent with the _ENDIAN; config flag, and if not, use a different function. This one is even faster than the one below - its inner loop loads 3; words (i.e. 4 24-bit pixels), does a lot of shifting and masking,; then writes 2 words. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkrgb.c:327,load,loads,327,graf2d/win32gdk/gdk/src/gdk/gdkrgb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkrgb.c,1,['load'],['loads']
Performance,"/* Resize the given region to the new size, returning a pointer; to the (possibly moved) region. This is optimized for speed;; some benchmarks seem to indicate that greater compactness is; achieved by unconditionally allocating and copying to a; new region. This module has incestuous knowledge of the; internals of both mfree and mmalloc. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mrealloc.c:105,optimiz,optimized,105,core/clib/src/mrealloc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mrealloc.c,1,['optimiz'],['optimized']
Performance,"/* Return the length of the queue, negative values mean, that threads; * are waiting, positve values mean, that there are entries in the; * queue. Actually this function returns the length of the queue minus; * the number of waiting threads, g_async_queue_length == 0 could also; * mean 'n' entries in the queue and 'n' thread waiting, such can; * happen due to locking of the queue or due to scheduling. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h:28,queue,queue,28,graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,5,['queue'],['queue']
Performance,"/* SCANLINE_MOD(print_component,*(imout->available),0, new_line->width ); */; /* copying/encoding previously cached line into destination image : */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/imencdec.c:109,cache,cached,109,graf2d/asimage/src/libAfterImage/imencdec.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/imencdec.c,1,['cache'],['cached']
Performance,"/* SECURITY and SAFETY:; *; * libpng is built with support for internal limits on image dimensions and; * memory usage. These are documented in scripts/pnglibconf.dfa of the; * source and recorded in the machine generated header file pnglibconf.h.; */; /* If you are running on a machine where you cannot allocate more; * than 64K of memory at once, uncomment this. While libpng will not; * normally need that much memory in a chunk (unless you load up a very; * large file), zlib needs to know how big of a chunk it can use, and; * libpng thus makes sure to check any memory allocation to verify it; * will fit into memory.; *; * zlib provides 'MAXSEG_64K' which, if defined, indicates the; * same limit and pngconf.h (already included) sets the limit; * if certain operating systems are detected.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:445,load,load,445,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['load'],['load']
Performance,/* SIMD load ops (unaligned) */; /// Loads two 128-bit floating-point vectors of [4 x float] from; /// unaligned memory locations and constructs a 256-bit floating-point vector; /// of [8 x float] by concatenating the two 128-bit vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing 4 consecutive; /// single-precision floating-point values. These values are to be copied to; /// bits[255:128] of the result. The address of the memory location does not; /// have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing 4 consecutive; /// single-precision floating-point values. These values are to be copied to; /// bits[127:0] of the result. The address of the memory location does not; /// have to be aligned.; /// \returns A 256-bit floating-point vector of [8 x float] containing the; /// concatenated result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:8,load,load,8,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,3,"['Load', 'load']","['Loads', 'load']"
Performance,/* SIMD load ops */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:8,load,load,8,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,1,['load'],['load']
Performance,/* SIMD load ops */; /// Loads 4 double-precision floating point values from a 32-byte aligned; /// memory location pointed to by \a __p into a vector of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVAPD </c> instruction.; ///; /// \param __p; /// A 32-byte aligned pointer to a memory location containing; /// double-precision floating point values.; /// \returns A 256-bit vector of [4 x double] containing the moved values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:8,load,load,8,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,2,"['Load', 'load']","['Loads', 'load']"
Performance,/* SIMPLIFIED READ/WRITE */; /* These are initialization functions for hardware specific PNG filter; * optimizations; list these here then select the appropriate one at compile; * time using the macro PNG_FILTER_OPTIMIZATIONS. If the macro is not defined; * the generic code is used.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:103,optimiz,optimizations,103,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['optimiz'],['optimizations']
Performance,"/* SIMPLIFIED_{READ|WRITE} */; /*******************************************************************************; * Section 6: IMPLEMENTATION OPTIONS; *******************************************************************************; *; * Support for arbitrary implementation-specific optimizations. The API allows; * particular options to be turned on or off. 'Option' is the number of the; * option and 'onoff' is 0 (off) or non-0 (on). The value returned is given; * by the PNG_OPTION_ defines below.; *; * HARDWARE: normally hardware capabilities, such as the Intel SSE instructions,; * are detected at run time, however sometimes it may be impossible; * to do this in user mode, in which case it is necessary to discover; * the capabilities in an OS specific way. Such capabilities are; * listed here when libpng has support for them and must be turned; * ON by the application if present.; *; * SOFTWARE: sometimes software optimizations actually result in performance; * decrease on some architectures or systems, or with some sets of; * PNG images. 'Software' options allow such optimizations to be; * selected at run time.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:282,optimiz,optimizations,282,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,4,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,/* SSE4 Streaming Load Hint Instruction. */; /// Loads integer values from a 128-bit aligned memory location to a; /// 128-bit integer vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVNTDQA / MOVNTDQA </c> instruction.; ///; /// \param __V; /// A pointer to a 128-bit aligned memory location that contains the integer; /// values.; /// \returns A 128-bit integer vector containing the data stored at the; /// specified memory location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:18,Load,Load,18,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,2,['Load'],"['Load', 'Loads']"
Performance,"/* SSE4.2 Packed Comparison Intrinsics and EFlag Reading. */; /// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and th",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:101,perform,perform,101,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,2,['perform'],['perform']
Performance,"/* SSE4.2 Packed Comparison Intrinsics. */; /// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns a 128-bit integer vector representing the result; /// mask of the comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extend",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:83,perform,perform,83,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,2,['perform'],['perform']
Performance,"/* SSL loaded dynamically from DLL / shared object */; /* Add all prototypes here, to be independent from OpenSSL source; * installation. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:7,load,loaded,7,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['load'],['loaded']
Performance,/* Save the best color numbers (plus 1) in the main cache array */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:52,cache,cache,52,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['cache'],['cache']
Performance,"/* Select MCU decoding routine */; /* We retain the hard-coded case for full-size blocks.; * This is not necessary, but it appears that this version is slightly; * more performant in the given implementation.; * With an improved implementation we would prefer a single optimized; * function.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c:169,perform,performant,169,graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,2,"['optimiz', 'perform']","['optimized', 'performant']"
Performance,"/* Select how many threads will be spawned to compress in parallel.; * When nbWorkers >= 1, triggers asynchronous mode when invoking ZSTD_compressStream*() :; * ZSTD_compressStream*() consumes input and flush output if possible, but immediately gives back control to caller,; * while compression is performed in parallel, within worker thread(s).; * (note : a strong exception to this rule is when first invocation of ZSTD_compressStream2() sets ZSTD_e_end :; * in which case, ZSTD_compressStream2() delegates to ZSTD_compress2(), which is always a blocking call).; * More workers improve speed, but also increase memory usage.; * Default value is `0`, aka ""single-threaded mode"" : no worker is spawned,; * compression is performed inside Caller's thread, and all invocations are blocking */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:299,perform,performed,299,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,2,['perform'],['performed']
Performance,/* Send all current and obsolete cache opt-out directives. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:33,cache,cache,33,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['cache'],['cache']
Performance,/* Send queue not full - write will not block. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:8,queue,queue,8,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,"/* Set the library compression level. Currently, valid values range from; * 0 - 9, corresponding directly to the zlib compression levels 0 - 9; * (0 - no compression, 9 - ""maximal"" compression). Note that tests have; * shown that zlib compression levels 3-6 usually perform as well as level 9; * for PNG images, and do considerably fewer calculations. In the future,; * these values may not correspond directly to the zlib compression levels.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:266,perform,perform,266,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['perform'],['perform']
Performance,"/* Set the number of threads, which can run concurrently for that pool, -1; * means no limit. 0 means has the effect, that the pool won't process; * requests until the limit is set higher again */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.h:44,concurren,concurrently,44,graf2d/win32gdk/gdk/src/glib/gthreadpool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.h,1,['concurren'],['concurrently']
Performance,/* Shift hash cache down 1. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_lazy.c:14,cache,cache,14,builtins/zstd/compress/zstd_lazy.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_lazy.c,1,['cache'],['cache']
Performance,/* Shut down the queue */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:17,queue,queue,17,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,1,['queue'],['queue']
Performance,"/* Sizes of match buffers for literals/lengths and distances. There are; * 4 reasons for limiting LIT_BUFSIZE to 64K:; * - frequencies can be kept in 16 bit counters; * - if compression is not successful for the first block, all input data is; * still in the window so we can still emit a stored block even when input; * comes from standard input. (This can also be done for all blocks if; * LIT_BUFSIZE is not greater than 32K.); * - if compression is not successful for a file smaller than 64K, we can; * even emit a stored file instead of a stored block (saving 5 bytes).; * - creating new Huffman trees less frequently may not provide fast; * adaptation to changes in the input data statistics. (Take for; * example a binary file with poorly compressible code followed by; * a highly compressible string table.) Smaller buffer sizes give; * fast adaptation but have of course the overhead of transmitting trees; * more frequently.; * - I can't count above 4; * The current code is general and allows DIST_BUFSIZE < LIT_BUFSIZE (to save; * memory at the expense of compression). Some optimizations would be possible; * if we rely on DIST_BUFSIZE == LIT_BUFSIZE.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZTrees.c:1087,optimiz,optimizations,1087,core/zip/src/ZTrees.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZTrees.c,1,['optimiz'],['optimizations']
Performance,"/* Skip to next match if the match length cannot increase; * or if the match length is less than 2. Note that the checks below; * for insufficient lookahead only occur occasionally for performance; * reasons. Therefore uninitialized memory will be accessed, and; * conditional jumps will be made that depend on those values.; * However the length of the match is limited to the lookahead, so; * the output of deflate is not affected by the uninitialized values.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:185,perform,performance,185,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,3,['perform'],['performance']
Performance,"/* Sliding window. Input bytes are read into the second half of the window,; * and move to the first half later to keep a dictionary of at least WSIZE; * bytes. With this organization, matches are limited to a distance of; * WSIZE-MAX_MATCH bytes, but this ensures that IO is always; * performed with a length multiple of the block size. Also, it limits; * the window size to 64K, which is quite useful on MSDOS.; * To do: limit the window size to WSIZE+BSZ if SMALL_MEM (the code would; * be less efficient since the data would have to be copied WSIZE/BSZ times); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Bits.h:286,perform,performed,286,core/zip/src/Bits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Bits.h,1,['perform'],['performed']
Performance,"/* Sliding window. Input bytes are read into the second half of the window,; * and move to the first half later to keep a dictionary of at least wSize; * bytes. With this organization, matches are limited to a distance of; * wSize-MAX_MATCH bytes, but this ensures that IO is always; * performed with a length multiple of the block size. Also, it limits; * the window size to 64K, which is quite useful on MSDOS.; * To do: use the user input buffer as sliding window.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.h:286,perform,performed,286,builtins/zlib/deflate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.h,3,['perform'],['performed']
Performance,"/* Slower way to find the channel vector:; // Get the vector of bin uncertainty caches for this channel; if( _barlowCache.find( channel_name ) == _barlowCache.end() ) {; std::cout << ""Error: channel: "" << channel_name; << "" not found in barlow Cache"" << std::endl;; throw runtime_error(""Channel not in barlow cache"");; }. std::vector< BarlowCache >& channel_cache = _barlowCache[ channel_name ];; */; // Loop over the bins in the cache; // Set all gamma's to 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/RooBarlowBeestonLL.cxx:80,cache,caches,80,roofit/histfactory/src/RooBarlowBeestonLL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/RooBarlowBeestonLL.cxx,4,"['Cache', 'cache']","['Cache', 'cache', 'caches']"
Performance,/* Socket queue (sq) : accepted sockets waiting for a; 	 worker thread */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:10,queue,queue,10,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,/* Special case: Huffman DC refinement scans need no Huffman table; * and therefore we can skip the optimization pass for them.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c:100,optimiz,optimization,100,graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,1,['optimiz'],['optimization']
Performance,/* Specialized optimizations */; // pow/powr/pown,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp:15,optimiz,optimizations,15,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,1,['optimiz'],['optimizations']
Performance,"/* Start by invoking BIT_initDStream().; * A chunk of the bitStream is then stored into a local register.; * Local register size is 64-bits on 64-bits systems, 32-bits on 32-bits systems (size_t).; * You can then retrieve bitFields stored into the local register, **in reverse order**.; * Local register is explicitly reloaded from memory by the BIT_reloadDStream() method.; * A reload guarantee a minimum of ((8*sizeof(bitD->bitContainer))-7) bits when its result is BIT_DStream_unfinished.; * Otherwise, it can be less than that, so proceed accordingly.; * Checking if DStream has reached its end can be performed with BIT_endOfDStream().; */; /*-****************************************; * unsafe API; ******************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h:606,perform,performed,606,builtins/zstd/common/bitstream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h,1,['perform'],['performed']
Performance,"/* Start with initCStream, providing the size of buffer to write into.; * bitStream will never write outside of this buffer.; * `dstCapacity` must be >= sizeof(bitD->bitContainer), otherwise @return will be an error code.; *; * bits are first added to a local register.; * Local register is size_t, hence 64-bits on 64-bits systems, or 32-bits on 32-bits systems.; * Writing data into memory is an explicit operation, performed by the flushBits function.; * Hence keep track how many bits are potentially stored into local register to avoid register overflow.; * After a flushBits, a maximum of 7 bits might still be stored into local register.; *; * Avoid storing elements of more than 24 bits if you want compatibility with 32-bits bitstream readers.; *; * Last operation is to close the bitStream.; * The function returns the final size of CStream in bytes.; * If data couldn't fit into `dstBuffer`, it will return a 0 ( == not storable); */; /*-********************************************; * bitStream decoding API (read backward); **********************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h:418,perform,performed,418,builtins/zstd/common/bitstream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h,1,['perform'],['performed']
Performance,"/* Starting with the hash of the previous RSYNC_LENGTH bytes, roll; * through the input. If we hit a synchronization point, then cut the; * job off, and tell the compressor to flush the job. Otherwise, load; * all the bytes and continue as normal.; * If we go too long without a synchronization point (targetSectionSize); * then a block will be emitted anyways, but this is okay, since if we; * are already synchronized we will remain synchronized.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c:202,load,load,202,builtins/zstd/compress/zstdmt_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c,1,['load'],['load']
Performance,/* Statistics tables for optimization */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:25,optimiz,optimization,25,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,1,['optimiz'],['optimization']
Performance,"/* Statistics tables for optimization; again, one set is enough */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcphuff.c:25,optimiz,optimization,25,graf2d/asimage/src/libAfterImage/libjpeg/jcphuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcphuff.c,1,['optimiz'],['optimization']
Performance,"/* Stop when cur_match becomes <= limit. To simplify the code,; * we prevent matches with the string of window index 0.; */; /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.; * It is easy to get rid of this optimization if necessary.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c:140,optimiz,optimized,140,core/zip/src/ZDeflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c,2,['optimiz'],"['optimization', 'optimized']"
Performance,/* Store these vals. Small performance increase as this skips three; * indexing operations in the loop code.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:27,perform,performance,27,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,1,['perform'],['performance']
Performance,/* Stores the data in A to the address P without polluting the caches. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:63,cache,caches,63,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,1,['cache'],['caches']
Performance,/* TRUE=optimize entropy encoding parms */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jpeglib.h:8,optimiz,optimize,8,graf2d/asimage/src/libAfterImage/libjpeg/jpeglib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jpeglib.h,1,['optimiz'],['optimize']
Performance,/* Tail of the socket queue */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:22,queue,queue,22,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,"/* The IBM double-double semantics. Such a number consists of a pair of IEEE; 64-bit doubles (Hi, Lo), where |Hi| > |Lo|, and if normal,; (double)(Hi + Lo) == Hi. The numeric value it's modeling is Hi + Lo.; Therefore it has two 53-bit mantissa parts that aren't necessarily adjacent; to each other, and two 11-bit exponents. Note: we need to make the value different from semBogus as otherwise; an unsafe optimization may collapse both values to a single address,; and we heavily rely on them having distinct addresses. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:406,optimiz,optimization,406,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['optimiz'],['optimization']
Performance,"/* The RGBA optimization works with png_ptr->bit_depth == 8; * but sometimes row_info->bit_depth has been changed to 8.; * In these cases, the palette hasn't been riffled.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:12,optimiz,optimization,12,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['optimiz'],['optimization']
Performance,"/* The application can compare zlibVersion and ZLIB_VERSION for consistency.; If the first character differs, the library code actually used is not; compatible with the zlib.h header file used by the application. This check; is automatically made by deflateInit and inflateInit.; */; /*; ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));. Initializes the internal stream state for compression. The fields; zalloc, zfree and opaque must be initialized before by the caller. If; zalloc and zfree are set to Z_NULL, deflateInit updates them to use default; allocation functions. The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:; 1 gives best speed, 9 gives best compression, 0 gives no compression at all; (the input data is simply copied a block at a time). Z_DEFAULT_COMPRESSION; requests a default compromise between speed and compression (currently; equivalent to level 6). deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_STREAM_ERROR if level is not a valid compression level, or; Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible; with the version assumed by the caller (ZLIB_VERSION). msg is set to null; if there is no error message. deflateInit does not perform any compression:; this will be done by deflate().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:1260,perform,perform,1260,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['perform'],['perform']
Performance,"/* The application can compare zlibVersion and ZLIB_VERSION for consistency.; If the first character differs, the library code actually used is; not compatible with the zlib.h header file used by the application.; This check is automatically made by deflateInit and inflateInit.; */; /*; ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));. Initializes the internal stream state for compression. The fields; zalloc, zfree and opaque must be initialized before by the caller.; If zalloc and zfree are set to Z_NULL, deflateInit updates them to; use default allocation functions. The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:; 1 gives best speed, 9 gives best compression, 0 gives no compression at; all (the input data is simply copied a block at a time).; Z_DEFAULT_COMPRESSION requests a default compromise between speed and; compression (currently equivalent to level 6). deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not; enough memory, Z_STREAM_ERROR if level is not a valid compression level,; Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible; with the version assumed by the caller (ZLIB_VERSION).; msg is set to null if there is no error message. deflateInit does not; perform any compression: this will be done by deflate().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:1258,perform,perform,1258,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['perform'],['perform']
Performance,/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.; * It is easy to get rid of this optimization if necessary.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:15,optimiz,optimized,15,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,10,['optimiz'],"['optimization', 'optimized']"
Performance,/* The consistency check is performed on the chromaticities; this factors out; * variations because of the normalization (or not) of the end point Y; * values.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:28,perform,performed,28,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['perform'],['performed']
Performance,"/* The do_local_background case; called when all the following transforms are to; * be done:; *; * PNG_RGB_TO_GRAY; * PNG_COMPOSITE; * PNG_GAMMA; *; * This is a work-around for the fact that both the PNG_RGB_TO_GRAY and; * PNG_COMPOSITE code performs gamma correction, so we get double gamma; * correction. The fix-up is to prevent the PNG_COMPOSITE operation from; * happening inside libpng, so this routine sees an 8 or 16-bit gray+alpha; * row and handles the removal or pre-multiplication of the alpha channel.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:242,perform,performs,242,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['perform'],['performs']
Performance,"/* The fixed point conversion performs range checking and evaluates; * its argument multiple times, so must be used with care. The; * range checking uses the PNG specification values for a signed; * 32-bit fixed point value except that the values are deliberately; * rounded-to-zero to an integral value - 21474 (21474.83 is roughly; * (2^31-1) * 100000). 's' is a string that describes the value being; * converted.; *; * NOTE: this macro will raise a png_error if the range check fails,; * therefore it is normally only appropriate to use this on values; * that come from API calls or other sources where an out of range; * error indicates a programming error, not a data error!; *; * NOTE: by default this is off - the macro is not used - because the; * function call saves a lot of code.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:30,perform,performs,30,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['perform'],['performs']
Performance,"/* The following virtual functions are used in register allocation.; * They are not implemented because the existing interface and the logic; * at the caller side do not work for the elementized vector load and store.; *; * virtual unsigned isLoadFromStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual unsigned isStoreToStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual void storeRegToStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned SrcReg, bool isKill, int FrameIndex,; * const TargetRegisterClass *RC,; * Register VReg) const;; * virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned DestReg, int FrameIndex,; * const TargetRegisterClass *RC,; * const TargetRegisterInfo *TRI,; * Register VReg) const;; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h:202,load,load,202,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h,2,['load'],"['load', 'loadRegFromStackSlot']"
Performance,/* The input reference is from a PC relative load instruction. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h:45,load,load,45,interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h,1,['load'],['load']
Performance,/* The mutex protects the queue */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:26,queue,queue,26,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,1,['queue'],['queue']
Performance,/* The number of bytes to load from the input. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c:26,load,load,26,builtins/zstd/compress/zstdmt_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c,1,['load'],['load']
Performance,/* The option to print latency information alongside instructions */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h:23,latency,latency,23,interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h,1,['latency'],['latency']
Performance,"/* The proper indexing and unwinding of index is done by prior leafinfo in the chain. */; //virtual Double_t TFormLeafInfoMultiVarDim::ReadValue(char *where, Int_t instance = 0) {; // return TFormLeafInfo::ReadValue(where,instance);; //}; ////////////////////////////////////////////////////////////////////////////////; /// Load the current array sizes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx:325,Load,Load,325,tree/treeplayer/src/TFormLeafInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx,1,['Load'],['Load']
Performance,/* The queue is a circular buffer */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:7,queue,queue,7,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,1,['queue'],['queue']
Performance,/* The queues are exclusive or - only one can be used. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:7,queue,queues,7,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queues']
Performance,"/* The size of the row must be within the limits of this architecture.; * Because the read code can perform arbitrary transformations the; * maximum size is checked here. Because the code in png_read_start_row; * adds extra space ""for safety's sake"" in several places a conservative; * limit is used here.; *; * NOTE: it would be far better to check the size that is actually used,; * but the effect in the real world is minor and the changes are more; * extensive, therefore much more dangerous and much more difficult to; * write in a way that avoids compiler warnings.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:100,perform,perform,100,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['perform'],['perform']
Performance,"/* The standard Huffman tables are only valid for 8-bit data precision.; * If the precision is higher, force optimization on so that usable; * tables will be computed. This test can be removed if default tables; * are supplied that are valid for the desired precision.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c:109,optimiz,optimization,109,graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,1,['optimiz'],['optimization']
Performance,/* The structs used below are to force the load/store to be unaligned. This; * is accomplished with the __packed__ attribute. The __may_alias__ prevents; * tbaa metadata from being generated based on the struct and the type of the; * field inside of it.; */; /// Load a 16-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 16-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:43,load,load,43,interpreter/llvm-project/clang/lib/Headers/immintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h,3,"['Load', 'load']","['Load', 'load']"
Performance,"/* The version tests may need to be added to, but the problem warning has; * consistently been fixed in GCC versions which obtain wide-spread release.; * The problem is that many versions of GCC rearrange comparison expressions in; * the optimizer in such a way that the results of the comparison will change; * if signed integer overflow occurs. Such comparisons are not permitted in; * ANSI C90, however GCC isn't clever enough to work out that that do not occur; * below in png_ascii_from_fp and png_muldiv, so it produces a warning with; * -Wextra. Unfortunately this is highly dependent on the optimizer and the; * machine architecture so the warning comes and goes unpredictably and is; * impossible to ""fix"", even were that a good idea.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:238,optimiz,optimizer,238,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,2,['optimiz'],['optimizer']
Performance,/* There is no sign-extending load-byte instruction. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:30,load,load-byte,30,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['load'],['load-byte']
Performance,"/* These basic checks suggest that the data has not been; * modified, but if the check level is more than 1 perform; * our own crc32 checksum on the data.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:108,perform,perform,108,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['perform'],['perform']
Performance,"/* These buffer sizes are softly recommended.; * They are not required : ZSTD_compressStream*() happily accepts any buffer size, for both input and output.; * Respecting the recommended size just makes it a bit easier for ZSTD_compressStream*(),; * reducing the amount of memory shuffling and buffering, resulting in minor performance savings.; *; * However, note that these recommendations are from the perspective of a C caller program.; * If the streaming interface is invoked from some other language,; * especially managed ones such as Java or Go, through a foreign function interface such as jni or cgo,; * a major performance rule is to reduce crossing such interface to an absolute minimum.; * It's not rare that performance ends being spent more into the interface, rather than compression itself.; * In which cases, prefer using large buffers, as large as practical,; * for both input and output, to reduce the nb of roundtrips.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:323,perform,performance,323,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,3,['perform'],['performance']
Performance,"/* These functions give the user control over the scan-line filtering in; * libpng and the compression methods used by zlib. These functions are; * mainly useful for testing, as the defaults should work with most users.; * Those users who are tight on memory or want faster performance at the; * expense of compression can modify them. See the compression library; * header file (zlib.h) for an explanation of the compression functions.; */; /* Set the filtering method(s) used by libpng. Currently, the only valid; * value for ""method"" is 0.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:274,perform,performance,274,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['perform'],['performance']
Performance,/* This controls optimization of the reading of 16-bit and 32-bit; * values from PNG files. It can be set on a per-app-file basis: it; * just changes whether a macro is used when the function is called.; * The library builder sets the default; if read functions are not; * built into the library the macro implementation is forced on.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngconf.h:17,optimiz,optimization,17,graf2d/asimage/src/libAfterImage/libpng/pngconf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngconf.h,1,['optimiz'],['optimization']
Performance,"/* This file contains code for unified image loading from XCF file */; /********************************************************************/; /* Copyright (c) 2001 Sasha Vasko <sasha at aftercode.net> */; /********************************************************************/; /*; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2.1 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the Free Software; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/xcf.c:45,load,loading,45,graf2d/asimage/src/libAfterImage/xcf.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/xcf.c,1,['load'],['loading']
Performance,"/* This file contains code for unified image loading from XPM file */; /********************************************************************/; /* Copyright (c) 2001 Sasha Vasko <sasha at aftercode.net> */; /********************************************************************/; /*; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2.1 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the Free Software; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/xpm.c:45,load,loading,45,graf2d/asimage/src/libAfterImage/xpm.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/xpm.c,1,['load'],['loading']
Performance,"/* This file contains code for unified image loading from many file formats */; /********************************************************************/; /* Copyright (c) 2001 Sasha Vasko <sasha at aftercode.net> */; /********************************************************************/; /*; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2.1 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the Free Software; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/bmp.c:45,load,loading,45,graf2d/asimage/src/libAfterImage/bmp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/bmp.c,1,['load'],['loading']
Performance,"/* This file contains code for unified image loading from many file formats */; /********************************************************************/; /* Copyright (c) 2001,2004 Sasha Vasko <sasha at aftercode.net> */; /* Copyright (c) 2004 Maxim Nikulin <nikulin at gorodok.net> */; /********************************************************************/; /*; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2.1 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the Free Software; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA; */; /*#undef NO_DEBUG_OUTPUT*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c:45,load,loading,45,graf2d/asimage/src/libAfterImage/import.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c,1,['load'],['loading']
Performance,"/* This file contains code for unified image loading from many; * uncompressed GIFs */; /********************************************************************/; /* Copyright (c) 2001 Sasha Vasko <sasha at aftercode.net> */; /********************************************************************/; /*; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2.1 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the Free Software; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ungif.c:45,load,loading,45,graf2d/asimage/src/libAfterImage/ungif.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ungif.c,1,['load'],['loading']
Performance,"/* This file is part of the Vc project; Copyright (C) 2009-2010 Matthias Kretz <kretz@kde.org>. Permission to use, copy, modify, and distribute this software; and its documentation for any purpose and without fee is hereby; granted, provided that the above copyright notice appear in all; copies and that both that the copyright notice and this; permission notice and warranty disclaimer appear in supporting; documentation, and that the name of the author not be used in; advertising or publicity pertaining to distribution of the; software without specific, written prior permission. The author disclaim all warranties with regard to this; software, including all implied warranties of merchantability; and fitness. In no event shall the author be liable for any; special, indirect or consequential damages or any damages; whatsoever resulting from loss of use, data or profits, whether; in an action of contract, negligence or other tortious action,; arising out of or in connection with the use or performance of; this software. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/testVc.cxx:1002,perform,performance,1002,test/testVc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/testVc.cxx,1,['perform'],['performance']
Performance,"/* This function always performs a signed comparison, but __v16qi is a char; which may be signed or unsigned, so use __v16qs. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/emmintrin.h:24,perform,performs,24,interpreter/llvm-project/clang/lib/Headers/emmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/emmintrin.h,1,['perform'],['performs']
Performance,"/* This function always performs a signed comparison, but __v32qi is a char; which may be signed or unsigned, so use __v32qs. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:24,perform,performs,24,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['perform'],['performs']
Performance,"/* This function always performs a signed extension, but __v16qi is a char; which may be signed or unsigned, so use __v16qs. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:24,perform,performs,24,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,8,['perform'],['performs']
Performance,"/* This function always performs a signed extension, but __v32qi is a char; which may be signed or unsigned, so use __v32qs. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bwintrin.h:24,perform,performs,24,interpreter/llvm-project/clang/lib/Headers/avx512bwintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bwintrin.h,1,['perform'],['performs']
Performance,"/* This function is called once for every PNG image (except for PNG images; * that only use PNG_FILTER_VALUE_NONE for all rows) to set the; * implementations required to reverse the filtering of PNG rows. Reversing; * the filter is the first transformation performed on the row data. It is; * performed in place, therefore an implementation can be selected based on; * the image pixel format. If the implementation depends on image width then; * take care to ensure that it works correctly if the image is interlaced -; * interlacing causes the actual row width to vary.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:257,perform,performed,257,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,2,['perform'],['performed']
Performance,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:745,perform,performed,745,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,2,"['optimiz', 'perform']","['optimized', 'performed']"
Performance,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:761,perform,performed,761,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,2,"['optimiz', 'perform']","['optimized', 'performed']"
Performance,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64/powerpc64le. It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary. Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:387,optimiz,optimized,387,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,1,['optimiz'],['optimized']
Performance,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le. It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary. Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h:377,optimiz,optimized,377,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h,1,['optimiz'],['optimized']
Performance,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h:379,optimiz,optimized,379,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h,2,['optimiz'],['optimized']
Performance,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:379,optimiz,optimized,379,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,2,"['latency', 'optimiz']","['latency', 'optimized']"
Performance,"/* This is an error, but break and return an error; * at the end, because returning out of a loop makes; * it harder for the compiler to optimize.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/entropy_common.c:137,optimiz,optimize,137,builtins/zstd/common/entropy_common.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/entropy_common.c,1,['optimiz'],['optimize']
Performance,"/* This is used because in some compiler implementations non-aligned; * structure members are supported, so the offsetof approach below fails.; * Set PNG_ALIGN_SIZE=0 for compiler combinations where unaligned access; * is good for performance. Do not do this unless you have tested the; * result and understand it.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:231,perform,performance,231,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['perform'],['performance']
Performance,"/* This leaves the alpha channel in the output, so it has to be; * removed by the code below. Set the encoding to the 'OPTIMIZE'; * one so the code only has to hack on the pixels that require; * composition.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:119,OPTIMIZ,OPTIMIZE,119,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['OPTIMIZ'],['OPTIMIZE']
Performance,"/* This represents a system thread as used by the implementation. An; * alien implementaion, as loaded by g_thread_init can only count on; * ""sizeof (gpointer)"" bytes to store their info. We however need more; * for some of our native implementations. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/glibconfig-bogus.h:96,load,loaded,96,graf2d/win32gdk/gdk/src/glib/glibconfig-bogus.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/glibconfig-bogus.h,2,['load'],['loaded']
Performance,"/* This section is performed when method enter event occurs.; * It updates the virtual stack, or creates it if this is the first ; * method entry in the thread. The stack pointer is decreased.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:19,perform,performed,19,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,1,['perform'],['performed']
Performance,/* This section is performed when method leave event occurs; * It updates the virtual stack.; * Increases the stack pointer.; * If the stack pointer reached the top (left the global function); * increase the pointer and the top pointer.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:19,perform,performed,19,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,1,['perform'],['performed']
Performance,"/* This table is used to remember the original form of pointers; * to large buffers (64K). Such pointers are normalized with a zero offset.; * Since MSDOS is not a preemptive multitasking OS, this table is not; * protected from concurrent access. This hack doesn't work anyway on; * a protected system like OS/2. Use Microsoft C instead.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zutil.c:228,concurren,concurrent,228,builtins/zlib/zutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zutil.c,2,['concurren'],['concurrent']
Performance,/* This version performs Floyd-Steinberg dithering */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:16,perform,performs,16,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['perform'],['performs']
Performance,/* This version performs no dithering */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:16,perform,performs,16,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['perform'],['performs']
Performance,"/* Throttling, bytes/sec. <= 0 means no; 	 * throttle */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:45,throttle,throttle,45,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['throttle'],['throttle']
Performance,"/* To support symbol prefixing it is necessary to know *before* including png.h; * whether the fixed point (and maybe other) APIs are exported, because if they; * are not internal definitions may be required. This is handled below just; * before png.h is included, but load the configuration now if it is available.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:269,load,load,269,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['load'],['load']
Performance,"/* To use this define PNG_FILTER_OPTIMIZATIONS as the name of a function to; * call to install hardware optimizations for the above functions; simply; * replace whatever elements of the pp->read_filter[] array with a hardware; * specific (or, for that matter, generic) optimization.; *; * To see an example of this examine what configure.ac does when; * --enable-arm-neon is specified on the command line.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:104,optimiz,optimizations,104,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,2,['optimiz'],"['optimization', 'optimizations']"
Performance,/* Try to load the dll from the PATH... */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:10,load,load,10,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,3,['load'],['load']
Performance,"/* Try to pop data, NULL is returned in case of empty queue */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h:54,queue,queue,54,graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,1,['queue'],['queue']
Performance,"/* TuneCPU doesn't impact emission of ELF attributes, ELF attributes only; care about arch related features, so we can set TuneCPU as CPU. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp:3,Tune,TuneCPU,3,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYAsmPrinter.cpp,2,['Tune'],['TuneCPU']
Performance,"/* Unix might return different error codes indicating to try again.; * For Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; * decades ago, but better check both and let the compile optimize it. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:202,optimiz,optimize,202,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['optimiz'],['optimize']
Performance,"/* Unused formal parameter warnings are silenced using the following macro; * which is expected to have no bad effects on performance (optimizing; * compilers will probably remove it entirely). Note that if you replace; * it with something other than whitespace, you must include the terminating; * semicolon.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:122,perform,performance,122,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,2,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,/* Update the cache with whether the file gamma is significantly different; * from sRGB.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:14,cache,cache,14,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['cache'],['cache']
Performance,"/* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 	 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; /* See also https://www.mnot.net/cache_docs/ */; /* According to RFC 2616, Section 14.21, caching times should not exceed; 	 * one year. A year with 365 days corresponds to 31536000 seconds, a; 	 * leap; 	 * year to 31622400 seconds. For the moment, we just send whatever has; 	 * been configured, still the behavior for >1 year should be considered; 	 * as undefined. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:8,Cache,Cache-Control,8,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Cache'],['Cache-Control']
Performance,"/* Use NO_FLUSH; this gives zlib the maximum opportunity to optimize the; * process. If the LZ stream is truncated the sequential reader will; * terminally damage the stream, above, by reading the chunk header of the; * following chunk (it then exits with png_error).; *; * TODO: deal more elegantly with truncated IDAT lists.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:60,optimiz,optimize,60,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['optimiz'],['optimize']
Performance,/* Use light weight sync for load to load ordering. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:29,load,load,29,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,2,['load'],['load']
Performance,"/* Use read() to load a buffer -- return -1 on error, otherwise 0. Read from; state->fd, and update state->eof, state->err, and state->msg as appropriate.; This function needs to loop on read(), since read() is not guaranteed to; read the number of bytes requested, depending on the type of descriptor. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c:17,load,load,17,builtins/zlib/gzread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c,1,['load'],['load']
Performance,/* Use the data cache block flush. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:16,cache,cache,16,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,1,['cache'],['cache']
Performance,/* Use the data cache block touch for store transient. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:16,cache,cache,16,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,6,['cache'],['cache']
Performance,"/* Values for max_lazy_match, good_match and max_chain_length, depending on; * the desired pack level (0..9). The values given below have been tuned to; * exclude worst case performance for pathological files. Better values may be; * found for specific files.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate_cf.c:143,tune,tuned,143,builtins/zlib/deflate_cf.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate_cf.c,2,"['perform', 'tune']","['performance', 'tuned']"
Performance,"/* Values for state->max_lazy_match, good_match and max_chain_length, depending on; * the desired pack level (0..9). The values given below have been tuned to; * exclude worst case performance for pathological files. Better values may be; * found for specific files.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c:150,tune,tuned,150,core/zip/src/ZDeflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c,2,"['perform', 'tune']","['performance', 'tuned']"
Performance,/* Vector load with broadcast */; /// Loads a scalar single-precision floating point value from the; /// specified address pointed to by \a __a and broadcasts it to the elements; /// of a [4 x float] vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTSS </c> instruction.; ///; /// \param __a; /// The single-precision floating point value to be broadcast.; /// \returns A 128-bit vector of [4 x float] whose 32-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:10,load,load,10,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,2,"['Load', 'load']","['Loads', 'load']"
Performance,"/* Vector-reduction arithmetic accepts vectors as inputs and produces scalars as; * outputs. This class of vector operation forms the basis of many scientific; * computations. In vector-reduction arithmetic, the evaluation order is; * independent of the order of the input elements of V. * For floating-point intrinsics:; * 1. When using fadd/fmul intrinsics, the order of operations within the; * vector is unspecified (associative math).; * 2. When using fmin/fmax intrinsics, NaN or -0.0 elements within the vector; * produce unspecified results. * Used bisection method. At each step, we partition the vector with previous; * step in half, and the operation is performed on its two halves.; * This takes log2(n) steps where n is the number of elements in the vector.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:665,perform,performed,665,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,1,['perform'],['performed']
Performance,"/* WARNING: * png_read_transform_info (pngrtran.c) performs a simpler set of; * calculations to calculate the final pixel depth, then; * png_do_read_transforms actually does the transforms. This means that the; * code which effectively calculates this value is actually repeated in three; * separate places. They must all match. Innocent changes to the order of; * transformations can and will break libpng in a way that causes memory; * overwrites.; *; * TODO: fix this.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:51,perform,performs,51,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['perform'],['performs']
Performance,"/* Wait for data until at maximum until end_time is reached, NULL is returned; * in case of empty queue*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h:98,queue,queue,98,graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.h,1,['queue'],['queue']
Performance,/* Wait until there is space in the queue for the new job */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:36,queue,queue,36,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,1,['queue'],['queue']
Performance,"/* We always increment the offset by 64 KB, since, if the dict is longer,; * we truncate it to the last 64k, and if it's shorter, we still want to; * advance by a whole window length so we can provide the guarantee that; * there are only valid offsets in the window, which allows an optimization; * in LZ4_compress_fast_continue() where it uses noDictIssue even when the; * dictionary isn't a full 64k. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:283,optimiz,optimization,283,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['optimiz'],['optimization']
Performance,"/* We are in fact a superfluous threads, so we go to; 		 * the global pool and just hand the data further to; 		 * the next one waiting in the queue */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c:143,queue,queue,143,graf2d/win32gdk/gdk/src/glib/gthreadpool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c,1,['queue'],['queue']
Performance,/* We cache vertex data for single-contour polygons so that we can; * try a quick-and-dirty decomposition first.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/tess.h:6,cache,cache,6,graf3d/eve7/glu/tess.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/tess.h,1,['cache'],['cache']
Performance,/* We can finally safely perform the max-exponent check. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:25,perform,perform,25,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['perform'],['perform']
Performance,"/* We do not set a ""Cache-Control"" header here, but leave the default.; 	 * Since browsers do not send an OPTIONS request, we can not test the; 	 * effect anyway. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:20,Cache,Cache-Control,20,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Cache'],['Cache-Control']
Performance,/* We must cache the pixmap in the GdkWindowWin32Data and; * paint it each time we get WM_ERASEBKGND; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkwindow-win32.c:11,cache,cache,11,graf2d/win32gdk/gdk/src/gdk/win32/gdkwindow-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkwindow-win32.c,1,['cache'],['cache']
Performance,"/* We only set the loaded table as valid if it contains all non-zero; * weights. Otherwise, we set it to check */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:19,load,loaded,19,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['load'],['loaded']
Performance,/* We optimize for a minimal match of four bytes */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate_cf.c:6,optimiz,optimize,6,builtins/zlib/deflate_cf.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate_cf.c,1,['optimiz'],['optimize']
Performance,"/* We use a full-image coefficient buffer when doing Huffman optimization,; * and also for writing multiple-scan JPEG files. In all cases, the DCT; * step is run during the first pass, and subsequent passes need only read; * the buffered coefficients.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c:61,optimiz,optimization,61,graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c,1,['optimiz'],['optimization']
Performance,/* We're already at a sync point so don't load any more until; * we're able to flush this sync point.; * This likely happened because the job table was full so we; * couldn't add our job.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c:42,load,load,42,builtins/zstd/compress/zstdmt_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c,1,['load'],['load']
Performance,"/* When applicable, dictionary's ID is written into frame header (default:1) */; /* multi-threading parameters */; /* These parameters are only active if multi-threading is enabled (compiled with build macro ZSTD_MULTITHREAD).; * Otherwise, trying to set any other value than default (0) will be a no-op and return an error.; * In a situation where it's unknown if the linked library supports multi-threading or not,; * setting ZSTD_c_nbWorkers to any value >= 1 and consulting the return value provides a quick way to check this property.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:84,multi-thread,multi-threading,84,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,3,['multi-thread'],['multi-threading']
Performance,"/* When spilling to stack */; // The SGPRs are written into this VGPR, which is then written to scratch; // (or vice versa for loads).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:127,load,loads,127,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['load'],['loads']
Performance,/* When using a dictionary the entire dictionary is valid if a single byte of the dictionary; * is within the window. We invalidate the dictionary (and set loadedDictEnd to 0) when it isn't; * valid for the entire block. So this check is sufficient to find the lowest valid match index.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h:156,load,loadedDictEnd,156,builtins/zstd/compress/zstd_compress_internal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h,1,['load'],['loadedDictEnd']
Performance,/* Will only have a value if used by the progressive image loader */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:59,load,loader,59,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,2,['load'],['loader']
Performance,"/* With these routines we avoid an integer divide, which will be slower on; * most machines. However, it does take more operations than the corresponding; * divide method, so it may be slower on a few RISC systems. There are two; * shifts (by 8 or 16 bits) and an addition, versus a single integer divide.; *; * Note that the rounding factors are NOT supposed to be the same! 128 and; * 32768 are correct for the NODIV code; 127 and 32767 are correct for the; * standard method.; *; * [Optimized code by Greg Roelofs and Mark Adler...blame us for bugs. :-) ]; */; /* fg and bg should be in `gamma 1.0' space; alpha is the opacity */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:486,Optimiz,Optimized,486,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['Optimiz'],['Optimized']
Performance,/* Would like to use Vector Shift Left Double by Octet; Immediate here to use the immediate form and avoid; load of __N * 8 value into a separate VR. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:108,load,load,108,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,1,['load'],['load']
Performance,/* Write an IDAT containing the data then reset the buffer. The; * first IDAT may need deflate header optimization.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c:102,optimiz,optimization,102,graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,1,['optimiz'],['optimization']
Performance,/* XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:65,load,load,65,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['load'],['load']
Performance,/* XXH_VSX_BE */; /*; * Performs an unaligned load and byte swaps it on big endian.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:24,Perform,Performs,24,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,"['Perform', 'load']","['Performs', 'load']"
Performance,"/* ZSTD_MULTITHREAD not defined */; /* ========================== */; /* No multi-threading support */; /* ========================== */; /* We don't need any data, but if it is empty, malloc() might return NULL. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:76,multi-thread,multi-threading,76,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,1,['multi-thread'],['multi-threading']
Performance,"/* ZSTD_d_forceIgnoreChecksum; * Experimental parameter.; * Default is 0 == disabled. Set to 1 to enable; *; * Tells the decompressor to skip checksum validation during decompression, regardless; * of whether checksumming was specified during compression. This offers some; * slight performance benefits, and may be useful for debugging.; * Param has values of type ZSTD_forceIgnoreChecksum_e; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:283,perform,performance,283,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['perform'],['performance']
Performance,"/* ZSTD_decompressSequencesLong() :; * decompression function triggered when a minimum share of offsets is considered ""long"",; * aka out of cache.; * note : ""long"" definition seems overloaded here, sometimes meaning ""wider than bitstream register"", and sometimes meaning ""farther than memory cache distance"".; * This function will try to mitigate main memory latency through the use of prefetching */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c:140,cache,cache,140,builtins/zstd/decompress/zstd_decompress_block.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c,3,"['cache', 'latency']","['cache', 'latency']"
Performance,"/* ZSTD_execSequenceEnd():; * This version handles cases that are near the end of the output buffer. It requires; * more careful checks to make sure there is no overflow. By separating out these hard; * and unlikely cases, we can speed up the common cases.; *; * NOTE: This function needs to be fast for a single long sequence, but doesn't need; * to be optimized for many small sequences, since those fall into ZSTD_execSequence().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c:354,optimiz,optimized,354,builtins/zstd/decompress/zstd_decompress_block.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c,1,['optimiz'],['optimized']
Performance,"/* ZSTD_getMatchPrice() :; * Provides the cost of the match part (offset + matchLength) of a sequence; * Must be combined with ZSTD_fullLiteralsCost() to get the full cost of a sequence.; * optLevel: when <2, favors small offset for decompression speed (improved cache efficiency) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c:263,cache,cache,263,builtins/zstd/compress/zstd_opt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c,1,['cache'],['cache']
Performance,"/* ZSTD_indexTooCloseToMax() :; * minor optimization : prefer memset() rather than reduceIndex(); * which is measurably slow in some circumstances (reported for Visual Studio).; * Works when re-using a context for a lot of smallish inputs :; * if all inputs are smaller than ZSTD_INDEXOVERFLOW_MARGIN,; * memset() will be triggered before reduceIndex().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:40,optimiz,optimization,40,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['optimiz'],['optimization']
Performance,"/* ZSTD_initCStream_advanced() :; * pledgedSrcSize must be exact.; * if srcSize is not known at init time, use value ZSTD_CONTENTSIZE_UNKNOWN.; * dict is loaded with default parameters ZSTD_dct_auto and ZSTD_dlm_byCopy. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:154,load,loaded,154,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['load'],['loaded']
Performance,/* _XVERTEXT_INCLUDED_ */; /* ---------------------------------------------------------------------- */; /* Make sure cache size is set */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx:118,cache,cache,118,graf2d/x11/src/Rotated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx,1,['cache'],['cache']
Performance,"/* __x86_64__ */; /*; * movdir64b - Move 64 bytes as direct store.; * The destination must be 64 byte aligned, and the store is atomic.; * The source address has no alignment requirement, and the load from; * the source address is not atomic.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/movdirintrin.h:196,load,load,196,interpreter/llvm-project/clang/lib/Headers/movdirintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/movdirintrin.h,1,['load'],['load']
Performance,/* __x86_64__ */; /// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param __A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see _rdpmc,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:42,perform,performance,42,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,4,['perform'],['performance']
Performance,"/* advantage to algorithm using less memory, to reduce cache eviction */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/huf_decompress.c:55,cache,cache,55,builtins/zstd/decompress/huf_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/huf_decompress.c,1,['cache'],['cache']
Performance,/* already loaded */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:11,load,loaded,11,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['load'],['loaded']
Performance,"/* array of length elements or NULL */; /****f* libAfterImage/asfont/get_asfont_glyph_spacing(); * NAME; * get_asfont_glyph_spacing(); * SYNOPSIS; * Bool get_asfont_glyph_spacing( ASFont* font, int *x, int *y );; * INPUTS; * font - Loaded ASFont structure.; * x - pointer to the variable to receive horizontal spacing value.; * y - pointer to the variable to receive vertical spacing value.; * RETURN VALUE; * True if meaningfull information has been returned.; * DESCRIPTION; * Returns inter-glyph spacing of specified font.; *********/; /****f* libAfterImage/asfont/set_asfont_glyph_spacing(); * NAME; * set_asfont_glyph_spacing(); * SYNOPSIS; * Bool set_asfont_glyph_spacing( ASFont* font, int x, int y );; * INPUTS; * font - Loaded ASFont structure.; * x - new horizontal spacing value.; * y - new vertical spacing value.; * RETURN VALUE; * TRue on success.; * DESCRIPTION; * Changes inter-glyph spacing of the specified font.; *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h:232,Load,Loaded,232,graf2d/asimage/src/libAfterImage/asfont.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h,2,['Load'],['Loaded']
Performance,/* block flush performed */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:15,perform,performed,15,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,3,['perform'],['performed']
Performance,/* body_len is the length of the entire queue in bytes; 	 * len is the length of the current message; 	 * data_len is the length of the current message's data payload; 	 * header_len is the length of the current message's header */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:40,queue,queue,40,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,/* cache it */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx:3,cache,cache,3,graf2d/x11/src/Rotated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx,1,['cache'],['cache']
Performance,/* cleanup cache (preserved over cleanup) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:11,cache,cache,11,interpreter/llvm-project/clang/lib/Headers/unwind.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h,1,['cache'],['cache']
Performance,"/* code is dev signed, cannot be loaded into prod signed code; (will go away with rdar://problem/28322552) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:33,load,loaded,33,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,1,['load'],['loaded']
Performance,/* colors[i] is only zero if the pixel at that location hasn't; * been allocated yet. This is a sanity check required for proper; * color allocation by the progressive image loader; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:174,load,loader,174,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,1,['load'],['loader']
Performance,/* complete loading into inBuffer in buffered mode */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:12,load,loading,12,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['load'],['loading']
Performance,/* compression parameters verification and optimization */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:43,optimiz,optimization,43,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['optimiz'],['optimization']
Performance,/* convert 24-bit packed to 32-bit unpacked */; /* todo: optimize this */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkrgb.c:57,optimiz,optimize,57,graf2d/win32gdk/gdk/src/gdk/gdkrgb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkrgb.c,1,['optimiz'],['optimize']
Performance,"/* count number of items in cache, for debugging */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx:28,cache,cache,28,graf2d/x11/src/Rotated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx,1,['cache'],['cache']
Performance,"/* current mask and opcode, overwritten by; 				 * memmove() */; /* Length of the message being read at the front of the; 				 * queue. Cast to 31 bit is OK, since we limited; 				 * data_len before. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:129,queue,queue,129,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,/* define it for speed optimization */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/res/ROOT/RSha256.hxx:23,optimiz,optimization,23,core/foundation/res/ROOT/RSha256.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/res/ROOT/RSha256.hxx,1,['optimiz'],['optimization']
Performance,"/* deflate.c -- compress data using the deflation algorithm; * Copyright (C) 1995-2005 Jean-loup Gailly.; * For conditions of distribution and use, see copyright notice in zlib.h; */; /*; * ALGORITHM; *; * The ""deflation"" process depends on being able to identify portions; * of the input text which are identical to earlier input (within a; * sliding window trailing behind the input currently being processed).; *; * The most straightforward technique turns out to be the fastest for; * most input files: try all possible matches and select the longest.; * The key feature of this algorithm is that insertions into the string; * dictionary are very simple and thus fast, and deletions are avoided; * completely. Insertions are performed at each input character, whereas; * string matches are performed only when the previous match ends. So it; * is preferable to spend more time in matches to allow very fast string; * insertions and avoid deletions. The matching algorithm for small; * strings is inspired from that of Rabin & Karp. A brute force approach; * is used to find longer strings when a small match has been found.; * A similar algorithm is used in comic (by Jan-Mark Wams) and freeze; * (by Leonid Broukhis).; * A previous version of this file used a more sophisticated algorithm; * (by Fiala and Greene) which is guaranteed to run in linear amortized; * time, but has a larger average cost, uses more memory and is patented.; * However the F&G algorithm may be faster for some highly redundant; * files if the parameter max_chain_length (described below) is too large.; *; * ACKNOWLEDGEMENTS; *; * The idea of lazy evaluation of matches is due to Jan-Mark Wams, and; * I found it in 'freeze' written by Leonid Broukhis.; * Thanks to many people for bug reports and testing.; *; * REFERENCES; *; * Deutsch, L.P.,""DEFLATE Compressed Data Format Specification"".; * Available in http://www.ietf.org/rfc/rfc1951.txt; *; * A description of the Rabin and Karp algorithm is given in the book; *",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/deflate.c:729,perform,performed,729,graf2d/asimage/src/libAfterImage/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/deflate.c,2,['perform'],['performed']
Performance,"/* deflate.c -- compress data using the deflation algorithm; * Copyright (C) 1995-2013 Jean-loup Gailly and Mark Adler; * For conditions of distribution and use, see copyright notice in zlib.h; */; /*; * ALGORITHM; *; * The ""deflation"" process depends on being able to identify portions; * of the input text which are identical to earlier input (within a; * sliding window trailing behind the input currently being processed).; *; * The most straightforward technique turns out to be the fastest for; * most input files: try all possible matches and select the longest.; * The key feature of this algorithm is that insertions into the string; * dictionary are very simple and thus fast, and deletions are avoided; * completely. Insertions are performed at each input character, whereas; * string matches are performed only when the previous match ends. So it; * is preferable to spend more time in matches to allow very fast string; * insertions and avoid deletions. The matching algorithm for small; * strings is inspired from that of Rabin & Karp. A brute force approach; * is used to find longer strings when a small match has been found.; * A similar algorithm is used in comic (by Jan-Mark Wams) and freeze; * (by Leonid Broukhis).; * A previous version of this file used a more sophisticated algorithm; * (by Fiala and Greene) which is guaranteed to run in linear amortized; * time, but has a larger average cost, uses more memory and is patented.; * However the F&G algorithm may be faster for some highly redundant; * files if the parameter max_chain_length (described below) is too large.; *; * ACKNOWLEDGEMENTS; *; * The idea of lazy evaluation of matches is due to Jan-Mark Wams, and; * I found it in 'freeze' written by Leonid Broukhis.; * Thanks to many people for bug reports and testing.; *; * REFERENCES; *; * Deutsch, L.P.,""DEFLATE Compressed Data Format Specification"".; * Available in http://tools.ietf.org/html/rfc1951; *; * A description of the Rabin and Karp algorithm is given i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:743,perform,performed,743,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,4,['perform'],['performed']
Performance,"/* dll was already loaded, no need to do it for the second time */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:19,load,loaded,19,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,1,['load'],['loaded']
Performance,/* do not invoke multi-threading when src size is too small */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:17,multi-thread,multi-threading,17,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['multi-thread'],['multi-threading']
Performance,/* do not optimize char* */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:10,optimiz,optimize,10,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,1,['optimiz'],['optimize']
Performance,/* do not perform lazy search above this match length */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:10,perform,perform,10,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,4,['perform'],['perform']
Performance,/* don't even load anything */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c:14,load,load,14,builtins/zstd/compress/zstdmt_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c,1,['load'],['load']
Performance,/* don't load invalid pages */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:9,load,load,9,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,1,['load'],['load']
Performance,/* don't use static : performance detrimental */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:22,perform,performance,22,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,2,['perform'],['performance']
Performance,/* don't want to try and load font as X11 unless requested to do so */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.c:25,load,load,25,graf2d/asimage/src/libAfterImage/asfont.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.c,1,['load'],['load']
Performance,/* dyld used to load this is a platform binary */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:16,load,load,16,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,1,['load'],['load']
Performance,"/* e->Org is an unprocessed vertex - just combine them, and wait; * for e->Org to be pulled from the queue; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c:101,queue,queue,101,graf3d/eve7/glu/sweep.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c,1,['queue'],['queue']
Performance,/* empty cache on next vertex() call */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/tess.h:9,cache,cache,9,graf3d/eve7/glu/tess.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/tess.h,1,['cache'],['cache']
Performance,"/* end collector dll part. */; /* loadiJIT_Funcs() : this function is called just in the beginning ; * and is responsible to load the functions from BistroJavaCollector.dll; * result:; * on success: the functions loads, iJIT_DLL_is_missing=0, return value = 1; * on failure: the functions are NULL, iJIT_DLL_is_missing=1, return value = 0; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:125,load,load,125,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,2,['load'],"['load', 'loads']"
Performance,"/* ensures dictionary is always loaded as rawContent, even if it starts with ZSTD_MAGIC_DICTIONARY */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:32,load,loaded,32,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['load'],['loaded']
Performance,"/* even if !queueEmpty, (possible if numThreadsBusy >= threadLimit),; * a few threads will be shutdown while !queueEmpty,; * but enough threads will remain active to finish the queue */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:12,queue,queueEmpty,12,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,3,['queue'],"['queue', 'queueEmpty']"
Performance,/* fill DTable; * We fill all entries of each weight in order.; * That way length is a constant for each iteration of the outter loop.; * We can switch based on the length to a different inner loop which is; * optimized for that particular case.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/huf_decompress.c:210,optimiz,optimized,210,builtins/zstd/decompress/huf_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/huf_decompress.c,1,['optimiz'],['optimized']
Performance,/* finish queue */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c:10,queue,queue,10,builtins/zstd/decompress/zstd_decompress_block.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c,1,['queue'],['queue']
Performance,/* flag to limit concurrent making */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/crc32.c:17,concurren,concurrent,17,builtins/zlib/crc32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/crc32.c,3,['concurren'],['concurrent']
Performance,"/* fprintf( stderr, ""compressed from %d to %d\n"", size, comp_size ); */; /* its better to do it here from performance point of view since most of; 	 * the data will be well compressed */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.c:106,perform,performance,106,graf2d/asimage/src/libAfterImage/asstorage.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.c,1,['perform'],['performance']
Performance,/* get pixel value and index into the cache */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:38,cache,cache,38,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['cache'],['cache']
Performance,/* global representing whether the BistroJavaCollector can't be loaded */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:64,load,loaded,64,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,1,['load'],['loaded']
Performance,"/* http://www.webdav.org/specs/rfc4918.html, 9.1:; * Some PROPFIND results MAY be cached, with care,; * as there is no cache validation mechanism for; * most properties. This method is both safe and; * idempotent (see Section 9.1 of [RFC2616]). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:82,cache,cached,82,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,2,['cache'],"['cache', 'cached']"
Performance,"/* http://www.webdav.org/specs/rfc4918.html, 9.1:; * When MKCOL is invoked without a request body,; * the newly created collection SHOULD have no; * members. A MKCOL request message may contain; * a message body. The precise behavior of a MKCOL; * request when the body is present is undefined,; * ... ==> We do not support MKCOL with body data.; * This method is idempotent, but not safe (see; * Section 9.1 of [RFC2616]). Responses to this; * method MUST NOT be cached. */; /* Methods for write access to files on WEBDAV (RFC 2518) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:464,cache,cached,464,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['cache'],['cached']
Performance,"/* if == 1 : dictionary is ""new"" for working context, and presumed ""cold"" (not in cpu cache) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_internal.h:86,cache,cache,86,builtins/zstd/decompress/zstd_decompress_internal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_internal.h,1,['cache'],['cache']
Performance,"/* if XImage is cached, need to recreate the bitmap */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx:16,cache,cached,16,graf2d/x11/src/Rotated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx,1,['cache'],['cached']
Performance,/* if the dll wasn't loaded - exit. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:21,load,loaded,21,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,1,['load'],['loaded']
Performance,"/* if this item is bigger than whole cache, forget it */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx:37,cache,cache,37,graf2d/x11/src/Rotated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx,1,['cache'],['cache']
Performance,"/* index of end of dictionary, within context's referential.; * When loadedDictEnd != 0, a dictionary is in use, and still valid.; * This relies on a mechanism to set loadedDictEnd=0 when dictionary is no longer within distance.; * Such mechanism is provided within ZSTD_window_enforceMaxDist() and ZSTD_checkDictValidity().; * When dict referential is copied into active context (i.e. not attached),; * loadedDictEnd == dictSize, since referential starts from zero.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h:69,load,loadedDictEnd,69,builtins/zstd/compress/zstd_compress_internal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h,3,['load'],['loadedDictEnd']
Performance,"/* infback.c -- inflate using a call-back interface; * Copyright (C) 1995-2005 Mark Adler; * For conditions of distribution and use, see copyright notice in zlib.h; */; /*; This code is largely copied from inflate.c. Normally either infback.o or; inflate.o would be linked into an application--not both. The interface; with inffast.c is retained so that optimized assembler-coded versions of; inflate_fast() can be used with either inflate.c or infback.c.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/infback.c:354,optimiz,optimized,354,graf2d/asimage/src/libAfterImage/zlib/infback.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/infback.c,1,['optimiz'],['optimized']
Performance,"/* infback.c -- inflate using a call-back interface; * Copyright (C) 1995-2011 Mark Adler; * For conditions of distribution and use, see copyright notice in zlib.h; */; /*; This code is largely copied from inflate.c. Normally either infback.o or; inflate.o would be linked into an application--not both. The interface; with inffast.c is retained so that optimized assembler-coded versions of; inflate_fast() can be used with either inflate.c or infback.c.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/infback.c:354,optimiz,optimized,354,builtins/zlib/infback.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/infback.c,1,['optimiz'],['optimized']
Performance,/* is it already missing... or the load of functions from the DLL failed */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:35,load,load,35,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,1,['load'],['load']
Performance,"/* keep is currently just the per-chunk setting, if there was no; * setting change it to the global default now (not that this may; * still be AS_DEFAULT) then obtain the cache of the chunk if required,; * if not simply skip the chunk.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:171,cache,cache,171,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['cache'],['cache']
Performance,/* latency in seconds */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/mac/DirectoryWatcher-mac.cpp:3,latency,latency,3,interpreter/llvm-project/clang/lib/DirectoryWatcher/mac/DirectoryWatcher-mac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/mac/DirectoryWatcher-mac.cpp,1,['latency'],['latency']
Performance,/* list of unicodes from current locale; 							 * - we use it to limit number of glyphs; 							 * we load */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h:103,load,load,103,graf2d/asimage/src/libAfterImage/asfont.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h,1,['load'],['load']
Performance,/* load */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:3,load,load,3,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,7,['load'],['load']
Performance,/* load 8 bytes from src[i] into MM0 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/transform.c:3,load,load,3,graf2d/asimage/src/libAfterImage/transform.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/transform.c,1,['load'],['load']
Performance,"/* load dictionary in ""content-only"" mode (no header analysis) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c:3,load,load,3,builtins/zstd/compress/zstdmt_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c,1,['load'],['load']
Performance,/* load entropy tables */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_ddict.c:3,load,load,3,builtins/zstd/decompress/zstd_ddict.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_ddict.c,2,['load'],['load']
Performance,/* load the Function from the DLL */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:3,load,load,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,1,['load'],['load']
Performance,/* loadStarted */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/qt5webdisplay/rootwebview.cpp:3,load,loadStarted,3,gui/qt5webdisplay/rootwebview.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/qt5webdisplay/rootwebview.cpp,1,['load'],['loadStarted']
Performance,/* loadedDictEnd is expressed within the referential of the active context */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:3,load,loadedDictEnd,3,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['load'],['loadedDictEnd']
Performance,"/* longest_match() with minor change to improve performance (in terms of; * execution time).; *; * The pristine longest_match() function is sketched bellow (strip the; * then-clause of the ""#ifdef UNALIGNED_OK""-directive); *; * ------------------------------------------------------------; * uInt longest_match(...) {; * ...; * do {; * match = s->window + cur_match; //s0; * if (*(ushf*)(match+best_len-1) != scan_end || //s1; * *(ushf*)match != scan_start) continue; //s2; * ...; *; * do {; * } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&; * *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&; * *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&; * *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&; * scan < strend); //s3; *; * ...; * } while(cond); //s4; *; * -------------------------------------------------------------; *; * The change include:; *; * 1) The hottest statements of the function is: s0, s1 and s4. Pull them; * together to form a new loop. The benefit is two-fold:; *; * o. Ease the compiler to yield good code layout: the conditional-branch; * corresponding to s1 and its biased target s4 become very close (likely,; * fit in the same cache-line), hence improving instruction-fetching; * efficiency.; *; * o. Ease the compiler to promote ""s->window"" into register. ""s->window""; * is loop-invariant; it is supposed to be promoted into register and keep; * the value throughout the entire loop. However, there are many such; * loop-invariant, and x86-family has small register file; ""s->window"" is; * likely to be chosen as register-allocation victim such that its value; * is reloaded from memory in every single iteration. By forming a new loop,; * ""s->window"" is loop-invariant of that newly created tight loop. It is; * lot easier for compiler to promote this quantity to register and keep; * its value throughout the entire small loop.; *; * 2) Transfrom s3 such that it examines sizeof(long)-byte-match at a time.; * This is done by:; * ------------------------------------------------; * v1 ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate_cf.c:48,perform,performance,48,builtins/zlib/deflate_cf.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate_cf.c,1,['perform'],['performance']
Performance,/* must load everything in one go */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:8,load,load,8,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['load'],['load']
Performance,/* need more data to skip -- load up output buffer */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c:29,load,load,29,builtins/zlib/gzread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c,1,['load'],['load']
Performance,/* need output data -- for small len or new stream load up our output; buffer */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c:51,load,load,51,builtins/zlib/gzread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c,1,['load'],['load']
Performance,/* new cache size */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx:7,cache,cache,7,graf2d/x11/src/Rotated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx,1,['cache'],['cache']
Performance,/* next pass is either optimization or output of next scan */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c:23,optimiz,optimization,23,graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,1,['optimiz'],['optimization']
Performance,/* next pass is either output of scan 0 (after optimization); * or output of scan 1 (if no optimization).; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c:47,optimiz,optimization,47,graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,2,['optimiz'],['optimization']
Performance,/* not allowed to cache font ID's */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx:18,cache,cache,18,graf2d/x11/src/Rotated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx,1,['cache'],['cache']
Performance,/* not enough input to load full header */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c:23,load,load,23,builtins/zstd/decompress/zstd_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c,1,['load'],['load']
Performance,"/* not enough input, wait for more */; /* decode loaded input */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c:49,load,loaded,49,builtins/zstd/decompress/zstd_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c,1,['load'],['loaded']
Performance,/* not loaded just yet - lets do it :*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.c:7,load,loaded,7,graf2d/asimage/src/libAfterImage/asfont.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.c,1,['load'],['loaded']
Performance,"/* not required, just to generate faster code (saves a function pointer load from IAT and an indirect jump) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/huf.h:72,load,load,72,builtins/zstd/common/huf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/huf.h,1,['load'],['load']
Performance,/* note : a loadPrefix becomes an internal CDict */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c:12,load,loadPrefix,12,builtins/zstd/compress/zstdmt_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c,1,['load'],['loadPrefix']
Performance,"/* notes on macros:; * having DISABLE_MEM_POOLS defined, disables mem_chunks alltogether, their; * allocations are performed through ordinary g_malloc/g_free.; * having G_DISABLE_CHECKS defined disables use of glib_mem_profiler_table and; * g_mem_profile().; * REALLOC_0_WORKS is defined if g_realloc (NULL, x) works.; * SANE_MALLOC_PROTOS is defined if the systems malloc() and friends functions; * match the corresponding GLib prototypes, keep configure.in and gmem.h in sync here.; * if ENABLE_GC_FRIENDLY is defined, freed memory should be 0-wiped.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c:115,perform,performed,115,graf2d/win32gdk/gdk/src/glib/gmem.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c,1,['perform'],['performed']
Performance,/* number of cached vertices */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/tess.h:13,cache,cached,13,graf3d/eve7/glu/tess.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/tess.h,1,['cache'],['cached']
Performance,"/* only allow pulling `cacheSize` number of entries; * into the cache or chainTable beyond `minChain`,; * to replace the entries pulled out of the; * chainTable into the cache. This lets us reach; * back further without increasing the total number; * of entries in the chainTable, guaranteeing the; * DDSS chain table will fit into the space; * allocated for the regular one. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_lazy.c:23,cache,cacheSize,23,builtins/zstd/compress/zstd_lazy.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_lazy.c,3,['cache'],"['cache', 'cacheSize']"
Performance,/* optimization for __gl_meshTessellateMonoRegion() */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c:3,optimiz,optimization,3,graf3d/eve7/glu/sweep.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c,1,['optimiz'],['optimization']
Performance,/* optimize adding to cache? */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gcompletion.c:3,optimiz,optimize,3,graf2d/win32gdk/gdk/src/glib/gcompletion.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gcompletion.c,2,"['cache', 'optimiz']","['cache', 'optimize']"
Performance,/* optimize pixel transfer rates */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ximage.c:3,optimiz,optimize,3,graf2d/asimage/src/libAfterImage/ximage.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ximage.c,1,['optimiz'],['optimize']
Performance,/* optimize singleton sets */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c:3,optimiz,optimize,3,interpreter/llvm-project/llvm/lib/Support/regcomp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c,1,['optimiz'],['optimize']
Performance,/* optimized for speed */; /* Process the input block. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c:3,optimiz,optimized,3,core/zip/src/ZDeflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c,1,['optimiz'],['optimized']
Performance,/* part already loaded*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c:16,load,loaded,16,builtins/zstd/decompress/zstd_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c,1,['load'],['loaded']
Performance,/* perform the first integration */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx:3,perform,perform,3,roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,1,['perform'],['perform']
Performance,/* performing dummy pass for 2-pass quant */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jpegint.h:3,perform,performing,3,graf2d/asimage/src/libAfterImage/libjpeg/jpegint.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jpegint.h,1,['perform'],['performing']
Performance,/* personality cache (for personality's benefit) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:15,cache,cache,15,interpreter/llvm-project/clang/lib/Headers/unwind.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h,1,['cache'],['cache']
Performance,/* pledges that last 64KB decompressed data will remain available unmodified. This optimization skips storage operations in tmp buffers. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.h:83,optimiz,optimization,83,builtins/lz4/lz4frame.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.h,1,['optimiz'],['optimization']
Performance,/* png_unknown_chunk is a structure to hold queued chunks for which there is; * no specific support. The idea is that we can use this to queue; * up private chunks for output even though the library doesn't actually; * know about their semantics.; *; * The data in the structure is set by libpng on read and used on write.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:44,queue,queued,44,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,2,['queue'],"['queue', 'queued']"
Performance,"/* pngrio.c - functions for data input; *; * Copyright (c) 2018 Cosmin Truta; * Copyright (c) 1998-2002,2004,2006-2016,2018 Glenn Randers-Pehrson; * Copyright (c) 1996-1997 Andreas Dilger; * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.; *; * This code is released under the libpng license.; * For conditions of distribution and use, see the disclaimer; * and license in png.h; *; * This file provides a location for all input. Users who need; * special handling are expected to write a function that has the same; * arguments as this and performs a similar function, but that possibly; * has a different input method. Note that you shouldn't change this; * function, but rather write a replacement function and then make; * libpng use it at run time with png_set_read_fn(...).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrio.c:551,perform,performs,551,graf2d/asimage/src/libAfterImage/libpng/pngrio.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrio.c,1,['perform'],['performs']
Performance,"/* pngwio.c - functions for data output; *; * Copyright (c) 2018 Cosmin Truta; * Copyright (c) 1998-2002,2004,2006-2014,2016,2018 Glenn Randers-Pehrson; * Copyright (c) 1996-1997 Andreas Dilger; * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.; *; * This code is released under the libpng license.; * For conditions of distribution and use, see the disclaimer; * and license in png.h; *; * This file provides a location for all output. Users who need; * special handling are expected to write functions that have the same; * arguments as these and perform similar functions, but that possibly; * use different output methods. Note that you shouldn't change these; * functions, but rather write replacement functions and then change; * them at run time with png_set_write_fn(...).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwio.c:559,perform,perform,559,graf2d/asimage/src/libAfterImage/libpng/pngwio.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwio.c,1,['perform'],['perform']
Performance,/* pointer into main cache array */; /* This array lists the candidate colormap indexes. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:21,cache,cache,21,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['cache'],['cache']
Performance,/* priority queue of vertex events */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/tess.h:12,queue,queue,12,graf3d/eve7/glu/tess.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/tess.h,1,['queue'],['queue']
Performance,/* propagation barrier cache (valid after phase 1) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:23,cache,cache,23,interpreter/llvm-project/clang/lib/Headers/unwind.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h,1,['cache'],['cache']
Performance,"/* public fields */; /* Mode flag: TRUE for optimization, FALSE for actual data output */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcphuff.c:44,optimiz,optimization,44,graf2d/asimage/src/libAfterImage/libjpeg/jcphuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcphuff.c,1,['optimiz'],['optimization']
Performance,"/* public fields */; /* These fields are loaded into local variables at start of each MCU.; * In case of suspension, we exit WITHOUT updating them.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c:41,load,loaded,41,graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,1,['load'],['loaded']
Performance,/* queue depth */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/test/RIoUring.cxx:3,queue,queue,3,io/io/test/RIoUring.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/test/RIoUring.cxx,1,['queue'],['queue']
Performance,/* queue is full */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,queue,queue,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['queue'],['queue']
Performance,"/* refuses to load a dictionary if it does not respect Zstandard's specification, starting with ZSTD_MAGIC_DICTIONARY */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:14,load,load,14,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['load'],['load']
Performance,/* remaining to load to get full skippable frame header */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c:16,load,load,16,builtins/zstd/decompress/zstd_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c,1,['load'],['load']
Performance,/* remove elements from cache as needed */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx:24,cache,cache,24,graf2d/x11/src/Rotated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx,1,['cache'],['cache']
Performance,"/* result of BIT_reloadDStream() */; /* 1,2,4,8 would be better for bitmap combinations, but slows down performance a bit ... :( */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h:104,perform,performance,104,builtins/zstd/common/bitstream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h,1,['perform'],['performance']
Performance,"/* reverse mapping of slot address into index in array */; /* slots may be placed in array pointing into different areas of the memory ; 	 * block, since we will need to implement some sort of garbadge collection and ; 	 * defragmentation mechanism - we need to be able to process them in orderly 	; 	 * fashion. ; 	 * So finally : ; 	 * 1) slot's index does not specify where in the memory slot ; 	 * is located, it is only used to address slot from outside.; 	 * 2) Using slots memory address and its size we can go through the chain of slots; 	 * and perform all the maintenance tasks as long as we have reverse mapping ; 	 * of addresses into indexes.; 	 * ; 	 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.h:554,perform,perform,554,graf2d/asimage/src/libAfterImage/asstorage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.h,1,['perform'],['perform']
Performance,/* single-usage dictionary */; /* Multi-threading */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h:34,Multi-thread,Multi-threading,34,builtins/zstd/compress/zstd_compress_internal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h,1,['Multi-thread'],['Multi-threading']
Performance,/* skip through the chain to the first position that won't be; * in the hash cache bucket */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_lazy.c:77,cache,cache,77,builtins/zstd/compress/zstd_lazy.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_lazy.c,1,['cache'],['cache']
Performance,/* some loop unrolling for optimization purposes - ; 	 we don't want to store diff[x] untill the second pass */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c:27,optimiz,optimization,27,graf2d/asimage/src/libAfterImage/scanline.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c,1,['optimiz'],['optimization']
Performance,/* speed optimization */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c:9,optimiz,optimization,9,builtins/zstd/compress/zstd_opt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c,1,['optimiz'],['optimization']
Performance,"/* start of frame, nothing already loaded nor skipped */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c:35,load,loaded,35,builtins/zstd/compress/zstd_opt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c,1,['load'],['loaded']
Performance,"/* stdout, and surprisingly even stderr, are not always flushed on process; * and thread exit, particularly when the system is under heavy load. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c:139,load,load,139,interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c,2,['load'],['load']
Performance,"/* surprisingly, having x loops inside y loop yields 30% to 80% better performance */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/transform.c:71,perform,performance,71,graf2d/asimage/src/libAfterImage/transform.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/transform.c,1,['perform'],['performance']
Performance,/* that thing below is supposedly highly optimized : */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.c:41,optimiz,optimized,41,graf2d/asimage/src/libAfterImage/asimage.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.c,1,['optimiz'],['optimized']
Performance,/* the cardinality field optimization should ignore the mask */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_bulk.cxx:25,optimiz,optimization,25,tree/ntuple/v7/test/ntuple_bulk.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_bulk.cxx,1,['optimiz'],['optimization']
Performance,"/* there needs to be support for Unicode here,; * unless we pretend that we can redefine the MD-5; * algorithm for multi-byte characters (perhaps; * by adding every four 16-bit characters and; * shortening the sum to 32 bits). Otherwise; * I suggest performing MD-5 as if every character; * was two bytes--e.g., 0040 0025 = @%--but then; * how will an ordinary MD-5 sum be matched?; * There is no way to standardize text to something; * like UTF-8 before transformation; speed cost is; * utterly prohibitive. The JavaScript standard; * itself needs to look at this: it should start; * providing access to strings as preformed UTF-8; * 8-bit unsigned value arrays.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:250,perform,performing,250,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performing']
Performance,/* this ain't worth a crap it seems. The code below seems to perform 20% slower then ; plain and simple one component at a time ; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/transform.c:61,perform,perform,61,graf2d/asimage/src/libAfterImage/transform.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/transform.c,1,['perform'],['perform']
Performance,"/* this function loads the collector dll (BistroJavaCollector) ; * and the relevant functions.; * on success: all functions load, iJIT_DLL_is_missing = 0, return value = 1; * on failure: all functions are NULL, iJIT_DLL_is_missing = 1, return value = 0; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:17,load,loads,17,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,2,['load'],"['load', 'loads']"
Performance,/* to allow deletion from priority queue */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/mesh.h:35,queue,queue,35,graf3d/eve7/glu/mesh.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/mesh.h,1,['queue'],['queue']
Performance,/* todo: optimize this */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkrgb.c:9,optimiz,optimize,9,graf2d/win32gdk/gdk/src/gdk/gdkrgb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkrgb.c,1,['optimiz'],['optimize']
Performance,"/* traversal function, assumes that `node' is root; * (only traverses `node' and its subtree).; * this function is just a high level interface to; * low level traversal functions, optimized for speed.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gnode.h:180,optimiz,optimized,180,graf2d/win32gdk/gdk/src/glib/gnode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gnode.h,1,['optimiz'],['optimized']
Performance,/* tuneParameters */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:3,tune,tuneParameters,3,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,1,['tune'],['tuneParameters']
Performance,/* turns out there is no performance gains from using int here instead of short - ; so save some memory if we can : */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.h:25,perform,performance,25,graf2d/asimage/src/libAfterImage/asstorage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.h,1,['perform'],['performance']
Performance,"/* typedef'd to LZ4F_CDict within lz4frame_static.h */; /*! LZ4F_createCDict() :; * When compressing multiple messages / blocks with the same dictionary, it's recommended to load it just once.; * LZ4F_createCDict() will create a digested dictionary, ready to start future compression operations without startup delay.; * LZ4F_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only.; * `dictBuffer` can be released after LZ4F_CDict creation, since its content is copied within CDict; * @return : digested dictionary for compression, or NULL if failed */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c:174,load,load,174,builtins/lz4/lz4frame.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c,2,"['concurren', 'load']","['concurrently', 'load']"
Performance,/* unfortunately this method does not seem to yield any better results performancewise: */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ximage.c:71,perform,performancewise,71,graf2d/asimage/src/libAfterImage/ximage.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ximage.c,1,['perform'],['performancewise']
Performance,/* until buffer loaded */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatasrc.c:16,load,loaded,16,graf2d/asimage/src/libAfterImage/libjpeg/jdatasrc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatasrc.c,1,['load'],['loaded']
Performance,/* unwinder cache (private fields for the unwinder's use) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:12,cache,cache,12,interpreter/llvm-project/clang/lib/Headers/unwind.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h,1,['cache'],['cache']
Performance,/* use the cache */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gcompletion.c:11,cache,cache,11,graf2d/win32gdk/gdk/src/glib/gcompletion.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gcompletion.c,1,['cache'],['cache']
Performance,/* use the distance_matrix to optimize this calculation; it had; better be allocated!! */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx:30,optimiz,optimize,30,math/mathmore/test/simanTSP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx,1,['optimiz'],['optimize']
Performance,/* used[i] is only -1 if the pixel at that location hasn't; * been allocated yet. This is a sanity check required for proper; * color allocation by the progressive image loader.; * When colors[i] == 0 it indicates the slot is available for; * allocation.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:170,load,loader,170,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,1,['load'],['loader']
Performance,"/* vec_perm */; // The vperm instruction is defined architecturally with a big-endian bias.; // For little endian, we swap the input operands and invert the permute; // control vector. Only the rightmost 5 bits matter, so we could use; // a vector of all 31s instead of all 255s to perform the inversion.; // However, when the PCV is not a constant, using 255 has an advantage; // in that the vec_xor can be recognized as a vec_nor (and for P8 and; // later, possibly a vec_nand).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h:282,perform,perform,282,interpreter/llvm-project/clang/lib/Headers/altivec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h,1,['perform'],['perform']
Performance,"/* vec_sum2s */; /* The vsum2sws instruction has a big-endian bias, so that the second; input vector and the result always reference big-endian elements; 1 and 3 (little-endian element 0 and 2). For ease of porting the; programmer wants elements 1 and 3 in both cases, so for little; endian we must perform some permutes. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h:299,perform,perform,299,interpreter/llvm-project/clang/lib/Headers/altivec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h,1,['perform'],['perform']
Performance,"/* vec_sums */; /* The vsumsws instruction has a big-endian bias, so that the second; input vector and the result always reference big-endian element 3; (little-endian element 0). For ease of porting the programmer; wants element 3 in both cases, so for little endian we must perform; some permutes. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h:276,perform,perform,276,interpreter/llvm-project/clang/lib/Headers/altivec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h,1,['perform'],['perform']
Performance,"/* violates C standard, by lying on structure alignment.; Only use if no other choice to achieve best performance on target platform */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/mem.h:102,perform,performance,102,builtins/zstd/common/mem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/mem.h,1,['perform'],['performance']
Performance,/* we absolutely do not want to load floating selection or invisible layers :*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/xcf.c:32,load,load,32,graf2d/asimage/src/libAfterImage/xcf.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/xcf.c,1,['load'],['load']
Performance,/* we skip all checks as it is static function and we want to optimize it; * as much as possible */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/transform.c:62,optimiz,optimize,62,graf2d/asimage/src/libAfterImage/transform.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/transform.c,3,['optimiz'],['optimize']
Performance,/* what channels to load */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h:20,load,load,20,graf2d/asimage/src/libAfterImage/import.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h,1,['load'],['load']
Performance,/* which transformations to perform */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h:28,perform,perform,28,graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,1,['perform'],['perform']
Performance,"/* zlib can't necessarily handle more than 65535 bytes at once (i.e. it; * can't even necessarily handle 65536 bytes) because the type uInt is; * ""16 bits or more"". Consequently it is necessary to chunk the input to; * zlib. This code uses ZLIB_IO_MAX, from pngpriv.h, as the maximum (the; * maximum value that can be stored in a uInt.) It is possible to set; * ZLIB_IO_MAX to a lower value in pngpriv.h and this may sometimes have; * a performance advantage, because it reduces the amount of data accessed; * at each step and that may give the OS more time to page it in.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:437,perform,performance,437,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['perform'],['performance']
Performance,"/* zlib.h declares a magic type 'uInt' that limits the amount of data that zlib; * can handle at once. This type need be no larger than 16 bits (so maximum of; * 65535), this define allows us to discover how big it is, but limited by the; * maximum for size_t. The value can be overridden in a library build; * (pngusr.h, or set it in CPPFLAGS) and it works to set it to a considerably; * lower value (e.g. 255 works). A lower value may help memory usage (slightly); * and may even improve performance on some systems (and degrade it on others.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h:490,perform,performance,490,graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,1,['perform'],['performance']
Performance,"/* zstd versions <= 1.3.4 mistakenly report corruption when; * FSE_readNCount() receives a buffer < 4 bytes.; * Fixed by https://github.com/facebook/zstd/pull/1146.; * This can happen when the last set_compressed table present is 2; * bytes and the bitstream is only one byte.; * In this exceedingly rare case, we will simply emit an uncompressed; * block, since it isn't worth optimizing.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:378,optimiz,optimizing,378,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,2,['optimiz'],['optimizing']
Performance,"/*! *****************************************************************************; Copyright (c) Microsoft Corporation. Permission to use, copy, modify, and/or distribute this software for any; purpose with or without fee is hereby granted. THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH; REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY; AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,; INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM; LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR; OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR; PERFORMANCE OF THIS SOFTWARE.; ***************************************************************************** */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/base/zstd.mjs:703,PERFORM,PERFORMANCE,703,js/modules/base/zstd.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/base/zstd.mjs,1,['PERFORM'],['PERFORMANCE']
Performance,"/*! Generate a conv net, perform forward pass */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestConvNet.h:25,perform,perform,25,tmva/tmva/test/DNN/CNN/TestConvNet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestConvNet.h,1,['perform'],['perform']
Performance,"/*! Generate a conv net, perform p */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestConvNet.h:25,perform,perform,25,tmva/tmva/test/DNN/CNN/TestConvNet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestConvNet.h,1,['perform'],['perform']
Performance,"/*! Generate a random net, perform forward and backward propagation and check; * the bias gradients using numerical differentiation. Returns the maximum; * relative gradient error and also prints it to stdout. */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagation.h:27,perform,perform,27,tmva/tmva/test/DNN/TestBackpropagation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagation.h,2,['perform'],['perform']
Performance,"/*! Generate a random net, perform forward and backward propagation and check; * the weight gradients using numerical differentiation. Returns the maximum; * relative gradient error and also prints it to stdout. */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagation.h:27,perform,perform,27,tmva/tmva/test/DNN/TestBackpropagation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagation.h,4,['perform'],['perform']
Performance,"/*! Generate a random, linear net, perform forward and backward propagation with; * L1 regularization and check the weight gradients using numerical; * differentiation. Returns the maximum relative gradient error and; * also prints it to stdout. */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagation.h:35,perform,perform,35,tmva/tmva/test/DNN/TestBackpropagation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagation.h,2,['perform'],['perform']
Performance,"/*! Generate a random, linear net, perform forward and backward propagation with; * L2 regularization and check the weight gradients using numerical; * differentiation. Returns the maximum relative gradient error and; * also prints it to stdout. */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagation.h:35,perform,perform,35,tmva/tmva/test/DNN/TestBackpropagation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagation.h,2,['perform'],['perform']
Performance,"/*! LZ4F_decompress() :; * Call this function repetitively to regenerate compressed data in srcBuffer.; * The function will attempt to decode up to *srcSizePtr bytes from srcBuffer; * into dstBuffer of capacity *dstSizePtr.; *; * The number of bytes regenerated into dstBuffer will be provided within *dstSizePtr (necessarily <= original value).; *; * The number of bytes effectively read from srcBuffer will be provided within *srcSizePtr (necessarily <= original value).; * If number of bytes read is < number of bytes provided, then decompression operation is not complete.; * Remaining data will have to be presented again in a subsequent invocation.; *; * The function result is an hint of the better srcSize to use for next call to LZ4F_decompress.; * Schematically, it's the size of the current (or remaining) compressed block + header of next block.; * Respecting the hint provides a small boost to performance, since it allows less buffer shuffling.; * Note that this is just a hint, and it's always possible to any srcSize value.; * When a frame is fully decoded, @return will be 0.; * If decompression failed, @return is an error code which can be tested using LZ4F_isError().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c:907,perform,performance,907,builtins/lz4/lz4frame.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c,1,['perform'],['performance']
Performance,"/*! LZ4_attach_dictionary() :; * This is an experimental API that allows; * efficient use of a static dictionary many times.; *; * Rather than re-loading the dictionary buffer into a working context before; * each compression, or copying a pre-loaded dictionary's LZ4_stream_t into a; * working LZ4_stream_t, this function introduces a no-copy setup mechanism,; * in which the working stream references the dictionary stream in-place.; *; * Several assumptions are made about the state of the dictionary stream.; * Currently, only streams which have been prepared by LZ4_loadDict() should; * be expected to work.; *; * Alternatively, the provided dictionaryStream may be NULL,; * in which case any existing dictionary stream is unset.; *; * If a dictionary is provided, it replaces any pre-existing stream history.; * The dictionary contents are the only history that can be referenced and; * logically immediately precede the data compressed in the first subsequent; * compression call.; *; * The dictionary will only remain attached to the working stream through the; * first compression call, at the end of which it is cleared. The dictionary; * stream (and source buffer) must remain in-place / accessible / unchanged; * through the completion of the first compression call on the stream.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:146,load,loading,146,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,2,['load'],"['loaded', 'loading']"
Performance,"/*! LZ4_compress_fast() :; Same as LZ4_compress_default(), but allows selection of ""acceleration"" factor.; The larger the acceleration value, the faster the algorithm, but also the lesser the compression.; It's a trade-off. It can be fine tuned, with each successive value providing roughly +~3% to speed.; An acceleration value of ""1"" is the same as regular LZ4_compress_default(); Values <= 0 will be replaced by LZ4_ACCELERATION_DEFAULT (currently == 1, see lz4.c).; Values > LZ4_ACCELERATION_MAX will be replaced by LZ4_ACCELERATION_MAX (currently == 65537, see lz4.c).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:239,tune,tuned,239,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['tune'],['tuned']
Performance,"/*! LZ4_decompress_*_usingDict() :; * These decoding functions work the same as; * a combination of LZ4_setStreamDecode() followed by LZ4_decompress_*_continue(); * They are stand-alone, and don't need an LZ4_streamDecode_t structure.; * Dictionary is presumed stable : it must remain accessible and unmodified during decompression.; * Performance tip : Decompression speed can be substantially increased; * when dst == dictStart + dictSize.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:336,Perform,Performance,336,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['Perform'],['Performance']
Performance,"/*! LZ4_decompress_safe_partial() :; * Decompress an LZ4 compressed block, of size 'srcSize' at position 'src',; * into destination buffer 'dst' of size 'dstCapacity'.; * Up to 'targetOutputSize' bytes will be decoded.; * The function stops decoding on reaching this objective.; * This can be useful to boost performance; * whenever only the beginning of a block is required.; *; * @return : the number of bytes decoded in `dst` (necessarily <= targetOutputSize); * If source stream is detected malformed, function returns a negative result.; *; * Note 1 : @return can be < targetOutputSize, if compressed block contains less data.; *; * Note 2 : targetOutputSize must be <= dstCapacity; *; * Note 3 : this function effectively stops decoding on reaching targetOutputSize,; * so dstCapacity is kind of redundant.; * This is because in older versions of this function,; * decoding operation would still write complete sequences.; * Therefore, there was no guarantee that it would stop writing at exactly targetOutputSize,; * it could write more bytes, though only up to dstCapacity.; * Some ""margin"" used to be required for this operation to work properly.; * Thankfully, this is no longer necessary.; * The function nonetheless keeps the same signature, in an effort to preserve API compatibility.; *; * Note 4 : If srcSize is the exact size of the block,; * then targetOutputSize can be any value,; * including larger than the block's decompressed size.; * The function will, at most, generate block's decompressed size.; *; * Note 5 : If srcSize is _larger_ than block's compressed size,; * then targetOutputSize **MUST** be <= block's decompressed size.; * Otherwise, *silent corruption will occur*.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:309,perform,performance,309,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['perform'],['performance']
Performance,"/*! LZ4_loadDict() :; * Use this function to reference a static dictionary into LZ4_stream_t.; * The dictionary must remain available during compression.; * LZ4_loadDict() triggers a reset, so any previous data will be forgotten.; * The same dictionary will have to be loaded on decompression side for successful decoding.; * Dictionary are useful for better compression of small data (KB range).; * While LZ4 accept any input as dictionary,; * results are generally better when using Zstandard's Dictionary Builder.; * Loading a size of 0 is allowed, and is the same as reset.; * @return : loaded dictionary size, in bytes (necessarily <= 64 KB); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:269,load,loaded,269,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,3,"['Load', 'load']","['Loading', 'loaded']"
Performance,"/*! LZ4_resetStream_fast() : v1.9.0+; * Use this to prepare an LZ4_stream_t for a new chain of dependent blocks; * (e.g., LZ4_compress_fast_continue()).; *; * An LZ4_stream_t must be initialized once before usage.; * This is automatically done when created by LZ4_createStream().; * However, should the LZ4_stream_t be simply declared on stack (for example),; * it's necessary to initialize it first, using LZ4_initStream().; *; * After init, start any new stream with LZ4_resetStream_fast().; * A same LZ4_stream_t can be re-used multiple times consecutively; * and compress multiple streams,; * provided that it starts each new stream with LZ4_resetStream_fast().; *; * LZ4_resetStream_fast() is much faster than LZ4_initStream(),; * but is not compatible with memory regions containing garbage data.; *; * Note: it's only useful to call LZ4_resetStream_fast(); * in the context of streaming compression.; * The *extState* functions perform their own resets.; * Invoking LZ4_resetStream_fast() before is redundant, and even counterproductive.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:935,perform,perform,935,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['perform'],['perform']
Performance,"/*! LZ4_setStreamDecode() :; * Use this function to instruct where to find the dictionary.; * This function is not necessary if previous data is still available where it was decoded.; * Loading a size of 0 is allowed (same effect as no dictionary).; * @return : 1 if OK, 0 if error; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:186,Load,Loading,186,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['Load'],['Loading']
Performance,"/*! POOL_add() :; * Add the job `function(opaque)` to the thread pool. `ctx` must be valid.; * Possibly blocks until there is room in the queue.; * Note : The function may be executed asynchronously,; * therefore, `opaque` must live until function has been completed.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.h:138,queue,queue,138,builtins/zstd/common/pool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.h,1,['queue'],['queue']
Performance,"/*! POOL_create() :; * Create a thread pool with at most `numThreads` threads.; * `numThreads` must be at least 1.; * The maximum number of queued jobs before blocking is `queueSize`.; * @return : POOL_ctx pointer on success, else NULL.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.h:140,queue,queued,140,builtins/zstd/common/pool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.h,2,['queue'],"['queueSize', 'queued']"
Performance,"/*! POOL_join() :; Shutdown the queue, wake any sleeping threads, and join all of the threads.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:32,queue,queue,32,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,1,['queue'],['queue']
Performance,"/*! POOL_resize() :; * Expands or shrinks pool's number of threads.; * This is more efficient than releasing + creating a new context,; * since it tries to preserve and re-use existing threads.; * `numThreads` must be at least 1.; * @return : 0 when resize was successful,; * !0 (typically 1) if there is an error.; * note : only numThreads can be resized, queueSize remains unchanged.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.h:357,queue,queueSize,357,builtins/zstd/common/pool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.h,1,['queue'],['queueSize']
Performance,/*! Performs one step of optimization. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Optimizer.h:4,Perform,Performs,4,tmva/tmva/inc/TMVA/DNN/Optimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Optimizer.h,2,"['Perform', 'optimiz']","['Performs', 'optimization']"
Performance,"/*! ZSTD_CCtx_loadDictionary_advanced() :; * Same as ZSTD_CCtx_loadDictionary(), but gives finer control over; * how to load the dictionary (by copy ? by reference ?); * and how to interpret it (automatic ? force raw mode ? full mode only ?) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:120,load,load,120,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['load'],['load']
Performance,"/*! ZSTD_CCtx_refPrefix() :; * Reference a prefix (single-usage dictionary) for next compressed frame.; * A prefix is **only used once**. Tables are discarded at end of frame (ZSTD_e_end).; * Decompression will need same prefix to properly regenerate data.; * Compressing with a prefix is similar in outcome as performing a diff and compressing it,; * but performs much faster, especially during decompression (compression speed is tunable with compression level).; * @result : 0, or an error code (which can be tested with ZSTD_isError()).; * Special: Adding any prefix (including NULL) invalidates any previous prefix or dictionary; * Note 1 : Prefix buffer is referenced. It **must** outlive compression.; * Its content must remain unmodified during compression.; * Note 2 : If the intention is to diff some large src data blob with some prior version of itself,; * ensure that the window size is large enough to contain the entire source.; * See ZSTD_c_windowLog.; * Note 3 : Referencing a prefix involves building tables, which are dependent on compression parameters.; * It's a CPU consuming operation, with non-negligible impact on latency.; * If there is a need to use the same prefix multiple times, consider loadDictionary instead.; * Note 4 : By default, the prefix is interpreted as raw content (ZSTD_dct_rawContent).; * Use experimental ZSTD_CCtx_refPrefix_advanced() to alter dictionary interpretation. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:311,perform,performing,311,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,4,"['latency', 'load', 'perform']","['latency', 'loadDictionary', 'performing', 'performs']"
Performance,"/*! ZSTD_CCtx_setParameter() :; * Set one compression parameter, selected by enum ZSTD_cParameter.; * All parameters have valid bounds. Bounds can be queried using ZSTD_cParam_getBounds().; * Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter).; * Setting a parameter is generally only possible during frame initialization (before starting compression).; * Exception : when using multi-threading mode (nbWorkers >= 1),; * the following parameters can be updated _during_ compression (within same frame):; * => compressionLevel, hashLog, chainLog, searchLog, minMatch, targetLength and strategy.; * new parameters will be active for next job only (after a flush()).; * @return : an error code (which can be tested using ZSTD_isError()).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:426,multi-thread,multi-threading,426,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['multi-thread'],['multi-threading']
Performance,"/*! ZSTD_DCtx_loadDictionary() :; * Create an internal DDict from dict buffer,; * to be used to decompress next frames.; * The dictionary remains valid for all future frames, until explicitly invalidated.; * @result : 0, or an error code (which can be tested with ZSTD_isError()).; * Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary,; * meaning ""return to no-dictionary mode"".; * Note 1 : Loading a dictionary involves building tables,; * which has a non-negligible impact on CPU usage and latency.; * It's recommended to ""load once, use many times"", to amortize the cost; * Note 2 :`dict` content will be copied internally, so `dict` can be released after loading.; * Use ZSTD_DCtx_loadDictionary_byReference() to reference dictionary content instead.; * Note 3 : Use ZSTD_DCtx_loadDictionary_advanced() to take control of; * how dictionary content is loaded and interpreted.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:423,Load,Loading,423,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,5,"['Load', 'latency', 'load']","['Loading', 'latency', 'load', 'loaded', 'loading']"
Performance,"/*! ZSTD_DCtx_loadDictionary_advanced() :; * Same as ZSTD_DCtx_loadDictionary(),; * but gives direct control over; * how to load the dictionary (by copy ? by reference ?); * and how to interpret it (automatic ? force raw mode ? full mode only ?). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:124,load,load,124,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['load'],['load']
Performance,"/*! ZSTD_adjustCParams() :; * optimize params for a given `srcSize` and `dictSize`.; * `srcSize` can be unknown, in which case use ZSTD_CONTENTSIZE_UNKNOWN.; * `dictSize` must be `0` when there is no dictionary.; * cPar can be invalid : all parameters will be clamped within valid range in the @return struct.; * This function never fails (wide contract) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:30,optimiz,optimize,30,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['optimiz'],['optimize']
Performance,"/*! ZSTD_compressStream2() :; * Behaves about the same as ZSTD_compressStream, with additional control on end directive.; * - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*(); * - Compression parameters cannot be changed once compression is started (save a list of exceptions in multi-threading mode); * - output->pos must be <= dstCapacity, input->pos must be <= srcSize; * - output->pos and input->pos will be updated. They are guaranteed to remain below their respective limit.; * - endOp must be a valid directive; * - When nbWorkers==0 (default), function is blocking : it completes its job before returning to caller.; * - When nbWorkers>=1, function is non-blocking : it copies a portion of input, distributes jobs to internal worker threads, flush to output whatever is available,; * and then immediately returns, just indicating that there is some data remaining to be flushed.; * The function nonetheless guarantees forward progress : it will return only after it reads or write at least 1+ byte.; * - Exception : if the first call requests a ZSTD_e_end directive and provides enough dstCapacity, the function delegates to ZSTD_compress2() which is always blocking.; * - @return provides a minimum amount of data remaining to be flushed from internal buffers; * or an error code, which can be tested using ZSTD_isError().; * if @return != 0, flush is not fully completed, there is still some data left within internal buffers.; * This is useful for ZSTD_e_flush, since in this case more flushes are necessary to empty all buffers.; * For ZSTD_e_end, @return == 0 when internal buffers are fully flushed and frame is completed.; * - after a ZSTD_e_end directive, if internal buffer is not fully flushed (@return != 0),; * only ZSTD_e_end or ZSTD_e_flush operations are allowed.; * Before starting a new compression job, or changing compression parameters,; * it is required to fully flush internal buffers.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:326,multi-thread,multi-threading,326,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['multi-thread'],['multi-threading']
Performance,"/*! ZSTD_createCDict() :; * When compressing multiple messages or blocks using the same dictionary,; * it's recommended to digest the dictionary only once, since it's a costly operation.; * ZSTD_createCDict() will create a state from digesting a dictionary.; * The resulting state can be used for future compression operations with very limited startup cost.; * ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only.; * @dictBuffer can be released after ZSTD_CDict creation, because its content is copied within CDict.; * Note 1 : Consider experimental function `ZSTD_createCDict_byReference()` if you prefer to not duplicate @dictBuffer content.; * Note 2 : A ZSTD_CDict can be created from an empty @dictBuffer,; * in which case the only thing that it transports is the @compressionLevel.; * This can be useful in a pipeline featuring ZSTD_compress_usingCDict() exclusively,; * expecting a ZSTD_CDict parameter with any data, including those without a known dictionary. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:424,concurren,concurrently,424,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['concurren'],['concurrently']
Performance,"/*! ZSTD_decompress_usingDict() :; * Decompression using a known Dictionary.; * Dictionary must be identical to the one used during compression.; * Note : This function loads the dictionary, resulting in significant startup delay.; * It's intended for a dictionary used only once.; * Note : When `dict == NULL || dictSize < 8` no dictionary is used. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:169,load,loads,169,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['load'],['loads']
Performance,"/*! ZSTD_getDictID_fromCDict() :; * Provides the dictID of the dictionary loaded into `cdict`.; * If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.; * Non-conformant dictionaries can still be loaded, but as content-only dictionaries. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:74,load,loaded,74,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,4,['load'],['loaded']
Performance,"/*! ZSTD_getDictID_fromDDict() :; * Provides the dictID of the dictionary loaded into `ddict`.; * If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.; * Non-conformant dictionaries can still be loaded, but as content-only dictionaries. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:74,load,loaded,74,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,4,['load'],['loaded']
Performance,"/*! ZSTD_getDictID_fromDict() :; * Provides the dictID stored within dictionary.; * if @return == 0, the dictionary is not conformant with Zstandard specification.; * It can still be loaded, but as a content-only dictionary. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c:183,load,loaded,183,builtins/zstd/decompress/zstd_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c,1,['load'],['loaded']
Performance,"/*! ZSTD_initCStream_advanced() :; * This function is deprecated, and is approximately equivalent to:; * ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);; * // Pseudocode: Set each zstd parameter and leave the rest as-is.; * for ((param, value) : params) {; * ZSTD_CCtx_setParameter(zcs, param, value);; * }; * ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);; * ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);; *; * dict is loaded with ZSTD_dct_auto and ZSTD_dlm_byCopy.; * pledgedSrcSize must be correct.; * If srcSize is not known at init time, use value ZSTD_CONTENTSIZE_UNKNOWN.; * Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:423,load,loaded,423,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['load'],['loaded']
Performance,"/*! ZSTD_initCStream_usingDict() :; * This function is deprecated, and is equivalent to:; * ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);; * ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);; * ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);; *; * Creates of an internal CDict (incompatible with static CCtx), except if; * dict == NULL or dictSize < 8, in which case no dict is used.; * Note: dict is loaded with ZSTD_dct_auto (treated as a full zstd dictionary if; * it begins with ZSTD_MAGIC_DICTIONARY, else as raw content) and ZSTD_dlm_byCopy.; * Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:423,load,loaded,423,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['load'],['loaded']
Performance,"/*! ZSTD_resetCStream() :; * This function is deprecated, and is equivalent to:; * ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);; * ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);; *; * start a new frame, using same parameters from previous frame.; * This is typically useful to skip dictionary loading stage, since it will re-use it in-place.; * Note that zcs must be init at least once before using ZSTD_resetCStream().; * If pledgedSrcSize is not known at reset time, use macro ZSTD_CONTENTSIZE_UNKNOWN.; * If pledgedSrcSize > 0, its value must be correct, as it will be written in header, and controlled at the end.; * For the time being, pledgedSrcSize==0 is interpreted as ""srcSize unknown"" for compatibility with older programs,; * but it will change to mean ""empty"" in future version, so use macro ZSTD_CONTENTSIZE_UNKNOWN instead.; * @return : 0, or an error code (which can be tested using ZSTD_isError()); * Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:298,load,loading,298,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['load'],['loading']
Performance,"/*! ZSTD_toFlushNow() :; * Tell how many bytes are ready to be flushed immediately.; * Useful for multithreading scenarios (nbWorkers >= 1).; * Probe the oldest active job, defined as oldest job not yet entirely flushed,; * and check its output buffer.; * @return : amount of data stored in oldest job and ready to be flushed immediately.; * if @return == 0, it means either :; * + there is no active job (could be checked with ZSTD_frameProgression()), or; * + oldest job is still actively compressing data,; * but everything it has produced has also been flushed so far,; * therefore flush speed is limited by production speed of oldest job; * irrespective of the speed of concurrent (and newer) jobs.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:675,concurren,concurrent,675,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['concurren'],['concurrent']
Performance,"/*! \class TMVA::ClassificationResult; * Class to save the results of the classifier.; * Every machine learning method booked have an object for the results; * in the classification process, in this class is stored the mvas,; * data loader name and ml method name and title.; * You can to display the results calling the method Show, get the ROC-integral with the; * method GetROCIntegral or get the TMVA::ROCCurve object calling GetROC.; \ingroup TMVA; */; /*! \class TMVA::Classification; * Class to perform two class classification.; * The first step before any analysis is to prepare the data,; * to do that you need to create an object of TMVA::DataLoader,; * in this object you need to configure the variables and the number of events; * to train/test.; * The class TMVA::Experimental::Classification needs a TMVA::DataLoader object,; * optional a TFile object to save the results and some extra options in a string; * like ""V:Color:Transformations=I;D;P;U;G:Silent:DrawProgressBar:ModelPersistence:Jobs=2"" where:; * V = verbose output; * Color = coloured screen output; * Silent = batch mode: boolean silent flag inhibiting any output from TMVA; * Transformations = list of transformations to test.; * DrawProgressBar = draw progress bar to display training and testing.; * ModelPersistence = to save the trained model in xml or serialized files.; * Jobs = number of ml methods to test/train in parallel using MultiProc, requires to call Evaluate method.; * Basic example.; * \code; void classification(UInt_t jobs = 2); {; TMVA::Tools::Instance();. TFile *input(0);; TString fname = ""./tmva_class_example.root"";; if (!gSystem->AccessPathName(fname)) {; input = TFile::Open(fname); // check if file in local directory exists; } else {; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD"");; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }. // Register the training and test trees. TTree *si",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Classification.h:233,load,loader,233,tmva/tmva/inc/TMVA/Classification.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Classification.h,2,"['load', 'perform']","['loader', 'perform']"
Performance,"/*! \class TMVA::CrossValidationResult; * Class to save the results of cross validation,; * the metric for the classification ins ROC and you can ROC curves; * ROC integrals, ROC average and ROC standard deviation.; \ingroup TMVA; */; /*! \class TMVA::CrossValidation; * Class to perform cross validation, splitting the dataloader into folds.; \ingroup TMVA; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/CrossValidation.h:280,perform,perform,280,tmva/tmva/inc/TMVA/CrossValidation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/CrossValidation.h,1,['perform'],['perform']
Performance,"/*! \class TMVA::RegressionVariance; \ingroup TMVA; Calculate the ""SeparationGain"" for Regression analysis; separation criteria used in various training algorithms. There are two things: the Separation Index, and the Separation Gain; Separation Index:; Measure of the ""Variance"" of a sample. Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality criteria which is optimized for when trying; to increase the information in the system (making the best selection; */; ////////////////////////////////////////////////////////////////////////////////; /// Separation Gain:; /// the measure of how the quality of separation of the sample increases; /// by splitting the sample e.g. into a ""left-node"" and a ""right-node""; /// (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); /// this is then the quality criteria which is optimized for when trying; /// to increase the information in the system; /// for the Regression: as the ""Gain is maximised"", the RMS (sqrt(variance)); /// which is used as a ""separation"" index should be as small as possible.; /// the ""figure of merit"" here has to be -(rms left+rms-right) or 1/rms...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RegressionVariance.cxx:561,optimiz,optimized,561,tmva/tmva/src/RegressionVariance.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RegressionVariance.cxx,2,['optimiz'],['optimized']
Performance,"/*!; * This function is deprecated, and is equivalent to:; *; * ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);; *; * re-use decompression parameters from previous init; saves dictionary loading; * Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:186,load,loading,186,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['load'],['loading']
Performance,"/*!; * XXH_FORCE_ALIGN_CHECK:; * This is an important performance trick; * for architectures without decent unaligned memory access performance.; * It checks for input alignment, and when conditions are met,; * uses a ""fast path"" employing direct 32-bit/64-bit read,; * resulting in _dramatically faster_ read speed.; *; * The check costs one initial branch per hash, which is generally negligible, but not zero.; * Moreover, it's not useful to generate binary for an additional code path; * if memory access uses same instruction for both aligned and unaligned adresses.; *; * In these cases, the alignment check can be removed by setting this macro to 0.; * Then the code will always use unaligned memory access.; * Align check is automatically disabled on x86, x64 & arm64,; * which are platforms known to offer good unaligned memory accesses performance.; *; * This option does not affect XXH3 (only XXH32 and XXH64).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:54,perform,performance,54,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,3,['perform'],['performance']
Performance,"/*!; * XXH_NO_INLINE_HINTS:; *; * By default, xxHash tries to force the compiler to inline almost all internal; * functions.; *; * This can usually improve performance due to reduced jumping and improved; * constant folding, but significantly increases the size of the binary which; * might not be favorable.; *; * Additionally, sometimes the forced inlining can be detrimental to performance,; * depending on the architecture.; *; * XXH_NO_INLINE_HINTS marks all internal functions as static, giving the; * compiler full control on whether to inline or not.; *; * When not optimizing (-O0), optimizing for size (-Os, -Oz), or using; * -fno-inline with GCC or Clang, this will automatically be defined.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:156,perform,performance,156,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,4,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,"/*!; * XXH_REROLL_XXH64:; * Whether to reroll the XXH64_finalize() loop.; *; * Just like XXH32, we can unroll the XXH64_finalize() loop. This can be a; * performance gain on 64-bit hosts, as only one jump is required.; *; * However, on 32-bit hosts, because arithmetic needs to be done with two 32-bit; * registers, and 64-bit arithmetic needs to be simulated, it isn't beneficial; * to unroll. The code becomes ridiculously large (the largest function in the; * binary on i386!), and rerolling it saves anywhere from 3kB to 20kB. It is; * also slightly faster because it fits into cache better and is more likely; * to be inlined by the compiler.; *; * If XXH_REROLL is defined, this is ignored and the loop is always rerolled.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:154,perform,performance,154,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,"['cache', 'perform']","['cache', 'performance']"
Performance,"/*!; Tutorial :; ----------; (Note : these functions only decompress FSE-compressed blocks.; If block is uncompressed, use memcpy() instead; If block is a single repeated byte, use memset() instead ). The first step is to obtain the normalized frequencies of symbols.; This can be performed by FSE_readNCount() if it was saved using FSE_writeNCount().; 'normalizedCounter' must be already allocated, and have at least 'maxSymbolValuePtr[0]+1' cells of signed short.; In practice, that means it's necessary to know 'maxSymbolValue' beforehand,; or size the table to handle worst case situations (typically 256).; FSE_readNCount() will provide 'tableLog' and 'maxSymbolValue'.; The result of FSE_readNCount() is the number of bytes read from 'rBuffer'.; Note that 'rBufferSize' must be at least 4 bytes, even if useful information is less than that.; If there is an error, the function will return an error code, which can be tested using FSE_isError(). The next step is to build the decompression tables 'FSE_DTable' from 'normalizedCounter'.; This is performed by the function FSE_buildDTable().; The space required by 'FSE_DTable' must be already allocated using FSE_createDTable().; If there is an error, the function will return an error code, which can be tested using FSE_isError(). `FSE_DTable` can then be used to decompress `cSrc`, with FSE_decompress_usingDTable().; `cSrcSize` must be strictly correct, otherwise decompression will fail.; FSE_decompress_usingDTable() result will tell how many bytes were regenerated (<=`dstCapacity`).; If there is an error, the function will return an error code, which can be tested using FSE_isError(). (ex: dst buffer too small); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:281,perform,performed,281,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,2,['perform'],['performed']
Performance,"/*!< maximum compression level available */; /***************************************; * Explicit context; ***************************************/; /*= Compression context; * When compressing many times,; * it is recommended to allocate a context just once,; * and re-use it for each successive compression operation.; * This will make workload friendlier for system's memory.; * Note : re-using context is just a speed / resource optimization.; * It doesn't change the compression ratio, which remains identical.; * Note 2 : In multi-threaded environments,; * use one different context per thread for parallel execution.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:432,optimiz,optimization,432,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,2,"['multi-thread', 'optimiz']","['multi-threaded', 'optimization']"
Performance,"/*!< recommended size for output buffer. Guarantee to successfully flush at least one complete block in all circumstances. */; /**************************; * Simple dictionary API; ***************************/; /*! ZSTD_compress_usingDict() :; * Compression at an explicit compression level using a Dictionary.; * A dictionary can be any arbitrary data segment (also called a prefix),; * or a buffer with specified information (see dictBuilder/zdict.h).; * Note : This function loads the dictionary, resulting in significant startup delay.; * It's intended for a dictionary used only once.; * Note 2 : When `dict == NULL || dictSize < 8` no dictionary is used. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:478,load,loads,478,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['load'],['loads']
Performance,"/** @brief BidirMMapPipe creates a bidirectional channel between the current; * process and a child it forks.; *; * @author Manuel Schiller <manuel.schiller@nikhef.nl>; * @date 2013-07-07; *; * This class creates a bidirectional channel between this process and a child; * it creates with fork().; *; * The channel is comrised of a small shared pool of buffer memory mmapped into; * both process spaces, and two pipes to synchronise the exchange of data. The; * idea behind using the pipes at all is to have some primitive which we can; * block on without having to worry about atomic operations or polling, leaving; * these tasks to the OS. In case the anonymous mmap cannot be performed on the; * OS the code is running on (for whatever reason), the code falls back to; * mmapping /dev/zero, mmapping a temporary file, or (if those all fail), a; * dynamically allocated buffer which is then transmitted through the pipe(s),; * a slightly slower alternative (because the data is copied more often).; *; * The channel supports five major operations: read(), write(), flush(),; * purge() and close(). Reading and writing may block until the required buffer; * space is available. Writes may queue up data to be sent to the other end; * until either enough pages are full, or the user calls flush which forces; * any unsent buffers to be sent to the other end. flush forces any data that; * is to be sent to be sent. purge discards any buffered data waiting to be; * read and/or sent. Closing the channel on the child returns zero, closing it; * on the parent returns the child's exit status.; *; * The class also provides operator<< and operator>> for C++-style I/O for; * basic data types (bool, char, short, int, long, long long, float, double; * and their unsigned counterparts). Data is transmitted binary (i.e. no; * formatting to strings like std::cout does). There are also overloads to; * support C-style zero terminated strings and std::string. In terms of; * performance, the former is to be ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:679,perform,performed,679,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,1,['perform'],['performed']
Performance,"/** @brief constructor (forks!); *; * Creates a bidirectional communications channel between this process; * and a child the constructor forks. On return from the constructor,; * isParent() and isChild() can be used to tell the parent end from the; * child end of the pipe. In the child, all other open BidirMMapPipes; * are closed.; *; * @param useExceptions read()/write() error reporting also done using; * exceptions; * @param useSocketpair use a socketpair instead of a pair or pipes; *; * Normally, exceptions are thrown for all serious I/O errors (apart; * from end of file). Setting useExceptions to false will force the; * read() and write() methods to only report serious I/O errors using; * flags.; *; * When useSocketpair is true, use a pair of Unix domain sockets; * created using socketpair instead a pair of pipes. The advantage is; * that only one pair of file descriptors is needed instead of two; * pairs which are needed for the pipe pair. Performance should very; * similar on most platforms, especially if mmap works, since only; * very little data is sent through the pipe(s)/socketpair.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:959,Perform,Performance,959,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,1,['Perform'],['Performance']
Performance,"/** @brief receive a pages from the other end (may block), queue them; *; * @returns number of pages received; *; * this is an application-level scatter read, which gets the list of; * pages to read from the pipe. if mmap works, it needs only one read; * call (to get the head of the list of pages transferred). if we need; * to copy pages through the pipe, we need to add one read for each; * empty page, and two reads for each non-empty page.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:59,queue,queue,59,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,1,['queue'],['queue']
Performance,"/** @brief write to pipe; *; * @param addr where to get data to write from; * @param sz size of data to write (in bytes); * @returns size of data written, or 0 in case of end-of-file; *; * write may block until data can be written to other end (depends a; * bit on available buffer space). It will return 0 if the other end; * closed the pipe. The data is queued to be written on the next; * convenient occasion, or it can be forced out with flush().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:356,queue,queued,356,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,1,['queue'],['queued']
Performance,"/** @fn RooAbsPdf::fitTo(); *; * @brief Fit PDF to given dataset.; *; * If dataset is unbinned, an unbinned maximum likelihood is performed.; * If the dataset is binned, a binned maximum likelihood is performed.; * By default the fit is executed through the MINUIT commands MIGRAD, HESSE in succession.; *; * @param data Reference to a RooAbsData object representing the dataset.; * @param cmdArgs Variadic template arguments representing optional command arguments.; * You can pass either an arbitrary number of RooCmdArg instances; * or a single RooLinkedList that points to the RooCmdArg objects.; * @return An owning pointer to the created RooAbsReal NLL object.; * @return RooFitResult with fit status and parameters if option Save() is used, `nullptr` otherwise. The user takes ownership of the fit result.; *; * @tparam CmdArgs_t Template types for optional command arguments.; * Can either be an arbitrary number of RooCmdArg or a single RooLinkedList.; *; * \note This front-end function should not be re-implemented in derived PDF types.; * If you mean to customize the likelihood fitting routine,; * you need to override the virtual RooAbsPdf::fitToImpl() method.; *; * The following named arguments are supported:; *; * <table>; * <tr><th> Type of CmdArg <th> Options to control construction of -log(L); * <tr><td> <td> All command arguments that can also be passed to the NLL creation method.; * \see RooAbsPdf::createNLL(); *; * <tr><th><th> Options to control flow of fit procedure; * <tr><td> `Minimizer(""<type>"", ""<algo>"")` <td> Choose minimization package and optionally the algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer interface,; * but others can be specified (through RooMinimizer interface).; * <table>; * <tr><th> Type <th> Algorithm; * <tr><td> Minuit <td> migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); * <tr><td> Minuit2 <td> migrad, simplex, minimize, scan; * <tr><td> GSLMultiMin <td> conjugatefr, conjugatepr, bfgs, b",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:130,perform,performed,130,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,2,['perform'],['performed']
Performance,"/** @name Backward Propagation (Dense Layers); * Low-level functions required for the forward propagation of activations; * through the network.; */; ///@{; /** Perform the complete backward propagation step. If the provided; * \p activationGradientsBackward matrix is not empty, compute the; * gradients of the objective function with respect to the activations; * of the previous layer (backward direction).; * Also compute the weight and the bias gradients. Modifies the values; * in \p df and thus produces only a valid result, if it is applied the; * first time after the corresponding forward propagation has been per-; * formed. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu.h:161,Perform,Perform,161,tmva/tmva/inc/TMVA/DNN/Architectures/Cpu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu.h,3,['Perform'],['Perform']
Performance,"/** @name Backward Propagation in Convolutional Layer; */; ///@{; /** Perform the complete backward propagation step in a Convolutional Layer.; * If the provided \p activationGradientsBackward matrix is not empty, compute the; * gradients of the objective function with respect to the activations; * of the previous layer (backward direction).; * Also compute the weight and the bias gradients. Modifies the values; * in \p df and thus produces only a valid result, if it is applied the; * first time after the corresponding forward propagation has been per-; * formed. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h:70,Perform,Perform,70,tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h,1,['Perform'],['Perform']
Performance,"/** @name interface inherited from IParamFunction */; /// get the parameter values (return values cachen inside, those inside TF1 might be different)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/Math/WrappedTF1.h:98,cache,cachen,98,hist/hist/inc/Math/WrappedTF1.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/Math/WrappedTF1.h,1,['cache'],['cachen']
Performance,"/** @namespace; * @summary Insiance of TStyle object like in ROOT; * @desc Includes default draw styles, can be changed after loading of JSRoot.core.js; * or can be load from the file providing style=itemname in the URL; * See [TStyle docu]{@link https://root.cern/doc/master/classTStyle.html} 'Private attributes' section for more detailed info about each value */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:126,load,loading,126,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['load'],"['load', 'loading']"
Performance,/** @summary Apply loaded TStyle object; * @desc One also can specify item name of JSON file name where style is loaded; * @param {object|string} style - either TStyle object of item name where object can be load */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:19,load,loaded,19,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,6,['load'],"['load', 'loaded']"
Performance,/** @summary Assign default layout and place where drawing will be performed; * @param {string} layout - layout like 'simple' or 'grid2x2'; * @param {string} frameid - DOM element id where object drawing will be performed */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:67,perform,performed,67,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['perform'],['performed']
Performance,"/** @summary Assigns pad name where element will be drawn; * @desc Should happened before first draw of element is performed, only for special use case; * @param {string} [pad_name] - on which sub-pad element should be draw, if not specified - use current; * @protected; * @deprecated to be removed in v8 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:115,perform,performed,115,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performed']
Performance,/** @summary Async function to load font; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:31,load,load,31,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['load'],['load']
Performance,"/** @summary Calculates pad position for RPadPos values; * @param {object} pos - instance of RPadPos; * @param {object} frame_painter - if drawing will be performed inside frame, frame painter */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:155,perform,performed,155,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performed']
Performance,"/** @summary Call 3D rendering of the geometry; * @param tmout - specifies delay, after which actual rendering will be invoked; * @param [measure] - when true, for the first time printout rendering time; * @return {Promise} when tmout bigger than 0 is specified; * @desc Timeout used to avoid multiple rendering of the picture when several 3D drawings; * superimposed with each other. If tmout <= 0, rendering performed immediately; * Several special values are used:; * -1 - force recheck of rendering order based on camera position */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:410,perform,performed,410,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performed']
Performance,/** @summary Central ROOT RBrowser controller; * @desc All Browser functionality is loaded after main ui5 rendering is performed */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/browser/controller/Browser.controller.js:84,load,loaded,84,ui5/browser/controller/Browser.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/browser/controller/Browser.controller.js,2,"['load', 'perform']","['loaded', 'performed']"
Performance,"/** @summary Central geometry viewer controller; * @desc All TGeo functionality is loaded after main ui5 rendering is performed,; * To start drawing, following stages should be completed:; * - ui5 element is rendered (onAfterRendering is called); * - TGeo-related JSROOT functionality is loaded; * - RGeomDrawing object delivered from the server; * Only after all this stages are completed, one could start to analyze */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomHierarchy.controller.js:83,load,loaded,83,ui5/geom/controller/GeomHierarchy.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomHierarchy.controller.js,6,"['load', 'perform']","['loaded', 'performed']"
Performance,/** @summary Check if dragging performed currently; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:31,perform,performed,31,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performed']
Performance,"/** @summary Check pad ranges when drawing of frame axes will be performed; * @desc Only if histogram is main painter and drawn with SAME option, pad range can be used; * In all other cases configured range must be derived from histogram itself */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:65,perform,performed,65,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performed']
Performance,"/** @summary Configure user-defined click handler; * @desc Function will be called every time when frame click was performed; * As argument, tooltip object with selected bins will be provided; * If handler function returns true, default handling of click will be disabled */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:115,perform,performed,115,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['perform'],['performed']
Performance,"/** @summary Configure user-defined click handler; * @desc Function will be called every time when frame click was performed; * As argument, tooltip object with selected bins will be provided; * If handler function returns true, default handling of click will be disabled; * @param {function} handler - function called when mouse click is done */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:115,perform,performed,115,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performed']
Performance,/** @summary Create painter to perform tree drawing on server side; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:31,perform,perform,31,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['perform']
Performance,/** @summary Creates transformation matrix for TGeoNode; * @desc created after node visibility flag is checked and volume cut is performed; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:129,perform,performed,129,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performed']
Performance,/** @summary Function called when frame is clicked and object selection can be performed; * @desc such event can be used to select */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:79,perform,performed,79,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performed']
Performance,"/** @summary Function can be used for zooming into specified range; * @desc if both limits for each axis 0 (like xmin === xmax === 0), axis will be unzoomed; * @param {number} xmin; * @param {number} xmax; * @param {number} [ymin]; * @param {number} [ymax]; * @param {number} [zmin]; * @param {number} [zmax]; * @param [interactive] - if changes was performed interactively; * @return {Promise} with boolean flag if zoom operation was performed */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:350,perform,performed,350,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['perform'],['performed']
Performance,"/** @summary Histogram drawing optimization: 0 - disabled, 1 - only for large (>5000 1d bins, >50 2d bins) histograms, 2 - always */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:31,optimiz,optimization,31,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['optimiz'],['optimization']
Performance,"/** @summary Inject message(s) into input queue, for debug purposes only; * @private */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:42,queue,queue,42,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['queue'],['queue']
Performance,/** @summary Load ES6 modules; * @param {String} arg - single URL or array of URLs; * @return {Promise} */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,Load,Load,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Load'],['Load']
Performance,"/** @summary Load MathJax functionality,; * @desc one need not only to load script but wait for initialization; * @private */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,Load,Load,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,"['Load', 'load']","['Load', 'load']"
Performance,"/** @summary Load and execute scripts, kept to support v6 applications; * @private */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,Load,Load,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Load'],['Load']
Performance,/** @summary Load custom panel in canvas left area */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/canv/controller/Canvas.controller.js:13,Load,Load,13,ui5/canv/controller/Canvas.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/canv/controller/Canvas.controller.js,1,['Load'],['Load']
Performance,"/** @summary Load required modules, noop for that menu class */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,Load,Load,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Load'],['Load']
Performance,"/** @summary Load script or CSS file into the browser; * @param {String} url - script or css file URL (or array, in this case they all loaded sequentially); * @return {Promise} */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,Load,Load,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,"['Load', 'load']","['Load', 'loaded']"
Performance,/** @summary Load symbol.ttf font to display greek labels. By default font file not loaded and unicode is used */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,Load,Load,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,"['Load', 'load']","['Load', 'loaded']"
Performance,/** @summary Location of JSROOT modules; * @desc Automatically detected and used to dynamically load other modules; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:96,load,load,96,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['load'],['load']
Performance,/** @summary Main function in geometry creation loop; * @desc Returns:; * - false when nothing todo; * - true if one could perform next action immediately; * - 1 when call after short timeout required; * - 2 when call must be done from processWorkerReply */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:123,perform,perform,123,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['perform']
Performance,"/** @summary Method converts JavaScript object into ROOT-like JSON; * @desc When performed properly, JSON can be used in [TBufferJSON::fromJSON()]{@link https://root.cern/doc/master/classTBufferJSON.html#a2ecf0daacdad801e60b8093a404c897d} method to read data back with C++; * Or one can again parse json with {@link parse} function; * @param {object} obj - JavaScript object to convert; * @param {number} [spacing] - optional line spacing in JSON; * @return {string} produced JSON code; * @example; * import { openFile, draw, toJSON } from 'https://root.cern/js/latest/modules/main.mjs';; * let file = await openFile('https://root.cern/js/files/hsimple.root');; * let obj = await file.readObject('hpxpy;1');; * obj.fTitle = 'New histogram title';; * let json = toJSON(obj); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:81,perform,performed,81,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performed']
Performance,"/** @summary Method used to set transparency for all geometrical shapes; * @param {number|Function} transparency - one could provide function; * @param {boolean} [skip_render] - if specified, do not perform rendering */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:199,perform,perform,199,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['perform']
Performance,/** @summary Old v6 method to load JSROOT functionality; * @desc; * Following components can be specified; * - 'io' TFile functionality; * - 'tree' TTree support; * - 'painter' d3.js plus basic painting functions; * - 'geom' TGeo support; * - 'math' some methods from TMath class; * - 'hierarchy' hierarchy browser; * - 'openui5' OpenUI5 and related functionality; * @param {Array|string} req - list of required components (as array or string separated by semicolon); * @return {Promise} with array of requirements (or single element) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/scripts/JSRoot.core.js:30,load,load,30,js/scripts/JSRoot.core.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/scripts/JSRoot.core.js,1,['load'],['load']
Performance,/** @summary Perform automatic zoom inside non-zero region of histogram */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,Perform,Perform,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,12,['Perform'],['Perform']
Performance,/** @summary Perform moving */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,Perform,Perform,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Perform'],['Perform']
Performance,/** @summary Performs 2D drawing of histogram; * @return {Promise} when ready */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,Perform,Performs,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,6,['Perform'],['Performs']
Performance,/** @summary Performs 3D drawing of histogram; * @return {Promise} when ready */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,Perform,Performs,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Perform'],['Performs']
Performance,/** @summary Performs axis drawing; * @return {Promise} which resolved when drawing is completed */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,Perform,Performs,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Perform'],['Performs']
Performance,/** @summary Performs generic I/O test for all branches in the TTree; * @desc Used when 'testio' draw option for TTree is specified; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,Perform,Performs,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Perform'],['Performs']
Performance,/** @summary Performs labels drawing; * @return {Promise} with gaps in both direction */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,Perform,Performs,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Perform'],['Performs']
Performance,/** @summary Process completed messages in the queue; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:47,queue,queue,47,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['queue'],['queue']
Performance,/** @summary Process script option - load and execute some gGeoManager-related calls */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:37,load,load,37,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['load'],['load']
Performance,/** @summary Provide data for receiver. When no queue - do it directly.; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:48,queue,queue,48,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['queue'],['queue']
Performance,"/** @summary Redraw object in specified HTML element with given draw options.; * @param {string|object} dom - id of div element to draw or directly DOMElement; * @param {object} obj - object to draw, object type should be registered before with {@link addDrawFunc}; * @param {string} opt - draw options; * @return {Promise} with painter object; * @desc If drawing was not done before, it will be performed with {@link draw}.; * Otherwise drawing content will be updated; * @public; * @example; * import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; * import { draw, redraw } from 'https://root.cern/js/latest/modules/draw.mjs';; * let file = await openFile('https://root.cern/js/files/hsimple.root');; * let obj = await file.readObject('hpxpy;1');; * await draw('drawing', obj, 'colz');; * let cnt = 0;; * setInterval(() => {; * obj.fTitle = `Next iteration ${cnt++}`;; * redraw('drawing', obj, 'colz');; * }, 1000); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:396,perform,performed,396,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performed']
Performance,/** @summary Reentrant method to perform geometry drawing step by step */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:33,perform,perform,33,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['perform']
Performance,"/** @summary Register draw function for the class; * @desc List of supported draw options could be provided, separated with ';'; * @param {object} args - arguments; * @param {string|regexp} args.name - class name or regexp pattern; * @param {function} [args.func] - draw function; * @param {function} [args.draw] - async function to load draw function; * @param {function} [args.class] - async function to load painter class with static draw function; * @param {boolean} [args.direct] - if true, function is just Redraw() method of ObjectPainter; * @param {string} [args.opt] - list of supported draw options (separated with semicolon) like 'col;scat;'; * @param {string} [args.icon] - icon name shown for the class in hierarchy browser; * @param {string} [args.draw_field] - draw only data member from object, like fHistogram; * @protected */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:333,load,load,333,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['load'],['load']
Performance,"/** @summary Reserve entry in queue for data, which is not yet decoded.; * @private */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:30,queue,queue,30,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['queue'],['queue']
Performance,"/** @summary Reset position, used for optimization of drawing of multiple markers; * @private */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:38,optimiz,optimization,38,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['optimiz'],['optimization']
Performance,/** @summary Returns array with supported draw options as configured in draw.mjs; * @desc works via pad painter and only when module was loaded */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:137,load,loaded,137,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['load'],['loaded']
Performance,/** @summary Returns optimized bins - if optimization enabled */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:21,optimiz,optimized,21,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['optimiz'],"['optimization', 'optimized']"
Performance,/** @summary Returns true if graph drawing can be optimize */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:50,optimiz,optimize,50,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['optimiz'],['optimize']
Performance,"/** @summary Should performs 3D drawing of histogram; * @desc Disable in 2D case, just draw with default options; * @return {Promise} when ready */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:20,perform,performs,20,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performs']
Performance,/** @summary Should performs 3D drawing of histogram; * @desc Disabled in 2D case. just draw default draw options; * @return {Promise} when ready */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:20,perform,performs,20,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performs']
Performance,/** @summary Should returns true if font has to be loaded before; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:51,load,loaded,51,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['load'],['loaded']
Performance,/** @summary Start async text drawing; * @return {Promise} for loading of font if necessary; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:63,load,loading,63,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['load'],['loading']
Performance,"/** @summary Tweak browser caching with stamp URL parameter; * @desc When specified, extra URL parameter like ```?stamp=unique_value``` append to each files loaded; * In such case browser will be forced to load file content disregards of server cache settings; * Can be disabled by providing &usestamp=false in URL or via Settings/Files sub-menu; * @default true */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:157,load,loaded,157,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,6,"['cache', 'load']","['cache', 'load', 'loaded']"
Performance,"/** @summary Zooming of single axis; * @param {String} name - axis name like x/y/z but also second axis x2 or y2; * @param {Number} vmin - axis minimal value, 0 for unzoom; * @param {Number} vmax - axis maximal value, 0 for unzoom; * @param {Boolean} [interactive] - if change was performed interactively; * @protected */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:281,perform,performed,281,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['perform'],['performed']
Performance,/** @summary calculation of text size consumes time and can be skipped to improve performance (but with side effects on text adjustments) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:82,perform,performance,82,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performance']
Performance,"/** @summary call 3D rendering of the frame; * @param {number} tmout - specifies delay, after which actual rendering will be invoked; * @desc Timeout used to avoid multiple rendering of the picture when several 3D drawings; * superimposed with each other.; * If tmout <= 0, rendering performed immediately; * If tmout === -1111, immediate rendering with SVG renderer is performed; * @private */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:284,perform,performed,284,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['perform'],['performed']
Performance,"/** @summary draw 3D histogram as scatter plot; * @desc If there are too many points, box will be displayed; * @return {Promise|false} either Promise or just false that drawing cannot be performed */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:187,perform,performed,187,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performed']
Performance,"/** @summary function can be used for zooming into specified range; * @desc if both limits for each axis 0 (like xmin === xmax === 0), axis will be unzoomed; * @return {Promise} with boolean flag if zoom operation was performed */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:218,perform,performed,218,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performed']
Performance,"/** @summary function to accumulate and process all drawings messages; * @desc if not all scripts are loaded, messages are queued and processed later */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomViewer.controller.js:102,load,loaded,102,ui5/geom/controller/GeomViewer.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomViewer.controller.js,2,"['load', 'queue']","['loaded', 'queued']"
Performance,/** @summary function used with THttpServer when tree is not yet loaded; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:65,load,loaded,65,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['load'],['loaded']
Performance,/** @summary indicates if painter performing objects draw; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:34,perform,performing,34,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performing']
Performance,/** @summary load openui5; * @return {Promise} for loading ready; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,load,load,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['load'],"['load', 'loading']"
Performance,/** @summary method called when MDI element is cleaned up; * @desc hook to perform extra actions when frame is cleaned; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:75,perform,perform,75,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['perform']
Performance,/** @summary method used to check matrix calculations performance with current three.js model */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:54,perform,performance,54,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performance']
Performance,/** @summary methods show info when first geometry drawing is performed */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:62,perform,performed,62,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performed']
Performance,/** @summary perform mesh highlight */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,perform,perform,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['perform']
Performance,/** @summary perform resize */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,perform,perform,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['perform']
Performance,/** @summary perform resize for each frame; * @protected */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,perform,perform,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['perform']
Performance,"/** @summary sync drawing/redrawing/resize of the pad; * @param {string} kind - kind of draw operation, if true - always queued; * @return {Promise} when pad is ready for draw operation or false if operation already queued; * @private */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:121,queue,queued,121,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,8,['queue'],['queued']
Performance,/** Check if want to perform action */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/browsable/inc/ROOT/Browsable/RElement.hxx:21,perform,perform,21,gui/browsable/inc/ROOT/Browsable/RElement.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/browsable/inc/ROOT/Browsable/RElement.hxx,7,['perform'],['perform']
Performance,/** Clear all pointers without performing cleanup */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/browsable/inc/ROOT/Browsable/RHolder.hxx:31,perform,performing,31,gui/browsable/inc/ROOT/Browsable/RHolder.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/browsable/inc/ROOT/Browsable/RHolder.hxx,1,['perform'],['performing']
Performance,"/** Compute multiple values using optimized functions.; This method creates a Batches object and passes it to the correct compute function.; In case Implicit Multithreading is enabled, the events to be processed are equally; divided among the tasks to be generated and computed in parallel.; \param computer An enum specifying the compute function to be used.; \param output The array where the computation results are stored.; \param vars A std::span containing pointers to the variables involved in the computation.; \param extraArgs An optional std::span containing extra double values that may participate in the computation. **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/RooBatchCompute.cxx:34,optimiz,optimized,34,roofit/batchcompute/src/RooBatchCompute.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/RooBatchCompute.cxx,1,['optimiz'],['optimized']
Performance,/** Convert cuda matrix to Root TMatrix. Performs synchronous data transfer. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaMatrix.h:41,Perform,Performs,41,tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaMatrix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaMatrix.h,2,['Perform'],['Performs']
Performance,/** Convert to a TMatrixT<AFloat_t> object. Performs a deep copy of the matrix; * elements. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuMatrix.h:44,Perform,Performs,44,tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuMatrix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuMatrix.h,2,['Perform'],['Performs']
Performance,"/** Copy data from another buffer. No real copying is performed, only the; * data pointers are swapped. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuBuffer.h:54,perform,performed,54,tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuBuffer.h,1,['perform'],['performed']
Performance,"/** Copy data to another buffer. No real copying is performed, only the; * data pointers are swapped. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuBuffer.h:52,perform,performed,52,tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuBuffer.h,1,['perform'],['performed']
Performance,/** Create RElement for current entry - may take much time to load object or open file */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/browsable/inc/ROOT/Browsable/RLevelIter.hxx:62,load,load,62,gui/browsable/inc/ROOT/Browsable/RLevelIter.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/browsable/inc/ROOT/Browsable/RLevelIter.hxx,1,['load'],['load']
Performance,"/** Custom ""builtins,"" detectable by type, for pass by ref and improved; performance.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CustomPyTypes.h:73,perform,performance,73,bindings/pyroot/cppyy/CPyCppyy/src/CustomPyTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CustomPyTypes.h,1,['perform'],['performance']
Performance,/** Deprecated: Multi-threading can only be enabled/disabled with the compile; time define LLVM_ENABLE_THREADS. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:16,Multi-thread,Multi-threading,16,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['Multi-thread'],['Multi-threading']
Performance,/** Event and event queue */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h:20,queue,queue,20,tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,1,['queue'],['queue']
Performance,/** HUF_readCTable() :; * Loading a CTable saved with HUF_writeCTable() */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/huf.h:26,Load,Loading,26,builtins/zstd/common/huf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/huf.h,1,['Load'],['Loading']
Performance,"/** Perform a line search from position defined by the vector st; along the direction step, where the length of vector step; gives the expected position of Minimum.; fcn is Value of function at the starting position ,; gdel (if non-zero) is df/dx along step at st.; Return a parabola point containing Minimum x position and y (function Value); - add a flag to control the debug; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnLineSearch.cxx:4,Perform,Perform,4,math/minuit2/src/MnLineSearch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnLineSearch.cxx,1,['Perform'],['Perform']
Performance,"/** Perform a line search using a cubic interpolation using x0, x1 , df/dx(x0) and d2/dx(x0) (second derivative); This is used at the beginning when the second derivative is known to be negative; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnLineSearch.cxx:4,Perform,Perform,4,math/minuit2/src/MnLineSearch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnLineSearch.cxx,1,['Perform'],['Perform']
Performance,"/** Perform a single optimization step on a given batch. Propagates the input; matrix forward through the net, evaluates the loss and propagates the gradients; backward through the net. The computed gradients are scaled by the learning; rate \f$\alpha\f$ and subtracted from the weights and bias values of each; layer. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DLMinimizers.h:4,Perform,Perform,4,tmva/tmva/inc/TMVA/DNN/DLMinimizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DLMinimizers.h,4,"['Perform', 'optimiz']","['Perform', 'optimization']"
Performance,/** Perform multiple optimization steps simultaneously. Performs the; * backprop algorithm on the input batches given in \p batches on; * the neural networks given in \p nets. The forward and backward propagation; * steps are executed in an interleaving manner in order to exploit potential; * batch-level parallelism for asynchronous device calls.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DLMinimizers.h:4,Perform,Perform,4,tmva/tmva/inc/TMVA/DNN/DLMinimizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DLMinimizers.h,6,"['Perform', 'optimiz']","['Perform', 'Performs', 'optimization']"
Performance,"/** Performs a minimization using the simplex method of Nelder and Mead; (ref. Comp. J. 7, 308 (1965)).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/ScanBuilder.h:4,Perform,Performs,4,math/minuit2/inc/Minuit2/ScanBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/ScanBuilder.h,2,['Perform'],['Performs']
Performance,"/** Reads a module from the given memory buffer, returning via the OutMP; * parameter a module provider which performs lazy deserialization.; *; * Returns 0 on success.; *; * Takes ownership of \p MemBuf if (and only if) the module was read; * successfully. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:110,perform,performs,110,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,1,['perform'],['performs']
Performance,"/** Reads a module from the specified path, returning via the OutMP parameter; a module provider which performs lazy deserialization. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage.; This is deprecated. Use LLVMGetBitcodeModuleInContext2. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:103,perform,performs,103,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,1,['perform'],['performs']
Performance,/** Replicated object class which is extremely scalable for fetch. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h:47,scalab,scalable,47,tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,1,['scalab'],['scalable']
Performance,"/** StackAllocator controls the memory allocation/deallocation of Minuit. If; _MN_NO_THREAD_SAVE_ is defined, memory is taken from a pre-allocated piece; of heap memory which is then used like a stack, otherwise via standard; malloc/free. Note that defining _MN_NO_THREAD_SAVE_ makes the code thread-; unsave. The gain in performance is mainly for cost-cheap FCN functions.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/StackAllocator.h:322,perform,performance,322,math/minuit2/inc/Minuit2/StackAllocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/StackAllocator.h,1,['perform'],['performance']
Performance,"/** TCpuBuffer; *; * Since the memory on the CPU is homogeneous, only one buffer class is required.; * The host and device buffer classes are the same and copying between the host; * and device buffer is achieved by simply swapping the memory pointers.; *; * Memory is handled as a shared pointer to a pointer of type AFloat, which is; * the floating point type used for the implementation.; *; * Copying and assignment of TCpuBuffer objects performs only a shallow copy; * meaning the underlying data is shared between those objects.; *; * \tparam AFloat The floating point type used for the computations.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuBuffer.h:442,perform,performs,442,tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuBuffer.h,1,['perform'],['performs']
Performance,/** TCudaHostBuffer; *; * Wrapper class for pinned memory buffers on the host. Uses; * std::shared_pointer with custom destructor to ensure consistent; * memory management and allow for easy copying/moving of the; * buffers. Copying is asynchronous and will set the cudaStream of the; * device buffer so that subsequent computations on the device buffer; * can be performed on the same stream.; *; * \tparam AFloat The floating point type to be stored in the buffers.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaBuffers.h:364,perform,performed,364,tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaBuffers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaBuffers.h,1,['perform'],['performed']
Performance,"/** Test that the data loader loads all data in the data set by summing; * up all elements batch wise and comparing to the result obtained by summing; * over the complete dataset.; */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestDataLoader.h:23,load,loader,23,tmva/tmva/test/DNN/TestDataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestDataLoader.h,4,['load'],"['loader', 'loads']"
Performance,"/** Test the data loader by loading identical input and output data, running it; * through an identity neural network and computing the mean squared error,; * should obviously be zero. */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestDataLoader.h:18,load,loader,18,tmva/tmva/test/DNN/TestDataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestDataLoader.h,4,['load'],"['loader', 'loading']"
Performance,"/** Testing the entire pipeline of the Method DL, when only a Multilayer Percepton; * is constructed with various optimizers. */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLOptimization.h:114,optimiz,optimizers,114,tmva/tmva/test/DNN/TestMethodDLOptimization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLOptimization.h,1,['optimiz'],['optimizers']
Performance,"/** The TCpu architecture class.; *; * Low-level interface class for multi-threaded CPU architectures. Contains as; * public types the declaration of the scalar, matrix and data loader types; * for this architecture as well as the remaining functions in the low-level; * interface in the form of static members.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu.h:69,multi-thread,multi-threaded,69,tmva/tmva/inc/TMVA/DNN/Architectures/Cpu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu.h,2,"['load', 'multi-thread']","['loader', 'multi-threaded']"
Performance,"/** The TCpuMatrix class.; *; * Matrix class for multi-threaded CPU architectures. Uses the TCpuBuffer; * class to store the matrices in column-major format for compatibility with; * BLAS. Provides Map and MapFrom member functions to simplify the application of; * activation functions and derivatives to matrices.; *; * Copying and assignment of TCpuMatrix objects only performs shallow copies, i.e.; * copying is fast and the resulting objects share the element data.; *; * \tparam AFloat The floating point type used to represent the matrix elements.; */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuMatrix.h:49,multi-thread,multi-threaded,49,tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuMatrix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuMatrix.h,2,"['multi-thread', 'perform']","['multi-threaded', 'performs']"
Performance,/** Tree viewer contoller; * All TTree functionality is loaded after main ui5 rendering is performed */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/tree/controller/TreeViewer.controller.js:56,load,loaded,56,ui5/tree/controller/TreeViewer.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/tree/controller/TreeViewer.controller.js,2,"['load', 'perform']","['loaded', 'performed']"
Performance,"/** ZSTD_CCtx_setParametersUsingCCtxParams() :; * just applies `params` into `cctx`; * no action is performed, parameters are merely stored.; * If ZSTDMT is enabled, parameters are pushed to cctx->mtctx.; * This is possible even if a compression is ongoing.; * In which case, new parameters will be applied on the fly, starting with next compression job.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:100,perform,performed,100,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['perform'],['performed']
Performance,/** ZSTD_adjustCParams_internal() :; * optimize `cPar` for a specified input (`srcSize` and `dictSize`).; * mostly downsize to reduce memory consumption and initialization latency.; * `srcSize` can be ZSTD_CONTENTSIZE_UNKNOWN when not known.; * `mode` is the mode for parameter adjustment. See docs for `ZSTD_cParamMode_e`.; * note : `srcSize==0` means 0!; * condition : cPar is presumed validated (can be checked using ZSTD_checkCParams()). */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:39,optimiz,optimize,39,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,2,"['latency', 'optimiz']","['latency', 'optimize']"
Performance,"/** \class ConstantTermsOptimizer; *; * \brief Analyzes a function given a dataset/observables for constant terms and caches those in the dataset; *; * This optimizer should be used on a consistent combination of function (usually a pdf) and a dataset with observables.; * It then analyzes the function to find parts that can be precalculated because they are constant given the set of; * observables. These are cached inside the dataset and used in subsequent evaluations of the function on that dataset.; * The typical use case for this is inside likelihood minimization where many calls of the same pdf/dataset combination; * are made. \p norm_set must provide the normalization set of the function, which would typically be the set of; * observables in the dataset; this is used to make sure all object caches are created before analysis by evaluating the; * function on this set at the beginning of enableConstantTermsOptimization.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/ConstantTermsOptimizer.cxx:118,cache,caches,118,roofit/roofitcore/src/TestStatistics/ConstantTermsOptimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/ConstantTermsOptimizer.cxx,4,"['cache', 'optimiz']","['cached', 'caches', 'optimizer']"
Performance,"/** \class FIFOQueue; * \brief A Queue with simple FIFO behavior; */; /// See Queue::pop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/FIFOQueue.cxx:33,Queue,Queue,33,roofit/multiprocess/src/FIFOQueue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/FIFOQueue.cxx,2,['Queue'],['Queue']
Performance,"/** \class JobManager; *; * \brief Main point of access for all MultiProcess infrastructure; *; * This class mainly serves as the access point to the multi-process infrastructure; * for 'Job's. It is meant to be used as a singleton that holds and connects the other; * infrastructural classes: the messenger, process manager, worker and queue loops.; *; * It is important that the user of this class, particularly the one that calls; * 'instance()' first, calls 'activate()' soon after, because everything that is; * done in between 'instance()' and 'activate()' will be executed on all processes.; * This may be useful in some cases, but in general, one will probably want to always; * use the 'JobManager' in its full capacity, including the queue and worker loops.; * This is the way the Job class uses this class, see 'Job::get_manager()'.; *; * The default number of processes is set using 'std::thread::hardware_concurrency()'.; * To change it, use 'Config::setDefaultNWorkers()' to set it to a different value; * before creation of a new JobManager instance.; */; // static function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/JobManager.cxx:337,queue,queue,337,roofit/multiprocess/src/JobManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/JobManager.cxx,2,['queue'],['queue']
Performance,"/** \class Messenger; *; * \brief Manages ZeroMQ sockets and wraps send and receive calls; *; * This class is used for all interprocess communication between the master,; * queue and worker processes. It sets up ZeroMQ sockets between all processes; * over IPC socket files stored in /tmp on the filesystem.; *; * Several sockets are used for communication between different places for; * different purposes:; * - Master and queue processes each have a PUSH-PULL socket pair to directly; * send/receive data between only the master and queue processes. This is; * currently used mainly for sending tasks to the queue from master. The; * socket from queue back to master is used only to test connections and may; * be removed in the future.; * - The queue process also has a PUSH-PULL socket pair with each worker; * process. These are used by the workers to obtain tasks from the queue.; * - The master has a PUB socket that the workers subscribe to with SUB; * sockets. These are used to update state. Note that to ensure robust; * reception of all messages on the SUB socket, it's important to send over; * state in as little messages as possible. For instance, it's best to send; * arrays over in a single big message instead of sending over each element; * separately. This also improves performance, since each message has some; * fixed overhead.; * - Each worker has a PUSH socket connected to a PULL socket on master that; * is used to send back task results from workers to master in; * 'JobManager::retrieve()'.; *; * @param process_manager ProcessManager instance which manages the master,; * queue and worker processes that we want to set up; * communication for in this Messenger.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx:173,queue,queue,173,roofit/multiprocess/src/Messenger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx,9,"['perform', 'queue']","['performance', 'queue']"
Performance,"/** \class PiecewiseInterpolation; * \ingroup HistFactory; * The PiecewiseInterpolation is a class that can morph distributions into each other, which; * is useful to estimate systematic uncertainties. Given a nominal distribution and one or; * more altered or distorted ones, it computes a new shape depending on the value of the nuisance; * parameters \f$ \alpha_i \f$:; * \f[; * A = \sum_i \mathrm{Interpolate}(\mathrm{low}_i, \mathrm{nominal}, \mathrm{high}_i, \alpha_i).; * \f]; * If an \f$ \alpha_i \f$ is zero, the distribution is identical to the nominal distribution, at; * \f$ \pm 1 \f$ it is identical to the up/down distribution for that specific \f$ i \f$.; *; * The class supports several interpolation methods, which can be selected for each parameter separately; * using setInterpCode(). The default interpolation code is 4. This performs; * - \f$ |\alpha | > 1 \f$: Linear extrapolation.; * - \f$ |\alpha | < 1 \f$: Polynomial interpolation. A sixth-order polynomial is used. Its coefficients; * are chosen such that function, first, and second derivative at \f$ \alpha \pm 1 \f$ match the values; * that the extrapolation procedure uses.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/PiecewiseInterpolation.cxx:846,perform,performs,846,roofit/histfactory/src/PiecewiseInterpolation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/PiecewiseInterpolation.cxx,1,['perform'],['performs']
Performance,"/** \class PriorityQueue; * \brief Queue that orders tasks according to specified task priorities.; */; /// See Queue::pop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/PriorityQueue.cxx:35,Queue,Queue,35,roofit/multiprocess/src/PriorityQueue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/PriorityQueue.cxx,2,['Queue'],['Queue']
Performance,"/** \class Queue; * \brief Keeps a queue of tasks for workers and manages the queue process through its event loop; *; * The Queue maintains a set of tasks on the queue process by receiving them; * from the master process. Worker processes can request to pop them off the; * queue. The communication between these processes is handled inside; * 'Queue::loop()', the queue process's event loop that polls the Messenger's; * sockets for incoming messages and handles them when they come.; *; * The reason for this class is to get automatic load balancing between; * workers. By allowing workers to request tasks whenever they are ready to; * do work, we don't need to manually distribute work over workers and they; * will always have something to do until all tasks have been completed.; * The alternative simple strategy of just distributing all tasks evenly over; * workers will be suboptimal when tasks have different or even varying; * runtimes (this simple strategy could be implemented with a PUSH-PULL; * ZeroMQ socket from master to workers, which would distribute tasks in a; * round-robin fashion, which, indeed, does not do load balancing).; */; /// Helper function for 'Queue::loop()'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Queue.cxx:11,Queue,Queue,11,roofit/multiprocess/src/Queue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Queue.cxx,11,"['Queue', 'load', 'queue']","['Queue', 'load', 'queue']"
Performance,/** \class RFrame; \ingroup GpadROOT7; \brief Holds an area where drawing on user coordinate-system can be performed.; \authors Axel Naumann <axel@cern.ch> Sergey Linev <s.linev@gsi.de>; \date 2017-09-26; \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome!; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RFrame.hxx:107,perform,performed,107,graf2d/gpadv7/inc/ROOT/RFrame.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RFrame.hxx,1,['perform'],['performed']
Performance,"/** \class RRawFileDavix RRawFileDavix.hxx. The RRawFileDavix class provides read-only access to remote non-ROOT files. It uses the Davix library for; the transport layer. It instructs the RRawFile base class to buffer in larger chunks than the default for; local files, assuming that remote file access has high(er) latency. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/davix/inc/ROOT/RRawFileDavix.hxx:317,latency,latency,317,net/davix/inc/ROOT/RRawFileDavix.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/davix/inc/ROOT/RRawFileDavix.hxx,1,['latency'],['latency']
Performance,"/** \class RRawFileNetXNG RRawFileNetXNG.hxx. The RRawFileNetXNG class provides read-only access to remote files using root/roots protocol. It uses the; XrdCl (XRootD client) library for the transport layer. It instructs the RRawFile base class to buffer in; larger chunks than the default for local files, assuming that remote file access has high(er) latency. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/inc/ROOT/RRawFileNetXNG.hxx:353,latency,latency,353,net/netxng/inc/ROOT/RRawFileNetXNG.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/inc/ROOT/RRawFileNetXNG.hxx,1,['latency'],['latency']
Performance,"/** \class RooStats::FeldmanCousins; \ingroup Roostats. The FeldmanCousins class (like the Feldman-Cousins technique) is essentially a; specific configuration of the more general NeymanConstruction. It is a concrete; implementation of the IntervalCalculator interface that, which uses the; NeymanConstruction in a particular way. As the name suggests, it returns a; ConfidenceInterval. In particular, it produces a RooStats::PointSetInterval,; which is a concrete implementation of the ConfInterval interface. The Neyman Construction is not a uniquely defined statistical technique, it; requires that one specify an ordering rule or ordering principle, which is; usually encoded by choosing a specific test statistic and limits of integration; (corresponding to upper/lower/central limits). As a result, this class must be; configured with the corresponding information before it can produce an interval. In the case of the Feldman-Cousins approach, the ordering principle is the; likelihood ratio -- motivated by the Neyman-Pearson lemma. When nuisance; parameters are involved, the profile likelihood ratio is the natural; generalization. One may either choose to perform the construction over the full; space of the nuisance parameters, or restrict the nuisance parameters to their; conditional MLE (eg. profiled values). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/FeldmanCousins.cxx:1166,perform,perform,1166,roofit/roostats/src/FeldmanCousins.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/FeldmanCousins.cxx,1,['perform'],['perform']
Performance,/** \class TAdadelta; * Adadelta Optimizer class; *; * This class represents the Adadelta Optimizer.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adadelta.h:33,Optimiz,Optimizer,33,tmva/tmva/inc/TMVA/DNN/Adadelta.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adadelta.h,2,['Optimiz'],['Optimizer']
Performance,/** \class TAdagrad; * Adagrad Optimizer class; *; * This class represents the Adagrad Optimizer.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adagrad.h:31,Optimiz,Optimizer,31,tmva/tmva/inc/TMVA/DNN/Adagrad.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adagrad.h,2,['Optimiz'],['Optimizer']
Performance,/** \class TAdam; * Adam Optimizer class; *; * This class represents the Adam Optimizer.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adam.h:25,Optimiz,Optimizer,25,tmva/tmva/inc/TMVA/DNN/Adam.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adam.h,2,['Optimiz'],['Optimizer']
Performance,"/** \class TBuffer3D; \ingroup Base. Generic 3D primitive description class.; See TBuffer3DTypes for producer classes. ### Filling TBuffer3D and Adding to Viewer. The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. - Some know how to draw certain shapes natively (e.g. spheres/tubes in OpenGL); - others always require a raw tessellation description of points/lines/segments.; - Some need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). \image html base_tbuffer3d.png. The `SectionsValid() / SetSectionsValid / ClearSectionsValid()` methods of; TBuffer3D are used to test/set/clear these section valid flags. The sections found in TBuffer3D (`Core/BoundingBox/Raw Sizes/Raw`) are sufficient; to describe any tessellated shape in a generic fashion. An additional; `ShapeSpecific` section in derived shape specific classes allows a more abstract; shape description (""a sphere of inner radius x, outer radius y""). This; enables a viewer which knows how to draw (tessellate) the shape itself to do so,; which can bring considerable performance and quality benefits, while providing a; generic fallback suitable for all viewers. The rules for client negotiation with the viewer are:. - If suitable specialized TBuffer3D class exists, use it, otherwise use TBuffer3D.; - Complete the mandatory Core section.; - Complete the ShapeSpecific section if applicable.; - Complete the BoundingBox if you can.; - Pass this buffer to the viewer using one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) AddObject(); will return flags indicating which ones, otherwise it returns kNo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer3D.cxx:563,perform,performance,563,core/base/src/TBuffer3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer3D.cxx,1,['perform'],['performance']
Performance,"/** \class TExec; \ingroup Base. TExec is a utility class that can be used to execute a C++ command; when some event happens in a pad.; The command in turn can invoke a C++ macro to paint graphics objects; at positions depending on the histogram or graph contents. ### Case 1:. The TExec object is in the list of pad primitives (after exec.Draw()).; When the pad is drawn, the TExec::Paint function is called. This function; will execute the specified command.; The following example uses the services of the class Aclock created; in `$ROOTSYS/test/Aclock.cxx`.; This examples uses a TTimer to redraw a pad at regular intervals (clock).; When the clock is updated, a string with the current date&time is drawn.; ~~~ {.cpp}; {; gSystem->Load(""$ROOTSYS/test/Aclock"");; Aclock ck(400);; gPad->SetFillColor(5);; TDatime dt;; TText t(.5,.3,""t"");; t.SetTextAlign(22);; t.SetTextSize(.07);; t.SetTextColor(4);; t.Draw();; TExec ex(""ex"",""dt.Set();t.SetTitle(dt.AsString())"");; ex.Draw();; }; ~~~. ### Case 2:. The TExec object may be added to the list of functions of a TH1 or TGraph; object via hist->GetListOfFunctions()->Add(exec).; When the histogram (or graph) is drawn, the TExec will be executed.; If the histogram is made persistent on a file, the TExec object; is also saved with the histogram. When redrawing the histogram in a; new session, the TExec will be executed. Example:. Assume an histogram TH1F *h already filled.; ~~~ {.cpp}; TExec *ex1 = new TExec(""ex1"",""DoSomething()"");; TExec *ex2 = new TExec(""ex2"","".x macro.C"");; h->GetListOfFunctions()->Add(ex1);; h->GetListOfFunctions()->Add(ex2);; h->Draw();; ~~~. When the Paint function for the histogram will be called, the ""DoSomething""; function will be called (interpreted or compiled) and also the macro.C. ### Case 3:. A TExec object is automatically generated when invoking TPad::AddExec.; Each pad contains a TList of TExecs (0, 1 or more). When a mouse event; (motion, click, etc) happens, the pad object executes sequentially; this l",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TExec.cxx:736,Load,Load,736,core/base/src/TExec.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TExec.cxx,1,['Load'],['Load']
Performance,"/** \class TF1Convolution; \ingroup Functions; \brief Class wrapping convolution of two functions. Class wrapping convolution of two functions: evaluation of \f$\int f(x)g(x-t)dx\f$. The convolution is performed by default using FFTW if it is available .; One can pass optionally the range of the convolution (by default the first function range is used).; Note that when using Discrete Fourier Transform (as FFTW), it is a circular transform, so the functions should be; approximately zero at the end of the range. If they are significantly different than zero on one side (e.g. the left side); a spill over will occur on the other side (e.g right side).; If no function range is given by default the function1 range + 10% is used; One should use also a not too small number of points for the DFT (a minimum of 1000). By default 10000 points are used.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:202,perform,performed,202,hist/hist/src/TF1Convolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx,1,['perform'],['performed']
Performance,/** \class TGLClip; \ingroup opengl; Abstract clipping shape - derives from TGLPhysicalShape; Adds clip mode (inside/outside) and pure virtual method to; approximate shape as set of planes. This plane set is used to perform; interactive clipping using OpenGL clip planes.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLClip.cxx:216,perform,perform,216,graf3d/gl/src/TGLClip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLClip.cxx,1,['perform'],['perform']
Performance,/** \class TGLColor; \ingroup opengl; Class encapsulating color information in preferred GL format - an; array of four unsigned bytes.; Color index is also cached for easier interfacing with the; traditional ROOT graphics.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx:156,cache,cached,156,graf3d/gl/src/TGLUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx,1,['cache'],['cached']
Performance,"/** \class TGLLogicalShape; \ingroup opengl; Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :. - Sphere A - Radius r1, center v1; - Sphere B - Radius r2, center v2; - Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes do not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:; ~~~ {.cpp}; * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod.; ~~~; Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx:919,perform,performed,919,graf3d/gl/src/TGLLogicalShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx,1,['perform'],['performed']
Performance,"/** \class TGLPhysicalShape; \ingroup opengl; Concrete physical shape - a GL drawable. Physical shapes are the; objects the user can actually see, select, move in the viewer. It is; a placement of the associated local frame TGLLogicaShape into the; world frame. The draw process is:. Load attributes - material colors etc; Load translation matrix - placement; Load gl name (for selection); Call our associated logical shape Draw() to draw placed shape. The physical shape supports translation, scaling and rotation,; selection, color changes, and permitted modification flags etc.; A physical shape cannot modify or be bound to another (or no); logical shape - hence const & handle. It can perform mutable; reference counting on the logical to enable purging. Physical shape also maintains a list of references to it and; provides notifications of change and destruction.; See class TGLPShapeRef which needs to be sub-classes for real use. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPhysicalShape.cxx:284,Load,Load,284,graf3d/gl/src/TGLPhysicalShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPhysicalShape.cxx,4,"['Load', 'perform']","['Load', 'perform']"
Performance,"/** \class TGLScene; \ingroup opengl; TGLScene provides management and rendering of ROOT's default 3D; /object representation as logical and physical shapes. A GL scene is the container for all the viewable objects (shapes); loaded into the viewer. It consists of two main stl::maps containing; the TGLLogicalShape and TGLPhysicalShape collections, and interface; functions enabling viewers to manage objects in these. The physical; shapes defined the placement of copies of the logical shapes - see; TGLLogicalShape/TGLPhysicalShape for more information on relationship. The scene can be drawn by owning viewer, passing camera, draw style; & quality (LOD), clipping etc - see Draw(). The scene can also be; drawn for selection in similar fashion - see Select(). The scene; keeps track of a single selected physical - which can be modified by; viewers. The scene maintains a lazy calculated bounding box for the total; scene extents, axis aligned round TGLPhysicalShape shapes. Currently a scene is owned exclusively by one viewer - however it is; intended that it could easily be shared by multiple viewers - for; efficiency and synchronisation reasons. Hence viewer variant objects; camera, clips etc being owned by viewer and passed at draw/select; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx:225,load,loaded,225,graf3d/gl/src/TGLScene.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx,1,['load'],['loaded']
Performance,/** \class TGLSceneInfo; \ingroup opengl; Base class for extended scene context. Scenes can be shared among several viewers and each scene needs to; cache some viewer/camera/clipping specific state => this is a; storage class for this data. Sub-classes of TGLSceneBase can override the virtual; CreateSceneInfo() method and in it instantiate a sub-class of; TGLSceneInfo containing the needed information. See TGLScene and; inner class SceneInfo; note that some casting is needed in actual; methods as TGLRnrCtx holds the base-class pointer.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLSceneInfo.cxx:149,cache,cache,149,graf3d/gl/src/TGLSceneInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLSceneInfo.cxx,1,['cache'],['cache']
Performance,/** \class TGLStopwatch; \ingroup opengl; Stopwatch object for timing GL work. We do not use the TStopwatch as; we need to perform GL flushing to get accurate times + we record; timing overheads here.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLStopwatch.cxx:123,perform,perform,123,graf3d/gl/src/TGLStopwatch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLStopwatch.cxx,1,['perform'],['perform']
Performance,"/** \class TGLViewer; \ingroup opengl; Base GL viewer object - used by both standalone and embedded (in pad); GL. Contains core viewer objects :. GL scene - collection of main drawn objects - see TGLStdScene; Cameras (fXyzzCamera) - ortho and perspective cameras - see TGLCamera; Clipping (fClipXyzz) - collection of clip objects - see TGLClip; Manipulators (fXyzzManip) - collection of manipulators - see TGLManip. It maintains the current active draw styles, clipping object,; manipulator, camera etc. TGLViewer is 'GUI free' in that it does not derive from any ROOT GUI; TGFrame etc - see TGLSAViewer for this. However it contains GUI; GUI style methods HandleButton() etc to which GUI events can be; directed from standalone frame or embedding pad to perform; interaction. Also, the TGLWidget needs to be created externally. It is not owned; by the viewer. For embedded (pad) GL this viewer is created directly by plugin; manager. For standalone the derived TGLSAViewer is.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx:755,perform,perform,755,graf3d/gl/src/TGLViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx,1,['perform'],['perform']
Performance,"/** \class TGTable; \ingroup guiwidgets. Create an array to hold a bunch of numbers. TGTable implements a table widget to display data in rows and; columns. The data is supplied by a TVirtualTableInterface. The table is a TGCanvas to make use of already available viewport; functionality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. ~~~; {; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5);. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTable.cxx:300,optimiz,optimizations,300,gui/gui/src/TGTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTable.cxx,2,"['load', 'optimiz']","['load', 'optimizations']"
Performance,"/** \class TGeoCacheState; \ingroup Geometry_classes. Class storing the state of the cache at a given moment. */; ////////////////////////////////////////////////////////////////////////////////; /// Default ctor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCache.cxx:85,cache,cache,85,geom/geom/src/TGeoCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCache.cxx,1,['cache'],['cache']
Performance,"/** \class TGeoIterator; \ingroup Geometry_classes; A geometry iterator. A geometry iterator that sequentially follows all nodes of the geometrical; hierarchy of a volume. The iterator has to be initiated with a top volume; pointer:. ~~~ {.cpp}; TGeoIterator next(myVolume);; ~~~. One can use the iterator as any other in ROOT:. ~~~ {.cpp}; TGeoNode *node;; while ((node=next())) {; ...; }; ~~~. The iterator can perform 2 types of iterations that can be selected via:. ~~~ {.cpp}; next.SetType(Int_t type);; ~~~. Here TYPE can be:; - 0 (default) - 'first daughter next' behavior; - 1 - iteration at the current level only. Supposing the tree structure looks like:. ~~~ {.cpp}; TOP ___ A_1 ___ A1_1 ___ A11_1; | | |___ A12_1; | |_____A2_1 ___ A21_1; | |___ A21_2; |___ B_1 ...; ~~~. The order of iteration for TYPE=0 is: A_1, A1_1, A11_1, A12_1, A2_1, A21_1,; A21_2, B_1, ... The order of iteration for TYPE=1 is: A_1, B_1, ...; At any moment during iteration, TYPE can be changed. If the last iterated node; is for instance A1_1 and the iteration type was 0, one can do:. ~~~ {.cpp}; next.SetType(1);; ~~~. The next iterated nodes will be the rest of A daughters: A2,A3,... The iterator; will return 0 after finishing all daughters of A. During iteration, the following can be retrieved:; - Top volume where iteration started: TGeoIterator::GetTopVolume(); - Node at level I in the current branch: TGeoIterator::GetNode(Int_t i); - Iteration type: TGeoIterator::GetType(); - Global matrix of the current node with respect to the top volume:; TGeoIterator::GetCurrentMatrix(). The iterator can be reset by changing (or not) the top volume:. ~~~ {.cpp}; TGeoIterator::Reset(TGeoVolume *top);; ~~~. ### Example:. We want to find out a volume named ""MyVol"" in the hierarchy of TOP volume. ~~~ {.cpp}; TIter next(TOP);; TGeoNode *node;; TString name(""MyVol"");; while ((node=next())); if (name == node->GetVolume()->GetName()) return node->GetVolume();; ~~~; */; /** \class TGeoIteratorPlugin; \ingroup Geo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNode.cxx:413,perform,perform,413,geom/geom/src/TGeoNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNode.cxx,1,['perform'],['perform']
Performance,"/** \class TGraphAsymmErrors; \ingroup Graphs; TGraph with asymmetric error bars. The TGraphAsymmErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with asymmetric error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; auto gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphAsymmErrors default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:116,perform,performed,116,hist/hist/src/TGraphAsymmErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx,1,['perform'],['performed']
Performance,"/** \class TGraphDelaunay2D; \ingroup Graphs; TGraphDelaunay2D generates a Delaunay triangulation of a TGraph2D.; The algorithm used for finding the triangles is based on [CDT](https://github.com/artem-ogre/CDT),; a C++ library for generating constraint or conforming Delaunay triangulations. The ROOT::Math::Delaunay2D class provides a wrapper for using; the **CDT** library. This implementation provides large improvements in terms of computational performances; compared to the legacy one available in TGraphDelaunay, and it is by default; used in TGraph2D. The old, legacy implementation can be still used when calling; `TGraph2D::GetHistogram` and `TGraph2D::Draw` with the `old` option. Definition of Delaunay triangulation (After B. Delaunay):; For a set S of points in the Euclidean plane, the unique triangulation DT(S); of S such that no point in S is inside the circumcircle of any triangle in; DT(S). DT(S) is the dual of the Voronoi diagram of S. If n is the number of; points in S, the Voronoi diagram of S is the partitioning of the plane; containing S points into n convex polygons such that each polygon contains; exactly one point and every point in a given polygon is closer to its; central point than to any other. A Voronoi diagram is sometimes also known; as a Dirichlet tessellation. \image html tgraph2d_delaunay.png. [This applet](http://www.cs.cornell.edu/Info/People/chew/Delaunay.html); gives a nice practical view of Delaunay triangulation and Voronoi diagram.; */; /// TGraphDelaunay2D normal constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay2D.cxx:451,perform,performances,451,hist/hist/src/TGraphDelaunay2D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay2D.cxx,1,['perform'],['performances']
Performance,"/** \class TGraphMultiErrors; \ingroup Graphs; TGraph with asymmetric error bars and multiple y error dimensions. The TGraphMultiErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"", ""A Simple Graph with multiple y-errors"", 200, 10, 700, 500);; c1->SetGrid();; c1->GetFrame()->SetBorderSize(12);; const Int_t np = 5;; Double_t x[np] = {0, 1, 2, 3, 4};; Double_t y[np] = {0, 2, 4, 1, 3};; Double_t exl[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t exh[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t eylstat[np] = {1, 0.5, 1, 0.5, 1};; Double_t eyhstat[np] = {0.5, 1, 0.5, 1, 2};; Double_t eylsys[np] = {0.5, 0.4, 0.8, 0.3, 1.2};; Double_t eyhsys[np] = {0.6, 0.7, 0.6, 0.4, 0.8};; auto gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; gme->AddYError(np, eylsys, eyhsys);; gme->SetMarkerStyle(20);; gme->SetLineColor(kRed);; gme->GetAttLine(0)->SetLineColor(kRed);; gme->GetAttLine(1)->SetLineColor(kBlue);; gme->GetAttFill(1)->SetFillStyle(0);; gme->Draw(""APS ; Z ; 5 s=0.5"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:148,perform,performed,148,hist/hist/src/TGraphMultiErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx,1,['perform'],['performed']
Performance,"/** \class THLimitsFinder; \ingroup Histograms; Class to compute nice axis limits. This class is called by default by the histogramming system; and also by TTree::Draw, TTreePlayer::DrawSelect. TGaxis use it also to; optimize axis labels. A different finder may be specified via THLimitsFinder::SetFinder.; */; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:217,optimiz,optimize,217,hist/hist/src/THLimitsFinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx,1,['optimiz'],['optimize']
Performance,"/** \class TLegend; \ingroup BasicGraphics. This class displays a legend box (TPaveText) containing several legend entries. Each legend entry is made of a reference to a ROOT object, a text label and an; option specifying which graphical attributes (marker/line/fill) should be; displayed. The following example shows how to create a legend. In this example the legend; contains a histogram, a function and a graph. The histogram is put in the legend; using its reference pointer whereas the graph and the function are added; using their names. Note that, because `TGraph` constructors do not have the; `TGraph` name as parameter, the graph name should be specified using the; `SetName` method. When an object is added by name, a scan is performed on the list of objects; contained in the current pad (`gPad`) and also in the possible; `TMultiGraph` and `THStack` present in the pad. If a matching; name is found, the corresponding object is added in the legend using its pointer. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,500);; gStyle->SetOptStat(0);. auto h1 = new TH1F(""h1"",""TLegend Example"",200,-10,10);; h1->FillRandom(""gaus"",30000);; h1->SetFillColor(kGreen);; h1->SetFillStyle(3003);; h1->Draw();. auto f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; f1->SetLineColor(kBlue);; f1->SetLineWidth(4);; f1->Draw(""same"");. const Int_t n = 20;; Double_t x[n], y[n], ex[n], ey[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 1000*sin(x[i]+0.2);; x[i] = 17.8*x[i]-8.9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; auto gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. auto legend = new TLegend(0.1,0.7,0.48,0.9);; legend->SetHeader(""The Legend Title"",""C""); // option ""C"" allows to center the header; legend->AddEntry(h1,""Histogram filled with random numbers"",""f"");; legend->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; legend->A",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLegend.cxx:738,perform,performed,738,graf2d/graf/src/TLegend.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLegend.cxx,1,['perform'],['performed']
Performance,"/** \class TNotifyLink; \ingroup Base. A node in a doubly linked list of subscribers to TChain notifications. TObject has a virtual TObject::Notify() method that takes no parameters and returns a boolean.; By default the method does nothing, and different objects in ROOT use this method for different purposes. `TChain` uses `Notify` to implement a callback mechanism that notifies interested parties (subscribers) when; the chain switches to a new sub-tree.; In practice it calls the Notify() method of its fNotify data member from TChain::LoadTree().; However there could be several different objects interested in knowing that a given TChain switched to a new tree.; TNotifyLink can be used to build a linked list of subscribers: calling TNotifyLink::Notify() on the head; node of the list propagates the call to all subscribers in the list. Example usage:; ~~~{.cpp}; TNotifyLink l(subscriber); // subscriber must implement `Notify()`; l.PrependLink(chain); // prepends `l` to the list of notify links of the chain; ~~~. \note TChain does not explicitly enforce that its fNotify data member be the head node of a list of; TNotifyLinks, but that is the case in practice at least when using TTreeReader or RDataFrame to process the chain. \note TChain does not take ownership of the TNotifyLink and the TNotifyLink does not take ownership of the; subscriber object.; **/; /// See TNotifyLink.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TNotifyLink.h:542,Load,LoadTree,542,core/base/inc/TNotifyLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TNotifyLink.h,1,['Load'],['LoadTree']
Performance,"/** \class TPad; \ingroup gpad. The most important graphics class in the ROOT system. A Pad is contained in a Canvas. A Pad may contain other pads (unlimited pad hierarchy). A pad is a linked list of primitives of any type (graphics objects,; histograms, detectors, tracks, etc.). Adding a new element into a pad is in general performed by the Draw; member function of the object classes. It is important to realize that the pad is a linked list of references; to the original object.; For example, in case of a histogram, the histogram.Draw() operation; only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted. \image html gpad_pad1.png. This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. \image html gpad_pad2.png. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object. When the object is within the distance window, the member function; ExecuteEvent is called for this object. In ExecuteEvent, move, changes can be performed on the object. For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes; ~~~ {.cpp}; TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::DistancetoPrimitive, TBox::ExecuteEvent; TH1::DistancetoPrimitive, TH1::ExecuteEvent; ~~~; A Pad supports linear and log scales coordinate systems.; The transformation coefficients are explained in TPad::ResizePad.; */; /",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:327,perform,performed,327,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,2,['perform'],['performed']
Performance,/** \class TRMSProp; * RMSProp Optimizer class; *; * This class represents the RMSProp Optimizer with options for applying momentum.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RMSProp.h:31,Optimiz,Optimizer,31,tmva/tmva/inc/TMVA/DNN/RMSProp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RMSProp.h,2,['Optimiz'],['Optimizer']
Performance,/** \class TSGD; * Stochastic Batch Gradient Descent Optimizer class; *; * This class represents the Stochastic Batch Gradient Descent Optimizer with options for applying momentum; * and nesterov momentum.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/SGD.h:53,Optimiz,Optimizer,53,tmva/tmva/inc/TMVA/DNN/SGD.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/SGD.h,2,['Optimiz'],['Optimizer']
Performance,"/** \class TSPlot. \legacy{TSPlot}. A common method used in High Energy Physics to perform measurements is; the maximum Likelihood method, exploiting discriminating variables to; disentangle signal from background. The crucial point for such an; analysis to be reliable is to use an exhaustive list of sources of; events combined with an accurate description of all the Probability; Density Functions (PDF). To assess the validity of the fit, a convincing quality check; is to explore further the data sample by examining the distributions of; control variables. A control variable can be obtained for instance by; removing one of the discriminating variables before performing again; the maximum Likelihood fit: this removed variable is a control; variable. The expected distribution of this control variable, for; signal, is to be compared to the one extracted, for signal, from the; data sample. In order to be able to do so, one must be able to unfold; from the distribution of the whole data sample. The TSPlot method allows to reconstruct the distributions for; the control variable, independently for each of the various sources of; events, without making use of any <em>a priori</em> knowledge on <u>this</u>; variable. The aim is thus to use the knowledge available for the; discriminating variables to infer the behaviour of the individual; sources of events with respect to the control variable. TSPlot is optimal if the control variable is uncorrelated with the discriminating variables. A detail description of the formalism itself, called \f$\hbox{$_s$}{\cal P}lot\f$, is given; in [[1](https://arxiv.org/abs/physics/0402083)]. ### The method. The \f$\hbox{$_s$}{\cal P}lot\f$ technique is developed in the above context of a; maximum Likelihood method making use of discriminating variables. One considers a data sample in which are merged several species; of events. These species represent various signal components and; background components which all together account for the data s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/splot/src/TSPlot.cxx:83,perform,perform,83,math/splot/src/TSPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/splot/src/TSPlot.cxx,2,['perform'],"['perform', 'performing']"
Performance,"/** \class TSVG; \ingroup PS. \brief Interface to SVG. [SVG](http://www.w3.org/Graphics/SVG/Overview.htm8); (Scalable Vector Graphics) is a language for describing; two-dimensional graphics in XML. SVG allows high quality vector graphics in; HTML pages. To print a ROOT canvas ""c1"" into an SVG file simply do:; ~~~ {.cpp}; c1->Print(""c1.svg"");; ~~~; The result is the ASCII file `c1.svg`. It can be open directly using a web browser or included in a html document; the following way:; ~~~ {.cpp}; <embed width=""95%"" height=""500"" src=""c1.svg"">; ~~~; It is best viewed with Internet Explorer and you need the; [Adobe SVG Viewer](http://www.adobe.com/svg/viewer/install/main.html). To zoom using the Adobe SVG Viewer, position the mouse over; the area you want to zoom and click the right button. To define the zoom area,; use Control+drag to mark the boundaries of the zoom area. To pan, use Alt+drag.; By clicking with the right mouse button on the SVG graphics you will get; a pop-up menu giving other ways to interact with the image. SVG files can be used directly in compressed mode to minimize the time; transfer over the network. Compressed SVG files should be created using; `gzip` on a normal ASCII SVG file and should then be renamed; using the file extension `.svgz`.; */; ////////////////////////////////////////////////////////////////////////////////; /// Default SVG constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TSVG.cxx:109,Scalab,Scalable,109,graf2d/postscript/src/TSVG.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TSVG.cxx,1,['Scalab'],['Scalable']
Performance,"/** \class TTreeFormula; Used to pass a selection expression to the Tree drawing routine. See TTree::Draw. A TreeFormula can contain any arithmetic expression including; standard operators and mathematical functions separated by operators.; Examples of valid expression:; ~~~{.cpp}; ""x<y && sqrt(z)>3.2""; ~~~; TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; - TFormLeafInfo; - TFormLeafInfoDirect; - TFormLeafInfoNumerical; - TFormLeafInfoClones; - TFormLeafInfoCollection; - TFormLeafInfoPointer; - TFormLeafInfoMethod; - TFormLeafInfoMultiVarDim; - TFormLeafInfoMultiVarDimDirect; - TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. - AddOffset(Int_t offset, TStreamerElement* element); - GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; - GetObjectAddress(TLeafElement* leaf) : Returns the location of the object pointed to.; - GetMultiplicity() : Returns info on the variability of the number of elements; - GetNdata(TLeaf* leaf) : Returns the number of elements; - GetNdata() : Used by GetNdata(TLeaf* leaf); - GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; - GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; - GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; - IsString(); - ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; - Update() : react to the possible loading of a shared library.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:1582,load,loading,1582,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['load'],['loading']
Performance,"/** \class TVirtualBranchBrowsable; \ingroup tree. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; ~~~ {.cpp}; TMethodBrowsable::Unregister(); ~~~; will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and their generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; ~~~ {.cpp}; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; ~~~; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; ~~~ {.cpp}; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; ~~~. It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:905,cache,cached,905,tree/tree/src/TBranchBrowsable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx,2,['cache'],['cached']
Performance,/** \class VOptimizer; Generic Optimizer class. This class represents the general class for all optimizers in the Deep Learning; Module.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Optimizer.h:31,Optimiz,Optimizer,31,tmva/tmva/inc/TMVA/DNN/Optimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Optimizer.h,2,"['Optimiz', 'optimiz']","['Optimizer', 'optimizers']"
Performance,"/** \defgroup CINDEX libclang: C Interface to Clang; *; * The C Interface to Clang provides a relatively small API that exposes; * facilities for parsing source code into an abstract syntax tree (AST),; * loading already-parsed ASTs, traversing the AST, associating; * physical source locations with elements within the AST, and other; * facilities that support Clang-based development tools.; *; * This C interface to Clang will never provide all of the information; * representation stored in Clang's C++ AST, nor should it: the intent is to; * maintain an API that is relatively stable from one release to the next,; * providing only the basic functionality needed to support development tools.; *; * To avoid namespace pollution, data types are prefixed with ""CX"" and; * functions are prefixed with ""clang_"".; *; * @{; */; /**; * An ""index"" that consists of a set of translation units that would; * typically be linked together into an executable or library.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:205,load,loading,205,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['load'],['loading']
Performance,"/** class TRefProxy; A reference proxy, which allows to access ROOT references (TRef); stored contained in other objects from TTree::Draw; */; ////////////////////////////////////////////////////////////////////////////////; /// TVirtualRefProxy overload: Update (and propagate) cached information",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TRefProxy.cxx:279,cache,cached,279,tree/treeplayer/src/TRefProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TRefProxy.cxx,1,['cache'],['cached']
Performance,/** opaque reference to a loaded object module */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:26,load,loaded,26,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['load'],['loaded']
Performance,"/*** \class TDLGradientDescent; *; * Generic implementation of gradient descent minimization for the; * deep learning neural nets.; *; * The TDLGradientDescent class implements an architecture, input data and; * deep learning neural network type independent implementation of the gradient; * descent minimization algorithm.; *; * This is provided by the Step(...), StepMomentum(...) and; * StepNesterov(...) functions that perform a single minimization step.; *; * The main training characteristics are defined by the provided learning rate,; * the test interval, and the convergence steps required for convergence. The; * test interval defines how often the error on the validation set is computed,; * and the values with which the step counter is increased each time the; * HasConverged() member function is called. A convergence step is defined as; * a step in which the test error is NOT less than 0.999 times the current; * minimal test error that has been reached. If between two subsequent calls; * to HasConverged(Double_t) the test error has not been sufficiently reduced; * it is assumed that a number of convergence steps equal to the test interval; * has been performed.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DLMinimizers.h:423,perform,perform,423,tmva/tmva/inc/TMVA/DNN/DLMinimizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DLMinimizers.h,2,['perform'],"['perform', 'performed']"
Performance,/*** state needed to cache single-contour polygons for renderCache() */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/tess.h:21,cache,cache,21,graf3d/eve7/glu/tess.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/tess.h,1,['cache'],['cache']
Performance,"/******* Streaming *******/; /*; * Streaming functions generate the xxHash value from an incrememtal input.; * This method is slower than single-call functions, due to state management.; * For small inputs, prefer `XXH32()` and `XXH64()`, which are better optimized.; *; * An XXH state must first be allocated using `XXH*_createState()`.; *; * Start a new hash by initializing the state with a seed using `XXH*_reset()`.; *; * Then, feed the hash state by calling `XXH*_update()` as many times as necessary.; *; * The function returns an error code, with 0 meaning OK, and any other value; * meaning there is an error.; *; * Finally, a hash value can be produced anytime, by using `XXH*_digest()`.; * This function returns the nn-bits hash as an int or long long.; *; * It's still possible to continue inserting input into the hash state after a; * digest, and generate new hash values later on by invoking `XXH*_digest()`.; *; * When done, release the state using `XXH*_freeState()`.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:256,optimiz,optimized,256,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['optimiz'],['optimized']
Performance,"/******* Streaming *******/; /*; * Streaming requires state maintenance.; * This operation costs memory and CPU.; * As a consequence, streaming is slower than one-shot hashing.; * For better performance, prefer one-shot functions whenever applicable.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:191,perform,performance,191,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['perform'],['performance']
Performance,"/******* Streaming *******/; /*; * Streaming requires state maintenance.; * This operation costs memory and CPU.; * As a consequence, streaming is slower than one-shot hashing.; * For better performance, prefer one-shot functions whenever applicable.; *; * XXH3_128bits uses the same XXH3_state_t as XXH3_64bits().; * Use already declared XXH3_createState() and XXH3_freeState().; *; * All reset and streaming functions have same meaning as their 64-bit counterpart.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:191,perform,performance,191,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['perform'],['performance']
Performance,/******** Multi-thread tests **********/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx:10,Multi-thread,Multi-thread,10,tree/dataframe/test/dataframe_callbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx,1,['Multi-thread'],['Multi-thread']
Performance,"/************ TEMPLATE FUNCTIONS' IMPLEMENTATIONS *******************/; //////////////////////////////////////////////////////////////////////////; /// Send a message with a code and an object to socket s.; /// The number of bytes sent is returned, as per TSocket::SendRaw.; /// This standalone function can be used to send a code and possibly; /// an object on a given socket. This function does not check whether the; /// socket connection is in a valid state. MPRecv() must be used to; /// retrieve the contents of the message.\n; /// **Note:** only objects the headers of which have been parsed by; /// cling can be sent using MPSend(). User-defined types can be made available to; /// cling via a call like `gSystem->ProcessLine(""#include \""header.h\"""")`.; /// Pointer types cannot be sent via MPSend() (with the exception of const char*).; /// \param s a pointer to a valid TSocket. No validity checks are performed\n; /// \param code the code to be sent; /// \param obj the object to be sent; /// \return the number of bytes sent, as per TSocket::SendRaw",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/inc/MPSendRecv.h:912,perform,performed,912,core/multiproc/inc/MPSendRecv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/inc/MPSendRecv.h,1,['perform'],['performed']
Performance,/************ These tests are run in single- and multi-thread mode (they use TEST_P instead of TEST) ************/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:49,multi-thread,multi-thread,49,tree/dataframe/test/dataframe_vary.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx,1,['multi-thread'],['multi-thread']
Performance,"/*************************** Static local guards ****************************/; /// Emits the guarded initializer and destructor setup for the given; /// variable, given that it couldn't be emitted as a constant.; /// If \p PerformInit is false, the initialization has been folded to a; /// constant and should not be performed.; ///; /// The variable may be:; /// - a static local variable; /// - a static data member of a class template instantiation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:224,Perform,PerformInit,224,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,2,"['Perform', 'perform']","['PerformInit', 'performed']"
Performance,"/*************************** thread_local initialization ********************/; /// Emits ABI-required functions necessary to initialize thread_local; /// variables in this translation unit.; ///; /// \param CXXThreadLocals - The thread_local declarations in this translation; /// unit.; /// \param CXXThreadLocalInits - If this translation unit contains any; /// non-constant initialization or non-trivial destruction for; /// thread_local variables, a list of functions to perform the; /// initialization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:475,perform,perform,475,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,1,['perform'],['perform']
Performance,"/**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : CCTreeWrapper *; * *; * *; * Description: a light wrapper of a decision tree, used to perform cost *; * complexity pruning ""in-place"" Cost Complexity Pruning *; * *; * Author: Doug Schouten (dschoute@sfu.ca) *; * *; * *; * Copyright (c) 2007: *; * CERN, Switzerland *; * MPI-K Heidelberg, Germany *; * U. of Texas at Austin, USA *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/CCTreeWrapper.h:278,perform,perform,278,tmva/tmva/inc/TMVA/CCTreeWrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/CCTreeWrapper.h,1,['perform'],['perform']
Performance,"/**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : CCTreeWrapper *; * *; * *; * Description: a light wrapper of a decision tree, used to perform cost *; * complexity pruning ""in-place"" Cost Complexity Pruning *; * *; * Author: Doug Schouten (dschoute@sfu.ca) *; * *; * *; * Copyright (c) 2007: *; * CERN, Switzerland *; * MPI-K Heidelberg, Germany *; * U. of Texas at Austin, USA *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; /*! \class TMVA::CCTreeWrapper; \ingroup TMVA. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/CCTreeWrapper.cxx:278,perform,perform,278,tmva/tmva/src/CCTreeWrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/CCTreeWrapper.cxx,1,['perform'],['perform']
Performance,"/**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : OptimizeConfigParameters *; * *; * *; * Description: The OptimizeConfigParameters takes care of ""scanning/fitting"" *; * different tuning parameters in order to find the best set of *; * tuning paraemters which will be used in the end *; * *; * Authors (alphabetical): *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * *; * Copyright (c) 2005: *; * CERN, Switzerland *; * MPI-K Heidelberg, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (http://ttmva.sourceforge.net/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/OptimizeConfigParameters.h:192,Optimiz,OptimizeConfigParameters,192,tmva/tmva/inc/TMVA/OptimizeConfigParameters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/OptimizeConfigParameters.h,2,['Optimiz'],['OptimizeConfigParameters']
Performance,"/**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : OptimizeConfigParameters *; * *; * *; * Description: The OptimizeConfigParameters takes care of ""scanning/fitting"" *; * different tuning parameters in order to find the best set of *; * tuning paraemters which will be used in the end *; * *; * Authors (alphabetical): *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * *; * Copyright (c) 2005: *; * CERN, Switzerland *; * MPI-K Heidelberg, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (http://ttmva.sourceforge.net/LICENSE) *; **********************************************************************************/; /*! \class TMVA::OptimizeConfigParameters; \ingroup TMVA. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/OptimizeConfigParameters.cxx:192,Optimiz,OptimizeConfigParameters,192,tmva/tmva/src/OptimizeConfigParameters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/OptimizeConfigParameters.cxx,3,['Optimiz'],['OptimizeConfigParameters']
Performance,/*******************************************************************************/; /* detail loading functions : 												 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/xcf.c:93,load,loading,93,graf2d/asimage/src/libAfterImage/xcf.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/xcf.c,1,['load'],['loading']
Performance,"/*******************************************************************************; * Advanced dictionary and prefix API; *; * This API allows dictionaries to be used with ZSTD_compress2(),; * ZSTD_compressStream2(), and ZSTD_decompress(). Dictionaries are sticky, and; * only reset with the context is reset with ZSTD_reset_parameters or; * ZSTD_reset_session_and_parameters. Prefixes are single-use.; ******************************************************************************/; /*! ZSTD_CCtx_loadDictionary() :; * Create an internal CDict from `dict` buffer.; * Decompression will have to use same dictionary.; * @result : 0, or an error code (which can be tested with ZSTD_isError()).; * Special: Loading a NULL (or 0-size) dictionary invalidates previous dictionary,; * meaning ""return to no-dictionary mode"".; * Note 1 : Dictionary is sticky, it will be used for all future compressed frames.; * To return to ""no-dictionary"" situation, load a NULL dictionary (or reset parameters).; * Note 2 : Loading a dictionary involves building tables.; * It's also a CPU consuming operation, with non-negligible impact on latency.; * Tables are dependent on compression parameters, and for this reason,; * compression parameters can no longer be changed after loading a dictionary.; * Note 3 :`dict` content will be copied internally.; * Use experimental ZSTD_CCtx_loadDictionary_byReference() to reference content instead.; * In such a case, dictionary buffer must outlive its users.; * Note 4 : Use ZSTD_CCtx_loadDictionary_advanced(); * to precisely select how dictionary content must be interpreted. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:702,Load,Loading,702,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,5,"['Load', 'latency', 'load']","['Loading', 'latency', 'load', 'loading']"
Performance,"/*******************************************************************************; Introduction. zstd, short for Zstandard, is a fast lossless compression algorithm, targeting; real-time compression scenarios at zlib-level and better compression ratios.; The zstd compression library provides in-memory compression and decompression; functions. The library supports regular compression levels from 1 up to ZSTD_maxCLevel(),; which is currently 22. Levels >= 20, labeled `--ultra`, should be used with; caution, as they require more memory. The library also offers negative; compression levels, which extend the range of speed vs. ratio preferences.; The lower the level, the faster the speed (at the cost of compression). Compression can be done in:; - a single step (described as Simple API); - a single step, reusing a context (described as Explicit context); - unbounded multiple steps (described as Streaming compression). The compression ratio achievable on small data can be highly improved using; a dictionary. Dictionary compression can be performed in:; - a single step (described as Simple dictionary API); - a single step, reusing a dictionary (described as Bulk-processing; dictionary API). Advanced experimental functions can be accessed using; `#define ZSTD_STATIC_LINKING_ONLY` before including zstd.h. Advanced experimental APIs should never be used with a dynamically-linked; library. They are not ""stable""; their definitions or signatures may change in; the future. Only static linking is allowed.; *******************************************************************************/; /*------ Version ------*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:1047,perform,performed,1047,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['perform'],['performed']
Performance,/******************************************************************************/; /* Loading ASTs/source. */; /******************************************************************************/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:85,Load,Loading,85,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,1,['Load'],['Loading']
Performance,"/******************************************************************************/; // Missing primary vertex class.; /******************************************************************************/; /******************************************************************************/; /******************************************************************************/; // This whole construction is somewhat doubtable. It requires; // shameless copying of experiment data. What is good about this; // scheme:; //; // 1) Filters can be applied at copy time so that only part of the; // data is copied over.; //; // 2) Once the data is extracted it can be used without experiment; // software. Thus, external service can provide this data and local; // client can be really thin.; //; // 3) Some pretty advanced visualization schemes/selections can be; // implemented in a general framework by providing data extractors; // only. This is also good for PR or VIP displays.; //; // 4) These classes can be extended by particular implementations. The; // container classes will use TClonesArray with user-specified element; // class.; // The common behaviour could be implemented entirely without usage of; // a common base classes, by just specifying names of members that; // retrieve specific data. This is fine as long as one only uses tree; // selections but becomes painful for extraction of data into local; // structures (could a) use interpreter but this is an overkill and; // would cause serious trouble for multi-threaded environment; b) use; // member offsets and data-types from the dictionary).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveVSDStructs.h:1507,multi-thread,multi-threaded,1507,graf3d/eve/inc/TEveVSDStructs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveVSDStructs.h,1,['multi-thread'],['multi-threaded']
Performance,"/******************************************************************************; Copyright (c) Microsoft Corporation. Permission to use, copy, modify, and/or distribute this software for any; purpose with or without fee is hereby granted. THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH; REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY; AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,; INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM; LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR; OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR; PERFORMANCE OF THIS SOFTWARE.; ***************************************************************************** */; /* global Reflect, Promise */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/base/svg2pdf.mjs:701,PERFORM,PERFORMANCE,701,js/modules/base/svg2pdf.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/base/svg2pdf.mjs,1,['PERFORM'],['PERFORMANCE']
Performance,"/*****************************************************************************; * Project: RooFit *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooAbsCachedPdf.cxx; \class RooAbsCachedPdf; \ingroup Roofitcore. Abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:638,cache,cache,638,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,4,['cache'],"['cache', 'cached']"
Performance,"/*****************************************************************************; * Project: RooFit *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooAbsCachedReal.cxx; \class RooAbsCachedReal; \ingroup Roofitcore. Abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx:642,cache,cache,642,roofit/roofitcore/src/RooAbsCachedReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx,4,['cache'],"['cache', 'cached']"
Performance,"/*****************************************************************************; * Project: RooFit *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooCachedPdf.cxx; \class RooCachedPdf; \ingroup Roofitcore. Implementation of RooAbsCachedPdf that can cache; any external RooAbsPdf input function provided in the constructor.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedPdf.cxx:621,cache,cache,621,roofit/roofitcore/src/RooCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedPdf.cxx,1,['cache'],['cache']
Performance,"/*****************************************************************************; * Project: RooFit *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooCachedReal.cxx; \class RooCachedReal; \ingroup Roofitcore. Implementation of RooAbsCachedReal that can cache; any external RooAbsReal input function provided in the constructor.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedReal.cxx:624,cache,cache,624,roofit/roofitcore/src/RooCachedReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedReal.cxx,1,['cache'],['cache']
Performance,"/*****************************************************************************; * Project: RooFit *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooNumRunningInt.cxx; \class RooNumRunningInt; \ingroup Roofitcore. Implementation of RooAbsCachedReal that represents a running integral; \f[ RI(f(x)) = \int_{xlow}^{x} f(x') dx' \f]; that is calculated internally with a numeric technique: The input function; is first sampled into a histogram, which is then numerically integrated.; The output function is an interpolated version of the integrated histogram.; The sampling density is controlled by the binning named ""cache"" in the observable x.; The shape of the p.d.f is always calculated for the entire domain in x and; cached in a histogram. The cache histogram is automatically recalculated; when any of the parameters of the input p.d.f. has changed.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx:987,cache,cache,987,roofit/roofitcore/src/RooNumRunningInt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx,3,['cache'],"['cache', 'cached']"
Performance,"/*****************************************************************************; * Project: RooFit *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooProjectedPdf.cxx; \class RooProjectedPdf; \ingroup Roofitcore. A RooAbsPdf implementation that represent a projection; of a given input p.d.f and the object returned by RooAbsPdf::createProjection.; The actual projection integral for it value and normalization are; calculated on the fly in getVal() once the normalization observables are known.; Class RooProjectedPdf can cache projected p.d.f.s for multiple normalization; observables simultaneously.; The createProjection() method of RooProjectedPdf is overloaded and will; return a new RooProjectedPdf that performs the projection of itself; and the requested additional projections in one integration step; The performance of <pre>f->createProjection(x)->createProjection(y)</pre>; is therefore identical to that of <pre>f->createProjection(RooArgSet(x,y))</pre>; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProjectedPdf.cxx:894,cache,cache,894,roofit/roofitcore/src/RooProjectedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProjectedPdf.cxx,3,"['cache', 'perform']","['cache', 'performance', 'performs']"
Performance,"/*****************************************************************************; * Project: RooFit *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; //////////////////////////////////////////////////////////////////////////////; /// \class RooFFTConvPdf; /// \ingroup Roofitcore; ///; /// This class implements a generic one-dimensional numeric convolution of two PDFs,; /// and can convolve any two RooAbsPdfs. The class exploits the convolution theorem; /// \f[; /// f(x) * g(x) \rightarrow F(k_i) \cdot G(k_i); /// \f]; /// to calculate the convolution by calculating a Real->Complex FFT of both input PDFs,; /// multiplying the complex coefficients and performing the reverse Complex->Real FFT; /// to get the result in the input space. This class uses the ROOT FFT interface to; /// the (free) FFTW3 package (www.fftw.org), and requires that your ROOT installation is; /// compiled with the `fftw3=ON` (default). Instructions for manually installing fftw below.; ///; /// Note that the performance in terms of speed and stability of RooFFTConvPdf is; /// vastly superior to that of RooNumConvPdf.; ///; /// An important feature of FFT convolutions is that the observable is assumed to be; /// cyclical. This is correct for cyclical observables such as angles,; /// but does not hold in general. For non-cyclical variables, wrap-around artifacts may be; /// encountered, *e.g.* if the PDF is zero at xMin and non-zero at xMax. A rising tail may appear at xMin.; /// This is inevitable when using FFTs. A distribution with 3 bins therefore looks like:; /// ```; /// ... 0 1 2 0 1 2 0 1 2 ...; /// ```; ///; /// Therefore, if bins 0 and 2 ar",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:1015,perform,performing,1015,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['perform'],['performing']
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooAbsFunc.cxx; \class RooAbsFunc; \ingroup Roofitcore. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsFunc.cxx:845,perform,performing,845,roofit/roofitcore/src/RooAbsFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsFunc.cxx,1,['perform'],['performing']
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooAbsMCStudyModule.cxx; \class RooAbsMCStudyModule; \ingroup Roofitcore. Base class for add-on modules to RooMCStudy that; can perform additional calculations on each generate+fit cycle managed; by RooMCStudy. This class can insert code to be executed before each generation step,; between the generation and fitting step and after the fitting step.; Any summary output variables declared in the RooDataSet exported through; summaryData() is merged with the 'master' summary dataset in RooMCStudy. Look at RooDLLSignificanceMCSModule for an example of an implementation.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMCStudyModule.cxx:834,perform,perform,834,roofit/roofitcore/src/RooAbsMCStudyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMCStudyModule.cxx,1,['perform'],['perform']
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooAbsOptTestStatistic.cxx; \class RooAbsOptTestStatistic; \ingroup Roofitcore. Abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities. Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result. Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx:930,optimiz,optimizations,930,roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,1,['optimiz'],['optimizations']
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooAbsTestStatistic.cxx; \class RooAbsTestStatistic; \ingroup Roofitcore. Abstract base class for all test; statistics. Test statistics that evaluate the PDF at each data; point should inherit from the RooAbsOptTestStatistic class which; implements several generic optimizations that can be done for such; quantities. This test statistic base class organizes calculation of test; statistic values for RooSimultaneous PDF as a combination of test; statistic values for the PDF components of the simultaneous PDF and; organizes multi-processor parallel calculation of test statistic; values. For the latter, the test statistic value is calculated in; partitions in parallel executing processes and a posteriori; combined in the main thread.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsTestStatistic.cxx:971,optimiz,optimizations,971,roofit/roofitcore/src/RooAbsTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsTestStatistic.cxx,1,['optimiz'],['optimizations']
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooCacheManager.cxx; \class RooCacheManager; \ingroup Roofitcore. Manages the storage of any type of data indexed on; the choice of normalization and optionally the set of integrated observables.; The purpose of this class is to facilitate storage of intermediate results; in operator p.d.f.s whose value and inner working are often highly dependent; on the user provided choice of normalization in getVal(). For efficiency reasons these normalization set pointer are; dereferenced as little as possible. This class contains a lookup; table for RooArgSet pointer pairs -> normalization lists. Distinct; pointer pairs that represent the same normalization/projection are; recognized and will all point to the same normalization list. Lists; for up to 'maxSize' different normalization/ projection; configurations can be cached.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCacheManager.cxx:1525,cache,cached,1525,roofit/roofitcore/src/RooCacheManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCacheManager.cxx,1,['cache'],['cached']
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooChangeTracker.cxx; \class RooChangeTracker; \ingroup Roofitcore. Meta object that tracks value; changes in a given set of RooAbsArgs by registering itself as value; client of these objects. The change tracker can perform an; additional validation step where it also compares the numeric; values of the tracked arguments with reference values to ensure; that values have actually changed. This may be useful in case some; of the tracked observables are in binned datasets where each; observable propagates a valueDirty flag when an event is loaded even; though usually only one observable actually changes.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooChangeTracker.cxx:922,perform,perform,922,roofit/roofitcore/src/RooChangeTracker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooChangeTracker.cxx,2,"['load', 'perform']","['loaded', 'perform']"
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooDataProjBinding.cxx; \class RooDataProjBinding; \ingroup Roofitcore. adaptor that projects a real function via summation of states; provided in a dataset. The real function must be attached to the; dataset before creating this binding object. If the dataset only contains category variables, the summation is optimized; performing a weighted sum over the states of a RooSuperCategory that is; constructed from all the categories in the dataset. **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataProjBinding.cxx:1018,optimiz,optimized,1018,roofit/roofitcore/src/RooDataProjBinding.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataProjBinding.cxx,2,"['optimiz', 'perform']","['optimized', 'performing']"
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooErrorVar.cxx; \class RooErrorVar; \ingroup Roofitcore. Auxiliary class that represents the error; of a RooRealVar as a separate object. The main reason of; existence of this class is to facilitate the reuse of existing; techniques to perform calculations that involve a RooRealVars; error, such as calculating the pull value.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooErrorVar.cxx:943,perform,perform,943,roofit/roofitcore/src/RooErrorVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooErrorVar.cxx,1,['perform'],['perform']
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooGenericPdf.cxx; \class RooGenericPdf; \ingroup Roofitcore. Implementation of a probability density function; that takes a RooArgList of servers and a C++ expression string defining how; its value should be calculated from the given list of servers.; A fully numerical integration is automatically performed to normalize the given; expression. RooGenericPdf uses a RooFormula object to perform the expression evaluation. The string expression can be any valid TFormula expression referring to the; listed servers either by name or by their ordinal list position. These three are; equivalent:; ```; RooFormulaVar(""gen"", ""x*y"", RooArgList(x,y)) // reference by name; RooFormulaVar(""gen"", ""@0*@1"", RooArgList(x,y)) // reference by ordinal with @; RooFormulaVar(""gen"", ""x[0]*x[1]"", RooArgList(x,y)) // TFormula-builtin reference by ordinal; ```; Note that `x[i]` is an expression reserved for TFormula. All variable references; are automatically converted to the TFormula-native format. If a variable with; the name `x` is given, the RooFormula interprets `x[i]` as a list position,; but `x` without brackets as the name of a RooFit object. The last two versions, while slightly less readable, are more versatile because; the names of the arguments are not hard coded.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenericPdf.cxx:1006,perform,performed,1006,roofit/roofitcore/src/RooGenericPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenericPdf.cxx,2,['perform'],"['perform', 'performed']"
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooNormSetCache.cxx; \class RooNormSetCache; \ingroup Roofitcore. Class RooNormSet cache manage the bookkeeping of multiple instances; of sets of integration and normalization observables that effectively; have the same definition. In complex function expression many; RooArgSets with the same contents may be passed to an object that; caches intermediate results dependent on the normalization/integration set; To avoid unnecessary cache faulting, This class tracks all instances; with the same contents and reports to the owner if the present nset/iset; is truly different from the current reference. Class RooNormSet only; evaluates each RooArgSet pointer once, it therefore assumes that; RooArgSets with normalization and/or integration sets are not changes; during their lifetime.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNormSetCache.cxx:789,cache,cache,789,roofit/roofitcore/src/RooNormSetCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNormSetCache.cxx,3,['cache'],"['cache', 'caches']"
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooNumGenFactory.cxx; \class RooNumGenFactory; \ingroup Roofitcore. %Factory to instantiate numeric integrators; from a given function binding and a given configuration. The factory; searches for a numeric integrator registered with the factory that; has the ability to perform the numeric integration. The choice of; method may depend on the number of dimensions integrated,; the nature of the integration limits (closed or open ended) and; the preference of the caller as encoded in the configuration object.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumGenFactory.cxx:976,perform,perform,976,roofit/roofitcore/src/RooNumGenFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumGenFactory.cxx,1,['perform'],['perform']
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooNumIntFactory.cxx; \class RooNumIntFactory; \ingroup Roofitcore. %Factory to instantiate numeric integrators; from a given function binding and a given configuration. The factory; searches for a numeric integrator registered with the factory that; has the ability to perform the numeric integration. The choice of; method may depend on the number of dimensions integrated,; the nature of the integration limits (closed or open ended) and; the preference of the caller as encoded in the configuration object.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumIntFactory.cxx:976,perform,perform,976,roofit/roofitcore/src/RooNumIntFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumIntFactory.cxx,1,['perform'],['perform']
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooObjCacheManager.cxx; \class RooObjCacheManager; \ingroup Roofitcore. Implementation of a RooCacheManager<RooAbsCacheElement>; that specializes in the storage of cache elements that contain RooAbsArg objects.; Caches with RooAbsArg derived payload require special care as server redirects; cache operation mode changes and constant term optimization calls may need to be; forwarded to such cache payload. This cache manager takes care of all these operations; by forwarding these calls to the RooAbsCacheElement interface functions, which; have a sensible default implementation.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooObjCacheManager.cxx:870,cache,cache,870,roofit/roofitcore/src/RooObjCacheManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooObjCacheManager.cxx,6,"['Cache', 'cache', 'optimiz']","['Caches', 'cache', 'optimization']"
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooRealIntegral.cxx; \class RooRealIntegral; \ingroup Roofitcore. Performs hybrid numerical/analytical integrals of RooAbsReal objects.; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implementations of the RooAbsIntegrator base class.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:772,Perform,Performs,772,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,3,"['Perform', 'perform']","['Performs', 'performed', 'performs']"
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooVectorDataStore.cxx; \class RooVectorDataStore; \ingroup Roofitcore. Uses `std::vector` to store data columns. Each of these vectors; is associated to an instance of a RooAbsReal, whose values it represents. Those; RooAbsReal are the observables of the dataset.; In addition to the observables, a data column can be bound to a different instance; of a RooAbsReal (e.g., the column ""x"" can be bound to the observable ""x"" of a computation; graph using attachBuffers()). In this case, a get() operation writes the value of; the requested column into the bound real. As a faster alternative to loading values one-by-one, one can use the function getBatches(),; which returns spans pointing directly to the data.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooVectorDataStore.cxx:1299,load,loading,1299,roofit/roofitcore/src/RooVectorDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooVectorDataStore.cxx,1,['load'],['loading']
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; //////////////////////////////////////////////////////////////////////////////; /// \class RooAddModel; ///; /// RooAddModel is an efficient implementation of a sum of PDFs of the form; /// \f[; /// c_1 \cdot \mathrm{PDF}_1 + c_2 \cdot \mathrm{PDF}_2 + ... + c_n \cdot \mathrm{PDF}_n; /// \f]; /// or; /// \f[; /// c_1 \cdot \mathrm{PDF}_1 + c_2 \cdot \mathrm{PDF}_2 + ... + \left( 1-\sum_{i=1}^{n-1} c_i \right) \cdot \mathrm{PDF}_n; /// \f]; /// The first form is for extended likelihood fits, where the; /// expected number of events is \f$ \sum_i c_i \f$. The coefficients \f$ c_i \f$; /// can either be explicitly provided, or, if all components support; /// extended likelihood fits, they can be calculated from the contribution; /// of each PDF to the total number of expected events.; ///; /// In the second form, the sum of the coefficients is enforced to be one,; /// and the coefficient of the last PDF is calculated from that condition.; ///; /// RooAddModel relies on each component PDF to be normalized, and will perform; /// no normalization other than calculating the proper last coefficient \f$ c_n \f$, if requested.; /// An (enforced) condition for this assumption is that each \f$ \mathrm{PDF}_i \f$ is independent; /// of each coefficient \f$ i \f$.; ///; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx:1722,perform,perform,1722,roofit/roofitcore/src/RooAddModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx,1,['perform'],['perform']
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; //////////////////////////////////////////////////////////////////////////////; /// \class RooLinearVar; /// RooLinearVar is the most general form of a derived real-valued object that can; /// be used by RooRealIntegral to integrate over. The requirements for this are; /// * Can be modified directly (i.e. invertible formula); /// * Jacobian term in integral is constant (but not necessarily 1); ///; /// This class implements the most general form that satisfies these requirements; /// \f[; /// RLV = \mathrm{slope} \cdot x + \mathrm{offset}; /// \f]; /// \f$ x \f$ is required to be a RooRealVar to meet the invertibility criterium,; /// `slope` and `offset` are RooAbsReals, but cannot overlap with \f$ x \f$,; /// *i.e.*, \f$ x \f$ may not be a server of `slope` and `offset`.; ///; /// In the context of a dataset, `slope` may not contain any real-valued dependents; /// (to satisfyt the constant Jacobian requirement). This check cannot be enforced at; /// construction time, but can be performed at run time through the isJacobianOK(depList); /// member function.; ///; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinearVar.cxx:1690,perform,performed,1690,roofit/roofitcore/src/RooLinearVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinearVar.cxx,1,['perform'],['performed']
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * AL, Alfio Lazzaro, INFN Milan, alfio.lazzaro@mi.infn.it *; * PB, Patrick Bos, NL eScience Center, p.bos@esciencecenter.nl *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooMinimizer.cxx; \class RooMinimizer; \ingroup Roofitcore. Wrapper class around ROOT::Math::Minimizer that; provides a seamless interface between the minimizer functionality; and the native RooFit interface.; By default the Minimizer is Minuit 2.; RooMinimizer can minimize any RooAbsReal function with respect to; its parameters. Usual choices for minimization are the object returned by; RooAbsPdf::createNLL() or RooAbsReal::createChi2().; RooMinimizer has methods corresponding to MINUIT functions like; hesse(), migrad(), minos() etc. In each of these function calls; the state of the MINUIT engine is synchronized with the state; of the RooFit variables: any change in variables, change; in the constant status etc is forwarded to MINUIT prior to; execution of the MINUIT call. Afterwards the RooFit objects; are resynchronized with the output state of MINUIT: changes; parameter values, errors are propagated.; Various methods are available to control verbosity, profiling,; automatic PDF optimization.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizer.cxx:1704,optimiz,optimization,1704,roofit/roofitcore/src/RooMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizer.cxx,1,['optimiz'],['optimization']
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * File: $Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooAbsCache.cxx; \class RooAbsCache; \ingroup Roofitcore. Abstract base class for data members of RooAbsArgs; that cache other (composite) RooAbsArg expressions. The RooAbsCache; interface defines the interaction between the owning RooAbsArg object; and the cache data member to communicate server redirects, operation; mode changes and constant term optimization management calls.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCache.cxx:807,cache,cache,807,roofit/roofitcore/src/RooAbsCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCache.cxx,3,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * File: $Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooAbsCacheElement.cxx; \class RooAbsCacheElement; \ingroup Roofitcore. Abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCacheElement.cxx:825,cache,cache,825,roofit/roofitcore/src/RooAbsCacheElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCacheElement.cxx,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"/****************************************************************************; *; * Find the specified icon file somewhere along the given path.; *; * There is a possible race condition here: We check the file and later; * do something with it. By then, the file might not be accessible.; * Oh well.; *; ****************************************************************************/; /* supposedly pathlist should not include any environment variables; including things like ~/; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterbase.c:171,race condition,race condition,171,graf2d/asimage/src/libAfterImage/afterbase.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterbase.c,1,['race condition'],['race condition']
Performance,"/**************************************************************************/; // Display-list cache; /**************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; /// Modify capture of draws into display list cache kTRUE - capture,; /// kFALSE direct draw. Return kTRUE is state changed, kFALSE if not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx:94,cache,cache,94,graf3d/gl/src/TGLLogicalShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx,2,['cache'],['cache']
Performance,"/**************************************************************************/; // High-level functions: drawing and picking.; /**************************************************************************/; //______________________________________________________________________; //void TGLViewerBase::Select(Int_t selX, Int_t selY, Int_t selRadius); //{; // Perform render-pass in selection mode.; // Process the selection results.; // For now only in derived classes.; //}; ////////////////////////////////////////////////////////////////////////////////; /// Process selection record on buffer-position 'recIdx' and; /// fill the data into 'rec'.; ///; /// Returns TRUE if scene was demangled and an object identified.; /// When FALSE is returned it is still possible that scene has been; /// identified. Check for this if interested in scene-selection.; ///; /// The select-buffer is taken form fRnrCtx.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewerBase.cxx:356,Perform,Perform,356,graf3d/gl/src/TGLViewerBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewerBase.cxx,1,['Perform'],['Perform']
Performance,"/**************************************************************************/; // Rendering; /**************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; /// Perform basic pre-render initialization:; /// - calculate LOD, Style, Clipping,; /// - build draw lists.; ///; /// This is called in the beginning of the GL-viewer draw cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLSceneBase.cxx:256,Perform,Perform,256,graf3d/gl/src/TGLSceneBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLSceneBase.cxx,1,['Perform'],['Perform']
Performance,"/**************************************************************************/; // Smart refresh; /**************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; /// Moves logicals that support smart-refresh to intermediate cache.; /// Destroys the others and returns the number of destroyed ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx:318,cache,cache,318,graf3d/gl/src/TGLScene.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx,1,['cache'],['cache']
Performance,/*************************************************************; * gdk_event_queue_append:; * Append an event onto the tail of the event queue.; * arguments:; * event: Event to append.; * results:; *************************************************************/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkevents.c:136,queue,queue,136,graf2d/win32gdk/gdk/src/gdk/gdkevents.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkevents.c,1,['queue'],['queue']
Performance,/*************************************************************; * gdk_event_queue_remove_link:; * Remove a specified list node from the event queue.; * arguments:; * node: Node to remove.; * results:; *************************************************************/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkevents.c:142,queue,queue,142,graf2d/win32gdk/gdk/src/gdk/gdkevents.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkevents.c,1,['queue'],['queue']
Performance,"/*********************************************; * Functions for maintaining the event queue *; *********************************************/; /*************************************************************; * gdk_event_queue_find_first:; * Find the first event on the queue that is not still; * being filled in.; * arguments:; * ; * results:; * Pointer to the list node for that event, or NULL; *************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkevents.c:86,queue,queue,86,graf2d/win32gdk/gdk/src/gdk/gdkevents.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkevents.c,2,['queue'],['queue']
Performance,"/********************************; * Dictionary helper functions; *******************************/; /*! ZSTD_getDictID_fromDict() :; * Provides the dictID stored within dictionary.; * if @return == 0, the dictionary is not conformant with Zstandard specification.; * It can still be loaded, but as a content-only dictionary. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:283,load,loaded,283,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['load'],['loaded']
Performance,"/********************; * Color allocation *; ********************/; /* Try to allocate a single color using alloc_color. If it succeeds,; * cache the result in our colormap, and store in ret.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c:140,cache,cache,140,graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcolor-win32.c,1,['cache'],['cache']
Performance,"/*************/; /****f* libAfterImage/asfont/create_font_manager(); * NAME; * create_font_manager(); * SYNOPSIS; * ASFontManager *create_font_manager( Display *dpy,; * const char *font_path,; * ASFontManager *reusable_memory );; * INPUTS; * dpy - pointer to valid and opened Display.; * font_path - string, representing colon separated list of; * directories to search for FreeType fonts.; * reusable_memory - optional preallocated memory for the ASFontMagaer; * object; * RETURN VALUE; * Pointer to Initialized ASFontManager object on success.; * NULL otherwise.; * DESCRIPTION; * create_font_manager() will create new ASFontManager structure if; * needed. It wioll then store copy of font_path and supplied pointer to; * Display in it. At that time Hash table of loaded fonts is initialized,; * and if needed FreeType library is initialized as well.; * ASFontManager object returned by this functions has to be open at all; * times untill text drawing is no longer needed.; *********/; /****f* libAfterImage/asfont/destroy_font_manager(); * NAME; * destroy_font_manager(); * SYNOPSIS; * void destroy_font_manager( ASFontManager *fontman,; * Bool reusable );; * INPUTS; * fontman - pointer to valid ASFontManager object to be deallocated.; * reusable - If True, then memory holding object itself will not be; * freed - only resources will be deallocated. That is; * usefull for structures created on stack.; * DESCRIPTION; * destroy_font_manager() closes all the fonts open with this; * ASFontManager. It will also close connection to FreeType library, and; * deallocate all cached data. If reusable is False - then memory used; * for object itself will not be freed.; *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h:766,load,loaded,766,graf2d/asimage/src/libAfterImage/asfont.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h,2,"['cache', 'load']","['cached', 'loaded']"
Performance,"/*************/; /****s* libAfterImage/ASFontManager; * NAME; * ASFontManager; * DESCRIPTION; * Global data identifying connection to external libraries, as well as; * fonts location paths.; * This structure has to be created/initialized prior to any font being; * loaded.; * It also holds list of fonts that are currently open, allowing for; * easy access to fonts.; * When ASFontManagaer object is destroyd it automagically closes all; * the open fonts.; * SOURCE; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h:265,load,loaded,265,graf2d/asimage/src/libAfterImage/asfont.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h,1,['load'],['loaded']
Performance,/*************/; /****s* libAfterImage/ASImageListEntry; * NAME; * ASImageListEntry - entry in linked list of images loaded from single ; * directory.; * SOURCE; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h:117,load,loaded,117,graf2d/asimage/src/libAfterImage/import.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h,1,['load'],['loaded']
Performance,"/********/; /****d* libAfterImage/asimage/quality; * FUNCTION; * Defines level of output quality/speed ratio; * NAME; * ASIMAGE_QUALITY_POOR there will be no dithering and interpolation used ; * while transforming ; * NAME; * ASIMAGE_QUALITY_FAST there will be no dithering and used while ; * transforming but interpolation will be used.; * NAME; * ASIMAGE_QUALITY_GOOD simplified dithering is performed in addition to ; * interpolation.; * NAME; * ASIMAGE_QUALITY_TOP full dithering and interpolation.; * NAME; * ASIMAGE_QUALITY_DEFAULT requests current default setting - typically; * same as ASIMAGE_QUALITY_GOOD.; * NAME; * MAX_GRADIENT_DITHER_LINES defines number of lines to use for dithering,; * while rendering gradients, in order to create smooth effect. Higher ; * number will slow things down, but will create better gradients.; * SOURCE; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/imencdec.h:394,perform,performed,394,graf2d/asimage/src/libAfterImage/imencdec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/imencdec.h,1,['perform'],['performed']
Performance,"/********/; /****d* libAfterImage/asimage/tint; * FUNCTION; * We use 32 bit ARGB values to define how tinting should be done.; * The formula for tinting particular channel data goes like that:; * tinted_data = (image_data * tint)/128; * So if tint channel value is greater then 127 - same channel will be; * brighter in destination image; if it is lower then 127 - same channel; * will be darker in destination image. Tint channel value of 127; * ( or 0x7F hex ) does not change anything.; * Alpha channel is tinted as well, allowing for creation of; * semitransparent images. Calculations are performed in 24.8 format -; * with 8 bit precision. Result is saturated to avoid overflow, and; * precision is carried over to next pixel ( error diffusion ), when con; * verting 24.8 to 8 bit format.; * NAME; * TINT_NONE special value that disables tinting; * NAME; * TINT_LEAVE_SAME also disables tinting.; * SOURCE; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:594,perform,performed,594,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,1,['perform'],['performed']
Performance,/*******/; /****d* libAfterImage/LIMITS; * NAME; * MAX_IMPORT_IMAGE_SIZE	effectively limits size of the allowed; *							images to be loaded from files. That is; * 							needed to be able to filter out corrupt files.; * NAME; * MAX_BEVEL_OUTLINE		Limit on bevel outline to be drawn around; * 							the image.; * NAME; * MAX_SEARCH_PATHS		Number of search paths to be used while loading ; * 							images from files.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:134,load,loaded,134,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,2,['load'],"['loaded', 'loading']"
Performance,"/*******/; /****s* libAfterImage/ASImageDecoder; * NAME; * ASImageDecoder describes the status of reading any particular ASImage,; * as well as providing detail on how it should be done.; * DESCRIPTION; * ASImageDecoder works as an abstraction layer and as the way to; * automate several operations. Most of the transformations in; * libAfterImage are performed as operations on ASScanline data; * structure, that holds all or some of the channels of single image; * scanline. In order to automate data extraction from ASImage into; * ASScanline ASImageDecoder has been designed.; *; * It has following features :; * 1) All missing scanlines, or channels of scanlines will be filled with; * supplied back_color; * 2) It is possible to leave out some channels of the image, extracting; * only subset of channels. It is done by setting only needed flags in; * filter member.; * 3) It is possible to extract sub-image of the image by setting offset_x; * and offset_y to top-left corner of sub-image, out_width - to width of; * the sub-image and calling decode_image_scanline method as many times; * as height of the sub-image.; * 4) It is possible to apply bevel to extracted sub-image, by setting; * bevel member to specific ASImageBevel structure.; *; * Extracted Scanlines will be stored in buffer and it will be updated; * after each call to decode_image_scanline().; * SOURCE; */; /* low level driver (what data to use - native, XImage or ARGB): */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/imencdec.h:352,perform,performed,352,graf2d/asimage/src/libAfterImage/imencdec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/imencdec.h,1,['perform'],['performed']
Performance,/******/; /****s* libAfterImage/ASImageManager; * NAME; * ASImageManager structure to be used to maintain list of loaded images ; * for given set of search paths and gamma. Images are named and reference ; * counted.; * SOURCE; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:114,load,loaded,114,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,1,['load'],['loaded']
Performance,"/****f* libAfterImage/asfont/open_freetype_font(); * NAME; * open_freetype_font(); * SYNOPSIS; * ASFont *open_freetype_font( ASFontManager *fontman,; * const char *font_string,; * int face_no,; * int size, Bool verbose);; * INPUTS; * fontman - pointer to previously created ASFontManager. Needed for; * connection to FreeType library, as well as path to; * search fonts in.; * font_string - filename of the file containing font's data.; * face_no - number of face within the font file; * size - font size in points. Applicable only to scalable fonts,; * such as TrueType.; * verbose - if True, extensive error messages will be printed if; * problems encountered.; * RETURN VALUE; * pointer to Opened ASFont structure, containing all the glyphs of the; * font, as well as other relevant info. On failure returns NULL.; * DESCRIPTION; * open_freetype_font() will attempt to find font file in any of the; * directories specified in ASFontManager's font_path. If it fails to do; * so - then it will check if filename has alldigit extentions. It will; * then try to interpret that extention as a face number, and try and; * find the file with extention stripped off.; * If file was found function will atempt to read it using FreeType; * library. If requested face is not available in the font - face 0 will; * be used.; * On success all the font's glyphs will be rendered and cached, and; * needed font geometry info collected.; * When FreeType Library is not available that function does nothing.; *********/; /****f* libAfterImage/asfont/open_X11_font(); * NAME; * open_X11_font(); * SYNOPSIS; * ASFont *open_X11_font( ASFontManager *fontman,; * const char *font_string);; * INPUTS; * fontman - pointer to previously created ASFontManager. Needed for; * connection X Server.; * font_string - name of the font as recognized by Xlib.; * RETURN VALUE; * pointer to Opened ASFont structure, containing all the glyphs of the; * font, as well as other relevant info. On failure returns NULL.; * DESCRIPTION; *",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h:535,scalab,scalable,535,graf2d/asimage/src/libAfterImage/asfont.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h,1,['scalab'],['scalable']
Performance,"/****f* libAfterImage/asfont/print_asfont(); * NAME; * print_asfont(); * SYNOPSIS; * void print_asfont( FILE* stream,; * ASFont* font);; * INPUTS; * stream - output file pointer; * font - pointer to ASFont structure to print.; * DESCRIPTION; * prints all the geometry information about font.; *********/; /****f* libAfterImage/asfont/print_asglyph(); * NAME; * print_asglyph(); * SYNOPSIS; * void 	print_asglyph( FILE* stream,; * ASFont* font, unsigned long c);; * INPUTS; * stream - output file pointer; * font - pointer to ASFont structure to print.; * c - character code to print glyph for; * DESCRIPTION; * prints out contents of the cached glyph for specifyed character code.; *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h:638,cache,cached,638,graf2d/asimage/src/libAfterImage/asfont.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h,1,['cache'],['cached']
Performance,"/****f* libAfterImage/asimage/create_image_layers(); * NAME ; * create_image_layers() - allocate and initialize set of ASImageLayer's.; * SYNOPSIS; * ASImageLayer *create_image_layers( int count );; * INPUTS; * count - number of ASImageLayer structures in allocated array.; * RETURN VALUE; * Pointer to newly allocated and initialized array of ASImageLayer; * structures on Success. NULL in case of any kind of error - that; * should never happen.; * DESCRIPTION; * Performs memory allocation for the new array of ASImageLayer; * structures, as well as initialization of allocated structure to; * sensible defaults - merge_func will be set to alphablend_scanlines.; *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:466,Perform,Performs,466,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,1,['Perform'],['Performs']
Performance,"/****f* libAfterImage/asimage/create_image_manager(); * NAME; * create_image_manager() create ASImage management and reference ; * counting object.; * SYNOPSIS; * ASImageManager *create_image_manager( ASImageManager *reusable_memory,; * double gamma, ... );; * INPUTS; * reusable_memory - optional pointer to a block of memory to be used to; * store ASImageManager object.; * double gamma - value of gamma correction to be used while loading; * images from files.; * ... - NULL terminated list of up to 8 PATH strings to list; * locations at which images could be found.; * DESCRIPTION; * Creates ASImageManager object in memory and initializes it with; * requested gamma value and PATH list. This Object will contain a hash; * table referencing all the loaded images. When such object is used while; * loading images from the file - gamma and PATH values will be used, so; * that all the loaded and referenced images will have same parameters.; * File name will be used as the image name, and if same file is attempted; * to be loaded again - instead reference will be incremented, and; * previously loaded image will be retyrned. All the images stored in; * ASImageManager's table will contain a back pointer to it, and they must; * be deallocated only by calling release_asimage(). destroy_asimage() will; * refuse to deallocate such an image.; *********/; /****f* libAfterImage/asimage/destroy_image_manager(); * NAME ; * destroy_image_manager() destroy management obejct.; * SYNOPSIS; * void destroy_image_manager( struct ASImageManager *imman, ; * 							 Bool reusable );; * INPUTS; * imman - pointer to ASImageManager object to be deallocated; * reusable - if True, then memory that holds object itself will; * not be deallocated. Usefull when object is created; * on stack.; * DESCRIPTION; * Destroys all the referenced images, PATH values and if reusable is False,; * also deallocates object's memory.; *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:434,load,loading,434,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,6,['load'],"['loaded', 'loading']"
Performance,"/****f* libAfterImage/hsv2rgb(); * NAME; * hsv2rgb(); * NAME; * hls2rgb(); * SYNOPSIS; * void hsv2rgb( CARD32 hue, CARD32 saturation, CARD32 value,; * CARD32 *red, CARD32 *green, CARD32 *blue);; * void hls2rgb( CARD32 hue, CARD32 luminance, CARD32 saturation,; * CARD32 *red, CARD32 *green, CARD32 *blue);; * INPUTS; * hue - 32 bit value, 16 lower bits of which represent hue.; * saturation - 32 bit value, 16 lower bits of which represent saturation.; * value - 32 bit value, 16 lower bits of which represent value.; * luminance - 32 bit value, 16 lower bits of which represent luminance.; * RETURN VALUE; * 32bit value pointed to by red, green and blue will be set; * respectively to RGB color channels.; * DESCRIPTION; * This functions performs reverse translation from HSV and HSL to; * RGB color; ****************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.h:739,perform,performs,739,graf2d/asimage/src/libAfterImage/blender.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/blender.h,1,['perform'],['performs']
Performance,"/****f* libAfterImage/import/file2ASImage(); * NAME; * file2ASImage() - load ASImage from file.; * SYNOPSIS; * ASImage *file2ASImage( const char *file, ASFlagType what,; * double gamma,; * unsigned int compression, ... );; * INPUTS; * file - file name with or without directory name; * what - reserved for future use; * gamma - gamma value to be used to correct image; * compression - compression level of the resulting ASImage; * ... - NULL terminated list of strings, representing; * arbitrary number of directories to be searched each.; * RETURN VALUE; * Pointer to ASImage structure holding image data on success.; * NULL on failure; * DESCRIPTION; * file2ASImage will attempt to interpret filename in the following way:; * 1)It will try to find file using unmodified filename in all the; * provided search paths.; * 2)It will attempt to append .gz and then .Z to the filename and; * find such file in all the provided search paths.; * 3)If filename ends with extension consisting of digits only - it will; * attempt to find file with this extension stripped off. On success; * this extension will be used to load subimage from the file with that; * number. Subimages are supported only for XCF, GIF, BMP, ICO and CUR; * files.; * After the file is found file2ASImage() attempts to detect file format,; * and if it is known it will load it into new ASImage structure.; * EXAMPLE; * asview.c: ASView.2; *********/; /****f* libAfterImage/import/get_asimage(); * NAME; * get_asimage() - increment reference counter if file is already loaded,; * or load image from file.; * SYNOPSIS; * ASImage *get_asimage( ASImageManager* imageman, const char *file,; * ASFlagType what, unsigned int compression );; * INPUTS; * imageman - pointer to valid ASVisual structure.; * file - root window ID for the destination screen.; * what - full image file's name with path.; * compression -; * RETURN VALUE; * Pointer to ASImage structure holding image data on success.; * NULL on failure; * DESCRIPTION; * get_asimag",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h:72,load,load,72,graf2d/asimage/src/libAfterImage/import.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h,1,['load'],['load']
Performance,"/****f* libAfterImage/import/file2pixmap(); * NAME; * file2pixmap() - convinience function to load file into X Pixmap.; * SYNOPSIS; * Pixmap file2pixmap( struct ASVisual *asv, Window root,; * const char *realfilename,; * Pixmap *mask_out);; * INPUTS; * asv - pointer to valid ASVisual structure.; * root - root window ID for the destination screen.; * realfilename - full image file's name with path.; * RETURN VALUE; * Pixmap ID of the X Pixmap filled with loaded image. If mask_out is; * not NULL it will point to image mask Pixmap ID if there is an alpha; * channel in image, None otherwise.; * On failure None will be returned.; * DESCRIPTION; * file2pixmap() will attempt to open specified file and autodetect its; * format. If format is known it will load it into ASImage first, and; * then convert it into X Pixmap. In case image has alpha channel -; * mask Pixmap will be produced if mask_out is not NULL.; *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h:94,load,load,94,graf2d/asimage/src/libAfterImage/import.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h,3,['load'],"['load', 'loaded']"
Performance,"/****h* libAfterImage/ascmap.h; * NAME; * ascmap - Defines main structures and function for image quantization.; * DESCRIPTION; * Image quantization is needed primarily in order to be able to export; * images into file, with colormap format, such as GIF and XPM.; * libAfterImage attempts to allocate colorcells to the most used colors,; * and then approximate remaining colors with the closest colorcell.; *; * Since quality of quantization is in reverse proportion to the number; * of colors in original image, libAfterImage allows to set arbitrary; * level of downsampling of the color spectrum in the range of 8 bit per; * channel to 1 bit per channel. Downsampling is performed by simple; * dropping of less significant bits off of color values.; *; * In order to be able to determine closeness of colors, 3-channel RGB; * values are converted into flat 24bit (or less if downsampling is used); * index. That is done by intermixing bits from different channels, like; * so : R8G8B8R7G7B7...R1G1B1. That flat index is used to arrange colors; * in ascending order, and later on to be able to find closest mapped; * color. Simple hashing technique is used to speed up the; * sorting/searching, as it allows to limit linked lists traversals.; *; * SEE ALSO; * Structures :; * ASColormapEntry; * ASColormap; *; * Functions :; * colormap_asimage(), destroy_colormap(); *; * Other libAfterImage modules :; * ascmap.h asfont.h asimage.h asvisual.h blender.h export.h; * import.h transform.h ximage.h; * AUTHOR; * Sasha Vasko <sasha at aftercode dot net>; *******/; /***********************************************************************************/; /* reduced colormap building code : */; /***********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ascmap.h:673,perform,performed,673,graf2d/asimage/src/libAfterImage/ascmap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ascmap.h,1,['perform'],['performed']
Performance,"/****h* libAfterImage/asfont.h; * NAME; * asfont; * DESCRIPTION; * Text drawing functionality.; * Text is drawn as an ASImage with only alpha channel. Since alpha; * channel is 8 bit widths that allows for 256 shades to be used in; * rendered glyphs. That in turn allows for smoothing and antialiasing; * of the drawn text. Such an approcah allows for easy manipulation of; * the drawn text, such as changing color, making it transparent,; * texturizing, rotation, etc.; *; * libAfterImage supports two types of fonts :; * Fonts that could be rendered using standard Xlib functionality, and; * fonts rendered by FreeType 2 library. That may include TrueType; * fonts. When fonts are obtained via Xlib special processing is; * performed in order to smooth its shape and leverage 256 shades; * palette available.; *; * Any font being used is has to be opened first. At that time its; * properties are analysed and glyphs are cached in clients memory.; * Special RLE compression method is used for font glyphs, significantly; * reducing memory utilization without any effect on performance.; *; * Font management and drawing functionality has been designed with; * internatiolization in mind, althou support for locales is not; * complete yet.; * SEE ALSO; * Structures :; * ASFontManager; * ASFont; * ASGlyph; * ASGlyphRange; *; * Functions :; * create_font_manager(), destroy_font_manager(),; * open_freetype_font(), open_X11_font(), get_asfont(),; * destroy_font(), print_asfont(), print_asglyph(),; * draw_text(),; * get_asfont_glyph_spacing(), set_asfont_glyph_spacing(); *; * Other libAfterImage modules :; * ascmap.h asfont.h asimage.h asvisual.h blender.h export.h; * import.h transform.h ximage.h; * AUTHOR; * Sasha Vasko <sasha at aftercode dot net>; ******************/; /****d* libAfterImage/MAX_GLYPHS_PER_FONT; * NAME; * MAX_GLYPHS_PER_FONT - Max value of glyphs per font allowed. ; * We need that so we can detect and avoid broken fonts somehow.; * SOURCE; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h:726,perform,performed,726,graf2d/asimage/src/libAfterImage/asfont.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h,3,"['cache', 'perform']","['cached', 'performance', 'performed']"
Performance,"/****h* libAfterImage/asimage.h; * NAME; * asimage defines main structures and function for image manipulation.; * DESCRIPTION; * libAfterImage provides powerful functionality to load, store; * and transform images. It allows for smaller memory utilization by; * utilizing run-length encoding of the image data. There could be; * different levels of compression selected, allowing to choose best; * speed/memory ratio.; *; * SEE ALSO; * Structures :; * ASImage; * ASImageManager; * ASImageBevel; * ASImageDecoder; * ASImageOutput; * ASImageLayer; * ASGradient; *; * Functions :; * asimage_init(), asimage_start(), create_asimage(),; * clone_asimage(), destroy_asimage(); *; * ImageManager Reference counting and managing :; * create_image_manager(), destroy_image_manager(),; * store_asimage(), fetch_asimage(), query_asimage(),; * dup_asimage(), release_asimage(),; * release_asimage_by_name(), forget_asimage(),; * safe_asimage_destroy(); *; * Gradients helper functions :; * flip_gradient(), destroy_asgradient(); *; * Layers helper functions :; * init_image_layers(), create_image_layers(),; * destroy_image_layers(); *; * Encoding :; * asimage_add_line(),	asimage_add_line_mono(),; * asimage_print_line(), get_asimage_chanmask(),; * move_asimage_channel(), copy_asimage_channel(),; * copy_asimage_lines(); *; * Decoding; * start_image_decoding(), stop_image_decoding(),; * asimage_decode_line (), set_decoder_shift(),; * set_decoder_back_color(); *; * Output :; * start_image_output(), set_image_output_back_color(),; * toggle_image_output_direction(), stop_image_output(); *; * Other libAfterImage modules :; * ascmap.h asfont.h asimage.h asvisual.h blender.h export.h; * import.h transform.h ximage.h; * AUTHOR; * Sasha Vasko <sasha at aftercode dot net>; ******/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:179,load,load,179,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,1,['load'],['load']
Performance,"/****h* libAfterImage/libAfterImage; * NAME; * libAfterImage - generic imaging library originally designed for; * AfterStep X Window Manager.; *; * PURPOSE; * libAfterImage is the imaging library implemented for AfterStep; * X Window Manager. It has been generalized to be suitable for any; * application in need of robust graphics engine.; *; * It provides facilities for loading images from files of different; * formats, compressed in memory storage of images, scaling,; * tinting/shading, flipping and superimposition of arbitrary number of; * images over each other. In addition it allows for linear gradients; * drawing, and antialiased/smoothed text drawing using both FreeType; * library and X Window fonts.; *; * Primary goals of this library are to achieve exceptional quality of; * images and text, making code fast and small at the same time.; * Additional steps are taken to compensate for screen colordepth; * limitation, and different error diffusion algorithms are used to; * provide for smooth images even in low colordepth modes.; *; * HISTORY; * libAfterImage has been implemented as an attempt to address several; * issues. First one, and most important is that X Window System; * completely lacks any tools for image manipulation, except for very; * rudimentary operations. With Introduction of Render extentions in; * XFree86 4.0 that situation is changing, but still is far from; * perfect. There need is therefore to implement client side image; * manipulation. That inturn creates a problem of image data transfer; * between Server and client.; *; * To avoid that full-time image storage on the client side is needed.; * Which is memory extensive. So there appears to be a need for some; * in-memory compression.; *; * On the other side there is an image quality issue. Its easy to write; * a scaling function by simply dropping out or duplicating pixels,; * but quality is awfull. What is needed is very fast; * averaging/interpolation code. That brings us to the issue of 8 ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterimage.h:373,load,loading,373,graf2d/asimage/src/libAfterImage/afterimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterimage.h,1,['load'],['loading']
Performance,"/****h* libAfterImage/transform.h; * NAME; * transform; * SYNOPSIS; * Defines transformations that could be performed on ASImage.; * DESCRIPTION; *; * Transformations can be performed with different degree of quality.; * Internal engine uses 24.8 bits per channel per pixel. As the result; * there are no precision loss, while performing complex calculations.; * Error diffusion algorithms could be used to transform it back into 8; * bit without quality loss.; *; * Any Transformation could be performed with the result written directly; * into XImage, so that it could be displayed faster.; *; * Complex interpolation algorithms are used to perform scaling; * operations, thus yielding very good quality. All the transformations; * are performed in integer math, with the result of greater speeds.; * Optional MMX inline assembly has been incorporated into some; * procedures, and allows to achieve considerably better performance on; * compatible CPUs.; *; * SEE ALSO; * Transformations :; * scale_asimage(), tile_asimage(), merge_layers(), ; * 			make_gradient(), flip_asimage(), mirror_asimage(), ; * 			pad_asimage(), blur_asimage_gauss(), fill_asimage(), ; * 			adjust_asimage_hsv(); *; * Other libAfterImage modules :; * ascmap.h asfont.h asimage.h asvisual.h blender.h export.h; * import.h transform.h ximage.h; * AUTHOR; * Sasha Vasko <sasha at aftercode dot net>; *******/; /****f* libAfterImage/transform/scale_asimage(); * NAME; * scale_asimage() - scales source ASImage into new image of requested ; * dimensions. ; * SYNOPSIS; * ASImage *scale_asimage( struct ASVisual *asv,; * ASImage *src,; * unsigned int to_width,; * unsigned int to_height,; * ASAltImFormats out_format,; * unsigned int compression_out, int quality );; * INPUTS; * asv 		- pointer to valid ASVisual structure; * src 		- source ASImage; * to_width 	- desired width of the resulting image; * to_height	- desired height of the resulting image; * out_format 	- optionally describes alternative ASImage format that; * sh",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/transform.h:108,perform,performed,108,graf2d/asimage/src/libAfterImage/transform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/transform.h,7,['perform'],"['perform', 'performance', 'performed', 'performing']"
Performance,"/**. Evaluate function Value, Gradient and Hessian using Fumili approximation, for values of parameters p; The result is cached inside and is return from the FumiliFCNBase::Value , FumiliFCNBase::Gradient and; FumiliFCNBase::Hessian methods. @param par vector of parameters. **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FumiliFCNBase.h:121,cache,cached,121,math/minuit2/inc/Minuit2/FumiliFCNBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FumiliFCNBase.h,3,['cache'],['cached']
Performance,"/**. The meaning of the vector of parameters is of course defined by the user,; who uses the values of those parameters to calculate their function Value.; The order and the position of these parameters is strictly the one specified; by the user when supplying the starting values for minimization. The starting; values must be specified by the user, either via an std::vector<double> or the; MnUserParameters supplied as input to the MINUIT minimizers such as; VariableMetricMinimizer or MnMigrad. Later values are determined by MINUIT; as it searches for the Minimum or performs whatever analysis is requested by; the user. @param v function parameters as defined by the user. @return the Value of the function. @see MnUserParameters; @see VariableMetricMinimizer; @see MnMigrad. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FCNBase.h:572,perform,performs,572,math/minuit2/inc/Minuit2/FCNBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FCNBase.h,1,['perform'],['performs']
Performance,"/**. \class TLinearFitter. \note An alternative to this class is to use ROOT::Fit::Fitter, calling the LinearFit() method. \ingroup MinuitOld. The Linear Fitter - For fitting functions that are LINEAR IN PARAMETERS. ## The Linear Fitter. Linear fitter is used to fit a set of data points with a linear; combination of specified functions. Note, that ""linear"" in the name; stands only for the model dependency on parameters, the specified; functions can be nonlinear.; The general form of this kind of model is; ~~~~; y(x) = a[0] + a[1]*f[1](x)+...a[n]*f[n](x); ~~~~. Functions f are fixed functions of x. For example, fitting with a; polynomial is linear fitting in this sense. ### Introduction. #### The fitting method. The fit is performed using the Normal Equations method with Cholesky; decomposition. #### Why should it be used?. The linear fitter is considerably faster than general non-linear; fitters and doesn't require to set the initial values of parameters. ### Using the fitter:. ### 1.Adding the data points:. #### 1.1 To store or not to store the input data?; - There are 2 options in the constructor - to store or not; store the input data. The advantages of storing the data; are that you'll be able to reset the fitting model without; adding all the points again, and that for very large sets; of points the chisquare is calculated more precisely.; The obvious disadvantage is the amount of memory used to; keep all the points.; - Before you start adding the points, you can change the; store/not store option by StoreData() method. #### 1.2 The data can be added:; - simply point by point - AddPoint() method; - an array of points at once:; If the data is already stored in some arrays, this data; can be assigned to the linear fitter without physically; coping bytes, thanks to the Use() method of; TVector and TMatrix classes - AssignData() method. ### 2.Setting the formula. #### 2.1 The linear formula syntax:; -Additive parts are separated by 2 plus signs ""++""; --for example """,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearFitter.cxx:732,perform,performed,732,math/minuit/src/TLinearFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearFitter.cxx,1,['perform'],['performed']
Performance,/**; 	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during; 	 * your texture's network fetch for increased concurrency.; 	 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:149,concurren,concurrency,149,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['concurren'],['concurrency']
Performance,/**; 	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during; 	 * your texture's network fetch for increased concurrency.; 	 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:157,concurren,concurrency,157,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['concurren'],['concurrency']
Performance,"/**; 	 * Returns an object mapping controller names to values. The object can be passed to `gui.load()` to; 	 * recall these values.; 	 * @example; 	 * {; 	 * 	controllers: {; 	 * 		prop1: 1,; 	 * 		prop2: 'value',; 	 * 		...; 	 * 	},; 	 * 	folders: {; 	 * 		folderName1: { controllers, folders },; 	 * 		folderName2: { controllers, folders }; 	 * 		...; 	 * 	}; 	 * }; 	 *; 	 * @param {boolean} recursive Pass false to exclude folders descending from this GUI.; 	 * @returns {object}; 	 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:96,load,load,96,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['load'],['load']
Performance,"/**; * (PDF 1.5) If set, the new value shall be committed as soon as a selection is made (commonly with the pointing device). In this case, supplying a value for a field involves three actions: selecting the field for fill-in, selecting a choice for the fill-in value, and leaving that field, which finalizes or “commits” the data choice and triggers any actions associated with the entry or changing of this data. If this flag is on, then processing does not wait for leaving the field action to occur, but immediately proceeds to the third step.; * This option enables applications to perform an action once a selection is made, without requiring the user to exit the field. If clear, the new value is not committed until the user exits the field.; *; * @name AcroFormChoiceField#commitOnSelChange; * @default false; * @type {boolean}; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:587,perform,perform,587,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['perform']
Performance,/**; * @addtogroup LLVMCCore; *; * @{; */; /**; * This function permanently loads the dynamic library at the given path.; * It is safe to call this function multiple times for the same library.; *; * @see sys::DynamicLibrary::LoadLibraryPermanently(); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h:76,load,loads,76,interpreter/llvm-project/llvm/include/llvm-c/Support.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h,2,"['Load', 'load']","['LoadLibraryPermanently', 'loads']"
Performance,/**; * @brief Perform prediction using int as spectator variable; * @param method Path to a method weight file.; * This tests check if issue #9115 is fixed since it uses an integer; * type in TMVA::Reader; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/crossvalidation/TestCrossValidationIntVar.cxx:14,Perform,Perform,14,tmva/tmva/test/crossvalidation/TestCrossValidationIntVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/crossvalidation/TestCrossValidationIntVar.cxx,1,['Perform'],['Perform']
Performance,"/**; * @brief Process, wrap and output the next piece of data.; *; * process() will output at least one line of output. This is not necessarily; * the @c data passed in. It may be data queued from a prior call to process().; * If the internal buffer is full, more than 1 line will be output.; *; * process() assumes that the a proper amount of indentation has already been; * output. It won't write any further indentation before the 1st line. If; * more than 1 line is written due to buffer constraints, the lines following; * the first will be indented by this method, though.; *; * No \\n is written by this method after the last line that is written.; *; * @param write where to write the data.; * @param data the new chunk of data to write.; * @param len the length of the chunk of data to write.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h:185,queue,queued,185,core/dictgen/res/OptionParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h,1,['queue'],['queued']
Performance,"/**; * @defgroup LLVMCCoreValueWithAlignment Values with alignment; *; * Functions in this group only apply to values with alignment, i.e.; * global variables, load and store instructions.; */; /**; * Obtain the preferred alignment of the value.; * @see llvm::AllocaInst::getAlignment(); * @see llvm::LoadInst::getAlignment(); * @see llvm::StoreInst::getAlignment(); * @see llvm::AtomicRMWInst::setAlignment(); * @see llvm::AtomicCmpXchgInst::setAlignment(); * @see llvm::GlobalValue::getAlignment(); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:160,load,load,160,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,2,"['Load', 'load']","['LoadInst', 'load']"
Performance,"/**; * @defgroup Triangulation Triangulation Class; * Class performing triangulations.; */; /// @{; /**; * Data structure representing a 2D constrained Delaunay triangulation; *; * @tparam T type of vertex coordinates (e.g., float, double); * @tparam TNearPointLocator class providing locating near point for efficiently; * inserting new points. Provides methods: 'addPoint(vPos, iV)' and; * 'nearPoint(vPos) -> iV'; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:60,perform,performing,60,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['perform'],['performing']
Performance,/**; * @internal; * @brief Interface for actions Parser::workhorse() should perform for each Option it; * parses.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h:76,perform,perform,76,core/dictgen/res/OptionParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h,1,['perform'],['perform']
Performance,"/**; * @internal; * @brief Takes input and line wraps it, writing out one line at a time so that; * it can be interleaved with output from other columns.; *; * The LineWrapper is used to handle the last column of each table as well as interjections.; * The LineWrapper is called once for each line of output. If the data given to it fits; * into the designated width of the last column it is simply written out. If there; * is too much data, an appropriate split point is located and only the data up to this; * split point is written out. The rest of the data is queued for the next line.; * That way the last column can be line wrapped and interleaved with data from; * other columns. The following example makes this clearer:; * @code; * Column 1,1 Column 2,1 This is a long text; * Column 1,2 Column 2,2 that does not fit into; * a single line.; * @endcode; *; * The difficulty in producing this output is that the whole string; * ""This is a long text that does not fit into a single line"" is the; * 1st and only part of column 3. In order to produce the above; * output the string must be output piecemeal, interleaved with; * the data from the other columns.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h:564,queue,queued,564,core/dictgen/res/OptionParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h,1,['queue'],['queued']
Performance,"/**; * @license; Copyright (c) 2008, Adobe Systems Incorporated; All rights reserved. Redistribution and use in source and binary forms, with or without ; modification, are permitted provided that the following conditions are; met:. * Redistributions of source code must retain the above copyright notice, ; this list of conditions and the following disclaimer.; ; * Redistributions in binary form must reproduce the above copyright; notice, this list of conditions and the following disclaimer in the ; documentation and/or other materials provided with the distribution.; ; * Neither the name of Adobe Systems Incorporated nor the names of its ; contributors may be used to endorse or promote products derived from ; this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS; IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,; THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR; PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR ; CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,; EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR; PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF; LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING; NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; */; /*; JPEG encoder ported to JavaScript and optimized by Andreas Ritter, www.bytestrom.eu, 11/2009. Basic GUI blocking jpeg encoder; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:1589,optimiz,optimized,1589,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['optimiz'],['optimized']
Performance,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:70,Cache,Cache,70,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,7,"['Cache', 'cache']","['Cache', 'cache']"
Performance,/**; * @}; */; /**; * @defgroup LLVMCCorePassManagers Pass Managers; * @ingroup LLVMCCore; *; * @{; */; /** Constructs a new whole-module pass pipeline. This type of pipeline is; suitable for link-time optimization and whole-module transformations.; @see llvm::PassManager::PassManager */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:202,optimiz,optimization,202,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['optimiz'],['optimization']
Performance,/**; * @}; */; /**; * @defgroup LLVMCCoreThreading Threading; *; * Handle the structures needed to make LLVM safe for multithreading.; *; * @{; */; /** Deprecated: Multi-threading can only be enabled/disabled with the compile; time define LLVM_ENABLE_THREADS. This function always returns; LLVMIsMultithreaded(). */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:164,Multi-thread,Multi-threading,164,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['Multi-thread'],['Multi-threading']
Performance,"/**; * A CompileUnit provides an anchor for all debugging; * information generated during this instance of compilation.; * \param Lang Source programming language, eg.; * \c LLVMDWARFSourceLanguageC99; * \param FileRef File info.; * \param Producer Identify the producer of debugging information; * and code. Usually this is a compiler; * version string.; * \param ProducerLen The length of the C string passed to \c Producer.; * \param isOptimized A boolean flag which indicates whether optimization; * is enabled or not.; * \param Flags This string lists command line options. This; * string is directly embedded in debug info; * output which may be used by a tool; * analyzing generated debugging information.; * \param FlagsLen The length of the C string passed to \c Flags.; * \param RuntimeVer This indicates runtime version for languages like; * Objective-C.; * \param SplitName The name of the file that we'll split debug info; * out into.; * \param SplitNameLen The length of the C string passed to \c SplitName.; * \param Kind The kind of debug information to generate.; * \param DWOId The DWOId if this is a split skeleton compile unit.; * \param SplitDebugInlining Whether to emit inline debug info.; * \param DebugInfoForProfiling Whether to emit extra debug info for; * profile collection.; * \param SysRoot The Clang system root (value of -isysroot).; * \param SysRootLen The length of the C string passed to \c SysRoot.; * \param SDK The SDK. On Darwin, the last component of the sysroot.; * \param SDKLen The length of the C string passed to \c SDK.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:488,optimiz,optimization,488,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,1,['optimiz'],['optimization']
Performance,"/**; * Abstract Base class to block based textures loader (dds, pvr, ...); *; * Sub classes have to implement the parse() method which will be used in load().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:51,load,loader,51,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,2,['load'],"['load', 'loader']"
Performance,"/**; * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...); *; * Sub classes have to implement the parse() method which will be used in load().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:30,load,load,30,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,2,['load'],['load']
Performance,"/**; * Adds a requirement that another module flag be present and have a; * specified value after linking is performed. The value must be a metadata; * pair, where the first element of the pair is the ID of the module flag; * to be restricted, and the second element of the pair is the value the; * module flag should be restricted to. This behavior can be used to; * restrict the allowable results (via triggering of an error) of linking; * IDs with the **Override** behavior.; *; * @see Module::ModFlagBehavior::Require; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:109,perform,performed,109,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['perform'],['performed']
Performance,"/**; * Adds a symbol to the list of global symbols that are cross-referenced between; * ThinLTO files. If the ThinLTO CodeGenerator can ensure that every; * references from a ThinLTO module to this symbol is optimized away, then; * the symbol can be discarded.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:208,optimiz,optimized,208,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['optimiz'],['optimized']
Performance,"/**; * Adds a symbol to the list of global symbols that must exist in the final; * generated code. If a function is not listed there, it might be inlined into; * every usage and optimized away. For every single module, the functions; * referenced from code outside of the ThinLTO modules need to be added here.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:178,optimiz,optimized,178,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['optimiz'],['optimized']
Performance,"/**; * Adds to a list of all global symbols that are cross-referenced between; * ThinLTO files. If the ThinLTO CodeGenerator can ensure that every; * references from a ThinLTO module to this symbol is optimized away, then; * the symbol can be discarded.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:201,optimiz,optimized,201,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['optimiz'],['optimized']
Performance,"/**; * Adds to a list of all global symbols that must exist in the final generated; * code. If a function is not listed there, it might be inlined into every usage; * and optimized away.; *; * \since prior to LTO_API_VERSION=3; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:171,optimiz,optimized,171,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['optimiz'],['optimized']
Performance,"/**; * Adds to a list of all global symbols that must exist in the final generated; * code. If a symbol is not listed there, it will be optimized away if it is; * inlined into every usage.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:136,optimiz,optimized,136,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['optimiz'],['optimized']
Performance,"/**; * Automatic insertion order optimized for better performance; * @details breadth-first traversal of a Kd-tree for initial bulk-load,; * randomized for subsequent insertions; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:33,optimiz,optimized,33,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,3,"['load', 'optimiz', 'perform']","['load', 'optimized', 'performance']"
Performance,"/**; * Calculate depth of each triangle in constraint triangulation. Supports; * overlapping boundaries.; *; * Perform depth peeling from super triangle to outermost boundary,; * then to next boundary and so on until all triangles are traversed.@n; * For example depth is:; * - 0 for triangles outside outermost boundary; * - 1 for triangles inside boundary but outside hole; * - 2 for triangles in hole; * - 3 for triangles in island and so on...; * @return vector where element at index i stores depth of i-th triangle; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:111,Perform,Perform,111,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['Perform'],['Perform']
Performance,"/**; * Centripetal CatmullRom Curve - which is useful for avoiding; * cusps and self-intersections in non-uniform catmull rom curves.; * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf; *; * curve.type accepts centripetal(default), chordal and catmullrom; * curve.tension is used for catmullrom which defaults to 0.5; */; /*; Based on an optimized c++ solution in; - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/; - http://ideone.com/NoEbVM. This CubicPoly class could be used for reusing some variables and calculations,; but for three.js curve use, it could be possible inlined and flatten into a single function call; which can be placed in CurveUtils.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:356,optimiz,optimized,356,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['optimiz'],['optimized']
Performance,/**; * Check that the glyph at <code>chr</code> exist. If not load it.; *; * @param chr character index; * @return <code>true</code> if the glyph can be created.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTFont.h:62,load,load,62,graf3d/ftgl/inc/FTFont.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTFont.h,1,['load'],['load']
Performance,/**; * Checks if a buffer is a loadable object compiled for requested target.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:31,load,loadable,31,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['load'],['loadable']
Performance,/**; * Checks if a buffer is a loadable object file.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:31,load,loadable,31,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['load'],['loadable']
Performance,/**; * Checks if a file is a loadable object compiled for requested target.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:29,load,loadable,29,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['load'],['loadable']
Performance,/**; * Checks if a file is a loadable object file.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:29,load,loadable,29,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['load'],['loadable']
Performance,"/**; * Conform Delaunay triangulation to a fixed edge by recursively inserting; * mid point of the edge and then conforming to its halves; * @param edge fixed edge to conform to; * @param originals original edges that new edge is piece of; * @param overlaps count of overlapping boundaries at the edge. Only used; * when re-introducing edge with overlaps > 0; * @param[in,out] remaining remaining edge parts to be conformed to; * @note in-out state (@param remaining @param reintroduce) is shared; * between different runs for performance gains (reducing memory; * allocations); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:527,perform,performance,527,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['perform'],['performance']
Performance,"/**; * Constructs the burrows-wheeler transformed string of a given string.; * @param T [0..n-1] The input string.; * @param U [0..n-1] The output string. (can be T); * @param A [0..n-1] The temporary array. (can be NULL); * @param n The length of the given string.; * @param num_indexes The length of secondary indexes array. (can be NULL); * @param indexes The secondary indexes array. (can be NULL); * @param openMP enables OpenMP optimization.; * @return The primary index if no error occurred, -1 or -2 otherwise.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/divsufsort.h:434,optimiz,optimization,434,builtins/zstd/dictBuilder/divsufsort.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/divsufsort.h,1,['optimiz'],['optimization']
Performance,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:508,optimiz,optimizations,508,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,1,['optimiz'],['optimizations']
Performance,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:429,optimiz,optimizations,429,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,1,['optimiz'],['optimizations']
Performance,/**; * Create a new descriptor for the specified subprogram.; * \param Builder The \c DIBuilder.; * \param Scope Function scope.; * \param Name Function name.; * \param NameLen Length of enumeration name.; * \param LinkageName Mangled function name.; * \param LinkageNameLen Length of linkage name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Function type.; * \param IsLocalToUnit True if this function is not externally visible.; * \param IsDefinition True if this is a function definition.; * \param ScopeLine Set to the beginning of the scope this starts; * \param Flags E.g.: \c LLVMDIFlagLValueReference. These flags are; * used to emit dwarf attributes.; * \param IsOptimized True if optimization is ON.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:742,optimiz,optimization,742,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,1,['optimiz'],['optimization']
Performance,"/**; * Create a simple custom MCJIT memory manager. This memory manager can; * intercept allocations in a module-oblivious way. This will return NULL; * if any of the passed functions are NULL.; *; * @param Opaque An opaque client object to pass back to the callbacks.; * @param AllocateCodeSection Allocate a block of memory for executable code.; * @param AllocateDataSection Allocate a block of memory for data.; * @param FinalizeMemory Set page permissions and flush cache. Return 0 on; * success, 1 on error.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:470,cache,cache,470,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,1,['cache'],['cache']
Performance,"/**; * Create a table from a set of data.; * @name table; * @function; * @param {Integer} [x] : left-position for top-left corner of table; * @param {Integer} [y] top-position for top-left corner of table; * @param {Object[]} [data] An array of objects containing key-value pairs corresponding to a row of data.; * @param {String[]} [headers] Omit or null to auto-generate headers at a performance cost. * @param {Object} [config.printHeaders] True to print column headers at the top of every page; * @param {Object} [config.autoSize] True to dynamically set the column widths to match the widest cell value; * @param {Object} [config.margins] margin values for left, top, bottom, and width; * @param {Object} [config.fontSize] Integer fontSize to use (optional); * @param {Object} [config.padding] cell-padding in pt to use (optional); * @param {Object} [config.headerBackgroundColor] default is #c8c8c8 (optional); * @param {Object} [config.headerTextColor] default is #000 (optional); * @param {Object} [config.rowStart] callback to handle before print each row (optional); * @param {Object} [config.cellStart] callback to handle before print each cell (optional); * @returns {jsPDF} jsPDF-instance; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:386,perform,performance,386,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performance']
Performance,/**; * Create a vector type that contains a defined type and has a scalable; * number of elements.; *; * The created type will exist in the context thats its element type; * exists in.; *; * @see llvm::ScalableVectorType::get(); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:67,scalab,scalable,67,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,2,"['Scalab', 'scalab']","['ScalableVectorType', 'scalable']"
Performance,"/**; * Deserialize a set of diagnostics from a Clang diagnostics bitcode; * file.; *; * \param file The name of the file to deserialize.; * \param error A pointer to a enum value recording if there was a problem; * deserializing the diagnostics.; * \param errorString A pointer to a CXString for recording the error string; * if the file was not successfully loaded.; *; * \returns A loaded CXDiagnosticSet if successful, and NULL otherwise. These; * diagnostics should be released using clang_disposeDiagnosticSet().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:359,load,loaded,359,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,2,['load'],['loaded']
Performance,/**; * Determine the number of diagnostics produced prior to the; * location where code completion was performed.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:103,perform,performed,103,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['perform'],['performed']
Performance,"/**; * FTCharmap takes care of specifying the encoding for a font and mapping; * character codes to glyph indices.; *; * It doesn't preprocess all indices, only on an as needed basis. This may; * seem like a performance penalty but it is quicker than using the 'raw'; * freetype calls and will save significant amounts of memory when dealing; * with unicode encoding; *; * @see ""Freetype 2 Documentation""; *; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTCharmap.h:208,perform,performance,208,graf3d/ftgl/inc/FTCharmap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTCharmap.h,1,['perform'],['performance']
Performance,/**; * Flags to indicate what fast-math-style optimizations are allowed; * on operations.; *; * See https://llvm.org/docs/LangRef.html#fast-math-flags; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:46,optimiz,optimizations,46,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['optimiz'],['optimizations']
Performance,"/**; * Generates code for the optimized merged module into one native object file.; * It will not run any IR optimizations on the merged module.; *; * On success returns a pointer to a generated mach-o/ELF buffer and length set; * to the buffer size. The buffer is owned by the lto_code_gen_t and will be; * freed when lto_codegen_dispose() is called, or; * lto_codegen_compile_optimized() is called again. On failure, returns NULL; * (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=12; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:30,optimiz,optimized,30,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,2,['optimiz'],"['optimizations', 'optimized']"
Performance,/**; * Get a glyph from the glyph list; *; * @param characterCode The char code of the glyph NOT the glyph index; * @return An FTGlyph or <code>null</code> is it hasn't been; * loaded.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTGlyphContainer.h:177,load,loaded,177,graf3d/ftgl/inc/FTGlyphContainer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTGlyphContainer.h,1,['load'],['loaded']
Performance,/**; * Get the flags for which fast-math-style optimizations are allowed for this; * value.; *; * Only valid on floating point instructions.; * @see LLVMCanValueUseFastMathFlags; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:47,optimiz,optimizations,47,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['optimiz'],['optimizations']
Performance,/**; * Gets the global face height for the face.; *; * If the face is scalable this returns the height of the global; * bounding box which ensures that any glyph will be less than or; * equal to this height. If the font isn't scalable there is no; * guarantee that glyphs will not be taller than this value.; *; * @return height in pixels.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTSize.h:70,scalab,scalable,70,graf3d/ftgl/inc/FTSize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTSize.h,2,['scalab'],['scalable']
Performance,/**; * Gets the global face width for the face.; *; * If the face is scalable this returns the width of the global; * bounding box which ensures that any glyph will be less than or; * equal to this width. If the font isn't scalable this value is; * the max_advance for the face.; *; * @return width in pixels.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTSize.h:69,scalab,scalable,69,graf3d/ftgl/inc/FTSize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTSize.h,2,['scalab'],['scalable']
Performance,"/**; * HINT_INLINE is used to help the compiler generate better code. It is *not*; * used for ""templates"", so it can be tweaked based on the compilers; * performance.; *; * gcc-4.8 and gcc-4.9 have been shown to benefit from leaving off the; * always_inline attribute.; *; * clang up to 5.0.0 (trunk) benefit tremendously from the always_inline; * attribute.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/compiler.h:154,perform,performance,154,builtins/zstd/common/compiler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/compiler.h,1,['perform'],['performance']
Performance,"/**; * If we are facing some sort of diamond carry propapagtion pattern try to; * break it up to generate something like:; * (uaddo_carry X, 0, (uaddo_carry A, B, Z):Carry); *; * The end result is usually an increase in operation required, but because the; * carry is now linearized, other transforms can kick in and optimize the DAG.; *; * Patterns typically look something like; * (uaddo A, B); * / \; * Carry Sum; * | \; * | (uaddo_carry *, 0, Z); * | /; * \ Carry; * | /; * (uaddo_carry X, *, *); *; * But numerous variation exist. Our goal is to identify A, B, X and Z and; * produce a combine with a single path for carry propagation.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:317,optimiz,optimize,317,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['optimiz'],['optimize']
Performance,"/**; * Index the given source file and the translation unit corresponding; * to that file via callbacks implemented through #IndexerCallbacks.; *; * \param client_data pointer data supplied by the client, which will; * be passed to the invoked callbacks.; *; * \param index_callbacks Pointer to indexing callbacks that the client; * implements.; *; * \param index_callbacks_size Size of #IndexerCallbacks structure that gets; * passed in index_callbacks.; *; * \param index_options A bitmask of options that affects how indexing is; * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.; *; * \param[out] out_TU pointer to store a \c CXTranslationUnit that can be; * reused after indexing is finished. Set to \c NULL if you do not require it.; *; * \returns 0 on success or if there were errors from which the compiler could; * recover. If there is a failure from which there is no recovery, returns; * a non-zero \c CXErrorCode.; *; * The rest of the parameters are the same as #clang_parseTranslationUnit.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:535,perform,performed,535,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['perform'],['performed']
Performance,"/**; * Insert an edge into constraint Delaunay triangulation; * @param edge edge to insert; * @param originalEdge original edge inserted edge is part of; * @param[in,out] remaining parts of the edge that still need to; * be inserted; * @param[in,out] tppIterations stack to be used for storing iterations of; * triangulating pseudo-polygon; * @note in-out state (@param remaining @param tppIterations) is shared; * between different runs for performance gains (reducing memory; * allocations); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:442,perform,performance,442,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['perform'],['performance']
Performance,"/**; * Insert an edge or its part into constraint Delaunay triangulation; * @param edge edge to insert; * @param originalEdge original edge inserted edge is part of; * @param[in,out] remainingStack parts of the edge that still need to; * be inserted; * @param[in,out] tppIterations stack to be used for storing iterations of; * triangulating pseudo-polygon; * @note in-out state (@param remaining @param tppIterations) is shared; * between different runs for performance gains (reducing memory; * allocations); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:459,perform,performance,459,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['perform'],['performance']
Performance,"/**; * Instantiates a ThinLTO code generator.; * Returns NULL on error (check lto_get_error_message() for details).; *; *; * The ThinLTOCodeGenerator is not intended to be reuse for multiple; * compilation: the model is that the client adds modules to the generator and; * ask to perform the ThinLTO optimizations / codegen, and finally destroys the; * codegenerator.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:280,perform,perform,280,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,2,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"/**; * Intern a string in the ExecutionSession's SymbolStringPool and return a; * reference to it. This increments the ref-count of the pool entry, and the; * returned value should be released once the client is done with it by; * calling LLVMOrcReleaseSymbolStringPoolEntry.; *; * Since strings are uniqued within the SymbolStringPool; * LLVMOrcSymbolStringPoolEntryRefs can be compared by value to test string; * equality.; *; * Note that this function does not perform linker-mangling on the string.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:464,perform,perform,464,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h,1,['perform'],['perform']
Performance,"/**; * Iteration of conform to fixed edge.; * @param edge fixed edge to conform to; * @param originals original edges that new edge is piece of; * @param overlaps count of overlapping boundaries at the edge. Only used; * when re-introducing edge with overlaps > 0; * @param[in,out] remaining remaining edge parts; * @note in-out state (@param remaining @param reintroduce) is shared; * between different runs for performance gains (reducing memory; * allocations); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:413,perform,performance,413,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['perform'],['performance']
Performance,/**; * Loads an object file from disk. The seek point of fd is not preserved.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=5; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Load,Loads,7,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,2,['Load'],['Loads']
Performance,/**; * Loads an object file from disk.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Load,Loads,7,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['Load'],['Loads']
Performance,/**; * Loads an object file from memory with an extra path argument.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=9; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Load,Loads,7,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['Load'],['Loads']
Performance,/**; * Loads an object file from memory.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Load,Loads,7,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['Load'],['Loads']
Performance,"/**; * Loads an object file in its own context.; *; * Loads an object file in its own LLVMContext. This function call is; * thread-safe. However, modules created this way should not be merged into an; * lto_code_gen_t using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Load,Loads,7,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,2,['Load'],['Loads']
Performance,/**; * Loads an object file in the codegen context.; *; * Loads an object file into the same context as \c cg. The module is safe to; * add using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Load,Loads,7,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,2,['Load'],['Loads']
Performance,/**; * Loads and creates a Freetype glyph.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTFace.h:7,Load,Loads,7,graf3d/ftgl/inc/FTFace.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/ftgl/inc/FTFace.h,1,['Load'],['Loads']
Performance,"/**; * Multiply two 24-bit integer values x and y. x and y; * are 32-bit integers but only the low 24-bits are used; * to perform the multiplication. mul24 should only; * be used when values in x and y are in the range [-; * 2^23, 2^23-1] if x and y are signed integers and in the; * range [0, 2^24-1] if x and y are unsigned integers. If; * x and y are not in this range, the multiplication; * result is implementation-defined.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:122,perform,perform,122,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h,1,['perform'],['perform']
Performance,"/**; * Namespace for dispatching RooFit computations to various backends.; *; * This namespace contains an interface for providing high-performance computation functions for use in; * RooAbsReal::doEval(), see RooBatchComputeInterface.; *; * Furthermore, several implementations of this interface can be created, which reside in RooBatchCompute::RF_ARCH,; * where RF_ARCH may be replaced by the architecture that this implementation targets, e.g. SSE, AVX, etc.; *; * Using the pointer RooBatchCompute::dispatch, a computation request can be dispatched to the fastest backend that is; * available on a specific platform.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooBatchCompute.h:136,perform,performance,136,roofit/batchcompute/res/RooBatchCompute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooBatchCompute.h,1,['perform'],['performance']
Performance,/**; * Obtain the (possibly scalable) number of elements in a vector type.; *; * This only works on types that represent vectors (fixed or scalable).; *; * @see llvm::VectorType::getNumElements(); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:28,scalab,scalable,28,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,2,['scalab'],['scalable']
Performance,/**; * Optimize and codegen all the modules added to the codegenerator using; * ThinLTO. Resulting objects are accessible using thinlto_module_get_object().; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Optimiz,Optimize,7,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['Optimiz'],['Optimize']
Performance,"/**; * Parse the given source file and the translation unit corresponding; * to that file.; *; * This routine is the main entry point for the Clang C API, providing the; * ability to parse a source file into a translation unit that can then be; * queried by other functions in the API. This routine accepts a set of; * command-line arguments so that the compilation can be configured in the same; * way that the compiler is configured on the command line.; *; * \param CIdx The index object with which the translation unit will be; * associated.; *; * \param source_filename The name of the source file to load, or NULL if the; * source file is included in \c command_line_args.; *; * \param command_line_args The command-line arguments that would be; * passed to the \c clang executable if it were being invoked out-of-process.; * These command-line options will be parsed and will affect how the translation; * unit is parsed. Note that the following options are ignored: '-c',; * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.; *; * \param num_command_line_args The number of command-line arguments in; * \c command_line_args.; *; * \param unsaved_files the files that have not yet been saved to disk; * but may be required for parsing, including the contents of; * those files. The contents and name of these files (as specified by; * CXUnsavedFile) are copied when necessary, so the client only needs to; * guarantee their validity until the call to this function returns.; *; * \param num_unsaved_files the number of unsaved file entries in \p; * unsaved_files.; *; * \param options A bitmask of options that affects how the translation unit; * is managed but not its compilation. This should be a bitwise OR of the; * CXTranslationUnit_XXX flags.; *; * \param[out] out_TU A non-NULL pointer to store the created; * \c CXTranslationUnit, describing the parsed code and containing any; * diagnostics produced by the compiler.; *; * \returns Zero on success, otherwi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:606,load,load,606,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['load'],['load']
Performance,/**; * Perform CodeGen only: disable all other stages.; *; * \since LTO_API_VERSION=19; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Perform,Perform,7,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['Perform'],['Perform']
Performance,"/**; * Perform code completion at a given location in a translation unit.; *; * This function performs code completion at a particular file, line, and; * column within source code, providing results that suggest potential; * code snippets based on the context of the completion. The basic model; * for code completion is that Clang will parse a complete source file,; * performing syntax checking up to the location where code-completion has; * been requested. At that point, a special code-completion token is passed; * to the parser, which recognizes this token and determines, based on the; * current location in the C/Objective-C/C++ grammar and the state of; * semantic analysis, what completions to provide. These completions are; * returned via a new \c CXCodeCompleteResults structure.; *; * Code completion itself is meant to be triggered by the client when the; * user types punctuation characters or whitespace, at which point the; * code-completion location will coincide with the cursor. For example, if \c p; * is a pointer, code-completion might be triggered after the ""-"" and then; * after the "">"" in \c p->. When the code-completion location is after the "">"",; * the completion results will provide, e.g., the members of the struct that; * ""p"" points to. The client is responsible for placing the cursor at the; * beginning of the token currently being typed, then filtering the results; * based on the contents of the token. For example, when code-completing for; * the expression \c p->get, the client should provide the location just after; * the "">"" (e.g., pointing at the ""g"") to this code-completion hook. Then, the; * client can filter the results based on the current token text (""get""), only; * showing those results that start with ""get"". The intent of this interface; * is to separate the relatively high-latency acquisition of code-completion; * results from the filtering of results on a per-character basis, which must; * have a lower latency.; *; * \param TU The transl",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:7,Perform,Perform,7,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,3,"['Perform', 'perform']","['Perform', 'performing', 'performs']"
Performance,/**; * Perform cross-module importing for the module identified by ModuleIdentifier.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:7,Perform,Perform,7,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['Perform'],['Perform']
Performance,/**; * Perform cross-module importing for the module identified by; * ModuleIdentifier.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:7,Perform,Perform,7,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['Perform'],['Perform']
Performance,/**; * Perform internalization. Index is updated to reflect linkage changes.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:7,Perform,Perform,7,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['Perform'],['Perform']
Performance,/**; * Perform internalization. Runs promote and internalization together.; * Index is updated to reflect linkage changes.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:7,Perform,Perform,7,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['Perform'],['Perform']
Performance,/**; * Perform post-importing ThinLTO optimizations.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:7,Perform,Perform,7,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,4,"['Perform', 'optimiz']","['Perform', 'optimizations']"
Performance,/**; * Perform prediction using float as spectator variable; * @param method Path to a method weight file.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/crossvalidation/TestCrossValidationIntVar.cxx:7,Perform,Perform,7,tmva/tmva/test/crossvalidation/TestCrossValidationIntVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/crossvalidation/TestCrossValidationIntVar.cxx,1,['Perform'],['Perform']
Performance,"/**; * Perform promotion and renaming of exported internal functions,; * and additionally resolve weak and linkonce symbols.; * Index is updated to reflect linkage changes from weak resolution.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:7,Perform,Perform,7,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['Perform'],['Perform']
Performance,/**; * Perform promotion and renaming of exported internal functions.; * Index is updated to reflect linkage changes from weak resolution.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:7,Perform,Perform,7,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['Perform'],['Perform']
Performance,/**; * Performs the same split as CvSplitKFolds; *; * @param ids; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/crossvalidation/TestCrossValidationSplitting.cxx:7,Perform,Performs,7,tmva/tmva/test/crossvalidation/TestCrossValidationSplitting.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/crossvalidation/TestCrossValidationSplitting.cxx,1,['Perform'],['Performs']
Performance,/**; * Prefetch num_elements * sizeof(gentype); * bytes into the global cache. The prefetch; * instruction is applied to a work-item in a workgroup; * and does not affect the functional; * behavior of the kernel.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:72,cache,cache,72,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h,1,['cache'],['cache']
Performance,"/**; * Provides a shared context for creating translation units.; *; * It provides two options:; *; * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of ""local""; * declarations (when loading any new translation units). A ""local"" declaration; * is one that belongs in the translation unit itself and not in a precompiled; * header that was used by the translation unit. If zero, all declarations; * will be enumerated.; *; * Here is an example:; *; * \code; * // excludeDeclsFromPCH = 1, displayDiagnostics=1; * Idx = clang_createIndex(1, 1);; *; * // IndexTest.pch was produced with the following command:; * // ""clang -x c IndexTest.h -emit-ast -o IndexTest.pch""; * TU = clang_createTranslationUnit(Idx, ""IndexTest.pch"");; *; * // This will load all the symbols from 'IndexTest.pch'; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; *; * // This will load all the symbols from 'IndexTest.c', excluding symbols; * // from 'IndexTest.pch'.; * char *args[] = { ""-Xclang"", ""-include-pch=IndexTest.pch"" };; * TU = clang_createTranslationUnitFromSourceFile(Idx, ""IndexTest.c"", 2, args,; * 0, 0);; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; * \endcode; *; * This process of creating the 'pch', loading it separately, and using it (via; * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks; * (which gives the indexer the same performance benefit as the compiler).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:199,load,loading,199,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,5,"['load', 'perform']","['load', 'loading', 'performance']"
Performance,/**; * Queue a memory fence to ensure correct ordering of memory; * operations between work-items of a work-group to; * image memory.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:7,Queue,Queue,7,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,1,['Queue'],['Queue']
Performance,/**; * Queue a memory fence to ensure correct; * ordering of memory operations to global memory; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:7,Queue,Queue,7,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,1,['Queue'],['Queue']
Performance,/**; * Queue a memory fence to ensure correct; * ordering of memory operations to local memory; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:7,Queue,Queue,7,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,1,['Queue'],['Queue']
Performance,/**; * Read memory barrier that orders only; * loads.; * The flags argument specifies the memory; * address space and can be set to a; * combination of the following literal; * values:; * CLK_LOCAL_MEM_FENCE; * CLK_GLOBAL_MEM_FENCE.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:47,load,loads,47,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h,1,['load'],['loads']
Performance,"/**; * Retrieve the buffer associated with the given file.; *; * \param tu the translation unit; *; * \param file the file for which to retrieve the buffer.; *; * \param size [out] if non-NULL, will be set to the size of the buffer.; *; * \returns a pointer to the buffer in memory that holds the contents of; * \p file, or a NULL pointer when the file is not loaded.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:360,load,loaded,360,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['load'],['loaded']
Performance,"/**; * Return the CXTranslationUnit for a given source file and the provided; * command line arguments one would pass to the compiler.; *; * Note: The 'source_filename' argument is optional. If the caller provides a; * NULL pointer, the name of the source file is expected to reside in the; * specified command line arguments.; *; * Note: When encountered in 'clang_command_line_args', the following options; * are ignored:; *; * '-c'; * '-emit-ast'; * '-fsyntax-only'; * '-o \<output file>' (both '-o' and '\<output file>' are ignored); *; * \param CIdx The index object with which the translation unit will be; * associated.; *; * \param source_filename The name of the source file to load, or NULL if the; * source file is included in \p clang_command_line_args.; *; * \param num_clang_command_line_args The number of command-line arguments in; * \p clang_command_line_args.; *; * \param clang_command_line_args The command-line arguments that would be; * passed to the \c clang executable if it were being invoked out-of-process.; * These command-line options will be parsed and will affect how the translation; * unit is parsed. Note that the following options are ignored: '-c',; * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.; *; * \param num_unsaved_files the number of unsaved file entries in \p; * unsaved_files.; *; * \param unsaved_files the files that have not yet been saved to disk; * but may be required for code completion, including the contents of; * those files. The contents and name of these files (as specified by; * CXUnsavedFile) are copied when necessary, so the client only needs to; * guarantee their validity until the call to this function returns.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:687,load,load,687,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['load'],['load']
Performance,"/**; * Returns 1 if the queue is full and 0 otherwise.; *; * When queueSize is 1 (pool was created with an intended queueSize of 0),; * then a queue is empty if there is a thread free _and_ no job is waiting.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c:24,queue,queue,24,builtins/zstd/common/pool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/pool.c,4,['queue'],"['queue', 'queueSize']"
Performance,"/**; * Returns the set of flags that is suitable for parsing a translation; * unit that is being edited.; *; * The set of flags returned provide options for \c clang_parseTranslationUnit(); * to indicate that the translation unit is likely to be reparsed many times,; * either explicitly (via \c clang_reparseTranslationUnit()) or implicitly; * (e.g., by code completion (\c clang_codeCompletionAt())). The returned flag; * set contains an unspecified set of optimizations (e.g., the precompiled; * preamble) geared toward improving the performance of these routines. The; * set of optimizations enabled may change from one version to the next.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:459,optimiz,optimizations,459,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,3,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,/**; * Returns the set of flags that is suitable for reparsing a translation; * unit.; *; * The set of flags returned provide options for; * \c clang_reparseTranslationUnit() by default. The returned flag; * set contains an unspecified set of optimizations geared toward common uses; * of reparsing. The set of optimizations enabled may change from one version; * to the next.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:243,optimiz,optimizations,243,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,2,['optimiz'],['optimizations']
Performance,/**; * Runs optimization for the merged module. Returns true on error.; *; * \since LTO_API_VERSION=12; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:12,optimiz,optimization,12,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['optimiz'],['optimization']
Performance,"/**; * Searches through the input for a synchronization point. If one is found, we; * will instruct the caller to flush, and return the number of bytes to load.; * Otherwise, we will load as many bytes as possible and instruct the caller; * to continue as normal.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c:155,load,load,155,builtins/zstd/compress/zstdmt_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c,2,['load'],['load']
Performance,/**; * Set the preferred alignment of the value.; * @see llvm::AllocaInst::setAlignment(); * @see llvm::LoadInst::setAlignment(); * @see llvm::StoreInst::setAlignment(); * @see llvm::AtomicRMWInst::setAlignment(); * @see llvm::AtomicCmpXchgInst::setAlignment(); * @see llvm::GlobalValue::setAlignment(); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:104,Load,LoadInst,104,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['Load'],['LoadInst']
Performance,/**; * Sets if we should run internalize pass during optimization and code; * generation.; *; * \since LTO_API_VERSION=14; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:53,optimiz,optimization,53,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['optimiz'],['optimization']
Performance,"/**; * Sets the cache pruning interval (in seconds). A negative value disables the; * pruning. An unspecified default value will be applied, and a value of 0 will; * force prunning to occur.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:16,cache,cache,16,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['cache'],['cache']
Performance,/**; * Sets the expiration (in seconds) for an entry in the cache. An unspecified; * default value will be applied. A value of 0 will be ignored.; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:60,cache,cache,60,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['cache'],['cache']
Performance,/**; * Sets the flags for which fast-math-style optimizations are allowed for this; * value.; *; * Only valid on floating point instructions.; * @see LLVMCanValueUseFastMathFlags; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:48,optimiz,optimizations,48,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['optimiz'],['optimizations']
Performance,"/**; * Sets the maximum cache size that can be persistent across build, in terms of; * percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over half the; * available space. A value over 100 will be reduced to 100, a value of 0 will; * be ignored. An unspecified default value will be applied.; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:24,cache,cache,24,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,2,['cache'],['cache']
Performance,"/**; * Sets the maximum cache size that can be persistent across build, in terms; * of percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over; * half the available space. A value over 100 will be reduced to 100, and a; * value of 0 will be ignored.; *; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:24,cache,cache,24,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,2,['cache'],['cache']
Performance,/**; * Sets the maximum number of files in the cache directory. An unspecified; * default value will be applied. A value of 0 will be ignored.; *; * \since LTO_API_VERSION=22; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:47,cache,cache,47,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['cache'],['cache']
Performance,/**; * Sets the maximum size of the cache directory (in bytes). A value over the; * amount of available space on the disk will be reduced to the amount of; * available space. An unspecified default value will be applied. A value of 0; * will be ignored.; *; * \since LTO_API_VERSION=22; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:36,cache,cache,36,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['cache'],['cache']
Performance,"/**; * Similar to ZSTD_nextSrcSizeToDecompress(), but when when a block input can be streamed,; * we allow taking a partial block as the input. Currently only raw uncompressed blocks can; * be streamed.; *; * For blocks that can be streamed, this allows us to reduce the latency until we produce; * output, and avoid copying the input.; *; * @param inputSize - The total amount of input that the caller currently has.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c:271,latency,latency,271,builtins/zstd/decompress/zstd_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c,1,['latency'],['latency']
Performance,"/**; * The type for the symbol lookup function. This may be called by the; * disassembler for things like adding a comment for a PC plus a constant; * offset load instruction to use a symbol name instead of a load address value.; * It is passed the block information is saved when the disassembler context is; * created and the ReferenceValue to look up as a symbol. If no symbol is found; * for the ReferenceValue NULL is returned. The ReferenceType of the; * instruction is passed indirectly as is the PC of the instruction in; * ReferencePC. If the output reference can be determined its type is returned; * indirectly in ReferenceType along with ReferenceName if any, or that is set; * to NULL.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h:158,load,load,158,interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h,2,['load'],['load']
Performance,"/**; * The type of the remark. For example, it can allow users to only keep the; * missed optimizations from the compiler.; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:90,optimiz,optimizations,90,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,1,['optimiz'],['optimizations']
Performance,"/**; * This class generates a Prefiltered, Mipmapped Radiance Environment Map; * (PMREM) from a cubeMap environment texture. This allows different levels of; * blur to be quickly accessed based on material roughness. It is packed into a; * special CubeUV format that allows us to perform custom interpolation so that; * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap; * chain, it only goes down to the LOD_MIN level (above), and then creates extra; * even more filtered 'mips' at the same LOD_MIN resolution, associated with; * higher roughness levels. In this way we maintain resolution to smoothly; * interpolate diffuse lighting while limiting sampling computation.; *; * Paper: Fast, Accurate Image-Based Lighting; * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:280,perform,perform,280,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['perform']
Performance,"/**; * This dispatch pointer points to an implementation of the compute library, provided one has been loaded.; * Using a virtual call, computation requests are dispatched to backends with architecture-specific functions; * such as SSE, AVX, AVX2, etc.; *; * \see RooBatchComputeInterface, RooBatchComputeClass, RF_ARCH; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooBatchCompute.h:103,load,loaded,103,roofit/batchcompute/res/RooBatchCompute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooBatchCompute.h,1,['load'],['loaded']
Performance,"/**; * This function will search through all previously loaded dynamic; * libraries for the symbol \p symbolName. If it is found, the address of; * that symbol is returned. If not, null is returned.; *; * @see sys::DynamicLibrary::SearchForAddressOfSymbol(); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h:56,load,loaded,56,interpreter/llvm-project/llvm/include/llvm-c/Support.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h,1,['load'],['loaded']
Performance,"/**; * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a; * mip map chain of bloom textures and blurs them with different radii. Because; * of the weighted combination of mips, and because larger blurs are done on; * higher mips, this effect provides good quality and performance.; *; * Reference:; * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:295,perform,performance,295,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['perform'],['performance']
Performance,"/**; * Used to indicate that the translation unit is incomplete.; *; * When a translation unit is considered ""incomplete"", semantic; * analysis that is typically performed at the end of the; * translation unit will be suppressed. For example, this suppresses; * the completion of tentative declarations in C and of; * instantiation of implicitly-instantiation function templates in; * C++. This option is typically used when parsing a header with the; * intent of producing a precompiled header.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:162,perform,performed,162,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['perform'],['performed']
Performance,"/**; * Used to indicate that the translation unit should be built with an; * implicit precompiled header for the preamble.; *; * An implicit precompiled header is used as an optimization when a; * particular translation unit is likely to be reparsed many times; * when the sources aren't changing that often. In this case, an; * implicit precompiled header will be built containing all of the; * initial includes at the top of the main file (what we refer to as; * the ""preamble"" of the file). In subsequent parses, if the; * preamble or the files in it have not changed, \c; * clang_reparseTranslationUnit() will re-use the implicit; * precompiled header to improve parsing performance.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:174,optimiz,optimization,174,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,/**; * Used to indicate that the translation unit should cache some; * code-completion results with each reparse of the source file.; *; * Caching of code-completion results is a performance optimization that; * introduces some overhead to reparsing but improves the performance of; * code-completion operations.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:57,cache,cache,57,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,4,"['cache', 'optimiz', 'perform']","['cache', 'optimization', 'performance']"
Performance,/**; * Used to track LoadClusters calls triggered by ClusterPool::GetCluster; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_cluster.cxx:21,Load,LoadClusters,21,tree/ntuple/v7/test/ntuple_cluster.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_cluster.cxx,1,['Load'],['LoadClusters']
Performance,"/**; * Vertical space ('\\n'), after which it is generally a good idea to; * perform indentation.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:77,perform,perform,77,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['perform'],['perform']
Performance,"/**; * Write temporary object file to SavedObjectDirectoryPath, write symlink; * to Cache directory if needed. Returns the path to the generated file in; * SavedObjectsDirectoryPath.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:84,Cache,Cache,84,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['Cache'],['Cache']
Performance,"/**; * Zstd fits all its internal datastructures into a single continuous buffer,; * so that it only needs to perform a single OS allocation (or so that a buffer; * can be provided to it and it can perform no allocations at all). This buffer; * is called the workspace.; *; * Several optimizations complicate that process of allocating memory ranges; * from this workspace for each internal datastructure:; *; * - These different internal datastructures have different setup requirements:; *; * - The static objects need to be cleared once and can then be trivially; * reused for each compression.; *; * - Various buffers don't need to be initialized at all--they are always; * written into before they're read.; *; * - The matchstate tables have a unique requirement that they don't need; * their memory to be totally cleared, but they do need the memory to have; * some bound, i.e., a guarantee that all values in the memory they've been; * allocated is less than some maximum value (which is the starting value; * for the indices that they will then use for compression). When this; * guarantee is provided to them, they can use the memory without any setup; * work. When it can't, they have to clear the area.; *; * - These buffers also have different alignment requirements.; *; * - We would like to reuse the objects in the workspace for multiple; * compressions without having to perform any expensive reallocation or; * reinitialization work.; *; * - We would like to be able to efficiently reuse the workspace across; * multiple compressions **even when the compression parameters change** and; * we need to resize some of the objects (where possible).; *; * To attempt to manage this buffer, given these constraints, the ZSTD_cwksp; * abstraction was created. It works as follows:; *; * Workspace Layout:; *; * [ ... workspace ... ]; * [objects][tables ... ->] free space [<- ... aligned][<- ... buffers]; *; * The various objects that live in the workspace are divided into the; * following",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h:110,perform,perform,110,builtins/zstd/compress/zstd_cwksp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h,3,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"/**; * \brief A Thread-safe cache for strings.; *; * This is used to generically store strings that are created in the computation; * graph machinery, for example when adding a new node.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:28,cache,cache,28,tree/dataframe/inc/ROOT/RDF/Utils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx,1,['cache'],['cache']
Performance,"/**; * \brief Inserts the input string in the cache and returns an iterator to the cached string.; *; * The function implements the following strategy for thread-safety:; * 1. Take a shared lock and early return if the string is already in the cache.; * 2. Release the shared lock and take an exclusive lock.; * 3. Check again if another thread filled the cache meanwhile. If so, return the cached value.; * 4. Insert the new value in the cache and return.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:46,cache,cache,46,tree/dataframe/inc/ROOT/RDF/Utils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx,6,['cache'],"['cache', 'cached']"
Performance,"/**; * \brief Namespace for new RooFit test statistic calculation.; *; * RooFit::TestStatistics contains a major refactoring of the RooAbsTestStatistic-RooAbsOptTestStatistic-RooNLLVar; * inheritance tree into:; * 1. statistics-based classes on the one hand;; * 2. calculation/evaluation/optimization based classes on the other hand.; *; * The likelihood is the central unit on the statistics side. The RooAbsL class is implemented for four kinds of; * likelihoods: binned, unbinned, ""subsidiary"" (an optimization for numerical stability that gathers components like; * global observables) and ""sum"" (over multiple components of the other types). These classes provide ways to compute; * their components in parallelizable chunks that can be used by the calculator classes as they see fit.; *; * On top of the likelihood classes, we also provide for convenience a likelihood builder buildLikelihood, as a free; * function in the namespace. This function analyzes the pdf and automatically constructs the proper likelihood, built; * up from the available RooAbsL subclasses.; *; * The calculator ""Wrapper"" classes are abstract interfaces. These can be implemented for different kinds of algorithms,; * or with different kinds of optimization ""back-ends"" in mind. In an upcoming PR, we will introduce the fork-based; * multi-processing implementation based on RooFit::MultiProcess. Other possible implementations could use the GPU or; * external tools like TensorFlow.; *; * The coupling of all these classes to RooMinimizer is made via the MinuitFcnGrad class, which owns the Wrappers that; * calculate the likelihood components.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/buildLikelihood.cxx:288,optimiz,optimization,288,roofit/roofitcore/src/TestStatistics/buildLikelihood.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/buildLikelihood.cxx,3,['optimiz'],['optimization']
Performance,"/**; * \brief Sets the border size of the TPave box and shadow; * \param bordersize 0: disable shadow and box, 1: disable only shadow, 2+: tunes the shadow border size; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/inc/TPave.h:139,tune,tunes,139,graf2d/graf/inc/TPave.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/inc/TPave.h,1,['tune'],['tunes']
Performance,"/**; * \class RooBatchComputeInterface; * \ingroup roofit_dev_docs_batchcompute; * \brief The interface which should be implemented to provide optimised computation functions for implementations of; * RooAbsReal::doEval().; *; * The class RooBatchComputeInterface provides the mechanism for external modules (like RooFit) to call; * functions from the library. The power lies in the virtual functions that can resolve to different; * implementations for the functionality; for example, calling a function through dispatchCuda; * will resolve to efficient CUDA implementations.; *; * This interface contains the signatures of the compute functions of every PDF that has an optimised implementation; * available. These are the functions that perform the actual computations in batches.; *; * Several implementations of this interface may be provided, e.g. SSE, AVX, AVX2 etc. At run time, the fastest; * implementation of this interface is selected, and using a virtual call, the computation is dispatched to the best; * backend.; *; * \see RooBatchCompute::dispatch, RooBatchComputeClass, RF_ARCH; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooBatchCompute.h:740,perform,perform,740,roofit/batchcompute/res/RooBatchCompute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooBatchCompute.h,1,['perform'],['perform']
Performance,"/**; * \class TBufferMerger TBufferMerger.hxx; * \ingroup IO; *; * TBufferMerger is a class to facilitate writing data in; * parallel from multiple threads, while writing to a single; * output file. Its purpose is similar to TParallelMergingFile,; * but instead of using processes that connect to a network; * socket, TBufferMerger uses threads that each write to a; * TBufferMergerFile, which in turn push data into a queue; * managed by the TBufferMerger.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/TBufferMerger.hxx:419,queue,queue,419,io/io/inc/ROOT/TBufferMerger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/TBufferMerger.hxx,1,['queue'],['queue']
Performance,"/**; * \class TBufferMergerFile TBufferMerger.hxx; * \ingroup IO; *; * A TBufferMergerFile is similar to a TMemFile, but when data; * is written to it, it is appended to the TBufferMerger queue.; * The TBufferMerger merges all data into the output file on disk.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/TBufferMerger.hxx:188,queue,queue,188,io/io/inc/ROOT/TBufferMerger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/TBufferMerger.hxx,1,['queue'],['queue']
Performance,"/**; * \defgroup Options setters; * @{; */; /**; * \defgroup Cache controlling options; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental build, and thus needs to be persistent accross build.; * The client enabled the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limit the frequency at which the garbage collector; * will try to scan the cache directory to prune it from expired entries.; * Setting to -1 disable the pruning (default). Setting to 0 will force; * pruning to occur.; * - The pruning expiration time indicates to the garbage collector how old; * an entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache till; * the occupied space goes below a threshold.; * @{; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:61,Cache,Cache,61,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,6,"['Cache', 'cache']","['Cache', 'cache']"
Performance,"/**; * g_async_queue_length:; * @queue: a #GAsyncQueue.; * ; * Returns the length of the queue, negative values mean waiting; * threads, positive values mean available entries in the; * @queue. Actually this function returns the number of data items in; * the queue minus the number of waiting threads. Thus a return value; * of 0 could mean 'n' entries in the queue and 'n' thread waiting.; * That can happen due to locking of the queue or due to; * scheduling. ; *; * Return value: the length of the @queue.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:33,queue,queue,33,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,7,['queue'],['queue']
Performance,"/**; * g_async_queue_length_unlocked:; * @queue: a #GAsyncQueue.; * ; * Returns the length of the queue, negative values mean waiting; * threads, positive values mean available entries in the; * @queue. Actually this function returns the number of data items in; * the queue minus the number of waiting threads. Thus a return value; * of 0 could mean 'n' entries in the queue and 'n' thread waiting.; * That can happen due to locking of the queue or due to; * scheduling. This function must be called while holding the @queue's; * lock.; *; * Return value: the length of the @queue.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:42,queue,queue,42,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,8,['queue'],['queue']
Performance,/**; * g_async_queue_lock:; * @queue: a #GAsyncQueue.; * ; * Acquire the @queue's lock. After that you can only call the; * g_async_queue_*_unlocked function variants on that; * @queue. Otherwise it will deadlock.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:31,queue,queue,31,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,3,['queue'],['queue']
Performance,/**; * g_async_queue_new:; * ; * Creates a new asynchronous queue with the initial reference count of 1.; * ; * Return value: the new #GAsyncQueue.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:60,queue,queue,60,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,1,['queue'],['queue']
Performance,/**; * g_async_queue_pop:; * @queue: a #GAsyncQueue.; * ; * Pop data from the @queue. This function blocks until data become; * available.; *; * Return value: data from the queue.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:30,queue,queue,30,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,3,['queue'],['queue']
Performance,/**; * g_async_queue_pop_unlocked:; * @queue: a #GAsyncQueue.; * ; * Pop data from the @queue. This function blocks until data become; * available. This function must be called while holding the @queue's; * lock.; *; * Return value: data from the queue.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:39,queue,queue,39,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,4,['queue'],['queue']
Performance,/**; * g_async_queue_push:; * @queue: a #GAsyncQueue.; * @data: @data to push into the @queue.; *; * Push the @data into the @queue. @data must not be #NULL.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:31,queue,queue,31,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,3,['queue'],['queue']
Performance,/**; * g_async_queue_push_unlocked:; * @queue: a #GAsyncQueue.; * @data: @data to push into the @queue.; * ; * Push the @data into the @queue. @data must not be #NULL. This; * function must be called while holding the @queue's lock.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:40,queue,queue,40,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,4,['queue'],['queue']
Performance,/**; * g_async_queue_ref:; * @queue: a #GAsyncQueue.; *; * Increases the reference count of the asynchronous @queue by 1.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:30,queue,queue,30,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,2,['queue'],['queue']
Performance,/**; * g_async_queue_ref_unlocked:; * @queue: a #GAsyncQueue.; * ; * Increases the reference count of the asynchronous @queue by 1. This; * function must be called while holding the @queue's lock.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:39,queue,queue,39,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,3,['queue'],['queue']
Performance,"/**; * g_async_queue_timed_pop:; * @queue: a #GAsyncQueue.; * @end_time: a #GTimeVal, determining the final time.; *; * Pop data from the @queue. If no data is received before @end_time,; * #NULL is returned.; *; * To easily calculate @end_time a combination of g_get_current_time(); * and g_time_val_add() can be used.; *; * Return value: data from the queue or #NULL, when no data is; * received before @end_time.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:36,queue,queue,36,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,3,['queue'],['queue']
Performance,"/**; * g_async_queue_timed_pop_unlocked:; * @queue: a #GAsyncQueue.; * @end_time: a #GTimeVal, determining the final time.; *; * Pop data from the @queue. If no data is received before @end_time,; * #NULL is returned. This function must be called while holding the; * @queue's lock.; *; * To easily calculate @end_time a combination of g_get_current_time(); * and g_time_val_add() can be used.; *; * Return value: data from the queue or #NULL, when no data is; * received before @end_time.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:45,queue,queue,45,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,4,['queue'],['queue']
Performance,"/**; * g_async_queue_try_pop:; * @queue: a #GAsyncQueue.; * ; * Try to pop data from the @queue. If no data is available, #NULL is; * returned.; *; * Return value: data from the queue or #NULL, when no data is; * available immediately.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:34,queue,queue,34,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,3,['queue'],['queue']
Performance,"/**; * g_async_queue_try_pop_unlocked:; * @queue: a #GAsyncQueue.; * ; * Try to pop data from the @queue. If no data is available, #NULL is; * returned. This function must be called while holding the @queue's; * lock.; *; * Return value: data from the queue or #NULL, when no data is; * available immediately.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:43,queue,queue,43,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,4,['queue'],['queue']
Performance,/**; * g_async_queue_unlock:; * @queue: a #GAsyncQueue.; * ; * Release the queue's lock.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:33,queue,queue,33,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,2,['queue'],['queue']
Performance,"/**; * g_async_queue_unref:; * @queue: a #GAsyncQueue.; * ; * Decreases the reference count of the asynchronous @queue by 1. If; * the reference count went to 0, the @queue will be destroyed and the; * memory allocated will be freed. So you are not allowed to use the; * @queue afterwards, as it might have disappeared.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:32,queue,queue,32,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,4,['queue'],['queue']
Performance,"/**; * g_async_queue_unref_and_unlock:; * @queue: a #GAsyncQueue.; * ; * Decreases the reference count of the asynchronous @queue by 1 and; * releases the lock. This function must be called while holding the; * @queue's lock. If the reference count went to 0, the @queue will be; * destroyed and the memory allocated will be freed. So you are not; * allowed to use the @queue afterwards, as it might have disappeared.; * The obvious asymmetry (it is not named; * g_async_queue_unref_unlocked) is because the queue can't be; * unlocked after dereffing it, as it might already have disappeared.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:43,queue,queue,43,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,6,['queue'],['queue']
Performance,"/**; * g_find_program_in_path:; * @program: a program name; * ; * Locates the first executable named @program in the user's path, in the; * same way that execvp() would locate it. Returns an allocated string; * with the absolute path name, or NULL if the program is not found in; * the path. If @program is already an absolute path, returns a copy of; * @program if @program exists and is executable, and NULL otherwise.; * ; * On Windows, if @program does not have a file type suffix, tries to; * append the suffixes in the PATHEXT environment variable (if that; * doesn't exists, the suffixes .com, .exe, and .bat) in turn, and; * then look for the resulting file name in the same way as; * CreateProcess() would. This means first in the directory where the; * program was loaded from, then in the current directory, then in the; * Windows 32-bit system directory, then in the Windows directory, and; * finally in the directories in the PATH environment variable. If; * the program is found, the return value contains the full name; * including the type suffix.; *; * Return value: absolute path, or NULL; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutils.c:775,load,loaded,775,graf2d/win32gdk/gdk/src/glib/gutils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutils.c,1,['load'],['loaded']
Performance,"/**; * g_io_channel_get_flags:; * @channel: a #GIOChannel; *; * Gets the current flags for a #GIOChannel, including read-only; * flags such as %G_IO_FLAG_IS_READABLE.; *; * The values of the flags %G_IO_FLAG_IS_READABLE and %G_IO_FLAG_IS_WRITEABLE; * are cached for internal use by the channel when it is created.; * If they should change at some later point (e.g. partial shutdown; * of a socket with the unix shutdown () function), the user; * should immediately call g_io_channel_get_flags () to update; * the internal values of these flags.; *; * Return value: the flags which are set on the channel; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c:255,cache,cached,255,graf2d/win32gdk/gdk/src/glib/giochannel.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c,1,['cache'],['cached']
Performance,"/**; * g_shell_parse_argv:; * @command_line: command line to parse; * @argcp: return location for number of args; * @argvp: return location for array of args; * @error: return location for error; * ; * Parses a command line into an argument vector, in much the same way; * the shell would, but without many of the expansions the shell would; * perform (variable expansion, globs, operators, filename expansion,; * etc. are not supported). The results are defined to be the same as; * those you would get from a UNIX98 /bin/sh, as long as the input; * contains none of the unsupported shell expansions. If the input; * does contain such expansions, they are passed through; * literally. Possible errors are those from the #G_SHELL_ERROR; * domain.; * ; * Return value: TRUE on success, FALSE if error set; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gshell.c:344,perform,perform,344,graf2d/win32gdk/gdk/src/glib/gshell.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gshell.c,1,['perform'],['perform']
Performance,"/**; * g_thread_pool_new: ; * @func: a function to execute in the threads of the new thread pool; * @user_data: user data that is handed over to @func every time it ; * is called; * @max_threads: the maximal number of threads to execute concurrently in ; * the new thread pool, -1 means no limit; * @exclusive: should this thread pool be exclusive?; * @error: return location for error; *; * This function creates a new thread pool.; *; * Whenever you call g_thread_pool_push(), either a new thread is; * created or an unused one is reused. At most @max_threads threads; * are running concurrently for this thread pool. @max_threads = -1; * allows unlimited threads to be created for this thread pool. The; * newly created or reused thread now executes the function @func with; * the two arguments. The first one is the parameter to; * g_thread_pool_push() and the second one is @user_data.; *; * The parameter @exclusive determines, whether the thread pool owns; * all threads exclusive or whether the threads are shared; * globally. If @exclusive is @TRUE, @max_threads threads are started; * immediately and they will run exclusively for this thread pool until; * it is destroyed by g_thread_pool_free(). If @exclusive is @FALSE,; * threads are created, when needed and shared between all; * non-exclusive thread pools. This implies that @max_threads may not; * be -1 for exclusive thread pools.; *; * @error can be NULL to ignore errors, or non-NULL to report; * errors. An error can only occur, when @exclusive is set to @TRUE and; * not all @max_threads threads could be created.; *; * Return value: the new #GThreadPool; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c:237,concurren,concurrently,237,graf2d/win32gdk/gdk/src/glib/gthreadpool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c,2,['concurren'],['concurrently']
Performance,"/**; * g_thread_pool_push:; * @pool: a #GThreadPool; * @data: a new task for @pool; * @error: return location for error; * ; * Inserts @data into the list of tasks to be executed by @pool. When; * the number of currently running threads is lower than the maximal; * allowed number of threads, a new thread is started (or reused) with; * the properties given to g_thread_pool_new (). Otherwise @data stays; * in the queue until a thread in this pool finishes its previous task; * and processes @data. ; *; * @error can be NULL to ignore errors, or non-NULL to report; * errors. An error can only occur, when a new thread couldn't be; * created. In that case @data is simply appended to the queue of work; * to do. ; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c:415,queue,queue,415,graf2d/win32gdk/gdk/src/glib/gthreadpool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c,2,['queue'],['queue']
Performance,"/**; * g_tree_search:; * @tree: a #GTree.; * @search_func: the comparison function used to search the #GTree. ; * @user_data: the data passed as the second argument to the @search_func ; * function.; * ; * Searches a #GTree using an alternative form of the comparison function.; *; * This function is not as useful as it sounds.; * It allows you to use a different function for performing the lookup of; * a key. However, since the tree is ordered according to the @key_compare_func; * function passed to g_tree_new(), the function you pass to g_tree_search() ; * must return exactly the same value as would be returned by the comparison ; * function, for each pair of tree nodes, or the search will not work.; * ; * To search for a specific value, you can use g_tree_foreach() or ; * g_tree_traverse().; *; * Return value: the value corresponding to the found key, or NULL if the key ; * is not found.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gtree.c:378,perform,performing,378,graf2d/win32gdk/gdk/src/glib/gtree.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gtree.c,1,['perform'],['performing']
Performance,"/**; * g_utf8_normalize:; * @str: a UTF-8 encoded string.; * @len: length of @str, in bytes, or -1 if @str is nul-terminated.; * @mode: the type of normalization to perform.; * ; * Converts a string into canonical form, standardizing; * such issues as whether a character with an accent; * is represented as a base character and combining; * accent or as a single precomposed character. You; * should generally call g_utf8_normalize() before; * comparing two Unicode strings.; *; * The normalization mode %G_NORMALIZE_DEFAULT only; * standardizes differences that do not affect the; * text content, such as the above-mentioned accent; * representation. %G_NORMALIZE_ALL also standardizes; * the ""compatibility"" characters in Unicode, such; * as SUPERSCRIPT THREE to the standard forms; * (in this case DIGIT THREE). Formatting information; * may be lost but for most text operations such; * characters should be considered the same.; * For example, g_utf8_collate() normalizes; * with %G_NORMALIZE_ALL as its first step.; *; * %G_NORMALIZE_DEFAULT_COMPOSE and %G_NORMALIZE_ALL_COMPOSE; * are like %G_NORMALIZE_DEFAULT and %G_NORMALIZE_ALL,; * but returned a result with composed forms rather; * than a maximally decomposed form. This is often; * useful if you intend to convert the string to; * a legacy encoding or pass it to a system with; * less capable Unicode handling.; * ; * Return value: a newly allocated string, that is the ; * normalized form of @str.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gunidecomp.c:165,perform,perform,165,graf2d/win32gdk/gdk/src/glib/gunidecomp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gunidecomp.c,1,['perform'],['perform']
Performance,"/**; * g_win32_get_package_installation_directory:; * @package: An identifier for a software package, or NULL; * @dll_name: The name of a DLL that a package provides, or NULL; *; * Try to determine the installation directory for a software package.; * Typically used by GNU software packages.; *; * @package should be a short identifier for the package. Typically it; * is the same identifier as used for GETTEXT_PACKAGE in software; * configured accoring to GNU standards. The function first looks in; * the Windows Registry for the value #InstallationDirectory in the; * key #HKLM\Software\@package, and if that value exists and is a; * string, returns that.; *; * If @package is NULL, or the above value isn't found in the; * Registry, but @dll_name is non-NULL, it should name a DLL loaded; * into the current process. Typically that would be the name of the; * DLL calling this function, looking for its installation; * directory. The function then asks Windows what directory that DLL; * was loaded from. If that directory's last component is ""bin"" or; * ""lib"", the parent directory is returned, otherwise the directory; * itself. If that DLL isn't loaded, the function proceeds as if; * @dll_name was NULL.; *; * If both @package and @dll_name are NULL, the directory from where; * the main executable of the process was loaded is uses instead in; * the same way as above.; *; * The return value should be freed with g_free() when not needed any longer. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gwin32.c:787,load,loaded,787,graf2d/win32gdk/gdk/src/glib/gwin32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gwin32.c,4,['load'],['loaded']
Performance,/**; * libclang crashed while performing the requested operation.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:30,perform,performing,30,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,1,['perform'],['performing']
Performance,"/**; @defgroup FitMain User Fitting classes. Main Classes used for fitting a given data set; @ingroup Fit; */; //___________________________________________________________________________________; /**; Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h:233,perform,performing,233,math/mathcore/inc/Fit/Fitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h,2,['perform'],"['performed', 'performing']"
Performance,"/**; @defgroup MCIntegration Numerical Monte Carlo Integration Classes; Classes implementing method for Monte Carlo Integration.; @ingroup Integration. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMCIntegrator.h:162,perform,performing,162,math/mathmore/inc/Math/GSLMCIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMCIntegrator.h,1,['perform'],['performing']
Performance,"/**; Assign from a linear algebra matrix of size at least 4x4,; which must support operator()(i,j) to obtain elements (0,3) thru (3,3).; Precondition: The matrix is assumed to be orthosymplectic. NO checking; or re-adjusting is performed.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzRotation.h:228,perform,performed,228,math/genvector/inc/Math/GenVector/LorentzRotation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzRotation.h,1,['perform'],['performed']
Performance,"/**; Construct from a linear algebra matrix of size at least 3x3,; which must support operator()(i,j) to obtain elements (0,0) thru (2,2).; Precondition: The matrix is assumed to be orthonormal. No checking; or re-adjusting is performed.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Rotation3D.h:227,perform,performed,227,math/genvector/inc/Math/GenVector/Rotation3D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Rotation3D.h,1,['perform'],['performed']
Performance,"/**; Construct from a linear algebra matrix of size at least 4x4,; which must support operator()(i,j) to obtain elements (0,3) thru (3,3).; Precondition: The matrix is assumed to be orthosymplectic. NO checking; or re-adjusting is performed.; Note: (0,0) refers to the XX component; (3,3) refers to the TT component.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzRotation.h:231,perform,performed,231,math/genvector/inc/Math/GenVector/LorentzRotation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzRotation.h,1,['perform'],['performed']
Performance,"/**; Constructor from the function object , dimension of the function and; and coordinate we want to adapt.; The coordinate cached vector is created inside and eventually the values must be passed; later with the SetX which will copy them; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/OneDimFunctionAdapter.h:124,cache,cached,124,math/mathcore/inc/Math/OneDimFunctionAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/OneDimFunctionAdapter.h,1,['cache'],['cached']
Performance,/**; Evaluate all derivatives using cached parameter values (multi-dim like interface); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IParamFunction.h:36,cache,cached,36,math/mathcore/inc/Math/IParamFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IParamFunction.h,1,['cache'],['cached']
Performance,/**; Evaluate all derivatives using cached parameter values; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IParamFunction.h:36,cache,cached,36,math/mathcore/inc/Math/IParamFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IParamFunction.h,2,['cache'],['cached']
Performance,/**; Evaluate partial derivative using cached parameter values (multi-dim like interface); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IParamFunction.h:39,cache,cached,39,math/mathcore/inc/Math/IParamFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IParamFunction.h,1,['cache'],['cached']
Performance,/**; Evaluate partial derivative using cached parameter values; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IParamFunction.h:39,cache,cached,39,math/mathcore/inc/Math/IParamFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IParamFunction.h,2,['cache'],['cached']
Performance,"/**; Finds a minimum of a function, if the function is unimodal between xmin and xmax; This method uses a combination of golden section search and parabolic interpolation; Details about convergence and properties of this algorithm can be; found in the book by R.P.Brent ""Algorithms for Minimization Without Derivatives""; or in the ""Numerical Recipes"", chapter 10.2; convergence is reached using tolerance = 2 *( epsrel * abs(x) + epsabs). type: 0-returns MinimumX; 1-returns Minimum; 2-returns MaximumX; 3-returns Maximum; 4-returns X corresponding to fy. if ok=true the method has converged.; Maxiter returns the actual number of iteration performed. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/BrentMethods.h:641,perform,performed,641,math/mathcore/inc/Math/BrentMethods.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/BrentMethods.h,1,['perform'],['performed']
Performance,/**; Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IParamFunction.h:83,cache,cached,83,math/mathcore/inc/Math/IParamFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IParamFunction.h,1,['cache'],['cached']
Performance,/**; Implement the ROOT::Math::IBaseFunctionOneDim interface DoEval(x) using the cached parameter values; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IParamFunction.h:81,cache,cached,81,math/mathcore/inc/Math/IParamFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IParamFunction.h,1,['cache'],['cached']
Performance,"/**; Initialize method for the Binomial distribution.; Used to generate poisson numbers for a constant parameters (n,p) of the Binomial distribution.; Use after the method TUnuran::SampleDiscr to generate the numbers.; The flag reinit perform a fast re-initialization when only the distribution parameters; are changed in the subsequent calls.; If the same TUnuran object is used to generate with other distributions it cannot be used.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/inc/TUnuran.h:235,perform,perform,235,math/unuran/inc/TUnuran.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/inc/TUnuran.h,1,['perform'],['perform']
Performance,/**; Initialize method for the Poisson distribution.; Used to generate poisson numbers for a constant parameter mu of the Poisson distribution.; Use after the method TUnuran::SampleDiscr to generate the numbers.; The flag reinit perform a fast re-initialization when only the distribution parameters; are changed in the subsequent calls.; If the same TUnuran object is used to generate with other distributions it cannot be used.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/inc/TUnuran.h:229,perform,perform,229,math/unuran/inc/TUnuran.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/inc/TUnuran.h,1,['perform'],['perform']
Performance,"/**; Introduction. LZ4 is lossless compression algorithm, providing compression speed >500 MB/s per core,; scalable with multi-cores CPU. It features an extremely fast decoder, with speed in; multiple GB/s per core, typically reaching RAM speed limits on multi-core systems. The LZ4 compression library provides in-memory compression and decompression functions.; It gives full buffer control to user.; Compression can be done in:; - a single step (described as Simple Functions); - a single step, reusing a context (described in Advanced Functions); - unbounded multiple steps (described as Streaming compression). lz4.h generates and decodes LZ4-compressed blocks (doc/lz4_Block_format.md).; Decompressing such a compressed block requires additional metadata.; Exact metadata depends on exact decompression function.; For the typical case of LZ4_decompress_safe(),; metadata includes block's compressed size, and maximum bound of decompressed size.; Each application is free to encode and pass such metadata in whichever way it wants. lz4.h only handle blocks, it can not generate Frames. Blocks are different from Frames (doc/lz4_Frame_format.md).; Frames bundle both blocks and metadata in a specified manner.; Embedding metadata is required for compressed data to be self-contained and portable.; Frame format is delivered through a companion API, declared in lz4frame.h.; The `lz4` CLI can only manage frames.; */; /*^***************************************************************; * Export parameters; *****************************************************************/; /*; * LZ4_DLL_EXPORT :; * Enable exporting of functions when building a Windows DLL; * LZ4LIB_VISIBILITY :; * Control library symbols visibility.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:107,scalab,scalable,107,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['scalab'],['scalable']
Performance,"/**; Inversion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successful.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/SMatrix.h:484,perform,performing,484,math/smatrix/inc/Math/SMatrix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/SMatrix.h,1,['perform'],['performing']
Performance,/**; Method to load an R's package; \param pkg R's pkg name; \return true or false if the package was loaded or not; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/inc/TRInterface.h:15,load,load,15,bindings/r/inc/TRInterface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/inc/TRInterface.h,2,['load'],"['load', 'loaded']"
Performance,/**; MinimTransformFunction class to perform a transformations on the; variables to deal with fixed or limited variables (support both double and single bounds); The class manages the passed function pointer. @ingroup MultiMin; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimTransformFunction.h:37,perform,perform,37,math/mathcore/inc/Math/MinimTransformFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimTransformFunction.h,1,['perform'],['perform']
Performance,/**; Optimized method to evaluate at the same time the function value and derivative at a point x.; Implement the interface specified by ROOT::Math::IGradientOneDim.; In the case of polynomial there is no advantage to compute both at the same time; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Polynomial.h:5,Optimiz,Optimized,5,math/mathmore/inc/Math/Polynomial.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Polynomial.h,1,['Optimiz'],['Optimized']
Performance,/**; Perform a fit with the previously set FCN function. Require SetFCN before; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h:5,Perform,Perform,5,math/mathcore/inc/Fit/Fitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h,1,['Perform'],['Perform']
Performance,/**; Perform a minimizer iteration and; if an unexpected problem occurs then an error code will be returned; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMinimizer1D.h:5,Perform,Perform,5,math/mathmore/inc/Math/GSLMinimizer1D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMinimizer1D.h,1,['Perform'],['Perform']
Performance,/**; Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h:5,Perform,Perform,5,math/mathcore/inc/Fit/Fitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h,1,['Perform'],['Perform']
Performance,/**; Perform a single iteration and return the Status; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/RootFinder.h:5,Perform,Perform,5,math/mathcore/inc/Math/RootFinder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/RootFinder.h,1,['Perform'],['Perform']
Performance,"/**; Performs the Anderson-Darling 1-Sample Test.; The Anderson-Darling 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andedarl.htm; and described and taken from (2); Marsaglia J.C.W., Marsaglia G. (2004), Evaluating the Anderson-Darling Distribution, Journal of Statistical Software, Volume 09, Issue i02.; and described and taken from (3); Lewis P.A.W. (1961), The Annals of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GoFTest.h:5,Perform,Performs,5,math/mathcore/inc/Math/GoFTest.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GoFTest.h,1,['Perform'],['Performs']
Performance,/**; Return cached Value of function Gradient estimated previously using the FumiliFCNBase::EvaluateAll method; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FumiliFCNBase.h:12,cache,cached,12,math/minuit2/inc/Minuit2/FumiliFCNBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FumiliFCNBase.h,1,['cache'],['cached']
Performance,/**; Return cached Value of objective function estimated previously using the FumiliFCNBase::EvaluateAll method. **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FumiliFCNBase.h:12,cache,cached,12,math/minuit2/inc/Minuit2/FumiliFCNBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FumiliFCNBase.h,1,['cache'],['cached']
Performance,/**; Return the number of iteration performed to find the Root.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/RootFinder.h:36,perform,performed,36,math/mathcore/inc/Math/RootFinder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/RootFinder.h,1,['perform'],['performed']
Performance,/**; Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x() and y() member functions; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/DisplacementVector2D.h:72,perform,perform,72,math/genvector/inc/Math/GenVector/DisplacementVector2D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/DisplacementVector2D.h,1,['perform'],['perform']
Performance,"/**; Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/DisplacementVector3D.h:72,perform,perform,72,math/genvector/inc/Math/GenVector/DisplacementVector3D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/DisplacementVector3D.h,1,['perform'],['perform']
Performance,"/**; Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/DisplacementVector3D.h:136,perform,perform,136,math/genvector/inc/Math/GenVector/DisplacementVector3D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/DisplacementVector3D.h,1,['perform'],['perform']
Performance,"/**; Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/DisplacementVector3D.h:123,perform,perform,123,math/genvector/inc/Math/GenVector/DisplacementVector3D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/DisplacementVector3D.h,1,['perform'],['perform']
Performance,"/**; Set components from a linear algebra matrix of size at least 3x3,; which must support operator()(i,j) to obtain elements (0,0) thru (2,2).; Precondition: The matrix is assumed to be orthonormal. NO checking; or re-adjusting is performed.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Rotation3D.h:232,perform,performed,232,math/genvector/inc/Math/GenVector/Rotation3D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Rotation3D.h,1,['perform'],['performed']
Performance,"/**; Set components from a linear algebra matrix of size at least 4x4,; which must support operator()(i,j) to obtain elements (0,0) thru (3,3).; Precondition: The matrix is assumed to be orthosymplectic. NO checking; or re-adjusting is performed.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzRotation.h:236,perform,performed,236,math/genvector/inc/Math/GenVector/LorentzRotation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzRotation.h,1,['perform'],['performed']
Performance,/**; Set integration function from a multi-dim function type.; Can be used in case of having 1D function implementing the generic interface; @param f integration function; @param icoord index of coordinate on which the integration is performed; @param x array of the passed variables values. In case of dim=1 a 0 can be passed; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h:234,perform,performed,234,math/mathcore/inc/Math/Integrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h,1,['perform'],['performed']
Performance,"/**; Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Interpolator.h:194,perform,performed,194,math/mathmore/inc/Math/Interpolator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Interpolator.h,1,['perform'],['performed']
Performance,"/**; Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Interpolator.h:203,perform,performed,203,math/mathmore/inc/Math/Interpolator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Interpolator.h,1,['perform'],['performed']
Performance,/**; Specialization for symmetric matrices.; Evaluate the expression performing a -= operation for symmetric matrices; Need to have a separate functions to avoid to modify two times the off-diagonal; elements (i.e applying two times the expression); Need to check whether creating a temporary object with the expression result; (like in op: A -= A + B ); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/HelperOps.h:69,perform,performing,69,math/smatrix/inc/Math/HelperOps.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/HelperOps.h,1,['perform'],['performing']
Performance,/**; Specialization for symmetric matrices; Evaluate the expression performing a += operation for symmetric matrices; Need to have a separate functions to avoid to modify two times the off-diagonal; elements (i.e applying two times the expression); Need to check whether creating a temporary object with the expression result; (like in op: A += A * B ); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/HelperOps.h:68,perform,performing,68,math/smatrix/inc/Math/HelperOps.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/HelperOps.h,1,['perform'],['performing']
Performance,"/**; The command line arguments are by default argc=0 and argv=NULL,; The verbose mode is by default disabled but you can enable it to show procedures information in stdout/stderr \note some time can produce so much noise in the output; \param argc default 0; \param argv default null; \param loadRcpp default true; \param verbose default false; \param interactive default true; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/inc/TRInterface.h:293,load,loadRcpp,293,bindings/r/inc/TRInterface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/inc/TRInterface.h,1,['load'],['loadRcpp']
Performance,/**; Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h:89,perform,performed,89,math/mathcore/inc/Fit/FitResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h,1,['perform'],['performed']
Performance,"/**; Wrapper class to FCNBase interface used internally by Minuit.; Apply conversion from calling the function from a Minuit Vector (MnAlgebraicVector) to a std::vector for; the function coordinates.; The class counts also the number of function calls. By default counter start from zero, but a different value; might be given if the class is instantiated later on, for example for a set of different minimizaitons; Normally the derived class MnUserFCN should be instantiated with performs in addition the transformatiopn; internal-> external parameters; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnFcn.h:481,perform,performs,481,math/minuit2/inc/Minuit2/MnFcn.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnFcn.h,1,['perform'],['performs']
Performance,/**; \brief Perform a vector read operation on multiple objects.; \param map A `MultiObjectRWOperation_t` that describes read operations to perform.; \param cid An object class ID.; \return Number of operations that could not complete.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:12,Perform,Perform,12,tree/ntuple/v7/inc/ROOT/RDaos.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx,2,"['Perform', 'perform']","['Perform', 'perform']"
Performance,/**; \brief Perform a vector read/write operation on different objects.; \param map A `MultiObjectRWOperation_t` that describes read/write operations to perform.; \param cid The `daos_oclass_id_t` used to qualify OIDs.; \param fn Either `&RDaosObject::Fetch` (read) or `&RDaosObject::Update` (write).; \return 0 if the operation succeeded; a negative DAOS error number otherwise.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:12,Perform,Perform,12,tree/ntuple/v7/inc/ROOT/RDaos.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx,2,"['Perform', 'perform']","['Perform', 'perform']"
Performance,/**; \brief Perform a vector write operation on multiple objects.; \param map A `MultiObjectRWOperation_t` that describes write operations to perform.; \param cid An object class ID.; \return Number of operations that could not complete.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:12,Perform,Perform,12,tree/ntuple/v7/inc/ROOT/RDaos.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx,2,"['Perform', 'perform']","['Perform', 'perform']"
Performance,"/**; \class RHistConcurrentFillManager; Manages the synchronization of calls to FillN(). The HIST template can be a RHist instance. This class hands out; RHistConcurrentFiller objects that can concurrently fill the histogram. They; buffer calls to Fill() until the buffer is full, and then swap the buffer; with that of the RHistConcurrentFillManager. The manager than fills the; histogram.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistConcurrentFill.hxx:193,concurren,concurrently,193,hist/histv7/inc/ROOT/RHistConcurrentFill.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistConcurrentFill.hxx,1,['concurren'],['concurrently']
Performance,/**; \class RHistConcurrentFiller; Buffers a thread's Fill calls and submits them to the; RHistConcurrentFillManager. Enables multi-threaded filling.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistConcurrentFill.hxx:126,multi-thread,multi-threaded,126,hist/histv7/inc/ROOT/RHistConcurrentFill.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistConcurrentFill.hxx,1,['multi-thread'],['multi-threaded']
Performance,/**; \class ROOT::Experimental::TTaskGroup; \ingroup Parallelism; \brief A class to manage the asynchronous execution of work items. A TTaskGroup represents concurrent execution of a group of tasks. Tasks may be dynamically added to the group as it; is executing.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TTaskGroup.hxx:157,concurren,concurrent,157,core/imt/inc/ROOT/TTaskGroup.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TTaskGroup.hxx,1,['concurren'],['concurrent']
Performance,/**; \class ROOT::Experimental::TTaskGroup; \ingroup Parallelism; \brief A class to manage the asynchronous execution of work items. A TTaskGroup represents concurrent execution of a group of tasks.; Tasks may be dynamically added to the group as it is executing.; Nesting TTaskGroup instances may result in a runtime overhead.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TTaskGroup.cxx:157,concurren,concurrent,157,core/imt/src/TTaskGroup.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TTaskGroup.cxx,1,['concurren'],['concurrent']
Performance,/**; \class TGenMapProxy; \ingroup IO; Localoptimization class. Collection proxies get copied. On copy we switch the type of the; proxy to the concrete STL type. The concrete types are optimized; for element access.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionProxy.cxx:185,optimiz,optimized,185,io/io/src/TGenCollectionProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionProxy.cxx,1,['optimiz'],['optimized']
Performance,/**; \class TGenSetProxy; \ingroup IO; Localoptimization class. Collection proxies get copied. On copy we switch the type of the; proxy to the concrete STL type. The concrete types are optimized; for element access.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionProxy.cxx:185,optimiz,optimized,185,io/io/src/TGenCollectionProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionProxy.cxx,1,['optimiz'],['optimized']
Performance,/**; \class TGenVectorBoolProxy; \ingroup IO; Local optimization class. Collection proxies get copied. On copy we switch the type of the; proxy to the concrete STL type. The concrete types are optimized; for element access.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionProxy.cxx:52,optimiz,optimization,52,io/io/src/TGenCollectionProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionProxy.cxx,2,['optimiz'],"['optimization', 'optimized']"
Performance,/**; \class TGenVectorProxy; \ingroup IO; Local optimization class. Collection proxies get copied. On copy we switch the type of the; proxy to the concrete STL type. The concrete types are optimized; for element access.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionProxy.cxx:48,optimiz,optimization,48,io/io/src/TGenCollectionProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionProxy.cxx,2,['optimiz'],"['optimization', 'optimized']"
Performance,/**; \file Initialisation.cxx; \ingroup Roofitcore; Run static initialisers on first load of RooFitCore.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/Initialisation.cxx:85,load,load,85,roofit/roofitcore/src/Initialisation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/Initialisation.cxx,1,['load'],['load']
Performance,"/**; \file RooAbsSelfCachedReal.h; \class RooAbsSelfCached; \ingroup Roofitcore. Abstract base class for functions whose; output is cached in terms of a histogram in all observables between; getVal() and evaluate(). For certain p.d.f.s that are very; expensive to calculate it may be beneficial to implement them as a; RooAbsSelfCached rather than a RooAbsReal/Pdf. Class; RooAbsSelfCached is designed to have its interface identical to; that of RooAbsReal/Pdf, so any p.d.f can make use of its caching; functionality by merely switching its base class. Existing; RooAbsReal/Pdf objects can also be cached a posteriori with the; RooCachedReal/Pdf wrapper function that takes any RooAbsReal/Pdf object as; input.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsSelfCachedReal.h:132,cache,cached,132,roofit/roofitcore/inc/RooAbsSelfCachedReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsSelfCachedReal.h,2,['cache'],['cached']
Performance,/**; class performing the numerical gradient calculation; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/Numerical2PGradientCalculator.h:11,perform,performing,11,math/minuit2/inc/Minuit2/Numerical2PGradientCalculator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/Numerical2PGradientCalculator.h,1,['perform'],['performing']
Performance,/**; fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface.; Note that both the input data and the function object are copied by the Fitter.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h:98,perform,performed,98,math/mathcore/inc/Fit/Fitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h,1,['perform'],['performed']
Performance,"/**; get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arranged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; The intervals can be corrected optionally using the chi2/ndf value of the fit if a chi2 fit is performed.; This has changed since ROOT 6.14, before the interval were corrected by default.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h:648,perform,performed,648,math/mathcore/inc/Fit/FitResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h,1,['perform'],['performed']
Performance,"/**; get the minos error for parameter i, return false if Minos failed; A minimizaiton must be performed befre, return false if no minimization has been done; In case of Minos failed the status error is updated as following; status += 10 * minosStatus.; The Minos status of last Minos run can also be retrieved by calling MinosStatus(); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/Minuit2Minimizer.h:95,perform,performed,95,math/minuit2/inc/Minuit2/Minuit2Minimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/Minuit2Minimizer.h,1,['perform'],['performed']
Performance,"/**; method to perform the minimization.; Return false in case the minimization did not converge. In this case a; status code different than zero is set; (retrieved by the derived method Minimizer::Status() )"". status = 1 : Covariance was made pos defined; status = 2 : Hesse is invalid; status = 3 : Edm is above max; status = 4 : Reached call limit; status = 5 : Any other failure; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/Minuit2Minimizer.h:15,perform,perform,15,math/minuit2/inc/Minuit2/Minuit2Minimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/Minuit2Minimizer.h,1,['perform'],['perform']
Performance,/**; perform a full calculation of the Hessian matrix for error calculation; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Minimizer.cxx:5,perform,perform,5,math/mathcore/src/Minimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Minimizer.cxx,2,['perform'],['perform']
Performance,/**; perform a full calculation of the Hessian matrix for error calculation; If a valid minimum exists the calculation is done on the minimum point otherwise is performed; in the current set values of parameters; Status code of minimizer is updated according to the following convention (in case Hesse failed); status += 100*hesseStatus where hesse status is:; status = 1 : hesse failed; status = 2 : matrix inversion failed; status = 3 : matrix is not pos defined; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/Minuit2Minimizer.h:5,perform,perform,5,math/minuit2/inc/Minuit2/Minuit2Minimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/Minuit2Minimizer.h,2,['perform'],"['perform', 'performed']"
Performance,/**; perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indices can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h:5,perform,perform,5,math/mathcore/inc/Fit/Fitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h,1,['perform'],['perform']
Performance,/**; perform an error analysis on the result using the Hessian; Errors are obtained from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h:5,perform,perform,5,math/mathcore/inc/Fit/Fitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h,1,['perform'],['perform']
Performance,/**; return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer is guaranteed to be valid as far as the fitter class is valid and a new fit is not redone.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h:281,perform,performing,281,math/mathcore/inc/Fit/Fitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h,1,['perform'],['performing']
Performance,/**; return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the fitter class; has not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h:261,perform,performing,261,math/mathcore/inc/Fit/Fitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h,1,['perform'],['performing']
Performance,/**< A load or store which is not atomic */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:7,load,load,7,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['load'],['load']
Performance,/**< Acquire provides a barrier of the sort; necessary to acquire a lock to access other; memory with normal loads and stores. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:109,load,loads,109,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['load'],['loads']
Performance,/**< Scalable SIMD vector type */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:5,Scalab,Scalable,5,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['Scalab'],['Scalable']
Performance,"/**< library version string; useful to check dll version */; /*-************************************; * Tuning parameter; **************************************/; /*!; * LZ4_MEMORY_USAGE :; * Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.); * Increasing memory usage improves compression ratio.; * Reduced memory usage may improve speed, thanks to better cache locality.; * Default value is 14, for 16KB, which nicely fits into Intel x86 L1 cache; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:407,cache,cache,407,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,2,['cache'],['cache']
Performance,"/**< provides Acquire semantics; for loads and Release; semantics for stores.; Additionally, it guarantees; that a total ordering exists; between all; SequentiallyConsistent; operations. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:37,load,loads,37,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['load'],['loads']
Performance,"/*- Prototypes -*/; /**; * Constructs the suffix array of a given string.; * @param T [0..n-1] The input string.; * @param SA [0..n-1] The output array of suffixes.; * @param n The length of the given string.; * @param openMP enables OpenMP optimization.; * @return 0 if no error occurred, -1 or -2 otherwise.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/divsufsort.h:241,optimiz,optimization,241,builtins/zstd/dictBuilder/divsufsort.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/divsufsort.h,1,['optimiz'],['optimization']
Performance,"/*-***************************************************************************; * Streaming decompression - HowTo; *; * A ZSTD_DStream object is required to track streaming operations.; * Use ZSTD_createDStream() and ZSTD_freeDStream() to create/release resources.; * ZSTD_DStream objects can be re-used multiple times.; *; * Use ZSTD_initDStream() to start a new decompression operation.; * @return : recommended first input size; * Alternatively, use advanced API to set specific properties.; *; * Use ZSTD_decompressStream() repetitively to consume your input.; * The function will update both `pos` fields.; * If `input.pos < input.size`, some input has not been consumed.; * It's up to the caller to present again remaining data.; * The function tries to flush all data decoded immediately, respecting output buffer size.; * If `output.pos < output.size`, decoder has flushed everything it could.; * But if `output.pos == output.size`, there might be some data left within internal buffers.,; * In which case, call ZSTD_decompressStream() again to flush whatever remains in the buffer.; * Note : with no additional input provided, amount of data flushed is necessarily <= ZSTD_BLOCKSIZE_MAX.; * @return : 0 when a frame is completely decoded and fully flushed,; * or an error code, which can be tested using ZSTD_isError(),; * or any other value > 0, which means there is still some decoding or flushing to do to complete current frame :; * the return value is a suggested next input size (just a hint for better latency); * that will never request more than the remaining frame size.; * *******************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:1518,latency,latency,1518,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['latency'],['latency']
Performance,"/*-***********************************************************************; * Streaming compression - HowTo; *; * A ZSTD_CStream object is required to track streaming operation.; * Use ZSTD_createCStream() and ZSTD_freeCStream() to create/release resources.; * ZSTD_CStream objects can be reused multiple times on consecutive compression operations.; * It is recommended to re-use ZSTD_CStream since it will play nicer with system's memory, by re-using already allocated memory.; *; * For parallel execution, use one separate ZSTD_CStream per thread.; *; * note : since v1.3.0, ZSTD_CStream and ZSTD_CCtx are the same thing.; *; * Parameters are sticky : when starting a new compression on the same context,; * it will re-use the same sticky parameters as previous compression session.; * When in doubt, it's recommended to fully initialize the context before usage.; * Use ZSTD_CCtx_reset() to reset the context and ZSTD_CCtx_setParameter(),; * ZSTD_CCtx_setPledgedSrcSize(), or ZSTD_CCtx_loadDictionary() and friends to; * set more specific parameters, the pledged source size, or load a dictionary.; *; * Use ZSTD_compressStream2() with ZSTD_e_continue as many times as necessary to; * consume input stream. The function will automatically update both `pos`; * fields within `input` and `output`.; * Note that the function may not consume the entire input, for example, because; * the output buffer is already full, in which case `input.pos < input.size`.; * The caller must check if input has been entirely consumed.; * If not, the caller must make some room to receive more compressed data,; * and then present again remaining input data.; * note: ZSTD_e_continue is guaranteed to make some forward progress when called,; * but doesn't guarantee maximal forward progress. This is especially relevant; * when compressing with multiple threads. The call won't block if it can; * consume some input, but if it can't it will wait for some, but not all,; * output to be flushed.; * @return : provides ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:1083,load,load,1083,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['load'],['load']
Performance,"/*-**************************************************************; * Memory I/O Implementation; *****************************************************************/; /* MEM_FORCE_MEMORY_ACCESS :; * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.; * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.; * The below switch allow to select different access method for improved performance.; * Method 0 (default) : use `memcpy()`. Safe and portable.; * Method 1 : `__packed` statement. It depends on compiler extension (i.e., not portable).; * This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.; * Method 2 : direct access. This method is portable but violate C standard.; * It can generate buggy code on targets depending on alignment.; * In some circumstances, it's the only known way to get the most performance (i.e. GCC + ARMv6); * See http://fastcompression.blogspot.fr/2015/08/accessing-unaligned-memory.html for details.; * Prefer these methods in priority order (0 > 1 > 2); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/mem.h:460,perform,performance,460,builtins/zstd/common/mem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/mem.h,2,['perform'],['performance']
Performance,"/*-*************************************; * Hash table; ***************************************; * A small specialized hash map for storing activeDmers.; * The map does not resize, so if it becomes full it will loop forever.; * Thus, the map must be large enough to store every value.; * The map implements linear probing and keeps its load less than 0.5.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/cover.c:336,load,load,336,builtins/zstd/dictBuilder/cover.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/cover.c,1,['load'],['load']
Performance,"/*---- unlikely / likely expressions -----------------------------------------*/; // These are meant to use in cases like:; // if (R__unlikely(expression)) { ... }; // in performance-critical sections. R__unlikely / R__likely provide hints to; // the compiler code generation to heavily optimize one side of a conditional,; // causing the other branch to have a heavy performance cost.; //; // It is best to use this for conditionals that test for rare error cases or; // backward compatibility code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RConfig.hxx:171,perform,performance-critical,171,core/foundation/inc/ROOT/RConfig.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RConfig.hxx,3,"['optimiz', 'perform']","['optimize', 'performance', 'performance-critical']"
Performance,"/*--.. Operations on global variables, load and store instructions .........--*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp:39,load,load,39,interpreter/llvm-project/llvm/lib/IR/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp,1,['load'],['load']
Performance,/*; 	deleteGeometry( geometryId ) {. 		// TODO: delete geometry and associated instances. 	}; 	*/; /*; 	deleteInstance( instanceId ) {. 		// Note: User needs to call optimize() afterward to pack the data. 		const drawInfo = this._drawInfo;; 		if ( instanceId >= drawInfo.length || drawInfo[ instanceId ].active === false ) {. 			return this;. 		}. 		drawInfo[ instanceId ].active = false;; 		this._visibilityChanged = true;. 		return this;. 	}; 	*/; // get bounding box and compute it if it doesn't exist,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:166,optimiz,optimize,166,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['optimiz'],['optimize']
Performance,"/*; * $XFree86: xc/include/extensions/render.h,v 1.10 2002/11/06 22:47:49 keithp Exp $; *; * Copyright © 2000 SuSE, Inc.; *; * Permission to use, copy, modify, distribute, and sell this software and its; * documentation for any purpose is hereby granted without fee, provided that; * the above copyright notice appear in all copies and that both that; * copyright notice and this permission notice appear in supporting; * documentation, and that the name of SuSE not be used in advertising or; * publicity pertaining to distribution of the software without specific,; * written prior permission. SuSE makes no representations about the; * suitability of this software for any purpose. It is provided ""as is""; * without express or implied warranty.; *; * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE; * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES; * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION; * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN; * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.; *; * Author: Keith Packard, SuSE, Inc.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/inc/X11/extensions/render.h:1168,PERFORM,PERFORMANCE,1168,graf2d/x11/inc/X11/extensions/render.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/inc/X11/extensions/render.h,1,['PERFORM'],['PERFORMANCE']
Performance,"/*; * 64-bit optimized (albeit more confusing) version.; *; * Uses some properties of addition and multiplication to remove the mask:; *; * Let:; * a = input_hi.lo = (input_hi & 0x00000000FFFFFFFF); * b = input_hi.hi = (input_hi & 0xFFFFFFFF00000000); * c = XXH_PRIME32_2; *; * a + (b * c); * Inverse Property: x + y - x == y; * a + (b * (1 + c - 1)); * Distributive Property: x * (y + z) == (x * y) + (x * z); * a + (b * 1) + (b * (c - 1)); * Identity Property: x * 1 == x; * a + b + (b * (c - 1)); *; * Substitute a, b, and c:; * input_hi.hi + input_hi.lo + ((xxh_u64)input_hi.lo * (XXH_PRIME32_2 - 1)); *; * Since input_hi.hi + input_hi.lo == input_hi, we get this:; * input_hi + ((xxh_u64)input_hi.lo * (XXH_PRIME32_2 - 1)); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:13,optimiz,optimized,13,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['optimiz'],['optimized']
Performance,"/*; * About virtual array management:; *; * The above ""normal"" array routines are only used to allocate strip buffers; * (as wide as the image, but just a few rows high). Full-image-sized buffers; * are handled as ""virtual"" arrays. The array is still accessed a strip at a; * time, but the memory manager must save the whole array for repeated; * accesses. The intended implementation is that there is a strip buffer in; * memory (as high as is possible given the desired memory limit), plus a; * backing file that holds the rest of the array.; *; * The request_virt_array routines are told the total size of the image and; * the maximum number of rows that will be accessed at once. The in-memory; * buffer must be at least as large as the maxaccess value.; *; * The request routines create control blocks but not the in-memory buffers.; * That is postponed until realize_virt_arrays is called. At that time the; * total amount of space needed is known (approximately, anyway), so free; * memory can be divided up fairly.; *; * The access_virt_array routines are responsible for making a specific strip; * area accessible (after reading or writing the backing file, if necessary).; * Note that the access routines are told whether the caller intends to modify; * the accessed strip; during a read-only pass this saves having to rewrite; * data to disk. The access routines are also responsible for pre-zeroing; * any newly accessed rows, if pre-zeroing was requested.; *; * In current usage, the access requests are usually for nonoverlapping; * strips; that is, successive access start_row numbers differ by exactly; * num_rows = maxaccess. This means we can get good performance with simple; * buffer dump/reload logic, by making the in-memory buffer be a multiple; * of the access height; then there will never be accesses across bufferload; * boundaries. The code will still work with overlapping access requests,; * but it doesn't handle bufferload overlaps very efficiently.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:1670,perform,performance,1670,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,1,['perform'],['performance']
Performance,"/*; * An inverse DCT routine is given a pointer to the input JBLOCK and a pointer; * to an output sample array. The routine must dequantize the input data as; * well as perform the IDCT; for dequantization, it uses the multiplier table; * pointed to by compptr->dct_table. The output data is to be placed into the; * sample array starting at a specified column. (Any row offset needed will; * be applied to the array pointer before it is passed to the IDCT code.); * Note that the number of samples emitted by the IDCT routine is; * DCT_h_scaled_size * DCT_v_scaled_size.; */; /* typedef inverse_DCT_method_ptr is declared in jpegint.h */; /*; * Each IDCT routine has its own ideas about the best dct_table element type.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdct.h:169,perform,perform,169,graf2d/asimage/src/libAfterImage/libjpeg/jdct.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdct.h,1,['perform'],['perform']
Performance,"/*; * Compute memory partition like procps(free), see https://gitlab.com/procps-ng/procps/-/blob/master/proc/sysinfo.c; * ; * fMemShared is a part of Cached (see https://lore.kernel.org/patchwork/patch/648763/), does not subtract twice from used; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx:150,Cache,Cached,150,core/unix/src/TUnixSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx,1,['Cache'],['Cached']
Performance,/*; * Compute the derived values for a Huffman table.; * This routine also performs some validation checks on the table.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:75,perform,performs,75,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,2,['perform'],['performs']
Performance,"/*; * Controls the alignment of the accumulator,; * for compatibility with aligned vector loads, which are usually faster.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:90,load,loads,90,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['load'],['loads']
Performance,/*; * Database can not be loaded; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h:26,load,loaded,26,interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h,1,['load'],['loaded']
Performance,"/*; * Decompression startup: read start of JPEG datastream to see what's there.; * Need only initialize JPEG object and supply a data source before calling.; *; * This routine will read as far as the first SOS marker (ie, actual start of; * compressed data), and will save all tables and parameters in the JPEG; * object. It will also initialize the decompression parameters to default; * values, and finally return JPEG_HEADER_OK. On return, the application may; * adjust the decompression parameters and then call jpeg_start_decompress.; * (Or, if the application only wanted to determine the image parameters,; * the data need not be decompressed. In that case, call jpeg_abort or; * jpeg_destroy to release any temporary space.); * If an abbreviated (tables only) datastream is presented, the routine will; * return JPEG_HEADER_TABLES_ONLY upon reaching EOI. The application may then; * re-use the JPEG object to read the abbreviated image datastream(s).; * It is unnecessary (but OK) to call jpeg_abort in this case.; * The JPEG_SUSPENDED return code only occurs if the data source module; * requests suspension of the decompressor. In this case the application; * should load more source data and then re-call jpeg_read_header to resume; * processing.; * If a non-suspending data source is used and require_image is TRUE, then the; * return code need not be inspected since only JPEG_HEADER_OK is possible.; *; * This routine is now just a front end to jpeg_consume_input, with some; * extra error checking.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdapimin.c:1177,load,load,1177,graf2d/asimage/src/libAfterImage/libjpeg/jdapimin.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdapimin.c,1,['load'],['load']
Performance,"/*; * Downcast + upcast is usually better than masking on older compilers like; * GCC 4.2 (especially 32-bit ones), all without affecting newer compilers.; *; * The other method, (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF), will AND both operands; * and perform a full 64x64 multiply -- entirely redundant on 32-bit.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:246,perform,perform,246,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['perform'],['perform']
Performance,"/*; * Fill the input buffer --- called whenever buffer is emptied.; *; * In typical applications, this should read fresh data into the buffer; * (ignoring the current state of next_input_byte & bytes_in_buffer),; * reset the pointer & count to the start of the buffer, and return TRUE; * indicating that the buffer has been reloaded. It is not necessary to; * fill the buffer entirely, only to obtain at least one more byte.; *; * There is no such thing as an EOF return. If the end of the file has been; * reached, the routine has a choice of ERREXIT() or inserting fake data into; * the buffer. In most cases, generating a warning message and inserting a; * fake EOI marker is the best course of action --- this will allow the; * decompressor to output however much of the image is there. However,; * the resulting error message is misleading if the real problem is an empty; * input file, so we handle that case specially.; *; * In applications that need to be able to suspend compression due to input; * not being available yet, a FALSE return indicates that no more data can be; * obtained right now, but more may be forthcoming later. In this situation,; * the decompressor will return to its caller (with an indication of the; * number of scanlines it has read, if any). The application should resume; * decompression after it has loaded more data into the input buffer. Note; * that there are substantial restrictions on the use of suspension --- see; * the documentation.; *; * When suspending, the decompressor will back up to a convenient restart point; * (typically the start of the current MCU). next_input_byte & bytes_in_buffer; * indicate where the restart point will be if the current call returns FALSE.; * Data beyond this point must be rescanned after resumption, so move it to; * the front of the buffer rather than discarding it.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatasrc.c:1338,load,loaded,1338,graf2d/asimage/src/libAfterImage/libjpeg/jdatasrc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatasrc.c,1,['load'],['loaded']
Performance,"/*; * Huffman coding optimization.; *; * We first scan the supplied data and count the number of uses of each symbol; * that is to be Huffman-coded. (This process MUST agree with the code above.); * Then we build a Huffman coding tree for the observed counts.; * Symbols which are not needed at all for the particular image are not; * assigned any code, which saves space in the DHT marker as well as in; * the compressed data.; */; /* Process a single block's worth of coefficients */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:21,optimiz,optimization,21,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,1,['optimiz'],['optimization']
Performance,"/*; * If an action is to be taken if `secretLen` condition is not respected,; * it should be done here.; * For now, it's a contract pre-condition.; * Adding a check and a branch here would cost performance at every hash.; * Also, note that function signature doesn't offer room to return an error.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:194,perform,performance,194,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['perform'],['performance']
Performance,"/*; * If an action is to be taken if `secret` conditions are not respected,; * it should be done here.; * For now, it's a contract pre-condition.; * Adding a check and a branch here would cost performance at every hash.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:193,perform,performance,193,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['perform'],['performance']
Performance,"/*; * Initialize the compression object with default parameters,; * then copy from the source object all parameters needed for lossless; * transcoding. Parameters that can be varied without loss (such as; * scan script and Huffman optimization) are left in their default states.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jctrans.c:231,optimiz,optimization,231,graf2d/asimage/src/libAfterImage/libjpeg/jctrans.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jctrans.c,1,['optimiz'],['optimization']
Performance,/*; * Insert all vertices into the priority queue which determines the; * order in which vertices cross the sweep line.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c:44,queue,queue,44,graf3d/eve7/glu/sweep.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c,1,['queue'],['queue']
Performance,"/*; * It's important for performance that XXH3_hashLong is not inlined.; * Since the function is not inlined, the compiler may not be able to understand that,; * in some scenarios, its `secret` argument is actually a compile time constant.; * This variant enforces that the compiler can detect that,; * and uses this opportunity to streamline the generated code for better performance.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:25,perform,performance,25,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,['perform'],['performance']
Performance,/*; * It's important for performance that XXH3_hashLong is not inlined.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:25,perform,performance,25,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,5,['perform'],['performance']
Performance,"/*; * Length of APP14 block	(2 bytes); * Block ID			(5 bytes - ASCII ""Adobe""); * Version Number		(2 bytes - currently 100); * Flags0			(2 bytes - currently 0); * Flags1			(2 bytes - currently 0); * Color transform		(1 byte); *; * Although Adobe TN 5116 mentions Version = 101, all the Adobe files; * now in circulation seem to use Version = 100, so that's what we write.; *; * We write the color transform byte as 1 if the JPEG color space is; * YCbCr, 2 if it's YCCK, 0 otherwise. Adobe's definition has to do with; * whether the encoder performed a transformation, which is pretty useless.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmarker.c:539,perform,performed,539,graf2d/asimage/src/libAfterImage/libjpeg/jcmarker.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmarker.c,1,['perform'],['performed']
Performance,/*; * Load Keras model from file; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx:6,Load,Load,6,tmva/pymva/src/MethodPyKeras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx,1,['Load'],['Load']
Performance,/*; * Load PyTorch model from file; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx:6,Load,Load,6,tmva/pymva/src/MethodPyTorch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx,1,['Load'],['Load']
Performance,/*; * Load training data to numpy array. ; * NOTE: These are later forced to be converted into torch tensors throught the training loop which may not be the ideal method.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx:6,Load,Load,6,tmva/pymva/src/MethodPyTorch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx,1,['Load'],['Load']
Performance,/*; * Load training data to numpy array; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx:6,Load,Load,6,tmva/pymva/src/MethodPyKeras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx,1,['Load'],['Load']
Performance,"/*; * Load validation data to numpy array; */; // NOTE: TMVA Validation data is a subset of all the training data; // we will not use test data for validation. They will be used for the real testing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx:6,Load,Load,6,tmva/pymva/src/MethodPyTorch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx,1,['Load'],['Load']
Performance,"/*; * Load validation data to numpy array; */; // NOTE: from TMVA, we get the validation data as a subset of all the training data; // we will not use test data for validation. They will be used for the real testing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx:6,Load,Load,6,tmva/pymva/src/MethodPyKeras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx,1,['Load'],['Load']
Performance,"/*; * NEON's setup for vmlal_u32 is a little more complicated than it is on; * SSE2, AVX2, and VSX.; *; * While PMULUDQ and VMULEUW both perform a mask, VMLAL.U32 performs an upcast.; *; * To do the same operation, the 128-bit 'Q' register needs to be split into; * two 64-bit 'D' registers, performing this operation::; *; * [ a | b ]; * | '---------. .--------' |; * | x |; * | .---------' '--------. |; * [ a & 0xFFFFFFFF | b & 0xFFFFFFFF ],[ a >> 32 | b >> 32 ]; *; * Due to significant changes in aarch64, the fastest method for aarch64 is; * completely different than the fastest method for ARMv7-A.; *; * ARMv7-A treats D registers as unions overlaying Q registers, so modifying; * D11 will modify the high half of Q5. This is similar to how modifying AH; * will only affect bits 8-15 of AX on x86.; *; * VZIP takes two registers, and puts even lanes in one register and odd lanes; * in the other.; *; * On ARMv7-A, this strangely modifies both parameters in place instead of; * taking the usual 3-operand form.; *; * Therefore, if we want to do this, we can simply use a D-form VZIP.32 on the; * lower and upper halves of the Q register to end up with the high and low; * halves where we want - all in one instruction.; *; * vzip.32 d10, d11 @ d10 = { d10[0], d11[0] }; d11 = { d10[1], d11[1] }; *; * Unfortunately we need inline assembly for this: Instructions modifying two; * registers at once is not possible in GCC or Clang's IR, and they have to; * create a copy.; *; * aarch64 requires a different approach.; *; * In order to make it easier to write a decent compiler for aarch64, many; * quirks were removed, such as conditional execution.; *; * NEON was also affected by this.; *; * aarch64 cannot access the high bits of a Q-form register, and writes to a; * D-form register zero the high bits, similar to how writes to W-form scalar; * registers (or DWORD registers on x86_64) work.; *; * The formerly free vget_high intrinsics now require a vext (with a few; * exceptions); *; * Ad",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:137,perform,perform,137,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,3,['perform'],"['perform', 'performing', 'performs']"
Performance,"/*; * Note: in debug mode, this overrides the asm optimization; * and Clang will emit MOVK chains again.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:50,optimiz,optimization,50,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['optimiz'],['optimization']
Performance,"/*; * On GCC & Clang, marking 'dest' as modified will cause the compiler:; * - do not extract the secret from sse registers in the internal loop; * - use less common registers, and avoid pushing these reg into stack; * The asm hack causes Clang to assume that XXH3_kSecretPtr aliases with; * customSecret, and on aarch64, this prevented LDP from merging two; * loads together for free. Putting the loads together before the stores; * properly generates LDP.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:361,load,loads,361,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,['load'],['loads']
Performance,"/*; * Perform case analysis. See Unicode 6.3.0, Table 3-7. Well-Formed UTF-8; * Byte Sequences.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp:6,Perform,Perform,6,interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 10x10 output block.; *; * Optimized algorithm with 12 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/20).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,2,"['Optimiz', 'Perform']","['Optimized', 'Perform']"
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 10x5 output block.; *; * 5-point IDCT in pass 1 (columns), 10-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 11x11 output block.; *; * Optimized algorithm with 24 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/22).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,2,"['Optimiz', 'Perform']","['Optimized', 'Perform']"
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 12x12 output block.; *; * Optimized algorithm with 15 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/24).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,2,"['Optimiz', 'Perform']","['Optimized', 'Perform']"
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 12x6 output block.; *; * 6-point IDCT in pass 1 (columns), 12-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 13x13 output block.; *; * Optimized algorithm with 29 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/26).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,2,"['Optimiz', 'Perform']","['Optimized', 'Perform']"
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 14x14 output block.; *; * Optimized algorithm with 20 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/28).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,2,"['Optimiz', 'Perform']","['Optimized', 'Perform']"
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 14x7 output block.; *; * 7-point IDCT in pass 1 (columns), 14-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 15x15 output block.; *; * Optimized algorithm with 22 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/30).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,2,"['Optimiz', 'Perform']","['Optimized', 'Perform']"
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 16x16 output block.; *; * Optimized algorithm with 28 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/32).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,2,"['Optimiz', 'Perform']","['Optimized', 'Perform']"
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 16x8 output block.; *; * 8-point IDCT in pass 1 (columns), 16-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 1x2 output block.; *; * 2-point IDCT in pass 1 (columns), 1-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 2x1 output block.; *; * 1-point IDCT in pass 1 (columns), 2-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 2x4 output block.; *; * 4-point IDCT in pass 1 (columns), 2-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 4x2 output block.; *; * 2-point IDCT in pass 1 (columns), 4-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 4x8 output block.; *; * 8-point IDCT in pass 1 (columns), 4-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 5x10 output block.; *; * 10-point IDCT in pass 1 (columns), 5-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 6x12 output block.; *; * 12-point IDCT in pass 1 (columns), 6-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 7x14 output block.; *; * 14-point IDCT in pass 1 (columns), 7-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 7x7 output block.; *; * Optimized algorithm with 12 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/14).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,2,"['Optimiz', 'Perform']","['Optimized', 'Perform']"
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 8x16 output block.; *; * 16-point IDCT in pass 1 (columns), 8-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 8x4 output block.; *; * 4-point IDCT in pass 1 (columns), 8-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a 9x9 output block.; *; * Optimized algorithm with 10 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/18).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,2,"['Optimiz', 'Perform']","['Optimized', 'Perform']"
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a reduced-size 1x1 output block.; *; * We hardly need an inverse DCT routine for this: just take the; * average pixel value, which is one-eighth of the DC coefficient.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a reduced-size 2x2 output block.; *; * Multiplication-less algorithm.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a reduced-size 3x3 output block.; *; * Optimized algorithm with 2 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/6).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,2,"['Optimiz', 'Perform']","['Optimized', 'Perform']"
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a reduced-size 3x6 output block.; *; * 6-point IDCT in pass 1 (columns), 3-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a reduced-size 4x4 output block.; *; * Optimized algorithm with 3 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point IDCT].; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,2,"['Optimiz', 'Perform']","['Optimized', 'Perform']"
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a reduced-size 5x5 output block.; *; * Optimized algorithm with 5 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/10).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,2,"['Optimiz', 'Perform']","['Optimized', 'Perform']"
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a reduced-size 6x3 output block.; *; * 3-point IDCT in pass 1 (columns), 6-point in pass 2 (rows).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform dequantization and inverse DCT on one block of coefficients,; * producing a reduced-size 6x6 output block.; *; * Optimized algorithm with 3 multiplications in the 1-D kernel.; * cK represents sqrt(2) * cos(K*pi/12).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,2,"['Optimiz', 'Perform']","['Optimized', 'Perform']"
Performance,/*; * Perform dequantization and inverse DCT on one block of coefficients.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctflt.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jidctflt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctflt.c,3,['Perform'],['Perform']
Performance,"/*; * Perform forward DCT on one or more blocks of a component.; *; * The input samples are taken from the sample_data[] array starting at; * position start_row/start_col, and moving to the right for any additional; * blocks. The quantized coefficients are returned in coef_blocks[].; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcdctmgr.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jcdctmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcdctmgr.c,1,['Perform'],['Perform']
Performance,/*; * Perform the forward DCT on a 10x10 sample block.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform the forward DCT on a 10x5 sample block.; *; * 10-point FDCT in pass 1 (rows), 5-point in pass 2 (columns).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,/*; * Perform the forward DCT on a 12x12 sample block.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform the forward DCT on a 12x6 sample block.; *; * 12-point FDCT in pass 1 (rows), 6-point in pass 2 (columns).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,/*; * Perform the forward DCT on a 13x13 sample block.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,/*; * Perform the forward DCT on a 14x14 sample block.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform the forward DCT on a 14x7 sample block.; *; * 14-point FDCT in pass 1 (rows), 7-point in pass 2 (columns).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,/*; * Perform the forward DCT on a 15x15 sample block.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,/*; * Perform the forward DCT on a 16x16 sample block.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform the forward DCT on a 16x8 sample block.; *; * 16-point FDCT in pass 1 (rows), 8-point in pass 2 (columns).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,/*; * Perform the forward DCT on a 1x1 sample block.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform the forward DCT on a 1x2 sample block.; *; * 1-point FDCT in pass 1 (rows), 2-point in pass 2 (columns).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform the forward DCT on a 2x1 sample block.; *; * 2-point FDCT in pass 1 (rows), 1-point in pass 2 (columns).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,/*; * Perform the forward DCT on a 2x2 sample block.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform the forward DCT on a 2x4 sample block.; *; * 2-point FDCT in pass 1 (rows), 4-point in pass 2 (columns).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,/*; * Perform the forward DCT on a 3x3 sample block.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform the forward DCT on a 3x6 sample block.; *; * 3-point FDCT in pass 1 (rows), 6-point in pass 2 (columns).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform the forward DCT on a 4x2 sample block.; *; * 4-point FDCT in pass 1 (rows), 2-point in pass 2 (columns).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,/*; * Perform the forward DCT on a 4x4 sample block.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform the forward DCT on a 4x8 sample block.; *; * 4-point FDCT in pass 1 (rows), 8-point in pass 2 (columns).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform the forward DCT on a 5x10 sample block.; *; * 5-point FDCT in pass 1 (rows), 10-point in pass 2 (columns).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,/*; * Perform the forward DCT on a 5x5 sample block.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform the forward DCT on a 6x12 sample block.; *; * 6-point FDCT in pass 1 (rows), 12-point in pass 2 (columns).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform the forward DCT on a 6x3 sample block.; *; * 6-point FDCT in pass 1 (rows), 3-point in pass 2 (columns).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,/*; * Perform the forward DCT on a 6x6 sample block.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform the forward DCT on a 7x14 sample block.; *; * 7-point FDCT in pass 1 (rows), 14-point in pass 2 (columns).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,/*; * Perform the forward DCT on a 7x7 sample block.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,/*; * Perform the forward DCT on a 9x9 sample block.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,/*; * Perform the forward DCT on an 11x11 sample block.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform the forward DCT on an 8x16 sample block.; *; * 8-point FDCT in pass 1 (rows), 16-point in pass 2 (columns).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,"/*; * Perform the forward DCT on an 8x4 sample block.; *; * 8-point FDCT in pass 1 (rows), 4-point in pass 2 (columns).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['Perform'],['Perform']
Performance,/*; * Perform the forward DCT on one block of samples.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctflt.c:6,Perform,Perform,6,graf2d/asimage/src/libAfterImage/libjpeg/jfdctflt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctflt.c,3,['Perform'],['Perform']
Performance,/*; * Portable and well-defined behavior.; * Don't use static: it is detrimental to performance.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:84,perform,performance,84,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['perform'],['performance']
Performance,"/*; * Portable scalar method. Optimized for 32-bit and 64-bit ALUs.; *; * This is a fast and simple grade school multiply, which is shown below; * with base 10 arithmetic instead of base 0x100000000.; *; * 9 3 // D2 lhs = 93; * x 7 5 // D2 rhs = 75; * ----------; * 1 5 // D2 lo_lo = (93 % 10) * (75 % 10) = 15; * 4 5 | // D2 hi_lo = (93 / 10) * (75 % 10) = 45; * 2 1 | // D2 lo_hi = (93 % 10) * (75 / 10) = 21; * + 6 3 | | // D2 hi_hi = (93 / 10) * (75 / 10) = 63; * ---------; * 2 7 | // D2 cross = (15 / 10) + (45 % 10) + 21 = 27; * + 6 7 | | // D2 upper = (27 / 10) + (45 / 10) + 63 = 67; * ---------; * 6 9 7 5 // D4 res = (27 * 10) + (15 % 10) + (67 * 100) = 6975; *; * The reasons for adding the products like this are:; * 1. It avoids manual carry tracking. Just like how; * (9 * 9) + 9 + 9 = 99, the same applies with this for UINT64_MAX.; * This avoids a lot of complexity.; *; * 2. It hints for, and on Clang, compiles to, the powerful UMAAL; * instruction available in ARM's Digital Signal Processing extension; * in 32-bit ARMv6 and later, which is shown below:; *; * void UMAAL(xxh_u32 *RdLo, xxh_u32 *RdHi, xxh_u32 Rn, xxh_u32 Rm); * {; * xxh_u64 product = (xxh_u64)*RdLo * (xxh_u64)*RdHi + Rn + Rm;; * *RdLo = (xxh_u32)(product & 0xFFFFFFFF);; * *RdHi = (xxh_u32)(product >> 32);; * }; *; * This instruction was designed for efficient long multiplication, and; * allows this to be calculated in only 4 instructions at speeds; * comparable to some 64-bit ALUs.; *; * 3. It isn't terrible on other platforms. Usually this will be a couple; * of 32-bit ADD/ADCs.; */; /* First calculate all of the cross products. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:30,Optimiz,Optimized,30,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['Optimiz'],['Optimized']
Performance,"/*; * Process some data in the first pass of a multi-pass case.; * We process the equivalent of one fully interleaved MCU row (""iMCU"" row); * per call, ie, v_samp_factor block rows for each component in the image.; * This amount of data is read from the source buffer, DCT'd and quantized,; * and saved into the virtual arrays. We also generate suitable dummy blocks; * as needed at the right and lower edges. (The dummy blocks are constructed; * in the virtual arrays, which have been padded appropriately.) This makes; * it possible for subsequent passes not to worry about real vs. dummy blocks.; *; * We must also emit the data to the entropy encoder. This is conveniently; * done by calling compress_output() after we've loaded the current strip; * of the virtual arrays.; *; * NB: input_buf contains a plane for each component in image. All; * components are DCT'd and loaded into the virtual arrays in this pass.; * However, it may be that only a subset of the components are emitted to; * the entropy encoder during this first pass; be careful about looking; * at the scan-dependent variables (MCU dimensions, etc).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c:726,load,loaded,726,graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c,2,['load'],['loaded']
Performance,"/*; * Project: RooFit; * Authors:; * Emmanouil Michalainas, CERN, Summer 2019; *; * Copyright (c) 2021, CERN; *; * Redistribution and use in source and binary forms,; * with or without modification, are permitted according to the terms; * listed in LICENSE (http://roofit.sourceforge.net/license.txt); */; /**; \file ComputeFunctions.cxx; \ingroup roofit_dev_docs_batchcompute. This file contains vectorizable computation functions for PDFs and other Roofit objects.; The same source file can also be compiled with nvcc. All functions have a single `Batches`; object as an argument passed by value, which contains all the information necessary for the; computation. In case of cuda computations, the loops have a step (stride) the size of the grid; which allows for reusing the same code as the cpu implementations, easier debugging and in terms; of performance, maximum memory coalescing. For more details, see; https://developer.nvidia.com/blog/cuda-pro-tip-write-flexible-kernels-grid-stride-loops/; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/ComputeFunctions.cxx:850,perform,performance,850,roofit/batchcompute/src/ComputeFunctions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/ComputeFunctions.cxx,1,['perform'],['performance']
Performance,"/*; * Project: xRooFit; * Author:; * Will Buttinger, RAL 2022; *; * Copyright (c) 2022, CERN; *; * Redistribution and use in source and binary forms,; * with or without modification, are permitted according to the terms; * listed in LICENSE (http://roofit.sourceforge.net/license.txt); */; /** \class ROOT::Experimental::XRooFit::xRooBrowser; \ingroup xroofit. \image html RooBrowser.png width=50%. \brief A version of the TBrowser that can be used to interact with RooFit models and datasets. Also available under the ROOT::Experimental::RooBrowser alias. To get started with the xRooBrowser, open any ROOT file containing a workspace; and then create an instance of the xRooBrowser just like; creating an instance of a `TBrowser`. A window will be displayed with a navigable; tree structure on the left that lets you explore the content of the workspaces; present in the loaded file. Note that additional files, <b>including json workspace files</b>,; can be loaded through the `Browser --> Open` menu in the top left corner. The context menu for each node (access by right clicking on the node) in the tree structure can be used to get more; information about the node. In particular, the `Draw` command can be selected on many of the nodes that are part of a; statistical model, which will visualize that part of the model in the browser window. A number of options are available; for the `Draw` command, including (some options can be combined):. - ""e"" : calculate and visualize propagated model uncertainty; - ""auxratio"" : Draw a ratio auxiliary plot below the main plot; - ""auxsignif"" : Draw a significance auxiliary plot below the main plot; - ""pull"" : show panel of current parameter values, which can be dragged in order to change the values and visualize the; effect on the model (very experimental feature). Once a node has been drawn, the styling of subsequent draws can be controlled through `TStyle` objects; that will now appear in the `objects` folder in the workspace. A model can be",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooBrowser.cxx:873,load,loaded,873,roofit/xroofit/src/xRooBrowser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooBrowser.cxx,2,['load'],['loaded']
Performance,"/*; * Set up for an output pass, and perform any dummy pass(es) needed.; * Common subroutine for jpeg_start_decompress and jpeg_start_output.; * Entry: global_state = DSTATE_PRESCAN only if previously suspended.; * Exit: If done, returns TRUE and sets global_state for proper output mode.; * If suspended, returns FALSE and sets global_state = DSTATE_PRESCAN.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdapistd.c:37,perform,perform,37,graf2d/asimage/src/libAfterImage/libjpeg/jdapistd.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdapistd.c,1,['perform'],['perform']
Performance,"/*; * The asm hack causes Clang to assume that kSecretPtr aliases with; * customSecret, and on aarch64, this prevented LDP from merging two; * loads together for free. Putting the loads together before the stores; * properly generates LDP.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:143,load,loads,143,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,['load'],['loads']
Performance,"/*; * The core arithmetic decoding routine (common in JPEG and JBIG).; * This needs to go as fast as possible.; * Machine-dependent optimization facilities; * are not utilized in this portable implementation.; * However, this code should be fairly efficient and; * may be a good base for further optimizations anyway.; *; * Return value is 0 or 1 (binary decision).; *; * Note: I've changed the handling of the code base & bit; * buffer register C compared to other implementations; * based on the standards layout & procedures.; * While it also contains both the actual base of the; * coding interval (16 bits) and the next-bits buffer,; * the cut-point between these two parts is floating; * (instead of fixed) with the bit shift counter CT.; * Thus, we also need only one (variable instead of; * fixed size) shift for the LPS/MPS decision, and; * we can get away with any renormalization update; * of C (except for new data insertion, of course).; *; * I've also introduced a new scheme for accessing; * the probability estimation state machine table,; * derived from Markus Kuhn's JBIG implementation.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdarith.c:132,optimiz,optimization,132,graf2d/asimage/src/libAfterImage/libjpeg/jdarith.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdarith.c,2,['optimiz'],"['optimization', 'optimizations']"
Performance,"/*; * The core arithmetic encoding routine (common in JPEG and JBIG).; * This needs to go as fast as possible.; * Machine-dependent optimization facilities; * are not utilized in this portable implementation.; * However, this code should be fairly efficient and; * may be a good base for further optimizations anyway.; *; * Parameter 'val' to be encoded may be 0 or 1 (binary decision).; *; * Note: I've added full ""Pacman"" termination support to the; * byte output routines, which is equivalent to the optional; * Discard_final_zeros procedure (Figure D.15) in the spec.; * Thus, we always produce the shortest possible output; * stream compliant to the spec (no trailing zero bytes,; * except for FF stuffing).; *; * I've also introduced a new scheme for accessing; * the probability estimation state machine table,; * derived from Markus Kuhn's JBIG implementation.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c:132,optimiz,optimization,132,graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,2,['optimiz'],"['optimization', 'optimizations']"
Performance,"/*; * These routines are concerned with the time-critical task of mapping input; * colors to the nearest color in the selected colormap.; *; * We re-use the histogram space as an ""inverse color map"", essentially a; * cache for the results of nearest-color searches. All colors within a; * histogram cell will be mapped to the same colormap entry, namely the one; * closest to the cell's center. This may not be quite the closest entry to; * the actual input color, but it's almost as good. A zero in the cache; * indicates we haven't found the nearest color for that cell yet; the array; * is cleared to zeroes before starting the mapping pass. When we find the; * nearest color for a cell, its colormap index plus one is recorded in the; * cache for future use. The pass2 scanning routines call fill_inverse_cmap; * when they need to use an unfilled entry in the cache.; *; * Our method of efficiently finding nearest colors is based on the ""locally; * sorted search"" idea described by Heckbert and on the incremental distance; * calculation described by Spencer W. Thomas in chapter III.1 of Graphics; * Gems II (James Arvo, ed. Academic Press, 1991). Thomas points out that; * the distances from a given colormap entry to each cell of the histogram can; * be computed quickly using an incremental method: the differences between; * distances to adjacent cells themselves differ by a constant. This allows a; * fairly fast implementation of the ""brute force"" approach of computing the; * distance from every colormap entry to every histogram cell. Unfortunately,; * it needs a work array to hold the best-distance-so-far for each histogram; * cell (because the inner loop has to be over cells, not colormap entries).; * The work array elements have to be INT32s, so the work array would need; * 256Kb at our recommended precision. This is not feasible in DOS machines.; *; * To get around these problems, we apply Thomas' method to compute the; * nearest colors for only the cells within a small sub",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:217,cache,cache,217,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,4,['cache'],['cache']
Performance,"/*; * This API consists of small unitary functions, which must be inlined for best performance.; * Since link-time-optimization is not available for all compilers,; * these functions are defined into a .h to be included.; */; /*-****************************************; * Dependencies; ******************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h:83,perform,performance,83,builtins/zstd/common/bitstream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"/*; * This code is derived from (original license follows):; *; * This is an OpenSSL-compatible implementation of the RSA Data Security, Inc.; * MD5 Message-Digest Algorithm (RFC 1321).; *; * Homepage:; * http://openwall.info/wiki/people/solar/software/public-domain-source-code/md5; *; * Author:; * Alexander Peslyak, better known as Solar Designer <solar at openwall.com>; *; * This software was written by Alexander Peslyak in 2001. No copyright is; * claimed, and the software is hereby placed in the public domain.; * In case this attempt to disclaim copyright and place the software in the; * public domain is deemed null and void, then the software is; * Copyright (c) 2001 Alexander Peslyak and it is hereby released to the; * general public under the following terms:; *; * Redistribution and use in source and binary forms, with or without; * modification, are permitted.; *; * There's ABSOLUTELY NO WARRANTY, express or implied.; *; * (This is a heavily cut-down ""BSD license"".); *; * This differs from Colin Plumb's older public domain implementation in that; * no exactly 32-bit integer data type is required (any 32-bit or wider; * unsigned integer data type will do), there's no compile-time endianness; * configuration, and the function prototypes match OpenSSL's. No code from; * Colin Plumb's implementation has been reused; this comment merely compares; * the properties of the two independent implementations.; *; * The primary goals of this implementation are portability and ease of use.; * It is meant to be fast, but not as fast as possible. Some known; * optimizations are not included to reduce source code size and avoid; * compile-time configuration.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MD5.cpp:1580,optimiz,optimizations,1580,interpreter/llvm-project/llvm/lib/Support/MD5.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MD5.cpp,1,['optimiz'],['optimizations']
Performance,"/*; * This code is derived from OpenBSD's libc, original license follows:; *; * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>; *; * Permission to use, copy, modify, and distribute this software for any; * purpose with or without fee is hereby granted, provided that the above; * copyright notice and this permission notice appear in all copies.; *; * THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES; * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF; * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR; * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES; * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN; * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF; * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regstrlcpy.c:841,PERFORM,PERFORMANCE,841,interpreter/llvm-project/llvm/lib/Support/regstrlcpy.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regstrlcpy.c,1,['PERFORM'],['PERFORMANCE']
Performance,"/*; * This section is for debugging outside of VTune. ; * It creates the environment variables that indicates call graph mode.; * If running outside of VTune remove the remark.; *; *; * static int firstTime = 1;; * char DoCallGraph[12] = ""DoCallGraph"";; * if (firstTime); * {; * firstTime = 0;; * SetEnvironmentVariable( ""BISTRO_COLLECTORS_DO_CALLGRAPH"", DoCallGraph);; * }; *; * end of section.; */; /* initialization part - the functions have not been loaded yet. This part; * will load the functions, and check if we are in Call Graph mode. ; * (for special treatment).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:454,load,loaded,454,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,2,['load'],"['load', 'loaded']"
Performance,"/*; * UGLY HACK:; * Clang generates a bunch of MOV/MOVK pairs for aarch64, and they are; * placed sequentially, in order, at the top of the unrolled loop.; *; * While MOVK is great for generating constants (2 cycles for a 64-bit; * constant compared to 4 cycles for LDR), long MOVK chains stall the; * integer pipelines:; * I L S; * MOVK; * MOVK; * MOVK; * MOVK; * ADD; * SUB STR; * STR; * By forcing loads from memory (as the asm line causes Clang to assume; * that XXH3_kSecretPtr has been changed), the pipelines are used more; * efficiently:; * I L S; * LDR; * ADD LDR; * SUB STR; * STR; * XXH3_64bits_withSeed, len == 256, Snapdragon 835; * without hack: 2654.4 MB/s; * with hack: 3202.9 MB/s; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:401,load,loads,401,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['load'],['loads']
Performance,"/*; * UGLY HACK:; * GCC usually generates the best code with -O3 for xxHash.; *; * However, when targeting AVX2, it is overzealous in its unrolling resulting; * in code roughly 3/4 the speed of Clang.; *; * There are other issues, such as GCC splitting _mm256_loadu_si256 into; * _mm_loadu_si128 + _mm256_inserti128_si256. This is an optimization which; * only applies to Sandy and Ivy Bridge... which don't even support AVX2.; *; * That is why when compiling the AVX2 version, it is recommended to use either; * -O2 -mavx2 -march=haswell; * or; * -O2 -mavx2 -mno-avx256-split-unaligned-load; * for decent performance, or to use Clang instead.; *; * Fortunately, we can control the first one with a pragma that forces GCC into; * -O2, but the other one we can't control without ""failed to inline always; * inline function due to target mismatch"" warnings.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:334,optimiz,optimization,334,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,3,"['load', 'optimiz', 'perform']","['load', 'optimization', 'performance']"
Performance,"/*; * UGLY HACK:; * This inline assembly hack forces acc into a normal register. This is the; * only thing that prevents GCC and Clang from autovectorizing the XXH32; * loop (pragmas and attributes don't work for some resason) without globally; * disabling SSE4.1.; *; * The reason we want to avoid vectorization is because despite working on; * 4 integers at a time, there are multiple factors slowing XXH32 down on; * SSE4:; * - There's a ridiculous amount of lag from pmulld (10 cycles of latency on; * newer chips!) making it slightly slower to multiply four integers at; * once compared to four integers independently. Even when pmulld was; * fastest, Sandy/Ivy Bridge, it is still not worth it to go into SSE; * just to multiply unless doing a long operation.; *; * - Four instructions are required to rotate,; * movqda tmp, v // not required with VEX encoding; * pslld tmp, 13 // tmp <<= 13; * psrld v, 19 // x >>= 19; * por v, tmp // x |= tmp; * compared to one for scalar:; * roll v, 13 // reliably fast across the board; * shldl v, v, 13 // Sandy Bridge and later prefer this for some reason; *; * - Instruction level parallelism is actually more beneficial here because; * the SIMD actually serializes this operation: While v1 is rotating, v2; * can load data, while v3 can multiply. SSE forces them to operate; * together.; *; * How this hack works:; * __asm__("""" // Declare an assembly block but don't declare any instructions; * : // However, as an Input/Output Operand,; * ""+r"" // constrain a read/write operand (+) as a general purpose register (r).; * (acc) // and set acc as the operand; * );; *; * Because of the 'r', the compiler has promised that seed will be in a; * general purpose register and the '+' says that it will be 'read/write',; * so it has to assume it has changed. It is like volatile without all the; * loads and stores.; *; * Since the argument has to be in a normal register (not an SSE register),; * each time XXH32_round is called, it is impossible to vectorize",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:492,latency,latency,492,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['latency'],['latency']
Performance,"/*; * We need a separate pointer for the hack below,; * which requires a non-const pointer.; * Any decent compiler will optimize this out otherwise.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:120,optimiz,optimize,120,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['optimiz'],['optimize']
Performance,"/*; * XXH3_accumulate_512 is the tightest loop for long inputs, and it is the most optimized.; *; * It is a hardened version of UMAC, based off of FARSH's implementation.; *; * This was chosen because it adapts quite well to 32-bit, 64-bit, and SIMD; * implementations, and it is ridiculously fast.; *; * We harden it by mixing the original input to the accumulators as well as the product.; *; * This means that in the (relatively likely) case of a multiply by zero, the; * original input is preserved.; *; * On 128-bit inputs, we swap 64-bit pairs when we add the input to improve; * cross-pollination, as otherwise the upper and lower halves would be; * essentially independent.; *; * This doesn't matter on 64-bit hashes since they all get merged together in; * the end, so we skip the extra step.; *; * Both XXH3_64bits and XXH3_128bits use this subroutine.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:83,optimiz,optimized,83,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['optimiz'],['optimized']
Performance,"/*; * XXH3_hashLong_64b_withSeed():; * Generate a custom key based on alteration of default XXH3_kSecret with the seed,; * and then use this key for long mode hashing.; *; * This operation is decently fast but nonetheless costs a little bit of time.; * Try to avoid it whenever possible (typically when seed==0).; *; * It's important for performance that XXH3_hashLong is not inlined. Not sure; * why (uop cache maybe?), but the difference is large and easily measurable.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:338,perform,performance,338,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,"['cache', 'perform']","['cache', 'performance']"
Performance,/*; * XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load.; *; * This is ideal for older compilers which don't inline memcpy.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:68,load,load,68,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['load'],['load']
Performance,"/*; * deflate.c by Jean-loup Gailly.; *; * PURPOSE; *; * Identify new text as repetitions of old text within a fixed-; * length sliding window trailing behind the new text.; *; * DISCUSSION; *; * The ""deflation"" process depends on being able to identify portions; * of the input text which are identical to earlier input (within a; * sliding window trailing behind the input currently being processed).; *; * The most straightforward technique turns out to be the fastest for; * most input files: try all possible matches and select the longest.; * The key feature of this algorithm is that insertions into the string; * dictionary are very simple and thus fast, and deletions are avoided; * completely. Insertions are performed at each input character, whereas; * string matches are performed only when the previous match ends. So it; * is preferable to spend more time in matches to allow very fast string; * insertions and avoid deletions. The matching algorithm for small; * strings is inspired from that of Rabin & Karp. A brute force approach; * is used to find longer strings when a small match has been found.; * A similar algorithm is used in comic (by Jan-Mark Wams) and freeze; * (by Leonid Broukhis).; * A previous version of this file used a more sophisticated algorithm; * (by Fiala and Greene) which is guaranteed to run in linear amortized; * time, but has a larger average cost, uses more memory and is patented.; * However the F&G algorithm may be faster for some highly redundant; * files if the parameter max_chain_length (described below) is too large.; *; * ACKNOWLEDGEMENTS; *; * The idea of lazy evaluation of matches is due to Jan-Mark Wams, and; * I found it in 'freeze' written by Leonid Broukhis.; * Thanks to many info-zippers for bug reports and testing.; *; * REFERENCES; *; * APPNOTE.TXT documentation file in PKZIP 1.93a distribution.; *; * A description of the Rabin and Karp algorithm is given in the book; * ""Algorithms"" by R. Sedgewick, Addison-Wesley, p252.; *; *",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c:719,perform,performed,719,core/zip/src/ZDeflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c,2,['perform'],['performed']
Performance,"/*; * delaunayTriangulation.cxx; *; * Created on: Jun 30, 2014; * Author: dfunke; *; * This test creates a TGraph2D, fills it with 3 points and then performs; * the Delaunay triangulation of them.; *; * Because of bug ROOT-XXX the data structures were not properly initialized and no triangle was found; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/delaunayTriangulation.cxx:149,perform,performs,149,test/delaunayTriangulation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/delaunayTriangulation.cxx,1,['perform'],['performs']
Performance,"/*; * jcdctmgr.c; *; * Copyright (C) 1994-1996, Thomas G. Lane.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This file contains the forward-DCT management logic.; * This code selects a particular DCT implementation to be used,; * and it performs related housekeeping chores including coefficient; * quantization.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcdctmgr.c:338,perform,performs,338,graf2d/asimage/src/libAfterImage/libjpeg/jcdctmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcdctmgr.c,1,['perform'],['performs']
Performance,"/*; * jdct.h; *; * Copyright (C) 1994-1996, Thomas G. Lane.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This include file contains common declarations for the forward and; * inverse DCT modules. These declarations are private to the DCT managers; * (jcdctmgr.c, jddctmgr.c) and the individual DCT algorithms.; * The individual DCT algorithms are kept in separate files to ease ; * machine-dependent tuning (e.g., assembly coding).; */; /*; * A forward DCT routine is given a pointer to an input sample array and; * a pointer to a work area of type DCTELEM[]; the DCT is to be performed; * in-place in that buffer. Type DCTELEM is int for 8-bit samples, INT32; * for 12-bit samples. (NOTE: Floating-point DCT implementations use an; * array of type FAST_FLOAT, instead.); * The input data is to be fetched from the sample array starting at a; * specified column. (Any row offset needed will be applied to the array; * pointer before it is passed to the FDCT code.); * Note that the number of samples fetched by the FDCT routine is; * DCT_h_scaled_size * DCT_v_scaled_size.; * The DCT outputs are returned scaled up by a factor of 8; they therefore; * have a range of +-8K for 8-bit data, +-128K for 12-bit data. This; * convention improves accuracy in integer implementations and saves some; * work in floating-point ones.; * Quantization of the output coefficients is done by jcdctmgr.c.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdct.h:678,perform,performed,678,graf2d/asimage/src/libAfterImage/libjpeg/jdct.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdct.h,1,['perform'],['performed']
Performance,"/*; * jddctmgr.c; *; * Copyright (C) 1994-1996, Thomas G. Lane.; * Modified 2002-2010 by Guido Vollbeding.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This file contains the inverse-DCT management logic.; * This code selects a particular IDCT implementation to be used,; * and it performs related housekeeping chores. No code in this file; * is executed per IDCT step, only during output pass setup.; *; * Note that the IDCT routines are responsible for performing coefficient; * dequantization as well as the IDCT proper. This module sets up the; * dequantization multiplier table needed by the IDCT routine.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jddctmgr.c:382,perform,performs,382,graf2d/asimage/src/libAfterImage/libjpeg/jddctmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jddctmgr.c,2,['perform'],"['performing', 'performs']"
Performance,"/*; * jidctflt.c; *; * Copyright (C) 1994-1998, Thomas G. Lane.; * Modified 2010 by Guido Vollbeding.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This file contains a floating-point implementation of the; * inverse DCT (Discrete Cosine Transform). In the IJG code, this routine; * must also perform dequantization of the input coefficients.; *; * This implementation should be more accurate than either of the integer; * IDCT implementations. However, it may not give the same results on all; * machines because of differences in roundoff behavior. Speed will depend; * on the hardware's floating point capacity.; *; * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT; * on each row (or vice versa, but it's more convenient to emit a row at; * a time). Direct algorithms are also available, but they are much more; * complex and seem not to be any faster when reduced to code.; *; * This implementation is based on Arai, Agui, and Nakajima's algorithm for; * scaled DCT. Their original paper (Trans. IEICE E-71(11):1095) is in; * Japanese, but the algorithm is described in the Pennebaker & Mitchell; * JPEG textbook (see REFERENCES section in file README). The following code; * is based directly on figure 4-8 in P&M.; * While an 8-point DCT cannot be done in less than 11 multiplies, it is; * possible to arrange the computation so that many of the multiplies are; * simple scalings of the final outputs. These multiplies can then be; * folded into the multiplications or divisions by the JPEG quantization; * table entries. The AA&N method leaves only 5 multiplies and 29 adds; * to be done in the DCT itself.; * The primary disadvantage of this method is that with a fixed-point; * implementation, accuracy is lost due to imprecise representation of the; * scaled quantization values. However, that problem does not arise if; * we use floating point arithmetic.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctflt.c:393,perform,perform,393,graf2d/asimage/src/libAfterImage/libjpeg/jidctflt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctflt.c,1,['perform'],['perform']
Performance,"/*; * jidctfst.c; *; * Copyright (C) 1994-1998, Thomas G. Lane.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This file contains a fast, not so accurate integer implementation of the; * inverse DCT (Discrete Cosine Transform). In the IJG code, this routine; * must also perform dequantization of the input coefficients.; *; * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT; * on each row (or vice versa, but it's more convenient to emit a row at; * a time). Direct algorithms are also available, but they are much more; * complex and seem not to be any faster when reduced to code.; *; * This implementation is based on Arai, Agui, and Nakajima's algorithm for; * scaled DCT. Their original paper (Trans. IEICE E-71(11):1095) is in; * Japanese, but the algorithm is described in the Pennebaker & Mitchell; * JPEG textbook (see REFERENCES section in file README). The following code; * is based directly on figure 4-8 in P&M.; * While an 8-point DCT cannot be done in less than 11 multiplies, it is; * possible to arrange the computation so that many of the multiplies are; * simple scalings of the final outputs. These multiplies can then be; * folded into the multiplications or divisions by the JPEG quantization; * table entries. The AA&N method leaves only 5 multiplies and 29 adds; * to be done in the DCT itself.; * The primary disadvantage of this method is that with fixed-point math,; * accuracy is lost due to imprecise representation of the scaled; * quantization values. The smaller the quantization table entry, the less; * precise the scaled value, so this implementation does worse with high-; * quality-setting files than with low-quality ones.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctfst.c:370,perform,perform,370,graf2d/asimage/src/libAfterImage/libjpeg/jidctfst.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctfst.c,1,['perform'],['perform']
Performance,"/*; * jidctint.c; *; * Copyright (C) 1991-1998, Thomas G. Lane.; * Modification developed 2002-2009 by Guido Vollbeding.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This file contains a slow-but-accurate integer implementation of the; * inverse DCT (Discrete Cosine Transform). In the IJG code, this routine; * must also perform dequantization of the input coefficients.; *; * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT; * on each row (or vice versa, but it's more convenient to emit a row at; * a time). Direct algorithms are also available, but they are much more; * complex and seem not to be any faster when reduced to code.; *; * This implementation is based on an algorithm described in; * C. Loeffler, A. Ligtenberg and G. Moschytz, ""Practical Fast 1-D DCT; * Algorithms with 11 Multiplications"", Proc. Int'l. Conf. on Acoustics,; * Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.; * The primary algorithm described there uses 11 multiplies and 29 adds.; * We use their alternate method with 12 multiplies and 32 adds.; * The advantage of this method is that no data path contains more than one; * multiplication; this allows a very simple and accurate implementation in; * scaled fixed-point arithmetic, with a minimal number of shifts.; *; * We also provide IDCT routines with various output sample block sizes for; * direct resolution reduction or enlargement and for direct resolving the; * common 2x1 and 1x2 subsampling cases without additional resampling: NxN; * (N=1...16), 2NxN, and Nx2N (N=1...8) pixels for one 8x8 input DCT block.; *; * For N<8 we simply take the corresponding low-frequency coefficients of; * the 8x8 input DCT block and apply an NxN point IDCT on the sub-block; * to yield the downscaled outputs.; * This can be seen as direct low-pass downsampling from the DCT domain; * point of view rather than the usual spatial dom",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:423,perform,perform,423,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['perform'],['perform']
Performance,"/*; * jmorecfg.h; *; * Copyright (C) 1991-1997, Thomas G. Lane.; * Modified 1997-2009 by Guido Vollbeding.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This file contains additional configuration options that customize the; * JPEG software for special applications or support machine-dependent; * optimizations. Most users will not need to touch this file.; */; /*; * Define BITS_IN_JSAMPLE as either; * 8 for 8-bit sample values (the usual setting); * 12 for 12-bit sample values; * Only 8 and 12 are legal data precisions for lossy JPEG according to the; * JPEG standard, and the IJG code does not support anything else!; * We do not support run-time selection of data precision, sorry.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h:398,optimiz,optimizations,398,graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmorecfg.h,1,['optimiz'],['optimizations']
Performance,"/*; * prod_hi = (data_key >> 32) * XXH_PRIME32_1;; *; * Avoid vmul_u32 + vshll_n_u32 since Clang 6 and 7 will; * incorrectly ""optimize"" this:; * tmp = vmul_u32(vmovn_u64(a), vmovn_u64(b));; * shifted = vshll_n_u32(tmp, 32);; * to this:; * tmp = ""vmulq_u64""(a, b); // no such thing!; * shifted = vshlq_n_u64(tmp, 32);; *; * However, unlike SSE, Clang lacks a 64-bit multiply routine; * for NEON, and it scalarizes two 64-bit multiplies instead.; *; * vmull_u32 has the same timing as vmul_u32, and it avoids; * this bug completely.; * See https://bugs.llvm.org/show_bug.cgi?id=39967; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:126,optimiz,optimize,126,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['optimiz'],['optimize']
Performance,"/*; ** Module name : threads; **; ** Description :; ** This file implements four functions, which shall perform some; ** actions on objects like histograms and a canvas.; */; // a global canvas for the drawing of histograms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/threads.cxx:104,perform,perform,104,test/threads.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/threads.cxx,1,['perform'],['perform']
Performance,"/*; *--------------------------------------------------------------; * gdk_event_peek; *; * Gets the next event.; *; * Arguments:; *; * Results:; * If an event is waiting that we care about, returns ; * a copy of that event, but does not remove it from; * the queue. The pointer is to be freed with gdk_event_free.; * Otherwise, returns NULL.; *; * Side effects:; *; *--------------------------------------------------------------; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkevents.c:260,queue,queue,260,graf2d/win32gdk/gdk/src/gdk/gdkevents.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkevents.c,1,['queue'],['queue']
Performance,/*; *--------------------------------------------------------------; * gdk_events_pending; *; * Returns if events are pending on the queue.; *; * Arguments:; *; * Results:; * Returns TRUE if events are pending; *; * Side effects:; *; *--------------------------------------------------------------; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkevents-win32.c:133,queue,queue,133,graf2d/win32gdk/gdk/src/gdk/win32/gdkevents-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkevents-win32.c,1,['queue'],['queue']
Performance,"/*; *; * Inverse of complemented incomplete gamma integral; *; *; *; * SYNOPSIS:; *; * double a, x, p, igami();; *; * x = igami( a, p );; *; * DESCRIPTION:; *; * Given p, the function finds x such that; *; * igamc( a, x ) = p.; *; * Starting with the approximate value; *; * 3; * x = a t; *; * where; *; * t = 1 - d - ndtri(p) sqrt(d); *; * and; *; * d = 1/9a,; *; * the routine performs up to 10 Newton iterations to find the; * root of igamc(a,x) - p = 0.; *; * ACCURACY:; *; * Tested at random a, p in the intervals indicated.; *; * a p Relative error:; * arithmetic domain domain # trials peak rms; * IEEE 0.5,100 0,0.5 100000 1.0e-14 1.7e-15; * IEEE 0.01,0.5 0,0.5 100000 9.0e-14 3.4e-15; * IEEE 0.5,10000 0,0.5 20000 2.3e-13 3.8e-14; */; /*; Cephes Math Library Release 2.8: June, 2000; Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephesInv.cxx:379,perform,performs,379,math/mathcore/src/SpecFuncCephesInv.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephesInv.cxx,1,['perform'],['performs']
Performance,"/*; *; * Inverse of incomplete beta integral; *; *; *; * SYNOPSIS:; *; * double a, b, x, y, incbi();; *; * x = incbi( a, b, y );; *; *; *; * DESCRIPTION:; *; * Given y, the function finds x such that; *; * incbet( a, b, x ) = y .; *; * The routine performs interval halving or Newton iterations to find the; * root of incbet(a,b,x) - y = 0.; *; *; * ACCURACY:; *; * Relative error:; * x a,b; * arithmetic domain domain # trials peak rms; * IEEE 0,1 .5,10000 50000 5.8e-12 1.3e-13; * IEEE 0,1 .25,100 100000 1.8e-13 3.9e-15; * IEEE 0,1 0,5 50000 1.1e-12 5.5e-15; * VAX 0,1 .5,100 25000 3.5e-14 1.1e-15; * With a and b constrained to half-integer or integer values:; * IEEE 0,1 .5,10000 50000 5.8e-12 1.1e-13; * IEEE 0,1 .5,100 100000 1.7e-14 7.9e-16; * With a = .5, b constrained to half-integer or integer values:; * IEEE 0,1 .5,10000 10000 8.3e-11 1.0e-11; */; /*; Cephes Math Library Release 2.8: June, 2000; Copyright 1984, 1996, 2000 by Stephen L. Moshier; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephesInv.cxx:248,perform,performs,248,math/mathcore/src/SpecFuncCephesInv.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephesInv.cxx,1,['perform'],['performs']
Performance,"/*; *; * a few macros for the inner loops of the fill code where; * performance considerations don't allow a procedure call.; *; * Evaluate the given edge at the given scanline.; * If the edge has expired, then we leave it and fix up; * the active edge table; otherwise, we increment the; * x value to be ready for the next scanline.; * The winding number rule is in effect, so we must notify; * the caller when the edge has been removed so they; * can reorder the Winding Active Edge Table.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPolyUtils.c:68,perform,performance,68,graf2d/asimage/src/TASPolyUtils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPolyUtils.c,1,['perform'],['performance']
Performance,"/*; // Function called from GuiPanelController.; onExit: function(); {; // QQQQ EveManager does not have Unregister ... nor UnregisterController; if (this.mgr) this.mgr.Unregister(this);; // QQQQ plus, we should unregister this as gl-controller, too; },*/; // Checks if all initialization is performed and startup renderer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/controller/GL.controller.js:292,perform,performed,292,ui5/eve7/controller/GL.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/controller/GL.controller.js,1,['perform'],['performed']
Performance,"/*; // The contiguity has been dropped since now caching is backed up by a TDS; // TODO: we can optimise this. The reason why addresses are not contiguous with; // data sources (now cache is achieved with a data source) is linked to Snapshot.; // Indeed we need to set an address for each branch and keep that constant; // through the entire event loop (this is how the TTree works!).; // We could remove this constraint from data sources if Snapshot offered some; // sort of cache to which the data is copied.; TEST(Cache, Contiguity); {; ROOT::RDataFrame tdf(2);; auto f = 0.f;; auto cached = tdf.Define(""float"", [&f]() { return f++; }).Cache<float>({""float""});; int counter = 0;; float *fPrec = nullptr;; auto count = [&counter, &fPrec](float &ff) {; if (1 == counter++) {; EXPECT_EQ(1, std::distance(fPrec, &ff));; }; fPrec = &ff;; };; cached.Foreach(count, {""float""});; }; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx:182,cache,cache,182,tree/dataframe/test/dataframe_cache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx,6,"['Cache', 'cache']","['Cache', 'cache', 'cached']"
Performance,"/*; ////////////////////////////////////////////////////////////////////////////////. const RooArgSet& RooStats::HistFactory::RooBarlowBeestonLL::bestFitParams() const; {; validateAbsMin() ;; return _paramAbsMin ;; }. ////////////////////////////////////////////////////////////////////////////////. const RooArgSet& RooStats::HistFactory::RooBarlowBeestonLL::bestFitObs() const; {; validateAbsMin() ;; return _obsAbsMin ;; }; */; ////////////////////////////////////////////////////////////////////////////////; /// Optimized implementation of createProfile for profile likelihoods.; /// Return profile of original function in terms of stated parameters; /// of interest rather than profiling recursively.; /*; RooAbsReal* RooStats::HistFactory::RooBarlowBeestonLL::createProfile(const RooArgSet& paramsOfInterest); {; return nll().createProfile(paramsOfInterest) ;; }; */; /*; void RooStats::HistFactory::RooBarlowBeestonLL::FactorizePdf(const RooArgSet &observables, RooAbsPdf &pdf, RooArgList &obsTerms, RooArgList &constraints) const {; // utility function to factorize constraint terms from a pdf; // (from G. Petrucciani); const std::type_info & id = typeid(pdf);; if (id == typeid(RooProdPdf)) {; RooProdPdf *prod = dynamic_cast<RooProdPdf *>(&pdf);; RooArgList list(prod->pdfList());; for (int i = 0, n = list.size(); i < n; ++i) {; RooAbsPdf *pdfi = (RooAbsPdf *) list.at(i);; FactorizePdf(observables, *pdfi, obsTerms, constraints);; }; } else if (id == typeid(RooSimultaneous) ) { //|| id == typeid(RooSimultaneousOpt)) {; RooSimultaneous *sim = dynamic_cast<RooSimultaneous *>(&pdf);; std::unique_ptr<RooAbsCategoryLValue> cat{(RooAbsCategoryLValue *) sim->indexCat().Clone()};; for (int ic = 0, nc = cat->numBins((const char *)0); ic < nc; ++ic) {; cat->setBin(ic);; FactorizePdf(observables, *sim->getPdf(cat->getLabel()), obsTerms, constraints);; }; } else if (pdf.dependsOn(observables)) {; if (!obsTerms.contains(pdf)) obsTerms.add(pdf);; } else {; if (!constraints.contains(pdf)) co",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/RooBarlowBeestonLL.cxx:517,Optimiz,Optimized,517,roofit/histfactory/src/RooBarlowBeestonLL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/RooBarlowBeestonLL.cxx,1,['Optimiz'],['Optimized']
Performance,"/*; ////////////////////////////////////////////////////////////////////////////////; /// thread for processing windows messages (aka Main/Server thread). static DWORD WINAPI MessageProcessingLoop(void *p); {; MSG msg;; Int_t erret;; Bool_t endLoop = kFALSE;; TGWin32RefreshTimer *refersh = 0;. // force to create message queue; ::PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);. // periodically we refresh windows; // Don't create refresh timer if the application has been created inside PVSS; if (gApplication) {; TString arg = gSystem->BaseName(gApplication->Argv(0));; if (!arg.Contains(""PVSS"")); refersh = new TGWin32RefreshTimer();; }. while (!endLoop) {; erret = ::GetMessage(&msg, NULL, NULL, NULL);; if (erret <= 0) endLoop = kTRUE;; endLoop = MessageProcessingFunc(&msg);; }. TGWin32::Instance()->CloseDisplay();; if (refersh); delete refersh;. // exit thread; if (erret == -1) {; erret = ::GetLastError();; Error(""MsgLoop"", ""Error in GetMessage"");; ::ExitThread(-1);; } else {; ::ExitThread(0);; }; return 0;; }; */; ////////////////////////////////////////////////////////////////////////////////; /// constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:322,queue,queue,322,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,1,['queue'],['queue']
Performance,"/*; ////////////////////////////////////////////////////////////////////////////////; ///; /// Test size to build kdtree; ///. void TestSizeIF(Int_t nsec, Int_t nrows, Int_t npoints, Int_t bsize, Int_t mode); {; Float_t before =Mem();; for (Int_t isec=0; isec<nsec;isec++); for (Int_t irow=0;irow<nrows;irow++){; TestkdtreeIF(npoints,1,mode,bsize);; }; Float_t after = Mem();; printf(""Memory usage %f\n"",after-before);; }; */; /*; ////////////////////////////////////////////////////////////////////////////////; ///; /// Test speed and functionality of 2D kdtree.; /// Input parameters:; /// npoints - number of data points; /// bsize - bucket size; /// nloop - number of loops; /// mode - tasks to be performed by the kdTree; /// - 0 : time building the tree; ///. void TestkdtreeIF(Int_t npoints, Int_t bsize, Int_t nloop, Int_t mode); {. Float_t rangey = 100;; Float_t rangez = 100;; Float_t drangey = 0.1;; Float_t drangez = 0.1;. //; Float_t *data0 = new Float_t[npoints*2];; Float_t *data[2];; data[0] = &data0[0];; data[1] = &data0[npoints];; //Int_t i;; for (Int_t i=0; i<npoints; i++){; data[0][i] = gRandom->Uniform(-rangey, rangey);; data[1][i] = gRandom->Uniform(-rangez, rangez);; }; TStopwatch timer;. // check time build; printf(""building kdTree ...\n"");; timer.Start(kTRUE);; TKDTreeIF *kdtree = new TKDTreeIF(npoints, 2, bsize, data);; kdtree->Build();; timer.Stop();; timer.Print();; if(mode == 0) return;. Float_t countern=0;; Float_t counteriter = 0;; Float_t counterfound = 0;. if (mode ==2){; if (nloop) timer.Start(kTRUE);; Int_t *res = new Int_t[npoints];; Int_t nfound = 0;; for (Int_t kloop = 0;kloop<nloop;kloop++){; if (kloop==0){; counteriter = 0;; counterfound= 0;; countern = 0;; }; for (Int_t i=0;i<npoints;i++){; Float_t point[2]={data[0][i],data[1][i]};; Float_t delta[2]={drangey,drangez};; Int_t iter =0;; nfound =0;; Int_t bnode =0;; //kdtree->FindBNode(point,delta, bnode);; //continue;; kdtree->FindInRangeA(point,delta,res,nfound,iter,bnode);; if (kloop==0){; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/kDTreeTest.cxx:703,perform,performed,703,math/mathcore/test/kDTreeTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/kDTreeTest.cxx,1,['perform'],['performed']
Performance,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any pending; output. deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the; stream state was inconsistent, Z_DATA_ERROR if the stream was freed; prematurely (some input or output was discarded). In the error case, msg; may be set but then points to a static string (which must not be; deallocated).; */; /*; ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));. Initializes the internal stream state for decompression. The fields; next_in, avail_in, zalloc, zfree and opaque must be initialized before by; the caller. If next_in is not Z_NULL and avail_in is large enough (the; exact value depends on the compression method), inflateInit determines the; compression method from the zlib header and allocates all data structures; accordingly; otherwise the allocation will be deferred to the first call of; inflate. If zalloc and zfree are set to Z_NULL, inflateInit updates them to; use default allocation functions. inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller, or Z_STREAM_ERROR if the parameters are; invalid, such as a null pointer to the structure. msg is set to null if; there is no error message. inflateInit does not perform any decompression; apart from possibly reading the zlib header if present: actual decompression; will be done by inflate(). (So next_in and avail_in may be modified, but; next_out and avail_out are unused and unchanged.) The current implementation; of inflateInit() does not process any header information -- that is deferred; until inflate() is called.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:1405,perform,perform,1405,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['perform'],['perform']
Performance,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any; pending output. deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the; stream state was inconsistent, Z_DATA_ERROR if the stream was freed; prematurely (some input or output was discarded). In the error case,; msg may be set but then points to a static string (which must not be; deallocated).; */; /*; ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));. Initializes the internal stream state for decompression. The fields; next_in, avail_in, zalloc, zfree and opaque must be initialized before by; the caller. If next_in is not Z_NULL and avail_in is large enough (the exact; value depends on the compression method), inflateInit determines the; compression method from the zlib header and allocates all data structures; accordingly; otherwise the allocation will be deferred to the first call of; inflate. If zalloc and zfree are set to Z_NULL, inflateInit updates them to; use default allocation functions. inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller. msg is set to null if there is no error; message. inflateInit does not perform any decompression apart from reading; the zlib header if present: this will be done by inflate(). (So next_in and; avail_in may be modified, but next_out and avail_out are unchanged.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:1314,perform,perform,1314,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['perform'],['perform']
Performance,/*; Clears the error and end-of-file flags for file. This is analogous to the; clearerr() function in stdio. This is useful for continuing to read a gzip; file that is being written concurrently.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:182,concurren,concurrently,182,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['concurren'],['concurrently']
Performance,/*; Clears the error and end-of-file flags for file. This is analogous to the; clearerr() function in stdio. This is useful for continuing to read a gzip; file that is being written concurrently.; */; /* checksum functions */; /*; These functions are not related to compression but are exported; anyway because they might be useful in applications using the; compression library.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:182,concurren,concurrently,182,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['concurren'],['concurrently']
Performance,"/*; Copyright 1992 Mark Spychalla. Permission to use, copy, modify, distribute, and sell this software and; its documentation for any purpose is hereby granted without fee,; provided that the above copyright notice appear in all copies and that; both that copyright notice and this permission notice appear in; supporting documentation, and that the name of Mark Spychalla not be used; in advertising or publicity pertaining to distribution of the software; without specific, written prior permission. Mark Spychalla makes no; representations about the suitability of this software for any purpose.; It is provided ""as is"" without express or implied warranty. Mark Spychalla disclaims all warranties with regard to this software,; including all implied warranties of merchantability and fitness, in no; event shall Mark Spychalla be liable for any special, indirect or; consequential damages or any damages whatsoever resulting from loss of use,; data or profits, whether in an action of contract, negligence or other; tortious action, arising out of or in connection with the use or performance; of this software.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.h:1084,perform,performance,1084,graf3d/x3d/src/x3d.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.h,1,['perform'],['performance']
Performance,"/*; Fine tune deflate's internal compression parameters. This should only be; used by someone who understands the algorithm used by zlib's deflate for; searching for the best matching string, and even then only by the most; fanatic optimizer trying to squeeze out the last compressed bit for their; specific input data. Read the deflate.c source code for the meaning of the; max_lazy, good_length, nice_length, and max_chain parameters. deflateTune() can be called after deflateInit() or deflateInit2(), and; returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:9,tune,tune,9,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,4,"['optimiz', 'tune']","['optimizer', 'tune']"
Performance,"/*; Huffman code decoding is performed using a multi-level table lookup.; The fastest way to decode is to simply build a lookup table whose; size is determined by the longest code. However, the time it takes; to build this table can also be a factor if the data being decoded; is not very long. The most common codes are necessarily the; shortest codes, so those codes dominate the decoding time, and hence; the speed. The idea is you can have a shorter table that decodes the; shorter, more probable codes, and then point to subsidiary tables for; the longer codes. The time it costs to decode the longer codes is; then traded against the time it takes to make longer tables. This results of this trade are in the variables lbits and dbits; below. lbits is the number of bits the first level table for literal/; length codes can decode in one step, and dbits is the same thing for; the distance codes. Subsequent tables are also less than or equal to; those sizes. These values may be adjusted either when all of the; codes are shorter than that, in which case the longest code length in; bits is used, or when the shortest code is *longer* than the requested; table size, in which case the length of the shortest code in bits is; used. There are two different values for the two tables, since they code a; different number of possibilities each. The literal/length table; codes 286 possible values, or in a flat code, a little over eight; bits. The distance table codes 30 possible values, or a little less; than five bits, flat. The optimum values for speed end up being; about one bit more than those, so lbits is 8+1 and dbits is 5+1.; The optimum values may differ though from machine to machine, and; possibly even between compilers. Your mileage may vary.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c:29,perform,performed,29,core/zip/src/ZInflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c,1,['perform'],['performed']
Performance,"/*; Initializes the compression dictionary from the given byte sequence; without producing any compressed output. This function must be called; immediately after deflateInit, deflateInit2 or deflateReset, before any; call of deflate. The compressor and decompressor must use exactly the same; dictionary (see inflateSetDictionary). The dictionary should consist of strings (byte sequences) that are likely; to be encountered later in the data to be compressed, with the most commonly; used strings preferably put towards the end of the dictionary. Using a; dictionary is most useful when the data to be compressed is short and can be; predicted with good accuracy; the data can then be compressed better than; with the default empty dictionary. Depending on the size of the compression data structures selected by; deflateInit or deflateInit2, a part of the dictionary may in effect be; discarded, for example if the dictionary is larger than the window size in; deflate or deflate2. Thus the strings most likely to be useful should be; put at the end of the dictionary, not at the front. In addition, the; current implementation of deflate will use at most the window size minus; 262 bytes of the provided dictionary. Upon return of this function, strm->adler is set to the adler32 value; of the dictionary; the decompressor may later use this value to determine; which dictionary has been used by the compressor. (The adler32 value; applies to the whole dictionary even if only a subset of the dictionary is; actually used by the compressor.) If a raw deflate was requested, then the; adler32 value is not computed and strm->adler is not set. deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a; parameter is invalid (such as NULL dictionary) or the stream state is; inconsistent (for example if deflate has already been called for this stream; or if the compression method is bsort). deflateSetDictionary does not; perform any compression: this will be done by deflate().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:1935,perform,perform,1935,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['perform'],['perform']
Performance,"/*; Initializes the decompression dictionary from the given uncompressed byte; sequence. This function must be called immediately after a call of inflate,; if that call returned Z_NEED_DICT. The dictionary chosen by the compressor; can be determined from the adler32 value returned by that call of inflate.; The compressor and decompressor must use exactly the same dictionary (see; deflateSetDictionary). For raw inflate, this function can be called at any; time to set the dictionary. If the provided dictionary is smaller than the; window and there is already data in the window, then the provided dictionary; will amend what's there. The application must insure that the dictionary; that was used for compression is provided. inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a; parameter is invalid (e.g. dictionary being Z_NULL) or the stream state is; inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the; expected one (incorrect adler32 value). inflateSetDictionary does not; perform any decompression: this will be done by subsequent calls of; inflate().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:1014,perform,perform,1014,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['perform'],['perform']
Performance,"/*; Initializes the decompression dictionary from the given uncompressed byte; sequence. This function must be called immediately after a call of inflate,; if that call returned Z_NEED_DICT. The dictionary chosen by the compressor; can be determined from the adler32 value returned by that call of inflate.; The compressor and decompressor must use exactly the same dictionary (see; deflateSetDictionary). For raw inflate, this function can be called; immediately after inflateInit2() or inflateReset() and before any call of; inflate() to set the dictionary. The application must insure that the; dictionary that was used for compression is provided. inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a; parameter is invalid (such as NULL dictionary) or the stream state is; inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the; expected one (incorrect adler32 value). inflateSetDictionary does not; perform any decompression: this will be done by subsequent calls of; inflate().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:931,perform,perform,931,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['perform'],['perform']
Performance,"/*; Kernel Density Estimation class.; The three main references are. (1) ""Scott DW, Multivariate Density Estimation.Theory, Practice and Visualization. New York: Wiley"",; (2) ""Jann Ben - ETH Zurich, Switzerland -, Univariate kernel density estimation document for KDENS: Stata module for univariate kernel density estimation.""; (3) ""Hardle W, Muller M, Sperlich S, Werwatz A, Nonparametric and Semiparametric Models. Springer.""The algorithm is briefly described in; ""Cranmer KS, Kernel Estimation in High-Energy Physics. Computer Physics Communications 136:198-207,2001"" - e-Print Archive: hep ex/0011057.; A binned version is also implemented to address the performance issue due to its data size dependence.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TKDE.h:659,perform,performance,659,hist/hist/inc/TKDE.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TKDE.h,1,['perform'],['performance']
Performance,"/*; Reads the given number of uncompressed bytes from the compressed file. If; the input file is not in gzip format, gzread copies the given number of; bytes into the buffer directly from the file. After reaching the end of a gzip stream in the input, gzread will continue; to read, looking for another gzip stream. Any number of gzip streams may be; concatenated in the input file, and will all be decompressed by gzread().; If something other than a gzip stream is encountered after a gzip stream,; that remaining trailing garbage is ignored (and no error is returned). gzread can be used to read a gzip file that is being concurrently written.; Upon reaching the end of the input, gzread will return with the available; data. If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then; gzclearerr can be used to clear the end of file indicator in order to permit; gzread to be tried again. Z_OK indicates that a gzip stream was completed; on the last gzread. Z_BUF_ERROR indicates that the input file ended in the; middle of a gzip stream. Note that gzread does not return -1 in the event; of an incomplete gzip stream. This error is deferred until gzclose(), which; will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip; stream. Alternatively, gzerror can be used before gzclose to detect this; case. gzread returns the number of uncompressed bytes actually read, less than; len for end of file, or -1 for error.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:625,concurren,concurrently,625,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['concurren'],['concurrently']
Performance,"/*; Some implementation details:. - The conditional `RLogBuilder` use prevents stream operators from being called if; verbosity is too low, i.e.:; ~~~; RLogScopedVerbosity silence(RLogLevel::kFatal);; R__LOG_DEBUG(7) << WillNotBeCalled();; ~~~; - To update counts of warnings / errors / fatal errors, those RLogEntries must; always be created, even if in the end their emission will be silenced. This; should be fine, performance-wise, as they should not happen frequently.; - Use `(condition) && RLogBuilder(...)` instead of `if (condition) RLogBuilder(...)`; to prevent ""ambiguous else"" in invocations such as `if (something) R__LOG_DEBUG()...`.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx:418,perform,performance-wise,418,core/foundation/inc/ROOT/RLogger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx,1,['perform'],['performance-wise']
Performance,"/*; TGLHistPainter is a proxy class. It inherits TVirtualHistPainter and; overrides its virtual functions, but all actual work is done by :; THistPainter - I name it ""default"" painter, it's the member of type; TVirtualHistPainter * and loaded via plugin-manager;; TGLLegoPainter - it draws different legos (lego/lego1/lego2/lego3);; TGLSurfacePainter - supports surfaces (surf/surf1/surf2/surf3/surf4/surf5);; TGLBoxPainter - box option for TH3;; TGLTF3Painter - TF3.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLHistPainter.h:236,load,loaded,236,graf3d/gl/inc/TGLHistPainter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLHistPainter.h,1,['load'],['loaded']
Performance,"/*; The application must update next_in and avail_in when avail_in has dropped; to zero. It must update next_out and avail_out when avail_out has dropped; to zero. The application must initialize zalloc, zfree and opaque before; calling the init function. All other fields are set by the compression; library and must not be updated by the application. The opaque value provided by the application will be passed as the first; parameter for calls of zalloc and zfree. This can be useful for custom; memory management. The compression library attaches no meaning to the; opaque value. zalloc must return Z_NULL if there is not enough memory for the object.; If zlib is used in a multi-threaded application, zalloc and zfree must be; thread safe. On 16-bit systems, the functions zalloc and zfree must be able to allocate; exactly 65536 bytes, but will not be required to allocate more than this if; the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS, pointers; returned by zalloc for objects of exactly 65536 bytes *must* have their; offset normalized to zero. The default allocation function provided by this; library ensures this (see zutil.c). To reduce memory requirements and avoid; any allocation of 64K objects, at the expense of compression ratio, compile; the library with -DMAX_WBITS=14 (see zconf.h). The fields total_in and total_out can be used for statistics or progress; reports. After compression, total_in holds the total size of the; uncompressed data and may be saved for use in the decompressor (particularly; if the decompressor wants to decompress everything in a single step).; */; /* constants */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:678,multi-thread,multi-threaded,678,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['multi-thread'],['multi-threaded']
Performance,"/*; The application must update next_in and avail_in when avail_in has; dropped to zero. It must update next_out and avail_out when avail_out; has dropped to zero. The application must initialize zalloc, zfree and; opaque before calling the init function. All other fields are set by the; compression library and must not be updated by the application. The opaque value provided by the application will be passed as the first; parameter for calls of zalloc and zfree. This can be useful for custom; memory management. The compression library attaches no meaning to the; opaque value. zalloc must return Z_NULL if there is not enough memory for the object.; If zlib is used in a multi-threaded application, zalloc and zfree must be; thread safe. On 16-bit systems, the functions zalloc and zfree must be able to allocate; exactly 65536 bytes, but will not be required to allocate more than this; if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,; pointers returned by zalloc for objects of exactly 65536 bytes *must*; have their offset normalized to zero. The default allocation function; provided by this library ensures this (see zutil.c). To reduce memory; requirements and avoid any allocation of 64K objects, at the expense of; compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h). The fields total_in and total_out can be used for statistics or; progress reports. After compression, total_in holds the total size of; the uncompressed data and may be saved for use in the decompressor; (particularly if the decompressor wants to decompress everything in; a single step).; */; /* constants */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:678,multi-thread,multi-threaded,678,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['multi-thread'],['multi-threaded']
Performance,"/*; The rounding mode is in bits 11:10 of FPSR, and has the following; settings:; 00 Round to nearest; 01 Round to -inf; 10 Round to +inf; 11 Round to 0. GET_ROUNDING, on the other hand, expects the following:; -1 Undefined; 0 Round to 0; 1 Round to nearest; 2 Round to +inf; 3 Round to -inf. To perform the conversion, we use a packed lookup table of the four 2-bit; values that we can index by FPSP[11:10]; 0x2d --> (0b00,10,11,01) --> (0,2,3,1) >> FPSR[11:10]. (0x2d >> ((FPSR & 0xc00) >> 9)) & 3; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:296,perform,perform,296,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['perform']
Performance,"/*; The rounding mode is in bits 30:31 of FPSR, and has the following; settings:; 00 Round to nearest; 01 Round to 0; 10 Round to +inf; 11 Round to -inf. GET_ROUNDING, on the other hand, expects the following:; -1 Undefined; 0 Round to 0; 1 Round to nearest; 2 Round to +inf; 3 Round to -inf. To perform the conversion, we do:; ((FPSCR & 0x3) ^ ((~FPSCR & 0x3) >> 1)); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:296,perform,perform,296,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['perform'],['perform']
Performance,"/*; This method performs Unroll and Jam. For a simple loop like:; for (i = ..); Fore(i); for (j = ..); SubLoop(i, j); Aft(i). Instead of doing normal inner or outer unrolling, we do:; for (i = .., i+=2); Fore(i); Fore(i+1); for (j = ..); SubLoop(i, j); SubLoop(i+1, j); Aft(i); Aft(i+1). So the outer loop is essetially unrolled and then the inner loops are fused; (""jammed"") together into a single loop. This can increase speed when there; are loads in SubLoop that are invariant to i, as they become shared between; the now jammed inner loops. We do this by spliting the blocks in the loop into Fore, Subloop and Aft.; Fore blocks are those before the inner loop, Aft are those after. Normal; Unroll code is used to copy each of these sets of blocks and the results are; combined together into the final form above. isSafeToUnrollAndJam should be used prior to calling this to make sure the; unrolling will be valid. Checking profitablility is also advisable. If EpilogueLoop is non-null, it receives the epilogue loop (if it was; necessary to create one and not fully unrolled).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:16,perform,performs,16,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,2,"['load', 'perform']","['loads', 'performs']"
Performance,"/*; ToDo list for expanding this check in the future, the list is not exhaustive.; There are also cases where calling super is suggested but not ""mandatory"".; In addition to be able to check the classes and methods below, architectural; improvements like being able to allow for the super-call to be done in a called; method would be good too. UIDocument subclasses; - finishedHandlingError:recovered: (is multi-arg); - finishedHandlingError:recovered: (is multi-arg). UIViewController subclasses; - loadView (should *never* call super); - transitionFromViewController:toViewController:; duration:options:animations:completion: (is multi-arg). UICollectionViewController subclasses; - loadView (take care because UIViewController subclasses should NOT call super; in loadView, but UICollectionViewController subclasses should). NSObject subclasses; - doesNotRecognizeSelector (it only has to call super if it doesn't throw). UIPopoverBackgroundView subclasses (some of those are class methods); - arrowDirection (should *never* call super); - arrowOffset (should *never* call super); - arrowBase (should *never* call super); - arrowHeight (should *never* call super); - contentViewInsets (should *never* call super). UITextSelectionRect subclasses (some of those are properties); - rect (should *never* call super); - range (should *never* call super); - writingDirection (should *never* call super); - isVertical (should *never* call super); - containsStart (should *never* call super); - containsEnd (should *never* call super); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp:500,load,loadView,500,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,3,['load'],['loadView']
Performance,"/*; Update a running CRC-32 with the bytes buf[0..len-1] and return the; updated CRC-32. If buf is NULL, this function returns the required initial; value for the for the crc. Pre- and post-conditioning (one's complement) is; performed within this function so it shouldn't be done by the application.; Usage example:. uLong crc = crc32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; crc = crc32(crc, buffer, length);; }; if (crc != original_crc) error();; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:226,perform,performed,226,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['perform'],['performed']
Performance,"/*; Update a running CRC-32 with the bytes buf[0..len-1] and return the; updated CRC-32. If buf is Z_NULL, this function returns the required; initial value for the crc. Pre- and post-conditioning (one's complement) is; performed within this function so it shouldn't be done by the application. Usage example:. uLong crc = crc32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; crc = crc32(crc, buffer, length);; }; if (crc != original_crc) error();; */; /*; ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));. Combine two CRC-32 check values into one. For two sequences of bytes,; seq1 and seq2 with lengths len1 and len2, CRC-32 check values were; calculated for each, crc1 and crc2. crc32_combine() returns the CRC-32; check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and; len2.; */; /* various hacks, don't look :) */; /* deflateInit and inflateInit are macros to allow checking the zlib version; * and the compiler's view of z_stream:; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:220,perform,performed,220,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['perform'],['performed']
Performance,/*; \class TGenListProxy; \ingroup IO; Local optimization class. Collection proxies get copied. On copy we switch the type of the; proxy to the concrete STL type. The concrete types are optimized; for element access.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionProxy.cxx:45,optimiz,optimization,45,io/io/src/TGenCollectionProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionProxy.cxx,2,['optimiz'],"['optimization', 'optimized']"
Performance,"/*; cout <<""Enter analytic Integral""<<endl;; printDirty(true);; // _nominal.arg().setDirtyInhibit(true) ;; _nominal.arg().setShapeDirty() ;; RooAbsReal* temp ;; RooFIter lowIter(_lowSet.fwdIterator()) ;; while((temp=(RooAbsReal*)lowIter.next())) {; // temp->setDirtyInhibit(true) ;; temp->setShapeDirty() ;; }; RooFIter highIter(_highSet.fwdIterator()) ;; while((temp=(RooAbsReal*)highIter.next())) {; // temp->setDirtyInhibit(true) ;; temp->setShapeDirty() ;; }; */; /*; RooAbsArg::setDirtyInhibit(true);; printDirty(true);; cout <<""done setting dirty inhibit = true""<<endl;. // old integral, only works for linear and not positive definite; CacheElem* cache = (CacheElem*) _normIntMgr.getObjByIndex(code-1) ;. std::unique_ptr<RooArgSet> vars2( getParameters(RooArgSet()) );; std::unique_ptr<RooArgSet> iset( _normIntMgr.nameSet2ByIndex(code-1)->select(*vars2) );; cout <<""iset = ""<<endl;; iset->Print(""v"");. double sum = 0;; RooArgSet* vars = getVariables();; vars->remove(_paramSet);; _paramSet.Print(""v"");; vars->Print(""v"");; if(vars->size()==1){; RooRealVar* obs = (RooRealVar*) vars->first();; for(int i=0; i<obs->numBins(); ++i){; obs->setVal( obs->getMin() + (.5+i)*(obs->getMax()-obs->getMin())/obs->numBins());; sum+=evaluate()*(obs->getMax()-obs->getMin())/obs->numBins();; cout << ""obs = "" << obs->getVal() << "" sum = "" << sum << endl;; }; } else{; cout <<""only know how to deal with 1 observable right now""<<endl;; }; */; /*; _nominal.arg().setDirtyInhibit(false) ;; RooFIter lowIter2(_lowSet.fwdIterator()) ;; while((temp=(RooAbsReal*)lowIter2.next())) {; temp->setDirtyInhibit(false) ;; }; RooFIter highIter2(_highSet.fwdIterator()) ;; while((temp=(RooAbsReal*)highIter2.next())) {; temp->setDirtyInhibit(false) ;; }; */; /*; RooAbsArg::setDirtyInhibit(false);; printDirty(true);; cout <<""done""<<endl;; cout << ""sum = "" <<sum<<endl;; //return sum;; */; // old integral, only works for linear and not positive definite",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/PiecewiseInterpolation.cxx:643,Cache,CacheElem,643,roofit/histfactory/src/PiecewiseInterpolation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/PiecewiseInterpolation.cxx,3,"['Cache', 'cache']","['CacheElem', 'cache']"
Performance,"/*; deflate compresses as much data as possible, and stops when the input; buffer becomes empty or the output buffer becomes full. It may introduce some; output latency (reading input without producing any output) except when; forced to flush. The detailed semantics are as follows. deflate performs one or both of the; following actions:. - Compress more input starting at next_in and update next_in and avail_in; accordingly. If not all input can be processed (because there is not; enough room in the output buffer), next_in and avail_in are updated and; processing will resume at this point for the next call of deflate(). - Provide more output starting at next_out and update next_out and avail_out; accordingly. This action is forced if the parameter flush is non zero.; Forcing flush frequently degrades the compression ratio, so this parameter; should be set only when necessary (in interactive applications).; Some output may be provided even if flush is not set. Before the call of deflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming; more output, and updating avail_in or avail_out accordingly; avail_out; should never be zero before the call. The application can consume the; compressed output when it wants, for example when the output buffer is full; (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK; and with zero avail_out, it must be called again after making room in the; output buffer because there might be more output pending. Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to; decide how much data to accumualte before producing output, in order to; maximize compression. If the parameter flush is set to Z_SYNC_FLUSH, all pending output is; flushed to the output buffer and the output is aligned on a byte boundary, so; that the decompressor can get all input data available so far. (In particular; avail_in is zero after the call if enough output sp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:161,latency,latency,161,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,2,"['latency', 'perform']","['latency', 'performs']"
Performance,"/*; deflate compresses as much data as possible, and stops when the input; buffer becomes empty or the output buffer becomes full. It may introduce; some output latency (reading input without producing any output) except when; forced to flush. The detailed semantics are as follows. deflate performs one or both of the; following actions:. - Compress more input starting at next_in and update next_in and avail_in; accordingly. If not all input can be processed (because there is not; enough room in the output buffer), next_in and avail_in are updated and; processing will resume at this point for the next call of deflate(). - Provide more output starting at next_out and update next_out and avail_out; accordingly. This action is forced if the parameter flush is non zero.; Forcing flush frequently degrades the compression ratio, so this parameter; should be set only when necessary (in interactive applications). Some; output may be provided even if flush is not set. Before the call of deflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming more; output, and updating avail_in or avail_out accordingly; avail_out should; never be zero before the call. The application can consume the compressed; output when it wants, for example when the output buffer is full (avail_out; == 0), or after each call of deflate(). If deflate returns Z_OK and with; zero avail_out, it must be called again after making room in the output; buffer because there might be more output pending. Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to; decide how much data to accumulate before producing output, in order to; maximize compression. If the parameter flush is set to Z_SYNC_FLUSH, all pending output is; flushed to the output buffer and the output is aligned on a byte boundary, so; that the decompressor can get all input data available so far. (In; particular avail_in is zero after the call if enough output sp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:161,latency,latency,161,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,2,"['latency', 'perform']","['latency', 'performs']"
Performance,"/*; if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }; */; // See concrete examples in TH1::H1FitChisquare, H1FitLikelihood",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:339,Perform,Perform,339,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['Perform'],['Perform']
Performance,"/*; inflate decompresses as much data as possible, and stops when the input; buffer becomes empty or the output buffer becomes full. It may introduce; some output latency (reading input without producing any output) except when; forced to flush. The detailed semantics are as follows. inflate performs one or both of the; following actions:. - Decompress more input starting at next_in and update next_in and avail_in; accordingly. If not all input can be processed (because there is not; enough room in the output buffer), next_in is updated and processing will; resume at this point for the next call of inflate(). - Provide more output starting at next_out and update next_out and avail_out; accordingly. inflate() provides as much output as possible, until there is; no more input data or no more space in the output buffer (see below about; the flush parameter). Before the call of inflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming more; output, and updating the next_* and avail_* values accordingly. The; application can consume the uncompressed output when it wants, for example; when the output buffer is full (avail_out == 0), or after each call of; inflate(). If inflate returns Z_OK and with zero avail_out, it must be; called again after making room in the output buffer because there might be; more output pending. The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,; Z_BLOCK, or Z_TREES. Z_SYNC_FLUSH requests that inflate() flush as much; output as possible to the output buffer. Z_BLOCK requests that inflate(); stop if and when it gets to the next deflate block boundary. When decoding; the zlib or gzip format, this will cause inflate() to return immediately; after the header and before the first block. When doing a raw inflate,; inflate() will go ahead and process the first block, and will return when it; gets to the end of that block, or when it runs out of data. The Z_BLO",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:163,latency,latency,163,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,2,"['latency', 'perform']","['latency', 'performs']"
Performance,"/*; inflate decompresses as much data as possible, and stops when the input; buffer becomes empty or the output buffer becomes full. It may introduce; some output latency (reading input without producing any output) except when; forced to flush. The detailed semantics are as follows. inflate performs one or both of the; following actions:. - Decompress more input starting at next_in and update next_in and avail_in; accordingly. If not all input can be processed (because there is not; enough room in the output buffer), next_in is updated and processing; will resume at this point for the next call of inflate(). - Provide more output starting at next_out and update next_out and avail_out; accordingly. inflate() provides as much output as possible, until there; is no more input data or no more space in the output buffer (see below; about the flush parameter). Before the call of inflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming; more output, and updating the next_* and avail_* values accordingly.; The application can consume the uncompressed output when it wants, for; example when the output buffer is full (avail_out == 0), or after each; call of inflate(). If inflate returns Z_OK and with zero avail_out, it; must be called again after making room in the output buffer because there; might be more output pending. The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,; Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much; output as possible to the output buffer. Z_BLOCK requests that inflate() stop; if and when it gets to the next deflate block boundary. When decoding the; zlib or gzip format, this will cause inflate() to return immediately after; the header and before the first block. When doing a raw inflate, inflate(); will go ahead and process the first block, and will return when it gets to; the end of that block, or when it runs out of data. The Z_BLOCK option",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:163,latency,latency,163,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,2,"['latency', 'perform']","['latency', 'performs']"
Performance,"/*; inflate() uses a state machine to process as much input data and generate as; much output data as possible before returning. The state machine is; structured roughly as follows:. for (;;) switch (state) {; ...; case STATEn:; if (not enough input data or output space to make progress); return;; ... make progress ...; state = STATEm;; break;; ...; }. so when inflate() is called again, the same case is attempted again, and; if the appropriate resources are provided, the machine proceeds to the; next state. The NEEDBITS() macro is usually the way the state evaluates; whether it can proceed or should return. NEEDBITS() does the return if; the requested bits are not available. The typical use of the BITS macros; is:. NEEDBITS(n);; ... do something with BITS(n) ...; DROPBITS(n);. where NEEDBITS(n) either returns from inflate() if there isn't enough; input left to load n bits into the accumulator, or it continues. BITS(n); gives the low n bits in the accumulator. When done, DROPBITS(n) drops; the low n bits off the accumulator. INITBITS() clears the accumulator; and sets the number of available bits to zero. BYTEBITS() discards just; enough bits to put the accumulator on a byte boundary. After BYTEBITS(); and a NEEDBITS(8), then BITS(8) would return the next byte in the stream. NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return; if there is no input available. The decoding of variable length codes uses; PULLBYTE() directly in order to pull just enough bytes to decode the next; code, and no more. Some states loop until they get enough input, making sure that enough; state information is maintained to continue the loop where it left off; if NEEDBITS() returns in the loop. For example, want, need, and keep; would all have to actually be part of the saved state in case NEEDBITS(); returns:. case STATEw:; while (want < need) {; NEEDBITS(n);; keep[want++] = BITS(n);; DROPBITS(n);; }; state = STATEx;; case STATEx:. As shown above, if the next state is a",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c:873,load,load,873,builtins/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c,2,['load'],['load']
Performance,"/*; inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):; - Using bit fields for code structure; - Different op definition to avoid & for extra bits (do & for table bits); - Three separate decoding do-loops for direct, window, and wnext == 0; - Special case for distance > 1 copies to do overlapped load and store copy; - Explicit branch predictions (based on measured branch probabilities); - Deferring match copy and interspersed it with decoding subsequent codes; - Swapping literal/length else; - Swapping window/direct else; - Larger unrolled copy loops (three is about right); - Moving len -= 3 statement into middle of loop; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inffast.c:319,load,load,319,builtins/zlib/inffast.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inffast.c,1,['load'],['load']
Performance,"/*; inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):; - Using bit fields for code structure; - Different op definition to avoid & for extra bits (do & for table bits); - Three separate decoding do-loops for direct, window, and write == 0; - Special case for distance > 1 copies to do overlapped load and store copy; - Explicit branch predictions (based on measured branch probabilities); - Deferring match copy and interspersed it with decoding subsequent codes; - Swapping literal/length else; - Swapping window/direct else; - Larger unrolled copy loops (three is about right); - Moving len -= 3 statement into middle of loop; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inffast.c:319,load,load,319,graf2d/asimage/src/libAfterImage/zlib/inffast.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inffast.c,1,['load'],['load']
Performance,/*; struct _objc_class {; Class isa;; Class super_class;; const char *name;; long version;; long info;; long instance_size;; struct _objc_ivar_list *ivars;; struct _objc_method_list *methods;; struct _objc_cache *cache;; struct _objc_protocol_list *protocols;; // Objective-C 1.0 extensions (<rdr://4585769>); const char *ivar_layout;; struct _objc_class_ext *ext;; };. See EmitClassExtension();; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:213,cache,cache,213,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['cache'],['cache']
Performance,"/*; {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/TViewerX3D.cxx:16,Load,Load,16,graf3d/x3d/src/TViewerX3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/TViewerX3D.cxx,1,['Load'],['Load']
Performance,/*< optimize for a specific zstd compression level; 0 means default */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zdict.h:4,optimiz,optimize,4,builtins/zstd/zdict.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zdict.h,1,['optimiz'],['optimize']
Performance,"/*===-- ittnotify_config.h - JIT Profiling API internal config-----*- C -*-===*; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===----------------------------------------------------------------------===*; *; * This file provides Intel(R) Performance Analyzer JIT (Just-In-Time); * Profiling API internal config.; *; * NOTE: This file comes in a style different from the rest of LLVM; * source base since this is a piece of code shared from Intel(R); * products. Please do not reformat / re-style this code to make; * subsequent merges and contributions from the original source base eaiser.; *; *===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h:401,Perform,Performance,401,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h,1,['Perform'],['Performance']
Performance,"/*===-- jitprofiling.c - JIT (Just-In-Time) Profiling API----------*- C -*-===*; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===----------------------------------------------------------------------===*; *; * This file provides Intel(R) Performance Analyzer JIT (Just-In-Time) ; * Profiling API implementation. ; *; * NOTE: This file comes in a style different from the rest of LLVM; * source base since this is a piece of code shared from Intel(R); * products. Please do not reformat / re-style this code to make; * subsequent merges and contributions from the original source base eaiser.; *; *===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:401,Perform,Performance,401,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,1,['Perform'],['Performance']
Performance,"/*===-- jitprofiling.h - JIT Profiling API-------------------------*- C -*-===*; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===----------------------------------------------------------------------===*; *; * This file provides Intel(R) Performance Analyzer JIT (Just-In-Time); * Profiling API declaration.; *; * NOTE: This file comes in a style different from the rest of LLVM; * source base since this is a piece of code shared from Intel(R); * products. Please do not reformat / re-style this code to make; * subsequent merges and contributions from the original source base eaiser.; *; *===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.h:401,Perform,Performance,401,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.h,1,['Perform'],['Performance']
Performance,"/*===-- llvm-c/lto.h - LTO Public C Interface ---------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides public interface to an abstract link time optimization*|; |* library. LLVM provides an implementation of this interface for use with *|; |* llvm bitcode files. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:471,optimiz,optimization,471,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['optimiz'],['optimization']
Performance,"/*CACHE_FID*/; /* look for a match in cache */; /* matching formula:; identical text;; identical fontname (if defined, font ID's if not);; angles close enough (<0.00001 here, could be smaller);; HORIZONTAL alignment matches, OR it's a one line string;; magnifications the same */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx:38,cache,cache,38,graf2d/x11/src/Rotated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx,1,['cache'],['cache']
Performance,/*CACHE_SIZE_LIMIT */; /* Make sure a cache method is specified */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx:38,cache,cache,38,graf2d/x11/src/Rotated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx,1,['cache'],['cache']
Performance,"/*CACHE_XIMAGES*/; /* if item isn't cached, destroy it completely */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx:36,cache,cached,36,graf2d/x11/src/Rotated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx,1,['cache'],['cached']
Performance,/*CacheFail*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:2,Cache,CacheFail,2,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,5,['Cache'],['CacheFail']
Performance,/*CacheFailure*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:2,Cache,CacheFailure,2,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Cache'],['CacheFailure']
Performance,/*CacheFailure=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaSema.cpp:2,Cache,CacheFailure,2,interpreter/cling/lib/MetaProcessor/MetaSema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaSema.cpp,7,['Cache'],['CacheFailure']
Performance,/*CacheFailures*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:2,Cache,CacheFailures,2,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,2,['Cache'],['CacheFailures']
Performance,/*Load*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:2,Load,Load,2,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,7,['Load'],['Load']
Performance,/*LoadBlockVarAddr*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:2,Load,LoadBlockVarAddr,2,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,2,['Load'],['LoadBlockVarAddr']
Performance,/*LoadExternal=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:2,Load,LoadExternal,2,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['Load'],['LoadExternal']
Performance,/*LoadedID*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:2,Load,LoadedID,2,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,3,['Load'],['LoadedID']
Performance,/*LoadedID=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:2,Load,LoadedID,2,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,1,['Load'],['LoadedID']
Performance,/*LoadedOffset*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:2,Load,LoadedOffset,2,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,3,['Load'],['LoadedOffset']
Performance,/*LoadedOffset=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:2,Load,LoadedOffset,2,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,1,['Load'],['LoadedOffset']
Performance,/*LoadedType*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:2,Load,LoadedType,2,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Load'],['LoadedType']
Performance,/*Optimize=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/StringTableBuilder.cpp:2,Optimiz,Optimize,2,interpreter/llvm-project/llvm/lib/MC/StringTableBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/StringTableBuilder.cpp,2,['Optimiz'],['Optimize']
Performance,/*PerformADL=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Perform,PerformADL,2,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,['Perform'],['PerformADL']
Performance,/*PerformInit*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:2,Perform,PerformInit,2,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,2,['Perform'],['PerformInit']
Performance,/*Scalable*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:2,Scalab,Scalable,2,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,1,['Scalab'],['Scalable']
Performance,/*Scalable=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:2,Scalab,Scalable,2,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,7,['Scalab'],['Scalable']
Performance,/*TuneCPU*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:2,Tune,TuneCPU,2,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,51,['Tune'],['TuneCPU']
Performance,/*TuneCPU=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCSubtarget.cpp:2,Tune,TuneCPU,2,interpreter/llvm-project/llvm/lib/Target/ARC/ARCSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCSubtarget.cpp,10,['Tune'],['TuneCPU']
Performance,/*cacheList*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooObjCacheManager.h:2,cache,cacheList,2,roofit/roofitcore/inc/RooObjCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooObjCacheManager.h,1,['cache'],['cacheList']
Performance,/*forcing int to bool (performance warning) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/cmake/win/w32pragma.h:23,perform,performance,23,cmake/win/w32pragma.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/cmake/win/w32pragma.h,1,['perform'],['performance']
Performance,/*load*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/rootpcm/src/rootclingIO.cxx:2,load,load,2,io/rootpcm/src/rootclingIO.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/rootpcm/src/rootclingIO.cxx,1,['load'],['load']
Performance,/*load=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:2,load,load,2,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,2,['load'],['load']
Performance,/*loadFirstMatchOnly*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:2,load,loadFirstMatchOnly,2,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['load'],['loadFirstMatchOnly']
Performance,"/*using Scalar_t = typename Architecture_t::Scalar_t;; using Net_t = TNet<Architecture_t>;; using TensorDataLoader_t = TTensorDataLoader<MatrixInput_t, Architecture_t>;. TMatrixT<Double_t> X(2000, 100), W(2000, 1);; randomMatrix(X);; randomMatrix(W);; MatrixInput_t input(X, X, W);; DataLoader_t loader(input, 2000, 20, 100, 100);. Net_t net(20, 100, ELossFunction::kMeanSquaredError);; net.AddLayer(100, EActivationFunction::kIdentity);; net.AddLayer(100, EActivationFunction::kIdentity);; net.Initialize(EInitialization::kIdentity);. Scalar_t maximumError = 0.0;; for (auto b : loader) {; auto inputMatrix = b.GetInput();; auto outputMatrix = b.GetOutput();; auto weightMatrix = b.GetWeights();; Scalar_t error = net.Loss(inputMatrix, outputMatrix, weightMatrix);; maximumError = std::max(error, maximumError);; }. return maximumError;*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestTensorDataLoader.h:296,load,loader,296,tmva/tmva/test/DNN/TestTensorDataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestTensorDataLoader.h,2,['load'],['loader']
Performance,"// !! Not normalizing and not storing input data, for performance reasons. Should perhaps restore normalization.; // But this can be done afterwards by adding a normalisation transformation (user defined)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/VariablePCATransform.cxx:54,perform,performance,54,tmva/tmva/src/VariablePCATransform.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/VariablePCATransform.cxx,1,['perform'],['performance']
Performance,"// ""Benchmark""-like optimization: single-source case",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:20,optimiz,optimization,20,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['optimiz'],['optimization']
Performance,"// ""E"" Performs a better error evaluation, calling HESSE and MINOS",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/Foption.h:7,Perform,Performs,7,hist/hist/inc/Foption.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/Foption.h,1,['Perform'],['Performs']
Performance,"// ""ELF Handling for Thread-Local Storage"" specifies that R_X86_64_GOTTPOFF; // relocation target a movq or addq instruction: don't let the load shrink.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:140,load,load,140,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['load']
Performance,"// ""Large"" reads are served directly, bypassing the cache; since nbytes > 0, fBlockSize == 0 is also handled here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/RRawFile.cxx:52,cache,cache,52,io/io/src/RRawFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/RRawFile.cxx,1,['cache'],['cache']
Performance,"// ""Stop Loading"" picture button",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtmlBrowser.h:9,Load,Loading,9,gui/guihtml/inc/TGHtmlBrowser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtmlBrowser.h,2,['Load'],['Loading']
Performance,"// ""The /fp:fast option allows the compiler to reorder, combine, or simplify; // floating-point operations to optimize floating-point code for speed and; // space. The compiler may omit rounding at assignment statements,; // typecasts, or function calls. It may reorder operations or make algebraic; // transforms, for example, by use of associative and distributive laws. It; // may reorder code even if such transformations result in observably; // different rounding behavior.""; //; // ""Under /fp:precise and /fp:strict, the compiler doesn't do any mathematical; // transformation unless the transformation is guaranteed to produce a bitwise; // identical result.""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp:110,optimiz,optimize,110,interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp,1,['optimiz'],['optimize']
Performance,"// ""UpdateForm"" is not a real PPC instruction form, it stands for dform; // load/store with update like ldu/stdu, or Prefetch intrinsic.; // For DS form instructions, their displacements must be multiple of 4.; // For DQ form instructions, their displacements must be multiple of 16.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:76,load,load,76,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['load'],['load']
Performance,"// ""avx512.mask.loadu"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:16,load,loadu,16,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,1,['load'],['loadu']
Performance,"// ""avx512.mask.loadu."" or ""avx512.mask.load.""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:16,load,loadu,16,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,2,['load'],"['load', 'loadu']"
Performance,"// ""cast"" fixed length vector to a scalable vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:35,scalab,scalable,35,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,3,['scalab'],['scalable']
Performance,"// ""target"" intrinsic forms of loads aren't currently known to; // MemoryLocation::get. TODO",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:31,load,loads,31,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['load'],['loads']
Performance,"// ""x86-64"" is a default target setting for many front ends. In these cases,; // they actually request for ""generic"" tuning unless the ""tune-cpu"" was; // specified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp:136,tune,tune-cpu,136,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp,1,['tune'],['tune-cpu']
Performance,"// ### FIXME:; // Want to update LLVM to 3.9 realease and better testing first, but; // ApplyHeaderSearchOptions shouldn't even be called here:; // 1. It's already been called via CI->createPreprocessor(TU_Complete); // 2. It could corrupt clang's directory cache; // HeaderSearchOptions.::AddSearchPath is a better alternative",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp:258,cache,cache,258,interpreter/cling/lib/Interpreter/CIFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp,1,['cache'],['cache']
Performance,"// #### Now in TrainNodeInfo, but I got a malloc segfault when I tried to destruct arrays there.; // #### So, I changed these from dynamic arrays to std::vector to fix this memory problem; // #### so no need to destruct them anymore. I didn't see any performance drop as a result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx:251,perform,performance,251,tmva/tmva/src/DecisionTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx,1,['perform'],['performance']
Performance,"// #### need a lambda function to pass to TThreadExecutor::MapReduce (multi-threading)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx:70,multi-thread,multi-threading,70,tmva/tmva/src/DecisionTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx,1,['multi-thread'],['multi-threading']
Performance,"// #16249: range based loop and the tree has zero entries; // as well as analogous cases.; // Getting the number of events can have a cost, for example in; // case of chains of remote files accessible with high latency.; // However, it is reasonable to assume that if iterators are; // being compared is because an iteration is taking place,; // therefore such cost has to be paid anyway, it's just; // anticipated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h:211,latency,latency,211,tree/treeplayer/inc/TTreeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h,1,['latency'],['latency']
Performance,"// #__include_macros has no effect on a user of a preprocessed source; // file; the only effect is on preprocessing.; //; // FIXME: That's not *quite* true: it causes the module in question to; // be loaded, which can affect downstream diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:200,load,loaded,200,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,1,['load'],['loaded']
Performance,"// #define R__CHECK_COLLECTION_MULTI_ACCESS; // When R__CHECK_COLLECTION_MULTI_ACCESS is turned on (defined),; // the normal (not locked) ROOT TCollections are instrumented with a; // pseudo read-write lock which does not halt the execution but detects; // and report concurrent access to the same collections.; // Multiple readers are allowed.; // Multiple concurrent writer is reported as a Conflict; // Readers access while a write is running is reported as Conflict; // Re-entrant writing call by the same Writer thread are allowed.; // Entering a writing section by a single Reader thread is allowed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h:268,concurren,concurrent,268,core/cont/inc/TCollection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h,2,['concurren'],['concurrent']
Performance,"// #else; // const std::vector<double> & MnUserTransformation::operator()(const MnAlgebraicVector& pstates) const {; // // transform an internal Minuit vector of internal values in a std::vector of external values; // // std::vector<double> Cache(pstates.size() );; // for(unsigned int i = 0; i < pstates.size(); i++) {; // if(fParameters[fExtOfInt[i]].HasLimits()) {; // fCache[fExtOfInt[i]] = Int2ext(i, pstates(i));; // } else {; // fCache[fExtOfInt[i]] = pstates(i);; // }; // }; // return fCache;; // }; // #endif",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserTransformation.cxx:241,Cache,Cache,241,math/minuit2/src/MnUserTransformation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserTransformation.cxx,1,['Cache'],['Cache']
Performance,// #pragma clang optimize off; // #pragma clang optimize on,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:17,optimiz,optimize,17,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,2,['optimiz'],['optimize']
Performance,"// #pragma cling(load, ""A"")",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ClingPragmas.cpp:17,load,load,17,interpreter/cling/lib/Interpreter/ClingPragmas.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ClingPragmas.cpp,1,['load'],['load']
Performance,"// #pragma optimize(""gsty"", on|off)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:11,optimiz,optimize,11,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,1,['optimiz'],['optimize']
Performance,"// %13 = bitcast x86_amx %src to <256 x i32>; // store <256 x i32> %13, <256 x i32>* %addr, align 64; // %add = <256 x i32> %13, <256 x i32> %src2; // -->; // %13 = bitcast x86_amx %src to <256 x i32>; // call void @llvm.x86.tilestored64.internal(%row, %col, %addr,; // %stride64, %13); // %14 = load <256 x i32>, %addr; // %add = <256 x i32> %14, <256 x i32> %src2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp:296,load,load,296,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,1,['load'],['load']
Performance,"// %2 = amxcast x86_amx %src to <225 x i32>; // -->; // %addr = alloca <225 x i32>, align 64; // %addr2 = bitcast <225 x i32>* to i8*; // call void @llvm.x86.tilestored64.internal(i16 %row, i16 %col,; // i8* %addr2, i64 %stride); // %2 = load <225 x i32>, <225 x i32>* %addr, align 64",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp:238,load,load,238,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,1,['load'],['load']
Performance,"// %2 = bitcast x86_amx %src to <256 x i32>; // -->; // %addr = alloca <256 x i32>, align 64; // %addr2 = bitcast <256 x i32>* to i8*; // call void @llvm.x86.tilestored64.internal(i16 %row, i16 %col,; // i8* %addr2, i64 %stride); // %2 = load <256 x i32>, <256 x i32>* %addr, align 64",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp:238,load,load,238,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,1,['load'],['load']
Performance,"// %65 = load <256 x i32>, <256 x i32>* %p, align 64; // %66 = call x86_amx @llvm.x86.cast.vector.to.tile(<256 x i32> %65); // -->; // %66 = call x86_amx @llvm.x86.tileloadd64.internal(i16 %row, i16 %col,; // i8* %p, i64 64)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp:9,load,load,9,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,2,['load'],['load']
Performance,"// %base cannot be redefined after the load as it will appear before; // TBB/TBH like:; // %base =; // %base =; // tBB %base, %idx",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:39,load,load,39,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,1,['load'],['load']
Performance,"// %src = load <256 x i32>, <256 x i32>* %addr, align 64; // %2 = bitcast <256 x i32> %src to x86_amx; // -->; // %2 = call x86_amx @llvm.x86.tileloadd64.internal(i16 %row, i16 %col,; // i8* %addr, i64 %stride64)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp:10,load,load,10,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,1,['load'],['load']
Performance,"// && oldcl->GetClassInfo()) {; // As a work-around to ROOT-6012, we need to register the class even if; // it is not a template instance, because a forward declaration in the header; // files loaded by the current dictionary wil also de-activate the update; // class info mechanism!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx:193,load,loaded,193,core/cont/src/TClassTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx,1,['load'],['loaded']
Performance,"// && oldcl->GetClassInfo()) {; // As a work-around to ROOT-6012, we need to register the class even if; // it is not a template instance, because a forward declaration in the header; // files loaded by the current dictionary wil also de-activate the update; // class info mechanism!; // The TClass exist and already has a class info, so it must; // correspond to a class template instantiation which the interpreter; // was able to make with the library containing the TClass Init.; // Because it is already known to the interpreter, the update class info; // will not be triggered, we need to force it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx:193,load,loaded,193,core/cont/src/TClassTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx,1,['load'],['loaded']
Performance,"// 'aarch64_neon_pmull64' takes i64 parameters; while pmull/pmull2; // instructions execute on SIMD registers. So canonicalize i64 to v1i64,; // which ISel recognizes better. For example, generate a ldr into d*; // registers as opposed to a GPR load followed by a fmov.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:245,load,load,245,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['load'],['load']
Performance,// 'dbg' Metadata cache.; /// Relative order of this instruction in its parent basic block. Used for; /// O(1) local dominance checks between instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:18,cache,cache,18,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['cache'],['cache']
Performance,"// 'errno' has to be checked. A load is required for this, with no more; // information we can assume that it is checked somehow.; // After this place 'errno' is allowed to be read and written.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp:32,load,load,32,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp,1,['load'],['load']
Performance,"// 'self' message receivers in class methods should be treated as message; // sends to the class object in order for the semantic checks to be; // performed correctly. Messages to 'super' already count as class messages,; // so they don't need to be handled here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:147,perform,performed,147,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['perform'],['performed']
Performance,// ((X << A) | Y) >> A -> X if effective width of Y is not larger than A.; // We can return X as we do in the above case since OR alters no bits in X.; // SimplifyDemandedBits in InstCombine can do more general optimization for; // bit manipulation. This pattern aims to provide opportunities for other; // optimizers by supporting a simple but common case in InstSimplify.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:211,optimiz,optimization,211,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['optimiz'],"['optimization', 'optimizers']"
Performance,// (2) Add to the worklist all bitcast and getelementptr instructions used by; // memory accesses requiring a scalar use. The pointer operands of loads and; // stores will be scalar as long as the memory accesses is not a gather or; // scatter operation. The value operand of a store will remain scalar if the; // store is scalarized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:146,load,loads,146,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['load'],['loads']
Performance,// (2) Install transform to optimize modules when they're materialized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp:28,optimiz,optimize,28,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp,1,['optimiz'],['optimize']
Performance,// (X & 8) != 0 --> (X & 8) >> 3; // Perform the xform if the AND RHS is a single bit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:37,Perform,Perform,37,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Perform'],['Perform']
Performance,// (X & 8) == 8 --> (X & 8) >> 3; // Perform the xform if C1 is a single bit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:37,Perform,Perform,37,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Perform'],['Perform']
Performance,"// (X*Y) * X => (X*X) * Y where Y != X; // The purpose is two-fold:; // 1) to form a power expression (of X).; // 2) potentially shorten the critical path: After transformation, the; // latency of the instruction Y is amortized by the expression of X*X,; // and therefore Y is in a ""less critical"" position compared to what it; // was before the transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:186,latency,latency,186,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['latency'],['latency']
Performance,"// (a): Very fast checks against top box and global caching; // (b): Use voxel cached best safety; // (c): Use voxel candidates (fetch them if they are not yet initialized)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:79,cache,cached,79,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['cache'],['cached']
Performance,"// (conservatively) we can't peak past the ordering implied by this; // operation, but we can add this load to our set of available values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:103,load,load,103,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['load'],['load']
Performance,"// (fFile != 0 && fTree == 0) can happen when; // InvalidateCurrentTree is called (for example from; // AddFriend). Having fTree === 0 is necessary in that; // case because in some cases GetTree is used as a check; // to see if a TTree is already loaded.; // However, this prevent using the following to reuse; // the TTreeCache object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:247,load,loaded,247,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['load'],['loaded']
Performance,"// (fadd double (sitofp x), fpcst) --> (sitofp (add int x, intcst)); // ... if the constant fits in the integer value. This is useful for things; // like (double)(x & 1234) + 4.0 -> (double)((X & 1234)+4) which no longer; // requires a constant pool load, and generally allows the add to be better; // instcombined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:250,load,load,250,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['load'],['load']
Performance,"// (icmp eq (lshr x, C), (lshr y, C)) gets optimized to:; // (icmp ult (xor x, y), 1 << C) so also look for that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:43,optimiz,optimized,43,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['optimiz'],['optimized']
Performance,"// (icmp ne (lshr x, C), (lshr y, C)) gets optimized to:; // (icmp ugt (xor x, y), (1 << C) - 1) so also look for that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:43,optimiz,optimized,43,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['optimiz'],['optimized']
Performance,// (load 128i16 and) deinterleave into 4 x 32i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 128i32 and) deinterleave into 4 x 32i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 128i8 and) deinterleave into 4 x 32i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 12i16 and) deinterleave into 3 x 4i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 12i16 and) deinterleave into 6 x 2i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 12i32 and) deinterleave into 3 x 4i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 12i32 and) deinterleave into 6 x 2i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 12i64 and) deinterleave into 3 x 4i64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 12i64 and) deinterleave into 6 x 2i64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 12i8 and) deinterleave into 3 x 4i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 12i8 and) deinterleave into 6 x 2i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 16i16 and) deinterleave into 2 x 8i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 16i16 and) deinterleave into 4 x 4i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 16i32 and) deinterleave into 2 x 8i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 16i32 and) deinterleave into 4 x 4i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 16i64 and) deinterleave into 2 x 8i64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 16i64 and) deinterleave into 4 x 4i64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 16i8 and) deinterleave into 2 x 8i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 16i8 and) deinterleave into 4 x 4i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 192i16 and) deinterleave into 6 x 32i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 192i8 and) deinterleave into 6 x 32i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 24i16 and) deinterleave into 3 x 8i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 24i16 and) deinterleave into 6 x 4i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 24i32 and) deinterleave into 3 x 8i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 24i32 and) deinterleave into 6 x 4i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 24i64 and) deinterleave into 3 x 8i64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 24i64 and) deinterleave into 6 x 4i64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 24i8 and) deinterleave into 3 x 8i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 24i8 and) deinterleave into 6 x 4i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 32i16 and) deinterleave into 2 x 16i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 32i16 and) deinterleave into 4 x 8i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 32i32 and) deinterleave into 2 x 16i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 32i32 and) deinterleave into 4 x 8i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 32i64 and) deinterleave into 2 x 16i64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 32i64 and) deinterleave into 4 x 8i64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 32i8 and) deinterleave into 2 x 16i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 32i8 and) deinterleave into 4 x 8i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 48i16 and) deinterleave into 3 x 16i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 48i16 and) deinterleave into 6 x 8i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 48i32 and) deinterleave into 3 x 16i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 48i32 and) deinterleave into 6 x 8i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 48i64 and) deinterleave into 3 x 16i64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 48i64 and) deinterleave into 6 x 8i64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 48i8 and) deinterleave into 3 x 16i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 48i8 and) deinterleave into 6 x 8i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 4i16 and) deinterleave into 2 x 2i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 4i32 and) deinterleave into 2 x 2i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 4i64 and) deinterleave into 2 x 2i64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 4i8 and) deinterleave into 2 x 2i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 64i16 and) deinterleave into 2 x 32i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 64i16 and) deinterleave into 4 x 16i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 64i32 and) deinterleave into 2 x 32i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 64i32 and) deinterleave into 4 x 16i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 64i32 and) deinterleave into 8 x 8i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 64i64 and) deinterleave into 2 x 32i64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 64i64 and) deinterleave into 4 x 16i64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 64i8 and) deinterleave into 2 x 32i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 64i8 and) deinterleave into 4 x 16i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 6i16 and) deinterleave into 3 x 2i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 6i32 and) deinterleave into 3 x 2i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 6i64 and) deinterleave into 3 x 2i64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 6i8 and) deinterleave into 3 x 2i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 8i16 and) deinterleave into 2 x 4i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,2,['load'],['load']
Performance,// (load 8i16 and) deinterleave into 4 x 2i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 8i32 and) deinterleave into 2 x 4i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 8i32 and) deinterleave into 4 x 2i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 8i64 and) deinterleave into 2 x 4i64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 8i64 and) deinterleave into 4 x 2i64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 8i8 and) deinterleave into 2 x 4i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 8i8 and) deinterleave into 4 x 2i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 96i16 and) deinterleave into 3 x 32i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 96i16 and) deinterleave into 6 x 16i16,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 96i32 and) deinterleave into 3 x 32i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 96i32 and) deinterleave into 6 x 16i32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 96i8 and) deinterleave into 3 x 32i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (load 96i8 and) deinterleave into 6 x 16i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:4,load,load,4,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// (loadGOT sym),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:4,load,loadGOT,4,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['load'],['loadGOT']
Performance,"// (re-)create the cache tag file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:19,cache,cache,19,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['cache'],['cache']
Performance,"// (select c, t, f) -> (or (czero_eqz t, c), (czero_nez f, c)); // Unless we have the short forward branch optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:107,optimiz,optimization,107,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['optimiz'],['optimization']
Performance,"// (srl (trunc (srl ...))) may be optimized by combining srl, so; // doesn't optimize trunc now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:34,optimiz,optimized,34,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,2,['optimiz'],"['optimize', 'optimized']"
Performance,"// (store (insert_vector_elt (load p), x, i), p) -> (store x, p+offset); //; // If a store of a load with an element inserted into it has no other; // uses in between the chain, then we can consider the vector store; // dead and replace it with just the single scalar element store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,load,load,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['load'],['load']
Performance,"// (vextract (v4f32 load $addr), c) -> (f32 load $addr+c*size); // (vextract (v4f32 s2v (f32 load $addr)), c) -> (f32 load $addr+c*size); // (vextract (v4f32 shuffle (load $addr), <1,u,u,u>), 0) -> (f32 load $addr)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,load,load,20,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,6,['load'],['load']
Performance,"// (vextract (vector_shuffle (load $addr), v2, <1, u, u, u>), 1); // =>; // (load $addr+1*size); // Don't duplicate a load with other uses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,load,load,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,3,['load'],['load']
Performance,// * Use LDE instead of LE/LEY for z13 to avoid partial register; // dependencies (LDE only supports small offsets).; // * Utilize the vector registers to hold floating point; // values (vector load / store instructions only support small; // offsets).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:194,load,load,194,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['load'],['load']
Performance,"// * if Size == 1, it is sufficient to load its origin aligned at 4.; // * if Size == 2, we assume most cases Addr % 2 == 0, so it is sufficient to; // load its origin aligned at 4. If not, although origins may be lost, it; // should not happen very often.; // * if align >= 4, Addr must be aligned to 4, otherwise it is UB. When; // Size % 4 == 0, it is more efficient to load origins without callbacks.; // * Otherwise we use __dfsan_load_label_and_origin.; // This should ensure that common cases run efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:39,load,load,39,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,3,['load'],['load']
Performance,"// *** WVE this is important *** this declares that frac effectively depends on the morphing parameters; // This will prevent the likelihood optimizers from erroneously declaring terms constant",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooMomentMorph.cxx:141,optimiz,optimizers,141,roofit/roofit/src/RooMomentMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooMomentMorph.cxx,6,['optimiz'],['optimizers']
Performance,"// *********************************** NOTE ************************************; // For selecting load and store instructions, the addressing modes are defined; // as ComplexPatterns in PPCInstrInfo.td, which are then utilized in the TD; // patterns to match the load the store instructions.; //; // The TD definitions for the addressing modes correspond to their respective; // Select<AddrMode>Form() function in PPCISelDAGToDAG.cpp. These functions rely; // on SelectOptimalAddrMode(), which calls computeMOFlags() to compute the; // address mode flags of a particular node. Afterwards, the computed address; // flags are passed into getAddrModeForFlags() in order to retrieve the optimal; // addressing mode. SelectOptimalAddrMode() then sets the Base and Displacement; // accordingly, based on the preferred addressing mode.; //; // Within PPCISelLowering.h, there are two enums: MemOpFlags and AddrMode.; // MemOpFlags contains all the possible flags that can be used to compute the; // optimal addressing mode for load and store instructions.; // AddrMode contains all the possible load and store addressing modes available; // on Power (such as DForm, DSForm, DQForm, XForm, etc.); //; // When adding new load and store instructions, it is possible that new address; // flags may need to be added into MemOpFlags, and a new addressing mode will; // need to be added to AddrMode. An entry of the new addressing mode (consisting; // of the minimal and main distinguishing address flags for the new load/store; // instructions) will need to be added into initializeAddrModeMap() below.; // Finally, when adding new addressing modes, the getAddrModeForFlags() will; // need to be updated to account for selecting the optimal addressing mode.; // *****************************************************************************; /// Initialize the map that relates the different addressing modes of the load; /// and store instructions to a set of flags. This ensures the load/store; /// instruction i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:99,load,load,99,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,3,['load'],['load']
Performance,"// ***************************************************************************; // Look for obvious safe cases to perform tail call optimization that do not; // require ABI changes.; // ***************************************************************************; // If this is a tail call via a function pointer, then don't do it!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:114,perform,perform,114,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"// *********************************************************************; // *** PART 4 *** Adjust normalization range for projected observables *; // *********************************************************************; // TODO; // *********************************************************************; // *** PART 4 *** Finalization and activation of optimization *; // *********************************************************************; // optimization steps (copied from ROATS::optimizeCaching)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/RooAbsL.cxx:354,optimiz,optimization,354,roofit/roofitcore/src/TestStatistics/RooAbsL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/RooAbsL.cxx,3,['optimiz'],"['optimization', 'optimizeCaching']"
Performance,"// *********************************************************************; // *** PART 4 *** Finalization and activation of optimization *; // *********************************************************************; // Redirect pointers of base class to clone",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx:123,optimiz,optimization,123,roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,1,['optimiz'],['optimization']
Performance,"// ********************************************************************; //; // source:; //; // type: source code; //; // created: 02. Apr 2001; //; // author: Thorsten Glebe; // HERA-B Collaboration; // Max-Planck-Institut fuer Kernphysik; // Saupfercheckweg 1; // 69117 Heidelberg; // Germany; // E-mail: T.Glebe@mpi-hd.mpg.de; //; // Description: Determinant of a square matrix, needed for Dfinv(); // Code was taken from CERNLIB::kernlib dfact function, translated; // from FORTRAN to C++ and optimized.; //; // changes:; // 02 Apr 2001 (TG) creation; //; // ********************************************************************",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Dfactir.h:497,optimiz,optimized,497,math/smatrix/inc/Math/Dfactir.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Dfactir.h,1,['optimiz'],['optimized']
Performance,"// ********************************************************************; //; // source:; //; // type: source code; //; // created: 02. Apr 2001; //; // author: Thorsten Glebe; // HERA-B Collaboration; // Max-Planck-Institut fuer Kernphysik; // Saupfercheckweg 1; // 69117 Heidelberg; // Germany; // E-mail: T.Glebe@mpi-hd.mpg.de; //; // Description: Determinant of a square matrix; // Code was taken from CERNLIB::kernlib dfact function, translated; // from FORTRAN to C++ and optimized.; //; // changes:; // 02 Apr 2001 (TG) creation; //; // ********************************************************************",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Dfact.h:477,optimiz,optimized,477,math/smatrix/inc/Math/Dfact.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Dfact.h,1,['optimiz'],['optimized']
Performance,"// ********************************************************************; //; // source:; //; // type: source code; //; // created: 03. Apr 2001; //; // author: Thorsten Glebe; // HERA-B Collaboration; // Max-Planck-Institut fuer Kernphysik; // Saupfercheckweg 1; // 69117 Heidelberg; // Germany; // E-mail: T.Glebe@mpi-hd.mpg.de; //; // Description: Matrix inversion; // Code was taken from CERNLIB::kernlib dfinv function, translated; // from FORTRAN to C++ and optimized.; //; // changes:; // 03 Apr 2001 (TG) creation; //; // ********************************************************************",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Dfinv.h:463,optimiz,optimized,463,math/smatrix/inc/Math/Dfinv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Dfinv.h,1,['optimiz'],['optimized']
Performance,"// ********************************************************************; //; // source:; //; // type: source code; //; // created: 03. Apr 2001; //; // author: Thorsten Glebe; // HERA-B Collaboration; // Max-Planck-Institut fuer Kernphysik; // Saupfercheckweg 1; // 69117 Heidelberg; // Germany; // E-mail: T.Glebe@mpi-hd.mpg.de; //; // Description: square Matrix inversion; // Code was taken from CERNLIB::kernlib dfinv function, translated; // from FORTRAN to C++ and optimized.; // n: Order of the square matrix; // idim: First dimension of array A; //; // changes:; // 03 Apr 2001 (TG) creation; //; // ********************************************************************",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Dinv.h:470,optimiz,optimized,470,math/smatrix/inc/Math/Dinv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Dinv.h,1,['optimiz'],['optimized']
Performance,"// ********************************************************************; //; // source:; //; // type: source code; //; // created: 22. Mar 2001; //; // author: Thorsten Glebe; // HERA-B Collaboration; // Max-Planck-Institut fuer Kernphysik; // Saupfercheckweg 1; // 69117 Heidelberg; // Germany; // E-mail: T.Glebe@mpi-hd.mpg.de; //; // Description: Determinant of a symmetric, positive definite matrix.; // Code was taken from CERNLIB::kernlib dsfact function, translated; // from FORTRAN to C++ and optimized.; //; // changes:; // 22 Mar 2001 (TG) creation; // 18 Apr 2001 (TG) removed internal copying of array.; //; // ********************************************************************",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Dsfact.h:501,optimiz,optimized,501,math/smatrix/inc/Math/Dsfact.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Dsfact.h,1,['optimiz'],['optimized']
Performance,"// ********************************************************************; //; // source:; //; // type: source code; //; // created: 22. Mar 2001; //; // author: Thorsten Glebe; // HERA-B Collaboration; // Max-Planck-Institut fuer Kernphysik; // Saupfercheckweg 1; // 69117 Heidelberg; // Germany; // E-mail: T.Glebe@mpi-hd.mpg.de; //; // Description: Inversion of a symmetric, positive definite matrix.; // Code was taken from CERNLIB::kernlib dsinv function, translated; // from FORTRAN to C++ and optimized.; //; // changes:; // 22 Mar 2001 (TG) creation; //; // ********************************************************************",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Dsinv.h:498,optimiz,optimized,498,math/smatrix/inc/Math/Dsinv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Dsinv.h,1,['optimiz'],['optimized']
Performance,"// ******************************************************************; // *** PART 3 *** Make adjustments for fit ranges, if specified *; // ******************************************************************; // TODO; // Jonas R.: The following code is commented out, because the functionality; // to mask out-of-range entries with `RooDataHist::cacheValidEntries` has; // been removed from the RooDataHist. If you want to implement ranged fits; // properly, please create a RooDataHist for the requested range with; // `RooDataHist::reduce`.; //// If dataset is binned, activate caching of bins that are invalid because they're outside the; //// updated range definition (WVE need to add virtual interface here); // RooDataHist *tmph = dynamic_cast<RooDataHist *>(data_.get());; // if (tmph) {; // tmph->cacheValidEntries();; //}; // This is deferred from part 2 - but must happen after part 3 - otherwise invalid bins cannot be properly marked in; // cacheValidEntries",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/RooAbsL.cxx:346,cache,cacheValidEntries,346,roofit/roofitcore/src/TestStatistics/RooAbsL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/RooAbsL.cxx,3,['cache'],['cacheValidEntries']
Performance,"// *If* there is a truncation between an outer shift and a possibly-mask,; // then said truncation *must* be one-use, else we can't perform the fold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:132,perform,perform,132,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['perform'],['perform']
Performance,"// *MENU*; /**; * @brief Sets the address of the object to be notified when the tree is loaded.; *; * The method TObject::Notify is called for the given object when the tree; * is loaded. Specifically this occurs in the TTree::LoadTree method. To; * remove the notification call this method with nullptr:; * @code tree->SetNotify(nullptr); @endcode; *; * If this is a TChain, `obj` is most often going to be a TNotifyLink.; *; * @param[in] obj Pointer to a TObject to be notified.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:88,load,loaded,88,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,3,"['Load', 'load']","['LoadTree', 'loaded']"
Performance,"// *Not* to do: we should not attempt to salvage load instructions,; // because the validity and lifetime of a dbg.value containing; // DW_OP_deref becomes difficult to analyze. See PR40628 for examples.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:49,load,load,49,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['load'],['load']
Performance,"// + load method cannot have availability attributes. It get called on; // startup, so it has to have the availability of the deployment target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:5,load,load,5,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['load'],['load']
Performance,"// +----------+-----+-----+-------+---------+------------+---------+----------+; // | 1 | 0 | 0 | 2 | 6 / 2 | 1 | 3 / 4 | yes? |; // +----------+-----+-----+-------+---------+------------+---------+----------+; // | 2 | 0 | 0 | 4 | 12 / 8 | 2 | 6 / 8 | yes |; // +----------+-----+-----+-------+---------+------------+---------+----------+; // | 2 | 0 | 0 | 2 | 6 / 4 | 2 | 6 / 8 | no |; // +----------+-----+-----+-------+---------+------------+---------+----------+; // | 1 | 0 | 1 | 2 | 6 / 2 | 1 | 3 / 2 | yes |; // +----------+-----+-----+-------+---------+------------+---------+----------+; //; // Some cases are of questionable benefit, like the one marked with ""yes?""; // above: fewer intrinsics and fewer vaddr and fewer total transfers between SP; // and TX, but higher vdata. We start by erring on the side of converting these; // to MSAA_LOAD.; //; // clang-format off; //; // This pass will combine intrinsics such as (not neccessarily consecutive):; // call float @llvm.amdgcn.image.load.2dmsaa.f32.i32(i32 1, i32 %s, i32 %t, i32 0, <8 x i32> %rsrc, i32 0, i32 0); // call float @llvm.amdgcn.image.load.2dmsaa.f32.i32(i32 1, i32 %s, i32 %t, i32 1, <8 x i32> %rsrc, i32 0, i32 0); // call float @llvm.amdgcn.image.load.2dmsaa.f32.i32(i32 1, i32 %s, i32 %t, i32 2, <8 x i32> %rsrc, i32 0, i32 0); // call float @llvm.amdgcn.image.load.2dmsaa.f32.i32(i32 1, i32 %s, i32 %t, i32 3, <8 x i32> %rsrc, i32 0, i32 0); // ==>; // call <4 x float> @llvm.amdgcn.image.msaa.load.2dmsaa.v4f32.i32(i32 1, i32 %s, i32 %t, i32 0, <8 x i32> %rsrc, i32 0, i32 0); //; // clang-format on; //; // Future improvements:; //; // - We may occasionally not want to do the combine if it increases the maximum; // register pressure.; //; // - Ensure clausing when multiple MSAA_LOAD are generated.; //; // Note: Even though the image_msaa_load intrinsic already exists on gfx10, this; // combine only applies to gfx11, due to a limitation in gfx10: the gfx10; // IMAGE_MSAA_LOAD only works correctly with single-c",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUImageIntrinsicOptimizer.cpp:2201,load,load,2201,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUImageIntrinsicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUImageIntrinsicOptimizer.cpp,1,['load'],['load']
Performance,"// - If the new-initializer is omitted, the object is default-; // initialized (8.5); if no initialization is performed,; // the object has indeterminate value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:110,perform,performed,110,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['perform'],['performed']
Performance,// - If we're building a (preprocessed) module and we've just loaded the; // module map file from which it was created.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:62,load,loaded,62,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['load'],['loaded']
Performance,"// - Otherwise, a temporary of type ""cv1 T1"" is created and initialized; // from the initializer expression using the rules for a non-reference; // copy-initialization (8.5). The reference is then bound to the; // temporary. [...]; // Ignore address space of reference type at this point and perform address; // space conversion after the reference binding step.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:292,perform,perform,292,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['perform']
Performance,"// - Otherwise, if the initializer list has a single element of type E; // [...references are handled above...], the object or reference is; // initialized from that element (by copy-initialization for; // copy-list-initialization, or by direct-initialization for; // direct-list-initialization); if a narrowing conversion is required; // to convert the element to T, the program is ill-formed.; //; // Per core-24034, this is direct-initialization if we were performing; // direct-list-initialization and copy-initialization otherwise.; // We can't use InitListChecker for this, because it always performs; // copy-initialization. This only matters if we might use an 'explicit'; // conversion operator, or for the special case conversion of nullptr_t to; // bool, so we only need to handle those cases.; //; // FIXME: Why not do this in all cases?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:460,perform,performing,460,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,2,['perform'],"['performing', 'performs']"
Performance,"// - otherwise, no initialization is performed.; // If a program calls for the default initialization of an object of; // a const-qualified type T, T shall be a class type with a user-provided; // default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:37,perform,performed,37,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['performed']
Performance,"// - set up number of threads for CPU if NumThreads option was specified; // `torch.set_num_threads` sets the number of threads that can be used to; // perform cpu operations like conv or mm (usually used by OpenMP or MKL).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx:152,perform,perform,152,tmva/pymva/src/MethodPyTorch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx,1,['perform'],['perform']
Performance,"// -- LoadTree() has not yet been called, no current tree.; // FIXME: We need an error message here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:6,Load,LoadTree,6,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['Load'],['LoadTree']
Performance,"// -- QUEUE - MASTER COMMUNICATION --",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/res/RooFit/MultiProcess/Messenger.h:6,QUEUE,QUEUE,6,roofit/multiprocess/res/RooFit/MultiProcess/Messenger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/res/RooFit/MultiProcess/Messenger.h,3,['QUEUE'],['QUEUE']
Performance,"// -- The branch already has an id cached, just use it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TRefTable.cxx:35,cache,cached,35,core/cont/src/TRefTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TRefTable.cxx,1,['cache'],['cached']
Performance,"// -- The branch does *not* have an id cached, find it or generate one.; // Lookup the branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TRefTable.cxx:39,cache,cached,39,core/cont/src/TRefTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TRefTable.cxx,1,['cache'],['cached']
Performance,"// -- The second and third operands have arithmetic or enumeration type;; // the usual arithmetic conversions are performed to bring them to a; // common type, and the result is of that type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:114,perform,performed,114,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['perform'],['performed']
Performance,"// -- The second and third operands have pointer type, or one has pointer; // type and the other is a null pointer constant, or both are null; // pointer constants, at least one of which is non-integral; pointer; // conversions and qualification conversions are performed to bring them; // to their composite pointer type. The result is of the composite; // pointer type.; // -- The second and third operands have pointer to member type, or one has; // pointer to member type and the other is a null pointer constant;; // pointer to member conversions and qualification conversions are; // performed to bring them to a common type, whose cv-qualification; // shall match the cv-qualification of either the second or the third; // operand. The result is of the common type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:262,perform,performed,262,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,2,['perform'],['performed']
Performance,"// -- WORKER - QUEUE COMMUNICATION --",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/res/RooFit/MultiProcess/Messenger.h:15,QUEUE,QUEUE,15,roofit/multiprocess/res/RooFit/MultiProcess/Messenger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/res/RooFit/MultiProcess/Messenger.h,3,['QUEUE'],['QUEUE']
Performance,"// -- if T is a reference type, no initialization is performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:53,perform,performed,53,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['perform'],['performed']
Performance,"// --- Load the data base ---",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSReactionDlg.cxx:7,Load,Load,7,test/periodic/XSReactionDlg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSReactionDlg.cxx,1,['Load'],['Load']
Performance,"// --- Perform a bubble sort ---",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSElementList.cxx:7,Perform,Perform,7,test/periodic/XSElementList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSElementList.cxx,1,['Perform'],['Perform']
Performance,// --- Utilities ---; // Array Caches (provide typed arrays for temporary by size),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:31,Cache,Caches,31,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Cache'],['Caches']
Performance,"// ---- perform series of fits to achieve best convergence; // ""m_ga_spread"" times the number of variables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/GeneticFitter.cxx:8,perform,perform,8,tmva/tmva/src/GeneticFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/GeneticFitter.cxx,1,['perform'],['perform']
Performance,"// ------ Operations combining two vectors ------; // -- need to have the specialized version in order to avoid; /**; Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/DisplacementVector2D.h:198,perform,perform,198,math/genvector/inc/Math/GenVector/DisplacementVector2D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/DisplacementVector2D.h,2,['perform'],['perform']
Performance,"// -----------------------------------------------------------------------------; // System of classes that represent all the intermediate values used during; // code-generation for an intrinsic.; //; // The base class 'Result' can represent a value of the LLVM type 'Value', or; // sometimes 'Address' (for loads/stores, including an alignment requirement).; //; // In the case where the Tablegen provides a value in the codegen dag as a; // plain integer literal, the Result object we construct here will be one that; // returns true from hasIntegerConstantValue(). This allows the generated C++; // code to use the constant directly in contexts which can take a literal; // integer, such as Builder.CreateExtractValue(thing, 1), without going to the; // effort of calling llvm::ConstantInt::get() and then pulling the constant; // back out of the resulting llvm:Value later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:308,load,loads,308,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,1,['load'],['loads']
Performance,"// --------------------------------------; // Load histograms; // --------------------------------------; // file with histograms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactoryPlotting.cxx:46,Load,Load,46,roofit/histfactory/test/testHistFactoryPlotting.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactoryPlotting.cxx,1,['Load'],['Load']
Performance,// -fbuiltin-module-map can be used to load the clang; // builtin headers modulemap file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:39,load,load,39,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['load'],['load']
Performance,// -fmodule-cache-path specifies where our implicitly-built module files; // should be written.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:12,cache,cache-path,12,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['cache'],['cache-path']
Performance,// -fprebuilt-module-path specifies where to load the prebuilt module files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:45,load,load,45,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['load'],['load']
Performance,"// -fsanitize=function and -fsanitize=kcfi instrument indirect function calls; // to load a type hash before the function label. Ensure functions are aligned; // by a least 4 to avoid unaligned access, which is especially important for; // -mno-unaligned-access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:85,load,load,85,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,1,['load'],['load']
Performance,"// -fsanitize=function and -fsanitize=kcfi instrument indirect function; // calls to load a type hash before the function label. Therefore, an; // execute-only target doesn't support the function and kcfi sanitizers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:85,load,load,85,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['load'],['load']
Performance,// -fsave-optimization-record enables it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:10,optimiz,optimization-record,10,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['optimiz'],['optimization-record']
Performance,// -fsave-optimization-record=<format> enables it as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:10,optimiz,optimization-record,10,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['optimiz'],['optimization-record']
Performance,"// -fsemantic-interposition is forwarded to CC1: set the; // ""SemanticInterposition"" metadata to 1 (make some linkages interposable) and; // make default visibility external linkage definitions dso_preemptable.; //; // -fno-semantic-interposition: if the target supports .Lfoo$local local; // aliases (make default visibility external linkage definitions dso_local).; // This is the CC1 default for ELF to match COFF/Mach-O.; //; // Otherwise use Clang's traditional behavior: like; // -fno-semantic-interposition but local aliases are not used. So references; // can be interposed if not optimized out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:589,optimiz,optimized,589,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['optimiz'],['optimized']
Performance,// -fslp-vectorize is enabled based on the optimization level selected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:43,optimiz,optimization,43,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['optimiz'],['optimization']
Performance,"// ... JobManager::queue()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/NoopJob.h:19,queue,queue,19,roofit/multiprocess/test/NoopJob.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/NoopJob.h,2,['queue'],['queue']
Performance,"// ... process the type T recursively by performing Steps 2 through 7, and; // use the result as the attribute value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:41,perform,performing,41,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,1,['perform'],['performing']
Performance,"// ... then queue:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/ProcessManager.cxx:12,queue,queue,12,roofit/multiprocess/src/ProcessManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/ProcessManager.cxx,1,['queue'],['queue']
Performance,// ... to a pointer that has been loaded from before...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:34,load,loaded,34,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['load'],['loaded']
Performance,// ...VFP load/store (reg+constant offset),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:10,load,load,10,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,1,['load'],['load']
Performance,// ...and the access stride is less than the cache line size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:45,cache,cache,45,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,1,['cache'],['cache']
Performance,"// ...and work if the Snapshot is performed via an Alias",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_more.cxx:34,perform,performed,34,tree/dataframe/test/datasource_more.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_more.cxx,1,['perform'],['performed']
Performance,"// ...and work if the caching is performed via an Alias",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_more.cxx:33,perform,performed,33,tree/dataframe/test/datasource_more.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_more.cxx,1,['perform'],['performed']
Performance,// ...iWMMXt load/store,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:13,load,load,13,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,1,['load'],['load']
Performance,"// ...or in shared libraries (without auto-loading).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp:43,load,loading,43,interpreter/cling/lib/Interpreter/BackendPasses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp,1,['load'],['loading']
Performance,// ..that is loading a predicate vector sized worth of bits..,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp:13,load,loading,13,interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,1,['load'],['loading']
Performance,// ..where the value inserted comes from a load..,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp:43,load,load,43,interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,1,['load'],['load']
Performance,"// .gif+NN implies that this is a subimage of the animation; // with NN*10ms delay (latency) until the next one.; // You can also use this option on the last image if you do not want the gif to replay",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx:84,latency,latency,84,graf2d/asimage/src/TASImage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx,1,['latency'],['latency']
Performance,"// .on('change', () => this.performDraw());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:28,perform,performDraw,28,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['perform'],['performDraw']
Performance,"// // @(#)root/hist:$Id$; // Authors: Bartolomeu Rabacal 07/2010; /**********************************************************************; * *; * Copyright (c) 2006 , ROOT MathLib Team *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; * *; **********************************************************************/; /** \class TKDE; \ingroup Hist; Kernel Density Estimation class.; The three main references are:; 1. ""Scott DW, Multivariate Density Estimation. Theory, Practice and Visualization. New York: Wiley"",; 2. ""Jann Ben - ETH Zurich, Switzerland -, Univariate kernel density estimation document for KDENS:; Stata module for univariate kernel density estimation.""; 3. ""Hardle W, Muller M, Sperlich S, Werwatz A, Nonparametric and Semiparametric Models. Springer.""; 4. ""Cranmer KS, Kernel Estimation in High-Energy; Physics. Computer Physics Communications 136:198-207,2001"" - e-Print Archive: hep ex/0011057. The algorithm is briefly described in (4). A binned version is also implemented to address the; performance issue due to its data size dependance.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:1082,perform,performance,1082,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['perform'],['performance']
Performance,"// // Idea: need to cache this result!; // TStreamerInfo *info = (TStreamerInfo*)config->fInfo;; // TStreamerElement *aElement = (TStreamerElement*)info->GetElem(config->fElemId);; //; // *Int_t clversion = ((TStreamerBase*)aElement)->Get BaseVersion();; // *TClass *cle = aElement->GetNewBaseClass();; // *(TSequence *actions = CreateReadMemberWiseActions( cle->GetStreamerInfo(clversion), ???? );; //; // TSequence *actions = CreateReadMemberWiseActions( ((TStreamerBase*)aElement)->GetBaseStreamerInfo(), ???? );; //; // actions->ReadBuffer(b,start,end);; // delete actions;; // const Int_t incr = ((TVectorLoopConfig*)loopconfig)->fIncrement;; // for(void *iter = start; iter != end; iter = (char*)iter + incr ); // {; // ((TStreamerInfo*)(((TStreamerBase*)aElement)->GetBaseStreamerInfo())->ReadBuffer(b,arr,-1,narr,ioffset,arrayMode);; //; // ((TStreamerInfo*)config->fInfo)->ReadBuffer(buf, (char**)&iter, config->fElemId, 1, config->fOffset, 1|2 );; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:20,cache,cache,20,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,1,['cache'],['cache']
Performance,"// // Returns true if load/store instruction \p Ldst can be sunk down; // // to instruction \p To; // bool canSinkLoadStoreTo(MachineInstr *Ldst, MachineInstr *To);; // Check if instructions \p Ldst and \p Add can be moved to become adjacent; // If they can return instruction which need not to move.; // If \p Uses is not null, fill it with instructions after \p Ldst which use; // \p Ldst's base register",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCOptAddrMode.cpp:22,load,load,22,interpreter/llvm-project/llvm/lib/Target/ARC/ARCOptAddrMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCOptAddrMode.cpp,1,['load'],['load']
Performance,"// // fast-track clean-cache processing; // if (_operMode==AClean) {; // return _value ;; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:23,cache,cache,23,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['cache'],['cache']
Performance,"// /dev/null always reports a pos of 0, so we cannot perform this check; // in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:53,perform,perform,53,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,1,['perform'],['perform']
Performance,"// 0 indicates that this declaration was the only declaration of its entity,; // and is used for space optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:103,optimiz,optimization,103,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['optimiz'],['optimization']
Performance,"// 1) Do not fold bitcast shuffle for scalable type. First, shuffle cost for; // scalable type is unknown; Second, we cannot reason if the narrowed shuffle; // mask for scalable type is a splat or not.; // 2) Disallow non-vector casts.; // TODO: We could allow any shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:38,scalab,scalable,38,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,3,['scalab'],['scalable']
Performance,"// 1-by-1 pivot block d(k): column k now holds w(k) = u(k)*d(k); // where u(k) is the k-th column of u; // perform a rank-1 update of a(0:k-1,0:k-1) as; // a := a - u(k)*d(k)*u(k)' = a - w(k)*1/d(k)*w(k)'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompBK.cxx:107,perform,perform,107,math/matrix/src/TDecompBK.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompBK.cxx,1,['perform'],['perform']
Performance,"// 1. If the Idx has been completely eliminated and this subvector's size is; // a vector register or a multiple thereof, or the surrounding elements are; // undef, then this is a subvector insert which naturally aligns to a vector; // register. These can easily be handled using subregister manipulation.; // 2. If the subvector is smaller than a vector register, then the insertion; // must preserve the undisturbed elements of the register. We do this by; // lowering to an EXTRACT_SUBVECTOR grabbing the nearest LMUL=1 vector type; // (which resolves to a subregister copy), performing a VSLIDEUP to place the; // subvector within the vector register, and an INSERT_SUBVECTOR of that; // LMUL=1 type back into the larger vector (resolving to another subregister; // operation). See below for how our VSLIDEUP works. We go via a LMUL=1 type; // to avoid allocating a large register group to hold our subvector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:579,perform,performing,579,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['perform'],['performing']
Performance,"// 128-bit atomic load.; // Val, OUTCHAIN = ATOMIC_LOAD_128(INCHAIN, ptr)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:18,load,load,18,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,1,['load'],['load']
Performance,// 128-bit loads and stores can be done without expanding,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:11,load,loads,11,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['load'],['loads']
Performance,// 128-bit loads are supported for all instruction types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:11,load,loads,11,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['load'],['loads']
Performance,// 1a. CopyFromReg (and load) arg registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp:24,load,load,24,interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp,2,['load'],['load']
Performance,"// 1w; /// The maximum size for the cache directory, in terms of percentage of the; /// available space on the disk. Set to 100 to indicate no limit, 50 to; /// indicate that the cache size will not be left over half the available disk; /// space. A value over 100 will be reduced to 100. A value of 0 disables the; /// percentage size-based pruning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h:36,cache,cache,36,interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,2,['cache'],['cache']
Performance,"// 2-by-2 pivot block d(k): columns k and k-1 now hold; // ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k); // where u(k) and u(k-1) are the k-th and (k-1)-th columns of u; // perform a rank-2 update of a(0:k-2,0:k-2) as; // a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )'; // = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompBK.cxx:167,perform,perform,167,math/matrix/src/TDecompBK.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompBK.cxx,1,['perform'],['perform']
Performance,// 2. Check that the load is a legal operation for that type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,load,load,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,"// 2. Cling's pretty printing (not done through backend for performance reasons)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx:60,perform,performance,60,bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,1,['perform'],['performance']
Performance,// 2. Collect library loads,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:22,load,loads,22,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,1,['load'],['loads']
Performance,"// 256 bit non-temporal loads can be lowered to LDNP. This is done using; // custom lowering, as there are no un-paired non-temporal loads legalization; // will break up 256 bit inputs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:24,load,loads,24,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['load'],['loads']
Performance,"// 2nd: load the weights from the temporary file into the MLP; // the MLP is already build",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodTMlpANN.cxx:8,load,load,8,tmva/tmva/src/MethodTMlpANN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodTMlpANN.cxx,1,['load'],['load']
Performance,"// 3) Find loads and stores that can be merged into a single load or store; // pair instruction.; // e.g.,; // ldr x0, [x2]; // ldr x1, [x2, #8]; // ; becomes; // ldp x0, x1, [x2]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:11,load,loads,11,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,2,['load'],"['load', 'loads']"
Performance,// 3. Perform the actual call.; // Deactivate any cleanups that we're supposed to do immediately before; // the call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:6,Perform,Perform,6,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['Perform'],['Perform']
Performance,// 3. Process library loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:22,load,loads,22,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,1,['load'],['loads']
Performance,"// 32 bit macho has no relocation for a-b if a is undefined, even if b is in; // the section that is being relocated. This means we have to use o load even; // for GVs that are known to be local to the dso.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:146,load,load,146,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,1,['load'],['load']
Performance,"// 32 bit macho has no relocation for a-b if a is undefined, even if; // b is in the section that is being relocated.; // This means we have to use o load even for GVs that are known to be; // local to the dso.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp:150,load,load,150,interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp,1,['load'],['load']
Performance,// 32-byte vector nontemporal stores are supported by AVX (the equivalent; // loads require AVX2).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:78,load,loads,78,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['loads']
Performance,"// 4) Find base register updates that can be merged into the load or store; // as a base-reg writeback.; // e.g.,; // ldr x0, [x2]; // add x2, x2, #4; // ; becomes; // ldr x0, [x2], #4",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:61,load,load,61,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,1,['load'],['load']
Performance,// 6 is an approximate latency for the mtctr instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:23,latency,latency,23,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,1,['latency'],['latency']
Performance,"// 8-, 16-, and 32-bit integer loads all implicitly zero-extend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:31,load,loads,31,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['load'],['loads']
Performance,// 8-bit and 16-bit loads implicitly zero-extend to 32-bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:20,load,loads,20,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['load'],['loads']
Performance,"// 8-byte load instructions, 4-byte jump, 4-byte padding",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFThumb.h:10,load,load,10,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFThumb.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFThumb.h,1,['load'],['load']
Performance,"// 96-bit loads are only available for vector loads. We need to split this; // into a 64-bit part, and 32 (unless we can widen to a 128-bit load).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:10,load,loads,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,3,['load'],"['load', 'loads']"
Performance,"// <----- bool is stored (for performance reasons, no std::vector<bool> has been taken)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx:30,perform,performance,30,tmva/tmva/src/DecisionTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx,2,['perform'],['performance']
Performance,"// << gTools().Color(""reset"")<<"" DataSet Name: ""<<gTools().Color(""bold"")<<loader->GetName()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Factory.cxx:74,load,loader,74,tmva/tmva/src/Factory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Factory.cxx,1,['load'],['loader']
Performance,// << load / store; // For load / store instructions the size is encoded in bits 31:30.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:6,load,load,6,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,4,['load'],['load']
Performance,"// <vscale x 1 x iN> is assumed to be profitable over iN because; // scalable registers are a distinct register class from scalar ones.; // If we ever find a target which wants to lower scalable vectors; // back to scalars, we'll need to update this code to explicitly; // ask TTI about the register class uses for each part.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:69,scalab,scalable,69,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['scalab'],['scalable']
Performance,// <vscale x n x ty>; // Convert fixed vectors to scalable if needed,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:50,scalab,scalable,50,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['scalab'],['scalable']
Performance,"// = SO_Linker; /// This function will search through all previously loaded dynamic; /// libraries for the symbol \p symbolName. If it is found, the address of; /// that symbol is returned. If not, null is returned. Note that this will; /// search permanently loaded libraries (getPermanentLibrary()) as well; /// as explicitly registered symbols (AddSymbol()).; /// @throws std::string on error.; /// Search through libraries for address of a symbol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:69,load,loaded,69,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,2,['load'],['loaded']
Performance,"// ======= Check if the library need to loaded or compiled",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:40,load,loaded,40,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['load'],['loaded']
Performance,"// ======= Load the library the script might depend on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:11,Load,Load,11,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['Load'],['Load']
Performance,"// =============================================================================; // If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),; // and we can't guarantee that the only accesses are loads,; // then add the following instructions to the first basic block:; //; // %temp = alloca %struct.x, align 8; // %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*; // %tv = load %struct.x addrspace(101)* %tempd; // store %struct.x %tv, %struct.x* %temp, align 8; //; // The above code allocates some space in the stack and copies the incoming; // struct from param space to local space.; // Then replace all occurrences of %d by %temp.; //; // In case we know that all users are GEPs or Loads, replace them with the same; // ones in parameter AS, so we can access them using ld.param.; // =============================================================================; // Replaces the \p OldUser instruction with the same in parameter AS.; // Only Load and GEP are supported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:213,load,loads,213,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,4,"['Load', 'load']","['Load', 'Loads', 'load', 'loads']"
Performance,"// @(#)root/base:$Id$; // Author: Fons Rademakers 04/08/95; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TString; \ingroup Base. Basic string class. Cannot be stored in a TCollection... use TObjString instead. The underlying string is stored as a char* that can be accessed via; TString::Data().; TString provides Short String Optimization (SSO) so that short; strings (<15 on 64-bit and <11 on 32-bit) are contained in the; TString internal data structure without the need for mallocing the; required space. Substring operations are provided by the TSubString class, which; holds a reference to the original string and its data, along with; the offset and length of the substring. To retrieve the substring; as a TString, construct a TString from it, eg:; ~~~ {.cpp}; root [0] TString s(""hello world""); root [1] TString s2( s(0,5) ); root [2] s2; (class TString)""hello""; ~~~; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx:651,Optimiz,Optimization,651,core/base/src/TString.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx,1,['Optimiz'],['Optimization']
Performance,"// @(#)root/base:$Id$; // Author: Fons Rademakers 14/02/2002; /*************************************************************************; * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TVirtualMutex; \ingroup Base. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; ~~~ {.cpp}; {; TLockGuard guard(mutex);; ... // do something; }; ~~~; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualMutex.cxx:590,load,loaded,590,core/base/src/TVirtualMutex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualMutex.cxx,1,['load'],['loaded']
Performance,"// @(#)root/base:$Id$; // Author: Fons Rademakers 26/1/2002; /*************************************************************************; * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TPluginManager; \ingroup Base. This class implements a plugin library manager. It keeps track of a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read SQLite files one needs to load the plugin library; libRSQLite.so which defines the TRSQLiteServer class. This loading; should be triggered when a given URI contains a regular expression; defined by the handler. Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like `<BaseClass>/PX0_<PluginClass>.C`,; e.g. TSQLServer/P20_TMySQLServer.C, to allow easy sorting and grouping.; If the BaseClass is in a namespace the directory must have the name; NameSpace@@BaseClass as `:` is a reserved pathname character on some; operating systems. Macros not beginning with 'P' and ending with "".C""; are ignored. These macros typically look like:; ~~~ {.cpp}; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }; ~~~; Plugin handlers can also be defined v",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx:602,load,load,602,core/base/src/TPluginManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx,3,['load'],"['load', 'loading']"
Performance,"// @(#)root/base:$Id$; // Author: Kristjan Gulbrandsen 11/05/04; /*************************************************************************; * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TVirtualPerfStats; \ingroup Base. Provides the interface for the PROOF internal performance measurement; and event tracing.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualPerfStats.cxx:514,perform,performance,514,core/base/src/TVirtualPerfStats.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualPerfStats.cxx,1,['perform'],['performance']
Performance,"// @(#)root/cont:$Id$; // Author: Fons Rademakers 11/08/95; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TObjectTable; \ingroup Containers; This class registers all instances of TObject and its derived; classes in a hash table. The Add() and Remove() members are called; from the TObject ctor and dtor, respectively. Using the Print(); member one can see all currently active objects in the system.; Using the resource (in .rootrc): Root.ObjectStat one can toggle this; feature on or off. Using the compile option R__NOSTATS one can de-active this feature; for the entire system (for maximum performance in highly time; critical applications). The following output has been produced in a ROOT interactive session; via the command gObjectTable->Print(); ~~~ {.cpp}; class cnt on heap size total size heap size; ============================================================================; TKey 4 4 72 288 288; TClass 84 84 80 6720 6720; TDataMember 276 276 24 6624 6624; TObject 11 11 12 132 132; TMethod 1974 1974 64 126336 126336; TDataType 34 34 56 1904 1904; TList 2328 2328 36 83808 83808; TH1F 1 1 448 448 448; TText 2688 2688 56 150528 150528; TGaxis 1 0 120 120 0; TAxis 6 3 88 528 264; TBox 57 57 52 2964 2964; TLine 118 118 40 4720 4720; TWbox 1 1 56 56 56; TArrow 1 1 64 64 64; TPaveText 59 59 124 7316 7316; TPave 1 1 92 92 92; TFile 1 1 136 136 136; TCanvas 3 3 444 1332 1332; TPad 1 1 312 312 312; TContextMenu 3 3 48 144 144; TMethodArg 2166 2166 44 95304 95304; TPaveLabel 1 1 120 120 120; THtml 1 1 32 32 32; TROOT 1 0 208 208 0; TApplication 1 1 28 28 28; TFileHandler 1 1 20 20 20; TColor 163 163 40 6520 6520; TStyle 1 1 364 364 364; TRealData 117 117 28 327",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TObjectTable.cxx:916,perform,performance,916,core/cont/src/TObjectTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TObjectTable.cxx,1,['perform'],['performance']
Performance,"// @(#)root/cont:$Id$; // Author: Rene Brun 28/09/2001; /*************************************************************************; * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TRefTable; \ingroup Containers; A TRefTable maintains the association between a referenced object; and the parent object supporting this referenced object. The parent object is typically a branch of a TTree. For each object; referenced in a TTree entry, the corresponding entry in the TTree's; TBranchRef::fRefTable contains the index of the branch that; needs to be loaded to bring the object into memory. Persistency of a TRefTable is split into two parts:; - entry specific information is stored (read) by FillBuffer; (ReadBuffer). For each referenced object the object's fUniqueID; and the referencing TRef::fPID is stored (to allow the TRefTable; to autoload references created by different processes).; - non-entry specific, i.e. global information is stored (read) by; the Streamer function. This comprises all members marked as; persistent. As TObject::fUniqueID is only unique for a given TProcessID, a table; of unique IDs is kept for each used TProcessID. There is no natural; order of TProcessIDs, so TRefTable stores a vector of the TGUID of; all known TProcessIDs in fProcessGUIDs; the index of a TProcessID in; this vector defines the index of the auto-loading info in fParentIDs; for that TProcessID. The mapping of TProcessID* to index is cached; for quick non-persistent lookup.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TRefTable.cxx:792,load,loaded,792,core/cont/src/TRefTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TRefTable.cxx,3,"['cache', 'load']","['cached', 'loaded', 'loading']"
Performance,"// @(#)root/fitpanel:$Id: ed8d59036b6a51c67cd739c2c75aa7780b847bf8 $; // Author: Ilka Antcheva, Lorenzo Moneta 10/08/2006; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TFitEditor; \ingroup fitpanel. Allows to perform, explore and compare various fits. To display the new Fit panel interface right click on a histogram; or a graph to pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likel",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:533,perform,perform,533,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['perform'],['perform']
Performance,"// @(#)root/ged:$Id$; // Author: Ilka Antcheva 11/05/04; /*************************************************************************; * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TAxisEditor; \ingroup ged. Implements GUI for axis attributes.; axis color; ticks parameters: length, setting on both axis sides,; logarithmic or linear scale along the selected axis,; primary, secondary and tertiary axis divisions,; setting more logarithmic labels,; optimizing labels' position if available; axis title - a title can be added via the text entry field; and can be set to be centered or rotated via the corresponding; check buttons, the title color, offset, font can be set easily; axis labels - their color, size, offset can be set similarly,; in addition there is a check box for no exponent choice,; and another one for setting the same decimal part for all labels. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TAxisEditor.cxx:694,optimiz,optimizing,694,gui/ged/src/TAxisEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TAxisEditor.cxx,1,['optimiz'],['optimizing']
Performance,"// @(#)root/geom:$Id$; // Author: Andrei Gheata 01/11/01; // CheckGeometry(), CheckOverlaps() by Mihaela Gheata; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TGeoChecker; \ingroup Geometry_painter. Geometry checking package. TGeoChecker class provides several geometry checking methods. There are two; types of tests that can be performed. One is based on random sampling or; ray-tracing and provides a visual check on how navigation methods work for; a given geometry. The second actually checks the validity of the geometry; definition in terms of overlapping/extruding objects. Both types of checks; can be done for a given branch (starting with a given volume) as well as for; the geometry as a whole. #### TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z). This method can be called directly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). #### TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. #### TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays until they exit geometry, plotting; all segmen",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx:653,perform,performed,653,geom/geompainter/src/TGeoChecker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx,1,['perform'],['performed']
Performance,"// @(#)root/geom:$Id$; // Author: Andrei Gheata 25/10/01; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TGeoMatrix; \ingroup Geometry_classes. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. ~~~ {.cpp}; MASTER = T * LOCAL; ~~~. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embedding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication. Rotation: Inverse rotation:. ~~~ {.cpp}; r11 r12 r13 0 r11 r21 r31 0; r",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx:650,optimiz,optimize,650,geom/geom/src/TGeoMatrix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx,2,"['optimiz', 'perform']","['optimize', 'performance']"
Performance,"// @(#)root/geom:$Id$; // Author: Mihaela Gheata 5/01/04; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TGeoPolygon; \ingroup Shapes_classes. An arbitrary polygon defined by vertices. The vertices; have to be defined CLOCKWISE in the XY plane, making either a convex; or concave polygon. No test for malformed polygons is performed. A polygon is a 2D shape defined by vertices in the XY plane. It is used by; TGeoXtru class for computing Contains() and Safety(). Only the pointers to; the actual lists of XY values are used - these are not owned by the class. To check if a point in XY plane is contained by a polygon, this is split; into an outscribed convex polygon and the remaining polygons of its subtraction; from the outscribed one. A point is INSIDE if it is; contained by the outscribed polygon but NOT by the remaining ones. Since these; can also be arbitrary polygons at their turn, a tree structure is formed:. ~~~ {.cpp}; P = Pconvex - (Pconvex-P) where (-) means 'subtraction'; Pconvex-P = P1 + P2 + ... where (+) means 'union'; ~~~. *Note that P1, P2, ... do not intersect each other and they are defined; by subsets of the list of vertices of P. They can be split in the same; way as P*. Therefore, if C(P) represents the Boolean : 'does P contains a given point?',; then:. ~~~ {.cpp}; C(P) = C(Pconvex) .and. not(C(P1) | C(P2) | ...); ~~~. For creating a polygon without TGeoXtru class, one has to call the constructor; TGeoPolygon(nvert) and then SetXY(Double_t *x, Double_t *y) providing the; arrays of X and Y vertex positions (defined clockwise) that have to 'live' longer; than the polygon they will describe. This complication is due to efficiency reasons",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPolygon.cxx:645,perform,performed,645,geom/geom/src/TGeoPolygon.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPolygon.cxx,1,['perform'],['performed']
Performance,"// @(#)root/gui:$Id$; // Author: Fons Rademakers 01/01/98; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**************************************************************************. This source is based on Xclass95, a Win95-looking GUI toolkit.; Copyright (C) 1996, 1997 David Barth, Ricky Ralston, Hector Peraza. Xclass95 is free software; you can redistribute it and/or; modify it under the terms of the GNU Library General Public; License as published by the Free Software Foundation; either; version 2 of the License, or (at your option) any later version. **************************************************************************/; /** \class TGPicture; \ingroup guiwidgets. The TGPicture class implements pictures and icons used in the; different GUI elements and widgets. The TGPicturePool class; implements a TGPicture cache. TGPictures are created, managed and; destroyed by the TGPicturePool. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGPicture.cxx:1140,cache,cache,1140,gui/gui/src/TGPicture.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGPicture.cxx,1,['cache'],['cache']
Performance,"// @(#)root/gui:$Id: 1f399bfa44c1323de4c6fe38d6d7a83a4bdf2e32 $; // Author: Fons Rademakers 1/7/2000; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**************************************************************************. This source is based on Xclass95, a Win95-looking GUI toolkit.; Copyright (C) 1996, 1997 David Barth, Ricky Ralston, Hector Peraza. Xclass95 is free software; you can redistribute it and/or; modify it under the terms of the GNU Library General Public; License as published by the Free Software Foundation; either; version 2 of the License, or (at your option) any later version. **************************************************************************/; /** \class TGTextView; \ingroup guiwidgets. A TGTextView is a text viewer widget. It is a specialization of; TGView. It uses the TGText class (which contains all text; manipulation code, i.e. loading a file in memory, changing,; removing lines, etc.). Use a TGTextView to view non-editable text.; For supported messages see TGView. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextView.cxx:1185,load,loading,1185,gui/gui/src/TGTextView.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextView.cxx,1,['load'],['loading']
Performance,"// @(#)root/gui:$Id: ba5caabd5d69c640536a71daaa6968de966be4a8 $; // Author: Fons Rademakers 26/04/98; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**************************************************************************. This source is based on Xclass95, a Win95-looking GUI toolkit.; Copyright (C) 1996, 1997 David Barth, Ricky Ralston, Hector Peraza. Xclass95 is free software; you can redistribute it and/or; modify it under the terms of the GNU Library General Public; License as published by the Free Software Foundation; either; version 2 of the License, or (at your option) any later version. **************************************************************************/; /** \class TGText; \ingroup guiwidgets. A TGText is a multi line text buffer. It allows the text to be; loaded from file, saved to file and edited. It is used in the; TGTextEdit widget. Single line text is handled by TGTextBuffer; and the TGTextEntry widget. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGText.cxx:1097,load,loaded,1097,gui/gui/src/TGText.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGText.cxx,1,['load'],['loaded']
Performance,"// @(#)root/hbook:$Id$; // Author: Rene Brun 18/02/2002; /*************************************************************************; * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class THbookFile; \ingroup Hist; This class is an interface to the Hbook objects in Hbook files.; Any Hbook object (1-D, 2-D, Profile, RWN or CWN can be read. NB: a THbookFile can only be used in READ mode; Use the utility in $ROOTSYS/bin/h2root to convert Hbook to Root. Example of use:. gSystem->Load(""libHbook"");; THbookFile f(""myfile.hbook"");; f.ls();; TH1F *h1 = (TH1F*)f.Get(1); //import histogram ID=1 in h1; h1->Fit(""gaus"");; THbookTree *T = (THbookTree*)f.Get(111); //import ntuple header; T->Print(); //show the Hbook ntuple variables; T->Draw(""x"",""y<0""); // as in normal TTree::Draw. THbookFile can be browsed via TBrowser.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hbook/src/THbookFile.cxx:718,Load,Load,718,hist/hbook/src/THbookFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hbook/src/THbookFile.cxx,1,['Load'],['Load']
Performance,"// @(#)root/hist:$Id$; /** \class RooStats::HybridPlot; \ingroup Roostats. This class provides the plots for the result of a study performed with the; HybridCalculatorOriginal class. Authors: D. Piparo, G. Schott - Universitaet Karlsruhe. An example plot is available here:; http://www-ekp.physik.uni-karlsruhe.de/~schott/roostats/hybridplot_example.png; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HybridPlot.cxx:131,perform,performed,131,roofit/roostats/src/HybridPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HybridPlot.cxx,1,['perform'],['performed']
Performance,"// @(#)root/io:$Id$; // Author: Markus Frank 28/10/04; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**; \class TEmulatedCollectionProxy; \ingroup IO. Streamer around an arbitrary STL like container, which implements basic; container functionality. ### Note:; Although this class contains all the setup necessary to deal; with maps, the map-like functionality is NOT supported.; For optimization reasons this functionality is put into; the class TEmulatedMapProxy.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TEmulatedCollectionProxy.cxx:696,optimiz,optimization,696,io/io/src/TEmulatedCollectionProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TEmulatedCollectionProxy.cxx,1,['optimiz'],['optimization']
Performance,"// @(#)root/io:$Id$; // Author: Markus Frank 28/10/04; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////////; // //; // TEmulatedMapProxy; //; // Streamer around an arbitrary container, which implements basic; // functionality and iteration.; //; // In particular this is used to implement splitting and abstract; // element access of any container. Access to compiled code is necessary; // to implement the abstract iteration sequence and functionality like; // size(), clear(), resize(). resize() may be a void operation.; //; //////////////////////////////////////////////////////////////////////////; /**; \class TEmulatedMapProxy; \ingroup IO. Streamer around a map container. For optimization reasons this functionality; is separated from the TEmulatedProxy.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TEmulatedMapProxy.cxx:1065,optimiz,optimization,1065,io/io/src/TEmulatedMapProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TEmulatedMapProxy.cxx,1,['optimiz'],['optimization']
Performance,"// @(#)root/io:$Id$; // Author: Rene Brun 18/05/2006; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**; \class TFileCacheRead; \ingroup IO. A cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TNetXNGFile and TWebFile (via TFile::ReadBuffers()).; When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx:455,cache,cache,455,io/io/src/TFileCacheRead.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx,4,['cache'],['cache']
Performance,"// @(#)root/io:$Id$; // Author: Rene Brun 18/05/2006; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**; \class TFileCacheWrite TFileCacheWrite.cxx; \ingroup IO; A cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TNetXNGFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheWrite.cxx:476,cache,cache,476,io/io/src/TFileCacheWrite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheWrite.cxx,5,['cache'],['cache']
Performance,"// @(#)root/meta:$Id$; // Author: Philippe Canal 15/03/2005; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TClassRef; TClassRef is used to implement a permanent reference to a TClass; object. In particular this reference will change if and when the; TClass object is regenerated. This regeneration usually happens; when a library containing the described class is loaded after a; file containing an instance of this class has been opened. The references kept track of using an intrusive double linked list.; The intrusive list is maintained by TClass::AddRef and; TClass::RemoveRef. The 'start' of the list is held in; TClass::fRefStart.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClassRef.cxx:687,load,loaded,687,core/meta/src/TClassRef.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClassRef.cxx,1,['load'],['loaded']
Performance,"// @(#)root/net:$Id$; // Author: A. Peters, G. Ganis 7/2/2007; /*************************************************************************; * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////////; // //; // TFileStager //; // //; // Abstract base class defining an interface to a stager. //; // //; // To open a connection to a stager use the static method //; // Open(""<stager>""), where <stager> contains a keyword allowing to load //; // the relevant plug-in, e.g. //; // TFileStager::Open(""root://lxb6064.cern.ch"") //; // will load TNetXNGFileStager and initialize it for the redirector at //; // lxb6046.cern.ch . //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TFileStager.cxx:728,load,load,728,net/net/src/TFileStager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TFileStager.cxx,2,['load'],['load']
Performance,"// @(#)root/net:$Id$; // Author: Fons Rademakers 13/02/2001; /*************************************************************************; * Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////////; // //; // TFTP //; // //; // This class provides all infrastructure for a performant file //; // transfer protocol. It works in conjuction with the rootd daemon //; // and can use parallel sockets to improve performance over fat pipes. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TFTP.cxx:569,perform,performant,569,net/net/src/TFTP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TFTP.cxx,2,['perform'],"['performance', 'performant']"
Performance,"// @(#)root/net:$Id$; // Author: Fons Rademakers 18/12/96; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////////; // //; // TServerSocket //; // //; // This class implements server sockets. A server socket waits for //; // requests to come in over the network. It performs some operation //; // based on that request and then possibly returns a full duplex socket //; // to the requester. The actual work is done via the TSystem class //; // (either TUnixSystem or TWinNTSystem). //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx:643,perform,performs,643,net/net/src/TServerSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx,1,['perform'],['performs']
Performance,"// @(#)root/net:$Id$; // Author: Fons Rademakers 19/1/2001; /*************************************************************************; * Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////////; // //; // TPServerSocket //; // //; // This class implements parallel server sockets. A parallel server //; // socket waits for requests to come in over the network. It performs //; // some operation based on that request and then possibly returns a //; // full duplex parallel socket to the requester. The actual work is //; // done via the TSystem class (either TUnixSystem or TWinNTSystem). //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPServerSocket.cxx:663,perform,performs,663,net/net/src/TPServerSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPServerSocket.cxx,1,['perform'],['performs']
Performance,"// @(#)root/net:$Id$; // Author: Fons Rademakers 22/1/2001; /*************************************************************************; * Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////////; // //; // TPSocket //; // //; // This class implements parallel client sockets. A parallel socket is //; // an endpoint for communication between two machines. It is parallel //; // because several TSockets are open at the same time to the same //; // destination. This especially speeds up communication over Big Fat //; // Pipes (i.e. high bandwidth, high latency WAN connections). //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPSocket.cxx:852,latency,latency,852,net/net/src/TPSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPSocket.cxx,1,['latency'],['latency']
Performance,"// @(#)root/net:$Id$; // Author: Fons Rademakers 25/11/99; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////////; // //; // TSQLServer //; // //; // Abstract base class defining interface to a SQL server. //; // //; // To open a connection to a server use the static method Connect(). //; // The db argument of Connect() is of the form: //; // <dbms>://<host>[:<port>][/<database>], e.g. //; // mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main, ... //; // Depending on the <dbms> specified an appropriate plugin library //; // will be loaded which will provide the real interface. //; // For SQLite, the syntax is slightly different: //; // sqlite://<database> //; // The string 'database' is directly passed to sqlite3_open(_v2), //; // so e.g. a filename or "":memory:"" are possible values. //; // For SQLite versions >= 3.7.7, SQLITE_OPEN_URI is activated to also //; // allow URI-parameters if needed. //; // //; // Related classes are TSQLResult and TSQLRow. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSQLServer.cxx:926,load,loaded,926,net/net/src/TSQLServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSQLServer.cxx,1,['load'],['loaded']
Performance,"// @(#)root/net:$Id$; // Author: Fons Rademakers 3/1/2002; /*************************************************************************; * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////////; // //; // TGrid //; // //; // Abstract base class defining interface to common GRID services. //; // //; // To open a connection to a GRID use the static method Connect(). //; // The argument of Connect() is of the form: //; // <grid>[://<host>][:<port>], e.g. alien://alice.cern.ch //; // Depending on the <grid> specified an appropriate plugin library //; // will be loaded which will provide the real interface. //; // //; // Related classes are TGridResult. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TGrid.cxx:862,load,loaded,862,net/net/src/TGrid.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TGrid.cxx,1,['load'],['loaded']
Performance,"// @(#)root/physics:$Id$; // Author: Pasha Murat , Peter Malzacher 12/02/99; // Oct 8 1999: changed Warning to Error and; // return fX in Double_t & operator(); // Oct 20 1999: ditto in Double_t operator(); // Jan 25 2000: implemented as (fP,fE) instead of (fX,fY,fZ,fE); /** \class TLorentzVector; \ingroup Physics. \attention \parblock; TLorentzVector is a legacy class.; It is slower and worse for serialization than the recommended superior alternative ROOT::Math::LorentzVector.; ROOT provides specialisations of the ROOT::Math::LorentzVector template which; offer superior runtime performance, i.e.:; - ROOT::Math::PtEtaPhiMVector based on pt (rho),eta,phi and M (t) coordinates in double precision; - ROOT::Math::PtEtaPhiEVector based on pt (rho),eta,phi and E (t) coordinates in double precision; - ROOT::Math::PxPyPzMVector based on px,py,pz and M (mass) coordinates in double precision; - ROOT::Math::PxPyPzEVector based on px,py,pz and E (energy) coordinates in double precision; - ROOT::Math::XYZTVector based on x,y,z,t coordinates (cartesian) in double precision (same as PxPyPzEVector); - ROOT::Math::XYZTVectorF based on x,y,z,t coordinates (cartesian) in float precision (same as PxPyPzEVector but float). More details can be found in the documentation of the @ref GenVector package.; \endparblock. ### Description; TLorentzVector is a general four-vector class, which can be used; either for the description of position and time (x,y,z,t) or momentum and; energy (px,py,pz,E). ### Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable.; By default all components are initialized by zero. ~~~ {.cpp}; TLorentzVector v1; // initialized by (0., 0., 0., 0.); TLorentzVector v2(1., 1., 1., 1.);; TLorentzVector v3(v1);; TLorentzVector v4(TVector3(1., 2., 3.),4.);; ~~~. For backward compatibility there are two constructors from an Double_t; and Float_t C array. ### Access to the components; There are two sets of access functions to the components",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TLorentzVector.cxx:587,perform,performance,587,math/physics/src/TLorentzVector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TLorentzVector.cxx,1,['perform'],['performance']
Performance,"// @(#)root/proof:$Id$; // Author: Fons Rademakers 14/02/97; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TSlave; \ingroup proofkernel. Class describing a PROOF worker server. It contains information like the; workers host name, ordinal number, performance index, socket, etc.; Objects of this class can only be created via TProof member functions. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx:569,perform,performance,569,proof/proof/src/TSlave.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx,1,['perform'],['performance']
Performance,"// @(#)root/proof:$Id$; // Author: Sangsu Ryu 22/06/2010; /*************************************************************************; * Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TProofBenchRunDataRead; \ingroup proofbench. I/O-intensive PROOF benchmark test reads in event files distributed; on the cluster. Number of events processed per second and size of; events processed per second are plotted against number of active; workers. Performance rate for unit packets and performance rate; for query are plotted. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBenchRunDataRead.cxx:683,Perform,Performance,683,proof/proofbench/src/TProofBenchRunDataRead.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBenchRunDataRead.cxx,2,"['Perform', 'perform']","['Performance', 'performance']"
Performance,"// @(#)root/proof:$Id$; // Author: Sangsu Ryu 22/06/2010; /*************************************************************************; * Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TSelEvent; \ingroup proofbench. Selector for PROOF I/O benchmark test.; For the I/O benchmark, event files are read in and histograms are filled.; For memory clean-up, dedicated files large enough to clean up memory ; cache on the machine are read in. Or memory clean-up can be ; accompolished by system call on Linux machine inside SlaveBegin(..) ; which should be much faster the reading in large files. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelEvent.cxx:645,cache,cache,645,proof/proofbench/src/TSelEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelEvent.cxx,1,['cache'],['cache']
Performance,"// @(#)root/proof:$Id$; // Author: Sangsu Ryu 22/06/2010; /*************************************************************************; * Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TSelHandleDataSet; \ingroup proofbench. PROOF selector for file cache release.; List of files to be cleaned for each node is provided by client. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelHandleDataSet.cxx:491,cache,cache,491,proof/proofbench/src/TSelHandleDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelHandleDataSet.cxx,1,['cache'],['cache']
Performance,"// @(#)root/proofplayer:$Id$; // Author: Jan Iwaszkiewicz 11/12/06; /*************************************************************************; * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TPacketizerAdaptive; \ingroup proofkernel. This packetizer is based on TPacketizer but uses different; load-balancing algorithms and data structures.; Two main improvements in the load-balancing strategy:; - First one was to change the order in which the files are assigned; to the computing nodes in such a way that network transfers are; evenly distributed in the query time. Transfer of the remote files; was often becoming a bottleneck at the end of a query.; - The other improvement is the use of time-based packet size. We; measure the processing rate of all the nodes and calculate the; packet size, so that it takes certain amount of time. In this way; packetizer prevents the situation where the query can't finish; because of one slow node. The data structures: TFileStat, TFileNode and TSlaveStat are; enriched + changed and TFileNode::Compare method is changed. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx:540,load,load-balancing,540,proof/proofplayer/src/TPacketizerAdaptive.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx,3,"['bottleneck', 'load']","['bottleneck', 'load-balancing']"
Performance,"// @(#)root/proofplayer:$Id$; // Author: Kristjan Gulbrandsen 11/05/04; /*************************************************************************; * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TPerfStats; \ingroup proofkernel. Provides the interface for the PROOF internal performance measurement; and event tracing. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPerfStats.cxx:521,perform,performance,521,proof/proofplayer/src/TPerfStats.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPerfStats.cxx,1,['perform'],['performance']
Performance,"// @(#)root/proofplayer:$Id$; // Author: Long Tran-Thanh 22/07/07; // Revised: G. Ganis, May 2011; /*************************************************************************; * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TPacketizerUnit; \ingroup proofkernel. This packetizer generates packets of generic units, representing the; number of times an operation cycle has to be repeated by the worker; node, e.g. the number of Monte carlo events to be generated.; Packets sizes are generated taking into account the performance of; worker nodes, based on the time needed to process previous packets,; with the goal of having all workers ending at the same time. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerUnit.cxx:760,perform,performance,760,proof/proofplayer/src/TPacketizerUnit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerUnit.cxx,1,['perform'],['performance']
Performance,"// @(#)root/proofplayer:$Id$; // Author: Maarten Ballintijn 18/03/02; /*************************************************************************; * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TPacketizer; \ingroup proofkernel. This class generates packets to be processed on PROOF worker servers.; A packet is an event range (begin entry and number of entries) or; object range (first object and number of objects) in a TTree; (entries) or a directory (objects) in a file.; Packets are generated taking into account the performance of the; remote machine, the time it took to process a previous packet on; the remote machine, the locality of the database files, etc. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx:767,perform,performance,767,proof/proofplayer/src/TPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx,1,['perform'],['performance']
Performance,"// @(#)root/proofplayer:$Id$; // Author: Maarten Ballintijn 9/7/2002; /*************************************************************************; * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TVirtualPacketizer; \ingroup proofkernel. The packetizer is a load balancing object created for each query.; It generates packets to be processed on PROOF worker servers.; A packet is an event range (begin entry and number of entries) or; object range (first object and number of objects) in a TTree; (entries) or a directory (objects) in a file.; Packets are generated taking into account the performance of the; remote machine, the time it took to process a previous packet on; the remote machine, the locality of the database files, etc. TVirtualPacketizer includes common parts of PROOF packetizers.; Look in subclasses for details.; The default packetizer is TPacketizerAdaptive (TPacketizer for Proof-Lite).; To use an alternative one, for instance - the TPacketizer, call:; proof->SetParameter(""PROOF_Packetizer"", ""TPacketizer"");. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TVirtualPacketizer.cxx:501,load,load,501,proof/proof/src/TVirtualPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TVirtualPacketizer.cxx,2,"['load', 'perform']","['load', 'performance']"
Performance,"// @(#)root/proofx:$Id$; // Author: G.Ganis Nov 2011; /*************************************************************************; * Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TProofPerfAnalysis; \ingroup proofbench. Set of tools to analyse the performance tree. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofPerfAnalysis.cxx:492,perform,performance,492,proof/proofbench/src/TProofPerfAnalysis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofPerfAnalysis.cxx,1,['perform'],['performance']
Performance,"// @(#)root/proofx:$Id$; // Author: Gerardo Ganis 12/12/2005; /*************************************************************************; * Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TProofServLite; \ingroup proofkernel. Version of the PROOF worker server for local running. The client starts; directly the desired number of these workers; the master and daemons are; eliminated, optimizing the number of messages exchanged and created / destroyed. */; //////////////////////////////////////////////////////////////////////////; // //; // TProofServLite //; // //; // TProofServLite is the version of the PROOF worker server for local //; // running. The client starts directly the desired number of these //; // workers; the master and daemons are eliminated, optimizing the number//; // of messages exchanged and created / destroyed. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServLite.cxx:628,optimiz,optimizing,628,proof/proof/src/TProofServLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServLite.cxx,2,['optimiz'],['optimizing']
Performance,"// @(#)root/rint:$Id$; // Author: Christian Lacunza <lacunza@cdfsg6.lbl.gov> 27/04/99; // Modified by Artur Szostak <artur@alice.phy.uct.ac.za> : 1 June 2003; // Added support for namespaces.; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////////////; // //; // TTabCom //; // //; // This class performs basic tab completion. //; // You should be able to hit [TAB] to complete a partially typed: //; // //; // username //; // environment variable //; // preprocessor directive //; // pragma //; // filename (with a context-sensitive path) //; // public member function or data member (including base classes) //; // global variable, function, or class name //; // //; // Also, something like //; // //; // someObject->Func([TAB] //; // someObject.Func([TAB] //; // someClass::Func([TAB] //; // someClass var([TAB] //; // new someClass([TAB] //; // //; // will print a list of prototypes for the indicated //; // method or constructor. //; // //; // Current limitations and bugs: //; // //; // 1. you can only use one member access operator at a time. //; // eg, this will work: gROOT->GetListOfG[TAB] //; // but this will not: gROOT->GetListOfGlobals()->Conta[TAB] //; // //; // 2. nothing is guaranteed to work on windows //; // (for one thing, /bin/env and /etc/passwd are hardcoded) //; // //; // 3. CINT shortcut #2 is deliberately not supported. //; // (using ""operator.()"" instead of ""operator->()"") //; // //; // 4. most identifiers (including C++ identifiers, usernames, //; // environment variables, etc) //; // are restriceted to this character set: [_a-zA-Z0-9] //; // therefore, you won't be able to complete thi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TTabCom.cxx:672,perform,performs,672,core/rint/src/TTabCom.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TTabCom.cxx,1,['perform'],['performs']
Performance,"// @(#)root/roostats:$Id$; // Author: Kyle Cranmer 28/07/2008; /*************************************************************************; * Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; /** \class RooStats::NumberCountingPdfFactory; \ingroup Roostats. A factory for building PDFs and data for a number counting combination.; The factory produces a PDF for N channels with uncorrelated background; uncertainty. Correlations can be added by extending this PDF with additional terms.; The factory relates the signal in each channel to a master signal strength times the; expected signal in each channel. Thus, the final test is performed on the master signal strength.; This yields a more powerful test than letting signal in each channel be independent. The problem has been studied in these references:. - http://arxiv.org/abs/physics/0511028; - http://arxiv.org/abs/physics/0702156; - http://cdsweb.cern.ch/record/1099969?ln=en. One can incorporate uncertainty on the expected signal by adding additional terms.; For the future, perhaps this factory should be extended to include the efficiency terms automatically. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/NumberCountingPdfFactory.cxx:942,perform,performed,942,roofit/roostats/src/NumberCountingPdfFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/NumberCountingPdfFactory.cxx,1,['perform'],['performed']
Performance,"// @(#)root/roostats:$Id$; // Author: Kyle Cranmer January 2009; /*************************************************************************; * Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class RooStats::NeymanConstruction; \ingroup Roostats. NeymanConstruction is a concrete implementation of the NeymanConstruction; interface that, as the name suggests, performs a NeymanConstruction. It produces; a RooStats::PointSetInterval, which is a concrete implementation of the; ConfInterval interface. The Neyman Construction is not a uniquely defined statistical technique, it; requires that one specify an ordering rule or ordering principle, which is; usually incoded by choosing a specific test statistic and limits of integration; (corresponding to upper/lower/central limits). As a result, this class must be; configured with the corresponding information before it can produce an interval.; Common configurations, such as the Feldman-Cousins approach, can be enforced by; other light weight classes. The Neyman Construction considers every point in the parameter space; independently, no assumptions are made that the interval is connected or of a; particular shape. As a result, the PointSetInterval class is used to represent; the result. The user indicate which points in the parameter space to perform; the construction by providing a PointSetInterval instance with the desired points. This class is fairly light weight, because the choice of parameter points to be; considered is factorized and so is the creation of the sampling distribution of; the test statistic (which is done by a concrete class implementing the; DistributionCreator interface). As a result, this class basically just drives the; construction by:. - using a DistributionCreator to c",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/NeymanConstruction.cxx:596,perform,performs,596,roofit/roostats/src/NeymanConstruction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/NeymanConstruction.cxx,1,['perform'],['performs']
Performance,"// @(#)root/roostats:$Id$; // Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke; // Contributions: Giovanni Petrucciani and Annapaola Decosa; /*************************************************************************; * Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class RooStats::HypoTestInverter; \ingroup Roostats. A class for performing a hypothesis test inversion by scanning; the hypothesis test results of a HypoTestCalculator for various values of the; parameter of interest. By looking at the confidence level curve of the result, an; upper limit can be derived by computing the intersection of the confidence level curve with the desired confidence level.; The class implements the RooStats::IntervalCalculator interface, and returns a; RooStats::HypoTestInverterResult. The result is a SimpleInterval, which; via the method UpperLimit() returns to the user the upper limit value. ## Scanning options; The HypoTestInverter implements various options for performing the scan.; - HypoTestInverter::RunFixedScan will scan the parameter of interest using a fixed grid.; - HypoTestInverter::SetAutoScan will perform an automatic scan to find; optimally the curve. It will stop when the desired precision is obtained.; - HypoTestInverter::RunOnePoint computes the confidence level at a given point. ### CLs presciption; The class can scan the CLs+b values or alternatively CLs. For the latter,; call HypoTestInverter::UseCLs().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx:590,perform,performing,590,roofit/roostats/src/HypoTestInverter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx,3,['perform'],"['perform', 'performing']"
Performance,"// @(#)root/roostats:$Id$; // Author: Kyle Cranmer, Sven Kreiss 23/05/10; /*************************************************************************; * Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class RooStats::AsymptoticCalculator; \ingroup Roostats. Hypothesis Test Calculator based on the asymptotic formulae for the profile; likelihood ratio. It performs hypothesis tests using the asymptotic formula for the profile likelihood, and; uses the Asimov data set to compute expected significances or limits. See G. Cowan, K. Cranmer, E. Gross and O. Vitells: Asymptotic formulae for; likelihood- based tests of new physics. Eur. Phys. J., C71:1–19, 2011.; It provides methods to perform hypothesis tests using the likelihood function,; and computes the \f$p\f$-values for the null and the alternate hypothesis using the asymptotic; formulae for the profile likelihood ratio described in the given paper. The calculator provides methods to produce the Asimov dataset, *i.e.* a dataset; generated where the observed values are equal to the expected ones.; The Asimov data set is then used to compute the observed asymptotic \f$p\f$-value for; the alternate hypothesis and the asymptotic expected \f$p\f$-values. The asymptotic formulae are valid only for one POI (parameter of interest). So; the calculator works only for one-dimensional (one POI) models.; If more than one POI exists, only the first one is used. The calculator can generate Asimov datasets from two kinds of PDFs:; - ""Counting"" distributions: RooPoisson, RooGaussian, or products of RooPoissons.; - Extended, *i.e.* number of events can be read off from extended likelihood term.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx:592,perform,performs,592,roofit/roostats/src/AsymptoticCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx,2,['perform'],"['perform', 'performs']"
Performance,"// @(#)root/roostats:$Id$; // Author: Sven Kreiss June 2010; /*************************************************************************; * Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class RooStats::HypoTestPlot; \ingroup Roostats. This class provides the plots for the result of a study performed with any of the; HypoTestCalculatorGeneric (e.g. HybridCalculator or FrequentistCalculator) class. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestPlot.cxx:529,perform,performed,529,roofit/roostats/src/HypoTestPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestPlot.cxx,1,['perform'],['performed']
Performance,"// @(#)root/roostats:$Id$; // Authors: Kevin Belasco 17/06/2009; // Authors: Kyle Cranmer 17/06/2009; /*************************************************************************; * Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; /** \class RooStats::PdfProposal; \ingroup Roostats. PdfProposal is a concrete implementation of the ProposalFunction interface.; It proposes points across the parameter space in the distribution of the; given PDF. To make Propose(xPrime, x) dependent on x, configure with; PdfProposal::AddMapping(varToUpdate, valueToUse). For example, suppose we have:. ~~~{.cpp}; // our parameter; RooRealVar p(""p"", ""p"", 5, 0, 10);. // create mean and sigma for gaussian proposal function; RooRealVar meanP(""meanP"", ""meanP"", 0, 10);; RooRealVar sigma(""sigma"", ""sigma"", 1, 0, 5);; RooGaussian pGaussian(""pGaussian"", ""pGaussian"", p, meanP, sigma);. // configure proposal function; PdfProposal pdfProposal(pGaussian);; pdfProposal.AddMapping(meanP, p); // each call of Propose(xPrime, x), meanP in; // the proposal function will be updated to; // the value of p in x. this will center the; // proposal function about x's p when; // proposing for xPrime. // To improve performance, PdfProposal has the ability to cache a specified; // number of proposals. If you don't call this function, the default cache size; // is 1, which can be slow.; pdfProposal.SetCacheSize(desiredCacheSize);; ~~~. PdfProposal currently uses a fixed cache size. Adaptive caching methods are in the works; for future versions.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/PdfProposal.cxx:1493,perform,performance,1493,roofit/roostats/src/PdfProposal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/PdfProposal.cxx,4,"['cache', 'perform']","['cache', 'performance']"
Performance,"// @(#)root/test:$Id$; // Author: Lorenzo Moneta 06/2005; // Martin Storø Nyfløtt 05/2017; ///////////////////////////////////////////////////////////////////////////////////; //; // MathMore test suite; // ==============================; //; // This program performs tests :; // - numerical integration, derivation and root finders; // - it compares for various values of the gamma and beta distribution); // - the numerical calculated integral of pdf with cdf function,; // - the calculated derivative of cdf with pdf; // - the inverse (using root finder) of cdf with quantile; //; // to run the program outside ROOT do:; // > make stressMathMoreUnit; // > ctest -R gtest-math-mathmore-test-stressMathMoreUnit; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testStress.cxx:259,perform,performs,259,math/mathmore/test/testStress.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testStress.cxx,1,['perform'],['performs']
Performance,"// @(#)root/test:$Id$; // Author: Lorenzo Moneta 06/2005; ///////////////////////////////////////////////////////////////////////////////////; //; // MathCore Benchmark test suite; // ==============================; //; // This program performs tests :; // - mathematical functions in particular the statistical functions by estimating; // pdf, cdf and quantiles. cdf are estimated directly and compared with calculated integral from pdf; // - physics vectors (2D, 3D and 4D) including I/O for every type and for both double and Double32_t; // - SMatrix and SVectors including I/O for double and Double32_t types; // - I/O of complex objects which dictionary has been generated using CINT (default) or Reflex; // TrackD and TrackD32 which contain physics vectors of double and Double32_t; // TrackErrD and TrackErrD32 which contain physics vectors and an SMatrix of double and Double32_t; // VecTrackD which contains an std::vector<TrackD>; //; //; // the program cun run only in compiled mode.; // To run outside ROOT do:; //; // > cd $ROOTSYS/test; // > make stressMathMore; // > ./stressMathMore; //; // to run using REflex set before compiling the environment variable useReflex.; //; // > export useReflex=1; // > make stressMathMore; // > ./stressMathMore; //; // to run inside ROOT using ACliC; // for using CINT you need first to have the library libTrackMathCoreDict.so; // (type: make libTrackMathCoreDict.so to make it); //; // root> gSystem->Load(""libMathCore"");; // root> gSystem->Load(""libTree"");; // root> gSystem->Load(""libHist"");; // root> .x stressMathCore.cxx+; //; // for using Reflex dictionaries you need first to have the library libTrackMathCoreRflx.so; // (type: make libTrackMathCoreRflx.so to make it); //; // root> gSystem->Load(""libMathCore"");; // root> gSystem->Load(""libTree"");; // root> gSystem->Load(""libHist"");; // root> gSystem->Load(""libReflex"");; // root> gSystem->SetIncludePath(""-DUSE_REFLEX"");; // root> .x stressMathCore.cxx+; //; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressMathCore.cxx:236,perform,performs,236,test/stressMathCore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressMathCore.cxx,8,"['Load', 'perform']","['Load', 'performs']"
Performance,"// @(#)root/test:$Id$; // Author: Lorenzo Moneta 06/2005; ///////////////////////////////////////////////////////////////////////////////////; //; // MathCore Benchmark test suite; // ==============================; //; // This program performs tests of ROOT::Math 4D LorentzVectors comparing with TLorentzVector; // The time performing various vector operations on a collection of vectors is measured.; // The benchmarked operations are:; // - vector construction from 4 values; // - construction using a setter method; // - simple addition of all the vector pairs in the collection; // - calculation of deltaR = phi**2 + eta**2 of all vector pairs in the collection; // - two simple analysis:; // - the first requires some cut (on pt and eta) and on the invariant mass; // of the selected pairs; // - the second requires just some cut in pt, eta and delta R on all the; // vector pair; // - conversion between XYZTVectors to PtRhoEtaPhi based vectors; //; // The two analysis demonstrates, especially in the second case, the advantage of using; // vector based on cylindrical coordinate, given the fact that the time spent in the conversion is; // much less than the time spent in the analysis routine.; //; // To run the program do:; // stressVector : run standard test with collection of 1000 vectors; // stressVector 10000 : run with a collection of 10000 vectors; //; ///////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/test/stress2D.cxx:236,perform,performs,236,math/genvector/test/stress2D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/test/stress2D.cxx,2,['perform'],"['performing', 'performs']"
Performance,"// @(#)root/test:$Id$; // Author: Lorenzo Moneta 06/2005; ///////////////////////////////////////////////////////////////////////////////////; //; // MathCore Benchmark test suite; // ==============================; //; // This program performs tests of ROOT::Math 4D LorentzVectors comparing with TLorentzVector; // The time performing various vector operations on a collection of vectors is measured.; // The benchmarked operations are:; // - vector construction from 4 values; // - construction using a setter method; // - simple addition of all the vector pairs in the collection; // - calculation of deltaR = phi**2 + eta**2 of all vector pairs in the collection; // - two simple analysis:; // - the first requires some cut (on pt and eta) and on the invariant mass; // of the selected pairs; // - the second requires just some cut in pt, eta and delta R on all the; // vector pair; // - conversion between XYZTVectors to PtRhoEtaPhi based vectors; //; // The two analysis demostrates, especially in the second case, the advantage of using; // vector based on cylindrical coordinate, given the fact that the time spent in the conversion is; // much less than the time spent in the analysis routine.; //; // To run the program do:; // stressVector : run standard test with collection of 1000 vectors; // stressVector 10000 : run with a collection of 10000 vectors; //; ///////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressVector.cxx:236,perform,performs,236,test/stressVector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressVector.cxx,2,['perform'],"['performing', 'performs']"
Performance,"// @(#)root/test:$Id$; // Author: Lorenzo Moneta 06/2005; ///////////////////////////////////////////////////////////////////////////////////; //; // MathMore Benchmark test suite; // ==============================; //; // This program performs tests :; // - numerical integration, derivation and root finders; // - it compares for various values of the gamma and beta distribution); // - the numerical calculated integral of pdf with cdf function,; // - the calculated derivative of cdf with pdf; // - the inverse (using root finder) of cdf with quantile; //; // to run the program outside ROOT do:; // > make stressMathMore; // > ./stressMathMore; //; // to run the program in ROOT; // root> gSystem->Load(""libMathMore""); // root> .x stressMathMore.cxx+; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressMathMore.cxx:236,perform,performs,236,test/stressMathMore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressMathMore.cxx,2,"['Load', 'perform']","['Load', 'performs']"
Performance,"// @(#)root/test:$Id$; // Author: Valeriy Onuchin & Fons Rademakers 04/10/98; ///////////////////////////////////////////////////////////////////; // Animated Text with cool wave effect.; //; // ROOT implementation of the hello world example borrowed; // from the Qt hello world example.; //; // To run this example do the following:; // $ root; // root [0] gSystem.Load(""Hello""); // root [1] Hello h; // <enjoy>; // root [2] .q; //; // Other ROOT fun examples: Tetris, Aclock ...; //; // Begin_Html; // <img src=""http://emcal06.rhic.bnl.gov/~onuchin/root/gif/hello_clock.gif"">; // End_Html; //; ///////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/Hello.cxx:366,Load,Load,366,test/Hello.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/Hello.cxx,1,['Load'],['Load']
Performance,"// @(#)root/test:$Id$; // Author: Valeriy Onuchin & Fons Rademakers 04/10/98; ///////////////////////////////////////////////////////////////////; // ROOT implementation of the X11 xclock.; //; // To run this example do the following:; //; // $ root; // root [0] gSystem->Load(""libGpad""); // root [1] gSystem->Load(""Aclock""); // root [1] Aclock a; // <enjoy>; // root [2] .q; //; // Other ROOT fun examples: Tetris, Hello ...; //; ///////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/Aclock.cxx:272,Load,Load,272,test/Aclock.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/Aclock.cxx,2,['Load'],['Load']
Performance,"// @(#)root/test:$Id$; // Author: Valeriy Onuchin & Fons Rademakers 04/10/98; ///////////////////////////////////////////////////////////////////; // ROOT implementation of the simple Tetris game; // Layout and some hints were taken from Qt /examples/tetris; //; // To run this game do the following:; // $ root; // root [0] gSystem.Load(""libGpad""); // root [1] gSystem.Load(""Tetris""); // root [2] Tetris t; // <play game>; // root [2] .q; //; ///////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.cxx:333,Load,Load,333,test/Tetris.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.cxx,2,['Load'],['Load']
Performance,"// @(#)root/test:$name: $:$id: stressFit.cxx,v 1.15 2002/10/25 10:47:51 rdm exp $; // Authors: Rene Brun, Eddy Offermann April 2006; //*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*//; // //; // Function Minimization Examples, Fred James //; // //; // from the //; // Proceedings of the 1972 CERN Computing and Data Processing School //; // Pertisau, Austria, 10-24 September, 1972 (CERN 72-21) //; // //; // Here a collection of test problems is assembled which were found to be //; // useful in verifying and comparing minimization routines. Many of these //; // are standard functions upon which it has become conventional to try all //; // new methods, quoting the performance in the publication of the algorithm //; // //; // Each test will produce one line (Test OK or Test FAILED) . At the end of //; // the test a table is printed showing the global results Real Time and //; // Cpu Time. One single number (ROOTMARKS) is also calculated showing the //; // relative performance of your machine compared to a reference machine //; // a Pentium IV 2.4 Ghz) with 512 MBytes of memory and 120 GBytes IDE disk. //; // //; // In the main routine the fitter can be chosen through TVirtualFitter : //; // - Minuit //; // - Minuit2 //; // - Fumili //; //; // To run the test, do, eg; // root -b -q stressFit.cxx; // root -b -q ""stressFit.cxx(\""Minuit2\"")""; // root -b -q ""stressFit.cxx+(\""Minuit2\"")""; // //; // The verbosity can be set through the global parameter gVerbose : //; // -1: off 1: on //; // The tolerance on the parameter deviation from the minimum can be set //; // through gAbsTolerance . //; // //; // An example of output when all the tests run OK is shown below: //; // ******************************************************************* //; // * Minimization - S T R E S S suite * //; // ******************************************************************* //; // ******************************************************************* //; // * Starting S T ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressFit.cxx:698,perform,performance,698,test/stressFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressFit.cxx,1,['perform'],['performance']
Performance,"// @(#)root/test:$name: $:$id: stressHistoFit.cxx,v 1.15 2002/10/25 10:47:51 rdm exp $; // Authors: David Gonzalez Maline November 2008; //*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*//; // //; // //; // Set of tests for different minimization algorithms and for //; // different objects. The tests are divided into three types: //; // //; // 1. 1D and 2D Objects, including 1D and 2D histograms, 1D and 2D //; // histograms with variable bins, TGraph, TGraphErrors, TGraph2D, //; // TGraph2DErrors //; // 2. Same as before, but trying linear fitters. //; // 3. Unbinned fits with trees of different dimensions. //; // //; // Each test will performed fits with different functions and //; // different minimization algorithms selected. There is an error //; // tolerance for each one of them. There is also the possibility to //; // inspect each one of the test individually changing the //; // defaultOptions variable. //; // //; // //; // An example of output when all the tests run OK is shown below: //; // ****************************************************************************; // * Starting stress H I S T O F I T *; // ****************************************************************************; // Test 1D and 2D objects; // Test 1: 'Histogram 1D Variable' with 'GAUS'...................OK; // Test 2: 'Histogram 1D' with 'GAUS'............................OK; // Test 3: 'TGraph 1D' with 'GAUS'...............................OK; // Test 4: 'TGraphErrors 1D' with 'GAUS'.........................OK; // Test 5: 'THnSparse 1D' with 'GAUS'............................OK; // Test 6: 'Histogram 1D Variable' with 'Polynomial'.............OK; // Test 7: 'Histogram 1D' with 'Polynomial'......................OK; // Test 8: 'TGraph 1D' with 'Polynomial'.........................OK; // Test 9: 'TGraphErrors 1D' with 'Polynomial'...................OK; // Test 10: 'THnSparse 1D' with 'Polynomial'......................OK; // Test 11: 'Histogram 2D Variable' wi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx:676,perform,performed,676,test/stressHistoFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx,1,['perform'],['performed']
Performance,"// @(#)root/thread:$Id$; /*; * Copyright (c) 2006-2011 High Performance Computing Center Stuttgart,; * University of Stuttgart. All rights reserved.; * Author: Rainer Keller, HLRS; * Modified: Fons Rademakers, CERN; * Modified: Philippe Canal, FNAL; *; * Thread-local storage (TLS) is not supported on all environments.; * This header file and test-program shows how to abstract away, using either; * __thread,; * __declspec(thread),; * thread_local or; * Pthread-Keys; * depending on the (configure-set) CPP-variables R__HAS___THREAD,; * R__HAS_DECLSPEC_THREAD or R__HAS_PTHREAD.; *; * Use the macros TTHREAD_TLS_DECLARE, TTHREAD_TLS_INIT, and the; * getters and setters TTHREAD_TLS_GET and TTHREAD_TLS_GET; * to work on the declared variables.; *; * In case of PThread keys, we need to resolve to using keys!; * In order to do so, we need to declare and access; * TLS variables through three macros:; * - TTHREAD_TLS_DECLARE; * - TTHREAD_TLS_INIT; * - TTHREAD_TLS_SET and; * - TTHREAD_TLS_GET; * We do depend on the following (GCC-)extension:; * - In case of function-local static functions,; * we declare a sub-function to create a specific key.; * Unfortunately, we do NOT use the following extensions:; * - Using typeof, we could get rid of the type-declaration; * which is used for casting, however typeof is not ANSI C.; * - We do NOT allow something like; * func (a, TTHREAD_TLS_SET(int, my_var, 5));; * as we do not use the gcc-extension of returning macro-values.; *; * C++11 requires the implementation of the thread_local storage.; *; * For simple type use:; * TTHREAD_TLS(int) varname;; *; * For array of simple type use:; * TTHREAD_TLS_ARRAY(int, arraysize, varname);; *; * For object use:; * TTHREAD_TLS_DECL(classname, varname);; * TTHREAD_TLS_DECL_ARG(classname, varname, arg);; * TTHREAD_TLS_DECL_ARG2(classname, varname, arg1, arg2);; *; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ThreadLocalStorage.h:60,Perform,Performance,60,core/foundation/inc/ThreadLocalStorage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ThreadLocalStorage.h,1,['Perform'],['Performance']
Performance,"// @(#)root/thread:$Id$; // // Author: Enric Tejedor Saavedra 03/12/15; //; /*************************************************************************; * Copyright (C) 1995-2015, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////////; // //; // TImplicitMT //; // //; // This file implements the methods to enable, disable and check the //; // status of the global implicit multi-threading in ROOT. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TImplicitMT.cxx:649,multi-thread,multi-threading,649,core/imt/src/TImplicitMT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TImplicitMT.cxx,1,['multi-thread'],['multi-threading']
Performance,"// @(#)root/tmva $Id$; // Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss,Or Cohen, Jan Therhaag, Eckhard von Toerne; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : MethodCompositeBase *; * *; * *; * Description: *; * Virtual base class for all MVA method *; * *; * Authors (alphabetical): *; * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; * Peter Speckmayer <Peter.Speckmazer@cern.ch> - CERN, Switzerland *; * Joerg Stelzer <Joerg.Stelzer@cern.ch> - CERN, Switzerland *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * Jan Therhaag <Jan.Therhaag@cern.ch> - U of Bonn, Germany *; * Eckhard v. Toerne <evt@uni-bonn.de> - U of Bonn, Germany *; * *; * Copyright (c) 2005-2011: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; /*! \class TMVA::MethodBoost; \ingroup TMVA. Class for boosting a TMVA method. This class is meant to boost a single classifier. Boosting means; training the classifier a few times. Every time the weights of the; events are modified according to how well the classifier performed; on the test sample. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBoost.cxx:1514,perform,performed,1514,tmva/tmva/src/MethodBoost.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBoost.cxx,1,['perform'],['performed']
Performance,"// @(#)root/tmva $Id$; // Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss,Or Cohen; /*****************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : MethodCompositeBase *; * *; * *; * Description: *; * Virtual base class for all MVA method *; * *; * Authors (alphabetical): *; * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; * Joerg Stelzer <Joerg.Stelzer@cern.ch> - MSU, USA *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; * Or Cohen <orcohenor@gmail.com> - Weizmann Inst., Israel *; * *; * Copyright (c) 2005: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * LAPP, Annecy, France *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; *****************************************************************************/; /*! \class TMVA::MethodCompositeBase; \ingroup TMVA. Virtual base class for combining several TMVA method. This class is virtual class meant to combine more than one classifier; together. The training of the classifiers is done by classes that are; derived from this one, while the saving and loading of weights file; and the evaluation is done here.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCompositeBase.cxx:1406,load,loading,1406,tmva/tmva/src/MethodCompositeBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCompositeBase.cxx,1,['load'],['loading']
Performance,"// @(#)root/tmva $Id$; // Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate Data analysis *; * Package: TMVA *; * Class : TMVA::MethodPlugins *; * *; * *; * Description: *; * Implementation (see header for description) *; * *; * Authors (alphabetical): *; * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; * Joerg Stelzer <stelzer@cern.ch> - DESY, Germany *; * Peter Speckmayer <peter.speckmayer@cern.ch> - CERN, Switzerland *; * Jan Therhaag <Jan.Therhaag@cern.ch> - U of Bonn, Germany *; * Eckhard v. Toerne <evt@uni-bonn.de> - U of Bonn, Germany *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * Daniel Martscheit <martschei@ekp.uni-karlsruhe.de> -KIT Karlsruhe, Ger. *; * *; * Copyright (c) 2005-2011: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; /*! \class TMVA::CreateMethodPlugins; \ingroup TMVA. Plugins analysis. The MethodPlugins is actually not a real method, but it is just a wrapper to call; the TPluginsManager of ROOT and find a external method which can be used to extend; TMVA by another classifier. The only methods which are actually really implemented; are the constructors which fulfill the plugins handling. The others will produce; FATAL warnings and stop TMVA execution. Right after the constructor, the additional method 'getPlugedinMethod()' is called,; which returns the method loaded by the plugin manager, and the MethodPlugins object; is already deleted. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPlugins.cxx:1828,load,loaded,1828,tmva/tmva/src/MethodPlugins.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPlugins.cxx,1,['load'],['loaded']
Performance,"// @(#)root/tmva $Id$; // Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : RegressionVariance *; * *; * *; * Description: Calculate the separation criteria used in regression *; * *; * There are two things: the Separation Index, and the Separation Gain *; * Separation Index: *; * Measure of the ""Variance"" of a sample. *; * *; * Separation Gain: *; * the measure of how the quality of separation of the sample increases *; * by splitting the sample e.g. into a ""left-node"" and a ""right-node"" *; * (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right) *; * this is then the quality criteria which is optimized for when trying *; * to increase the information in the system (making the best selection *; * *; * *; * Authors (alphabetical): *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * *; * Copyright (c) 2005: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * Heidelberg U., Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RegressionVariance.h:820,optimiz,optimized,820,tmva/tmva/inc/TMVA/RegressionVariance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RegressionVariance.h,1,['optimiz'],['optimized']
Performance,"// @(#)root/tmva $Id$; // Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : SeparationBase *; * *; * *; * Description: An interface to different separation criteria used in various *; * training algorithms, as there are: *; * Gini-Index, Cross Entropy, Misclassification Error, e.t.c. *; * *; * There are two things: the Separation Index, and the Separation Gain *; * Separation Index: *; * Measure of the ""purity"" of a sample. If all elements (events) in the *; * sample belong to the same class (e.g. signal or backgr), than the *; * separation index is 0 (meaning 100% purity (or 0% purity as it is *; * symmetric. The index becomes maximal, for perfectly mixed samples *; * eg. purity=50% , N_signal = N_bkg *; * *; * Separation Gain: *; * the measure of how the quality of separation of the sample increases *; * by splitting the sample e.g. into a ""left-node"" and a ""right-node"" *; * (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right) *; * this is then the quality criterion which is optimized for when trying *; * to increase the information in the system (making the best selection *; * *; * *; * Authors (alphabetical): *; * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; * *; * Copyright (c) 2005: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * Heidelberg U., Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/SeparationBase.h:1212,optimiz,optimized,1212,tmva/tmva/inc/TMVA/SeparationBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/SeparationBase.h,1,['optimiz'],['optimized']
Performance,"// @(#)root/tmva $Id$; // Author: Andreas Hoecker, Joerg Stelzer, Helge Voss; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : RegressionVariance *; * *; * *; * Description: Calculate the separation criteria used in regression *; * *; * There are two things: the Separation Index, and the Separation Gain *; * Separation Index: *; * Measure of the ""Variance"" of a sample. *; * *; * Separation Gain: *; * the measure of how the quality of separation of the sample increases *; * by splitting the sample e.g. into a ""left-node"" and a ""right-node"" *; * (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right) *; * this is then the quality criteria which is optimized for when trying *; * to increase the information in the system (making the best selection *; * *; * *; * Authors (alphabetical): *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * *; * Copyright (c) 2005: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * Heidelberg U., Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RegressionVariance.cxx:810,optimiz,optimized,810,tmva/tmva/src/RegressionVariance.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RegressionVariance.cxx,1,['optimiz'],['optimized']
Performance,"// @(#)root/tmva $Id$; // Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag, Omar Zapata, Lorenzo Moneta, Sergei Gleyzer; //NOTE: Based on TMVA::Factory; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : DataLoader *; * *; * *; * Description: *; * This is a class to load datasets into every booked method *; * *; * Authors (alphabetical): *; * Lorenzo Moneta <Lorenzo.Moneta@cern.ch> - CERN, Switzerland *; * Omar Zapata <andresete.chaos@gmail.com> - ITM/UdeA, Colombia *; * Sergei Gleyzer<sergei.gleyzer@cern.ch> - CERN, Switzerland *; * *; * Copyright (c) 2005-2011: *; * CERN, Switzerland *; * ITM/UdeA, Colombia *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DataLoader.h:472,load,load,472,tmva/tmva/inc/TMVA/DataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DataLoader.h,1,['load'],['load']
Performance,"// @(#)root/tmva $Id$; // Author: Omar Zapata; // Mentors: Lorenzo Moneta, Sergei Gleyzer; //NOTE: Based on TMVA::Factory; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : DataLoader *; * *; * *; * Description: *; * This is a class to load datasets into every booked method *; * *; * Authors (alphabetical): *; * Lorenzo Moneta <Lorenzo.Moneta@cern.ch> - CERN, Switzerland *; * Omar Zapata <Omar.Zapata@cern.ch> - ITM/UdeA, Colombia *; * Sergei Gleyzer<sergei.gleyzer@cern.ch> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * ITM/UdeA, Colombia *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; /*! \class TMVA::DataLoader; \ingroup TMVA. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DataLoader.cxx:378,load,load,378,tmva/tmva/src/DataLoader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DataLoader.cxx,1,['load'],['load']
Performance,"// @(#)root/tmva $Id$; // Author: Simon Pfreundschuh; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////; // Concrete instantiation of the generic activation function test //; // for the multi-threaded CPU implementation. //; //////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestActivationFunctionsCpu.cxx:548,multi-thread,multi-threaded,548,tmva/tmva/test/DNN/TestActivationFunctionsCpu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestActivationFunctionsCpu.cxx,1,['multi-thread'],['multi-threaded']
Performance,"// @(#)root/tmva $Id$; // Author: Simon Pfreundschuh; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Concrete instantiation of the generic backpropagation test for //; // multi-threaded CPU architectures. //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagationCpu.cxx:538,multi-thread,multi-threaded,538,tmva/tmva/test/DNN/TestBackpropagationCpu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagationCpu.cxx,2,['multi-thread'],['multi-threaded']
Performance,"// @(#)root/tmva $Id$; // Author: Simon Pfreundschuh; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ///////////////////////////////////////////////////////////////////; // Concrete instantiation of the generic derivative test for the //; // multi-threaded CPU implementation. //; ///////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestDerivativesCpu.cxx:536,multi-thread,multi-threaded,536,tmva/tmva/test/DNN/TestDerivativesCpu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestDerivativesCpu.cxx,1,['multi-thread'],['multi-threaded']
Performance,"// @(#)root/tmva $Id$; // Author: Simon Pfreundschuh; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////; // Test for the loss function implementatoins for the //; // multi-threaded CPU version using the generic test defined in //; // TestLossFunctions.h. //; //////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestLossFunctionsCpu.cxx:524,multi-thread,multi-threaded,524,tmva/tmva/test/DNN/TestLossFunctionsCpu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestLossFunctionsCpu.cxx,1,['multi-thread'],['multi-threaded']
Performance,"// @(#)root/tmva $Id$; // Author: Simon Pfreundschuh; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /////////////////////////////////////////////////////////////////////; // Train the multi-threaded CPU implementation of DNNs on a random //; // linear mapping. In the linear case the minimization problem is //; // convex and the gradient descent training should converge to the //; // global minimum. //; /////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMinimizationCpu.cxx:477,multi-thread,multi-threaded,477,tmva/tmva/test/DNN/TestMinimizationCpu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMinimizationCpu.cxx,1,['multi-thread'],['multi-threaded']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Ravi Kiran S; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing MethodDL with DNN for Adadelta optimizer ( CPU backend ) *; * *; * Authors (alphabetical): *; * Ravi Kiran S <sravikiran0606@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2018: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLAdadeltaOptimizationCpu.cxx:321,optimiz,optimizer,321,tmva/tmva/test/DNN/TestMethodDLAdadeltaOptimizationCpu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLAdadeltaOptimizationCpu.cxx,1,['optimiz'],['optimizer']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Ravi Kiran S; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing MethodDL with DNN for Adagrad optimizer ( CPU backend ) *; * *; * Authors (alphabetical): *; * Ravi Kiran S <sravikiran0606@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2018: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLAdagradOptimizationCpu.cxx:320,optimiz,optimizer,320,tmva/tmva/test/DNN/TestMethodDLAdagradOptimizationCpu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLAdagradOptimizationCpu.cxx,1,['optimiz'],['optimizer']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Ravi Kiran S; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing MethodDL with DNN for Adam optimizer ( CPU backend ) *; * *; * Authors (alphabetical): *; * Ravi Kiran S <sravikiran0606@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2018: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLAdamOptimizationCpu.cxx:317,optimiz,optimizer,317,tmva/tmva/test/DNN/TestMethodDLAdamOptimizationCpu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLAdamOptimizationCpu.cxx,1,['optimiz'],['optimizer']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Ravi Kiran S; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing MethodDL with DNN for RMSProp optimizer ( CPU backend ) *; * *; * Authors (alphabetical): *; * Ravi Kiran S <sravikiran0606@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2018: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLRMSPropOptimizationCpu.cxx:320,optimiz,optimizer,320,tmva/tmva/test/DNN/TestMethodDLRMSPropOptimizationCpu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLRMSPropOptimizationCpu.cxx,1,['optimiz'],['optimizer']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Ravi Kiran S; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Various Optimizers for training DeepNet *; * *; * Authors (alphabetical): *; * Ravi Kiran S <sravikiran0606@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2018: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestOptimization.h:298,Optimiz,Optimizers,298,tmva/tmva/test/DNN/TestOptimization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestOptimization.h,1,['Optimiz'],['Optimizers']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Ravi Kiran S; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing various optimizers for Cpu Backend *; * *; * Authors (alphabetical): *; * Ravi Kiran S <sravikiran0606@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2018: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestOptimizationCpu.cxx:298,optimiz,optimizers,298,tmva/tmva/test/DNN/TestOptimizationCpu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestOptimizationCpu.cxx,3,['optimiz'],['optimizers']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Ravi Kiran S; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : TAdadelta *; * *; * *; * Description: *; * Adadelta Optimizer Class *; * *; * Authors (alphabetical): *; * Ravi Kiran S <sravikiran0606@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2018: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adadelta.h:301,Optimiz,Optimizer,301,tmva/tmva/inc/TMVA/DNN/Adadelta.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adadelta.h,1,['Optimiz'],['Optimizer']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Ravi Kiran S; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : TAdagrad *; * *; * *; * Description: *; * Adagrad Optimizer Class *; * *; * Authors (alphabetical): *; * Ravi Kiran S <sravikiran0606@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2018: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adagrad.h:299,Optimiz,Optimizer,299,tmva/tmva/inc/TMVA/DNN/Adagrad.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adagrad.h,1,['Optimiz'],['Optimizer']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Ravi Kiran S; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : TAdam *; * *; * *; * Description: *; * Adam Optimizer Class *; * *; * Authors (alphabetical): *; * Ravi Kiran S <sravikiran0606@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2018: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adam.h:293,Optimiz,Optimizer,293,tmva/tmva/inc/TMVA/DNN/Adam.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adam.h,1,['Optimiz'],['Optimizer']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Ravi Kiran S; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : TRMSProp *; * *; * *; * Description: *; * RMSProp Optimizer Class *; * *; * Authors (alphabetical): *; * Ravi Kiran S <sravikiran0606@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2018: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RMSProp.h:299,Optimiz,Optimizer,299,tmva/tmva/inc/TMVA/DNN/RMSProp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RMSProp.h,1,['Optimiz'],['Optimizer']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Ravi Kiran S; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : TSGD *; * *; * *; * Description: *; * Stochastic Batch Gradient Descent Optimizer Class *; * *; * Authors (alphabetical): *; * Ravi Kiran S <sravikiran0606@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2018: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/SGD.h:321,Optimiz,Optimizer,321,tmva/tmva/inc/TMVA/DNN/SGD.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/SGD.h,1,['Optimiz'],['Optimizer']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Ravi Kiran S; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : VOptimizer *; * *; * *; * Description: *; * General Optimizer Class *; * *; * Authors (alphabetical): *; * Ravi Kiran S <sravikiran0606@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2018 : *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Optimizer.h:301,Optimiz,Optimizer,301,tmva/tmva/inc/TMVA/DNN/Optimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Optimizer.h,1,['Optimiz'],['Optimizer']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Simon Pfreundschuh 05/07/16; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////; // Definition of the TCpu architecture, which provides a //; // multi-threaded CPU implementation of the low-level interface //; // networks for Cpus using BLAS and Roots TThreadExecutor //; //////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu.h:545,multi-thread,multi-threaded,545,tmva/tmva/inc/TMVA/DNN/Architectures/Cpu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu.h,1,['multi-thread'],['multi-threaded']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Simon Pfreundschuh 06/06/17; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /////////////////////////////////////////////////////////////////////; // Partial specialization of the TDataLoader class to adapt it to //; // the TMatrix class. Also the data transfer is kept simple, since //; // this implementation (being intended as reference and fallback //; // is not optimized for performance. //; /////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference/DataLoader.h:704,optimiz,optimized,704,tmva/tmva/inc/TMVA/DNN/Architectures/Reference/DataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference/DataLoader.h,2,"['optimiz', 'perform']","['optimized', 'performance']"
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Simon Pfreundschuh 08/08/16; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /////////////////////////////////////////////////////////////////////; // Generic data loader for neural network input data. Provides a //; // high level abstraction for the transfer of training data to the //; // device. //; /////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DataLoader.h:500,load,loader,500,tmva/tmva/inc/TMVA/DNN/DataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DataLoader.h,1,['load'],['loader']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Simon Pfreundschuh 08/08/16; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ///////////////////////////////////////////////////////////////; // Test the generic data loader for the CUDA implementation. //; ///////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestDataLoaderCuda.cxx:503,load,loader,503,tmva/tmva/test/DNN/TestDataLoaderCuda.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestDataLoaderCuda.cxx,2,['load'],['loader']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Simon Pfreundschuh 12/07/16; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////; // Test the reference data loader implementation. //; ////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestDataLoader.cxx:494,load,loader,494,tmva/tmva/test/DNN/TestDataLoader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestDataLoader.cxx,2,['load'],['loader']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Simon Pfreundschuh 12/08/16; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /////////////////////////////////////////////////////////////; // CPU Buffer interface class for the generic data loader. //; /////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuBuffer.h:527,load,loader,527,tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuBuffer.h,2,['load'],['loader']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Simon Pfreundschuh 19/07/16; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ///////////////////////////////////////////////////////////////////; // Implementation of the activation functions for multi-threaded //; // CPU architectures using Roots TThreadExecutor and BLAS. //; ///////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/ActivationFunctions.hxx:532,multi-thread,multi-threaded,532,tmva/tmva/src/DNN/Architectures/Cpu/ActivationFunctions.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/ActivationFunctions.hxx,1,['multi-thread'],['multi-threaded']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Simon Pfreundschuh 20/07/16; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /////////////////////////////////////////////////////////////////////; // Implementation of the loss functions for the multi-threaded CPU //; // implementation using Roots TThreadExecutor and BLAS. //; /////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/LossFunctions.hxx:532,multi-thread,multi-threaded,532,tmva/tmva/src/DNN/Architectures/Cpu/LossFunctions.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/LossFunctions.hxx,1,['multi-thread'],['multi-threaded']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Simon Pfreundschuh 20/07/16; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////; // Implementation of Helper arithmetic functions for the //; // multi-threaded CPU implementation of DNNs. //; ////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/Arithmetic.hxx:539,multi-thread,multi-threaded,539,tmva/tmva/src/DNN/Architectures/Cpu/Arithmetic.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/Arithmetic.hxx,1,['multi-thread'],['multi-threaded']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Simon Pfreundschuh 21/07/16; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ///////////////////////////////////////////////////////////////////////; // Implementation of the regularization functionals and gradients //; // for the multi-threaded CPU implementation using Roots TThreadExecutor. //; ///////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/Regularization.hxx:567,multi-thread,multi-threaded,567,tmva/tmva/src/DNN/Architectures/Cpu/Regularization.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/Regularization.hxx,1,['multi-thread'],['multi-threaded']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Simon Pfreundschuh 21/07/16; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////; // Implementation for the DataLoader for the multi-threaded //; // CPU implementation of DNNs. //; //////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/DataLoader.cxx:526,multi-thread,multi-threaded,526,tmva/tmva/src/DNN/Architectures/Cpu/DataLoader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/DataLoader.cxx,1,['multi-thread'],['multi-threaded']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Simon Pfreundschuh 21/07/16; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ///////////////////////////////////////////////////////////////; // Implementation of output functions for multi-threaded CPU //; // architectures. //; ///////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/OutputFunctions.hxx:520,multi-thread,multi-threaded,520,tmva/tmva/src/DNN/Architectures/Cpu/OutputFunctions.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/OutputFunctions.hxx,1,['multi-thread'],['multi-threaded']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Simon Pfreundschuh 21/07/16; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////; // Implementation of the DNN initialization methods for the //; // multi-threaded CPU backend. //; //////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/Initialization.hxx:544,multi-thread,multi-threaded,544,tmva/tmva/src/DNN/Architectures/Cpu/Initialization.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/Initialization.hxx,1,['multi-thread'],['multi-threaded']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Simon Pfreundschuh 21/07/16; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /////////////////////////////////////////////////////////////; // Test the multi-threaded CPU data loader implementation. //; /////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestDataLoaderCpu.cxx:488,multi-thread,multi-threaded,488,tmva/tmva/test/DNN/TestDataLoaderCpu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestDataLoaderCpu.cxx,4,"['load', 'multi-thread']","['loader', 'multi-threaded']"
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Vladimir Ilievski, Ravi Kiran S; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing MethodDL with DNN for SGD optimizer ( CPU backend ) *; * *; * Authors (alphabetical): *; * Ravi Kiran S <sravikiran0606@gmail.com> - CERN, Switzerland *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2018: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLSGDOptimizationCpu.cxx:335,optimiz,optimizer,335,tmva/tmva/test/DNN/TestMethodDLSGDOptimizationCpu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLSGDOptimizationCpu.cxx,1,['optimiz'],['optimizer']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Vladimir Ilievski, Ravi Kiran S; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing MethodDL with DNN for various optimizers *; * *; * Authors (alphabetical): *; * Ravi Kiran S <sravikiran0606@gmail.com> - CERN, Switzerland *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2018: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLOptimization.h:339,optimiz,optimizers,339,tmva/tmva/test/DNN/TestMethodDLOptimization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLOptimization.h,1,['optimiz'],['optimizers']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : TTensorDataLoader *; * *; * *; * Description: *; * Specialization of the Tensor Data Loader Class *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; //////////////////////////////////////////////////////////////////////////; // Partial specialization of the TTensorDataLoader class to adapt //; // it to the TMatrix class. Also the data transfer is kept simple, //; // since this implementation (being intended as reference and fallback) //; // is not optimized for performance. //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference/TensorDataLoader.h:339,Load,Loader,339,tmva/tmva/inc/TMVA/DNN/Architectures/Reference/TensorDataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference/TensorDataLoader.h,3,"['Load', 'optimiz', 'perform']","['Loader', 'optimized', 'performance']"
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : TTensorDataLoader *; * *; * *; * Description: *; * Specialization of the Tensor Data Loader Class *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ///////////////////////////////////////////////////////////////////; // Specializations of Copy functions for the TensorDataLoader //; // specialized for the reference architecture. //; ///////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Reference/TensorDataLoader.cxx:339,Load,Loader,339,tmva/tmva/src/DNN/Architectures/Reference/TensorDataLoader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Reference/TensorDataLoader.cxx,1,['Load'],['Loader']
Performance,"// @(#)root/tmva/tmva/dnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : TTensorDataLoader *; * *; * *; * Description: *; * Tensor Data Loader Class *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/TensorDataLoader.h:317,Load,Loader,317,tmva/tmva/inc/TMVA/DNN/TensorDataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/TensorDataLoader.h,1,['Load'],['Loader']
Performance,"// @(#)root/tree:$Id$; // Author Lukasz Janyst <ljanyst@cern.ch> 23/01/2008; /** \class TBranchSTL; \ingroup tree. A Branch handling STL collection of pointers (vectors, lists, queues,; sets and multisets) while storing them in split mode.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx:177,queue,queues,177,tree/tree/src/TBranchSTL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx,1,['queue'],['queues']
Performance,"// @(#)root/tree:$Id$; // Author: Anna Kreshuk 17/03/2007; /*************************************************************************; * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TEntryListFromFile; \ingroup tree. Manages entry lists from different files, when they are not loaded; in memory at the same time. This entry list should only be used when processing a TChain (see; TChain::SetEntryList() function). File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element.; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken.; It is assumed that there are as many lists, as there are chain elements,; and they are in the same order. If one of the list files can't be opened, or there is an error reading a list; from the file, this list is skipped and the entry loop continues on the next; list.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx:523,load,loaded,523,tree/tree/src/TEntryListFromFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx,1,['load'],['loaded']
Performance,"// @(#)root/tree:$Id$; // Author: Anna Kreshuk 27/10/2006; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TEntryListBlock; \ingroup tree. Used by TEntryList to store the entry numbers. There are 2 ways to represent entry numbers in a TEntryListBlock:. 1. as bits, where passing entry numbers are assigned 1, not passing - 0; 2. as a simple array of entry numbers; - storing the numbers of entries that pass; - storing the numbers of entries that don't pass. In both cases, a UShort_t* is used. The second option is better in case; less than 1/16 or more than 15/16 of entries pass the selection, and the representation can be; changed by calling OptimizeStorage() function.; When the block is being filled, it's always stored as bits, and the OptimizeStorage(); function is called by TEntryList when it starts filling the next block. If; Enter() or Remove() is called after OptimizeStorage(), representation is; again changed to 1). Begin_Macro; entrylistblock_figure1.C; End_Macro. ## Operations on blocks (see also function comments). - __Merge__() - adds all entries from one block to the other. If the first block; uses array representation, it's changed to bits representation only; if the total number of passing entries is still less than kBlockSize; - __GetEntry(n)__ - returns n-th non-zero entry.; - __Next__() - return next non-zero entry. In case of representation 1), Next(); is faster than GetEntry(); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx:968,Optimiz,OptimizeStorage,968,tree/tree/src/TEntryListBlock.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx,3,['Optimiz'],['OptimizeStorage']
Performance,"// @(#)root/tree:$Id$; // Author: Anna Kreshuk 27/10/2006; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////////; // TEntryListBlock; //; // Used internally in TEntryList to store the entry numbers.; //; // There are 2 ways to represent entry numbers in a TEntryListBlock:; // 1) as bits, where passing entry numbers are assigned 1, not passing - 0; // 2) as a simple array of entry numbers; // In both cases, a UShort_t* is used. The second option is better in case; // less than 1/16 of entries passes the selection, and the representation can be; // changed by calling OptimizeStorage() function.; // When the block is being filled, it's always stored as bits, and the OptimizeStorage(); // function is called by TEntryList when it starts filling the next block. If; // Enter() or Remove() is called after OptimizeStorage(), representation is; // again changed to 1).; //; // Operations on blocks (see also function comments):; // - Merge() - adds all entries from one block to the other. If the first block; // uses array representation, it's changed to bits representation only; // if the total number of passing entries is still less than kBlockSize; // - GetEntry(n) - returns n-th non-zero entry.; // - Next() - return next non-zero entry. In case of representation 1), Next(); // is faster than GetEntry(); //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListBlock.h:951,Optimiz,OptimizeStorage,951,tree/tree/inc/TEntryListBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListBlock.h,3,['Optimiz'],['OptimizeStorage']
Performance,"// @(#)root/tree:$Id$; // Author: Bruno Lenzi 12/07/2011; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TEntryListArray; \ingroup tree. A list of entries and subentries in a TTree or TChain. TEntryListArray is an extension of TEntryList, used to hold selected entries and; subentries (sublists) for when the user has a TTree with containers (vectors, arrays, ...). ## Usage with TTree::Draw to select entries and subentries. ### To fill a list elist; ~~~ {.cpp}; tree->Draw("">> elist"", ""x > 0"", ""entrylistarray"");`; ~~~; ### To use a list to select entries and subentries; ~~~ {.cpp}; tree->SetEntryList(elist);; tree->Draw(""y"");; tree->Draw(""z"");; ~~~; Its main purpose is to improve the performance of a code that needs to apply; complex cuts on TTree::Draw multiple times. After the first call above to; TTree::Draw, a TEntryListArray is created and filled with the entries and the; indices of the arrays that satisfied the selection cut (x > 0). In the subsequent; calls to TTree::Draw, only these entries / subentries are used to fill histograms. ## About the class. The class derives from TEntryList and can be used basically in the same way.; This same class is used to keep entries and subentries, so there are two types of; TEntryListArray's:. 1. The ones that only hold subentries; - fEntry is set to the entry# for which the subentries correspond; - fSubLists must be 0; 2. The ones that hold entries and eventually lists with subentries in fSubLists.; - fEntry = -1 for those; - If there are no sublists for a given entry, all the subentries will be used; in the selection. ## Additions with respect to TEntryList. 1. Data members:; - fSubLists: a container to hold",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListArray.cxx:1012,perform,performance,1012,tree/tree/src/TEntryListArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListArray.cxx,1,['perform'],['performance']
Performance,"// @(#)root/tree:$Id$; // Author: Rene Brun 04/06/2006; /*************************************************************************; * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TTreeCache; \ingroup tree; \brief A cache to speed-up the reading of ROOT datasets. # A cache to speed-up the reading of ROOT datasets. ## Table of Contents; - [Motivation](\ref motivation); - [General Description](\ref description); - [Changes in behaviour](\ref changesbehaviour); - [Self-optimization](\ref cachemisses); - [Examples of usage](\ref examples); - [Check performance and stats](\ref checkPerf). \anchor motivation; ## Motivation: why having a cache is needed?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of TTrees with several; hundred or thousand branches. When writing, this does not generate a performance problem because branch; buffers are always written sequentially and, thanks to OS optimisations,; content is flushed to the output file when a few MBytes of data are available.; On the other hand, when reading, one may hit performance problems because of; latencies e.g imposed by network.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second. The TreeCache tries to prefetch all the buffers for the selected branches; in order to transfer a few multi-Megabytes large buffers instead of many; multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to; be read in increasing order such that the fil",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:461,cache,cache,461,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,6,"['cache', 'optimiz', 'perform']","['cache', 'cachemisses', 'optimization', 'performance']"
Performance,"// @(#)root/tree:$Id$; // Author: Rene Brun 12/01/96; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**; \defgroup tree Tree Library. In order to store columnar datasets, ROOT provides the TTree, TChain,; TNtuple and TNtupleD classes.; The TTree class represents a columnar dataset. Any C++ type can be stored in the; columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; it is demonstrated to scale and it's battle tested. It has been optimized during the years; to reduce dataset sizes on disk and to deliver excellent runtime performance.; It allows to access only part of the columns of the datasets, too.; The TNtuple and TNtupleD classes are specialisations of the TTree class which can; only hold single precision and double precision floating-point numbers respectively;; The TChain is a collection of TTrees, which can be located also in different files. */; /** \class TTree; \ingroup tree. A TTree represents a columnar dataset. Any C++ type can be stored in its columns. A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; represented by the TBranch class.; Behind each branch, buffers are allocated automatically by ROOT.; Such buffers are automatically written to disk or kept in memory until the size stored in the; attribute fMaxVirtualSize is reached.; Variables of one branch are written to the same buffer. A branch buffer is; automatically compressed if the file compression attribute is set (default).; Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one object into; one single I/O buffer or to make ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:785,optimiz,optimized,785,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,2,"['optimiz', 'perform']","['optimized', 'performance']"
Performance,"// @(#)root/tree:$Id$; // Author: Rene Brun 19/08/2004; /*************************************************************************; * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TBranchRef; \ingroup tree. A branch containing and managing a TRefTable for TRef autoloading.; It loads the TBranch containing a referenced object when requested; by TRef::GetObject(), so the reference can be resolved. The; information which branch to load is stored by TRefTable. Once a; TBranch has read the TBranchRef's current entry it will not be told; to re-read, in case the use has changed objects read from the; branch. ### LIMITATION :; Note that this does NOT allow for autoloading of references spanning; different entries. The TBranchRef's current entry has to correspond; to the entry of the TBranch containing the referenced object. The TRef cannot be stored in a top-level branch which is a; TBranchObject for the auto-loading to work. E.g. you cannot store; the TRefs in TObjArray, and create a top-level branch storing this; TObjArray.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchRef.cxx:523,load,loads,523,tree/tree/src/TBranchRef.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchRef.cxx,3,['load'],"['load', 'loading', 'loads']"
Performance,"// @(#)root/treeplayer:$Id$; // Author: Philippe Canal 01/06/2004; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TFormLeafInfo; This class is a small helper class to implement reading a data member; on an object stored in a TTree. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; - TFormLeafInfo; - TFormLeafInfoDirect; - TFormLeafInfoNumerical; - TFormLeafInfoClones; - TFormLeafInfoCollection; - TFormLeafInfoPointer; - TFormLeafInfoMethod; - TFormLeafInfoMultiVarDim; - TFormLeafInfoMultiVarDimDirect; - TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. - AddOffset(Int_t offset, TStreamerElement* element); - GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; - GetObjectAddress(TLeafElement* leaf) : Returns the location of the object pointed to.; - GetMultiplicity() : Returns info on the variability of the number of elements; - GetNdata(TLeaf* leaf) : Returns the number of elements; - GetNdata() : Used by GetNdata(TLeaf* leaf); - GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; - GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; - GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; - IsString(); - ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; - Update() : react to the possible loading of a shared library.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx:1833,load,loading,1833,tree/treeplayer/src/TFormLeafInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx,1,['load'],['loading']
Performance,"// @(#)root/treeplayer:$Id$; // Author: Rene Brun 29/10/09; /*************************************************************************; * Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TTreePerfStats. TTree I/O performance measurement. see example of use below. The function FileReadEvent is called from TFile::ReadBuffer.; For each call the following information is stored in fGraphIO; - x[i] = Tree entry number; - y[i] = 1e-6*(file position); - ey[i] = 1e-9*number of bytes read; For each call the following information is stored in fGraphTime; - x[i] = Tree entry number; - y[i] = Time now; - ey[i] = readtime, eg timenow - start; The TTreePerfStats object can be saved in a ROOT file in such a way that; its inspection can be done outside the job that generated it. Example of use:; ~~~{.cpp}; {; TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; T = (TTree*)f->Get(""Events"");; Long64_t nentries = T->GetEntries();; T->SetCacheSize(10000000);; T->SetCacheEntryRange(0,nentries);; T->AddBranchToCache(""*"");; //; TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);; //; for (Int_t i=0;i<nentries;i++) {; T->GetEntry(i);; }; ps->SaveAs(""cmsperf.root"");; }; ~~~; then, in a root interactive session, one can do:; ~~~{.cpp}; root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();; ~~~; The Draw or Print functions print the following information:; - TreeCache = TTree cache size in MBytes; - N leaves = Number of leaves in the TTree; - ReadTotal = Total number of zipped bytes read; - ReadUnZip = Total number of unzipped bytes read; - ReadCalls = Total number of disk reads; - ReadSize = Average read size in KBytes; - Readahead = Readahead size in KBytes; - Readextra = Readahead overhead in percent; - Real Time = Real",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePerfStats.cxx:455,perform,performance,455,tree/treeplayer/src/TTreePerfStats.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePerfStats.cxx,1,['perform'],['performance']
Performance,"// @(#)root/x11ttf:$Id: 80028b538e60290371c1c5d73728f78b1c32f09a $; // Author: Valeriy Onuchin (Xft support) 02/10/07; // Author: Olivier Couet 01/10/02; // Author: Fons Rademakers 21/11/98; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TGX11TTF; \ingroup x11. Interface to low level X11 (Xlib). This class gives access to basic; X11 graphics via the parent class TGX11. However, all text and font; handling is done via the Freetype TrueType library. When the; shared library containing this class is loaded the global gVirtualX; is redirected to point to this class.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11ttf/src/TGX11TTF.cxx:824,load,loaded,824,graf2d/x11ttf/src/TGX11TTF.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11ttf/src/TGX11TTF.cxx,1,['load'],['loaded']
Performance,// @TODO: Map geometryId to index of the arrays because; // optimize() can make geometryId mismatch the index,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:60,optimiz,optimize,60,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['optimiz'],['optimize']
Performance,// @TODO: Map id to index of the arrays because; // optimize() can make id mismatch the index,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:52,optimiz,optimize,52,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['optimiz'],['optimize']
Performance,"// @TODO: SkinnedMesh support?; // @TODO: geometry.groups support?; // @TODO: geometry.drawRange support?; // @TODO: geometry.morphAttributes support?; // @TODO: Support uniform parameter per geometry; // @TODO: Add an ""optimize"" function to pack geometry and remove data gaps; // copies data from attribute ""src"" into ""target"" starting at ""targetOffset""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:220,optimiz,optimize,220,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['optimiz'],['optimize']
Performance,"// @llvm.masked.load.*(Ptr, alignment, Mask, Src0)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:16,load,load,16,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['load'],['load']
Performance,// @llvm.readcyclecounter requires the Performance Monitors extension.; // Default to the 0 expansion on unsupported platforms.; // FIXME: Technically there are older ARM CPUs that have; // implementation-specific ways of obtaining this information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:39,Perform,Performance,39,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['Performance']
Performance,"// A 32-bit (address + offset) should not cause unsigned 32-bit integer; // wraparound, because s_load instructions perform the addition in 64 bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUGlobalISelUtils.cpp:116,perform,perform,116,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUGlobalISelUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUGlobalISelUtils.cpp,2,['perform'],['perform']
Performance,// A 32-bit value where only one byte has a nonzero value. Exclude; // zero to match GCC. This constraint is used by GCC internally for; // constants that can be loaded with a move/shift combination.; // It is not useful otherwise but is implemented for compatibility.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:162,load,loaded,162,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['load'],['loaded']
Performance,"// A 64bit st2 which does not start at element 0 will involved adding extra; // ext elements making the st2 unprofitable, and if there is a nearby store; // that points to BaseAddr+16 or BaseAddr-16 then it can be better left as a; // zip;ldp pair which has higher throughput.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:265,throughput,throughput,265,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['throughput'],['throughput']
Performance,"// A BCE atom ""Binary Compare Expression Atom"" represents an integer load; // that is a constant offset from a base value, e.g. `a` or `o.c` in the example; // at the top.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:69,load,load,69,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,1,['load'],['load']
Performance,"// A BUILD_PAIR is always having the least significant part in elt 0 and the; // most significant part in elt 1. So when combining into one large load, we; // need to consider the endianness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:146,load,load,146,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,"// A CAS is effectively a atomic store and load combined under a; // predicate. From the perspective of base pointers, we just treat it; // like a load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:43,load,load,43,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,2,['load'],['load']
Performance,// A CSE config for fully optimized builds.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:26,optimiz,optimized,26,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,1,['optimiz'],['optimized']
Performance,"// A Chain is a set of instructions such that:; // - All instructions have the same equivalence class, so in particular all are; // loads, or all are stores.; // - We know the address accessed by the i'th chain elem relative to the; // chain's leader instruction, which is the first instr of the chain in BB; // order.; //; // Chains have two canonical orderings:; // - BB order, sorted by Instr->comesBefore.; // - Offset order, sorted by OffsetFromLeader.; // This pass switches back and forth between these orders.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:132,load,loads,132,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['load'],['loads']
Performance,// A CodeTemplate is a set of InstructionTemplates that may not be fully; // specified (i.e. some variables are not yet set). This allows the; // SnippetGenerator to instantiate it many times with specific values to study; // their impact on instruction's performance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h:256,perform,performance,256,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h,1,['perform'],['performance']
Performance,"// A DFS traversal of GEP chain trees starting from Root.; //; // Recursion descends through GEP instructions and; // llvm.preserve.static.offset calls. Recursion stops at any other; // instruction. If load or store instruction is reached it is replaced; // by a call to `llvm.bpf.getelementptr.and.load` or; // `llvm.bpf.getelementptr.and.store` intrinsic.; // If `llvm.bpf.getelementptr.and.load/store` is reached the accumulated; // GEPs are merged into the intrinsic call.; // If nested calls to `llvm.preserve.static.offset` are encountered these; // calls are marked for deletion.; //; // Parameters description:; // - Insn - current position in the tree; // - GEPs - GEP instructions for the current branch; // - Visited - a list of visited instructions in DFS order,; // order is important for unused instruction deletion.; // - AllowPartial - when true GEP chains that can't be folded are; // not reported, otherwise diagnostic message is show for such chains.; // - StillUsed - set to true if one of the GEP chains could not be; // folded, makes sense when AllowPartial is false, means that root; // preserve.static.offset call is still in use and should remain; // until the next run of this pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:202,load,load,202,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,3,['load'],['load']
Performance,"// A FileID is a (cached via ContentCache) SourceManager view of a; // FileManager::FileEntry (which is a wrapper on the file system file).; // In a subtle cases, code unloading can remove the cached region.; // However we are safe because it will empty the ContentCache and force; // the FileEntry to be re-read. It will keep the FileID intact and valid; // by design. When we reprocess the same (but modified) file it will get; // a new FileID. Then the Invalid flag will be false but the underlying; // buffer content will be empty. It will not compare equal to the lookup; // string and we will avoid using (a potentially broken) cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:18,cache,cached,18,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,3,['cache'],"['cache', 'cached']"
Performance,// A Load tagged with nonnull or dereferenceable with null pointer undefined; // is never null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:5,Load,Load,5,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['Load'],['Load']
Performance,"// A PHI node is allowed to have multiple (duplicated) entries for the same; // basic block, as long as the value is the same. So if we already injected; // a load in the predecessor, then we should reuse the same load for all; // duplicated entries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:159,load,load,159,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,2,['load'],['load']
Performance,"// A RUToken is created by the RCU for every instruction dispatched to the; // schedulers. These ""tokens"" are managed by the RCU in its token Queue.; //; // On every cycle ('cycleEvent'), the RCU iterates through the token queue; // looking for any token with its 'Executed' flag set. If a token has that; // flag set, then the instruction has reached the write-back stage and will; // be retired by the RCU.; //; // 'NumSlots' represents the number of entries consumed by the instruction in; // the reorder buffer. Those entries will become available again once the; // instruction is retired.; //; // Note that the size of the reorder buffer is defined by the scheduling; // model via field 'NumMicroOpBufferSize'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RetireControlUnit.h:142,Queue,Queue,142,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RetireControlUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RetireControlUnit.h,2,"['Queue', 'queue']","['Queue', 'queue']"
Performance,// A SUB can be used to perform comparison.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:24,perform,perform,24,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['perform'],['perform']
Performance,"// A SchedWrite may specify a number of cycles in which a resource group; // is reserved. For example (on target x86; cpu Haswell):; //; // SchedWriteRes<[HWPort0, HWPort1, HWPort01]> {; // let ReleaseAtCycles = [2, 2, 3];; // }; //; // This means:; // Resource units HWPort0 and HWPort1 are both used for 2cy.; // Resource group HWPort01 is the union of HWPort0 and HWPort1.; // Since this write touches both HWPort0 and HWPort1 for 2cy, HWPort01; // will not be usable for 2 entire cycles from instruction issue.; //; // On top of those 2cy, SchedWriteRes explicitly specifies an extra latency; // of 3 cycles for HWPort01. This tool assumes that the 3cy latency is an; // extra delay on top of the 2 cycles latency.; // During those extra cycles, HWPort01 is not usable by other instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp:588,latency,latency,588,interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,3,['latency'],['latency']
Performance,"// A T1 post-indexed load is just a single register LDM: LDM r0!, {r1}.; // The encoding of LDM is not how the rest of ISel expects a post-inc load to; // look however, so we use a pseudo here and switch it for a tLDMIA_UPD after; // ISel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:21,load,load,21,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,2,['load'],['load']
Performance,"// A Toy Monte Carlo study that perform cycles of event generation and; // fittting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:32,perform,perform,32,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['perform'],['perform']
Performance,// A address must be loaded from a small section if its size is less than the; // small section size threshold. Data in this section could be addressed by; // using gp_rel operator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp:21,load,loaded,21,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetObjectFile.cpp,1,['load'],['loaded']
Performance,// A address must be loaded from a small section if its size is less than the; // small section size threshold. Data in this section must be addressed using; // gp_rel operator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetObjectFile.cpp:21,load,loaded,21,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetObjectFile.cpp,2,['load'],['loaded']
Performance,"// A binary image could be unloaded and then reloaded at different; // place, so update binary load address.; // Only update for the first executable segment and assume all other; // segments are loaded at consecutive memory addresses, which is the case on; // X64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp:95,load,load,95,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,2,['load'],"['load', 'loaded']"
Performance,"// A binary intrusively linked into a LRU cache list. If the binary is empty,; // then the entry marks that an error occurred, and it is not part of the LRU; // list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h:42,cache,cache,42,interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,1,['cache'],['cache']
Performance,// A bit overloaded data structures. Visited contains constant/GV; // if we already met it. In this case CacheOfFreezes has a freeze if it is; // required.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:105,Cache,CacheOfFreezes,105,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,1,['Cache'],['CacheOfFreezes']
Performance,// A broadcast of a load can be cheaper on some targets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:20,load,load,20,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['load']
Performance,// A cache key only makes sense if memoization is possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:5,cache,cache,5,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,1,['cache'],['cache']
Performance,// A cache made available to the Filter to store SUnits for subsequent; // invocations of the Filter,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:5,cache,cache,5,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['cache'],['cache']
Performance,"// A cache of GCs for general use",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:5,cache,cache,5,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,1,['cache'],['cache']
Performance,// A cache of encodings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CodeEmitter.h:5,cache,cache,5,interpreter/llvm-project/llvm/include/llvm/MCA/CodeEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CodeEmitter.h,1,['cache'],['cache']
Performance,// A cache of existing trackers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/RegisterAliasing.h:5,cache,cache,5,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/RegisterAliasing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/RegisterAliasing.h,1,['cache'],['cache']
Performance,// A cache representing if we've fully checked the various comparison category; // types stored in ASTContext. The bit-index corresponds to the integer value; // of a ComparisonCategoryType enumerator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:5,cache,cache,5,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['cache'],['cache']
Performance,// A cached stat value would be fine as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:5,cache,cached,5,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,1,['cache'],['cached']
Performance,"// A call that doesNotAccessMemory is handled as a Scalar,; // onlyReadsMemory will be handled as a Load instruction,; // all other calls will be handled as stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:100,Load,Load,100,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['Load'],['Load']
Performance,"// A call to a readnone function whose arguments are all things computed; // outside this function can be marked tail. Even if you stored the; // alloca address into a global, a readnone function can't load the; // global anyhow.; //; // Note that this runs whether we know an alloca has escaped or not. If; // it has, then we can't trust Tracker.AllocaUsers to be accurate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:202,load,load,202,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,1,['load'],['load']
Performance,// A chain edge between a store and a load is treated as a back-edge in the; // adjacency matrix.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:38,load,load,38,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['load'],['load']
Performance,"// A class that performs reachability queries for CFGBlocks. Several internal; // checks in this checker require reachability information. The requests all; // tend to have a common destination, so we lazily do a predecessor search; // from the destination node and cache the results to prevent work; // duplication.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/CFGReachabilityAnalysis.h:16,perform,performs,16,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/CFGReachabilityAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/CFGReachabilityAnalysis.h,2,"['cache', 'perform']","['cache', 'performs']"
Performance,// A class to compute the name of a set of merged basic blocks.; // This is optimized for the common case of no block names.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:76,optimiz,optimized,76,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,1,['optimiz'],['optimized']
Performance,"// A class which is used to collect decl names starting from normalised; // names (typedef resolution is excluded here, just string manipulation; // is performed). At the heart of the implementation, an unordered set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TClass.h:152,perform,performed,152,core/meta/inc/TClass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TClass.h,1,['perform'],['performed']
Performance,"// A comparison between two BCE atoms, e.g. `a == o.a` in the example at the; // top.; // Note: the terminology is misleading: the comparison is symmetric, so there; // is no real {l/r}hs. What we want though is to have the same base on the; // left (resp. right), so that we can detect consecutive loads. To ensure this; // we put the smallest atom on the left.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:299,load,loads,299,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,1,['load'],['loads']
Performance,"// A conditional branch which exits the loop, which can be optimized to an; // unconditional branch in the unrolled loop in some cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:59,optimiz,optimized,59,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,1,['optimiz'],['optimized']
Performance,"// A constant GEP expression that has a GlobalVariable as base pointer is; // usually lowered to a load from constant pool. Such operation is unlikely; // to be cheaper than compute it by <Base + Offset>, which can be lowered to; // an ADD instruction or folded into Load/Store instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:99,load,load,99,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,2,"['Load', 'load']","['Load', 'load']"
Performance,"// A constant pool entry may be more aligned thant he load we're trying to; // replace. If we don't support unaligned scalar mem, prefer the constant; // pool.; // TODO: Can the caller pass down the alignment?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:54,load,load,54,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['load'],['load']
Performance,"// A constant undef variable can't be written to, and any load is; // undef, so it should be eliminated by the optimizer. It could be; // dropped by the back end if not. This pass skips over it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUMemoryUtils.cpp:58,load,load,58,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUMemoryUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUMemoryUtils.cpp,2,"['load', 'optimiz']","['load', 'optimizer']"
Performance,"// A critical sequence is computed as the longest path from a node of the; // RootSet to a leaf node (i.e. a node with no successors). The RootSet is; // composed of nodes with at least one successor, and no predecessors.; //; // Each node of the graph starts with an initial default cost of zero. The; // cost of a node is a measure of criticality: the higher the cost, the bigger; // is the performance impact.; // For register and memory dependencies, the cost is a function of the write; // latency as well as the actual delay (in cycles) caused to users.; // For processor resource dependencies, the cost is a function of the resource; // pressure. Resource interferences with low frequency values are ignored.; //; // This algorithm is very similar to a (reverse) Dijkstra. Every iteration of; // the inner loop selects (i.e. visits) a node N from a set of `unvisited; // nodes`, and then propagates the cost of N to all its neighbors.; //; // The `unvisited nodes` set initially contains all the nodes from the; // RootSet. A node N is added to the `unvisited nodes` if all its; // predecessors have been visited already.; //; // For simplicity, every node tracks the number of unvisited incoming edges in; // field `NumVisitedPredecessors`. When the value of that field drops to; // zero, then the corresponding node is added to a `ToVisit` set.; //; // At the end of every iteration of the outer loop, set `ToVisit` becomes our; // new `unvisited nodes` set.; //; // The algorithm terminates when the set of unvisited nodes (i.e. our RootSet); // is empty. This algorithm works under the assumption that the graph is; // acyclic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp:393,perform,performance,393,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp,2,"['latency', 'perform']","['latency', 'performance']"
Performance,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:34,bottleneck,bottleneck,34,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,5,"['bottleneck', 'latency', 'perform']","['bottleneck', 'latency', 'performance']"
Performance,"// A dependency-breaking instruction doesn't have to wait on the register; // input operands, and it is often optimized at register renaming stage.; // Update RAW dependencies if this instruction is not a dependency-breaking; // instruction. A dependency-breaking instruction is a zero-latency; // instruction that doesn't consume hardware resources.; // An example of dependency-breaking instruction on X86 is a zero-idiom XOR.; //; // We also don't update data dependencies for instructions that have been; // eliminated at register renaming stage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/DispatchStage.cpp:110,optimiz,optimized,110,interpreter/llvm-project/llvm/lib/MCA/Stages/DispatchStage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/DispatchStage.cpp,2,"['latency', 'optimiz']","['latency', 'optimized']"
Performance,// A deterministic alternative to SmallPtrSet with the same lookup; // performance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp:71,perform,performance,71,interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp,1,['perform'],['performance']
Performance,"// A dummy class to return nullptr instead of P2 when performing ""more; // specialized than primary"" check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:54,perform,performing,54,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['perform'],['performing']
Performance,"// A f32 load feeding into a v4f32 insert_vector_elt is handled in this way; // because on P10, it allows this specific insert_vector_elt load pattern to; // utilize the refactored load and store infrastructure in order to exploit; // prefixed loads.; // On targets with inexpensive direct moves (Power9 and up), a; // (insert_vector_elt v4f32:$vec, (f32 load)) is always better as an integer; // load since a single precision load will involve conversion to double; // precision on the load followed by another conversion to single precision.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:9,load,load,9,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,8,['load'],"['load', 'loads']"
Performance,// A fairly simplistic guess as to whether a potential load/store to a; // stack location could require an extra register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:55,load,load,55,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,1,['load'],['load']
Performance,"// A finally block is a statement which must be executed on any edge; // out of a given scope. Unlike a cleanup, the finally block may; // contain arbitrary control flow leading out of itself. In; // addition, finally blocks should always be executed, even if there; // are no catch handlers higher on the stack. Therefore, we; // surround the protected scope with a combination of a normal; // cleanup (to catch attempts to break out of the block via normal; // control flow) and an EH catch-all (semantically ""outside"" any try; // statement to which the finally block might have been attached).; // The finally block itself is generated in the context of a cleanup; // which conditionally leaves the catch-all.; // Jump destination for performing the finally block on an exception; // edge. We'll never actually reach this block, so unreachable is; // fine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:738,perform,performing,738,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,1,['perform'],['performing']
Performance,// A fixed length vector being extracted from a scalable vector; // may not be any *smaller* than the scalable one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,scalab,scalable,48,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['scalab'],['scalable']
Performance,"// A fixed point semantic fits in a floating point semantic if the maximum; // and minimum values as integers of the fixed point semantic can fit in the; // floating point semantic.; // If these values do not fit, then a floating point rescaling of the true; // maximum/minimum value will not fit either, so the floating point semantic; // cannot be used to perform such a rescaling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp:358,perform,perform,358,interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp,1,['perform'],['perform']
Performance,// A flat load may access private memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:10,load,load,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['load'],['load']
Performance,"// A frame index is never a dynamically controllable load, so only; // harden it if we're covering fixed address loads as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:53,load,load,53,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,2,['load'],"['load', 'loads']"
Performance,// A function call can be replicated by optimizations like callsite; // splitting or jump threading and the replicates end up sharing the; // sample nested callee profile instead of slicing the original; // inlinee's profile. We want to do merge exactly once by filtering out; // callee profiles with a non-zero head sample count.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:40,optimiz,optimizations,40,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['optimiz'],['optimizations']
Performance,"// A function cannot capture state in memory if it only reads memory, it can; // however return/throw state and the state might be influenced by the; // pointer value, e.g., loading from a returned pointer might reveal a bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:174,load,loading,174,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['load'],['loading']
Performance,// A gather/scatter of a splat is a zero strided load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:49,load,load,49,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,1,['load'],['load']
Performance,// A global symbol table for symbols from all loaded modules.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:46,load,loaded,46,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,1,['load'],['loaded']
Performance,// A has a store dependence on B (or on some load within GroupB) and; // is part of a store group. Release A's group to prevent illegal; // sinking of A below B. A will then be free to form another group; // with instructions that precede it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:45,load,load,45,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['load'],['load']
Performance,// A helper that returns true if the use of Ptr by MemAccess will be scalar.; // The pointer operands of loads and stores will be scalar as long as the; // memory access is not a gather or scatter operation. The value operand of a; // store will remain scalar if the store is scalarized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:105,load,loads,105,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['load'],['loads']
Performance,"// A is output , B is a cached index tensor used for backward pass and C is the input",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/Propagation.hxx:24,cache,cached,24,tmva/tmva/src/DNN/Architectures/Cpu/Propagation.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/Propagation.hxx,1,['cache'],['cached']
Performance,"// A key component of v_perm is a mapping between byte position of the src; // operands, and the byte position of the dest. To provide such, we need: 1. the; // node that provides x byte of the dest of the OR, and 2. the byte of the node; // used to provide that x byte. calculateByteProvider finds which node provides; // a certain byte of the dest of the OR, and calculateSrcByte takes that node,; // and finds an ultimate src and byte position For example: The supported; // LoadCombine pattern for vector loads is as follows; // t1; // or; // / \; // t2 t3; // zext shl; // | | \; // t4 t5 16; // or anyext; // / \ |; // t6 t7 t8; // srl shl or; // / | / \ / \; // t9 t10 t11 t12 t13 t14; // trunc* 8 trunc* 8 and and; // | | / | | \; // t15 t16 t17 t18 t19 t20; // trunc* 255 srl -256; // | / \; // t15 t15 16; //; // *In this example, the truncs are from i32->i16; //; // calculateByteProvider would find t6, t7, t13, and t14 for bytes 0-3; // respectively. calculateSrcByte would find (given node) -> ultimate src &; // byteposition: t6 -> t15 & 1, t7 -> t16 & 0, t13 -> t15 & 0, t14 -> t15 & 3.; // After finding the mapping, we can combine the tree into vperm t15, t16,; // 0x05000407; // Find the source and byte position from a node.; // \p DestByte is the byte position of the dest of the or that the src; // ultimately provides. \p SrcIndex is the byte of the src that maps to this; // dest of the or byte. \p Depth tracks how many recursive iterations we have; // performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:478,Load,LoadCombine,478,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,3,"['Load', 'load', 'perform']","['LoadCombine', 'loads', 'performed']"
Performance,"// A lifetime end, assume or noalias.decl intrinsic should not stop tail; // call optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:82,optimiz,optimization,82,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,1,['optimiz'],['optimization']
Performance,"// A llvm.dbg.value may be using a value before its definition, due to; // optimizations in this pass and others. Scan for such dbg.values, and rescue; // them by moving the dbg.value to immediately after the value definition.; // FIXME: Ideally this should never be necessary, and this has the potential; // to re-order dbg.value intrinsics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:75,optimiz,optimizations,75,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['optimiz'],['optimizations']
Performance,// A load barrier may not pass a previous load or load barrier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp:5,load,load,5,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp,3,['load'],['load']
Performance,"// A load extending to i64 will actually produce i32, which will then; // need to be extended to i64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:5,load,load,5,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,1,['load'],['load']
Performance,// A load from a constant PseudoSourceValue is invariant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:5,load,load,5,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,1,['load'],['load']
Performance,"// A load from a fixed stack slot can be rematerialized. This may be; // redundant with subsequent checks, but it's target-independent,; // simple, and a common case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:5,load,load,5,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['load'],['load']
Performance,"// A load from a uniform value is always the same, regardless of any; // applied offset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:5,load,load,5,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['load'],['load']
Performance,// A load from pointer which was loaded inside the same bundle is an; // impossible clause because we will need to write and read the same; // register inside. In this case processRegUses will return false.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFormMemoryClauses.cpp:5,load,load,5,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFormMemoryClauses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFormMemoryClauses.cpp,2,['load'],"['load', 'loaded']"
Performance,"// A load here means one of two things: a load of undef from a global,; // a load from an unknown pointer. Either way, having it return undef; // is okay.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:5,load,load,5,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,3,['load'],['load']
Performance,// A load is a use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:5,load,load,5,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,1,['load'],['load']
Performance,"// A load is known dereferenceable up to the alignment, so it's legal to widen; // to it.; //; // TODO: Could check dereferenceable for less aligned cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:5,load,load,5,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['load'],['load']
Performance,// A load may not pass a previous store or store barrier; // unless flag 'NoAlias' is set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp:5,load,load,5,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp,1,['load'],['load']
Performance,// A load may pass a previous load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp:5,load,load,5,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp,2,['load'],['load']
Performance,"// A load of a floating-point value into the high-order half of; // a vector register is safe, provided that we introduce a swap; // following the load, which will be done by the SUBREG_TO_REG; // support. So just mark these as safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:5,load,load,5,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,2,['load'],['load']
Performance,// A load of i8 or i16 sign/zero extends to i32.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:5,load,load,5,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,1,['load'],['load']
Performance,// A load which gets inserted into a vector element will be combined into a; // VLE type instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:5,load,load,5,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['load'],['load']
Performance,"// A loaded value compared with 0 with multiple users becomes Load and; // Test. The load is then not foldable, so return 0 cost for the ICmp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:5,load,loaded,5,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,3,"['Load', 'load']","['Load', 'load', 'loaded']"
Performance,// A location loaded from with an invariant_load is assumed to *never* change; // within the visible scope of the compilation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:14,load,loaded,14,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['load'],['loaded']
Performance,"// A map from mangled names to their function's source location, used for; // backend diagnostics as the Clang AST may be unavailable. We actually use; // the mangled name's hash as the key because mangled names can be very; // long and take up lots of space. Using a hash can cause name collision,; // but that is rare and the consequences are pointing to a wrong source; // location which is not severe. This is a vector instead of an actual map; // because we optimize for time building this map rather than time; // retrieving an entry, as backend diagnostics are uncommon.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h:463,optimiz,optimize,463,interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h,1,['optimiz'],['optimize']
Performance,"// A masked load can not be unfolded to a full load, otherwise it would access; // unexpected memory. A simple store can not be unfolded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86FoldTablesEmitter.cpp:12,load,load,12,interpreter/llvm-project/llvm/utils/TableGen/X86FoldTablesEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86FoldTablesEmitter.cpp,2,['load'],['load']
Performance,// A mayLoad instruction without a def is not a load. Likely a prefetch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:48,load,load,48,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['load'],['load']
Performance,// A memory intrinsic which is loaded from.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:31,load,loaded,31,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['load'],['loaded']
Performance,// A more flexible cost calculation for the critical path includes the slack; // of the original code sequence. This may allow the transform to proceed; // even if the instruction depths (data dependency cycles) become worse.; // Account for the latency of the inserted and deleted instructions by,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:246,latency,latency,246,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,1,['latency'],['latency']
Performance,"// A new load group is created if we are in one of the following situations:; // 1) This is a load barrier (by construction, a load barrier is always; // assigned to a different memory group).; // 2) There is no load in flight (by construction we always keep loads and; // stores into separate memory groups).; // 3) There is a load barrier in flight. This load depends on it.; // 4) There is an intervening store between the last load dispatched to the; // LSU and this load. We always create a new group even if this load; // does not alias the last dispatched store.; // 5) There is no intervening store and there is an active load group.; // However that group has already started execution, so we cannot add; // this load to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp:9,load,load,9,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp,12,['load'],"['load', 'loads']"
Performance,"// A non-integral address space for pointers to named objects outside of; // linear memory: WebAssembly globals or WebAssembly locals. Loads and stores; // to these pointers are lowered to global.get / global.set or local.get /; // local.set, as appropriate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/Utils/WasmAddressSpaces.h:135,Load,Loads,135,interpreter/llvm-project/llvm/lib/Target/WebAssembly/Utils/WasmAddressSpaces.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/Utils/WasmAddressSpaces.h,1,['Load'],['Loads']
Performance,"// A normal empty GNU hash table section produced by linker might have; // symndx set to the number of dynamic symbols + 1 (for the zero symbol); // and have dummy null values in the Bloom filter and in the buckets; // vector (or no values at all). It happens because the value of symndx is not; // important for dynamic loaders when the GNU hash table is empty. They just; // skip the whole object during symbol lookup. In such cases, the symndx value; // is irrelevant and we should not report a warning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:321,load,loaders,321,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,1,['load'],['loaders']
Performance,"// A note on thread groups: Tasks are by default in no group (represented; // by nullptr ThreadPoolTaskGroup pointer in the Tasks queue) and functionality; // here normally works on all tasks regardless of their group (functions; // in that case receive nullptr ThreadPoolTaskGroup pointer as argument).; // A task in a group has a pointer to that ThreadPoolTaskGroup in the Tasks; // queue, and functions called to work only on tasks from one group take that; // pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ThreadPool.cpp:130,queue,queue,130,interpreter/llvm-project/llvm/lib/Support/ThreadPool.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ThreadPool.cpp,2,['queue'],['queue']
Performance,// A null pointer access can be undefined but any offset from null may; // be OK. We do not try to optimize the latter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:99,optimiz,optimize,99,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['optimiz'],['optimize']
Performance,"// A pair that consists the proccessed, and passed events while loading the chunk",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchGenerator.hxx:64,load,loading,64,tmva/tmva/inc/TMVA/RBatchGenerator.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchGenerator.hxx,1,['load'],['loading']
Performance,// A phi node we want to perform this function on should be from the; // loop header.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:25,perform,perform,25,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,2,['perform'],['perform']
Performance,"// A phi would be free, unless we're costing the throughput because it; // will require a register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:49,throughput,throughput,49,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,1,['throughput'],['throughput']
Performance,"// A pointer induction, performed by using a gep",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,perform,performed,24,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['perform'],['performed']
Performance,"// A pointer loaded from a global would have been captured, and we know; // that the global is non-escaping, so no alias.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:13,load,loaded,13,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['load'],['loaded']
Performance,// A pointer select which is loaded from and for which the load; // can be replace by a value select.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:29,load,loaded,29,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,2,['load'],"['load', 'loaded']"
Performance,// A pointer vector can not be the return type of the ldN intrinsics. Need to; // load integer vectors first and then convert to pointer vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:82,load,load,82,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['load'],['load']
Performance,"// A priority queue for BVHPrioElement with an additional clear method; // for quick reset",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:14,queue,queue,14,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['queue'],['queue']
Performance,// A promoted result type forces the need for an extending load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:59,load,load,59,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['load'],['load']
Performance,// A pseudo probe call shouldn't change any function attribute since it; // doesn't translate to a real instruction. It comes with a memory access; // tag to prevent itself being removed by optimizations and not block; // other instructions being optimized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:190,optimiz,optimizations,190,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,2,['optimiz'],"['optimizations', 'optimized']"
Performance,"// A release fence requires that all stores complete before it, but does; // not prevent the reordering of following loads 'before' the fence. As a; // result, we don't need to consider it as writing to memory and don't need; // to advance the generation. We do need to prevent DSE across the fence,; // but that's handled above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:117,load,loads,117,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['load'],['loads']
Performance,"// A release fence requires that all stores complete before it, but does; // not prevent the reordering of following loads or stores 'before' the; // fence. As a result, we look past it when finding a dependency for; // loads. DSE uses this to find preceding stores to delete and thus we; // can't bypass the fence if the query instruction is a store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:117,load,loads,117,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,2,['load'],['loads']
Performance,"// A representation of ""interesting"" bytes within a given span of memory.; // These bytes are those that are loaded or stored, and they don't have; // to cover the entire span of memory.; //; // The representation works by picking a contiguous sequence of bytes; // from somewhere within a llvm::Value, and placing it at a given offset; // within the span.; //; // The sequence of bytes from llvm:Value is represented by Segment.; // Block is Segment, plus where it goes in the span.; //; // An important feature of ByteSpan is being able to make a ""section"",; // i.e. creating another ByteSpan corresponding to a range of offsets; // relative to the source span.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:109,load,loaded,109,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['load'],['loaded']
Performance,// A reverse mapping from dependencies to the dependees. This is; // used when removing instructions to keep the cache coherent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:113,cache,cache,113,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['cache'],['cache']
Performance,// A section will have a LoadAddr of 0 if it wasn't loaded for whatever; // reason (e.g. zero byte COFF sections). Don't include those sections in; // the allocation map.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp:25,Load,LoadAddr,25,interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp,2,"['Load', 'load']","['LoadAddr', 'loaded']"
Performance,// A set of parameters for which the check is suppressed because; // reference counting is being performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:97,perform,performed,97,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,1,['perform'],['performed']
Performance,"// A significant optimization not implemented here is assuming that alloca; // addresses are not equal to incoming argument values. They don't *alias*,; // as we say, but that doesn't mean they aren't equal, so we take a; // conservative approach.; //; // This is inspired in part by C++11 5.10p1:; // ""Two pointers of the same type compare equal if and only if they are both; // null, both point to the same function, or both represent the same; // address.""; //; // This is pretty permissive.; //; // It's also partly due to C11 6.5.9p6:; // ""Two pointers compare equal if and only if both are null pointers, both are; // pointers to the same object (including a pointer to an object and a; // subobject at its beginning) or function, both are pointers to one past the; // last element of the same array object, or one is a pointer to one past the; // end of one array object and the other is a pointer to the start of a; // different array object that happens to immediately follow the first array; // object in the address space.); //; // C11's version is more restrictive, however there's no reason why an argument; // couldn't be a one-past-the-end value for a stack object in the caller and be; // equal to the beginning of a stack object in the callee.; //; // If the C and C++ standards are ever made sufficiently restrictive in this; // area, it may be possible to update LLVM's semantics accordingly and reinstate; // this optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,optimiz,optimization,17,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['optimiz'],['optimization']
Performance,"// A simple round-robin cache: what enters first, leaves first.; // MRU cache wasn't worth the extra CPU cycles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/PlatformPosix.cpp:24,cache,cache,24,interpreter/cling/lib/Utils/PlatformPosix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/PlatformPosix.cpp,2,['cache'],['cache']
Performance,// A single load must use slot #0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:12,load,load,12,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,1,['load'],['load']
Performance,"// A slidedown/slideup with an *undefined* merge op can freely clobber; // elements not copied from the source vector (e.g. masked off, tail, or; // slideup's prefix). Notes:; // * We can't modify SEW here since the slide amount is in units of SEW.; // * VL=1 is special only because we have existing support for zero vs; // non-zero VL. We could generalize this if we had a VL > C predicate.; // * The LMUL1 restriction is for machines whose latency may depend on VL.; // * As above, this is only legal for tail ""undefined"" not ""agnostic"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:443,latency,latency,443,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['latency'],['latency']
Performance,"// A special case is when the least significant bits from the load are masked; // away, but using an AND rather than a right shift. HasShiftedOffset is used; // to indicate that the narrowed load should be left-shifted ShAmt bits to get; // the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:62,load,load,62,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['load'],['load']
Performance,"// A special combine for the vqdmulh family of instructions. This is one of the; // potential set of patterns that could patch this instruction. The base pattern; // you would expect to be min(max(ashr(mul(mul(sext(x), 2), sext(y)), 16))).; // This matches the different min(max(ashr(mul(mul(sext(x), sext(y)), 2), 16))),; // which llvm will have optimized to min(ashr(mul(sext(x), sext(y)), 15))) as; // the max is unnecessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:347,optimiz,optimized,347,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['optimiz'],['optimized']
Performance,// A specialized derived class of inner loop vectorizer that performs; // vectorization of *epilogue* loops in the process of vectorizing loops and; // their epilogues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:61,perform,performs,61,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['perform'],['performs']
Performance,"// A splat of an inserted scalar constant becomes a vector constant:; // shuf (inselt ?, C, IndexC), undef, <IndexC, IndexC...> --> <C, C...>; // NOTE: We may have commuted above, so analyze the updated Indices, not the; // original mask constant.; // NOTE: This transformation depends on the value of the mask which is not; // known at compile time for scalable vectors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:354,scalab,scalable,354,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['scalab'],['scalable']
Performance,// A store may not pass a previous load or load barrier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp:35,load,load,35,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp,2,['load'],['load']
Performance,"// A temporary struct to spill SGPRs.; // This is mostly to spill SGPRs to memory. Spilling SGPRs into VGPR lanes emits; // just v_writelane and v_readlane.; //; // When spilling to memory, the SGPRs are written into VGPR lanes and the VGPR; // is saved to scratch (or the other way around for loads).; // For this, a VGPR is required where the needed lanes can be clobbered. The; // RegScavenger can provide a VGPR where currently active lanes can be; // clobbered, but we still need to save inactive lanes.; // The high-level steps are:; // - Try to scavenge SGPR(s) to save exec; // - Try to scavenge VGPR; // - Save needed, all or inactive lanes of a TmpVGPR; // - Spill/Restore SGPRs using TmpVGPR; // - Restore TmpVGPR; //; // To save all lanes of TmpVGPR, exec needs to be saved and modified. If we; // cannot scavenge temporary SGPRs to save exec, we use the following code:; // buffer_store_dword TmpVGPR ; only if active lanes need to be saved; // s_not exec, exec; // buffer_store_dword TmpVGPR ; save inactive lanes; // s_not exec, exec",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:294,load,loads,294,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['load'],['loads']
Performance,"// A thread that calls with load==true and a thread that calls with load==false; // will conflict here (the load==true will be updating the list while the; // other is reading it). To solve the problem, we could use a read-write lock; // inside the list itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:28,load,load,28,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,3,['load'],['load']
Performance,// A transparent ILE is not performing aggregate initialization and should; // not be filled in.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:28,perform,performing,28,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['performing']
Performance,"// A traversal scope limits the parts of the AST visible to certain analyses.; // RecursiveASTVisitor only visits specified children of TranslationUnitDecl.; // getParents() will only observe reachable parent edges.; //; // The scope is defined by a set of ""top-level"" declarations which will be; // visible under the TranslationUnitDecl.; // Initially, it is the entire TU, represented by {getTranslationUnitDecl()}.; //; // After setTraversalScope({foo, bar}), the exposed AST looks like:; // TranslationUnitDecl; // - foo; // - ...; // - bar; // - ...; // All other siblings of foo and bar are pruned from the tree.; // (However they are still accessible via TranslationUnitDecl->decls()); //; // Changing the scope clears the parent cache, which is expensive to rebuild.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:737,cache,cache,737,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['cache'],['cache']
Performance,"// A two-CLC sequence is a clear win over a loop, not least because; // it needs only one branch. A three-CLC sequence needs the same; // number of branches as a loop (i.e. 2), but is shorter. That; // brings us to lengths greater than 768 bytes. It seems relatively; // likely that a difference will be found within the first 768 bytes,; // so we just optimize for the smallest number of branch; // instructions, in order to avoid polluting the prediction buffer; // too much.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:353,optimiz,optimize,353,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['optimiz'],['optimize']
Performance,"// A utility to establish an ordering between virtual registers:; // VRegA < VRegB <=> RegisterOrdering[VRegA] < RegisterOrdering[VRegB]; // This is meant as a cache for the ordering of virtual registers defined; // by a potentially expensive comparison function, or obtained by a proce-; // dure that should not be repeated each time two registers are compared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:160,cache,cache,160,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,1,['cache'],['cache']
Performance,// A value produced by a load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:25,load,load,25,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['load'],['load']
Performance,"// A vector full of immediates; various special cases are already; // handled, so this is best done with a single constant-pool load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:128,load,load,128,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['load']
Performance,"// A vector must always be stored in memory as-is, i.e. without any padding; // between the elements, since various code depend on it, e.g. in the; // handling of a bitcast of a vector type to int, which may be done with a; // vector store followed by an integer load. A vector that does not have; // elements that are byte-sized must therefore be stored as an integer; // built out of the extracted vector elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:263,load,load,263,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,3,['load'],['load']
Performance,"// A virtual call site. VTable is the loaded virtual table pointer, and CS is; // the indirect virtual call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:38,load,loaded,38,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['load'],['loaded']
Performance,// A volatile load has side effects beyond what readonly can be relied; // upon.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:14,load,load,14,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['load'],['load']
Performance,// A volatile load/store means that the alloca can't be elided anyway.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:14,load,load,14,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['load'],['load']
Performance,// A vselect where all conditions and data are constants can be optimized into; // a single vector load by SelectionDAGLegalize::ExpandBUILD_VECTOR().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:64,optimiz,optimized,64,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['load', 'optimiz']","['load', 'optimized']"
Performance,// A younger load cannot pass a older load barrier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp:13,load,load,13,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp,2,['load'],['load']
Performance,// A zero immediate should always be loaded with a single li.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:37,load,loaded,37,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['load'],['loaded']
Performance,// A zero latency instruction doesn't consume any scheduler resources.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:10,latency,latency,10,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['latency'],['latency']
Performance,// AA - Used for DAG load/store alias analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,load,load,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,"// AAPCS guarantees that sp will be 8-byte aligned on any public interface,; // however this is not necessarily true on taking any interrupt. Instruct; // the backend to perform a realignment as part of the function prologue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/ARM.cpp:170,perform,perform,170,interpreter/llvm-project/clang/lib/CodeGen/Targets/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/ARM.cpp,1,['perform'],['perform']
Performance,// AArch64 Scalable Vector Extension,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/VFABIDemangler.h:11,Scalab,Scalable,11,interpreter/llvm-project/llvm/include/llvm/IR/VFABIDemangler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/VFABIDemangler.h,1,['Scalab'],['Scalable']
Performance,"// AArch64 does not have floating-point extending loads, i1 sign-extending; // load, floating-point truncating stores, or v2i32->v2i16 truncating store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:50,load,loads,50,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['load'],"['load', 'loads']"
Performance,"// AArch64 high-vector ""long"" operations are formed by performing the non-high; // version on an extract_subvector of each operand which gets the high half:; //; // (longop2 LHS, RHS) == (longop (extract_high LHS), (extract_high RHS)); //; // However, there are cases which don't have an extract_high explicitly, but; // have another operation that can be made compatible with one for free. For; // example:; //; // (dupv64 scalar) --> (extract_high (dup128 scalar)); //; // This routine does the actual conversion of such DUPs, once outer routines; // have determined that everything else is in order.; // It also supports immediate DUP-like nodes (MOVI/MVNi), which we can fold; // similarly here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:55,perform,performing,55,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['perform'],['performing']
Performance,// ADDI instruction's destination register can be used for computing; // offsets. So Scalable stack offsets require up to one scratch register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:85,Scalab,Scalable,85,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['Scalab'],['Scalable']
Performance,"// AIX and the 64-bit ELF ABIs need to maintain the TOC pointer accross; // indirect calls. The save of the caller's TOC pointer to the stack will be; // inserted into the DAG as part of call lowering. The restore of the TOC; // pointer is modeled by using a pseudo instruction for the call opcode that; // represents the 2 instruction sequence of an indirect branch and link,; // immediately followed by a load of the TOC pointer from the stack save; // slot into gpr2. For 64-bit ELFv2 ABI with PCRel, do not restore the TOC; // as it is not saved or used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:407,load,load,407,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['load'],['load']
Performance,// AIX big archives may contain shared object members. The AIX OS requires these; // members to be aligned if they are 64-bit and recommends it for 32-bit; // members. This ensures that when these members are loaded they are aligned in; // memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp:209,load,loaded,209,interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp,1,['load'],['loaded']
Performance,// AMD64-ABI 3.5.7p5: Step 4. Fetch type from l->reg_save_area with; // an offset of l->gp_offset and/or l->fp_offset. This may require; // copying to a temporary location in case the parameter is passed; // in different register classes or requires an alignment greater; // than 8 for general purpose registers and 16 for XMM registers.; //; // FIXME: This really results in shameful code when we end up needing to; // collect arguments from different places; often what should result in a; // simple assembling of a structure from scattered addresses has many more; // loads than necessary. Can we clean this up?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:571,load,loads,571,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['load'],['loads']
Performance,"// AND instruction will essentially update SF and clear OF, so; // NoSignFlag should be false in the sense that SF is modified by `AND`.; //; // However, the implementation artifically sets `NoSignFlag` to true; // to poison the SF bit; that is to say, if SF is looked at later, the; // optimization (to erase TEST64rr) will be disabled.; //; // The reason to poison SF bit is that SF bit value could be different; // in the `AND` and `TEST` operation; signed bit is not known for `AND`,; // and is known to be 0 as a result of `TEST64rr`.; //; // FIXME: As opposed to poisoning the SF bit directly, consider peeking into; // the AND instruction and using the static information to guide peephole; // optimization if possible. For example, it's possible to fold a; // conditional move into a copy if the relevant EFLAG bits could be deduced; // from an immediate operand of and operation.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:287,optimiz,optimization,287,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,2,['optimiz'],['optimization']
Performance,"// AND masks that can be performed by two rldic{l, r}; // instructions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:25,perform,performed,25,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,1,['perform'],['performed']
Performance,// ARM does not have floating-point extending loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:46,load,loads,46,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['load'],['loads']
Performance,// ARM does not have i1 sign extending load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:39,load,load,39,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['load'],['load']
Performance,// ARM halfword load/stores and signed byte loads need an additional; // operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:16,load,load,16,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,4,['load'],"['load', 'loads']"
Performance,// ARM halfword load/stores and signed byte loads use +/-imm8 offsets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:16,load,load,16,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,2,['load'],"['load', 'loads']"
Performance,// ARM supports all 4 flavors of integer indexed load / store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:49,load,load,49,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['load'],['load']
Performance,// ARM variants loading and updating the same register are only officially; // UNPREDICTABLE on v7 upwards. Goodness knows what they did before.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:16,load,loading,16,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['load'],['loading']
Performance,// ATOMIC_CMP_SWAP for i8/i16 needs to zero-extend its input since it will be; // compared to a value that is atomically loaded (atomic loads zero-extend).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:121,load,loaded,121,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['load'],"['loaded', 'loads']"
Performance,// AVR does not yet support tail call optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:38,optimiz,optimization,38,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,1,['optimiz'],['optimization']
Performance,// AVX instructions with high latency,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:30,latency,latency,30,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['latency'],['latency']
Performance,// AVX load instructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:7,load,load,7,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['load'],['load']
Performance,// AVX-512 masked load/store is cheaper,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:18,load,load,18,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,"// AVX2 also has wider vector sign/zero extending loads, VPMOV[SZ]X",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:50,load,loads,50,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['loads']
Performance,// AVX2 can more effectively perform this as a zext/trunc to/from v8i32.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:29,perform,perform,29,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['perform']
Performance,// AVX512 instructions with high latency,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:33,latency,latency,33,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['latency'],['latency']
Performance,// AVX512 load instructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:10,load,load,10,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['load'],['load']
Performance,// AVX512IFMA multiply and add.; // NOTE: These are different than the instruction and perform; // op0 x op1 + op2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:87,perform,perform,87,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['perform'],['perform']
Performance,"// Abort if we have to process too many values to get a result for this one.; // Because of the design of the overdefined cache currently being per-block; // to avoid naming-related issues (IE it wants to try to give different; // results for the same name in different blocks), overdefined results don't; // get cached globally, which in turn means we will often try to rediscover; // the same overdefined result again and again. Once something like; // PredicateInfo is used in LVI or CVP, we should be able to make the; // overdefined cache global, and remove this throttle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:122,cache,cache,122,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,4,"['cache', 'throttle']","['cache', 'cached', 'throttle']"
Performance,"// About Module states: added->loaded->finalized.; //; // The purpose of the ""added"" state is having modules in standby. (added=known; // but not compiled). The idea is that you can add a module to provide function; // definitions but if nothing in that module is referenced by a module in which; // a function is executed (note the wording here because it's not exactly the; // ideal case) then the module never gets compiled. This is sort of lazy; // compilation.; //; // The purpose of the ""loaded"" state (loaded=compiled and required sections; // copied into local memory but not yet ready for execution) is to have an; // intermediate state wherein clients can remap the addresses of sections, using; // MCJIT::mapSectionAddress, (in preparation for later copying to a new location; // or an external process) before relocations and page permissions are applied.; //; // It might not be obvious at first glance, but the ""remote-mcjit"" case in the; // lli tool does this. In that case, the intermediate action is taken by the; // RemoteMemoryManager in response to the notifyObjectLoaded function being; // called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:31,load,loaded,31,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,3,['load'],['loaded']
Performance,"// About a half of the loads may be folded in shuffles when we have only; // one result. If we have more than one result, or the loads are masked,; // we do not fold loads at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:23,load,loads,23,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,3,['load'],['loads']
Performance,"// Above the cutoff, we give a cost to each private memory object; // depending its size. If the array can be optimized by SROA this cost is not; // added to the total-cost in the inliner cost analysis.; //; // We choose the total cost of the alloca such that their sum cancels the; // bonus given in the threshold (ArgAllocaCost).; //; // Cost_Alloca_0 + ... + Cost_Alloca_N == ArgAllocaCost; //; // Awkwardly, the ArgAllocaCost bonus is multiplied by threshold-multiplier,; // the single-bb bonus and the vector-bonus.; //; // We compensate the first two multipliers, by repeating logic from the; // inliner-cost in here. The vector-bonus is 0 on AMDGPU.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:110,optimiz,optimized,110,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,1,['optimiz'],['optimized']
Performance,"// Abstract base class for cached p.d.f.s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCachedPdf.h:27,cache,cached,27,roofit/roofitcore/inc/RooAbsCachedPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCachedPdf.h,2,['cache'],['cached']
Performance,"// Accept ADRP, ADDLow and LOADGot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp:27,LOAD,LOADGot,27,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp,1,['LOAD'],['LOADGot']
Performance,"// Accept cases where the vector elements are integers and the scalar is; // an integer.; // FIXME: Notionally if the scalar was a floating point value with a precise; // integral representation, we could cast it to an appropriate integer; // type and then perform the rest of the checks here. GCC will perform; // this conversion in some cases as determined by the input language.; // We should accept it on a language independent basis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:257,perform,perform,257,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['perform'],['perform']
Performance,// Accept widening loads based on alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:19,load,loads,19,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['load'],['loads']
Performance,// Access size for load/store instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:19,load,load,19,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,1,['load'],['load']
Performance,// Access the path to this entry in the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:40,cache,cache,40,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['cache'],['cache']
Performance,"// Accesses larger than the native width are turned into cmpxchg/libcalls, so; // there is no benefit in turning such RMWs into loads, and it is actually; // harmful as it introduces a mfence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:128,load,loads,128,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['loads']
Performance,"// According to GCC info page:; //; // 6.28 Compound Literals; //; // As an optimization, G++ sometimes gives array compound literals longer; // lifetimes: when the array either appears outside a function or has a; // const-qualified type. If foo and its initializer had elements of type; // char *const rather than char *, or if foo were a global variable, the; // array would have static storage duration. But it is probably safest; // just to avoid the use of array compound literals in C++ code.; //; // Obey that rule by checking constness for converted array types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:76,optimiz,optimization,76,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['optimiz'],['optimization']
Performance,"// According to [dcl.fct.def.coroutine]p9, Lookup allocation functions using a; // parameter list composed of the requested size of the coroutine state being; // allocated, followed by the coroutine function's arguments. If a matching; // allocation function exists, use it. Otherwise, use an allocation function; // that just takes the requested size.; //; // [dcl.fct.def.coroutine]p9; // An implementation may need to allocate additional storage for a; // coroutine.; // This storage is known as the coroutine state and is obtained by calling a; // non-array allocation function ([basic.stc.dynamic.allocation]). The; // allocation function's name is looked up by searching for it in the scope of; // the promise type.; // - If any declarations are found, overload resolution is performed on a; // function call created by assembling an argument list. The first argument is; // the amount of space requested, and has type std::size_t. The; // lvalues p1 ... pn are the succeeding arguments.; //; // ...where ""p1 ... pn"" are defined earlier as:; //; // [dcl.fct.def.coroutine]p3; // The promise type of a coroutine is `std::coroutine_traits<R, P1, ...,; // Pn>`; // , where R is the return type of the function, and `P1, ..., Pn` are the; // sequence of types of the non-object function parameters, preceded by the; // type of the object parameter ([dcl.fct]) if the coroutine is a non-static; // member function. [dcl.fct.def.coroutine]p4 In the following, p_i is an; // lvalue of type P_i, where p1 denotes the object parameter and p_i+1 denotes; // the i-th non-object function parameter for a non-static member function,; // and p_i denotes the i-th function parameter otherwise. For a non-static; // member function, q_1 is an lvalue that denotes *this; any other q_i is an; // lvalue that denotes the parameter copy corresponding to p_i.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:782,perform,performed,782,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,1,['perform'],['performed']
Performance,"// According to https://clang.llvm.org/docs/ClangPlugins.html; // plugin arguments are in the form:; // -Xclang {-load, -plugin, -plugin-arg-<plugin-name>, -add-plugin}; // -Xclang <arbitrary-argument>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:114,load,load,114,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,1,['load'],['load']
Performance,// According to spec debugging info has to come before loading the; // corresponding code load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:55,load,loading,55,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,2,['load'],"['load', 'loading']"
Performance,"// According to the PE Format spec, in ""The .tls Section""; // (http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx):; // 2. When a thread is created, the loader communicates the address; // of the thread's TLS array by placing the address of the thread; // environment block (TEB) in the FS register. A pointer to the TLS; // array is at the offset of 0x2C from the beginning of TEB. This; // behavior is Intel x86-specific.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:169,load,loader,169,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['load'],['loader']
Performance,// Account for additional optimizations taking place before the LoopUnrollPass; // would unroll the loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:26,optimiz,optimizations,26,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['optimiz'],['optimizations']
Performance,// Acquire/Release load/store is not legal for targets without a dmb or; // equivalent available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:19,load,load,19,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['load'],['load']
Performance,"// Activate constant term optimization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx:26,optimiz,optimization,26,roofit/roofitcore/src/FitHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx,1,['optimiz'],['optimization']
Performance,"// Actual draw method (non DL cached)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLLogicalShape.h:30,cache,cached,30,graf3d/gl/inc/TGLLogicalShape.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLLogicalShape.h,1,['cache'],['cached']
Performance,"// Actual registering the basket for loading from the file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:37,load,loading,37,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['load'],['loading']
Performance,// Actually perform exhaustive combination generation.; // Each result will be passed into the callback.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:12,perform,perform,12,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,1,['perform'],['perform']
Performance,// Actually perform the constructor call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:12,perform,perform,12,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['perform']
Performance,// Actually perform the elimination.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:12,perform,perform,12,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['perform'],['perform']
Performance,// Actually perform the operation.; // evalBinOpNN expects the two indexes to already be the right type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:12,perform,perform,12,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['perform'],['perform']
Performance,"// Add !invariant.load md to virtual function load to indicate that; // function didn't change inside vtable.; // It's safe to add it without -fstrict-vtable-pointers, but it would not; // help in devirtualization because it will only matter if we will have 2; // the same virtual function loads from the same vtable load, which won't; // happen without enabled devirtualization with -fstrict-vtable-pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:18,load,load,18,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,4,['load'],"['load', 'loads']"
Performance,"// Add DAG nodes to load the arguments or copy them out of registers. On; // entry to a function on PPC, the arguments start after the linkage area,; // although the first ones are often in registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,load,load,20,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['load'],['load']
Performance,// Add GOT/Stubs optimizer pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_i386.cpp:17,optimiz,optimizer,17,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_i386.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_i386.cpp,3,['optimiz'],['optimizer']
Performance,"// Add MC directives to embed target binaries. We ensure that each; // section and image is 16-byte aligned. This is not mandatory, but; // increases the likelihood of data to be aligned with a cache block; // in several main host machines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPUtility.cpp:194,cache,cache,194,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPUtility.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPUtility.cpp,1,['cache'],['cache']
Performance,"// Add ObjC ARC final-cleanup optimizations. This is done as part of the; // ""codegen"" passes so that it isn't run multiple times when there is; // inlining happening.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:30,optimiz,optimizations,30,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,1,['optimiz'],['optimizations']
Performance,// Add PromiseAlloca to Allocas list so that; // 1. updateLayoutIndex could update its index after; // `performOptimizedStructLayout`; // 2. it is processed in insertSpills.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:104,perform,performOptimizedStructLayout,104,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['perform'],['performOptimizedStructLayout']
Performance,// Add a bitcast if the resulting load type doesn't match v2f64.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:34,load,load,34,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['load'],['load']
Performance,// Add a cost for constant load to vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:27,load,load,27,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// Add a cost of address generation + the cost of the load. The address; // is expected to be a PC relative offset to a constant pool entry; // using auipc/addi.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:54,load,load,54,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,1,['load'],['load']
Performance,// Add a data dependency to reflect that NewSU reads the value defined; // by LoadSU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:78,Load,LoadSU,78,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['Load'],['LoadSU']
Performance,// Add a new loop into the loop queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:32,queue,queue,32,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,1,['queue'],['queue']
Performance,// Add a pass that writes the optimized IR to an output stream,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:30,optimiz,optimized,30,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,1,['optimiz'],['optimized']
Performance,// Add a phi edge for the last LoadCmpBlock to Endblock with a value of 0; // since early exit to ResultBlock was not taken (no difference was found in; // any of the bytes).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:31,Load,LoadCmpBlock,31,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,2,['Load'],['LoadCmpBlock']
Performance,// Add a pointer to the value to load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:33,load,load,33,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,1,['load'],['load']
Performance,"// Add a summary to a FunctionDecl found by lookup. The lookup is performed; // by the given Name, and in the global scope. The summary will be attached; // to the found FunctionDecl only if the signatures match.; //; // Returns true if the summary has been added, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:66,perform,performed,66,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['perform'],['performed']
Performance,"// Add a trailing update record, if any. These must go last because we; // lazily load their attached statement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:82,load,load,82,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['load'],['load']
Performance,"// Add a waitcnt to flush the LOADcnt, SAMPLEcnt and BVHcnt counters at the; // end of the given block if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:30,LOAD,LOADcnt,30,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['LOAD'],['LOADcnt']
Performance,"// Add all branches to be cached. This also sets fIsManual, stops learning,; // and makes fEntryNext = -1 (which forces a cache fill, which is good)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:26,cache,cached,26,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],"['cache', 'cached']"
Performance,// Add all leaves to Available queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:31,queue,queue,31,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['queue'],['queue']
Performance,// Add all strings to the string table upfront so it can generate an optimized; // representation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp:69,optimiz,optimized,69,interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp,1,['optimiz'],['optimized']
Performance,"// Add all the required instructions to the block; // These cannot live in another block (because they; // depend (order dependency) on one of the; // instruction in the block, and are required for the; // high latency instruction we add.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:211,latency,latency,211,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['latency'],['latency']
Performance,"// Add an REP prefix to BSF instructions so that new processors can; // recognize as TZCNT, which has better performance than BSF.; // BSF and TZCNT have different interpretations on ZF bit. So make sure; // it won't be used later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp:109,perform,performance,109,interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,1,['perform'],['performance']
Performance,"// Add an action to be performed when the binary is evicted, before all; // previously registered evictors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h:23,perform,performed,23,interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,1,['perform'],['performed']
Performance,"// Add an extra element to the shuffle, taking it from element Elem of Op.; // A null Op indicates a vector input whose value will be calculated later;; // there is at most one such input per shuffle and it always has the same; // type as the result. Aborts and returns false if the source vector elements; // of an EXTRACT_VECTOR_ELT are smaller than the destination elements. Per; // LLVM they become implicitly extended, but this is rare and not optimized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:449,optimiz,optimized,449,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['optimiz'],['optimized']
Performance,// Add an implicit use of the load so it is not dead.; // FIXME This inserts an unnecessary waitcnt,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:30,load,load,30,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['load'],['load']
Performance,// Add bitcasts and zero GEPs to queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:33,queue,queue,33,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['queue'],['queue']
Performance,"// Add candidates from ADL. Per [over.match.oper]p2, this lookup is not; // performed for an assignment operator (nor for operator[] nor operator->,; // which don't get here).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:76,perform,performed,76,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['perform'],['performed']
Performance,// Add comments for values loaded from constant pool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp:27,load,loaded,27,interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,1,['load'],['loaded']
Performance,"// Add cost for extending to illegal -too wide- scalable vectors.; // zero/sign extend are implemented by multiple unpack operations,; // where each operation has a cost of 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:48,scalab,scalable,48,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['scalab'],['scalable']
Performance,"// Add dead subregister definitions if we are defining the whole register; // but only part of it is live.; // This could happen if the rematerialization instruction is rematerializing; // more than actually is used in the register.; // An example would be:; // %1 = LOAD CONSTANTS 5, 8 ; Loading both 5 and 8 in different subregs; // ; Copying only part of the register here, but the rest is undef.; // %2:sub_16bit<def, read-undef> = COPY %1:sub_16bit; // ==>; // ; Materialize all the constants but only using one; // %2 = LOAD_CONSTANTS 5, 8; //; // at this point for the part that wasn't defined before we could have; // subranges missing the definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:267,LOAD,LOAD,267,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,2,"['LOAD', 'Load']","['LOAD', 'Loading']"
Performance,// Add dependencies to previous stores and loads mapped to V.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:43,load,loads,43,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['load'],['loads']
Performance,// Add extra latency due to delays in the forwarding data paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.cpp:13,latency,latency,13,interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.cpp,1,['latency'],['latency']
Performance,// Add information about load/store queues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp:25,load,load,25,interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,2,"['load', 'queue']","['load', 'queues']"
Performance,// Add late LTO optimization passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:16,optimiz,optimization,16,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['optimiz'],['optimization']
Performance,// Add latency if DefMI is a real instruction. Transients get latency 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:7,latency,latency,7,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,4,['latency'],['latency']
Performance,// Add latency to instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:7,latency,latency,7,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,1,['latency'],['latency']
Performance,// Add load and check to the basicblock.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:7,load,load,7,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['load'],['load']
Performance,"// Add metadata to the load, but setVectorValue to the reverse shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:23,load,load,23,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['load'],['load']
Performance,// Add metadata to the loop L to disable loop optimizations. Callers need to; // confirm that optimizing loop L is not beneficial.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:46,optimiz,optimizations,46,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,2,['optimiz'],"['optimizations', 'optimizing']"
Performance,// Add non-overlapping loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:23,load,loads,23,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,1,['load'],['loads']
Performance,"// Add observables exclusively used to calculate cached observables to pruneSet",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:49,cache,cached,49,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['cache'],['cached']
Performance,"// Add operand bundle ""clang.arc.attachedcall"" to the call instead of emitting; // retainRV or claimRV calls in the IR. We currently do this only when the; // optimization level isn't -O0 since global-isel, which is currently run at; // -O0, doesn't know about the operand bundle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:159,optimiz,optimization,159,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['optimiz'],['optimization']
Performance,// Add operands to the queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenPredicate.cpp:23,queue,queue,23,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenPredicate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenPredicate.cpp,1,['queue'],['queue']
Performance,// Add other optimization related attributes if we are optimizing this; // function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:13,optimiz,optimization,13,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,2,['optimiz'],"['optimization', 'optimizing']"
Performance,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:394,latency,latency,394,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,2,['latency'],['latency']
Performance,"// Add padding if necessary to align the data element properly.; // Currently the only structure with scalable size will be the homogeneous; // scalable vector types. Homogeneous scalable vector types have members of; // the same data type so no alignment issue will happen. The condition here; // assumes so and needs to be adjusted if this assumption changes (e.g. we; // support structures with arbitrary scalable data type, or structure that; // contains both fixed size and scalable size data type members).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:102,scalab,scalable,102,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,5,['scalab'],['scalable']
Performance,// Add parameters to local variable map.; // FIXME: right now we emulate params with loads; that should be fixed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:85,load,loads,85,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,1,['load'],['loads']
Performance,// Add partitions for values used outside. These partitions can be out of; // order from the original program order. This is OK because if the; // partition uses a load we will merge this partition with the original; // partition of the load that we set up in the previous loop (see; // mergeToAvoidDuplicatedLoads).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:164,load,load,164,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,2,['load'],['load']
Performance,// Add passes that optimize machine instructions in SSA form.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:19,optimiz,optimize,19,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['optimiz'],['optimize']
Performance,// Add passes that perform straight-line scalar optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:19,perform,perform,19,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,2,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,// Add root to Available queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:25,queue,queue,25,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,2,['queue'],['queue']
Performance,"// Add scalarization of target's unsupported masked memory intrinsics pass.; // the unsupported intrinsic will be replaced with a chain of basic blocks,; // that stores/loads element one-by-one if the appropriate mask bit is set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:169,load,loads,169,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['load'],['loads']
Performance,// Add some optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h:12,optimiz,optimizations,12,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h,3,['optimiz'],['optimizations']
Performance,// Add support for postincrement and predecrement load/stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:50,load,load,50,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,1,['load'],['load']
Performance,"// Add support for querying global aliasing information when available.; // Because the `AAManager` is a function analysis and `GlobalsAA` is a module; // analysis, all that the `AAManager` can do is query for any *cached*; // results from `GlobalsAA` through a readonly proxy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:215,cache,cached,215,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['cache'],['cached']
Performance,// Add the 16-bit load / store instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:18,load,load,18,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,2,['load'],['load']
Performance,"// Add the Module to the ""Loaded"" set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:26,Load,Loaded,26,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,1,['Load'],['Loaded']
Performance,// Add the cache directory as a temp so the crash diagnostics pick it up.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:11,cache,cache,11,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['cache'],['cache']
Performance,// Add the core optimizing pipeline.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:16,optimiz,optimizing,16,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['optimiz'],['optimizing']
Performance,"// Add the cost of the permutations.; // For VSX, we can do unaligned loads and stores on Altivec/VSX types. On the; // P7, unaligned vector loads are more expensive than the permutation-based; // load sequence, so that might be used instead, but regardless, the net cost; // is about the same (not counting loop-invariant instructions).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:70,load,loads,70,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,3,['load'],"['load', 'loads']"
Performance,"// Add the data-in-code load command size, if used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:24,load,load,24,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,1,['load'],['load']
Performance,"// Add the deployment target version info load command size, if used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:42,load,load,42,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,1,['load'],['load']
Performance,"// Add the enum to the list of loaded enums.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:31,load,loaded,31,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['load'],['loaded']
Performance,// Add the last overlapping load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:28,load,load,28,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,1,['load'],['load']
Performance,// Add the linker option load commands sizes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:25,load,load,25,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,1,['load'],['load']
Performance,// Add the loaded IR module to the JIT. This will set up symbol tables and; // prepare for materialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp:11,load,loaded,11,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,1,['load'],['loaded']
Performance,// Add the loaded values to the phi nodes for calculating memcmp result only; // if result is not used in a zero equality.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:11,load,loaded,11,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,1,['load'],['loaded']
Performance,"// Add the loh load command size, if used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:15,load,load,15,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,1,['load'],['load']
Performance,"// Add the narrow phi to list, so that it will be adjusted later when the; // the transformation is performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:100,perform,performed,100,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,1,['perform'],['performed']
Performance,"// Add the node to the queue, if it is not there yet",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:23,queue,queue,23,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,1,['queue'],['queue']
Performance,"// Add the non-lazy-bind attribute, since objc_loadClassref is likely to; // be called a lot.; //; // Also it is safe to make it readnone, since we never load or store the; // classref except by calling this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:154,load,load,154,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['load'],['load']
Performance,"// Add the phis created into the IDF blocks to NonOptPhis, so they are not; // optimized out as trivial by the call to getPreviousDefFromEnd below.; // Once they are complete, all these Phis are added to the FixupList, and; // removed from NonOptPhis inside fixupDefs(). Existing Phis in IDF may; // need fixing as well, and potentially be trivial before this insertion,; // hence add all IDF Phis. See PR43044.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:79,optimiz,optimized,79,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['optimiz'],['optimized']
Performance,// Add the registers this load reads to those we check for clobbers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp:26,load,load,26,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp,1,['load'],['load']
Performance,"// Add the special flag to GDM to signal retrying with no inlining.; // Note, changing the state ensures that we are not going to cache out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:130,cache,cache,130,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,1,['cache'],['cache']
Performance,"// Add the symbol table load command sizes, if used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:24,load,load,24,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,1,['load'],['load']
Performance,"// Add the target variant version info load command size, if used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:39,load,load,39,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,1,['load'],['load']
Performance,// Add the vectorized (and predicated) loads/store instructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:39,load,loads,39,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['load'],['loads']
Performance,// Add the virtual directory to the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:36,cache,cache,36,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,1,['cache'],['cache']
Performance,// Add this function to constructors.; // Set priority to 1 so that __tgt_register_lib is executed AFTER; // __tgt_register_requires (we want to know what requirements have been; // asked for before we load a libomptarget plugin so that by the time the; // plugin is loaded it can report how many devices there are which can; // satisfy these requirements).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp:202,load,load,202,interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp,2,['load'],"['load', 'loaded']"
Performance,// Add this loop back onto the back of the queue to preserve our invariants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:43,queue,queue,43,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,1,['queue'],['queue']
Performance,"// Add to cache list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:10,cache,cache,10,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['cache'],['cache']
Performance,"// Add to cache only on HTTP success, so that we do not cache; // error response bodies as proper responses to requests.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:10,cache,cache,10,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,2,['cache'],['cache']
Performance,"// Add to the queue",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:14,queue,queue,14,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,2,['queue'],['queue']
Performance,// Add to the queue all successors with zero local in-degree,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:14,queue,queue,14,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,1,['queue'],['queue']
Performance,"// Add track in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx:20,cache,cache,20,proof/proofplayer/src/TEventIter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx,1,['cache'],['cache']
Performance,// Add trailing '/' to cache dir if necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:23,cache,cache,23,interpreter/llvm-project/llvm/tools/lli/lli.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp,1,['cache'],['cache']
Performance,"// Add transform passes.; // Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:50,optimiz,optimizations,50,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,4,['optimiz'],['optimizations']
Performance,// Add tune CPU to the Key.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp:7,tune,tune,7,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp,1,['tune'],['tune']
Performance,"// Add uniform instructions demanding lane 0 to the worklist. Instructions; // that are scalar with predication must not be considered uniform after; // vectorization, because that would create an erroneous replicating region; // where only a single instance out of VF should be formed.; // TODO: optimize such seldom cases if found important, see PR40816.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:297,optimiz,optimize,297,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['optimiz'],['optimize']
Performance,// AddRecs require their operands be loop-invariant with respect to their; // loops. Don't perform this transformation if it would break this; // requirement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:91,perform,perform,91,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['perform'],['perform']
Performance,"// Adding and subtracting also works for multiple accumulators, even mixing different N.; // It doesn't vectorize, but that's only a performance issue, not a precision issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testKahan.cxx:133,perform,performance,133,math/mathcore/test/testKahan.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testKahan.cxx,1,['perform'],['performance']
Performance,"// Adding overlap candidates can highly improve performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h:48,perform,performance,48,geom/geom/inc/TGeoParallelWorld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h,1,['perform'],['performance']
Performance,"// Additional code to be given to cling at library load",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:51,load,load,51,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['load'],['load']
Performance,"// Additionally, we should remove them from the fallback indirect call,; // so that we don't attempt to perform indirect call promotion later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:104,perform,perform,104,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['perform'],['perform']
Performance,// Address computations in vectorized code with non-consecutive addresses will; // likely result in more instructions compared to scalar code where the; // computation can more often be merged into the index mode. The resulting; // extra micro-ops can significantly decrease throughput.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:275,throughput,throughput,275,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,3,['throughput'],['throughput']
Performance,"// Address space 8 pointers are handled by a 4xs32 load, bitcast, and; // ptrtoint. This is needed to account for the fact that we can't have i128; // as a register class for SelectionDAG reasons.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:51,load,load,51,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['load'],['load']
Performance,// Address where section is to be loaded,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:34,load,loaded,34,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,3,['load'],['loaded']
Performance,// Addressing mode for load/store instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:23,load,load,23,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,1,['load'],['load']
Performance,// Addressing modes 4 & 6 (load/store) instructions can't encode an; // immediate offset for stack references.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:27,load,load,27,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['load'],['load']
Performance,// Adds a log entry to end of the queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h:34,queue,queue,34,interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,2,['queue'],['queue']
Performance,"// Adjust AllocSize to be the space remaining after this offset.; // We can't subtract a fixed size from a scalable one, so in that case; // assume the scalable value is of minimum size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:107,scalab,scalable,107,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,2,['scalab'],['scalable']
Performance,"// Adjust alignment of arguments passed byval in .param address space. We can; // increase alignment of such arguments in a way that ensures that we can; // effectively vectorize their loads. We should also traverse all loads from; // byval pointer and adjust their alignment, if those were using known offset.; // Such alignment changes must be conformed with parameter store and load in; // NVPTXTargetLowering::LowerCall.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:185,load,loads,185,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,3,['load'],"['load', 'loads']"
Performance,// Adjust height by Dep.DefMI latency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:30,latency,latency,30,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['latency'],['latency']
Performance,// Adjust load/store to the new chosen base.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:10,load,load,10,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['load'],['load']
Performance,"// Adjust offset for a float argument by adding 4 since the argument is; // stored in 8 bytes buffer with offset like below. LLVM generates; // 4 bytes load instruction, so need to adjust offset here. This; // adjustment is required in only LowerFormalArguments. In LowerCall,; // a float argument is converted to i64 first, and stored as 8 bytes; // data, which is required by ABI, so no need for adjustment.; // 0 4; // +------+------+; // | empty| float|; // +------+------+",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:152,load,load,152,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['load'],['load']
Performance,"// Adjust offset for extended arguments, SPARC is big-endian.; // The caller will have written the full slot with extended bytes, but we; // prefer our own extending loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:166,load,loads,166,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,1,['load'],['loads']
Performance,"// Adjust the dependence latency using operand def/use information,; // then allow the target to perform its own adjustments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:25,latency,latency,25,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,2,"['latency', 'perform']","['latency', 'perform']"
Performance,"// Adjust the function prologue to enable split stacks. This currently only; // supports android and linux.; //; // The ABI of the segmented stack prologue is a little arbitrarily chosen, but; // must be well defined in order to allow for consistent implementations of the; // __morestack helper function. The ABI is also not a normal ABI in that it; // doesn't follow the normal calling conventions because this allows the; // prologue of each function to be optimized further.; //; // Currently, the ABI looks like (when calling __morestack); //; // * r4 holds the minimum stack size requested for this function call; // * r5 holds the stack size of the arguments to the function; // * the beginning of the function is 3 instructions after the call to; // __morestack; //; // Implementations of __morestack should use r4 to allocate a new stack, r5 to; // place the arguments on to the new stack, and the 3-instruction knowledge to; // jump directly to the body of the function when working on the new stack.; //; // An old (and possibly no longer compatible) implementation of __morestack for; // ARM can be found at [1].; //; // [1] - https://github.com/mozilla/rust/blob/86efd9/src/rt/arch/arm/morestack.S",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:460,optimiz,optimized,460,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['optimiz'],['optimized']
Performance,// Adjust the latency between both instrs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:14,latency,latency,14,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,1,['latency'],['latency']
Performance,// Adjust type of load/store op if we've extended the scalar; // return value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:18,load,load,18,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['load'],['load']
Performance,// Advance the pointer so that the loaded byte will contain the sign bit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:35,load,loaded,35,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['load'],['loaded']
Performance,// Advance the pointer to the next token in the circular token queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RetireControlUnit.h:63,queue,queue,63,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RetireControlUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RetireControlUnit.h,1,['queue'],['queue']
Performance,"// Advertise ourself as the loading class for this class name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:28,load,loading,28,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['load'],['loading']
Performance,"// After all the set up is performed, then do the Fit!!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:27,perform,performed,27,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['perform'],['performed']
Performance,"// After creating a control flow hub, the operands of PHINodes in an outgoing; // block Out no longer match the predecessors of that block. Predecessors of Out; // that are incoming blocks to the hub are now replaced by just one edge from; // the hub. To match this new control flow, the corresponding values from each; // PHINode must now be moved a new PHINode in the first guard block of the hub.; //; // This operation cannot be performed with SSAUpdater, because it involves one; // new use: If the block Out is in the list of Incoming blocks, then the newly; // created PHI in the Hub will use itself along that edge from Out to Hub.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:433,perform,performed,433,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,1,['perform'],['performed']
Performance,"// After creating a new PHI for ValNo, the phi translate result for ValNo will; // be changed, so erase the related stale entries in phi translate cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:147,cache,cache,147,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['cache'],['cache']
Performance,"// After getting the multiplication result in 4 parts, we need to perform a; // shift right by the amount of the scale to get the result in that scale.; //; // Let's say we multiply 2 64 bit numbers. The resulting value can be held in; // 128 bits that are cut into 4 32-bit parts:; //; // HH HL LH LL; // |---32---|---32---|---32---|---32---|; // 128 96 64 32 0; //; // |------VTSize-----|; //; // |NVTSize-|; //; // The resulting Lo and Hi would normally be in LL and LH after the shift. But; // to avoid unneccessary shifting of all 4 parts, we can adjust the shift; // amount and get Lo and Hi using two funnel shifts. Or for the special case; // when Scale is a multiple of NVTSize we can just pick the result without; // shifting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:66,perform,perform,66,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['perform'],['perform']
Performance,"// After incoming values splitting, the old phi may become trivial.; // Keeping the trivial phi can introduce definition inside the outline; // region which is live-out, causing necessary overhead (load, store; // arg passing etc).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:198,load,load,198,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,1,['load'],['load']
Performance,"// After loading modules, we must update the redeclaration chains.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:9,load,loading,9,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['load'],['loading']
Performance,"// After optimizations, coro_suspends using this coro_save might have; // been removed, remember orphaned coro_saves to remove them later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp:9,optimiz,optimizations,9,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp,1,['optimiz'],['optimizations']
Performance,"// After reaching the terminal, it's time to perform identity comparisons.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp:45,perform,perform,45,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp,1,['perform'],['perform']
Performance,"// After reordering basic blocks, we must update basic block branches to; // insert explicit fallthrough branches when required and optimize branches; // when possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:132,optimiz,optimize,132,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,1,['optimiz'],['optimize']
Performance,"// After scheduling is done, improve low latency placements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h:41,latency,latency,41,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,1,['latency'],['latency']
Performance,"// After successfully parsing some operands there are three special cases; // to consider (i.e. notional operands not separated by commas). Two are; // due to memory specifiers:; // + An RBrac will end an address for load/store/prefetch; // + An '!' will indicate a pre-indexed operation.; //; // And a further case is '}', which ends a group of tokens specifying the; // SME accumulator array 'ZA' or tile vector, i.e.; //; // '{ ZA }' or '{ <ZAt><HV>.<BHSDQ>[<Wv>, #<imm>] }'; //; // It's someone else's responsibility to make sure these tokens are sane; // in the given context!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:217,load,load,217,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['load'],['load']
Performance,"// After the first and second level caches, I see two common sorts of; // behavior: 1) a lot of searched FileID's are ""near"" the cached file; // location or are ""near"" the cached expansion location. 2) others are just; // completely random and may be a very long way away.; //; // To handle this, we do a linear search for up to 8 steps to catch #1 quickly; // then we fall back to a less cache efficient, but more scalable, binary; // search to find the location.; // See if this is near the file point - worst case we start scanning from the; // most newly created FileID.; // LessIndex - This is the lower bound of the range that we're searching.; // We know that the offset corresponding to the FileID is less than; // SLocOffset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:36,cache,caches,36,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,5,"['cache', 'scalab']","['cache', 'cached', 'caches', 'scalable']"
Performance,"// After the item is in the cache, we can do further initialization which; // is then allowed to access the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h:28,cache,cache,28,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h,2,['cache'],['cache']
Performance,// After this point the DAG node only permits extracting fixed-width; // subvectors from scalable vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:89,scalab,scalable,89,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['scalab'],['scalable']
Performance,// After we finish hardening loads we handle interprocedural hardening if; // enabled and relevant for this instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:29,load,loads,29,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['load'],['loads']
Performance,// After we performed the cast we can check for postfix-expr pieces.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:12,perform,performed,12,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['perform'],['performed']
Performance,"// After we're done with everything else, convert IMPLICIT_DEF; // passthru operands to NoRegister. This is required to workaround; // an optimization deficiency in MachineCSE. This really should; // be merged back into each of the patterns (i.e. there's no good; // reason not to go directly to NoReg), but is being done this way; // to allow easy backporting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:138,optimiz,optimization,138,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['optimiz'],['optimization']
Performance,"// After-burner: apply interpolating cache on (numeric) integral if requested by user",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:37,cache,cache,37,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['cache'],['cache']
Performance,"// Aggregate assignment turns into llvm.memcpy. This is almost valid per; // C99 6.5.16.1p3, which states ""If the value being stored in an object is; // read from another object that overlaps in anyway the storage of the first; // object, then the overlap shall be exact and the two objects shall have; // qualified or unqualified versions of a compatible type.""; //; // memcpy is not defined if the source and destination pointers are exactly; // equal, but other compilers do this optimization, and almost every memcpy; // implementation handles this case safely. If there is a libc that does not; // safely handle this, we can add a target hook.; // Get data size info for this aggregate. Don't copy the tail padding if this; // might be a potentially-overlapping subobject, since the tail padding might; // be occupied by a different object. Otherwise, copying it is fine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:483,optimiz,optimization,483,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['optimiz'],['optimization']
Performance,// Aggressively form a vector op if the cost is equal because the transform; // may enable further optimization.; // Codegen can reverse this transform (scalarize) if it was not profitable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:99,optimiz,optimization,99,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['optimiz'],['optimization']
Performance,// Aggressively form vector ops if the cost is equal because the transform; // may enable further optimization.; // Codegen can reverse this transform (scalarize) if it was not profitable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:98,optimiz,optimization,98,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['optimiz'],['optimization']
Performance,"// Algorithm: REveTrans a; a.SetupRotation(i1, i2, amount); MultLeft(a);; // Optimized version:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveTrans.cxx:77,Optimiz,Optimized,77,graf3d/eve7/src/REveTrans.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveTrans.cxx,1,['Optimiz'],['Optimized']
Performance,"// Algorithm: REveTrans a; a.SetupRotation(i1, i2, amount); MultRight(a);; // Optimized version:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveTrans.cxx:78,Optimiz,Optimized,78,graf3d/eve7/src/REveTrans.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveTrans.cxx,1,['Optimiz'],['Optimized']
Performance,"// Algorithm: TEveTrans a; a.SetupRotation(i1, i2, amount); MultLeft(a);; // Optimized version:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrans.cxx:77,Optimiz,Optimized,77,graf3d/eve/src/TEveTrans.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrans.cxx,1,['Optimiz'],['Optimized']
Performance,"// Algorithm: TEveTrans a; a.SetupRotation(i1, i2, amount); MultRight(a);; // Optimized version:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrans.cxx:78,Optimiz,Optimized,78,graf3d/eve/src/TEveTrans.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrans.cxx,1,['Optimiz'],['Optimized']
Performance,// Alias Analysis to check for stores b/w the loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:46,load,loads,46,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['load'],['loads']
Performance,// Alias analysis result aggregration using which this query is performed.; // Can be used to perform recursive queries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:64,perform,performed,64,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,2,['perform'],"['perform', 'performed']"
Performance,"// Align two vectors (in Op0, Op1) to one that would have; // been loaded from address in Op2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:67,load,loaded,67,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,1,['load'],['loaded']
Performance,"// Align vector address: Op0 & -Op1, except when it is; // an address in a vector load, then it's a no-op.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:82,load,load,82,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,1,['load'],['load']
Performance,// Aligned 128-bit loads and stores are single-copy atomic according to the; // v8.4a spec. LRCPC3 introduces 128-bit STILP/LDIAPP but still requires LSE2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:19,load,loads,19,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['load'],['loads']
Performance,// Aligned loads and stores are easy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:11,load,loads,11,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,1,['load'],['loads']
Performance,// All FP constants are loaded from the constant pool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:24,load,loaded,24,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['load'],['loaded']
Performance,"// All FP registers must be explicitly defined, so load a 0 instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:51,load,load,51,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,1,['load'],['load']
Performance,// All GPR and vector loads can be unaligned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:22,load,loads,22,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['loads']
Performance,"// All analysis has completed and has determined that fusion is legal; // and profitable. At this point, start transforming the code and; // perform fusion.; // Execute the hoist/sink operations on preheader instructions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:141,perform,perform,141,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['perform'],['perform']
Performance,// All cached tokens were consumed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:7,cache,cached,7,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,1,['cache'],['cached']
Performance,"// All clang classes are considered loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx:36,load,loaded,36,core/metacling/src/TClingClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx,1,['load'],['loaded']
Performance,// All code for this class below this point is needed because of the; // temporary implicit conversion to uint64_t. The operator overloads are; // needed because otherwise the conversion of the parent class; // UnivariateLinearPolyBase -> TypeSize is ambiguous.; // TODO: Remove the implicit conversion.; // Casts to a uint64_t if this is a fixed-width size.; //; // This interface is deprecated and will be removed in a future version; // of LLVM in favour of upgrading uses that rely on this implicit conversion; // to uint64_t. Calls to functions that return a TypeSize should use the; // proper interfaces to TypeSize.; // In practice this is mostly calls to MVT/EVT::getSizeInBits().; //; // To determine how to upgrade the code:; //; // if (<algorithm works for both scalable and fixed-width vectors>); // use getKnownMinValue(); // else if (<algorithm works only for fixed-width vectors>) {; // if <algorithm can be adapted for both scalable and fixed-width vectors>; // update the algorithm and use getKnownMinValue(); // else; // bail out early for scalable vectors and use getFixedValue(); // },MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h:773,scalab,scalable,773,interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h,3,['scalab'],['scalable']
Performance,"// All extending loads extend to i32, so even if the value in; // memory is shorter than 32 bits, it will be i32 after the load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:17,load,loads,17,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,2,['load'],"['load', 'loads']"
Performance,// All function calls in the inlined function must get 'strictfp'; // attribute to prevent undesirable optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:103,optimiz,optimizations,103,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,1,['optimiz'],['optimizations']
Performance,// All getCopyFromReg ops must precede any getMemcpys to prevent the; // scheduler clobbering a register before it has been copied.; // The stages are:; // 1. CopyFromReg (and load) arg & vararg registers.; // 2. Chain CopyFromReg nodes into a TokenFactor.; // 3. Memcpy 'byVal' args & push final InVals.; // 4. Chain mem ops nodes into a TokenFactor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp:176,load,load,176,interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp,2,['load'],['load']
Performance,// All globals dynamically protected by MTE must have their address tags; // synthesized. This is done by having the loader stash the tag in the GOT; // entry. Force all tagged globals (even ones with internal linkage) through; // the GOT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp:117,load,loader,117,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp,1,['load'],['loader']
Performance,// All its uses (except phi) should load from stored mem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp:36,load,load,36,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,1,['load'],['load']
Performance,// All its uses should load from stored mem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp:23,load,load,23,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,1,['load'],['load']
Performance,// All load/store instructions must use the same offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:7,load,load,7,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,1,['load'],['load']
Performance,"// All loads have known dependences inside F, so the global can be localized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:7,load,loads,7,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['load'],['loads']
Performance,// All loads must share the same chain,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:7,load,loads,7,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loads']
Performance,// All loads must share the same chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:7,load,loads,7,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loads']
Performance,// All modules provided by any files we tried and failed to load are now; // unavailable; includes of those modules should now be handled textually.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:60,load,load,60,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['load'],['load']
Performance,// All of the Buckets produced by best-effort cache-line algorithm.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Randstruct.cpp:46,cache,cache-line,46,interpreter/llvm-project/clang/lib/AST/Randstruct.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Randstruct.cpp,1,['cache'],['cache-line']
Performance,// All of the Function*'s in the MiscompiledFunctions list are in the old; // module. Update this list to include all of the functions in the; // optimized and loop extracted module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:146,optimiz,optimized,146,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,1,['optimiz'],['optimized']
Performance,"// All of the XOR, OR and CMP use ALU ports, and data dependency will become the; // bottleneck after this transform on high end CPU. So this max leaf node; // limitation is guard cmp+ccmp will be profitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:85,bottleneck,bottleneck,85,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['bottleneck'],['bottleneck']
Performance,// All of the below are only true if the loaded pointer is produced; // by the dependent instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:41,load,loaded,41,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['load'],['loaded']
Performance,// All our optimizations involve subtracting 1 from the immediate and forming; // an ADDI. Make sure the new immediate is valid for an ADDI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:11,optimiz,optimizations,11,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['optimiz'],['optimizations']
Performance,// All recorded sections are candidates for load-address patching.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:44,load,load-address,44,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,1,['load'],['load-address']
Performance,// All references from second operand of store (destination address); // can be considered write-only if they're not referenced by any; // non-store instruction. References from first operand of store; // (stored value) can't be treated either as read- or as write-only; // so we add them to RefEdges as we do with all other instructions; // except non-volatile load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:362,load,load,362,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,1,['load'],['load']
Performance,"// All remaining transformation depend on the value of the mask, which is; // not known at compile time for scalable vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:108,scalab,scalable,108,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['scalab'],['scalable']
Performance,"// All stores must be the same size to ensure that we are writing all of the; // bytes in the wide value.; // This store should have exactly one use as a chain operand for another; // store in the merging set. If there are other chain uses, then the; // transform may not be safe because order of loads/stores outside of this; // set may not be preserved.; // TODO: We could allow multiple sizes by tracking each stored byte.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:297,load,loads,297,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loads']
Performance,"// All the code from this point onwards assumes fixed width vectors, but it's; // possible that some of the combinations could be made to work for scalable; // vectors too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:147,scalab,scalable,147,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['scalab'],['scalable']
Performance,// All the loads are scalar loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:11,load,loads,11,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,2,['load'],['loads']
Performance,// All the optimizations depend on the format string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:11,optimiz,optimizations,11,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['optimiz'],['optimizations']
Performance,// All the top bits are guaranteed to be zero - inform the optimizers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:59,optimiz,optimizers,59,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['optimiz'],['optimizers']
Performance,// All the uses should be loads and stores now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:26,load,loads,26,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['load'],['loads']
Performance,"// All threads will load/unload the same library",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingLoadUnloadFileTests.cxx:20,load,load,20,core/metacling/test/TClingLoadUnloadFileTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingLoadUnloadFileTests.cxx,1,['load'],['load']
Performance,// All use must be dominated by the load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:36,load,load,36,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['load'],['load']
Performance,"// All use must be dominated by the load/store.; // If Ptr may be folded in addressing mode of other use, then it's; // not profitable to do this transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:36,load,load,36,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['load'],['load']
Performance,"// All user input files reside at the index range [0, NumUserInputs), and; // system input files reside at [NumUserInputs, NumInputs). For explicitly; // loaded module files, ignore missing inputs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:154,load,loaded,154,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['load'],['loaded']
Performance,// All users should be a shift by constant less than or equal to 32. This; // ensures we'll do this optimization for each of them to produce an; // add/sub+sext_inreg they can all share.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:100,optimiz,optimization,100,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['optimiz'],['optimization']
Performance,// All-one mask is modelled as no-mask following the convention for masked; // load/store/gather/scatter. Initialize BlockMask to no-mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:79,load,load,79,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['load'],['load']
Performance,"// All-zero GEP is a no-op, unless it performs a vector splat.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:38,perform,performs,38,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['perform'],['performs']
Performance,// Allocate a stack slot like for any local variable to guarantee optimal; // debug info at -O0. The mem2reg pass will eliminate it when optimizing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:137,optimiz,optimizing,137,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['optimiz'],['optimizing']
Performance,// Allocate pre-loaded kernel arguemtns. Arguments to be preloading must be; // sequential starting from the first argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:16,load,loaded,16,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['load'],['loaded']
Performance,"// Allocate the generational 'most recent' cache now, if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h:43,cache,cache,43,interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h,1,['cache'],['cache']
Performance,"// Allocate undef operands. This is a separate step because in a situation; // like ` = OP undef %X, %X` both operands need the same register assign; // so we should perform the normal assignment first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:166,perform,perform,166,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['perform'],['perform']
Performance,// Allow exactly one instruction to be speculated regardless of its cost; // (as long as it is safe to do so).; // This is intended to flatten the CFG even if the instruction is a division; // or other expensive operation. The speculation of an expensive instruction; // is expected to be undone in CodeGenPrepare if the speculation has not; // enabled further IR optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:364,optimiz,optimizations,364,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['optimiz'],['optimizations']
Performance,"// Allow exactly one numeric character for the additional refinement; // step parameter. This is reasonable for all currently-supported; // operations and architectures because we would expect that a larger value; // of refinement steps would cause the estimate ""optimization"" to; // under-perform the native operation. Also, if the estimate does not; // converge quickly, it probably will not ever converge, so further; // refinement steps will not produce a better answer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:263,optimiz,optimization,263,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"// Allow explicitly setting mayLoad = 1, even when the pattern has no loads.; // Some targets translate immediates to loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:70,load,loads,70,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,2,['load'],['loads']
Performance,// Allow multi-threaded access if there is a .dwp file as the CU index and; // TU index might be accessed from multiple threads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp:9,multi-thread,multi-threaded,9,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,1,['multi-thread'],['multi-threaded']
Performance,// Allow one node which will masked along with any loads found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,load,loads,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loads']
Performance,"// Allow optional post-processing of object inserted in cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h:56,cache,cache,56,roofit/roofitcore/inc/RooCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h,2,['cache'],['cache']
Performance,// Allow re-materialization of PIC load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:35,load,load,35,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['load'],['load']
Performance,// Allow stack slot loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:20,load,loads,20,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['load'],['loads']
Performance,"// Allow the object writer a chance to perform post-layout binding (for; // example, to set the index fields in the symbol data).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:39,perform,perform,39,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,1,['perform'],['perform']
Performance,// Allow to selectively load BTF information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/BTF/BTFParser.h:24,load,load,24,interpreter/llvm-project/llvm/include/llvm/DebugInfo/BTF/BTFParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/BTF/BTFParser.h,1,['load'],['load']
Performance,// Allow wider loads if they are sufficiently aligned to avoid memory faults; // and if the original load is simple.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:15,load,loads,15,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,2,['load'],"['load', 'loads']"
Performance,// Already cached sizes for this address space.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:11,cache,cached,11,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,1,['cache'],['cached']
Performance,// Already multiple stores forward to this load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:43,load,load,43,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['load'],['load']
Performance,"// Already queued or processing queries: switch to asynchronous mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:11,queue,queued,11,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['queue'],['queued']
Performance,// Also allow power of 2 integer types that have at least 8 bits and fit in; // a register. These types are common in frontend languages and targets; // usually support loads of these types.; // TODO: We could relax this to any integer that fits in a register and rely; // on ABI alignment and padding in the table to allow the load to be widened.; // Or we could widen the constants and truncate the load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:169,load,loads,169,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,3,['load'],"['load', 'loads']"
Performance,// Also avoid sibcall optimization if either caller or callee uses struct; // return semantics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:22,optimiz,optimization,22,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['optimiz'],['optimization']
Performance,// Also avoid sibcall optimization if we're an sret return fn and the callee; // is incompatible. See comment in LowerReturn about why hasStructRetAttr is; // insufficient.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:22,optimiz,optimization,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['optimiz'],['optimization']
Performance,// Also avoid tail call optimization if either caller or callee uses struct; // return semantics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:24,optimiz,optimization,24,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['optimiz'],['optimization']
Performance,"// Also check if our value operand is defined by a load of the same memory; // location, and the memory state is the same as it was then (otherwise, it; // could have been overwritten later. See test32 in; // transforms/DeadStoreElimination/simple.ll).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:51,load,load,51,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['load'],['load']
Performance,// Also invalidate the Alias Analysis cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:38,cache,cache,38,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['cache'],['cache']
Performance,// Also keep natural memory operands second if the loaded value is; // only used here. Several comparisons have memory forms.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:51,load,loaded,51,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['load'],['loaded']
Performance,// Also move the copy from the scratch rsrc descriptor into the loop; // to allow it to be optimized away.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:91,optimiz,optimized,91,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['optimiz'],['optimized']
Performance,"// Also need to check the dest regclass, in case we're trying to optimize; // something like:; // %1(gpr) = PHI %2(fpr), bb1, %(fpr), bb2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:65,optimiz,optimize,65,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['optimiz'],['optimize']
Performance,// Also perform the normal invalidation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:8,perform,perform,8,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['perform'],['perform']
Performance,// Also take the opportunity here to try to do some optimization.; // Try to convert this into a G_SUB if the offset is a 0-x negate idiom.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:52,optimiz,optimization,52,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['optimiz'],['optimization']
Performance,// Alternate float MMA loads,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:23,load,loads,23,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['load'],['loads']
Performance,// Alternate float MMA loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:23,load,loads,23,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['load'],['loads']
Performance,"// Although we checked in the beginning that ID is not in the cache, it is; // possible that during recursion and different modification ID was inserted; // into the cache. So if we find it, just return it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:62,cache,cache,62,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['cache'],['cache']
Performance,"// Always allow upcasts, and perform no dynamic check for them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h:29,perform,perform,29,interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,1,['perform'],['perform']
Performance,"// Always call EvalInstance(0) to insure the loading; // of the branches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx:45,load,loading,45,tree/treeplayer/src/TSelectorDraw.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx,1,['load'],['loading']
Performance,"// Always convert switches to br_tables unless there is only one case, which; // is equivalent to a simple branch. This reduces code size for wasm, and we; // defer possible jump table optimizations to the VM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:185,optimiz,optimizations,185,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['optimiz'],['optimizations']
Performance,"// Always emit type metadata on non-available_externally definitions, and on; // available_externally definitions if we are performing whole program; // devirtualization. For WPD we need the type metadata on all vtable; // definitions to ensure we associate derived classes with base classes; // defined in headers but with a strong definition only in a shared library.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:124,perform,performing,124,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['perform'],['performing']
Performance,"// Always fold if there is one use, or if we're optimizing for size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:48,optimiz,optimizing,48,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['optimiz'],['optimizing']
Performance,// Always generate a memcpy of alignment 1 here because we don't know; // the alignment of the src pointer. Other optimizations can infer; // better alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:114,optimiz,optimizations,114,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['optimiz'],['optimizations']
Performance,// Always inline the outlined function if optimizations are enabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:42,optimiz,optimizations,42,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['optimiz'],['optimizations']
Performance,"// Always keep a floating-point constant second, since comparisons with; // zero can use LOAD TEST and comparisons with other constants make a; // natural memory operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:89,LOAD,LOAD,89,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['LOAD'],['LOAD']
Performance,"// Always perform integer promotion before checking type equality.; // Otherwise, e.g. (bool) a + (bool) b could trigger a backend assertion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h:10,perform,perform,10,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,1,['perform'],['perform']
Performance,"// Always perform this optimization before types are legal. If the target; // prefers, also try this after legalization to catch stores that were created; // by intrinsics or other nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,perform,perform,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,// Always return. Either we cached out or we just emitted an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:28,cache,cached,28,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,1,['cache'],['cached']
Performance,// Always treat non-scalable MVTs as smaller than scalable MVTs for the; // purposes of ordering.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:20,scalab,scalable,20,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,2,['scalab'],['scalable']
Performance,"// Always try to replace 16 bit load with 32 bit zero extending.; // Code size is the same, and there is sometimes a perf advantage; // from eliminating a false dependence on the upper portion of; // the register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:32,load,load,32,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,1,['load'],['load']
Performance,"// An FCVT[SU] instruction performs: convertToInt(Val * 2^fbits) where fbits; // is between 1 and 32 for a destination w-register, or 1 and 64 for an; // x-register.; //; // By this stage, we've detected (fp_to_[su]int (fmul Val, THIS_NODE)) so we; // want THIS_NODE to be 2^fbits. This is much easier to deal with using; // integers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:27,perform,performs,27,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['perform'],['performs']
Performance,// An MFENCE is modeled as a load but isn't vulnerable to misspeculation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:29,load,load,29,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['load'],['load']
Performance,// An ObjC-Identified object can't alias a load if it is never locally stored.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp:43,load,load,43,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp,1,['load'],['load']
Performance,// An address that can be used in a non-macro load or store,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h:46,load,load,46,interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h,1,['load'],['load']
Performance,"// An alternative would move this code to each of the function; // calling LoadTree (and to overload a few more).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:75,Load,LoadTree,75,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['Load'],['LoadTree']
Performance,"// An empty inline asm with input reg == output reg.; // An opaque no-op cast, basically.; // This prevents code bloat as a result of rematerializing trivial definitions; // such as constants or global addresses at every load and store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:221,load,load,221,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,1,['load'],['load']
Performance,"// An end user of a pointer argument is a load or store instruction.; // Returns std::nullopt if this load or store is not based on the argument.; // Return true if we can promote the instruction, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:42,load,load,42,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,2,['load'],['load']
Performance,"// An entry value is a register location -- but with an updated; // expression. The register location of such DBG_VALUE is always the; // one from the entry DBG_VALUE, it does not matter if the entry value; // was copied in to another register due to some optimizations.; // Non-entry value register locations are like the source; // DBG_VALUE, but with the register number from this VarLoc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:256,optimiz,optimizations,256,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,1,['optimiz'],['optimizations']
Performance,// An error margin is necessary because of poor performance of the generic RP; // tracker and can be adjusted up for tuning heuristics to try and more; // aggressively reduce register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:48,perform,performance,48,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['perform'],['performance']
Performance,"// An explicit instantiation of a template has weak linkage, since; // explicit instantiations can occur in multiple translation units; // and must all be equivalent. However, we are not allowed to; // throw away these explicit instantiations.; //; // CUDA/HIP: For -fno-gpu-rdc case, device code is limited to one TU,; // so say that CUDA templates are either external (for kernels) or internal.; // This lets llvm perform aggressive inter-procedural optimizations. For; // -fgpu-rdc case, device function calls across multiple TU's are allowed,; // therefore we need to follow the normal linkage paradigm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:416,perform,perform,416,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,2,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,// An image load instruction with TFE/LWE only conditionally writes to its; // result registers. Initialize them to zero so that we always get well; // defined result values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp:12,load,load,12,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,1,['load'],['load']
Performance,"// An implementation implicitly has the availability of the interface.; // Unless it is ""+load"" method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:90,load,load,90,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['load'],['load']
Performance,// An implicitly-loaded module file should have its module listed in some; // module map file that we've already loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:17,load,loaded,17,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,2,['load'],['loaded']
Performance,// An incomplete TypeString stub is placed in the cache for this RecordType; // so that recursive calls to this RecordType will use it whilst building a; // complete TypeString for this RecordType.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:50,cache,cache,50,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,1,['cache'],['cache']
Performance,// An index was successfully created and we will be able to load metadata; // on-demand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:60,load,load,60,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,1,['load'],['load']
Performance,"// An init list can be an lvalue if it is bound to a reference and; // contains only one element. In that case, we look at that element; // for an exact classification. Init list creation takes care of the; // value kind for us, so we only need to fine-tune.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:253,tune,tune,253,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,1,['tune'],['tune']
Performance,"// An instruction scheduler typically runs on unbundled instructions, however; // other passes may query the latency of a bundled instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:109,latency,latency,109,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['latency'],['latency']
Performance,"// An interleaved load will look like this for Factor=3:; // %wide.vec = load <12 x i32>, ptr %3, align 4; // %strided.vec = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec1 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>; // %strided.vec2 = shufflevector %wide.vec, poison, <4 x i32> <stride mask>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:18,load,load,18,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,2,['load'],['load']
Performance,// An optimization remark emitter. Used to report failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp:6,optimiz,optimization,6,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,1,['optimiz'],['optimization']
Performance,// An optimized implementation for this simple case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:6,optimiz,optimized,6,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,6,['optimiz'],['optimized']
Performance,"// An option to enable unsafe alias results from the GlobalsModRef analysis.; // When enabled, GlobalsModRef will provide no-alias results which in extremely; // rare cases may not be conservatively correct. In particular, in the face of; // transforms which cause asymmetry between how effective getUnderlyingObject; // is for two pointers, it may produce incorrect results.; //; // These unsafe results have been returned by GMR for many years without; // causing significant issues in the wild and so we provide a mechanism to; // re-enable them for users of LLVM that have a particular performance; // sensitivity and no known issues. The option also makes it easy to evaluate; // the performance impact of these results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:590,perform,performance,590,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,2,['perform'],['performance']
Performance,// An optional ObjectCache to be notified of compiled objects and used to; // perform lookup of pre-compiled code to avoid re-compilation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:78,perform,perform,78,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,1,['perform'],['perform']
Performance,// An optional name of a performance counter that can be used to measure; // cycles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:25,perform,performance,25,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,1,['perform'],['performance']
Performance,// An optional name of a performance counter that can be used to measure; // uops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:25,perform,performance,25,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,1,['perform'],['performance']
Performance,"// An rvalue for an integral bit-field (9.6) can be converted to an; // rvalue of type int if int can represent all the values of the; // bit-field; otherwise, it can be converted to unsigned int if; // unsigned int can represent all the values of the bit-field. If; // the bit-field is larger yet, no integral promotion applies to; // it. If the bit-field has an enumerated type, it is treated as any; // other value of that type for promotion purposes (C++ 4.5p3).; // FIXME: We should delay checking of bit-fields until we actually perform the; // conversion.; //; // FIXME: In C, only bit-fields of types _Bool, int, or unsigned int may be; // promoted, per C11 6.3.1.1/2. We promote all bit-fields (including enum; // bit-fields and those whose underlying type is larger than int) for GCC; // compatibility.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:535,perform,perform,535,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['perform'],['perform']
Performance,// An unknown load depends on all stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,load,load,14,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['load'],['load']
Performance,// An unknown store depends on all stores and loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:46,load,loads,46,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['load'],['loads']
Performance,"// Analyze \p SymbolicPHI, a SCEV expression of a phi node, and check if the; // computation that updates the phi follows the following pattern:; // (SExt/ZExt ix (Trunc iy (%SymbolicPHI) to ix) to iy) + InvariantAccum; // which correspond to a phi->trunc->sext/zext->add->phi update chain.; // If so, try to see if it can be rewritten as an AddRecExpr under some; // Predicates. If successful, return them as a pair. Also cache the results; // of the analysis.; //; // Example usage scenario:; // Say the Rewriter is called for the following SCEV:; // 8 * ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // where:; // %X = phi i64 (%Start, %BEValue); // It will visitMul->visitAdd->visitSExt->visitTrunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be igno",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:423,cache,cache,423,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['cache'],['cache']
Performance,// Analyze all uses and calculate increase in size. Perform the optimization; // only if there is no increase in size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:52,Perform,Perform,52,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,2,"['Perform', 'optimiz']","['Perform', 'optimization']"
Performance,"// Analyze all uses of 'add'. If the output of 'add' is used as an address; // in the base+immediate addressing mode load/store instructions, see if; // they can be updated to use the immediate value as an offet. Thus,; // providing us the opportunity to eliminate 'add'.; // Ex: Rx= add(Rt,#12); // memw(Rx+#0) = Rs; // This can be replaced with memw(Rt+#12) = Rs; //; // This transformation is only performed if all uses can be updated and; // the offset isn't required to be constant extended.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:117,load,load,117,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,2,"['load', 'perform']","['load', 'performed']"
Performance,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:66,load,load,66,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,6,['load'],"['load', 'loads']"
Performance,"// Analyze the given select instruction, returning true if it cannot be; // understood. It is assumed that MI->isSelect() is true.; //; // When successful, return the controlling condition and the operands that; // determine the true and false result values.; //; // Result = SELECT Cond, TrueOp, FalseOp; //; // Lanai can optimize certain select instructions, for example by predicating; // the instruction defining one of the operands and sets Optimizable to true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:323,optimiz,optimize,323,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,2,"['Optimiz', 'optimiz']","['Optimizable', 'optimize']"
Performance,// Analyze webs and determine those that cannot be optimized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:51,optimiz,optimized,51,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,1,['optimiz'],['optimized']
Performance,// And actually perform the cast sinking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:16,perform,perform,16,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['perform'],['perform']
Performance,// And cache the (real) result for the future.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:7,cache,cache,7,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,1,['cache'],['cache']
Performance,"// And clamp it, because OOB load is an immediate UB,; // while shift overflow would have *just* been poison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:29,load,load,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['load'],['load']
Performance,// And kind-of perform the result swap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:15,perform,perform,15,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['perform'],['perform']
Performance,"// And load it! While the load is not legal, legalizing it is obvious.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:7,load,load,7,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,2,['load'],['load']
Performance,// And load the address point from the VTT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:7,load,load,7,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['load'],['load']
Performance,// And that the new unaligned load will be fast.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,load,load,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,// And update the type cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:23,cache,cache,23,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,2,['cache'],['cache']
Performance,// And we need to promote i64 loads/stores into vector load/store,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:30,load,loads,30,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,2,['load'],"['load', 'loads']"
Performance,"// Annotate the load as an invariant load iff inside an instance method; // and ivar belongs to instance method's class and one of its super class.; // This check is needed because the ivar offset is a lazily; // initialised value that may depend on objc_msgSend to perform a fixup on; // the first message dispatch.; //; // An additional opportunity to mark the load as invariant arises when the; // base of the ivar access is a parameter to an Objective C method.; // However, because the parameters are not available in the current; // interface, we cannot perform this check.; //; // Note that for direct methods, because objc_msgSend is skipped,; // and that the method may be inlined, this optimization actually; // can't be performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:16,load,load,16,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,7,"['load', 'optimiz', 'perform']","['load', 'optimization', 'perform', 'performed']"
Performance,"// Anonymous namespace.; ////////////////////////////////////////////////////////////////////////////////; /// Fill the cache buffer with the branches in the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:120,cache,cache,120,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],['cache']
Performance,// Another limit for the alias checks: The maximum distance between load/store; // instructions where alias checks are done.; // This limit is useful for very large basic blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:68,load,load,68,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['load']
Performance,"// Another special-case: SRL/SRA is basically zero/sign-extending a narrower; // value, or it may be shifting a higher subword, half or byte into the; // lowest bits.; // Only handle shift with constant shift amount, and the shiftee must be a; // load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:247,load,load,247,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,// AntiDepBreakMode - Type of anti-dependence breaking that should; // be performed before post-RA scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:74,perform,performed,74,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,1,['perform'],['performed']
Performance,// Any MVE load/store,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:11,load,load,11,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['load'],['load']
Performance,"// Any ModRef post-dominated by Load doesn't matter, also Load and Store; // themselves can be ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:32,Load,Load,32,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,2,['Load'],['Load']
Performance,"// Any analyses cached for this SCC are no longer precise as the shape; // has changed by introducing this cycle. However, we have taken care to; // update the proxies so it remains valide.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:16,cache,cached,16,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,1,['cache'],['cached']
Performance,// Any inter-function unconditional jump is considered tail call at; // this point. This is not 100% accurate and could further be; // optimized based on some source annotation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp:135,optimiz,optimized,135,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp,1,['optimiz'],['optimized']
Performance,// Any legal vector type can be splatted more efficiently than; // loading/spilling from memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:67,load,loading,67,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['loading']
Performance,// Any non-call uses of the result of llvm.type.checked.load will; // prevent us from optimizing away the llvm.type.test.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:56,load,load,56,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,2,"['load', 'optimiz']","['load', 'optimizing']"
Performance,// Any other non-load instruction might take address!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp:17,load,load,17,interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,1,['load'],['load']
Performance,"// Any phi, if it is removed, may affect other phis (make them dead).; // For each removed phi, collect the potentially affected phis and add; // them back to the queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:163,queue,queue,163,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,1,['queue'],['queue']
Performance,"// Any possible offset could be multiple of GEP stride. And any valid; // offset is multiple of load alignment, so checking only multiples of bigger; // one is sufficient to say results' equality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:96,load,load,96,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['load'],['load']
Performance,"// Any register load of a 64-bit value really requires 2 32-bit moves. For all; // practical purposes, the extra mov 0 to load a 64-bit is free. As used,; // this will enable reducing 64-bit operations the 32-bit, which is always; // good.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:16,load,load,16,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,2,['load'],['load']
Performance,// Anything using the load now uses the current value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:22,load,load,22,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['load'],['load']
Performance,// Append the cached TypeString if we have one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:14,cache,cached,14,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,2,['cache'],['cached']
Performance,// Append this load onto the list of split loads so we can find it later; // to rewrite the stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:15,load,load,15,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,2,['load'],"['load', 'loads']"
Performance,"// Apply ""llvm.mem.parallel_loop_access"" metadata to load/stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGLoopInfo.cpp:53,load,load,53,interpreter/llvm-project/clang/lib/CodeGen/CGLoopInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGLoopInfo.cpp,1,['load'],['load']
Performance,// Apply a post-processing optimizing block placement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:27,optimiz,optimizing,27,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['optimiz'],['optimizing']
Performance,"// Apply further optimizations for special cases; // (select (x != 0), -1, 0) -> neg & sbb; // (select (x == 0), 0, -1) -> neg & sbb",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:17,optimiz,optimizations,17,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,1,['optimiz'],['optimizations']
Performance,// Apply preemptive heuristics based on the total latency and resources; // inside and outside this zone. Potential stalls should be considered before; // following this policy.; // Compute the critical resource outside the zone.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:50,latency,latency,50,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['latency'],['latency']
Performance,// Apply the given CPU name as the 'tune-cpu' so that the optimizer can; // favor this processor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:36,tune,tune-cpu,36,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,2,"['optimiz', 'tune']","['optimizer', 'tune-cpu']"
Performance,"// Apply the named return value optimization for this return statement,; // which means doing nothing: the appropriate result has already been; // constructed into the NRVO variable.; // If there is an NRVO flag for this variable, set it to 1 into indicate; // that the cleanup code should not destroy the variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:32,optimiz,optimization,32,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['optimiz'],['optimization']
Performance,"// Apply tracking optimization here. Default strategy is to track components; // of RooAddPdfs and RooRealSumPdfs. If these components are a RooProdPdf; // or a RooProduct respectively, track the components of these products instead; // of the product term",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx:18,optimiz,optimization,18,roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,2,['optimiz'],['optimization']
Performance,// Are there other uses of the loaded value than the operation?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:31,load,loaded,31,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['load'],['loaded']
Performance,// Are there stores / loads / calls between them?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:22,load,loads,22,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['load'],['loads']
Performance,// Are we allowed to form a atomic load or store of this type?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:35,load,load,35,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['load'],['load']
Performance,"// ArgDbgValues are hoisted to the beginning of the entry block. So we; // should only emit as ArgDbgValue if the dbg.value intrinsic describes a; // variable that also is a param.; //; // Although, if we are at the top of the entry block already, we can still; // emit using ArgDbgValue. This might catch some situations when the; // dbg.value refers to an argument that isn't used in the entry block, so; // any CopyToReg node would be optimized out and the only way to express; // this DBG_VALUE is by using the physical reg (or FI) as done in this; // method. ArgDbgValues are hoisted to the beginning of the entry block. So; // we should only emit as ArgDbgValue if the Variable is an argument to the; // current function, and the dbg.value intrinsic is found in the entry; // block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:438,optimiz,optimized,438,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['optimiz'],['optimized']
Performance,"// Arguments to functions or returns from functions are inherently; // escaping, so we can immediately classify those as not aliasing any; // non-addr-taken globals.; //; // (Transitive) loads from a global are also safe - if this aliased; // another global, its address would escape, so no alias.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:187,load,loads,187,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['load'],['loads']
Performance,// Arm Performance Libraries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:7,Perform,Performance,7,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,2,['Perform'],['Performance']
Performance,"// As C11 defines, a zero sized bit-field defines a barrier, so; // fields after and before it should be race condition free.; // The AAPCS acknowledges it and imposes no restritions when the; // natural container overlaps a zero-length bit-field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp:105,race condition,race condition,105,interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,1,['race condition'],['race condition']
Performance,"// As SHUFPD uses a single LHS/RHS element per lane, we can always; // perform the shuffle once the lanes have been shuffled in place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:71,perform,perform,71,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['perform']
Performance,"// As a compile-time optimization, avoid allocating and evaluating an MCExpr; // tree for (Hi - Lo) when Hi and Lo are offsets into the same fragment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:21,optimiz,optimization,21,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,1,['optimiz'],['optimization']
Performance,"// As a heuristic prune all diagnostics not in the main file. Currently; // the majority of warnings in headers are false positives. These; // are largely caused by configuration state, e.g. preprocessor; // defined code, etc.; //; // Note that this is also a performance optimization. Analyzing; // headers many times can be expensive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:260,perform,performance,260,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"// As a heuristic, if some headers don't have a weight, give them the; // minimum weight seen (not to disrupt the existing trends too much by; // using a weight that's in the general range of the other headers' weights,; // and the minimum seems to perform better than the average.); // FIXME: better update in the passes that drop the header weight.; // If no headers have a weight, give them even weight (use weight 1).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:249,perform,perform,249,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,1,['perform'],['perform']
Performance,"// As a very special optimization, in ARC++, if the l-value is the; // result of a non-volatile assignment, do a simple retain of the; // result of the call to objc_storeWeak instead of reloading.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:21,optimiz,optimization,21,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['optimiz'],['optimization']
Performance,"// As an optimization hint for the linker, before the JALR we add:; // .reloc tmplabel, R_{MICRO}MIPS_JALR, symbol; // tmplabel:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:9,optimiz,optimization,9,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['optimiz'],['optimization']
Performance,"// As an optimization, if all incoming values in the new PhiNode (which is a; // subset of the incoming values of the old PHI node) have the same value,; // eliminate the PHI Node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:9,optimiz,optimization,9,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,1,['optimiz'],['optimization']
Performance,"// As an optimization, we can clear the SignExtended flag because; // sext(zext(a)) = zext(a). Verified in @sext_zext in split-gep.ll.; //; // Clear the NonNegative flag, because zext(a) >= 0 does not imply a >= 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:9,optimiz,optimization,9,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,1,['optimiz'],['optimization']
Performance,"// As before, model no mask as a trivial mask if it'll let us do an; // optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:72,optimiz,optimization,72,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['optimiz'],['optimization']
Performance,"// As currently implemented in clang, NVPTX code has no standard library to; // speak of. Headers provide a standard-ish library implementation, but many; // of the signatures are wrong -- for example, many libm functions are not; // extern ""C"".; //; // libdevice, an IR library provided by nvidia, is linked in by the front-end,; // but only used functions are provided to llvm. Moreover, most of the; // functions in libdevice don't map precisely to standard library functions.; //; // FIXME: Having no standard library prevents e.g. many fastmath; // optimizations, so this situation should be fixed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:554,optimiz,optimizations,554,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,1,['optimiz'],['optimizations']
Performance,"// As described the MIPSR6 spec, the compact branches that compare registers; // must:; // a) Not use the zero register.; // b) Not use the same register twice.; // c) rs < rt for bnec, beqc.; // NB: For this case, the encoding will swap the operands as their; // ordering doesn't matter. GAS performs this transformation too.; // Hence, that constraint does not have to be enforced.; //; // The compact branches that branch iff the signed addition of two registers; // would overflow must have rs >= rt. That can be handled like beqc/bnec with; // operand swapping. They do not have restriction of using the zero register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:293,perform,performs,293,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['perform'],['performs']
Performance,"// As long as the user is another old PHI node, then even if we don't; // rewrite it, the PHI web we're considering won't have any users; // outside itself, so it'll be dead.; // example:; // bb.0:; // %0 = amxcast ...; // bb.1:; // %1 = amxcast ...; // bb.2:; // %goodphi = phi %0, %1; // %3 = amxcast %goodphi; // bb.3:; // %goodphi2 = phi %0, %goodphi; // %4 = amxcast %goodphi2; // When optimizeAMXCastFromPhi process %3 and %goodphi, %goodphi2 is; // outside the phi-web, so the combination stop When; // optimizeAMXCastFromPhi process %4 and %goodphi2, the optimization; // will be done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp:391,optimiz,optimizeAMXCastFromPhi,391,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,3,['optimiz'],"['optimization', 'optimizeAMXCastFromPhi']"
Performance,"// As the comparison is performed twice (by exchanging the reference; // and target readers) the element missing/added status does specify; // the comparison pass.; // By recording each missing/added elements along with its pass, it; // allows checking which elements were missing/added during each pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVCompare.h:24,perform,performed,24,interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVCompare.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVCompare.h,1,['perform'],['performed']
Performance,"// As the language options may have not been loaded yet (when; // deserializing an ASTUnit), adding keywords to the identifier table is; // deferred to Preprocessor::Initialize().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:45,load,loaded,45,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,1,['load'],['loaded']
Performance,"// As we are now support display list caching we can create, draw and; // delete mesh parts of suitable LOD (quality) here - it will be cached; // into a display list by base-class TGLLogicalShape::Draw(),; // against our id and the LOD value. So this will only occur once; // for a certain cylinder/LOD combination",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCylinder.cxx:136,cache,cached,136,graf3d/gl/src/TGLCylinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCylinder.cxx,1,['cache'],['cached']
Performance,"// As we do not modify the function here we can remove the const; // withouth breaking implicit assumptions. At the end of the day, we could; // initialize the cache eagerly which would look the same to the users.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:160,cache,cache,160,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['cache'],['cache']
Performance,"// As we scan the uses of the alloca instruction, keep track of stores,; // and decide whether all of the loads and stores to the alloca are within; // the same basic block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:106,load,loads,106,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['load'],['loads']
Performance,// Ask the ABI to load the callee. Note that This is modified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp:18,load,load,18,interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,1,['load'],['load']
Performance,// Ask the target to try folding the load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp:37,load,load,37,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,1,['load'],['load']
Performance,// Assert that the following invariants hold:; // 1. All active variables are unassigned.; // 2. All active variables form watched literals.; // 3. Unassigned variables that form watched literals are active.; // FIXME: Consider replacing these with test cases that fail if the any; // of the invariants is broken. That might not be easy due to the; // transformations performed by `buildCNF`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:368,perform,performed,368,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,1,['perform'],['performed']
Performance,// Assert the invariant that the watched literal is always the first one; // in the clause.; // FIXME: Consider replacing this with a test case that fails if the; // invariant is broken by `updateWatchedLiterals`. That might not be easy; // due to the transformations performed by `buildCNF`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:268,perform,performed,268,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,1,['perform'],['performed']
Performance,// Assign a default latency for this write.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp:20,latency,latency,20,interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,4,['latency'],['latency']
Performance,// Assign the Latency field of NodeSUnit using target-provided information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:14,Latency,Latency,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['Latency'],['Latency']
Performance,// Assign the Latency field of SU using target-provided information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,Latency,Latency,14,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['Latency'],['Latency']
Performance,"// Assign the kIsOnHeap bit in 'bits' based on the pattern seen in uniqueID.; // See Storage::FilledByObjectAlloc for details.; // This routine is marked as inline with attribute noinline so that it never; // inlined and thus can be used in a valgrind suppression file to suppress; // the known/intentional uninitialized memory read but still be a 'quick'; // function call to avoid losing performance at object creation.; // Moving the function into the source file, results in doubling of the; // overhead (compared to inlining)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TStorage.h:390,perform,performance,390,core/base/inc/TStorage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TStorage.h,1,['perform'],['performance']
Performance,// Assign the position number to the instruction. Note that we are going to; // move some instructions during the optimization however there will never; // be a need to move two instructions before any selected instruction. So to; // avoid multiple positions' updates during moves we just increase position; // counter by two leaving a free space for instructions which will be moved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp:114,optimiz,optimization,114,interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,1,['optimiz'],['optimization']
Performance,"// Assign zero count for remaining probes without sample hits to; // differentiate from probes optimized away, of which the counts are unknown; // and will be inferred by the compiler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp:95,optimiz,optimized,95,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp,1,['optimiz'],['optimized']
Performance,// Assume a 3cy latency for fp arithmetic ops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:16,latency,latency,16,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,1,['latency'],['latency']
Performance,// Assume a 3cy latency for fp select ops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:16,latency,latency,16,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['latency'],['latency']
Performance,// Assume a cache line size of 64 bytes if no size is set in RISCVSubtarget.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:12,cache,cache,12,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,1,['cache'],['cache']
Performance,"// Assume all Objective-C methods follow Cocoa Memory Management rules.; // FIXME: Does the non-threaded performSelector family really belong here?; // The selector could be, say, @selector(copy).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:105,perform,performSelector,105,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,1,['perform'],['performSelector']
Performance,// Assume cross register banks copies are as expensive as loads.; // FIXME: Do we want some more target hooks?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,load,loads,58,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loads']
Performance,// Assume loads from different basic blocks are unsafe to move.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:10,load,loads,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['load'],['loads']
Performance,// Assume ordered loads and stores may have a loop carried dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:18,load,loads,18,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['load'],['loads']
Performance,// Assume that Future CPU has the same cache line size as the others.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:39,cache,cache,39,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,1,['cache'],['cache']
Performance,"// Assume that a path spanning two iterations is a cycle, which could; // overestimate in strange cases. This allows cyclic latency to be; // estimated as the minimum slack of the vreg's depth or height.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:124,latency,latency,124,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['latency'],['latency']
Performance,"// Assume that the load and the intrinsic are connected directly with a; // chain:; // t1: i32,ch = int.load ..., ..., ..., Loc, ... // <-- C; // t2: i32,ch = load t1:1, Loc, ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:19,load,load,19,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,3,['load'],['load']
Performance,"// Assume the most general case where the switch is lowered into; // either a jump table, bit test, or a balanced binary tree consisting of; // case clusters without merging adjacent clusters with the same; // destination. We do not consider the switches that are lowered with a mix; // of jump table/bit test/binary search tree. The cost of the switch is; // proportional to the size of the tree or the size of jump table range.; //; // NB: We convert large switches which are just used to initialize large phi; // nodes to lookup tables instead in simplifycfg, so this shouldn't prevent; // inlining those. It will prevent inlining in cases where the optimization; // does not (yet) fire.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:653,optimiz,optimization,653,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['optimiz'],['optimization']
Performance,"// Assume the user requests the most aggressive unrolling, even if the rest of; // the code is optimized using a lower setting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:95,optimiz,optimized,95,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['optimiz'],['optimized']
Performance,"// Assume vscale may be larger than 1 (or the value being tuned for),; // so that scalable vectorization is slightly favorable over fixed-width; // vectorization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:58,tune,tuned,58,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,"['scalab', 'tune']","['scalable', 'tuned']"
Performance,// Assumes power of 2 memory size. Subtargets that have only naturally-aligned; // memory access need to perform additional legalization here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:105,perform,perform,105,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,1,['perform'],['perform']
Performance,// Assuming that all loads of legal types cost 1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:21,load,loads,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,1,['load'],['loads']
Performance,"// Assuming the effective width of Y is not larger than A, i.e. all bits; // from X and Y are disjoint in (X << A) | Y,; // if the mask of this AND op covers all bits of X or Y, while it covers; // no bits from the other, we can bypass this AND op. E.g.,; // ((X << A) | Y) & Mask -> Y,; // if Mask = ((1 << effective_width_of(Y)) - 1); // ((X << A) | Y) & Mask -> X << A,; // if Mask = ((1 << effective_width_of(X)) - 1) << A; // SimplifyDemandedBits in InstCombine can optimize the general case.; // This pattern aims to help other passes for a common case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:471,optimiz,optimize,471,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['optimiz'],['optimize']
Performance,"// Assumptions that are known to be false are equivalent to; // unreachable. Also, if the condition is undefined, then we make the; // choice most beneficial to the optimizer, and choose that to also be; // unreachable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:165,optimiz,optimizer,165,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['optimiz'],['optimizer']
Performance,// Asynchronous JIT link for ORC.; //; // Warning: This API is experimental and probably should not be used by anyone; // but ORC's RTDyldObjectLinkingLayer2. Internally it constructs a RuntimeDyld; // instance and uses continuation passing to perform the fix-up and finalize; // steps asynchronously.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:244,perform,perform,244,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['perform'],['perform']
Performance,"// At O0 and O1 we only run the always inliner which is more efficient. At; // higher optimization levels we run the normal inliner.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp:86,optimiz,optimization,86,interpreter/cling/lib/Interpreter/BackendPasses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp,1,['optimiz'],['optimization']
Performance,// At any optimization level above -O0 we use the Machine Scheduler and not; // the default Post RA List Scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:10,optimiz,optimization,10,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,1,['optimiz'],['optimization']
Performance,"// At higher optimization levels, try to clean up any runtime overlap and; // alignment checks inserted by the vectorizer. We want to track correlated; // runtime checks for two inner loops in the same outer loop, fold any; // common computations, hoist loop-invariant aspects out of any outer loop,; // and unswitch the runtime checks if possible. Once hoisted, we may have; // dead (or speculatable) control flows or more combining opportunities.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:13,optimiz,optimization,13,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['optimiz'],['optimization']
Performance,"// At least of the ClassInfo have not been loaded in memory yet and; // since there is no virtual base class (or we don't have enough so it; // would not make a difference) we can use the 'static' information",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:43,load,loaded,43,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['load'],['loaded']
Performance,"// At least one of the memory access instructions may access a loop; // varying object, e.g. the address of underlying object is loaded inside; // the loop, like A[B[i]]. We cannot determine direction or distance in; // those cases, and also are unable to generate any runtime checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:129,load,loaded,129,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['load'],['loaded']
Performance,"// At least one of the operands should be an extract, and the other should be; // something that is easy to convert to v1i64 type (in this case a load).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:146,load,load,146,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['load'],['load']
Performance,"// At most half of the elements can be used to hold optimized versions.; // We use the bottom to hold the optimized-into elements and the non-optimized elements; // and the top to hold the original copy of the optimized out elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:52,optimiz,optimized,52,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,4,['optimiz'],"['optimized', 'optimized-into']"
Performance,"// At now, use None by default because checks may introduce an unexpected; // performance regression or incompatibility with execute-only mappings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp:78,perform,performance,78,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp,1,['perform'],['performance']
Performance,"// At the ACLE level there's only one predicate type, svbool_t, which is; // mapped to <n x 16 x i1>. However, this might be incompatible with the; // actual type being loaded. For example, when loading doubles (i64) the; // predicate should be <n x 2 x i1> instead. At the IR level the type of; // the predicate and the data being loaded must match. Cast to the type; // expected by the intrinsic. The intrinsic itself should be defined in; // a way than enforces relations between parameter types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:169,load,loaded,169,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,3,['load'],"['loaded', 'loading']"
Performance,"// At the IR layer, all the masked load intrinsics have policy operands,; // none of the others do. All have passthru operands. For our pseudos,; // all loads have policy operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:35,load,load,35,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,2,['load'],"['load', 'loads']"
Performance,"// At the end of the first full calculation, wire the caches",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNLLVar.cxx:54,cache,caches,54,roofit/roofitcore/src/RooNLLVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNLLVar.cxx,2,['cache'],['caches']
Performance,"// At the end of the first full calculation, wire the caches. This doesn't; // need to be done in BatchMode with the RooFit driver.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/RooUnbinnedL.cxx:54,cache,caches,54,roofit/roofitcore/src/TestStatistics/RooUnbinnedL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/RooUnbinnedL.cxx,1,['cache'],['caches']
Performance,"// At the top level, we can perform a base-to-derived pointer-to-member; // conversion:; //; // - [...] where C1 is reference-related to C2 or C2 is; // reference-related to C1; //; // (Note that the only kinds of reference-relatedness in scope here are; // ""same type or derived from"".) At any other level, the class must; // exactly match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:28,perform,perform,28,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['perform'],['perform']
Performance,"// At this layer, we can key the cache off of a single class, which is much; // easier than caching each vbtable individually.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:33,cache,cache,33,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['cache'],['cache']
Performance,"// At this point more information has been loaded. This; // information might be pertinent to the normalization of the name.; // For example it might contain or be a typedef for which we don't; // have a forward declaration (eg. typedef to instance of class; // template with default parameters). So let's redo the normalization; // as the new information (eg. typedef in TROOT::GetListOfTypes) might; // lead to a different value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:43,load,loaded,43,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['load'],['loaded']
Performance,"// At this point we don't have any forward reference remaining, or temporary; // that haven't been loaded. We can safely drop RAUW support and mark cycles; // as resolved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:99,load,loaded,99,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,1,['load'],['loaded']
Performance,// At this point we have updated the state properly.; // Everything after this is merely checking to see if the return value has; // been over- or under-retained.; // Did we cache out?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:174,cache,cache,174,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,1,['cache'],['cache']
Performance,"// At this point we know how much data we have emitted. We use this value to; // compare canonical DIE offsets in analyzeContextInfo to see if a definition; // is already emitted, without being affected by canonical die offsets set; // later. This prevents undeterminism when analyze and clone execute; // concurrently, as clone set the canonical DIE offset and analyze reads it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:306,concurren,concurrently,306,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,1,['concurren'],['concurrently']
Performance,// At this point we need AT to perform the expansions and we exit if it is; // not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:31,perform,perform,31,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['perform'],['perform']
Performance,// At this point we need AT to perform the expansions; // and we exit if it is not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:31,perform,perform,31,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,2,['perform'],['perform']
Performance,"// At this point, UP.Runtime indicates that run-time unrolling is allowed.; // However, we only want to actually perform it if we don't know the trip; // count and the unroll count doesn't divide the known trip multiple.; // TODO: This decision should probably be pushed up into; // computeUnrollCount().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:113,perform,perform,113,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['perform'],['perform']
Performance,"// At this point, all update records for loaded decls are in place, so any; // fake class definitions should have become real.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:41,load,loaded,41,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['load'],['loaded']
Performance,"// At this point, offset where we need to branch does not fit into; // immediate field of the branch instruction and is not in the same; // segment as jump instruction. Therefore we will break it into couple; // instructions, where we first load the offset into register, and then we; // do branch register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:241,load,load,241,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,1,['load'],['load']
Performance,"// At this point, the code is well formed. Perform constprop, instsimplify,; // and dce.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:43,Perform,Perform,43,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,1,['Perform'],['Perform']
Performance,"// At this point, we are not going to remove any RR pairs, but we still are; // able to move RR pairs. If one of our pointers is afflicted with; // CFGHazards, we cannot perform such code motion so exit early.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:170,perform,perform,170,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['perform'],['perform']
Performance,"// At this point, we have a stack instruction that we might need to fix up.; // up. We'll handle it if it's a load or store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:110,load,load,110,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['load'],['load']
Performance,"// At this point, we have a stack instruction that we might need to; // fix up. We'll handle it if it's a load or store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:106,load,load,106,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['load'],['load']
Performance,"// At this point, we have collected all of the loads and stores we can; // pre-split, and the specific splits needed for them. We actually do the; // splitting in a specific order in order to handle when one of the loads in; // the value operand to one of the stores.; //; // First, we rewrite all of the split loads, and just accumulate each split; // load in a parallel structure. We also build the slices for them and append; // them to the alloca slices.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:47,load,loads,47,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,4,['load'],"['load', 'loads']"
Performance,"// At this point, we have split the I's block to allow one lane in wavefront; // to update the precomputed reduced value. Also, completed the codegen for; // new control flow i.e. iterative loop which perform reduction and scan using; // ComputeLoop and ComputeEnd.; // For the new control flow, we need to move branch instruction i.e.; // terminator created during SplitBlockAndInsertIfThen from I's block to; // ComputeEnd block. We also need to set up predecessor to next block when; // single lane done updating the final reduced value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp:201,perform,perform,201,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,1,['perform'],['perform']
Performance,"// At this point, we know that we perform a cross-register-bank copy.; // Check if it is expensive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:34,perform,perform,34,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['perform'],['perform']
Performance,"// At this point, we're committed to promoting the alloca using IDF's, and; // the standard SSA construction algorithm. Determine which blocks need phi; // nodes and see if we can optimize out some work by avoiding insertion of; // dead phi nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:180,optimiz,optimize,180,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['optimiz'],['optimize']
Performance,"// At this point, we're definitely going to unswitch something so invalidate; // any cached information in ScalarEvolution for the outer most loop; // containing an exit block and all nested loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:85,cache,cached,85,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['cache'],['cached']
Performance,"// At this very end of the compilation pipeline, if any DBG_VALUEs with; // registers remain, it means they are dangling info which we failed to update; // when their corresponding def instruction was transformed/moved/splitted etc.; // Because Wasm cannot access values in LLVM virtual registers in the debugger,; // these dangling DBG_VALUEs in effect kill the effect of any previous DBG_VALUE; // associated with the variable, which will appear as ""optimized out"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp:452,optimiz,optimized,452,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp,1,['optimiz'],['optimized']
Performance,// Atom Silvermont codes from the Intel software optimization guide.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp:49,optimiz,optimization,49,interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,1,['optimiz'],['optimization']
Performance,// Atomic instructions already bypass caches to the scope specified by the; // SyncScope operand. Only non-atomic volatile and nontemporal instructions; // need additional treatment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:38,cache,caches,38,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,2,['cache'],['caches']
Performance,// Atomic loads have complications involved.; // A Monotonic (or higher) load is OK if the query inst is itself not; // atomic.; // FIXME: This is overly conservative.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:10,load,loads,10,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,2,['load'],"['load', 'loads']"
Performance,// Atomic loads need special handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:10,load,loads,10,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,3,['load'],['loads']
Performance,"// Attempt to avoid passing indirect results using byval when possible. This; // is important for good codegen.; //; // We do this by coercing the value into a scalar type which the backend can; // handle naturally (i.e., without using byval).; //; // For simplicity, we currently only do this when we have exhausted all of the; // free integer registers. Doing this when there are free integer registers; // would require more care, as we would have to ensure that the coerced value; // did not claim the unused register. That would require either reording the; // arguments to the function (so that any subsequent inreg values came first),; // or only doing this optimization when there were no following arguments that; // might be inreg.; //; // We currently expect it to be rare (particularly in well written code) for; // arguments to be passed on the stack when there are still free integer; // registers available (this would typically imply large structs being passed; // by value), so this seems like a fair tradeoff for now.; //; // We can revisit this if the backend grows support for 'onstack' parameter; // attributes. See PR12193.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:665,optimiz,optimization,665,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['optimiz'],['optimization']
Performance,"// Attempt to combine a shuffle of 2 inputs of 'scalar sources' -; // BUILD_VECTOR or SCALAR_TO_VECTOR into a single BUILD_VECTOR.; //; // SHUFFLE(BUILD_VECTOR(), BUILD_VECTOR()) -> BUILD_VECTOR() is always; // a simplification in some sense, but it isn't appropriate in general: some; // BUILD_VECTORs are substantially cheaper than others. The general case; // of a BUILD_VECTOR requires inserting each element individually (or; // performing the equivalent in a temporary stack variable). A BUILD_VECTOR of; // all constants is a single constant pool load. A BUILD_VECTOR where each; // element is identical is a splat. A BUILD_VECTOR where most of the operands; // are undef lowers to a small number of element insertions.; //; // To deal with this, we currently use a bunch of mostly arbitrary heuristics.; // We don't fold shuffles where one side is a non-zero constant, and we don't; // fold shuffles if the resulting (non-splat) BUILD_VECTOR would have duplicate; // non-constant operands. This seems to work out reasonably well in practice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:434,perform,performing,434,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,"['load', 'perform']","['load', 'performing']"
Performance,// Attempt to combine into a vector load/broadcast.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,load,load,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['load']
Performance,"// Attempt to commute shufps LHS loads:; // permilps(shufps(load(),x)) --> permilps(shufps(x,load()))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:33,load,loads,33,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,['load'],"['load', 'loads']"
Performance,// Attempt to convert VGPR load to an AGPR load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:27,load,load,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,2,['load'],['load']
Performance,// Attempt to convert a sra of a load into a narrower sign-extending load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,load,load,33,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['load'],['load']
Performance,// Attempt to convert a srl of a load into a narrower zero-extending load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,load,load,33,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['load'],['load']
Performance,// Attempt to convert full width vector loads into broadcast loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:40,load,loads,40,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,2,['load'],['loads']
Performance,// Attempt to convert the load of inserted vector into a fold load; // of a single float.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:26,load,load,26,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,2,['load'],['load']
Performance,"// Attempt to create a USUBSAT(LHS, RHS) node with DstVT, performing a; // clamp/truncation if necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,perform,performing,58,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['perform'],['performing']
Performance,"// Attempt to decompose a subvector insert/extract between VecVT and; // SubVecVT via subregister indices. Returns the subregister index that; // can perform the subvector insert/extract with the given element index, as; // well as the index corresponding to any leftover subvectors that must be; // further inserted/extracted within the register class for SubVecVT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:150,perform,perform,150,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['perform'],['perform']
Performance,"// Attempt to detect ""hidden"" splats, which only reveal themselves as splats; // when re-interpreted as a vector with a larger element type. For example,; // v4i16 = build_vector i16 0, i16 1, i16 0, i16 1; // could be instead splat as; // v2i32 = build_vector i32 0x00010000, i32 0x00010000; // TODO: This optimization could also work on non-constant splats, but it; // would require bit-manipulation instructions to construct the splat value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:307,optimiz,optimization,307,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['optimiz'],['optimization']
Performance,"// Attempt to detect the file type using file magic. We have a slight bias; // towards the binary format, and we do this by making sure that the first 4; // bytes of the binary file is some combination of the following byte; // patterns: (observe the code loading them assumes they're little endian); //; // 0x01 0x00 0x00 0x00 - version 1, ""naive"" format; // 0x01 0x00 0x01 0x00 - version 1, ""flight data recorder"" format; // 0x02 0x00 0x01 0x00 - version 2, ""flight data recorder"" format; //; // YAML files don't typically have those first four bytes as valid text so we; // try loading assuming YAML if we don't find these bytes.; //; // Only if we can't load either the binary or the YAML format will we yield an; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:256,load,loading,256,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,3,['load'],"['load', 'loading']"
Performance,// Attempt to extract+simplify a (constant pool load) shuffle mask.; // TODO: Support other types from getTargetShuffleMaskIndices?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:48,load,load,48,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['load']
Performance,// Attempt to fast-select a load instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:28,load,load,28,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['load'],['load']
Performance,// Attempt to find another opprotunity for zero latency in a different; // dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:48,latency,latency,48,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['latency'],['latency']
Performance,// Attempt to fold target constant loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:35,load,loads,35,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['loads']
Performance,// Attempt to issue a wide load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:27,load,load,27,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['load'],['load']
Performance,// Attempt to load pass plugins and register their callbacks with PB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:14,load,load,14,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,1,['load'],['load']
Performance,"// Attempt to load pass plugins and register their callbacks with PB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp:14,load,load,14,interpreter/cling/lib/Interpreter/BackendPasses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp,1,['load'],['load']
Performance,// Attempt to load the HSA runtime.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp:14,load,load,14,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp,1,['load'],['load']
Performance,// Attempt to load the NVPTX driver runtime.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/nvptx-arch/NVPTXArch.cpp:14,load,load,14,interpreter/llvm-project/clang/tools/nvptx-arch/NVPTXArch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/nvptx-arch/NVPTXArch.cpp,1,['load'],['load']
Performance,"// Attempt to lookup the copy constructor. Various pieces of machinery; // will spring into action, like template instantiation, which means this; // cannot be a simple walk of the class's decls. Instead, we must perform; // lookup and overload resolution.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:213,perform,perform,213,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['perform'],['perform']
Performance,// Attempt to lower to a bitmask if we can. Only if not optimizing for size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:56,optimiz,optimizing,56,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['optimiz'],['optimizing']
Performance,// Attempt to match VBROADCAST*128 subvector broadcast load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:55,load,load,55,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['load']
Performance,// Attempt to match against a OR if we're performing a blend shuffle and the; // non-blended source element is zero in each case.; // TODO: Handle cases where V1/V2 sizes doesn't match SizeInBits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:42,perform,performing,42,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['performing']
Performance,// Attempt to match against broadcast-from-vector.; // Limit AVX1 to cases where we're loading+broadcasting a scalar element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:87,load,loading,87,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['loading']
Performance,"// Attempt to match index patterns, as long as we're not relying on implicit; // sign-extension, which is performed BEFORE scale.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:106,perform,performed,106,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['perform'],['performed']
Performance,"// Attempt to optimize ADD/FADD/MUL reductions with HADD, promotion etc..",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:14,optimiz,optimize,14,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['optimiz'],['optimize']
Performance,// Attempt to optimize all the phis in the functions to the correct type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:14,optimiz,optimize,14,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['optimiz'],['optimize']
Performance,"// Attempt to optimize the G_BRCOND + G_ICMP into a TB(N)Z/CB(N)Z.; //; // Speculation tracking/SLH assumes that optimized TB(N)Z/CB(N)Z; // instructions will not be produced, as they are conditional branch; // instructions that do not set flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:14,optimiz,optimize,14,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,2,['optimiz'],"['optimize', 'optimized']"
Performance,// Attempt to optimize the comparison instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:14,optimiz,optimize,14,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['optimiz'],['optimize']
Performance,// Attempt to optimize the test bit by walking over instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:14,optimiz,optimize,14,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['optimiz'],['optimize']
Performance,"// Attempt to perform logical operations on the results of comparisons while; // keeping the values in GPRs. Without doing so, these would end up being; // lowered to CR-logical operations which suffer from significant latency and; // low ILP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:14,perform,perform,14,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,2,"['latency', 'perform']","['latency', 'perform']"
Performance,// Attempt to perform typo correction to find a module name that works.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:14,perform,perform,14,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['perform'],['perform']
Performance,// Attempt to perform zero-initialization using memset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp:14,perform,perform,14,interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,1,['perform'],['perform']
Performance,"// Attempt to propagate the AND back up to the leaves which, if they're; // loads, can be combined to narrow loads and the AND node can be removed.; // Perform after legalization so that extend nodes will already be; // combined into the loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:76,load,loads,76,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,4,"['Perform', 'load']","['Perform', 'loads']"
Performance,"// Attempt to read a caged page data when cluster cache is disabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx:50,cache,cache,50,tree/ntuple/v7/test/ntuple_storage_daos.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx,1,['cache'],['cache']
Performance,"// Attempt to read all the entries written above as caged pages, with cluster cache turned on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx:78,cache,cache,78,tree/ntuple/v7/test/ntuple_storage_daos.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx,1,['cache'],['cache']
Performance,"// Attempt to synchronize the packet size with the tree cache size",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx:56,cache,cache,56,proof/proofplayer/src/TPacketizerAdaptive.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx,1,['cache'],['cache']
Performance,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:15,optimiz,optimize,15,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,4,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,"// Author: Christoph Rosemann Jul 2010; // TMVA unit tests; //; // this class acts as interface to create, train and evaluate the method; // specified in the constructor; // as additional argument the limits of the ROC integral can be given; // to determine the performance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/stressTMVA.cxx:262,perform,performance,262,tmva/tmva/test/stressTMVA.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/stressTMVA.cxx,1,['perform'],['performance']
Performance,"// Author: Christoph Rosemann Oct 2010; // TMVA unit tests; //; // this class acts as interface to create, train and evaluate the method; // specified in the constructor; // additionally the regression performance is evaluated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/stressTMVA.cxx:202,perform,performance,202,tmva/tmva/test/stressTMVA.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/stressTMVA.cxx,1,['perform'],['performance']
Performance,"// Author: Eckhard von Toerne, uses Christoph Rosemann's MethodUnitTest as example Nov 2010; // TMVA unit tests; //; // this class acts as interface to create, train and evaluate the method; // specified in the constructor; // as additional argument the limits of the ROC integral can be given; // to determine the performance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/stressTMVA.cxx:315,perform,performance,315,tmva/tmva/test/stressTMVA.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/stressTMVA.cxx,1,['perform'],['performance']
Performance,"// Author: Rahul Balasubramanian, Nikhef 08 Apr 2021; /*****************************************************************************; * RooFit; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2019, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; //////////////////////////////////////////////////////////////////////////////; /// \class RooLinearCombination; /// RooLinearCombination is a class that helps perform linear combination of; /// floating point numbers and permits handling them as multiprecision; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinearCombination.cxx:845,perform,perform,845,roofit/roofitcore/src/RooLinearCombination.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinearCombination.cxx,1,['perform'],['perform']
Performance,"// Author: Stefan Schmitt; // DESY, 13/10/08; // Version 17.9, add new methods GetDF(), GetSURE(), ScanSURE(), GetSqrtEvEmatrix(); //; // History:; // Version 17.8, add new method GetDXDY() for histograms; // Version 17.7, updates in the TUnfold implementation; // Version 17.6, updated doxygen-style comments, add one argument for scanLCurve; // Version 17.5, fix memory leak and other bugs; // Version 17.4, in parallel to changes in TUnfoldBinning; // Version 17.3, in parallel to changes in TUnfoldBinning; // Version 17.2, in parallel to changes in TUnfoldBinning; // Version 17.1, bug fixes in GetFoldedOutput, GetOutput; // Version 17.0, error matrix with SetInput, store fL not fLSquared; // Version 16.2, in parallel to bug-fix in TUnfoldSys; // Version 16.1, in parallel to bug-fix in TUnfold.C; // Version 16.0, some cleanup, more getter functions, query version number; // Version 15, simplified L-curve scan, new tau definition, new eror calc.; // Version 14, with changes in TUnfoldSys.cxx; // Version 13, new methods for derived classes; // Version 12, with support for preconditioned matrix inversion; // Version 11, regularisation methods have return values; // Version 10, with bug-fix in TUnfold.cxx; // Version 9, implements method for optimized inversion of sparse matrix; // Version 8, replace all TMatrixSparse matrix operations by private code; // Version 7, fix problem with TMatrixDSparse,TMatrixD multiplication; // Version 6, completely remove definition of class XY; // Version 5, move definition of class XY from TUnfold.C to this file; // Version 4, with bug-fix in TUnfold.C; // Version 3, with bug-fix in TUnfold.C; // Version 2, with changed ScanLcurve() arguments; // Version 1, added ScanLcurve() method; // Version 0, stable version of basic unfolding algorithm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfold.h:1256,optimiz,optimized,1256,hist/unfold/inc/TUnfold.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfold.h,1,['optimiz'],['optimized']
Performance,"// Automated cache management function - Returns `true` if cache is invalidated; // A - Check if set1/2 are in cache and range name is identical",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNormSetCache.cxx:13,cache,cache,13,roofit/roofitcore/src/RooNormSetCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNormSetCache.cxx,3,['cache'],['cache']
Performance,"// Avoid CMOV instruction which value is used as a pointer to load from.; // This is another conservative check to avoid converting CMOV instruction; // used with tree-search like algorithm, where the branch is unpredicted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:62,load,load,62,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,1,['load'],['load']
Performance,"// Avoid adding the ""Stride == 1"" predicate when we know that; // Stride >= Trip-Count. Such a predicate will effectively optimize a single; // or zero iteration loop, as Trip-Count <= Stride == 1.; //; // TODO: We are currently not making a very informed decision on when it is; // beneficial to apply stride versioning. It might make more sense that the; // users of this analysis (such as the vectorizer) will trigger it, based on; // their specific cost considerations; For example, in cases where stride; // versioning does not help resolving memory accesses/dependences, the; // vectorizer should evaluate the cost of the runtime test, and the benefit; // of various possible stride specializations, considering the alternatives; // of using gather/scatters (if available).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:122,optimiz,optimize,122,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['optimiz'],['optimize']
Performance,"// Avoid bugpoint weirdness: A block may end with a conditional branch but; // jumps to the same MBB is either case. We have duplicate CFG edges in that; // case that we can't handle. Since this never happens in properly optimized; // code, just skip those edges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:221,optimiz,optimized,221,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,1,['optimiz'],['optimized']
Performance,// Avoid converting a constant or loop invariant test back to a runtime; // test. This is critical for when SCEV's cached ExitCount is less precise; // than the current IR (such as after we've proven a particular exit is; // actually dead and thus the BE count never reaches our ExitCount.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:115,cache,cached,115,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['cache'],['cached']
Performance,// Avoid copying a block to the heap if the block is assigned to a local; // auto variable that is declared in the same scope as the block. This; // optimization is unsafe if the local variable is declared in an outer; // scope. For example:; //; // BlockTy b;; // {; // b = ^{...};; // }; // // It is unsafe to invoke the block here if it wasn't copied to the; // // heap.; // b();,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,optimiz,optimization,149,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['optimiz'],['optimization']
Performance,"// Avoid destroying the cache; must be placed before deleting the trees",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx:24,cache,cache,24,proof/proofplayer/src/TEventIter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx,2,['cache'],['cache']
Performance,// Avoid disabling potential load folding opportunities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:29,load,load,29,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['load']
Performance,"// Avoid hoisting (and (load x) 1) since it is unlikely to be folded by the; // target even if isLoadExtLegal says an i1 EXTLOAD is valid. For example,; // for the AArch64 target isLoadExtLegal(ZEXTLOAD, i32, i1) returns true, but; // (and (load x) 1) is not matched as a single instruction, rather as a LDR; // followed by an AND.; // TODO: Look into removing this restriction by fixing backends to either; // return false for isLoadExtLegal for i1 or have them select this pattern to; // a single instruction.; //; // Also avoid hoisting if we didn't see any ands with the exact DemandBits; // mask, since these are the only ands that will be removed by isel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:24,load,load,24,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,2,['load'],['load']
Performance,// Avoid instructions which load from potentially varying memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:28,load,load,28,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['load'],['load']
Performance,"// Avoid loading zero-sized COFF sections.; // In PE files, VirtualSize gives the section size, and SizeOfRawData; // may be zero for sections with content. In Obj files, SizeOfRawData; // gives the section size, and VirtualSize is always zero. Hence; // the need to check for both cases below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:9,load,loading,9,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,1,['load'],['loading']
Performance,"// Avoid materializing a constant when possible by reusing a known value in; // a register. However, don't perform this optimization if the known value; // is one, zero or negative one in the case of a CSEL. We can always; // materialize these values using CSINC, CSEL and CSINV with wzr/xzr as the; // FVal, respectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:107,perform,perform,107,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,// Avoid partial and undef register update stalls unless optimizing for size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:57,optimiz,optimizing,57,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,3,['optimiz'],['optimizing']
Performance,// Avoid performing the look-up in the common case where the specified; // expression has no loop-variant portions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:9,perform,performing,9,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['perform'],['performing']
Performance,"// Avoid proven overflow cases: this will ensure that the backedge taken count; // will not generate any unsigned overflow. Relaxed no-overflow conditions; // exploit NoWrapFlags, allowing to optimize in presence of undefined; // behaviors like the case of C language.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:192,optimiz,optimize,192,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['optimiz'],['optimize']
Performance,"// Avoid proven overflow cases: this will ensure that the backedge taken; // count will not generate any unsigned overflow. Relaxed no-overflow; // conditions exploit NoWrapFlags, allowing to optimize in presence of; // undefined behaviors like the case of C language.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:192,optimiz,optimize,192,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['optimiz'],['optimize']
Performance,"// Avoid race conditions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TWin32Condition.cxx:9,race condition,race conditions,9,core/thread/src/TWin32Condition.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TWin32Condition.cxx,2,['race condition'],['race conditions']
Performance,"// Avoid reading outside the memory accessed by the original load (could; // happened if we only adjust the load base pointer by ShAmt). Instead we; // try to narrow the load even further. The typical scenario here is:; // (i64 (truncate (i96 (srl (load x), 64)))) ->; // (i64 (truncate (i96 (zextload (load i32 + offset) from i32))))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:61,load,load,61,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,5,['load'],['load']
Performance,"// Avoid rematerializing instructions that return a value that is; // different depending on vector length, even when it is not returned; // in a scalable vector/predicate register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:146,scalab,scalable,146,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['scalab'],['scalable']
Performance,"// Avoid rematerializing rematerializable instructions that use/define; // scalable values, such as 'pfalse' or 'ptrue', which result in different; // results when the runtime vector length is different.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:75,scalab,scalable,75,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['scalab'],['scalable']
Performance,// Avoid scalarizing zero splat stores for scalable vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:43,scalab,scalable,43,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['scalab'],['scalable']
Performance,// Avoid serializing long latency dependence chains.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:26,latency,latency,26,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['latency'],['latency']
Performance,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:26,latency,latency,26,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,4,['latency'],['latency']
Performance,"// Avoid sinking loads in order not to skip state-modifying instructions,; // that may alias with the loaded address.; // Only allow sinking of loads within the same basic block that are; // conservatively proven to be safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:17,load,loads,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,3,['load'],"['loaded', 'loads']"
Performance,// Avoid some checks and module map parsing when loading PCM files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:49,load,loading,49,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,1,['load'],['loading']
Performance,// Avoid the transformation if there are multiple uses of the loaded value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:62,load,loaded,62,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['loaded']
Performance,// Avoid traversing for Load operand with high number of users.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:24,Load,Load,24,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['Load'],['Load']
Performance,// Avoid unrolling when optimizing for size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:24,optimiz,optimizing,24,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,2,['optimiz'],['optimizing']
Performance,"// B - Check if dependents(set1/set2) are compatible with current cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNormSetCache.cxx:66,cache,cache,66,roofit/roofitcore/src/RooNormSetCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNormSetCache.cxx,1,['cache'],['cache']
Performance,// BF16 - Load/Store Actions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:10,Load,Load,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Load'],['Load']
Performance,// BPF target does not support tail call optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:41,optimiz,optimization,41,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,1,['optimiz'],['optimization']
Performance,"// BROADCAST - match the smallest possible repetition pattern, load that; // scalar/subvector element and then broadcast to the entire vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:63,load,load,63,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['load']
Performance,"// BUILD_VECTORs are lowered to the instruction that initializes the highest; // possible number of lanes at once followed by a sequence of replace_lane; // instructions to individually initialize any remaining lanes.; // TODO: Tune this. For example, lanewise swizzling is very expensive, so; // swizzled lanes should be given greater weight.; // TODO: Investigate looping rather than always extracting/replacing specific; // lanes to fill gaps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:228,Tune,Tune,228,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['Tune'],['Tune']
Performance,"// BZHI, if available, is always fast, unlike BEXTR. But even if we decide; // that we can't use BEXTR, it is only worthwhile using BZHI if the mask; // does not fit into 32 bits. Load folding is not a sufficient reason.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:180,Load,Load,180,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['Load'],['Load']
Performance,// Bail due to missing support for ISD::STRICT_ scalable vector operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:48,scalab,scalable,48,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['scalab'],['scalable']
Performance,// Bail for single insertion if it is a load.; // TODO: Handle this once getVectorInstrCost can cost for load/stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:40,load,load,40,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,2,['load'],['load']
Performance,// Bail if the number of loads (non-overlapping + potential overlapping one); // is larger than the max allowed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:25,load,loads,25,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,1,['load'],['loads']
Performance,// Bail if we don't have anything cached for this block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:34,cache,cached,34,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,1,['cache'],['cached']
Performance,// Bail on analysing scalable LocationSize,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:21,scalab,scalable,21,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['scalab'],['scalable']
Performance,// Bail on doing Size comparison which depends on AA for now; // TODO: Remove AnyScalable once Alias Analysis deal with scalable vectors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:120,scalab,scalable,120,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['scalab'],['scalable']
Performance,// Bail out early if sample-loader inliner is disabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:28,load,loader,28,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['load'],['loader']
Performance,// Bail out early if shuffle is scalable type. The number of elements in; // shuffle mask is unknown at compile-time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:32,scalab,scalable,32,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,['scalab'],['scalable']
Performance,// Bail out early. Not expect to load from scalable global variable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:33,load,load,33,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,2,"['load', 'scalab']","['load', 'scalable']"
Performance,"// Bail out if an aligned load of the container cannot cover the entire; // bit-field. This can happen for example, if the bit-field is part of a; // packed struct. AAPCS does not define access rules for such cases, we let; // clang to follow its own rules.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp:26,load,load,26,interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,1,['load'],['load']
Performance,// Bail out if performing this load would access non-bit-fields members.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp:15,perform,performing,15,interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,2,"['load', 'perform']","['load', 'performing']"
Performance,// Bail out if the aggregate contains scalable vector type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:38,scalab,scalable,38,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['scalab'],['scalable']
Performance,"// Bail out if the array is too large. Ideally we would like to optimize; // arrays of arbitrary size but this has a terrible impact on compile time.; // The threshold here is chosen arbitrarily, maybe needs a little bit of; // tuning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:64,optimiz,optimize,64,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,2,['optimiz'],['optimize']
Performance,// Bail out if we inserted the instruction to prevent optimizations from; // stepping on each other's toes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:54,optimiz,optimizations,54,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['optimiz'],['optimizations']
Performance,// Bail out of the optimization if any of the basic block is target of; // INLINEASM_BR instruction,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:19,optimiz,optimization,19,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['optimiz'],['optimization']
Performance,// Bail out on large Width. This happens when no proper combining / constant; // folding was performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:93,perform,performed,93,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['perform'],['performed']
Performance,// Bail out on large immediates. This happens when no proper; // combining/constant folding was performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:96,perform,performed,96,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['perform'],['performed']
Performance,"// Bail out when changing the scalable property, since we can't be sure that; // we're actually narrowing here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,scalab,scalable,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['scalab'],['scalable']
Performance,// Bail until we can represent demanded elements for scalable vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:53,scalab,scalable,53,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,2,['scalab'],['scalable']
Performance,"// Base class for cache elements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCacheElement.h:18,cache,cache,18,roofit/roofitcore/inc/RooAbsCacheElement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCacheElement.h,1,['cache'],['cache']
Performance,"// Base class for cache managers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCache.h:18,cache,cache,18,roofit/roofitcore/inc/RooAbsCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCache.h,1,['cache'],['cache']
Performance,"// Base is undef and at least 2 input vectors shuffled - perform 2 vectors; // shuffles step by step, combining shuffle between the steps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:57,perform,perform,57,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['perform'],['perform']
Performance,"// Base is undef and only 1 vector is shuffled - perform the action only for; // single vector, if the mask is not the identity mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:49,perform,perform,49,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['perform'],['perform']
Performance,// Base pointer which every load should share.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:28,load,load,28,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['load'],['load']
Performance,"// BaseIndexOffset assumes that offsets are fixed-size, which; // is not valid for scalable vectors where the offsets are; // scaled by `vscale`, so bail out early.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:83,scalab,scalable,83,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['scalab'],['scalable']
Performance,"// Based on Lemma 2.5 from [2], after insertion of (From,To), v is affected; // iff depth(NCD)+1 < depth(v) && a path P from To to v exists where every; // w on P s.t. depth(v) <= depth(w); //; // This reduces to a widest path problem (maximizing the depth of the; // minimum vertex in the path) which can be solved by a modified version of; // Dijkstra with a bucket queue (named depth-based search in [2]).; // To is in the path, so depth(NCD)+1 < depth(v) <= depth(To). Nothing; // affected if this does not hold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:368,queue,queue,368,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,1,['queue'],['queue']
Performance,"// Basic Block Sections can be enabled for a subset of machine basic blocks.; // This is done by passing a file containing names of functions for which basic; // block sections are desired. Additionally, machine basic block ids of the; // functions can also be specified for a finer granularity. Moreover, a cluster; // of basic blocks could be assigned to the same section.; // Optionally, a debug-info filename can be specified for each function to allow; // distinguishing internal-linkage functions of the same name.; // A file with basic block sections for all of function main and three blocks; // for function foo (of which 1 and 2 are placed in a cluster) looks like this:; // (Profile for function foo is only loaded when its debug-info filename; // matches 'path/to/foo_file.cc').; // ----------------------------; // list.txt:; // !main; // !foo M=path/to/foo_file.cc; // !!1 2; // !!4",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:719,load,loaded,719,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,1,['load'],['loaded']
Performance,// Be careful not to replace a load of an addrspace value with an inttoptr here,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:31,load,load,31,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['load'],['load']
Performance,"// Be conservative, don't insert instruction above something that may have; // side-effects. And since it's potentially bad to separate flag setting; // instruction from the conditional branch, just abort the optimization; // completely.; // Also avoid moving code above predicated instruction since it's hard to; // reason about register liveness with predicated instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:209,optimiz,optimization,209,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['optimiz'],['optimization']
Performance,// Be conservative. We don't want this xform to end up introducing; // reloads just before load / store instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:91,load,load,91,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['load'],['load']
Performance,"// Be sure to propagate alignment to this load; LLVM doesn't know that NVPTX; // addrspacecast preserves alignment. Since params are constant, this load is; // definitely not volatile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:42,load,load,42,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,2,['load'],['load']
Performance,"// Because DepCands is constructed by visiting accesses in the order in; // which they appear in alias sets (which is deterministic) and the; // iteration order within an equivalence class member is only dependent on; // the order in which unions and insertions are performed on the; // equivalence class, the iteration order is deterministic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:266,perform,performed,266,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['perform'],['performed']
Performance,"// Because SROA can't handle speculating stores of selects, try not to sink; // loads, stores or lifetime markers of allocas when we'd have to create a; // PHI for the address operand. Also, because it is likely that loads or; // stores of allocas will disappear when Mem2Reg/SROA is run, don't sink; // them.; // This can cause code churn which can have unintended consequences down; // the line - see https://llvm.org/bugs/show_bug.cgi?id=30244.; // FIXME: This is a workaround for a deficiency in SROA - see; // https://llvm.org/bugs/show_bug.cgi?id=30188",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:80,load,loads,80,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,2,['load'],['loads']
Performance,"// Because of how we convert atomic_load and atomic_store to normal loads and; // stores in the DAG, we need to ensure that the MMOs are marked volatile; // since DAGCombine hasn't been updated to account for atomic, but non; // volatile loads. (See D57601)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:68,load,loads,68,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,2,['load'],['loads']
Performance,"// Because of the context trimming performed during matching, the callsite; // context could have more stack ids than the MIB. We match up to the end of; // the shortest stack context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:35,perform,performed,35,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['perform'],['performed']
Performance,"// Because of the type rules of C, we often end up computing a; // logical value, then zero extending it to int, then wanting it; // as a logical value again. Optimize this common case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:159,Optimiz,Optimize,159,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['Optimiz'],['Optimize']
Performance,"// Because the LoopInfo stores the loops in RPO, we walk the worklist; // from back to front so that we work forward across the CFG, which; // for unrolling is only needed to get optimization remarks emitted in; // a forward order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:179,optimiz,optimization,179,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['optimiz'],['optimization']
Performance,"// Because there are implicit symbol index values (-2, -1, 0, 1, 2),; // LoaderSecRelEnt.SymbolIndex - FirstSymIdxOfLoaderSec will get the; // real symbol from the symbol table.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/XCOFFDumper.cpp:73,Load,LoaderSecRelEnt,73,interpreter/llvm-project/llvm/tools/llvm-readobj/XCOFFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/XCOFFDumper.cpp,1,['Load'],['LoaderSecRelEnt']
Performance,"// Because typo correction is expensive, only do it if the implicit; // function declaration is going to be treated as an error.; //; // Perform the correction before issuing the main diagnostic, as some; // consumers use typo-correction callbacks to enhance the main diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:137,Perform,Perform,137,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Perform'],['Perform']
Performance,"// Because vslideup leaves the destination elements at the start intact, we can; // use it to perform shuffles that insert subvectors:; //; // vector_shuffle v8:v8i8, v9:v8i8, <0, 1, 2, 3, 8, 9, 10, 11>; // ->; // vsetvli zero, 8, e8, mf2, ta, ma; // vslideup.vi v8, v9, 4; //; // vector_shuffle v8:v8i8, v9:v8i8 <0, 1, 8, 9, 10, 5, 6, 7>; // ->; // vsetvli zero, 5, e8, mf2, tu, ma; // vslideup.v1 v8, v9, 2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:94,perform,perform,94,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['perform'],['perform']
Performance,// Because we are dealing with BE architecture we need to offset loading of; // partial types,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:65,load,loading,65,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,1,['load'],['loading']
Performance,"// Because we process the basic blocks in pre-order of the dominator tree, a; // candidate that doesn't dominate the current instruction won't dominate any; // future instruction either. Therefore, we pop it out of the stack. This; // optimization makes the algorithm O(n).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:235,optimiz,optimization,235,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,2,['optimiz'],['optimization']
Performance,"// Because we try to optimize around register mask operands by ignoring regs; // that aren't currently tracked, we set up something ugly for later: RegMask; // operands that are seen earlier than the first use of a register, still need; // to clobber that register in the transfer function. But this information; // isn't actively recorded. Instead, we track each RegMask used in each block,; // and accumulated the clobbered but untracked registers in each block into; // the following bitvector. Later, if new values are tracked, we can add; // appropriate clobbers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:21,optimiz,optimize,21,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['optimiz'],['optimize']
Performance,"// Before blocking SIGTERM, set the signal handler, so we can also check after blocking whether a signal occurred; // In our case, we already set it in the ProcessManager after forking to the queue and worker processes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx:192,queue,queue,192,roofit/multiprocess/src/Messenger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx,3,['queue'],['queue']
Performance,"// Before kernel 4.17, Linux did not support MAP_FIXED_NOREPLACE, so if it is; // not available, simplfy define it as MAP_FIXED which performs the same; // function but does not guarantee existing mappings won't get clobbered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MmapUtils.h:134,perform,performs,134,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MmapUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MmapUtils.h,1,['perform'],['performs']
Performance,// Before legalize we can introduce illegal bswaps which will be later; // converted to an explicit bswap sequence. This way we end up with a single; // load and byte shuffling instead of several loads and byte shuffling.; // We do not introduce illegal bswaps when zero-extending as this tends to; // introduce too many arithmetic instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:153,load,load,153,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['load'],"['load', 'loads']"
Performance,// Before legalize we can introduce too wide illegal loads which will be later; // split into legal sized loads. This enables us to combine i64 load by i8; // patterns to a couple of i32 loads on 32 bit targets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,load,loads,53,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,4,['load'],"['load', 'loads']"
Performance,"// Before rematerializing into a register for a single instruction, try to; // fold a load into the instruction. That avoids allocating a new register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:86,load,load,86,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['load'],['load']
Performance,"// Before running any passes, run the verifier to determine if the input; // coming from the front-end and/or optimizer is valid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:110,optimiz,optimizer,110,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['optimiz'],['optimizer']
Performance,"// Before selecting a DUP instruction, check if it is better selected as a; // MOV or load from a constant pool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:86,load,load,86,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['load'],['load']
Performance,"// Before the load we need a fence. Here is an example lifted from; // http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf showing why a fence; // is required:; // Thread 0:; // x.store(1, relaxed);; // r1 = y.fetch_add(0, release);; // Thread 1:; // y.fetch_add(42, acquire);; // r2 = x.load(relaxed);; // r1 = r2 = 0 is impossible, but becomes possible if the idempotent rmw is; // lowered to just a load without a fence. A mfence flushes the store buffer,; // making the optimization clearly correct.; // FIXME: it is required if isReleaseOrStronger(Order) but it is not clear; // otherwise, we might be able to be more aggressive on relaxed idempotent; // rmw. In practice, they do not look useful, so we don't try to be; // especially clever.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:14,load,load,14,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,4,"['load', 'optimiz']","['load', 'optimization']"
Performance,"// Before we actually start lowering (and allocating spill slots for values),; // reserve any stack slots which we judge to be profitable to reuse for a; // particular value. This is purely an optimization over the code below and; // doesn't change semantics at all. It is important for performance that we; // reserve slots for both deopt and gc values before lowering either.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:193,optimiz,optimization,193,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"// Before we generate a new store to a temporary stack slot, see if there is; // already one that we can use. There often is because when we scalarize; // vector operations (using SelectionDAG::UnrollVectorOp for example) a whole; // series of EXTRACT_VECTOR_ELT nodes are generated, one for each element in; // the vector. If all are expanded here, we don't want one store per vector; // element.; // Caches for hasPredecessorHelper",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:402,Cache,Caches,402,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['Cache'],['Caches']
Performance,"// Before we go any further, try the complete->base constructor; // delegation optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:79,optimiz,optimization,79,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['optimiz'],['optimization']
Performance,"// Before we handle the more subtle cases of register-register CMOVs inside; // of potentially hot loops, we want to quickly remove all CMOVs (ForceAll) or; // the ones with a memory operand (ForceMemOperand option). The latter CMOV; // will risk a stall waiting for the load to complete that speculative; // execution behind a branch is better suited to handle on modern x86 chips.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:271,load,load,271,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,1,['load'],['load']
Performance,"// Before weak cmpxchgs existed, the instruction simply returned the; // value loaded from memory, so bitcode files from that era will be; // expecting the first component of a modern cmpxchg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:79,load,loaded,79,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['load'],['loaded']
Performance,"// Before, there were calls to `pdf->dependsOn()` here, but they were very; // expensive for large computation graphs! Given that we have to traverse; // the computation graph with a call to `pdf->getParameters()` anyway, we; // can just check if the set of all variables operlaps with the observables; // or constraind parameters.; //; // We are using an optimized implementation of overlap checking. Because; // the overlap is checked by name, we can check overlap of the; // corresponding name pointers. The optimization can't be in; // RooAbsCollection itself, because it is crucial that the memory for the; // non-tmp name pointers is not reallocated for each pdf.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:356,optimiz,optimized,356,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,2,['optimiz'],"['optimization', 'optimized']"
Performance,"// Begin by bitcasting the input to byte vector, then split those bytes; // into lo/hi nibbles and use the PSHUFB LUT to perform CLTZ on each of them.; // If the hi input nibble is zero then we add both results together, otherwise; // we just take the hi result (by masking the lo result to zero before the; // add).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:121,perform,perform,121,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['perform']
Performance,// Being able to dereference past the end is useful for emitting scalar loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:72,load,loads,72,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['load'],['loads']
Performance,// Below are GFX12+ cache policy bits; // Temporal hint,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIDefines.h:20,cache,cache,20,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIDefines.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIDefines.h,1,['cache'],['cache']
Performance,"// Below is based on the following information:; // +------------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+; // | Processor Name | Cache Line Size (Bytes) | Source |; // +------------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+; // | i386 | 64 | https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf |; // | i486 | 16 | ""four doublewords"" (doubleword = 32 bits, 4 bits * 32 bits = 16 bytes) https://en.wikichip.org/w/images/d/d3/i486_MICROPROCESSOR_HARDWARE_REFERENCE_MANUAL_%281990%29.pdf and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.4216&rep=rep1&type=pdf (page 29) |; // | i586/Pentium MMX | 32 | https://www.7-cpu.com/cpu/P-MMX.html |; // | i686/Pentium | 32 | https://www.7-cpu.com/cpu/P6.html |; // | Netburst/Pentium4 | 64 | https://www.7-cpu.com/cpu/P4-180.html |; // | Atom | 64 | https://www.7-cpu.com/cpu/Atom.html |; // | Westmere | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/sandy_bridge_(client) ""Cache Architecture"" |; // | Sandy Bridge | 64 | https://en.wikipedia.org/wiki/Sandy_Bridge and https://www.7-cpu.com/cpu/SandyBridge.html |; // | Ivy Bridge | 64 | https://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ and https://www.7-cpu.com/cpu/IvyBridge.html |; // | Haswell | 64 | https://www.7-cpu.com/cpu/Haswell.html |; // | Broadwell | 64 | https://www.7-cpu.com/cpu/Broadwell.html |; // | Skylake (including skylake-avx512) | 64 | https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html ""Cache Hierarchy"" |; // | Cascade Lake | 64 | https://www.nas.nasa.gov/hecc/support/kb/cascade-lake-processors_579.html ""Cache Hierarchy"" |; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:299,Cache,Cache,299,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,2,"['Cache', 'optimiz']","['Cache', 'optimization-manual']"
Performance,"// Below the cutoff, assume that the private memory objects would be; // optimized",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:73,optimiz,optimized,73,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,1,['optimiz'],['optimized']
Performance,"// Big endian - avoid unaligned loads.; // EXTLOAD:i24 -> (shl EXTLOAD:i16, 8) | ZEXTLOAD@+2:i8; // Load the top RoundWidth bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:32,load,loads,32,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,2,"['Load', 'load']","['Load', 'loads']"
Performance,"// Big endian intrinsics are more complex. The user intended these; // intrinsics to operate on a vector ""as-if"" loaded by (V)LDR,; // but we load as-if (V)LD1. So we should swap all arguments and; // swap the return value too.; //; // If we call sub-intrinsics, we should call a version that does; // not re-swap the arguments!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:113,load,loaded,113,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,2,['load'],"['load', 'loaded']"
Performance,// Big-endian - high bits are at low addresses. Favor aligned loads at; // the cost of some bit-fiddling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:62,load,loads,62,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['load'],['loads']
Performance,// BinOpShuffles need to be handled a single time in case both operands of the; // binop are the same load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:102,load,load,102,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,1,['load'],['load']
Performance,"// Bind the address of the object, then check to see if we cached out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:59,cache,cached,59,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,1,['cache'],['cached']
Performance,"// Binned (RooDataHist) and unbinned datasets (RooDataSet) share; // many properties and inherit from a common abstract base class; // (RooAbsData), that provides an interface for all operations; // that can be performed regardless of the data format",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:211,perform,performed,211,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['perform'],['performed']
Performance,"// Bit-reverse Load Intrinsic :Crawl up and figure out the object from previous; // instruction. So far we only handle bitcast, extract value and bit reverse; // load intrinsic instructions. Should we handle CGEP ?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:15,Load,Load,15,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,2,"['Load', 'load']","['Load', 'load']"
Performance,// Bit-reverse Load Intrinsic: Check if the instruction is a bit reverse load; // intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:15,Load,Load,15,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,2,"['Load', 'load']","['Load', 'load']"
Performance,"// Bit-reverse Load Intrinsic: Figure out the underlying object the base; // pointer points to, for the bit-reverse load intrinsic. Setting this to; // memoperand might help alias analysis to figure out the dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:15,Load,Load,15,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,2,"['Load', 'load']","['Load', 'load']"
Performance,"// Bit-reverse Load Intrinsic: For a PHI Node return either an incoming edge or; // a back edge. If the back edge comes from the intrinsic itself, the incoming; // edge is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:15,Load,Load,15,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['Load'],['Load']
Performance,"// Bitcast an i64 load inserted into a vector to f64.; // Otherwise, the i64 value will be legalized to a pair of i32 values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:18,load,load,18,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['load'],['load']
Performance,// Bitcast or gep with zeros are using Ptr. Add to queue to check it's; // users. U = bitcast Ptr,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:51,queue,queue,51,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['queue'],['queue']
Performance,// Bitcast to a wide integer type if the loads are vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:41,load,loads,41,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['load'],['loads']
Performance,"// Bitcast to vXi1 type and then back to integer. This gets the mask; // register type into the IR, but might be optimized out depending on; // what's around it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:113,optimiz,optimized,113,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['optimiz'],['optimized']
Performance,"// Bits 3 and 4 are the same, add an artificial edge and set extra; // latency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:71,latency,latency,71,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['latency'],['latency']
Performance,// Bits indicating whether the loader should prepare for MTE to be enabled on; // the heap and/or stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:31,load,loader,31,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['load'],['loader']
Performance,"// Blocks until there are log entries in the queue, then pops and returns the; // first one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h:45,queue,queue,45,interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,1,['queue'],['queue']
Performance,"// Bool vector load - attempt to cast to an integer, as we have good; // (vXiY *ext(vXi1 bitcast(iX))) handling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:15,load,load,15,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['load']
Performance,"// Bool vectors are excluded by default, but make it explicit to; // emphasize that bool vectors cannot be loaded or stored.; // Also, disallow double vector stores (to prevent unnecessary; // store widening in DAG combiner).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:107,load,loaded,107,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,1,['load'],['loaded']
Performance,"// Boolean optimization breakpoint",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:11,optimiz,optimization,11,hist/hist/src/TFormula_v5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx,1,['optimiz'],['optimization']
Performance,"// Booleans need to be unpacked, so we use a cached entry.; // FIXME: I should really use a variant here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx:45,cache,cached,45,tree/dataframe/src/RArrowDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx,1,['cache'],['cached']
Performance,// Bootstrap attributes by copying function attributes from the; // original function. This should include optimization settings and so on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:107,optimiz,optimization,107,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['optimiz'],['optimization']
Performance,"// Bootstrap process -- here be phase-ordering dragons.; //; // The MachOPlatform class uses allocation actions to register metadata; // sections with the ORC runtime, however the runtime contains metadata; // registration functions that have their own metadata that they need to; // register (e.g. the frame-info registration functions have frame-info).; // We can't use an ordinary lookup to find these registration functions; // because their address is needed during the link of the containing graph; // itself (to build the allocation actions that will call the registration; // functions). Further complicating the situation (a) the graph containing; // the registration functions is allowed to depend on other graphs (e.g. the; // graph containing the ORC runtime RTTI support) so we need to handle an; // unknown set of dependencies during bootstrap, and (b) these graphs may; // be linked concurrently if the user has installed a concurrent dispatcher.; //; // We satisfy these constraints by implementing a bootstrap phase during which; // allocation actions generated by MachOPlatform are appended to a list of; // deferred allocation actions, rather than to the graphs themselves. At the; // end of the bootstrap process the deferred actions are attached to a final; // ""complete-bootstrap"" graph that causes them to be run.; //; // The bootstrap steps are as follows:; //; // 1. Request the graph containing the mach header. This graph is guaranteed; // not to have any metadata so the fact that the registration functions; // are not available yet is not a problem.; //; // 2. Look up the registration functions and discard the results. This will; // trigger linking of the graph containing these functions, and; // consequently any graphs that it depends on. We do not use the lookup; // result to find the addresses of the functions requested (as described; // above the lookup will return too late for that), instead we capture the; // addresses in a post-allocation pass injected by ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:898,concurren,concurrently,898,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,2,['concurren'],"['concurrent', 'concurrently']"
Performance,"// Both FMINNUM/FMAXNUM and FMINNUM_IEEE/FMAXNUM_IEEE handle quiet; // NaNs in the same way. But, FMINNUM/FMAXNUM and FMINNUM_IEEE/; // FMAXNUM_IEEE handle signaling NaNs differently. If we cannot prove; // that there are not any sNaNs, then the optimization is not valid; // for FMINNUM_IEEE/FMAXNUM_IEEE. In the presence of sNaNs, we apply; // the optimization using FMINNUM/FMAXNUM for the following cases. If; // we can prove that we do not have any sNaNs, then we can do the; // optimization using FMINNUM_IEEE/FMAXNUM_IEEE for the following; // cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:246,optimiz,optimization,246,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,3,['optimiz'],['optimization']
Performance,"// Both GetCTypesType and GetCTypesPtrType, rely on the ctypes module itself; // caching the types (thus also making them unique), so no ref-count is needed.; // Further, by keeping a ref-count on the module, it won't be off-loaded until; // the 2nd cleanup cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPEnum.cxx:225,load,loaded,225,bindings/pyroot/cppyy/CPyCppyy/src/CPPEnum.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPEnum.cxx,1,['load'],['loaded']
Performance,// Both Predicate and Mask are unknown.; // Emulate masked store with predicated-load + mux + predicated-store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:81,load,load,81,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['load'],['load']
Performance,"// Both compare operands can be widened for free. The LHS can use an; // extended load, and the RHS is a constant:; // vselect (ext (setcc load(X), C)), N1, N2 -->; // vselect (setcc extload(X), C'), N1, N2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:82,load,load,82,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['load'],['load']
Performance,"// Both strings are ascii, perform a case-insensitive comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GSIStreamBuilder.cpp:27,perform,perform,27,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GSIStreamBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GSIStreamBuilder.cpp,1,['perform'],['perform']
Performance,// Break out; we'll perform typo correction below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:20,perform,perform,20,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['perform'],['perform']
Performance,"// Break up the BB if there are any instrs which aren't guaranteed to transfer; // execution to their successor.; //; // Consider, for example:; //; // def assert_arr_len(int n) { if (n < 2) exit(); }; //; // load arr[0]; // call assert_array_len(arr.length); // load arr[1]; //; // Even though assert_arr_len does not read or write any memory, we can't; // speculate the second load before the call. More info at; // https://github.com/llvm/llvm-project/issues/52950.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:209,load,load,209,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,3,['load'],['load']
Performance,"// Break-up fixed-vector PHIs into smaller pieces.; // Default threshold is 32, so it breaks up any vector that's >32 bits into; // its elements, or into 32-bit pieces (for 8/16 bit elts).; //; // This is only helpful for DAGISel because it doesn't handle large PHIs as; // well as GlobalISel. DAGISel lowers PHIs by using CopyToReg/CopyFromReg.; // With large, odd-sized PHIs we may end up needing many `build_vector`; // operations with most elements being ""undef"". This inhibits a lot of; // optimization opportunities and can result in unreasonably high register; // pressure and the inevitable stack spilling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:495,optimiz,optimization,495,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['optimiz'],['optimization']
Performance,// Brief cached information for each register class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterClassInfo.h:9,cache,cached,9,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterClassInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterClassInfo.h,1,['cache'],['cached']
Performance,// Broadcast form.; // Load size is based on W-bit as only D and Q are supported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ATTInstPrinter.cpp:23,Load,Load,23,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ATTInstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ATTInstPrinter.cpp,2,['Load'],['Load']
Performance,// Broadcast form.; // Load size is word for TA map. Otherwise it is based on W-bit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ATTInstPrinter.cpp:23,Load,Load,23,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ATTInstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ATTInstPrinter.cpp,2,['Load'],['Load']
Performance,// Broadcast shuffle kinds can be performed with 'dup'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:34,perform,performed,34,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['perform'],['performed']
Performance,// Broadcast shuffle kinds for scalable vectors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:31,scalab,scalable,31,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['scalab'],['scalable']
Performance,"// Broken - caching a cached tdf destroys the cache of the cached.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx:22,cache,cached,22,tree/dataframe/test/dataframe_cache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx,3,['cache'],"['cache', 'cached']"
Performance,"// Bucket queue of tree nodes ordered by descending level. For simplicity,; // we use a priority_queue here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:10,queue,queue,10,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,1,['queue'],['queue']
Performance,// Build TopLevelProbeFrameMap to track size for optimized inlinees when probe; // is available,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp:49,optimiz,optimized,49,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp,1,['optimiz'],['optimized']
Performance,// Build a DependentNameType that will perform lookup into RD at; // instantiation time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:39,perform,perform,39,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['perform'],['perform']
Performance,// Build a factor node to remember that this load is independent of the; // other one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:45,load,load,45,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,8,['load'],['load']
Performance,// Build a factor node to remember that this load is independent of; // the other one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:45,load,load,45,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,2,['load'],['load']
Performance,// Build a load instruction for the builtin variable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:11,load,load,11,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,1,['load'],['load']
Performance,// Build a load of the counted_by field.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:11,load,load,11,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['load'],['load']
Performance,// Build a load of the index and subtract it from the count.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:11,load,load,11,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['load'],['load']
Performance,"// Build a minimal pipeline based on the semantics required by LLVM,; // which is just that always inlining occurs. Further, disable generating; // lifetime intrinsics to avoid enabling further optimizations during; // code generation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:194,optimiz,optimizations,194,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['optimiz'],['optimizations']
Performance,// Build a plain volatile load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:26,load,load,26,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['load'],['load']
Performance,"// Build and insert into an implicit UNDEF value. This is OK because; // we will be shifting and then extracting the lower 8/16-bits.; // This has the potential to cause partial register stall. e.g.; // movw (%rbp,%rcx,2), %dx; // leal -65(%rdx), %esi; // But testing has shown this *does* help performance in 64-bit mode (at; // least on modern x86 machines).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:295,perform,performance,295,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['perform'],['performance']
Performance,"// Build cache of commonly used python strings (the cache is python intern, so; // all strings are shared python-wide, not just in cppyy).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/PyStrings.cxx:9,cache,cache,9,bindings/pyroot/cppyy/CPyCppyy/src/PyStrings.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/PyStrings.cxx,2,['cache'],['cache']
Performance,"// Build correct orders for extract{element,value}, loads and; // stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:52,load,loads,52,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['loads']
Performance,// Build direct call with NOP for TOC restore.; // FIXME: We can and should optimize away the NOP for local calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:76,optimiz,optimize,76,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['optimiz'],['optimize']
Performance,// Build shuffle mask to perform the splat.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:25,perform,perform,25,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp,1,['perform'],['perform']
Performance,"// Build the ""promoted"" result VTList for the load. If we are really loading; // i8s, then the return type will be promoted to i16 since we do not expose; // 8-bit registers in NVPTX.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:46,load,load,46,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,2,['load'],"['load', 'loading']"
Performance,"// Build the GC_TRANSITION_START node if necessary.; //; // The operands to the GC_TRANSITION_{START,END} nodes are laid out in the; // order in which they appear in the call to the statepoint intrinsic. If; // any of the operands is a pointer-typed, that operand is immediately; // followed by a SRCVALUE for the pointer that may be used during lowering; // (e.g. to form MachinePointerInfo values for loads/stores).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:403,load,loads,403,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,1,['load'],['loads']
Performance,"// Build the bad char heuristic table, with uint8_t to reduce cache thrashing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringRef.cpp:62,cache,cache,62,interpreter/llvm-project/llvm/lib/Support/StringRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringRef.cpp,1,['cache'],['cache']
Performance,"// Build the cache for all selection rules",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/Scanner.cxx:13,cache,cache,13,core/dictgen/src/Scanner.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/Scanner.cxx,1,['cache'],['cache']
Performance,// Build the function loaded notification message,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp:22,load,loaded,22,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp,1,['load'],['loaded']
Performance,"// Build the list of loaded PAR packages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:21,load,loaded,21,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,2,['load'],['loaded']
Performance,// Build the vector from the load operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:29,load,load,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['load'],['load']
Performance,"// Build the virtual file, Give it a name that's likely not to ever; // be #included (so we won't get a clash in clang's cache).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp:121,cache,cache,121,interpreter/cling/lib/Interpreter/CIFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp,1,['cache'],['cache']
Performance,// Build up a worklist of inner-loops to transform to avoid iterator; // invalidation.; // FIXME: This logic comes from other passes that actually change the loop; // nest structure. It isn't clear this is necessary (or useful) for a pass; // which merely optimizes the use of loads in a loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:256,optimiz,optimizes,256,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,2,"['load', 'optimiz']","['loads', 'optimizes']"
Performance,// Build up the expression (Reg + FixedOffset + ScalableOffset * VLENB).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:48,Scalab,ScalableOffset,48,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['Scalab'],['ScalableOffset']
Performance,"// Builds a vector type from scalar loads; // VecTy: Resulting Vector type; // LDOps: Load operators to build a vector type; // [Start,End) the list of loads to use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:36,load,loads,36,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,3,"['Load', 'load']","['Load', 'loads']"
Performance,// Bump CurCycle to account for latency. We assume the latency of other; // available instructions may be hidden by the stall (not a full pipe stall).; // This updates the hazard recognizer's cycle before reserving resources for; // this instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:32,latency,latency,32,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,['latency'],['latency']
Performance,// But some vector extending loads are legal,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:29,load,loads,29,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['load'],['loads']
Performance,"// By default, a dependency-breaking zero-idiom is expected to be optimized; // at register renaming stage. That means, no physical register is allocated; // to the instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/DispatchStage.cpp:66,optimiz,optimized,66,interpreter/llvm-project/llvm/lib/MCA/Stages/DispatchStage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/DispatchStage.cpp,1,['optimiz'],['optimized']
Performance,"// By default, assume nontemporal memory loads are available for loads that; // are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:41,load,loads,41,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,2,['load'],['loads']
Performance,"// By default, assume that it is cheaper to extract a subvector from a wide; // vector load rather than creating multiple narrow vector loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:87,load,load,87,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['load'],"['load', 'loads']"
Performance,"// By default, assume that the load will immediately leak.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:31,load,load,31,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['load'],['load']
Performance,"// By default, just classify everything as 'basic' or -1 to represent that; // don't know the throughput cost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:94,throughput,throughput,94,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,1,['throughput'],['throughput']
Performance,"// By default, use natural alignment for vector types. This is consistent; // with what clang and llvm-gcc do.; //; // We're only calculating a natural alignment, so it doesn't have to be; // based on the full size for scalable vectors. Using the minimum element; // count should be enough here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:219,scalab,scalable,219,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,1,['scalab'],['scalable']
Performance,"// By design, DeclContext is required to be a base class of some class that; // derives from Decl. Thus, it should always be possible to dyn_cast() from; // a DeclContext pointer to a Decl pointer and Decl::castFromDeclContext(); // asserts that to be the case. Since this function is intended for use in a; // debugger, it performs an additional check in order to prevent a failed; // cast and assertion. If that check fails, then the (invalid) DeclContext; // is dumped with an indication of its invalidity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp:324,perform,performs,324,interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp,1,['perform'],['performs']
Performance,"// By first forwarding the load command to the master and workers; // and only then loading locally we load/build in parallel",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:27,load,load,27,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,3,['load'],"['load', 'loading']"
Performance,"// By first forwarding the load command to the unique workers; // and only then loading locally we load/build in parallel",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:27,load,load,27,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,3,['load'],"['load', 'loading']"
Performance,"// By now we processed all instructions in a function, except; // non-volatile loads and non-volatile value stores. Let's find; // ref edges for both of instruction sets",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:79,load,loads,79,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,1,['load'],['loads']
Performance,"// By-val arguments are passed left-justfied in register.; // Every load here needs to be shifted, otherwise a full register load; // should have been used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:68,load,load,68,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['load'],['load']
Performance,// ByVal requires some special handling as it's too big for a single; // load,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:73,load,load,73,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['load'],['load']
Performance,// Bypass getHazardType calls in case of long latency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:46,latency,latency,46,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['latency'],['latency']
Performance,// Bypass lots of virtual calls in case of long latency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:48,latency,latency,48,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['latency'],['latency']
Performance,// Byte swapping load/store. Same operands as regular load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:17,load,load,17,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,2,['load'],['load']
Performance,"// Bytes is a VPERM-like permute vector, except that -1 is used for; // undefined bytes. Return true if it can be performed using VSLDB.; // When returning true, set StartIndex to the shift amount and OpNo0; // and OpNo1 to the VPERM operands that should be used as the first; // and second shift operand respectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:114,perform,performed,114,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['perform'],['performed']
Performance,"// C - Reset cache and refill with current state",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNormSetCache.cxx:13,cache,cache,13,roofit/roofitcore/src/RooNormSetCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNormSetCache.cxx,1,['cache'],['cache']
Performance,"// C r e a t e m a n a g e r; // ---------------------------; // Configure manager to perform binned extended likelihood fits (Binned(),Extended()) on data generated; // with a Poisson fluctuation on Nobs (Extended())",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:86,perform,perform,86,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['perform'],['perform']
Performance,"// C's comma performs lvalue conversion (C99 6.3.2.1) on both its; // operands, but not unary promotions.; // C++'s comma does not do any conversions at all (C++ [expr.comma]p1).; // So we treat the LHS as a ignored value, and in C++ we allow the; // containing site to determine what should be done with the RHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:13,perform,performs,13,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['perform'],['performs']
Performance,"// C++ 6.4.2.p2:; // Integral promotions are performed (on the switch condition).; //; // A case value unrepresentable by the original switch condition; // type (before the promotion) doesn't make sense, even when it can; // be represented by the promoted type. Therefore we need to find; // the pre-promotion type of the switch condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:45,perform,performed,45,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['perform'],['performed']
Performance,"// C++ [basic.lookup.classref]p4:; // If the id-expression in a class member access is a qualified-id of; // the form; //; // class-name-or-namespace-name::...; //; // the class-name-or-namespace-name following the . or -> operator is; // looked up both in the context of the entire postfix-expression and in; // the scope of the class of the object expression. If the name is found; // only in the scope of the class of the object expression, the name; // shall refer to a class-name. If the name is found only in the; // context of the entire postfix-expression, the name shall refer to a; // class-name or namespace-name. [...]; //; // Qualified name lookup into a class will not find a namespace-name,; // so we do not need to diagnose that case specifically. However,; // this qualified name lookup may find nothing. In that case, perform; // unqualified name lookup in the given scope (if available) or; // reconstruct the result from when name lookup was performed at template; // definition time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:836,perform,perform,836,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,2,['perform'],"['perform', 'performed']"
Performance,"// C++ [basic.start.init]p2:; // Definitions of explicitly specialized class template static data; // members have ordered initialization. Other class template static data; // members (i.e., implicitly or explicitly instantiated specializations); // have unordered initialization.; //; // As a consequence, we can put them into their own llvm.global_ctors entry.; //; // If the global is externally visible, put the initializer into a COMDAT; // group with the global being initialized. On most platforms, this is a; // minor startup time optimization. In the MS C++ ABI, there are no guard; // variables, so this COMDAT key is required for correctness.; //; // SelectAny globals will be comdat-folded. Put the initializer into a; // COMDAT group associated with the global, so the initializers get folded; // too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:539,optimiz,optimization,539,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,1,['optimiz'],['optimization']
Performance,// C++ [class.copy]p3:; // A member function template is never instantiated to perform the copy; // of a class object to an object of its class type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:79,perform,perform,79,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['perform'],['perform']
Performance,"// C++ [class.static.data]p4; // If a static data member is of const integral or const; // enumeration type, its declaration in the class definition can; // specify a constant-initializer which shall be an integral; // constant expression (5.19). In that case, the member can appear; // in integral constant expressions. The member shall still be; // defined in a namespace scope if it is used in the program and the; // namespace scope definition shall not contain an initializer.; //; // We already performed a redefinition check above, but for static; // data members we also need to check whether there was an in-class; // declaration with an initializer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:501,perform,performed,501,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['perform'],['performed']
Performance,"// C++ [conv.prom]p5:; // A prvalue for an integral bit-field can be converted to a prvalue of type; // int if int can represent all the values of the bit-field; otherwise, it; // can be converted to unsigned int if unsigned int can represent all the; // values of the bit-field. If the bit-field is larger yet, no integral; // promotion applies to it.; // C11 6.3.1.1/2:; // [For a bit-field of type _Bool, int, signed int, or unsigned int:]; // If an int can represent all values of the original type (as restricted by; // the width, for a bit-field), the value is converted to an int; otherwise,; // it is converted to an unsigned int.; //; // FIXME: C does not permit promotion of a 'long : 3' bitfield to int.; // We perform that promotion here to match GCC and C++.; // FIXME: C does not permit promotion of an enum bit-field whose rank is; // greater than that of 'int'. We perform that promotion to match GCC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:722,perform,perform,722,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,['perform'],['perform']
Performance,"// C++ [expr.cast]p5: The conversions performed by; // - a const_cast,; // - a static_cast,; // - a static_cast followed by a const_cast,; // - a reinterpret_cast, or; // - a reinterpret_cast followed by a const_cast,; // can be performed using the cast notation of explicit type conversion.; // [...] If a conversion can be interpreted in more than one of the ways; // listed above, the interpretation that appears first in the list is used,; // even if a cast resulting from that interpretation is ill-formed.; // In plain language, this means trying a const_cast ...; // Note that for address space we check compatibility after const_cast.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:38,perform,performed,38,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,2,['perform'],['performed']
Performance,"// C++ [expr.new]p20:; // A declaration of a placement deallocation function matches the; // declaration of a placement allocation function if it has the; // same number of parameters and, after parameter transformations; // (8.3.5), all parameter types except the first are; // identical. [...]; //; // To perform this comparison, we compute the function type that; // the deallocation function should have, and use that type both; // for template argument deduction and for comparison purposes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:307,perform,perform,307,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['perform'],['perform']
Performance,// C++ [expr.rel]p2:; // [...] Pointer conversions (4.10) and qualification; // conversions (4.4) are performed on pointer operands (or on; // a pointer operand and a null pointer constant) to bring; // them to their composite pointer type. [...]; //; // C++ [expr.eq]p1 uses the same notion for (in)equality; // comparisons of pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:102,perform,performed,102,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['perform'],['performed']
Performance,// C++ [expr.unary.op]p1: The unary * operator performs indirection:; // [...] the result is an lvalue referring to the object or function; // to which the expression points.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:47,perform,performs,47,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,1,['perform'],['performs']
Performance,// C++ [temp.arg.nontype]p5:; // The following conversions are performed on each expression used; // as a non-type template-argument. If a non-type; // template-argument cannot be converted to the type of the; // corresponding template-parameter then the program is; // ill-formed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:63,perform,performed,63,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['perform'],['performed']
Performance,"// C++ [temp.class.order]p1:; // For two class template partial specializations, the first is at least as; // specialized as the second if, given the following rewrite to two; // function templates, the first function template is at least as; // specialized as the second according to the ordering rules for function; // templates (14.6.6.2):; // - the first function template has the same template parameters as the; // first partial specialization and has a single function parameter; // whose type is a class template specialization with the template; // arguments of the first partial specialization, and; // - the second function template has the same template parameters as the; // second partial specialization and has a single function parameter; // whose type is a class template specialization with the template; // arguments of the second partial specialization.; //; // Rather than synthesize function templates, we merely perform the; // equivalent partial ordering by performing deduction directly on; // the template arguments of the class template partial; // specializations. This computation is slightly simpler than the; // general problem of function template partial ordering, because; // class template partial specializations are more constrained. We; // know that every template parameter is deducible from the class; // template partial specialization's template arguments, for; // example.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:935,perform,perform,935,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,2,['perform'],"['perform', 'performing']"
Performance,"// C++ [temp.deduct.call]p1: (CWG 1591); // If removing references and cv-qualifiers from P gives; // std::initializer_list<P0> or P0[N] for some P0 and N and the argument is; // a non-empty initializer list, then deduction is performed instead for; // each element of the initializer list, taking P0 as a function template; // parameter type and the initializer element as its argument; //; // We've already removed references and cv-qualifiers here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:227,perform,performed,227,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['perform'],['performed']
Performance,// C++ [temp.expl.spec]p11:; // A trailing template-argument can be left unspecified in the; // template-id naming an explicit function template specialization; // provided it can be deduced from the function argument type.; // Perform template argument deduction to determine whether we may be; // specializing this template.; // FIXME: It is somewhat wasteful to build,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:228,Perform,Perform,228,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Perform'],['Perform']
Performance,// C++ [temp.explicit]p3:; // A definition of a class template or class member template; // shall be in scope at the point of the explicit instantiation of; // the class template or class member template.; //; // This check comes when we actually try to perform the; // instantiation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:254,perform,perform,254,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['perform'],['perform']
Performance,"// C++ [temp.mem]p6:; // [...] For each such operator, if argument deduction succeeds; // (14.9.2.3), the resulting specialization is used as if found by; // name lookup.; //; // When referencing a conversion function for any purpose other than; // a redeclaration (such that we'll be building an expression with the; // result), perform template argument deduction and place the; // specialization into the result set. We do this to avoid forcing all; // callers to perform special deduction for conversion functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:330,perform,perform,330,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,2,['perform'],['perform']
Performance,"// C++ [temp.res]p3:; // A qualified-id that refers to a type and in which the; // nested-name-specifier depends on a template-parameter (14.6.2); // shall be prefixed by the keyword typename to indicate that the; // qualified-id denotes a type, forming an; // elaborated-type-specifier (7.1.5.3).; //; // We therefore do not perform any name lookup if the result would; // refer to a member of an unknown specialization.; // In C++2a, in several contexts a 'typename' is not required. Also; // allow this as an extension.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:326,perform,perform,326,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['perform'],['perform']
Performance,"// C++ performs lvalue-to-rvalue conversion as a default argument; // promotion, even on class types, but note:; // C++11 [conv.lval]p2:; // When an lvalue-to-rvalue conversion occurs in an unevaluated; // operand or a subexpression thereof the value contained in the; // referenced object is not accessed. Otherwise, if the glvalue; // has a class type, the conversion copy-initializes a temporary; // of type T from the glvalue and the result of the conversion; // is a prvalue for the temporary.; // FIXME: add some way to gate this entire thing for correctness in; // potentially potentially evaluated contexts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:7,perform,performs,7,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['perform'],['performs']
Performance,"// C++03 [basic.lookup.classref]p1:; // [...] If the lookup in the class of the object expression finds a; // template, the name is also looked up in the context of the entire; // postfix-expression and [...]; //; // Note: C++11 does not perform this second lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:238,perform,perform,238,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['perform'],['perform']
Performance,"// C++03 [basic.lookup.classref]p4:; // [...] If the name is found in both contexts, the; // class-name-or-namespace-name shall refer to the same entity.; //; // We already found the name in the scope of the object. Now, look; // into the current scope (the scope of the postfix-expression) to; // see if we can find the same name there. As above, if there is no; // scope, reconstruct the result from the template instantiation itself.; //; // Note that C++11 does *not* perform this redundant lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:472,perform,perform,472,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['perform'],['perform']
Performance,"// C++03 [namespace.udecl]p4:; // A using-declaration used as a member-declaration shall refer; // to a member of a base class of the class being defined [etc.].; // Salient point: SS doesn't have to name a base class as long as; // lookup only finds members from base classes. Therefore we can; // diagnose here only if we can prove that can't happen,; // i.e. if the class hierarchies provably don't intersect.; // TODO: it would be nice if ""definitely valid"" results were cached; // in the UsingDecl and UsingShadowDecl so that these checks didn't; // need to be repeated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:475,cache,cached,475,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['cache'],['cached']
Performance,"// C++0x [class.copy]p28:; // The implicitly-defined or move assignment operator for a non-union class; // X performs memberwise move assignment of its subobjects. The direct base; // classes of X are assigned first, in the order of their declaration in the; // base-specifier-list, and then the immediate non-static data members of X; // are assigned, in the order in which they were declared in the class; // definition.; // Issue a warning if our implicit move assignment operator will move; // from a virtual base more than once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:109,perform,performs,109,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['perform'],['performs']
Performance,"// C++0x [class.copy]p30:; // The implicitly-defined or explicitly-defaulted copy assignment operator; // for a non-union class X performs memberwise copy assignment of its; // subobjects. The direct base classes of X are assigned first, in the; // order of their declaration in the base-specifier-list, and then the; // immediate non-static data members of X are assigned, in the order in; // which they were declared in the class definition.; // The statements that form the synthesized function body.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:130,perform,performs,130,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['perform'],['performs']
Performance,"// C++0x [meta.rel]p4:; // Given the following function prototype:; //; // template <class T>; // typename add_rvalue_reference<T>::type create();; //; // the predicate condition for a template specialization; // is_convertible<From, To> shall be satisfied if and only if; // the return expression in the following code would be; // well-formed, including any implicit conversions to the return; // type of the function:; //; // To test() {; // return create<From>();; // }; //; // Access checking is performed as if in a context unrelated to To and; // From. Only the validity of the immediate context of the expression; // of the return-statement (including conversions to the return type); // is considered.; //; // We model the initialization as a copy-initialization of a temporary; // of the appropriate type, which for this expression is identical to the; // return statement (since NRVO doesn't apply).; // Functions aren't allowed to return function or array types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:501,perform,performed,501,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['perform'],['performed']
Performance,"// C++0x [over.match.funcs]p4:; // For non-static member functions, the type of the implicit object; // parameter is; //; // - ""lvalue reference to cv X"" for functions declared without a; // ref-qualifier or with the & ref-qualifier; // - ""rvalue reference to cv X"" for functions declared with the &&; // ref-qualifier; //; // where X is the class of which the function is a member and cv is the; // cv-qualification on the member function declaration.; //; // However, when finding an implicit conversion sequence for the argument, we; // are not allowed to perform user-defined conversions; // (C++ [over.match.funcs]p5). We perform a simplified version of; // reference binding here, that allows class rvalues to bind to; // non-constant references.; // First check the qualifiers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:559,perform,perform,559,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['perform'],['perform']
Performance,"// C++11 [class.ctor]p5:; // A default constructor is trivial if:; // - all the [direct subobjects] have trivial default constructors; //; // Note, no overload resolution is performed in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:174,perform,performed,174,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['perform'],['performed']
Performance,"// C++11 [dcl.init.list]p3, per DR1467:; // - If T is a class type and the initializer list has a single element of; // type cv U, where U is T or a class derived from T, the object is; // initialized from that element (by copy-initialization for; // copy-list-initialization, or by direct-initialization for; // direct-list-initialization).; // - Otherwise, if T is a character array and the initializer list has a; // single element that is an appropriately-typed string literal; // (8.5.2 [dcl.init.string]), initialization is performed as described; // in that section.; // - Otherwise, if T is an aggregate, [...] (continue below).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:530,perform,performed,530,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['performed']
Performance,"// C++11 [dcl.init.list]p3:; // - If T is an aggregate, aggregate initialization is performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:84,perform,performed,84,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['performed']
Performance,"// C++11 [dcl.type.simple]p4:; // The type denoted by decltype(e) is defined as follows:; // C++20:; // - if E is an unparenthesized id-expression naming a non-type; // template-parameter (13.2), decltype(E) is the type of the; // template-parameter after performing any necessary type deduction; // Note that this does not pick up the implicit 'const' for a template; // parameter object. This rule makes no difference before C++20 so we apply; // it unconditionally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:256,perform,performing,256,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['perform'],['performing']
Performance,"// C++11 [expr.call]p7:; // After these conversions, if the argument does not have arithmetic,; // enumeration, pointer, pointer to member, or class type, the program; // is ill-formed.; //; // Since we've already performed array-to-pointer and function-to-pointer; // decay, the only such type in C++ is cv void. This also handles; // initializer lists as variadic arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:214,perform,performed,214,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['perform'],['performed']
Performance,"// C++11 [expr.cond]p6; // Lvalue-to-rvalue, array-to-pointer, and function-to-pointer standard; // conversions are performed on the second and third operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:116,perform,performed,116,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['perform'],['performed']
Performance,"// C++11 [expr.prim.lambda]p21:; // When the lambda-expression is evaluated, the entities that; // are captured by copy are used to direct-initialize each; // corresponding non-static data member of the resulting closure; // object. (For array members, the array elements are; // direct-initialized in increasing subscript order.) These; // initializations are performed in the (unspecified) order in; // which the non-static data members are declared.; // C++ [expr.prim.lambda]p12:; // An entity captured by a lambda-expression is odr-used (3.2) in; // the scope containing the lambda-expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:361,perform,performed,361,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['perform'],['performed']
Performance,// C++11 [expr.static.cast]p11: Behavior is undefined if a downcast is; // performed and the object is not of the derived type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:75,perform,performed,75,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['perform'],['performed']
Performance,// C++11 [expr.static.cast]p2: Behavior is undefined if a downcast is; // performed and the object is not of the derived type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:74,perform,performed,74,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['perform'],['performed']
Performance,"// C++11 [over.match.list]p1, per DR1467:; // When objects of non-aggregate type T are list-initialized, such that; // 8.5.4 [dcl.init.list] specifies that overload resolution is performed; // according to the rules in this section, overload resolution selects; // the constructor in two phases:; //; // - Initially, the candidate functions are the initializer-list; // constructors of the class T and the argument list consists of the; // initializer list as a single argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:179,perform,performed,179,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['performed']
Performance,"// C++11 [over.match.list]p1:; // - If no viable initializer-list constructor is found, overload resolution; // is performed again, where the candidate functions are all the; // constructors of the class T and the argument list consists of the; // elements of the initializer list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:115,perform,performed,115,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['performed']
Performance,"// C++11 [temp.deduct.partial]p5:; // Before the partial ordering is done, certain transformations are; // performed on the types used for partial ordering:; // - If P is a reference type, P is replaced by the type referred to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:107,perform,performed,107,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['perform'],['performed']
Performance,"// C++11 and later guarantees that a thread eventually will do one of the; // following (C++11 [intro.multithread]p24 and C++17 [intro.progress]p1):; // - terminate,; // - make a call to a library I/O function,; // - perform an access through a volatile glvalue, or; // - perform a synchronization operation or an atomic operation.; //; // Hence each function is 'mustprogress' in C++11 or later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:217,perform,perform,217,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,2,['perform'],['perform']
Performance,"// C++14 [dcl.init.aggr]p13:; // If the assignment-expression can initialize a member, the member is; // initialized. Otherwise [...] brace elision is assumed; //; // Brace elision is never performed if the element is not an; // assignment-expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:190,perform,performed,190,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['performed']
Performance,"// C++14 and before:; // - if the function is a constructor, the call initializes a temporary; // of the cv-unqualified version of the destination type. The [...]; // temporary [...] is then used to direct-initialize, according to the; // rules above, the object that is the destination of the; // copy-initialization.; // Note that this just performs a simple object copy from the temporary.; //; // C++17:; // - if the function is a constructor, the call is a prvalue of the; // cv-unqualified version of the destination type whose return object; // is initialized by the constructor. The call is used to; // direct-initialize, according to the rules above, the object that; // is the destination of the copy-initialization.; // Therefore we need to do nothing further.; //; // FIXME: Mark this copy as extraneous.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:343,perform,performs,343,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['performs']
Performance,"// C++17 [expr.new]p13:; // If no matching function is found and the allocated object type has; // new-extended alignment, the alignment argument is removed from the; // argument list, and overload resolution is performed again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:212,perform,performed,212,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['perform'],['performed']
Performance,"// C++17 [expr.type.conv]p1:; // If the type is a placeholder for a deduced class type, [...perform class; // template argument deduction...]; // C++23:; // Otherwise, if the type contains a placeholder type, it is replaced by the; // type determined by placeholder type deduction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:92,perform,perform,92,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['perform'],['perform']
Performance,"// C++17 [expr.type.conv]p2:; // If the type is cv void and the initializer is (), the expression is a; // prvalue of the specified type that performs no initialization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:142,perform,performs,142,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['perform'],['performs']
Performance,// C++17 onwards require that we evaluate the RHS first.; // Compute RHS and save it in a temporary variable so we can; // load it again later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:123,load,load,123,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,1,['load'],['load']
Performance,"// C++17 onwards require that we evaluate the RHS first.; // Compute RHS and save it in a temporary variable so we can; // load it again later.; // FIXME: Compound assignments are unsequenced in C, so we might; // have to figure out how to reject them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:123,load,load,123,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,1,['load'],['load']
Performance,"// C++1y / DR1070:; // shall be initialized [...] from an empty initializer list.; //; // We apply the resolution of this DR to C++11 but not C++98, since C++98; // does not have useful semantics for initialization from an init list.; // We treat this as copy-initialization, because aggregate initialization; // always performs copy-initialization on its elements.; //; // Only do this if we're initializing a class type, to avoid filling in; // the initializer list where possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:320,perform,performs,320,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['performs']
Performance,// C++1y [dcl.constexpr]p3 allows anything except:; // a definition of a variable of non-literal type or of static or; // thread storage duration or [before C++2a] for which no; // initialization is performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:199,perform,performed,199,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['perform'],['performed']
Performance,"// C++1z [over.load]p2; // Certain function declarations cannot be overloaded:; // -- Function declarations that differ only in the return type,; // the exception specification, or both cannot be overloaded.; // Check the exception specifications match. This may recompute the type of; // both Old and New if it resolved exception specifications, so grab the; // types again after this. Because this updates the type, we do this before; // any of the other checks below, which may update the ""de facto"" NewQType; // but do not necessarily update the type of New.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:15,load,load,15,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['load'],['load']
Performance,"// C++1z [over.match.class.deduct]p1:; // Initialization and overload resolution are performed as described in; // [dcl.init] and [over.match.ctor], [over.match.copy], or [over.match.list]; // (as appropriate for the type of initialization performed) for an object; // of a hypothetical class type, where the selected functions and function; // templates are considered to be the constructors of that class type; //; // Since we know we're initializing a class type of a type unrelated to that; // of the initializer, this reduces to something fairly reasonable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:85,perform,performed,85,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,2,['perform'],['performed']
Performance,"// C++1z [temp.arg.template]p4: (DR 150); // A template template-parameter P is at least as specialized as a; // template template-argument A if, given the following rewrite to two; // function templates...; // Rather than synthesize function templates, we merely perform the; // equivalent partial ordering by performing deduction directly on; // the template parameter lists of the template template parameters.; //; // Given an invented class template X with the template parameter list of; // A (including default arguments):",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:264,perform,perform,264,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,2,['perform'],"['perform', 'performing']"
Performance,"// C++20 [dcl.init.list]p3:; // - If the braced-init-list contains a designated-initializer-list, T shall; // be an aggregate class. [...] Aggregate initialization is performed.; //; // We allow arrays here too in order to support array designators.; //; // FIXME: This check should precede the handling of reference initialization.; // We follow other compilers in allowing things like 'Aggr &&a = {.x = 1};'; // as a tentative DR resolution.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:167,perform,performed,167,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['performed']
Performance,"// C++20 [dcl.init.list]p3:; // The ordered identifiers in the designators of the designated-; // initializer-list shall form a subsequence of the ordered identifiers; // in the direct non-static data members of T.; //; // Note that this is not a condition on forming the aggregate; // initialization, only on actually performing initialization,; // so it is not checked in VerifyOnly mode.; //; // FIXME: This is the only reordering diagnostic we produce, and it only; // catches cases where we have a top-level field designator that jumps; // backwards. This is the only such case that is reachable in an; // otherwise-valid C++20 program, so is the only case that's required for; // conformance, but for consistency, we should diagnose all the other; // cases where a designator takes us backwards too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:319,perform,performing,319,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['performing']
Performance,"// C++20 designated initialization can result in direct-list-initialization; // of the designated subobject. This is the only way that we can end up; // performing direct initialization as part of aggregate initialization, so; // it needs special handling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:153,perform,performing,153,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['performing']
Performance,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless [...] x is a reference that is usable in; // constant expressions.; // CUDA/HIP:; // If a reference variable referencing a host variable is captured in a; // device or host device lambda, the value of the referee must be copied; // to the capture and the reference variable must be treated as odr-use; // since the value of the referee is not known at compile time and must; // be loaded from the captured.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:513,load,loaded,513,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['load'],['loaded']
Performance,// C++2a [class.compare.default]p3 [P2002R0]:; // A defaulted comparison function is constexpr-compatible if; // [...] no overlod resolution performed [...] results in a; // non-constexpr function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:141,perform,performed,141,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['perform'],['performed']
Performance,"// C++2a [expr.spaceship]p6: If at least one of the operands is of pointer; // type, array-to-pointer, ..., conversions are performed on both operands to; // bring them to their composite type.; // Otherwise, all comparisons expect an rvalue, so convert to rvalue before; // any type-related checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:124,perform,performed,124,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['perform'],['performed']
Performance,"// C++98 [expr.new]p7:; // The expression in a direct-new-declarator shall have integral type; // with a non-negative value.; //; // Let's see if this is a constant < 0. If so, we reject it out of hand,; // per CWG1464. Otherwise, if it's not a constant, we must have an; // unparenthesized array type.; // We've already performed any required implicit conversion to integer or; // unscoped enumeration type.; // FIXME: Per CWG1464, we are required to check the value prior to; // converting to size_t. This will never find a negative array size in; // C++14 onwards, because Value is always unsigned here!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:321,perform,performed,321,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['perform'],['performed']
Performance,"// C++: Perform implicit template instantiations.; //; // FIXME: When we perform these implicit instantiations, we do not; // carefully keep track of the point of instantiation (C++ [temp.point]).; // This means that name lookup that occurs within the template; // instantiation will always happen at the end of the translation unit,; // so it will find some names that are not required to be found. This is; // valid, but we could do better by diagnosing if an instantiation uses a; // name that was not visible at its first point of instantiation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:8,Perform,Perform,8,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,2,"['Perform', 'perform']","['Perform', 'perform']"
Performance,"// C99 6.3.1.1p2; /// Return the ""preferred"" alignment of the specified type \p T for; /// the current target, in bits.; ///; /// This can be different than the ABI alignment in cases where it is; /// beneficial for performance or backwards compatibility preserving to; /// overalign a data type. (Note: despite the name, the preferred alignment; /// is ABI-impacting, and not an optimization.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:216,perform,performance,216,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"// C99 6.5.2.2p6:; // If the expression that denotes the called function has a type; // that does not include a prototype, [the default argument; // promotions are performed]. If the number of arguments does not; // equal the number of parameters, the behavior is undefined. If; // the function is defined with a type that includes a prototype,; // and either the prototype ends with an ellipsis (, ...) or the; // types of the arguments after promotion are not compatible with; // the types of the parameters, the behavior is undefined. If the; // function is defined with a type that does not include a; // prototype, and the types of the arguments after promotion are; // not compatible with those of the parameters after promotion,; // the behavior is undefined [except in some trivial cases].; // That is, in the general case, we should assume that a call; // through an unprototyped function type works like a *non-variadic*; // call. The way we make this work is to cast to the exact type; // of the promoted arguments.; //; // Chain calls use this same code path to add the invisible chain parameter; // to the function type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:164,perform,performed,164,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['perform'],['performed']
Performance,// C99 6.8.4.2p5 - Integer promotions are performed on the controlling expr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:42,perform,performed,42,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['perform'],['performed']
Performance,"// CF is used, we can't perform this optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:24,perform,perform,24,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"// CFI-specific: if we are exporting and any llvm.type.checked.load; // intrinsics were *not* devirtualized, we need to add the resulting; // llvm.type.test intrinsics to the function summaries so that the; // LowerTypeTests pass will export them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:63,load,load,63,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['load'],['load']
Performance,"// CLING WORKAROUND: make sure variable is loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:43,load,loaded,43,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['load'],['loaded']
Performance,"// CLING WORKAROUND: the following causes templates to be instantiated first within the proper; // scope, making the lookup succeed and preventing spurious duplicate instantiations later. Also,; // if the variable is not yet loaded, pull it in through gInterpreter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:225,load,loaded,225,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['load'],['loaded']
Performance,// CMSE: Check for target 8M (for -mcmse to be applicable) is performed later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:62,perform,performed,62,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,1,['perform'],['performed']
Performance,// CPU being tuned for.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h:13,tune,tuned,13,interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,1,['tune'],['tuned']
Performance,"// CPU load information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TSystem.h:7,load,load,7,core/base/inc/TSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TSystem.h,1,['load'],['load']
Performance,"// CUDA_VERSION >= 9020; // CUDA no longer provides inline assembly (or bitcode) implementation of these; // functions, so we have to reimplment them. The implementation is naive and is; // not optimized for performance.; // Helper function to convert N-bit boolean subfields into all-0 or all-1.; // E.g. __bool2mask(0x01000100,8) -> 0xff00ff00; // __bool2mask(0x00010000,16) -> 0xffff0000",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h:194,optimiz,optimized,194,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,2,"['optimiz', 'perform']","['optimized', 'performance']"
Performance,"// CXSourceLocation consists of the following fields:; //; // void *ptr_data[2];; // unsigned int_data;; //; // The lowest bit of ptr_data[0] is always set to 1 to indicate this; // is a persistent diagnostic.; //; // For now, do the unoptimized approach and store the data in a side; // data structure. We can optimize this case later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXLoadedDiagnostic.cpp:311,optimiz,optimize,311,interpreter/llvm-project/clang/tools/libclang/CXLoadedDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXLoadedDiagnostic.cpp,1,['optimiz'],['optimize']
Performance,// Cache (64-bit pointer),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,1,['Cache'],['Cache']
Performance,"// Cache Dir",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:3,Cache,Cache,3,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,1,['Cache'],['Cache']
Performance,// Cache Exprs,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Z3Solver.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Support/Z3Solver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Z3Solver.cpp,1,['Cache'],['Cache']
Performance,// Cache Hit!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['Cache'],['Cache']
Performance,"// Cache Manager class generic objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h:3,Cache,Cache,3,roofit/roofitcore/inc/RooCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h,1,['Cache'],['Cache']
Performance,// Cache ProfileSummaryAnalysis once to avoid the potential need to insert; // RequireAnalysisPass for PSI before subsequent non-module passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,4,['Cache'],['Cache']
Performance,// Cache ROCm installation search paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,1,['Cache'],['Cache']
Performance,// Cache Sorts,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Z3Solver.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Support/Z3Solver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Z3Solver.cpp,1,['Cache'],['Cache']
Performance,// Cache VVT's default mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['Cache'],['Cache']
Performance,// Cache a bunch of frame-related predicates for this subtarget.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['Cache'],['Cache']
Performance,// Cache all of our results so we can cheaply reuse them; // NOTE: This is actually two caches: one of the base defining value; // relation and one of the base pointer relation! FIXME,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,2,"['Cache', 'cache']","['Cache', 'caches']"
Performance,"// Cache all of the lookups performed by this method. Many headers are; // multiply included, and the ""pragma once"" optimization prevents them from; // being relex/pp'd, but they would still have to search through a; // (potentially huge) series of SearchDirs to find it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,3,"['Cache', 'optimiz', 'perform']","['Cache', 'optimization', 'performed']"
Performance,"// Cache all successors, sorted by frequency info and cycle depth.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['Cache'],['Cache']
Performance,// Cache already parsed PatFrags to avoid doing extra work.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,1,['Cache'],['Cache']
Performance,// Cache and recycle the CodeExtractor analysis to avoid O(n^2) compile-time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,2,['Cache'],['Cache']
Performance,// Cache and return.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ConstantInitBuilder.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/CodeGen/ConstantInitBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ConstantInitBuilder.cpp,1,['Cache'],['Cache']
Performance,// Cache arch related info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,1,['Cache'],['Cache']
Performance,// Cache arguments that will be moved to the end in the target node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['Cache'],['Cache']
Performance,"// Cache column names for this variation and store views for later use",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx:3,Cache,Cache,3,tree/dataframe/src/RDFColumnRegister.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx,1,['Cache'],['Cache']
Performance,"// Cache constant nodes with dataset - also cache entries corresponding to zero-weights in data when using BinnedLikelihood",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx:3,Cache,Cache,3,roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,2,"['Cache', 'cache']","['Cache', 'cache']"
Performance,"// Cache constant nodes with dataset - also cache entries corresponding to zero-weights in data when using; // BinnedLikelihood; // NOTE: we pass nullptr as cache-owner here, because we don't use the cacheOwner() anywhere in TestStatistics; // TODO: make sure this (nullptr) is always correct",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/ConstantTermsOptimizer.cxx:3,Cache,Cache,3,roofit/roofitcore/src/TestStatistics/ConstantTermsOptimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/ConstantTermsOptimizer.cxx,4,"['Cache', 'cache']","['Cache', 'cache', 'cache-owner', 'cacheOwner']"
Performance,"// Cache contains sorted {V1,V2} pairs but we should return original order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['Cache'],['Cache']
Performance,"// Cache contains sorted {V1,V2} pairs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['Cache'],['Cache']
Performance,"// Cache copy feature is not publicly accessible",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooDataSet.h:3,Cache,Cache,3,roofit/roofitcore/inc/RooDataSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooDataSet.h,1,['Cache'],['Cache']
Performance,"// Cache dir",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:3,Cache,Cache,3,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,1,['Cache'],['Cache']
Performance,"// Cache dir locker",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProofLite.h:3,Cache,Cache,3,proof/proof/inc/TProofLite.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProofLite.h,1,['Cache'],['Cache']
Performance,// Cache disabled or no entry for this module in the combined index or; // no module hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['Cache'],['Cache']
Performance,"// Cache element containing expensive object and parameter values for which object is valid",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooExpensiveObjectCache.h:3,Cache,Cache,3,roofit/roofitcore/inc/RooExpensiveObjectCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooExpensiveObjectCache.h,1,['Cache'],['Cache']
Performance,// Cache file 'stat' results and directories with absolutely paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,1,['Cache'],['Cache']
Performance,// Cache for is hidden property,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,1,['Cache'],['Cache']
Performance,// Cache for later,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp,2,['Cache'],['Cache']
Performance,// Cache for phi-translate in scalarpre.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,1,['Cache'],['Cache']
Performance,// Cache for pointerMayBeCaptured calls inside AA. This is preserved; // globally through SLP because we don't perform any action which; // invalidates capture results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,"['Cache', 'perform']","['Cache', 'perform']"
Performance,"// Cache for the ""fake"" buffer used for error-recovery purposes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:3,Cache,Cache,3,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['Cache'],['Cache']
Performance,"// Cache for the BitTracker's cell map. Map lookup has a logarithmic; // complexity, this class will memoize the lookup results to reduce; // the access time for repeated lookups of the same cell.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,1,['Cache'],['Cache']
Performance,// Cache for this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.h,1,['Cache'],['Cache']
Performance,// Cache for this.; /// Number of bytes in the LDS that are being used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.h,1,['Cache'],['Cache']
Performance,"// Cache for x values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooNDKeysPdf.h:3,Cache,Cache,3,roofit/roofit/inc/RooNDKeysPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooNDKeysPdf.h,1,['Cache'],['Cache']
Performance,"// Cache from index to (Align, Offset Pair)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['Cache'],['Cache']
Performance,// Cache glue to its user,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,1,['Cache'],['Cache']
Performance,// Cache hit :),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp,1,['Cache'],['Cache']
Performance,"// Cache is dirty, no calculation has been started yet; //cout << ""RooRealMPFE::getValF("" << GetName() << "") cache is dirty, calling calculate and evaluate"" << endl ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx:3,Cache,Cache,3,roofit/roofitcore/src/RooRealMPFE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx,2,"['Cache', 'cache']","['Cache', 'cache']"
Performance,"// Cache is enabled, hard-link the entry (or copy if hard-link fails).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['Cache'],['Cache']
Performance,"// Cache is invalidated and we need to wait for all unzipping tasks to be finished before fill new baskets in cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:3,Cache,Cache,3,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,2,"['Cache', 'cache']","['Cache', 'cache']"
Performance,// Cache it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,1,['Cache'],['Cache']
Performance,"// Cache knowledge of AR NSW, which is propagated to this AddRec.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Cache'],['Cache']
Performance,"// Cache knowledge of AR NUW, which is propagated to this AddRec.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Cache'],['Cache']
Performance,"// Cache knowledge of AR NW, which is propagated to this AddRec.; // Negative step causes unsigned wrap, but it still can't self-wrap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Cache'],['Cache']
Performance,"// Cache knowledge of AR NW, which is propagated to this; // AddRec. Negative step causes unsigned wrap, but it; // still can't self-wrap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Cache'],['Cache']
Performance,// Cache known disjoint allowed registers pairs,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,1,['Cache'],['Cache']
Performance,// Cache level bits,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,3,['Cache'],['Cache']
Performance,// Cache line size. Most architectures have 32 or 64 byte cache lines.; // We use 64 bytes here because it provides good branching factors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,2,"['Cache', 'cache']","['Cache', 'cache']"
Performance,// Cache lookup using SchedClassID from Instrumentation,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,1,['Cache'],['Cache']
Performance,"// Cache management",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProofLite.h:3,Cache,Cache,3,proof/proof/inc/TProofLite.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProofLite.h,2,['Cache'],['Cache']
Performance,"// Cache management functions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCachedPdf.h:3,Cache,Cache,3,roofit/roofitcore/inc/RooAbsCachedPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCachedPdf.h,4,['Cache'],['Cache']
Performance,// Cache misses on the chains before merging.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['Cache'],['Cache']
Performance,// Cache misses on the merged chain,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['Cache'],['Cache']
Performance,"// Cache must ignore the #var columns",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_more.cxx:3,Cache,Cache,3,tree/dataframe/test/datasource_more.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_more.cxx,1,['Cache'],['Cache']
Performance,"// Cache must throw if #var is passed explicitly...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_more.cxx:3,Cache,Cache,3,tree/dataframe/test/datasource_more.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_more.cxx,1,['Cache'],['Cache']
Performance,"// Cache needs to be able to clear _norm pointer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooMomentMorph.h:3,Cache,Cache,3,roofit/roofit/inc/RooMomentMorph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooMomentMorph.h,2,['Cache'],['Cache']
Performance,"// Cache numeric integrals in >1d expensive object cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:3,Cache,Cache,3,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,4,"['Cache', 'cache']","['Cache', 'cache']"
Performance,"// Cache of addresses to FQDNs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/inc/TNetXNGSystem.h:3,Cache,Cache,3,net/netxng/inc/TNetXNGSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/inc/TNetXNGSystem.h,1,['Cache'],['Cache']
Performance,// Cache of created instructions to avoid creating duplicates.; // XXX Currently only used by genBitSplit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,1,['Cache'],['Cache']
Performance,// Cache of frame indexes used on previous instruction processing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,1,['Cache'],['Cache']
Performance,// Cache of mapping from node ids (for RefNodes) to the containing; // basic blocks. Not computing it each time for each node reduces; // the liveness calculation time by a large fraction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFLiveness.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFLiveness.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFLiveness.h,1,['Cache'],['Cache']
Performance,// Cache of pre-allocated worklists for data-recursion walk of Stmts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h:3,Cache,Cache,3,interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h,1,['Cache'],['Cache']
Performance,// Cache of reached blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,1,['Cache'],['Cache']
Performance,"// Cache of the BasePtr and Stride determined from this GEP. When a GEP is; // used by multiple gathers/scatters, this allow us to reuse the scalar; // instructions we created for the first gather/scatter for the others.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,1,['Cache'],['Cache']
Performance,// Cache of the vtable's size in bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,1,['Cache'],['Cache']
Performance,"// Cache optimisation, count true and false positives with memory access; // instead of code branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/ResultsMulticlass.cxx:3,Cache,Cache,3,tmva/tmva/src/ResultsMulticlass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/ResultsMulticlass.cxx,1,['Cache'],['Cache']
Performance,// Cache original types of the values that will likely need truncating,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,1,['Cache'],['Cache']
Performance,// Cache our result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp,1,['Cache'],['Cache']
Performance,"// Cache parameter set",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:3,Cache,Cache,3,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['Cache'],['Cache']
Performance,// Cache resolved constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['Cache'],['Cache']
Performance,"// Cache results for the lifetime of the Simplifier. Results change every; // time new constraints are added to the program state, which is the whole; // point of simplifying, and for that very reason it's pointless to maintain; // the same cache for the duration of the whole analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,2,"['Cache', 'cache']","['Cache', 'cache']"
Performance,"// Cache size",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TEventIter.h:3,Cache,Cache,3,proof/proofplayer/inc/TEventIter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TEventIter.h,1,['Cache'],['Cache']
Performance,// Cache some information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp,1,['Cache'],['Cache']
Performance,// Cache some types,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,1,['Cache'],['Cache']
Performance,// Cache subframework.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,1,['Cache'],['Cache']
Performance,// Cache the 'defining value' relation used in the computation and; // insertion of base phis and selects. This ensures that we don't insert; // large numbers of duplicate base_phis. Use one cache for both; // inlineGetBaseAndOffset() and insertParsePoints().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,2,"['Cache', 'cache']","['Cache', 'cache']"
Performance,"// Cache the (non-uniqified!) list of predecessors in a vector,; // checking the limit at the same time for efficiency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['Cache'],['Cache']
Performance,"// Cache the ABI from the TargetMachine, we use it everywhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,1,['Cache'],['Cache']
Performance,// Cache the DataLayout since we use it a lot.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['Cache'],['Cache']
Performance,// Cache the DomTree node that defined the value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,2,['Cache'],['Cache']
Performance,"// Cache the Loop ExitBlocks across this loop. We expect to get a lot of; // instructions within the same loops, computing the exit blocks is; // expensive, and we're not mutating the loop structure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,1,['Cache'],['Cache']
Performance,// Cache the MCRegisterInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,2,['Cache'],['Cache']
Performance,"// Cache the Pass ID here in case the pass manager finds this pass is; // redundant with ones already scheduled / available, and deletes it.; // Fundamentally, once we add the pass to the manager, we no longer own it; // and shouldn't reference it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,1,['Cache'],['Cache']
Performance,// Cache the Produced object file,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['Cache'],['Cache']
Performance,// Cache the SP register vreg if we need it more than once in this call site.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64CallLowering.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64CallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64CallLowering.cpp,3,['Cache'],['Cache']
Performance,// Cache the critical resources ID in this scheduled zone.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['Cache'],['Cache']
Performance,"// Cache the current info if we now have it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:3,Cache,Cache,3,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['Cache'],['Cache']
Performance,"// Cache the current value, so that we can return a reference to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h,3,['Cache'],['Cache']
Performance,// Cache the decl of the right overload.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StringChecker.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StringChecker.cpp,1,['Cache'],['Cache']
Performance,// Cache the demangled names.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,1,['Cache'],['Cache']
Performance,// Cache the fact V is it's own base for later usage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['Cache'],['Cache']
Performance,// Cache the fact that this declaration is implicitly visible because; // its parent has a visible definition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['Cache'],['Cache']
Performance,// Cache the fact that this definition is implicitly visible because; // there is a visible merged definition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['Cache'],['Cache']
Performance,// Cache the globals for all vbtables so we don't have to recompute the; // mangled names.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['Cache'],['Cache']
Performance,"// Cache the index of the branch in the cache's array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreePerfStats.h:3,Cache,Cache,3,tree/treeplayer/inc/TTreePerfStats.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreePerfStats.h,2,"['Cache', 'cache']","['Cache', 'cache']"
Performance,"// Cache the inlined-at nodes as they're built so they are reused, without; // this every instruction's inlined-at chain would become distinct from each; // other.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['Cache'],['Cache']
Performance,// Cache the iterator before visiting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,1,['Cache'],['Cache']
Performance,"// Cache the landing pad on the innermost scope. If this is a; // non-EH scope, cache the landing pad on the enclosing scope, too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,2,"['Cache', 'cache']","['Cache', 'cache']"
Performance,// Cache the lexed token.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,1,['Cache'],['Cache']
Performance,"// Cache the likelihood ratio L(\rho)/L(\hat{\rho}), too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiencyHelper.h:3,Cache,Cache,3,hist/hist/src/TEfficiencyHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiencyHelper.h,1,['Cache'],['Cache']
Performance,// Cache the list of excess pressure sets in this region. This will also track; // the max pressure in the scheduled code for these sets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['Cache'],['Cache']
Performance,"// Cache the name and the value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx:3,Cache,Cache,3,core/dictgen/src/XMLReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx,1,['Cache'],['Cache']
Performance,"// Cache the pointers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:3,Cache,Cache,3,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Cache'],['Cache']
Performance,// Cache the properties info at module-init time so we don't have to; // construct them for every function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h,1,['Cache'],['Cache']
Performance,"// Cache the redirection in the previously-inserted entry, still available; // in the tentative return value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,1,['Cache'],['Cache']
Performance,"// Cache the resolved paths based on the index in the line table,; // because calling realpath is expensive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp,2,['Cache'],['Cache']
Performance,"// Cache the result for later visits. If we happened to visit this during; // the above recursion, we would consider it unknown until now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,1,['Cache'],['Cache']
Performance,"// Cache the result of an SMT query (true, false, unknown). The key is the; // hash of the constraints in a state",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConstraintManager.h:3,Cache,Cache,3,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConstraintManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConstraintManager.h,1,['Cache'],['Cache']
Performance,// Cache the result of checking for constant initialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Cache'],['Cache']
Performance,// Cache the result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,3,['Cache'],['Cache']
Performance,// Cache the results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['Cache'],['Cache']
Performance,// Cache the sort key.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,1,['Cache'],['Cache']
Performance,// Cache the sum of all unit weights.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,1,['Cache'],['Cache']
Performance,// Cache the summary with original key to make the next lookup faster; // and return the iterator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h:3,Cache,Cache,3,interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h,1,['Cache'],['Cache']
Performance,// Cache the tokens for the exception-specification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['Cache'],['Cache']
Performance,// Cache the valid types we encounter to avoid rechecking structs that are; // used again,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Cache'],['Cache']
Performance,"// Cache the value in memory than is not part of the object but is accessible via a SchemaRule",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TVirtualStreamerInfo.h:3,Cache,Cache,3,core/meta/inc/TVirtualStreamerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TVirtualStreamerInfo.h,1,['Cache'],['Cache']
Performance,// Cache the vmaddress of __TEXT,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp,1,['Cache'],['Cache']
Performance,// Cache this info for later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['Cache'],['Cache']
Performance,// Cache this slot so we find it when going through the normal; // assignment loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,1,['Cache'],['Cache']
Performance,// Cache this value so we don't re-check it after type-erased operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,1,['Cache'],['Cache']
Performance,// Cache to store the penalty of formatting a vector of AnnotatedLines; // starting from a specific additional offset. Improves performance if there; // are many nested blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.h:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.h,2,"['Cache', 'perform']","['Cache', 'performance']"
Performance,// Cache token uses found so far. Note that we track the unique definitions; // and not the token values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericConvergenceVerifier.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/include/llvm/ADT/GenericConvergenceVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericConvergenceVerifier.h,1,['Cache'],['Cache']
Performance,"// Cache used frame indexes during statepoint re-write to re-use them in; // processing next statepoint instruction.; // Two strategies. One is to preserve the size of spill slot while another one; // extends the size of spill slots to reduce the number of them, causing; // the less total frame size. But unspill will have ""implicit"" any extend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,1,['Cache'],['Cache']
Performance,// Cache variable used by hasBranchTargetEnforcement().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:3,Cache,Cache,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['Cache'],['Cache']
Performance,// Cache whether or not the constant is a splat.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h:3,Cache,Cache,3,interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,1,['Cache'],['Cache']
Performance,"// Cache's paren var-list is required, so error here if it isn't provided.; // We know that the consumeOpen above left the first non-paren here, so; // diagnose, then continue as if it was completely omitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:3,Cache,Cache,3,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['Cache'],['Cache']
Performance,"// CacheLineStep",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFActionHelpers.cxx:3,Cache,CacheLineStep,3,tree/dataframe/src/RDFActionHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFActionHelpers.cxx,2,['Cache'],['CacheLineStep']
Performance,// Cached analysis information for the current function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:3,Cache,Cached,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,1,['Cache'],['Cached']
Performance,"// Cached eve-element pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveGedEditor.h:3,Cache,Cached,3,graf3d/eve/inc/TEveGedEditor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveGedEditor.h,1,['Cache'],['Cached']
Performance,// Cached ext-tsp score for the chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Cache,Cached,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['Cache'],['Cached']
Performance,"// Cached for convenience",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/inc/TNetXNGSystem.h:3,Cache,Cached,3,net/netxng/inc/TNetXNGSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/inc/TNetXNGSystem.h,1,['Cache'],['Cached']
Performance,"// Cached for performance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/BaseSelectionRule.h:3,Cache,Cached,3,core/dictgen/res/BaseSelectionRule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/BaseSelectionRule.h,2,"['Cache', 'perform']","['Cached', 'performance']"
Performance,// Cached gain value for merging the pair of chains.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Cache,Cached,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['Cache'],['Cached']
Performance,"// Cached gain values for merging the pair of chains. Since the gain of; // merging (Src, Dst) and (Dst, Src) might be different, we store both values; // here and a flag indicating which of the options results in a higher gain.; // Cached gain values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Cache,Cached,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,2,['Cache'],['Cached']
Performance,// Cached gnu_debuglink's target CRC,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/CommonConfig.h:3,Cache,Cached,3,interpreter/llvm-project/llvm/include/llvm/ObjCopy/CommonConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/CommonConfig.h,1,['Cache'],['Cached']
Performance,// Cached information for anything that uses LHS will be invalid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Cache,Cached,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['Cache'],['Cached']
Performance,// Cached information for anything that uses NotCmp will be invalid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Cache,Cached,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['Cache'],['Cached']
Performance,// Cached methods which are marked as 'call_super'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/examples/CallSuperAttribute/CallSuperAttrInfo.cpp:3,Cache,Cached,3,interpreter/llvm-project/clang/examples/CallSuperAttribute/CallSuperAttrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/examples/CallSuperAttribute/CallSuperAttrInfo.cpp,1,['Cache'],['Cached']
Performance,"// Cached model projection",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveProjectionAxesGL.h:3,Cache,Cached,3,graf3d/eve/inc/TEveProjectionAxesGL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveProjectionAxesGL.h,1,['Cache'],['Cached']
Performance,// Cached queries per register unit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:3,Cache,Cached,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,1,['Cache'],['Cached']
Performance,// Cached register mask interference info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:3,Cache,Cached,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,1,['Cache'],['Cached']
Performance,// Cached result of EvaluateCRExpr(Val),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:3,Cache,Cached,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,1,['Cache'],['Cached']
Performance,// Cached results from CallerCalleePair to the number of available call paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.h:3,Cache,Cached,3,interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.h,1,['Cache'],['Cached']
Performance,// Cached results from a CallerCalleePair to a unique call path between them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.h:3,Cache,Cached,3,interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.h,1,['Cache'],['Cached']
Performance,// Cached subtarget predicates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:3,Cache,Cached,3,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,2,['Cache'],['Cached']
Performance,// Cached symbolization from PC to Frame.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/RawMemProfReader.h:3,Cache,Cached,3,interpreter/llvm-project/llvm/include/llvm/ProfileData/RawMemProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/RawMemProfReader.h,1,['Cache'],['Cached']
Performance,"// Cached the correct isprint variant rather than checking in a loop.; //; // If output handles UTF-8 and string is UTF-8, then validate against UTF-8.; // If string is UTF-8 validate printable against std::isprint<char32_t>.; // If nothing is UTF-8 validate against std::isprint<char> .",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/UTF8.cpp:3,Cache,Cached,3,interpreter/cling/lib/Utils/UTF8.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/UTF8.cpp,1,['Cache'],['Cached']
Performance,"// Cached tobj pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveGedEditor.h:3,Cache,Cached,3,graf3d/eve/inc/TEveGedEditor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveGedEditor.h,1,['Cache'],['Cached']
Performance,"// Cached version of system function lstat",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:3,Cache,Cached,3,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['Cache'],['Cached']
Performance,"// Cached version of system function readlink",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:3,Cache,Cached,3,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['Cache'],['Cached']
Performance,"// Cached version of system function realpath",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:3,Cache,Cached,3,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['Cache'],['Cached']
Performance,// Caches boolean evaluations of expressions to avoid multiple re-evaluations; // during construction of branches for chained logical operators.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:3,Cache,Caches,3,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['Cache'],['Caches']
Performance,// Caches for hasPredecessorHelper.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Cache,Caches,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Cache'],['Caches']
Performance,// Caches the converted primitive shadow value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:3,Cache,Caches,3,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,1,['Cache'],['Caches']
Performance,// Caches the primitive shadow value that built the shadow value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:3,Cache,Caches,3,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,1,['Cache'],['Caches']
Performance,// Caches.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:3,Cache,Caches,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,1,['Cache'],['Caches']
Performance,// Calculate by how many bytes the stack has to be adjusted in case of tail; // call optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:85,optimiz,optimization,85,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['optimiz'],['optimization']
Performance,"// Calculate cache contents; // Decode integration code",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx:13,cache,cache,13,roofit/roofitcore/src/RooMultiVarGaussian.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx,1,['cache'],['cache']
Performance,"// Calculate the expected task execution order for a priority queue; //; // We would expect the first executed task to be the one with the highest; // priority, but it is sometimes (even often) rather one of the first; // submitted tasks instead. This is because the worker will immediately steal; // a task once one is on the queue. Often, the worker's first request comes; // before the highest priority one was added. So when comparing to the; // suggested order, we have to move this first executed task to the front.; //; // Things can go even worse in slow systems; there may be several tasks that; // get executed before the queue managed to receive all tasks. We loop; // through all of these, until we hit the last submitted task. From that point; // on, we demand adherence to the expected order.; //; // In the worst case, this could mean that the tasks are received as 0, 1,; // 2, 3, 4, 5, 6, 7, 8, 9. This is still expected behavior, given the; // asynchronous nature of the system, although, of course, quite; // undesirable and would indicate a clear need to improve performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Queue.cxx:62,queue,queue,62,roofit/multiprocess/test/test_Queue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Queue.cxx,4,"['perform', 'queue']","['performance', 'queue']"
Performance,"// Calculate the first values; // Always call EvalInstance(0) to insure the loading; // of the branches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorEntries.cxx:76,load,loading,76,tree/treeplayer/src/TSelectorEntries.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorEntries.cxx,1,['load'],['loading']
Performance,"// Calculate the individual character placements.; // Otherwise, if a string is printed in one line the kerning is not; // performed. In order to measure the precise character positions we need to; // trick FreeType into rendering high-resolution characters otherwise it will; // stick to the screen pixel grid which is far worse than we can achieve on; // print.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TPDF.cxx:123,perform,performed,123,graf2d/postscript/src/TPDF.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TPDF.cxx,1,['perform'],['performed']
Performance,// Calculate the multiplicative inverse of K! / 2^T;; // this multiplication factor will perform the exact division by; // K! / 2^T.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:89,perform,perform,89,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['perform'],['perform']
Performance,// Calculate the new Ptr and create the new load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,load,load,44,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,// Calculate the total size to store. We don't have access to what we're; // actually storing other than performing the loop and collecting the; // info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:105,perform,performing,105,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,2,['perform'],['performing']
Performance,// Calculate this function's optimization goal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMAsmPrinter.cpp:29,optimiz,optimization,29,interpreter/llvm-project/llvm/lib/Target/ARM/ARMAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMAsmPrinter.cpp,1,['optimiz'],['optimization']
Performance,"// Call CINT to perform constructor call. Catch any error thrown by argument conversion method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx:16,perform,perform,16,roofit/roofitcore/src/RooFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx,1,['perform'],['perform']
Performance,"// Call DAG.getMemIntrinsicNode for a load, but first widen a dwordx3 type to; // dwordx4 if on SI and handle TFE loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:38,load,load,38,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,2,['load'],"['load', 'loads']"
Performance,"// Call DAG.getMemIntrinsicNode for a load, but first widen a dwordx3 type to; // dwordx4 if on SI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.h:38,load,load,38,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.h,1,['load'],['load']
Performance,// Call EmitLoadOfScalar except when the lvalue is a bitfield to emit a; // primitive load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:86,load,load,86,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['load'],['load']
Performance,"// Call LowerUnalignedLoad for all loads, it recognizes loads that; // don't need extra aligning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:35,load,loads,35,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,2,['load'],['loads']
Performance,"// Call fegetmode, which saves control modes into a stack slot. Then load; // the value to return from the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:69,load,load,69,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['load'],['load']
Performance,// Call lowering helpers.; /// Check whether the call is eligible for tail call optimization. Targets; /// that want to do tail call optimization should implement this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:80,optimiz,optimization,80,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,2,['optimiz'],['optimization']
Performance,"// Call over-loadable method Select, as to allow the user to; // interfere with the selection of functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:13,load,loadable,13,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['load'],['loadable']
Performance,"// Call site-related attributes are only useful in optimized programs, and; // when there's a possibility of debugging backtraces.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:51,optimiz,optimized,51,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['optimiz'],['optimized']
Performance,"// Call the Optimizer with the set of kernel parameters and ranges that are meant to be tuned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodSVM.cxx:12,Optimiz,Optimizer,12,tmva/tmva/src/MethodSVM.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodSVM.cxx,2,"['Optimiz', 'tune']","['Optimizer', 'tuned']"
Performance,// Call to perform layout on the MachO. Returns the total size of the; // resulting file.; // This method will automatically insert some load commands (e.g.; // LC_SYMTAB) and fill in load command fields.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOBuilder.h:11,perform,perform,11,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOBuilder.h,3,"['load', 'perform']","['load', 'perform']"
Performance,"// CallExpr store some data in trailing objects. However since CallExpr; // is used a base of other expression classes we cannot use; // llvm::TrailingObjects. Instead we manually perform the pointer arithmetic; // and casts.; //; // The trailing objects are in order:; //; // * A single ""Stmt *"" for the callee expression.; //; // * An array of getNumPreArgs() ""Stmt *"" for the pre-argument expressions.; //; // * An array of getNumArgs() ""Stmt *"" for the argument expressions.; //; // * An optional of type FPOptionsOverride.; //; // Note that we store the offset in bytes from the this pointer to the start; // of the trailing objects. It would be perfectly possible to compute it; // based on the dynamic kind of the CallExpr. However 1.) we have plenty of; // space in the bit-fields of Stmt. 2.) It was benchmarked to be faster to; // compute this once and then load the offset from the bit-fields of Stmt,; // instead of re-computing the offset each time the trailing objects are; // accessed.; /// Return a pointer to the start of the trailing array of ""Stmt *"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:180,perform,perform,180,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,2,"['load', 'perform']","['load', 'perform']"
Performance,"// CallShowMember will force a call to InheritsFrom, which indirectly; // calls TClass::GetClass. It forces the loading of new typedefs in; // case some of them were not yet loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:112,load,loading,112,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,2,['load'],"['loaded', 'loading']"
Performance,// Callback to repair a call site of the associated function. The elements; // of the privatizable type are loaded prior to the call and passed to the; // new function version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:108,load,loaded,108,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['load'],['loaded']
Performance,"// Called by the bottleneck analysis at the end of simulation to propagate; // costs through the edges of the graph, and compute a critical path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:17,bottleneck,bottleneck,17,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,1,['bottleneck'],['bottleneck']
Performance,// Called by type legalization to handle splat of i64 on RV32.; // FIXME: We can optimize this when the type has sign or zero bits in one; // of the halves.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:81,optimiz,optimize,81,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['optimiz'],['optimize']
Performance,"// Called when CPPScope acts as a metaclass; since type_new always resets; // tp_alloc, and since it does not call tp_init on types, the metaclass is; // being fixed up here, and the class is initialized here as well.; // fixup of metaclass (left permanent, and in principle only called once b/c; // cppyy caches python classes)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx:306,cache,caches,306,bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,1,['cache'],['caches']
Performance,"// Callee contains any byval parameter is not supported, too.; // Note: This is a quick work around, because in some cases, e.g.; // caller's stack size > callee's stack size, we are still able to apply; // sibling call optimization. For example, gcc is able to do SCO for caller1; // in the following example, but not for caller2.; // struct test {; // long int a;; // char ary[56];; // } gTest;; // __attribute__((noinline)) int callee(struct test v, struct test *b) {; // b->a = v.a;; // return 0;; // }; // void caller1(struct test a, struct test c, struct test *b) {; // callee(gTest, b); }; // void caller2(struct test *b) { callee(gTest, b); }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:220,optimiz,optimization,220,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['optimiz'],['optimization']
Performance,// Callee pop calling convention. Pop parameter/linkage area. Used for tail; // call optimization,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:85,optimiz,optimization,85,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['optimiz'],['optimization']
Performance,"// Caller (`X86InstrInfo::optimizeCompareInstr`) guarantees that; // `CmpValDefInstr` defines the value that's used by `CmpInstr`; in this case; // if `CmpValDefInstr` sets the EFLAGS, it is likely that `CmpInstr` is; // redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:26,optimiz,optimizeCompareInstr,26,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['optimiz'],['optimizeCompareInstr']
Performance,"// Calling a function pointer does not in itself cause the pointer to; // be captured. This is a subtle point considering that (for example); // the callee might return its own address. It is analogous to saying; // that loading a value from a pointer does not cause the pointer to be; // captured, even though the loaded value might be the pointer itself; // (think of self-referential objects).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:221,load,loading,221,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,2,['load'],"['loaded', 'loading']"
Performance,// Calls that have already been optimized. We may add a call to multiple; // VTableSlotInfos if vtable loads are coalesced and need to make sure not to; // optimize a call more than once.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:32,optimiz,optimized,32,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,3,"['load', 'optimiz']","['loads', 'optimize', 'optimized']"
Performance,// Calls that only access inaccessible memory do not block sinking the; // load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:75,load,load,75,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['load'],['load']
Performance,"// Can a (CMP op1, (sub 0, op2) be turned into a CMN instruction on; // the grounds that ""op1 - (-op2) == op1 + op2"" ? Not always, the C and V flags; // can be set differently by this operation. It comes down to whether; // ""SInt(~op2)+1 == SInt(~op2+1)"" (and the same for UInt). If they are then; // everything is fine. If not then the optimization is wrong. Thus general; // comparisons are only valid if op2 != 0.; //; // So, finally, the only LLVM-native comparisons that don't mention C and V; // are SETEQ and SETNE. They're the only ones we can safely use CMN for in; // the absence of information about op2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:337,optimiz,optimization,337,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['optimiz'],['optimization']
Performance,// Can load and store double precision even without FeatureFP64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:7,load,load,7,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,2,['load'],['load']
Performance,// Can never fold addr of global into load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:38,load,load,38,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['load'],['load']
Performance,"// Can not analyze scalable type, the number of elements is not a compile-time; // constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:19,scalab,scalable,19,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['scalab'],['scalable']
Performance,"// Can not handle scalable type, the number of elements is not a compile-time; // constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:18,scalab,scalable,18,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['scalab'],['scalable']
Performance,"// Can this instruction generate a non-zero result when given only zeroed; // operands? This allows us to know that, given operands with false bytes; // zeroed by masked loads, that the result will also contain zeros in those; // bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:170,load,loads,170,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,1,['load'],['loads']
Performance,"// Can we use this vector size, as per the remaining element count?; // Iff the vector is naturally aligned, we can do a wide load regardless.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:126,load,load,126,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,// Can't cluster load/store that have ordered or volatile memory reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:17,load,load,17,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['load'],['load']
Performance,// Can't do a scalar atomic load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:28,load,load,28,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['load'],['load']
Performance,// Can't do the optimization if it has non-C++ uses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:16,optimiz,optimization,16,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,1,['optimiz'],['optimization']
Performance,// Can't express arbitrary shufflevectors for scalable vectors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-stress/llvm-stress.cpp:46,scalab,scalable,46,interpreter/llvm-project/llvm/tools/llvm-stress/llvm-stress.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-stress/llvm-stress.cpp,1,['scalab'],['scalable']
Performance,// Can't fold load update node because the second; // output is used so that load update node can't be removed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:14,load,load,14,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,2,['load'],['load']
Performance,"// Can't handle this load, bail out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:21,load,load,21,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['load'],['load']
Performance,"// Can't handle unknown size alloca.; // (e.g. Variable Length Array, Scalable Vector)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:70,Scalab,Scalable,70,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['Scalab'],['Scalable']
Performance,// Can't if the load is volatile or atomic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:16,load,load,16,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['load']
Performance,"// Can't merge volatiles or load/stores that have a hint to avoid pair; // formation, for example.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:28,load,load,28,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['load'],['load']
Performance,// Can't optimize uncond branch,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:9,optimiz,optimize,9,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['optimiz'],['optimize']
Performance,// Can't pass scalable vectors on the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:14,scalab,scalable,14,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['scalab'],['scalable']
Performance,// Can't split volatile or atomic loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:34,load,loads,34,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['load'],['loads']
Performance,"// Can't use TII->loadRegFromStackSlot(), because we need the shape; // information for reload.; // tileloadd (%sp, %idx), %tmm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:18,load,loadRegFromStackSlot,18,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,1,['load'],['loadRegFromStackSlot']
Performance,// Cannot analyze scalable type. The number of vector elements is not a; // compile-time constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:18,scalab,scalable,18,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['scalab'],['scalable']
Performance,"// Cannot call cached p.d.f w.o nset; // if (!nset) return evaluate() ;; // Calculate current unnormalized value of object; // coverity[NULL_RETURNS]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx:15,cache,cached,15,roofit/roofitcore/src/RooAbsCachedReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx,1,['cache'],['cached']
Performance,// Cannot encode an offset register and an immediate offset in the same; // instruction. Fold the immediate offset into the load/store instruction and; // emit an additional add to take care of the offset register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:124,load,load,124,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,1,['load'],['load']
Performance,// Cannot handle opaque target constants and we must respect the user's; // request not to split indexes from loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:110,load,loads,110,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loads']
Performance,// Cannot handle reading from store of first-class aggregate or scalable type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:64,scalab,scalable,64,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,1,['scalab'],['scalable']
Performance,"// Cannot move control-flow-involving, volatile loads, vaarg, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:48,load,loads,48,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['load'],['loads']
Performance,// Cannot move the load or store to NewBB above its definition in DBB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:19,load,load,19,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['load'],['load']
Performance,// Cannot move the load or store to NewPt above its definition in D.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:19,load,load,19,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['load'],['load']
Performance,// Cannot optimize with MemProf profile during IR instrumentation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/PGOOptions.cpp:10,optimiz,optimize,10,interpreter/llvm-project/llvm/lib/Support/PGOOptions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/PGOOptions.cpp,1,['optimiz'],['optimize']
Performance,"// Cannot safely mirror live intervals with PHI nodes, so check for these; // before optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMaskingPreRA.cpp:85,optimiz,optimization,85,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMaskingPreRA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMaskingPreRA.cpp,1,['optimiz'],['optimization']
Performance,"// Canonicalise concat_vectors so that the right-hand vector has as few; // bit-casts as possible before its real operation. The primary matching; // destination for these operations will be the narrowing ""2"" instructions,; // which depend on the operation being performed on this right-hand vector.; // For example,; // (concat_vectors LHS, (v1i64 (bitconvert (v4i16 RHS)))); // becomes; // (bitconvert (concat_vectors (v4i16 (bitconvert LHS)), RHS))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:263,perform,performed,263,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['perform'],['performed']
Performance,"// Canonicalization: if only one input vector is constant, it shall be the; // second one. This transformation depends on the value of the mask which; // is not known at compile time for scalable vectors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:187,scalab,scalable,187,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['scalab'],['scalable']
Performance,// Canonicalize -fmodules-cache-path before storing it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:26,cache,cache-path,26,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['cache'],['cache-path']
Performance,"// Canonicalize SHUFFLE(UNARYOP(X)) -> UNARYOP(SHUFFLE(X)).; // Canonicalize SHUFFLE(BINOP(X,Y)) -> BINOP(SHUFFLE(X),SHUFFLE(Y)).; // Perform this after other shuffle combines to allow inner shuffles to be; // combined away first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:134,Perform,Perform,134,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Perform'],['Perform']
Performance,// Canonicalize binary shuffles of horizontal ops that use the; // same sources to an unary shuffle.; // TODO: Try to perform this fold even if the shuffle remains.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:118,perform,perform,118,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['perform']
Performance,// Canonicalize splat shuffle to use poison RHS. Handle this explicitly in; // order to support scalable vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:96,scalab,scalable,96,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['scalab'],['scalable']
Performance,// Canonicalize to use preferred load address as base address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp:33,load,load,33,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,2,['load'],['load']
Performance,"// Canonicalize toward having the constant on the RHS.; // TODO: Handle non-splat vector constants. All undef causes trouble.; // FIXME: We can't yet fold constant scalable vector splats, so avoid an; // infinite loop here when we encounter one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:164,scalab,scalable,164,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['scalab'],['scalable']
Performance,"// Cap the cost at a value linear to the number of elements in the vector.; // The default lowering is to use the stack. The vector store + scalar loads; // is linear in VL. However, at high lmuls vslide1down and vslidedown end up; // being (at least) linear in LMUL. As a result, using the vslidedown; // lowering for every element ends up being VL*LMUL..; // TODO: Should we be directly costing the stack alternative? Doing so might; // give us a more accurate upper bound.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:147,load,loads,147,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['load'],['loads']
Performance,"// CapturePred and others may have left the node in the pending queue, avoid; // adding it twice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:64,queue,queue,64,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['queue'],['queue']
Performance,"// Case 1: A full group. Can Skip the checks; For full groups, if the wide; // load would wrap around the address space we would do a memory access at; // nullptr even without the transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:79,load,load,79,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['load'],['load']
Performance,// Case 1: Ptrs are the arguments of loads that we are going to transform; // into masked gather load intrinsic.; // All the scalar GEPs will be removed as a result of vectorization.; // For any external uses of some lanes extract element instructions will; // be generated (which cost is estimated separately).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,load,loads,37,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['load'],"['load', 'loads']"
Performance,"// Case 2: If first and last members of the group don't wrap this implies; // that all the pointers in the group don't wrap.; // So we check only group member 0 (which is always guaranteed to exist),; // and the last group member. Case 3 (scalar epilog) is not relevant for; // stores with gaps, which are implemented with masked-store (rather than; // speculative access, as in loads).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:379,load,loads,379,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['load'],['loads']
Performance,// Case 2: estimate costs for pointer related costs when vectorizing to; // a wide load/store.; // Scalar cost is estimated as a set of pointers with known relationship; // between them.; // For vector code we will use BasePtr as argument for the wide load/store; // but we also need to account all the instructions which are going to; // stay in vectorized code due to uses outside of these scalar; // loads/stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:83,load,load,83,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,3,['load'],"['load', 'loads']"
Performance,"// Case 3: A non-reversed interleaved load group with gaps: We need; // to execute at least one scalar epilogue iteration. This will ensure; // we don't speculatively access memory out-of-bounds. We only need; // to look for a member at index factor - 1, since every group must have; // a member at index zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:38,load,load,38,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['load'],['load']
Performance,// Cast float to int to perform ANDs if necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:24,perform,perform,24,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['perform'],['perform']
Performance,// Cast pointer to the type we really want to load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:46,load,load,46,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['load'],['load']
Performance,// Cast ptr32 and ptr64 pointers to the default address space before a load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:71,load,load,71,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['load']
Performance,// Cast the adjusted this to a pointer to vtable pointer and load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:61,load,load,61,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['load'],['load']
Performance,// Cast to pointer if the load needs a pointer type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:26,load,load,26,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,1,['load'],['load']
Performance,"// Casts, loads and instructions outside of our range terminate a chain; // successfully.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:10,load,loads,10,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['load'],['loads']
Performance,// Catch weird sized loads that don't evenly divide into the access sizes; // TODO: May be able to widen depending on alignment etc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:21,load,loads,21,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['load'],['loads']
Performance,"// Caution: A load via the GOT can expand to a GPR32 operand, a load via; // spill and reload can expand as a GPR64 operand. Examine the; // operand in detail and default to ABI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:14,load,load,14,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,4,['load'],['load']
Performance,// Certain loads for GOT references can be relocated against the symbol; // directly if the symbol ends up in the same linkage unit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp:11,load,loads,11,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp,1,['load'],['loads']
Performance,"// Certain memory accesses are known to not alias any SU in Stores; // or Loads, and have therefore their own 'NonAlias'; // domain. E.g. spill / reload instructions never alias LLVM I/R; // Values. It would be nice to assume that this type of memory; // accesses always have a proper memory operand modelling, and are; // therefore never unanalyzable, but this is conservatively not; // done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:74,Load,Loads,74,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['Load'],['Loads']
Performance,// Chain for all loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:17,load,loads,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['load'],['loads']
Performance,// Chain for the series of load,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:27,load,load,27,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['load'],['load']
Performance,// Chain is the output chain of the last Load/Store or CopyToReg node.; // ByValChain is the output chain of the last Memcpy node created for copying; // byval arguments to the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:41,Load,Load,41,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['Load'],['Load']
Performance,"// Chain the prefetch in parallel with any pending loads, to stay out of; // the way of later optimizations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:51,load,loads,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,2,"['load', 'optimiz']","['loads', 'optimizations']"
Performance,"// Chain up all pending constrained intrinsics together with all; // pending loads, by simply appending them to PendingLoads and; // then calling getMemoryRoot().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:77,load,loads,77,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['load'],['loads']
Performance,"// Change (or (bool?A:B),(bool?C:D)) --> (bool?(or A,C):(or B,D)); // Since this OR statement hasn't been optimized further yet, we hope; // that this transformation will allow the new ORs to be optimized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:106,optimiz,optimized,106,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,2,['optimiz'],['optimized']
Performance,// Change TLS initial-exec (or TLS local-exec on AIX) D-form loads to; // X-form loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:61,load,loads,61,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,2,['load'],['loads']
Performance,"// Change a chain of {load; op; store} of the same value into a simple op; // through memory of that value, if the uses of the modified value and its; // address are suitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:22,load,load,22,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['load'],['load']
Performance,"// Change a chain of {load; op; store} of the same value into a simple op; // through memory of that value, if the uses of the modified value and its; // address are suitable.; //; // The tablegen pattern memory operand pattern is currently not able to match; // the case where the CC on the original operation are used.; //; // See the equivalent routine in X86ISelDAGToDAG for further comments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:22,load,load,22,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['load'],['load']
Performance,"// Change a chain of {load; op; store} of the same value into a simple op; // through memory of that value, if the uses of the modified value and its; // address are suitable.; //; // The tablegen pattern memory operand pattern is currently not able to match; // the case where the EFLAGS on the original operation are used.; //; // To move this to tablegen, we'll need to improve tablegen to allow flags to; // be transferred from a node in the pattern to the result node, probably with; // a new keyword. For example, we have this; // def DEC64m : RI<0xFF, MRM1m, (outs), (ins i64mem:$dst), ""dec{q}\t$dst"",; // [(store (add (loadi64 addr:$dst), -1), addr:$dst),; // (implicit EFLAGS)]>;; // but maybe need something like this; // def DEC64m : RI<0xFF, MRM1m, (outs), (ins i64mem:$dst), ""dec{q}\t$dst"",; // [(store (add (loadi64 addr:$dst), -1), addr:$dst),; // (transferrable EFLAGS)]>;; //; // Until then, we manually fold these and instruction select the operation; // here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:22,load,load,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['load'],['load']
Performance,"// Change select and PHI nodes to select values instead of addresses: this; // helps alias analysis out a lot, allows many others simplifications, and; // exposes redundancy in the code.; //; // Note that we cannot do the transformation unless we know that the; // introduced loads cannot trap! Something like this is valid as long as; // the condition is always false: load (select bool %C, int* null, int* %G),; // but it would not be valid if we transformed it to load from null; // unconditionally.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:276,load,loads,276,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,3,['load'],"['load', 'loads']"
Performance,// Change the floating point control register to use double extended; // precision when performing the addition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:88,perform,performing,88,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['performing']
Performance,// Change the load into a load of bool then a select.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:14,load,load,14,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,2,['load'],['load']
Performance,// Change the opcode to load address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:24,load,load,24,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,1,['load'],['load']
Performance,// Change the physical register to performe truncate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86InstructionSelector.cpp:35,perform,performe,35,interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86InstructionSelector.cpp,1,['perform'],['performe']
Performance,"// Changes background color according to the queue of pending events",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/src/TRecorder.cxx:45,queue,queue,45,gui/recorder/src/TRecorder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/src/TRecorder.cxx,1,['queue'],['queue']
Performance,// Check (a) if Load is a predecessor to Xn + Yn,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:16,Load,Load,16,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['Load'],['Load']
Performance,"// Check Load, Store, GEP, and BitCast Uses on alloca and make them; // use the converted generic address, in order to expose non-generic; // addrspacecast to NVPTXInferAddressSpaces. For other types; // of instructions this is unnecessary and may introduce redundant; // address cast.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp:9,Load,Load,9,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp,1,['Load'],['Load']
Performance,"// Check all machine operands that reference the antidependent register and must; // be replaced by NewReg. Return true if any of their parent instructions may; // clobber the new register.; //; // Note: AntiDepReg may be referenced by a two-address instruction such that; // it's use operand is tied to a def operand. We guard against the case in which; // the two-address instruction also defines NewReg, as may happen with; // pre/postincrement loads. In this case, both the use and def operands are in; // RegRefs because the def is inserted by PrescanInstruction and not erased; // during ScanInstruction. So checking for an instruction with definitions of; // both NewReg and AntiDepReg covers it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:448,load,loads,448,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,1,['load'],['loads']
Performance,// Check all the loads are the same distance apart,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,load,loads,17,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['load'],['loads']
Performance,"// Check all use of User node. If all of them are safe, optimize; // truncate to extract_subreg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:56,optimiz,optimize,56,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['optimiz'],['optimize']
Performance,"// Check all use of selections, bit operations, and copies. If all of them; // are safe, optimize truncate to extract_subreg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:89,optimiz,optimize,89,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['optimiz'],['optimize']
Performance,"// Check all uses after FirstMI of the given register, keeping a vector of; // instructions that would be compressible if the given register (and offset if; // applicable) were compressible.; //; // If there are enough uses for this optimization to improve code size and a; // compressed register is available, return that compressed register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:233,optimiz,optimization,233,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,1,['optimiz'],['optimization']
Performance,"// Check all uses for MemoryDefs, except for defs completely overwriting; // the original location. Otherwise we have to check uses of *all*; // MemoryDefs we discover, including non-aliasing ones. Otherwise we might; // miss cases like the following; // 1 = Def(LoE) ; <----- DeadDef stores [0,1]; // 2 = Def(1) ; (2, 1) = NoAlias, stores [2,3]; // Use(2) ; MayAlias 2 *and* 1, loads [0, 3].; // (The Use points to the *first* Def it may alias); // 3 = Def(1) ; <---- Current (3, 2) = NoAlias, (3,1) = MayAlias,; // stores [0,1]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:379,load,loads,379,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['load'],['loads']
Performance,"// Check and make sure ""cache"" directory exists",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:24,cache,cache,24,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['cache'],['cache']
Performance,// Check cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:9,cache,cache,9,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,1,['cache'],['cache']
Performance,// Check collection; perform on-demand update if stale.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Debuginfod/Debuginfod.cpp:21,perform,perform,21,interpreter/llvm-project/llvm/lib/Debuginfod/Debuginfod.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Debuginfod/Debuginfod.cpp,2,['perform'],['perform']
Performance,// Check each definition in NewRoot and compute the latency,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:52,latency,latency,52,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,1,['latency'],['latency']
Performance,// Check first terminator for branches to optimize,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPreEmitPeephole.cpp:42,optimiz,optimize,42,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPreEmitPeephole.cpp,1,['optimiz'],['optimize']
Performance,"// Check for SSSE3 which lets us lower all v16i8 shuffles much more directly; // with PSHUFB. It is important to do this before we attempt to generate any; // blends but after all of the single-input lowerings. If the single input; // lowerings can find an instruction sequence that is faster than a PSHUFB, we; // want to preserve that and we can DAG combine any longer sequences into; // a PSHUFB in the end. But once we start blending from multiple inputs,; // the complexity of DAG combining bad patterns back into PSHUFB is too high,; // and there are *very* few patterns that would actually be faster than the; // PSHUFB approach because of its ability to zero lanes.; //; // If the mask is a binary compaction, we can more efficiently perform this; // as a PACKUS(AND(),AND()) - which is quicker than UNPACK(PSHUFB(),PSHUFB()).; //; // FIXME: The only exceptions to the above are blends which are exact; // interleavings with direct instructions supporting them. We currently don't; // handle those well here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:742,perform,perform,742,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['perform']
Performance,// Check for _L to _LZ optimization,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:23,optimiz,optimization,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['optimiz'],['optimization']
Performance,// Check for a cached result,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:15,cache,cached,15,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['cache'],['cached']
Performance,// Check for a likely high-latency flag def.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:27,latency,latency,27,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,1,['latency'],['latency']
Performance,"// Check for an existing cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:25,cache,cache,25,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,2,['cache'],['cache']
Performance,"// Check for an indirect call or branch that may need its input hardened; // even if we couldn't find the specific load used, or were able to; // avoid hardening it for some reason. Note that here we cannot break; // out afterward as we may still need to handle any call aspect of this; // instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:115,load,load,115,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['load'],['load']
Performance,"// Check for broadcast loads, which are supported by the LD1R instruction.; // In terms of code-size, the shuffle vector is free when a load + dup get; // folded into a LD1R. That's what we check and return here. For performance; // and reciprocal throughput, a LD1R is not completely free. In this case, we; // return the cost for the broadcast below (i.e. 1 for most/all types), so; // that we model the load + dup sequence slightly higher because LD1R is a; // high latency instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:23,load,loads,23,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,6,"['latency', 'load', 'perform', 'throughput']","['latency', 'load', 'loads', 'performance', 'throughput']"
Performance,"// Check for cached parameter set",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:13,cache,cached,13,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['cache'],['cached']
Performance,// Check for compatible operands. If the corresponding operands are not; // compatible - need to perform alternate vectorization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:97,perform,perform,97,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['perform'],['perform']
Performance,// Check for either a dependence (latency) or resource (hazard) stall.; //; // Note: The ScheduleHazardRecognizer interface requires a non-const SU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:34,latency,latency,34,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['latency'],['latency']
Performance,// Check for existing uses of a vector register within the packet which; // would be affected by converting a vector load into .cur formt.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:117,load,load,117,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['load'],['load']
Performance,// Check for indexed addressing modes w/ the base register being the; // same as a destination/source register or pair load where; // the Rt == Rt2. All of those are undefined behaviour.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:119,load,load,119,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['load'],['load']
Performance,"// Check for loads from a code text region. For such loads, just give up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:13,load,loads,13,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,2,['load'],['loads']
Performance,// Check for loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:13,load,loads,13,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,1,['load'],['loads']
Performance,"// Check for optimized basis functions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx:13,optimiz,optimized,13,roofit/roofitcore/src/RooTruthModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx,1,['optimiz'],['optimized']
Performance,"// Check for register classes of the register used as the source for; // the store, and the register used as the destination for the load.; // Also, only accept base+imm_offset addressing modes. Other addressing; // modes can have side-effects (post-increments, etc.). For stack; // slots they are very unlikely, so there is not much loss due to; // this restriction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:133,load,load,133,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,1,['load'],['load']
Performance,"// Check for some cases that are worth simplifying. Right now we want to look; // for loads that are used by a switch or by the condition for the branch. If; // we see one, check to see if it's partially redundant. If so, insert a PHI; // which can then be used to thread the values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:86,load,loads,86,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['load'],['loads']
Performance,"// Check for source drift. If the source has changed since the profiles; // were obtained, optimizing basic blocks might be sub-optimal.; // This only applies to BasicBlockSection::List as it creates; // clusters of basic blocks using basic block ids. Source drift can; // invalidate these groupings leading to sub-optimal code generation with; // regards to performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:91,optimiz,optimizing,91,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,2,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,// Check for the OptimizeNone attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:17,Optimiz,OptimizeNone,17,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,1,['Optimiz'],['OptimizeNone']
Performance,"// Check for the case where we're going to rewrite to a new alloca of the; // exact same type as the original, and with the same access offsets. In that; // case, re-use the existing alloca, but still run through the rewriter to; // perform phi and select speculation.; // P.beginOffset() can be non-zero even with the same type in a case with; // out-of-bounds access (e.g. @PR35657 function in SROA/basictest.ll).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:233,perform,perform,233,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['perform'],['perform']
Performance,"// Check for the fully redundant, dominating load case. In this case, we can; // just use the dominating value directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:45,load,load,45,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['load'],['load']
Performance,// Check for the magic bytes. This file format is designed to be mmap'ed; // into a process and accessed as read only. This is done for performance; // and efficiency for symbolicating and parsing GSYM data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp:136,perform,performance,136,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp,1,['perform'],['performance']
Performance,"// Check for the offset in the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx:31,cache,cache,31,core/metacling/src/TClingClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx,1,['cache'],['cache']
Performance,// Check for the post-increment load/store instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:32,load,load,32,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['load'],['load']
Performance,// Check for trivially easy constant prop into one of the operands; // If this is the case then perform the operation now to resolve SGPR; // issue. If we don't do that here we will always insert a mov to m0; // that can't be resolved in later operand folding pass,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFixSGPRCopies.cpp:96,perform,perform,96,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFixSGPRCopies.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFixSGPRCopies.cpp,1,['perform'],['perform']
Performance,// Check for whether we can use INSERTPS to perform the shuffle. We only use; // INSERTPS when the V1 elements are already in the correct locations; // because otherwise we can just always use two SHUFPS instructions which; // are much smaller to encode than a SHUFPS and an INSERTPS. We can also; // perform INSERTPS if a single V1 element is out of place and all V2; // elements are zeroable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:44,perform,perform,44,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['perform'],['perform']
Performance,// Check for zero extended loads. Treat any-extend loads as zero extended; // loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:27,load,loads,27,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,3,['load'],['loads']
Performance,// Check if Load is reachable from any of the nodes in the worklist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:12,Load,Load,12,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['Load'],['Load']
Performance,// Check if Loads come from same BB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:12,Load,Loads,12,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['Load'],['Loads']
Performance,// Check if ObjC container adds ivars after variable sized ivar in superclass.; // Perform the check only if OCD is the first container to declare ivars to; // avoid multiple warnings for the same ivar.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:83,Perform,Perform,83,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['Perform'],['Perform']
Performance,// Check if S has already been translated and cached.; // This handles the lookup of SSA names for DeclRefExprs here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:46,cache,cached,46,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,1,['cache'],['cached']
Performance,// Check if SI that may alias with MemLoc can be safely skipped. This is; // possible in case if SI can only must alias or no alias with MemLoc (no; // partial overlapping possible) and it writes the same value that MemLoc; // contains now (it was loaded before this store and was not modified in; // between).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:248,load,loaded,248,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['load'],['loaded']
Performance,"// Check if a given register has bits that are references to any other; // registers. This is to detect situations where the instruction that; // defines register R takes register Q as an operand, but R itself does; // not contain any bits from Q. Loads are examples of how this could; // happen:; // R = load Q; // In this case (assuming we do not have any knowledge about the loaded; // value), we must not treat R as a ""conveyance"" of the bits from Q.; // (The information in BT about R's bits would have them as constants,; // in case of zero-extending loads, or refs to R.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:248,Load,Loads,248,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,4,"['Load', 'load']","['Loads', 'load', 'loaded', 'loads']"
Performance,// Check if a load may be folded as a memory operand in its user.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:14,load,load,14,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,1,['load'],['load']
Performance,// Check if a load/store has DQ form.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:14,load,load,14,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['load'],['load']
Performance,// Check if a load/store has DS form.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:14,load,load,14,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['load'],['load']
Performance,// Check if a load/store has update form. This lambda is used by function; // collectCandidates which can collect candidates for types defined by lambda.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:14,load,load,14,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['load'],['load']
Performance,"// Check if a load/store is candidate for chain commoning.; // If the SCEV is only with one ptr operand in its start, we can use that; // start as a chain separator. Mark this load/store as a candidate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:14,load,load,14,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,2,['load'],['load']
Performance,// Check if a post-indexed load/store can be used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:27,load,load,27,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['load'],['load']
Performance,"// Check if addasl instruction can be removed. This is possible only; // if it's feeding to only load/store instructions with base + register; // offset as these instruction can be tranformed to use 'absolute plus; // shifted register offset'.; // ex:; // Rs = ##foo; // Rx = addasl(Rs, Rt, #2); // Rd = memw(Rx + #28); // Above three instructions can be replaced with Rd = memw(Rt<<#2 + ##foo+28)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:97,load,load,97,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,1,['load'],['load']
Performance,"// Check if all the basket in the cache have already be used and; // thus we can reuse the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:34,cache,cache,34,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],['cache']
Performance,// Check if all the bytes of the OR we are looking at are loaded from the same; // base address. Collect bytes offsets from Base address in ByteOffsets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,load,loaded,58,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loaded']
Performance,// Check if all users of the load are extracts with no memory modifications; // between the load and the extract. Compute the cost of both the original; // code and the scalarized version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:29,load,load,29,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,2,['load'],['load']
Performance,"// Check if all users of this load are shufflevectors. If we encounter any; // users that are extractelement instructions or binary operators, we save; // them to later check if they can be modified to extract from one of the; // shufflevectors instead of the load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:30,load,load,30,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,2,['load'],['load']
Performance,// Check if any instruction between the load and the extract may modify; // memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:40,load,load,40,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['load'],['load']
Performance,// Check if any of the loaded plugins replaces the main AST action,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:23,load,loaded,23,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['load'],['loaded']
Performance,// Check if better to perform a shuffle of 2 vectors or just of a single; // vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:22,perform,perform,22,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['perform'],['perform']
Performance,"// Check if cache already exists",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx:12,cache,cache,12,roofit/roofitcore/src/RooAddModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx,2,['cache'],['cache']
Performance,"// Check if cache entry was previously created",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx:12,cache,cache,12,roofit/roofitcore/src/RooMultiVarGaussian.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx,1,['cache'],['cache']
Performance,"// Check if each register feeding into each OR is a load from the same; // base pointer + some arithmetic.; //; // e.g. a[0], a[1] << 8, a[2] << 16, etc.; //; // Also verify that each of these ends up putting a[i] into the same memory; // offset as a load into a wide type would.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:52,load,load,52,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,2,['load'],['load']
Performance,"// Check if histogram is from ntupla/tree or not.; // If it is a standard histogram or a ntupla based histogram; // show a different frame in case of rebinning (fBinCont) with sliders and bin number entries; // connected to different methods.; // For example the entry field fBinNumberEntry is connected to; // the method DoBinLabel in case of non-ntupla histograms which just call Th1::Rebin; // In csae of a tree based histogram the entry field fBinNumberEntry1 is used which is connected to; // TH1Editor::DoBinLabel1 which is re-filling the histograms with the cached values from the TTreePlayer.; // Since the actual number of histogram entry can be larger than the cache size of the TTreePlayer; // (see JIRA ROOT-5900 or http://root.cern.ch/phpBB3/viewtopic.php?f=3&t=17107 ); // the GUI frame based on a non-tupla histogram is used when the number of entries of the histogram is; // not the same as the number of filled entries in the TTreePlayer object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TH1Editor.cxx:565,cache,cached,565,gui/ged/src/TH1Editor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TH1Editor.cxx,2,['cache'],"['cache', 'cached']"
Performance,"// Check if histogram is from ntupla/tree or not.; // If it is a standard histogram or a ntupla based histogram; // show a different frame in case of rebinning (fBinCont) with sliders and bin number entries; // connected to different methods.; // For example the entry field fBinXNumberEntry is connected to; // the method DoBinLabel in case of non-ntupla histograms which just call Th1::Rebin; // In csae of a tree based histogram the entry field fBinNumberEntry1 is used which is connected to; // TH1Editor::DoBinLabel1 which is re-filling the histograms with the cached values from the TTreePlayer.; // Since the actual number of histogram entry can be larger than the cache size of the TTreePlayer; // (see JIRA ROOT-5900 or http://root.cern.ch/phpBB3/viewtopic.php?f=3&t=17107 ); // the GUI frame based on a non-tupla histogram is used when the number of entries of the histogram is; // not the same as the number of filled entries in the TTreePlayer object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TH2Editor.cxx:566,cache,cached,566,gui/ged/src/TH2Editor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TH2Editor.cxx,2,['cache'],"['cache', 'cached']"
Performance,"// Check if info already loaded (not first call ...)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:25,load,loaded,25,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['load'],['loaded']
Performance,// Check if it is a P9 vector load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:30,load,load,30,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['load'],['load']
Performance,// Check if it is safe to move LoadI next to the SI.; // Conservatively assume it is safe only if there is no instruction; // modifying memory in-between the load and the select instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:31,Load,LoadI,31,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,2,"['Load', 'load']","['LoadI', 'load']"
Performance,// Check if it will be merged with the load.; // 1. Check the alignment / fast memory access constraint.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,load,load,39,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,// Check if it's profitable to perform this CSE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:31,perform,perform,31,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['perform'],['perform']
Performance,"// Check if it's safe to fold the load. If the size of the object is; // narrower than the load width, then it's not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:34,load,load,34,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,2,['load'],['load']
Performance,"// Check if it's safe to fold the load. If the size of the object is; // narrower than the load width, then it's not.; // FIXME: Allow scalar intrinsic instructions like ADDSSrm_Int.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:34,load,load,34,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,2,['load'],['load']
Performance,// Check if it's safe to move the load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:34,load,load,34,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['load'],['load']
Performance,// Check if load can be rewritten as load of vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:12,load,load,12,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['load'],['load']
Performance,// Check if load with Addr dependent from select can be converted to select; // between load values. There must be no instructions between the found; // loads and DepInst that may clobber the loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:12,load,load,12,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,4,['load'],"['load', 'loads']"
Performance,// Check if loads are consecutive and same size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:12,load,loads,12,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['load'],['loads']
Performance,"// Check if loads are same, atomic, volatile and having same address space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:12,load,loads,12,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['load'],['loads']
Performance,"// Check if masking is required.; // A Group may need masking for one of two reasons: it resides in a block that; // needs predication, or it was decided to use masking to deal with gaps; // (either a gap at the end of a load-access that may result in a speculative; // load, or any gaps in a store-access).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:221,load,load-access,221,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['load'],"['load', 'load-access']"
Performance,"// Check if one of the inputs to U is a load instruction and the output; // is used by a store instruction. If so and they also have the same; // base pointer, then don't preoprocess this node sequence as it; // can be matched to a memop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:40,load,load,40,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,1,['load'],['load']
Performance,"// Check if owner has a TEventList set. If yes we optimize for this; // Special case reading only the baskets containing entries in the; // list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:50,optimiz,optimize,50,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['optimiz'],['optimize']
Performance,// Check if pre-AVX condcode can be performed by a single FCMP op.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,perform,performed,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['performed']
Performance,// Check if previous best source instruction has a new zero latency; // dependence opportunity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:60,latency,latency,60,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['latency'],['latency']
Performance,// Check if range spans loaded entities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp:24,load,loaded,24,interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp,1,['load'],['loaded']
Performance,"// Check if replacement decision is already available in the cached table.; // if so, return it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:61,cache,cached,61,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,1,['cache'],['cached']
Performance,"// Check if result was cached",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:23,cache,cached,23,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['cache'],['cached']
Performance,// Check if that load feeds fp instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp:17,load,load,17,interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/GISel/PPCRegisterBankInfo.cpp,1,['load'],['load']
Performance,"// Check if that load feeds fp instructions.; // In that case, we want the default mapping to be on FPR; // instead of blind map every scalar to GPR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp:17,load,load,17,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp,2,['load'],['load']
Performance,// Check if the Offset is a valid auto-inc imm by Load/Store Type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:50,Load,Load,50,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,1,['Load'],['Load']
Performance,// Check if the assumption and the load are executed together without; // memory modification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:35,load,load,35,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['load'],['load']
Performance,// Check if the base load is entirely dereferenceable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:21,load,load,21,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['load']
Performance,// Check if the bytes of the OR we are looking at match with either big or; // little endian value load,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:99,load,load,99,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,"// Check if the bytes offsets we are looking at match with either big or; // little endian value loaded. Return true for big endian, false for little; // endian, and std::nullopt if match failed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:97,load,loaded,97,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loaded']
Performance,"// Check if the cache pointer actually points to a data member of the pdf.; // We can't get the actual address of the private _normMgr member, but we; // can still check if the cache points to a member by checking the range; // of the address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooCacheManager.cxx:16,cache,cache,16,roofit/roofitcore/test/testRooCacheManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooCacheManager.cxx,2,['cache'],['cache']
Performance,// Check if the cached information is valid.; // The same BitVector can be reused for all PhysRegs.; // We could cache multiple VirtRegs if it becomes necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:16,cache,cached,16,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,2,['cache'],"['cache', 'cached']"
Performance,// Check if the call may read from the memory location written; // to by SI. Check CI's attributes and arguments; the number of; // such checks performed is limited above by NoOfMemAccTooLarge.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:144,perform,performed,144,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['perform'],['performed']
Performance,// Check if the chain is produced by the load or is a TokenFactor with; // the load output chain as an operand. Return InputChain by reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:41,load,load,41,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,2,['load'],['load']
Performance,"// Check if the correct load instruction has been emitted - SelectionDAG might; // have emitted a zero-extending load, but we need a sign-extending load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:24,load,load,24,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,3,['load'],['load']
Performance,"// Check if the declaration is template instantiation, which is not in; // any DeclContext yet, because it came from; // Sema::PerformPendingInstantiations; // if (isa<FunctionDecl>(D) &&; // cast<FunctionDecl>(D)->getTemplateInstantiationPattern()); // return false;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/AST.cpp:127,Perform,PerformPendingInstantiations,127,interpreter/cling/lib/Utils/AST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/AST.cpp,1,['Perform'],['PerformPendingInstantiations']
Performance,// Check if the defining load is simple.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:25,load,load,25,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['load'],['load']
Performance,"// Check if the file is already in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:39,cache,cache,39,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,1,['cache'],['cache']
Performance,// Check if the first operand of the sign extension is a subword buffer load; // instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPostLegalizerCombiner.cpp:72,load,load,72,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPostLegalizerCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPostLegalizerCombiner.cpp,1,['load'],['load']
Performance,// Check if the input is an extended load of the required or/shift expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,load,load,37,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['load']
Performance,// Check if the instruction Inst is part of a pair of instructions that make up; // a link time GOT PC Rel optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h:107,optimiz,optimization,107,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCELFStreamer.h,1,['optimiz'],['optimization']
Performance,// Check if the last operand is an expression with the variant kind; // VK_PPC_PCREL_OPT. If this is the case then this is a linker optimization; // relocation and the .reloc directive needs to be added.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:132,optimiz,optimization,132,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,1,['optimiz'],['optimization']
Performance,// Check if the latency is greater than one between this instruction and any; // instruction in the previous packet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:16,latency,latency,16,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['latency'],['latency']
Performance,"// Check if the load and the store have the same base, constant offsets and; // non-overlapping access ranges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:16,load,load,16,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,1,['load'],['load']
Performance,// Check if the load can safely be moved to all the unavailable predecessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:16,load,load,16,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['load'],['load']
Performance,// Check if the load instruction has already been selected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:16,load,load,16,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,1,['load'],['load']
Performance,// Check if the load is the offending instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:16,load,load,16,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,1,['load'],['load']
Performance,// Check if the load stride matches the store stride.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:16,load,load,16,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['load'],['load']
Performance,// Check if the load/store are clusterable according to the PowerPC; // specification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:16,load,load,16,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['load'],['load']
Performance,"// Check if the loaded memory location begins before the end of the store; // location. If the condition holds, they might overlap, otherwise they are; // guaranteed to not overlap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:16,load,loaded,16,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['load'],['loaded']
Performance,"// Check if the loaded module covers all headers that were specified; // by the user on the command line. This is an integrity check to; // ensure that our used module map is not containing extraneous headers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:16,load,loaded,16,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['load'],['loaded']
Performance,// Check if the loaded value is used only in a store operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,load,loaded,16,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loaded']
Performance,"// Check if the loaded value, e.g. a constantpool of a global address, are; // the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:16,load,loaded,16,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['load'],['loaded']
Performance,// Check if the loads are close enough.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:16,load,loads,16,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['load'],['loads']
Performance,"// Check if the machine opcodes are different. If they are different; // then we consider them to not be of the same base address,; // EXCEPT in the case of Thumb2 byte loads where one is LDRBi8 and the other LDRBi12.; // In this case, they are considered to be the same because they are different; // encoding forms of the same basic instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:169,load,loads,169,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['load'],['loads']
Performance,"// Check if the memory, where FP state is written to, is used only in a single; // load operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:83,load,load,83,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,"// Check if the new combined immediate forms an illegal addressing mode.; // Do not combine if it was legal before but would get illegal.; // To do so, we need to find a load/store user of the pointer to get; // the access type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:170,load,load,170,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['load'],['load']
Performance,// Check if the new load that we are going to create is legal; // if we are in the post-legalization phase.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:20,load,load,20,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['load'],['load']
Performance,// Check if the opcode can be converted into an indexed load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:56,load,load,56,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,2,['load'],['load']
Performance,"// Check if the operands of an and/or operation are comparisons and if they; // compare against the same value. Replace the and/or-cmp-cmp sequence with; // min/max cmp sequence. If LHS1 is equal to RHS1, then the or-cmp-cmp; // sequence will be replaced with min-cmp sequence:; // (LHS0 < LHS1) | (RHS0 < RHS1) -> min(LHS0, RHS0) < LHS1; // and and-cmp-cmp will be replaced with max-cmp sequence:; // (LHS0 < LHS1) & (RHS0 < RHS1) -> max(LHS0, RHS0) < LHS1; // The optimization does not work for `==` or `!=` .; // The two comparisons should have either the same predicate or the; // predicate of one of the comparisons is the opposite of the other one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:466,optimiz,optimization,466,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['optimiz'],['optimization']
Performance,// Check if the pattern has loads,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:28,load,loads,28,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['load'],['loads']
Performance,// Check if the previous best destination instruction has a new zero; // latency dependence opportunity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:73,latency,latency,73,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['latency'],['latency']
Performance,"// Check if the result of the node is only used as a return value, as; // otherwise we can't perform a tail-call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:93,perform,perform,93,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['perform'],['perform']
Performance,"// Check if the return value is used as only a return value, as otherwise; // we can't perform a tail-call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:87,perform,perform,87,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['perform'],['perform']
Performance,"// Check if the return value is used as only a return value, as otherwise; // we can't perform a tail-call. In particular, we need to check for; // target ISD nodes that are returns and any other ""odd"" constructs; // that the generic analysis code won't necessarily catch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:87,perform,perform,87,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['perform'],['perform']
Performance,"// Check if the scalar load can be widened into a vector load. And if; // the address is ""base + cst"" see if the cst can be ""absorbed"" into; // the shuffle mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,load,load,23,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['load'],['load']
Performance,// Check if the scheduler should penalize instructions that are available to; // early due to a zero-latency dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:101,latency,latency,101,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['latency'],['latency']
Performance,"// Check if the store begins before the end of the load location. If the; // condition holds, they alias, otherwise they are guaranteed to not; // overlap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:51,load,load,51,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['load'],['load']
Performance,// Check if the stored value is loaded from some location and the loaded; // value is used only in the store operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,load,loaded,32,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['load'],['loaded']
Performance,// Check if the symbol is already cached.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/SymbolCache.cpp:34,cache,cached,34,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/SymbolCache.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/SymbolCache.cpp,2,['cache'],['cached']
Performance,"// Check if the symbol is available without loading the library.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:44,load,loading,44,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['load'],['loading']
Performance,// Check if the target supplies paired loads for this type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,load,loads,39,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loads']
Performance,"// Check if the tree is already loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx:32,load,loaded,32,proof/proofplayer/src/TEventIter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx,1,['load'],['loaded']
Performance,"// Check if there are any side-effecting instructions (e.g. stores, calls,; // volatile loads) in the part of the loop that the code *would* execute; // without unswitching.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:88,load,loads,88,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['load'],['loads']
Performance,"// Check if there are any stores, calls, etc. between any of the loads. If; // there are, then we can't safely perform the combine.; //; // MaxIter is chosen based off the (worst case) number of iterations it; // typically takes to succeed in the LLVM test suite plus some padding.; //; // FIXME: Is there a better way to check for load fold barriers?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:65,load,loads,65,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,3,"['load', 'perform']","['load', 'loads', 'perform']"
Performance,"// Check if there are other uses. If so, do not combine as it will introduce; // an extra load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:90,load,load,90,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['load'],['load']
Performance,"// Check if there is a global cache-packet sync setting",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx:30,cache,cache-packet,30,proof/proofplayer/src/TPacketizerAdaptive.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx,1,['cache'],['cache-packet']
Performance,// Check if there is a load that defines the vector being extracted from.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:23,load,load,23,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['load'],['load']
Performance,// Check if there is cached Def with invariant.group.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:21,cache,cached,21,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['cache'],['cached']
Performance,// Check if this argument may be loaded into the same register as the; // previous argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp:33,load,loaded,33,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp,1,['load'],['loaded']
Performance,"// Check if this could be a perfect shuffle, or a combination of perfect; // shuffles.; //; // Consider this permutation (using hex digits to make the ASCII diagrams; // easier to read):; // { 0, 8, 1, 9, 2, A, 3, B, 4, C, 5, D, 6, E, 7, F }.; // This is a ""deal"" operation: divide the input into two halves, and; // create the output by picking elements by alternating between these two; // halves:; // 0 1 2 3 4 5 6 7 --> 0 8 1 9 2 A 3 B 4 C 5 D 6 E 7 F [*]; // 8 9 A B C D E F; //; // Aside from a few special explicit cases (V6_vdealb, etc.), HVX provides; // a somwehat different mechanism that could be used to perform shuffle/; // deal operations: a 2x2 transpose.; // Consider the halves of inputs again, they can be interpreted as a 2x8; // matrix. A 2x8 matrix can be looked at four 2x2 matrices concatenated; // together. Now, when considering 2 elements at a time, it will be a 2x4; // matrix (with elements 01, 23, 45, etc.), or two 2x2 matrices:; // 01 23 45 67; // 89 AB CD EF; // With groups of 4, this will become a single 2x2 matrix, and so on.; //; // The 2x2 transpose instruction works by transposing each of the 2x2; // matrices (or ""sub-matrices""), given a specific group size. For example,; // if the group size is 1 (i.e. each element is its own group), there; // will be four transposes of the four 2x2 matrices that form the 2x8.; // For example, with the inputs as above, the result will be:; // 0 8 2 A 4 C 6 E; // 1 9 3 B 5 D 7 F; // Now, this result can be tranposed again, but with the group size of 2:; // 08 19 4C 5D; // 2A 3B 6E 7F; // If we then transpose that result, but with the group size of 4, we get:; // 0819 2A3B; // 4C5D 6E7F; // If we concatenate these two rows, it will be; // 0 8 1 9 2 A 3 B 4 C 5 D 6 E 7 F; // which is the same as the ""deal"" [*] above.; //; // In general, a ""deal"" of individual elements is a series of 2x2 transposes,; // with changing group size. HVX has two instructions:; // Vdd = V6_vdealvdd Vu, Vv, Rt; // Vdd = V6_shufvdd Vu, V",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:617,perform,perform,617,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['perform'],['perform']
Performance,"// Check if this decl was interesting to the consumer. If we just loaded; // the declaration, then we know it was interesting and we skip the call; // to isConsumerInterestedIn because it is unsafe to call in the; // current ASTReader state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:66,load,loaded,66,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['load'],['loaded']
Performance,"// Check if this is a broadcast of a scalar. We special case lowering; // for scalars so that we can more effectively fold with loads.; // If the original value has a larger element type than the shuffle, the; // broadcast element is in essence truncated. Make that explicit to ease; // folding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:128,load,loads,128,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['loads']
Performance,// Check if this is a call to the implicitarg_ptr builtin and it; // is used to retrieve the hostcall pointer. The implicit arg for; // hostcall is not used only if every use of the implicitarg_ptr; // is a load that clearly does not retrieve any byte of the; // hostcall pointer. We check this by tracing all the uses of the; // initial call to the implicitarg_ptr intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp:207,load,load,207,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp,1,['load'],['load']
Performance,// Check if this is a load from a fixed stack object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:22,load,load,22,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['load'],['load']
Performance,// Check if this is a load whose address needs to be hardened.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:22,load,load,22,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['load'],['load']
Performance,// Check if this is a performSelector method that uses a selector that returns; // a record or a vector type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:22,perform,performSelector,22,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['perform'],['performSelector']
Performance,// Check if this is a supported operation and select a function to perform; // it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:67,perform,perform,67,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['perform'],['perform']
Performance,// Check if this is an optimizable reg-reg move or an XCHG-like instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/DispatchStage.cpp:23,optimiz,optimizable,23,interpreter/llvm-project/llvm/lib/MCA/Stages/DispatchStage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/DispatchStage.cpp,1,['optimiz'],['optimizable']
Performance,// Check if this is one of multiple writes performed by this; // instruction to register RegID.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp:43,perform,performed,43,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,1,['perform'],['performed']
Performance,"// Check if this load is used as several smaller chunks of bits.; // Basically, look for uses in trunc or trunc(lshr) and record a new chain; // of computation for each trunc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,load,load,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,// Check if this load/store has a hint to avoid pair formation.; // MachineMemOperands hints are set by the AArch64StorePairSuppress pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:17,load,load,17,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['load'],['load']
Performance,"// Check if this store is using a load result that appears after the; // last store. If so, bail out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp:34,load,load,34,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp,1,['load'],['load']
Performance,"// Check if two reductions are known to load data where one is before/after; // another. Return negative if N0 loads data before N1, positive if N1 is; // before N0 and 0 otherwise if nothing is known.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:40,load,load,40,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['load'],"['load', 'loads']"
Performance,"// Check if type is already in sub-class cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TIsAProxy.cxx:41,cache,cache,41,core/meta/src/TIsAProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TIsAProxy.cxx,1,['cache'],['cache']
Performance,"// Check if we a have a const declaration with an initializer, we may be; // able to emit it as available_externally to expose it's value to the; // optimizer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:149,optimiz,optimizer,149,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['optimiz'],['optimizer']
Performance,// Check if we already have a cache entry for this value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp:30,cache,cache,30,interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp,1,['cache'],['cache']
Performance,// Check if we are performing code completion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:19,perform,performing,19,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['perform'],['performing']
Performance,// Check if we are performing the same sort of operation on the same types; // but not on the same values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:19,perform,performing,19,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,1,['perform'],['performing']
Performance,// Check if we can find an unused register which we can use to rename; // the register used by the first load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:105,load,load,105,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,1,['load'],['load']
Performance,// Check if we can load the element with one instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:19,load,load,19,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['load'],['load']
Performance,// Check if we can move the stack update instruction up the epilogue; // past the callee saves. This will allow the move to LR instruction; // to be executed before the restores of the callee saves which means; // that the callee saves can hide the latency from the MTLR instrcution.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:249,latency,latency,249,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['latency'],['latency']
Performance,"// Check if we can potentially perform a tail call. More detailed checking; // is be done within LowerCallTo, after more information about the call is; // known.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:31,perform,perform,31,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['perform'],['perform']
Performance,// Check if we can use the condition value to increment/decrement a single; // constant value. This simplifies a select to an add and removes a constant; // load/materialization from the general case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:157,load,load,157,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,// Check if we found an assumption associated with this load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:56,load,load,56,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['load'],['load']
Performance,// Check if we have SSE3 which will let us use MOVDDUP etc. The; // instructions are no slower than UNPCKLPD but has the option to; // fold the input operand into even an unaligned memory load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:188,load,load,188,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['load']
Performance,"// Check if we have a cache histogram in the global expensive object cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:22,cache,cache,22,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,2,['cache'],['cache']
Performance,"// Check if we have a cached safety value from parallel world, and if this can still be used.; // Return negative value if no cache available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h:22,cache,cached,22,geom/geom/inc/TGeoNavigator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h,2,['cache'],"['cache', 'cached']"
Performance,// Check if we have already symbolized and cached the result or if we; // don't want to attempt symbolization since we know this address is bad.; // In this case the address is also removed from the current callstack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp:43,cache,cached,43,interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,1,['cache'],['cached']
Performance,"// Check if we have contents registered already in global expensive object cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:75,cache,cache,75,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,2,['cache'],['cache']
Performance,"// Check if we need to load a split item or a full one",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.cxx:23,load,load,23,tree/ntuple/v7/src/RColumnElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.cxx,1,['load'],['load']
Performance,"// Check if we should inline a call based on its kind.; // FIXME: this checks both static and dynamic properties of the call, which; // means we're redoing a bit of work that could be cached in the function; // summary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:184,cache,cached,184,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,1,['cache'],['cached']
Performance,// Check if we support repeated scalar values processing (optimization of; // original scalar identity operations on matched horizontal reductions).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:58,optimiz,optimization,58,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['optimiz'],['optimization']
Performance,"// Check if we're building a constant vector, in which case we want to; // generate a constant pool load instead of a vector insert sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:100,load,load,100,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['load'],['load']
Performance,// Check if we've already translated this type. Don't try to do a; // get-or-create style insertion that caches the hash lookup across the; // lowerType call. It will update the TypeIndices map.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:105,cache,caches,105,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['cache'],['caches']
Performance,"// Check if we've performed the split already - note, we only want; // to split the path once per memory region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:18,perform,performed,18,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,1,['perform'],['performed']
Performance,// Check in the cache first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:16,cache,cache,16,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['cache'],['cache']
Performance,"// Check is the file is in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx:31,cache,cache,31,proof/proof/src/TDataSetManagerFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx,1,['cache'],['cache']
Performance,"// Check list of auth info for already loaded info about this host",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:39,load,loaded,39,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['load'],['loaded']
Performance,"// Check loads only against next equivalent class, but stores also against; // other stores in the same equivalence class - to the same address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:9,load,loads,9,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['load'],['loads']
Performance,// Check loop-invariant address because this may also be a sinkable load; // whose address is not necessarily loop-invariant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:68,load,load,68,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['load'],['load']
Performance,"// Check memory cache for the given files",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofBenchTypes.h:16,cache,cache,16,proof/proofbench/inc/TProofBenchTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofBenchTypes.h,1,['cache'],['cache']
Performance,// Check no NaNs before converting to fixed vector scalable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:51,scalab,scalable,51,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['scalab'],['scalable']
Performance,"// Check non-power-of-2 loads/stores for legal vector element types with; // NEON. Non-power-of-2 memory ops will get broken down to a set of; // operations on smaller power-of-2 ops, including ld1/st1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:24,load,loads,24,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['load'],['loads']
Performance,"// Check only that we have a template template argument. We don't want to; // try to check well-formedness now, because our template template parameter; // might have dependent types in its template parameters, which we wouldn't; // be able to match now.; //; // If none of the template template parameter's template arguments mention; // other template parameters, we could actually perform more checking here.; // However, it isn't worth doing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:384,perform,perform,384,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['perform'],['perform']
Performance,"// Check safety of replacing the scalar load with a larger vector load.; // We use minimal alignment (maximum flexibility) because we only care about; // the dereferenceable region. When calculating cost and creating a new op,; // we may use a larger value based on alignment attributes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:40,load,load,40,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,2,['load'],['load']
Performance,// Check that GOT equivalent symbol is cached.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:39,cache,cached,39,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['cache'],['cached']
Performance,"// Check that InternedResult matches up with MR->getSymbols(), overriding; // flags if requested.; // This guards against faulty transformations / compilers / object caches.; // First check that there aren't any missing symbols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:166,cache,caches,166,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,1,['cache'],['caches']
Performance,// Check that a load of the wide type is both allowed and fast on the target,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,load,load,16,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,load,load,27,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,18,['load'],"['load', 'loading', 'loads']"
Performance,"// Check that all accesses to pointers in the alias set use the same type.; // We cannot (yet) promote a memory location that is loaded and stored in; // different sizes. While we are at it, collect alignment and AA info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:129,load,loaded,129,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['load'],['loaded']
Performance,// Check that all the users could perform the shl themselves.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:34,perform,perform,34,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['perform'],['perform']
Performance,// Check that both loads are next to each other in memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,load,loads,19,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loads']
Performance,// Check that each mul is operating on two different loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:53,load,loads,53,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,1,['load'],['loads']
Performance,"// Check that each of the elements provided is valid in a collection literal,; // performing conversions as necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:82,perform,performing,82,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['perform'],['performing']
Performance,"// Check that each of the keys and values provided is valid in a collection; // literal, performing conversions as necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:89,perform,performing,89,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['perform'],['performing']
Performance,// Check that for every known block the cached value is correct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:40,cache,cached,40,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,1,['cache'],['cached']
Performance,"// Check that new latch is a deoptimizing exit and then repeat rotation if possible.; // Deoptimizing latch exit is not a generally typical case, so we just loop over.; // TODO: if it becomes a performance bottleneck extend rotation algorithm; // to handle multiple rotations in one go.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:194,perform,performance,194,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,2,"['bottleneck', 'perform']","['bottleneck', 'performance']"
Performance,// Check that performing a lshr will not lose any information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:14,perform,performing,14,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['perform'],['performing']
Performance,"// Check that sinking the store won't cause program behavior changes. Sinking; // the store out of the Q blocks won't change any behavior as we're sinking; // from a block to its unconditional successor. But we're moving a store from; // the P blocks down through the middle block (QBI) and past both QFB and QTB.; // So we need to check that there are no aliasing loads or stores in; // QBI, QTB and QFB. We also need to check there are no conflicting memory; // operations between PStore and the end of its parent block.; //; // The ideal way to do this is to query AliasAnalysis, but we don't; // preserve AA currently so that is dangerous. Be super safe and just; // check there are no other memory operations at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:365,load,loads,365,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['load'],['loads']
Performance,"// Check that summary index contains regular LTO module when performing; // export to prevent occasional use of index from pure ThinLTO compilation; // (-fno-split-lto-module). This kind of summary index is passed to; // DevirtIndex::run, not to DevirtModule::run used by opt/runForTesting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:61,perform,performing,61,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['perform'],['performing']
Performance,// Check that swifterror argument is only used by loads and stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:50,load,loads,50,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['load'],['loads']
Performance,"// Check that swifterror value is only used by loads, stores, or as; // a swifterror argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:47,load,loads,47,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['load'],['loads']
Performance,// Check that the __objc_imageinfo section is unreferenced.; // FIXME: We could optimize this check if Symbols had a ref-count.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:80,optimiz,optimize,80,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,1,['optimiz'],['optimize']
Performance,"// Check that the add is independent of the load/store. Otherwise, folding; // it would create a cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:44,load,load,44,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['load'],['load']
Performance,"// Check that the add is independent of the load/store. Otherwise, folding; // it would create a cycle. We can avoid searching through Addr as it's a; // predecessor to both.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:44,load,load,44,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['load'],['load']
Performance,"// Check that the add is independent of the load/store.; // Otherwise, folding it would create a cycle. Search through Addr; // as well, since the User may not be a direct user of Addr and; // only share a base pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:44,load,load,44,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['load'],['load']
Performance,// Check that the base address of flat scratch load/store in the form of `base +; // offset` is legal to be put in SGPR/VGPR (i.e. unsigned per hardware; // requirement). We always treat the first operand as the base address here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp:47,load,load,47,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,2,['load'],['load']
Performance,// Check that the difference between original and new latency is decreasing for; // later patterns. This helps to discover sub-optimal pattern orderings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:54,latency,latency,54,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,1,['latency'],['latency']
Performance,// Check that the load is legal for this type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18,load,load,18,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,// Check that the module is well formed on completion of optimization,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt/opt.cpp:57,optimiz,optimization,57,interpreter/llvm-project/llvm/tools/opt/opt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt/opt.cpp,1,['optimiz'],['optimization']
Performance,// Check that the muls operate directly upon sign extended loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:59,load,loads,59,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,1,['load'],['loads']
Performance,// Check that the offset between the pointers to produce a single continuous; // load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:81,load,load,81,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,// Check that the predication in the loop will be equivalent once we; // perform the conversion. Also ensure that we can provide the number; // of elements to the loop start instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:73,perform,perform,73,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,1,['perform'],['perform']
Performance,"// Check that the select condition doesn't reach either load. If so,; // folding this will induce a cycle into the DAG. If not, this is safe to; // xform, so create a select of the addresses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:56,load,load,56,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,"// Check that the shift amount is in range. If not, don't perform undefined; // shifts. When the shift is visited it will be simplified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:58,perform,perform,58,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['perform'],['perform']
Performance,"// Check that the shift amount is in range. If not, don't perform undefined; // shifts. When the shift is visited, it will be simplified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:58,perform,perform,58,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['perform'],['perform']
Performance,// Check that the sorted loads are consecutive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:25,load,loads,25,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['loads']
Performance,// Check that the stored value cover all bits that are loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:55,load,loaded,55,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loaded']
Performance,// Check that the type of the VarDecl has an accessible copy constructor and; // resolve its destructor's exception specification.; // This also performs initialization of block variables when they are moved; // to the heap. It uses the same rules as applicable for implicit moves; // according to the C++ standard in effect ([class.copy.elision]p3).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:145,perform,performs,145,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['perform'],['performs']
Performance,"// Check that there is no implicit control flow instructions above our load in; // its block. If there is an instruction that doesn't always pass the; // execution to the following instruction, then moving through it may become; // invalid. For example:; //; // int arr[LEN];; // int index = ???;; // ...; // guard(0 <= index && index < LEN);; // use(arr[index]);; //; // It is illegal to move the array access to any point above the guard,; // because if the index is out of bounds we should deoptimize rather than; // access the array.; // Check that there is no guard in this block above our instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:71,load,load,71,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['load'],['load']
Performance,// Check that this load could be paired.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:19,load,load,19,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,1,['load'],['load']
Performance,"// Check that we didn't try to load a non-module AST file as a module.; //; // FIXME: Should we also perform the converse check? Loading a module as; // a PCH file sort of works, but it's a bit wonky.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:31,load,load,31,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,3,"['Load', 'load', 'perform']","['Loading', 'load', 'perform']"
Performance,// Check that we do not move a store past loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:42,load,loads,42,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['load'],['loads']
Performance,"// Check that we have all tracked parameters at the last block.; // As we are performing a backward version of the analysis,; // it should be the ENTRY block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:78,perform,performing,78,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['perform'],['performing']
Performance,"// Check that, from after the Load to the end of the BB,; // - if the dest has any Mod, src has no Ref, and; // - if the dest has any Ref, src has no Mod except full-sized lifetimes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:30,Load,Load,30,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['Load'],['Load']
Performance,"// Check the PHIs in the join block. If any of them use a register; // that is defined as IMPLICIT_DEF, do not convert this. This can; // legitimately happen if one side of the split never executes, but; // the compiler is unable to prove it. That side may then seem to; // provide an ""undef"" value to the join block, however it will never; // execute at run-time. If we convert this case, the ""undef"" will; // be used in a MUX instruction, and that may seem like actually; // using an undefined value to other optimizations. This could lead; // to trouble further down the optimization stream, cause assertions; // to fail, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:511,optimiz,optimizations,511,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,2,['optimiz'],"['optimization', 'optimizations']"
Performance,// Check the TuneCPU name if specified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp:13,Tune,TuneCPU,13,interpreter/llvm-project/clang/lib/Basic/Targets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp,1,['Tune'],['TuneCPU']
Performance,"// Check the cache before climbing up use-def chains. This also terminates; // otherwise infinitely recursive queries. Include MayBeCrossIteration in the; // cache key, because some cases where MayBeCrossIteration==false returns; // MustAlias or NoAlias may become MayAlias under MayBeCrossIteration==true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:13,cache,cache,13,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,2,['cache'],['cache']
Performance,// Check the cache first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:13,cache,cache,13,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,3,['cache'],['cache']
Performance,// Check the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:13,cache,cache,13,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,1,['cache'],['cache']
Performance,// Check the cached regunit intervals.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:13,cache,cached,13,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['cache'],['cached']
Performance,// Check the cost of inserting the necessary logic before performing the; // transformation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:58,perform,performing,58,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['perform'],['performing']
Performance,"// Check the file cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelHandleDataSet.cxx:18,cache,cache,18,proof/proofbench/src/TSelHandleDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelHandleDataSet.cxx,1,['cache'],['cache']
Performance,// Check the fold operand is not the loaded/stored value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:37,load,loaded,37,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['load'],['loaded']
Performance,// Check the function attributes and profiles to find out if this function; // should be optimized for size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:89,optimiz,optimized,89,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['optimiz'],['optimized']
Performance,"// Check the innermost scope for a cached landing pad. If this is; // a non-EH cleanup, we'll check enclosing scopes in EmitLandingPad.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:35,cache,cached,35,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,1,['cache'],['cached']
Performance,"// Check the list of auth info for already loaded info about this host",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:43,load,loaded,43,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['load'],['loaded']
Performance,"// Check the loop for a trip count threshold: vectorize loops with a tiny trip; // count by optimizing for size, to minimize overheads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:92,optimiz,optimizing,92,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['optimiz'],['optimizing']
Performance,// Check the single-element cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:28,cache,cache,28,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['cache'],['cache']
Performance,"// Check the source type is the same as the type of the result.; // If not, this concat may extend the vector, so we can not; // optimize it away.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:129,optimiz,optimize,129,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['optimiz'],['optimize']
Performance,"// Check the write cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/src/TNetXNGFile.cxx:19,cache,cache,19,net/netxng/src/TNetXNGFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/src/TNetXNGFile.cxx,1,['cache'],['cache']
Performance,"// Check these files with those in the cache (if any)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:39,cache,cache,39,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,1,['cache'],['cache']
Performance,// Check to see how many predecessors have the loaded value fully; // available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:47,load,loaded,47,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['load'],['loaded']
Performance,"// Check to see if any of the pending instructions are ready to issue. If; // so, add them to the available queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:108,queue,queue,108,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,6,['queue'],['queue']
Performance,// Check to see if the element's load is consecutive to the base load; // or offset from a previous (already checked) load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:33,load,load,33,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,['load'],['load']
Performance,// Check to see if the load is invalidated from the start of the block to; // the load itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:23,load,load,23,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,2,['load'],['load']
Performance,"// Check to see if this is a BUILD_VECTOR of a bunch of values; // which come from any_extend or zero_extend nodes. If so, we can create; // a new BUILD_VECTOR using bit-casts which may enable other BUILD_VECTOR; // optimizations. We do not handle sign-extend because we can't fill the sign; // using shuffles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:216,optimiz,optimizations,216,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['optimiz'],['optimizations']
Performance,"// Check to see if this load can be trivially constant folded, e.g. if the; // input is from a string literal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:24,load,load,24,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['load'],['load']
Performance,"// Check to see if we are dereferencing a null pointer. If so,; // and if not volatile-qualified, this is undefined behavior that the; // optimizer will delete, so warn about it. People sometimes try to use this; // to get a deterministic trap and are surprised by clang's behavior. This; // only handles the pattern ""*null"", which is a very syntactic check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:138,optimiz,optimizer,138,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['optimiz'],['optimizer']
Performance,// Check to see if we have information for the specified type cached.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp:62,cache,cached,62,interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp,1,['cache'],['cached']
Performance,"// Check to see if we have something like this:; // load i32* P; // load i8* (P+1); // if we have this, replace the later with an extraction from the former.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:52,load,load,52,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,2,['load'],['load']
Performance,"// Check to see if we should lower the memcpy to loads and stores first.; // For cases within the target-specified limits, this is the best choice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:49,load,loads,49,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['load'],['loads']
Performance,"// Check to see if we should lower the memmove to loads and stores first.; // For cases within the target-specified limits, this is the best choice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:50,load,loads,50,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['load'],['loads']
Performance,"// Check to see if we've already emitted this. This is necessary; // for a couple of reasons: first, decls can end up in the; // deferred-decls queue multiple times, and second, decls can end; // up with definitions in unusual ways (e.g. by an extern inline; // function acquiring a strong function redefinition). Just; // ignore these cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:144,queue,queue,144,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['queue'],['queue']
Performance,"// Check to see whether we could do some optimization; // to attach relocation to downstream dependent instructions.; // Two kinds of patterns are recognized below:; // Pattern 1:; // %1 = LD_imm64 @""llvm.b:0:4$0:1"" <== patch_imm = 4; // %2 = LDD %1, 0 <== this insn will be removed; // %3 = ADD_rr %0, %2; // %4 = LDW[32] %3, 0 OR STW[32] %4, %3, 0; // The `%4 = ...` will be transformed to; // CORE_[ALU32_]MEM(%4, mem_opcode, %0, @""llvm.b:0:4$0:1""); // and later on, BTF emit phase will translate to; // %4 = LDW[32] %0, 4 STW[32] %4, %0, 4; // and attach a relocation to it.; // Pattern 2:; // %15 = LD_imm64 @""llvm.t:5:63$0:2"" <== relocation type 5; // %16 = LDD %15, 0 <== this insn will be removed; // %17 = SRA_rr %14, %16; // The `%17 = ...` will be transformed to; // %17 = CORE_SHIFT(SRA_ri, %14, @""llvm.t:5:63$0:2""); // and later on, BTF emit phase will translate to; // %r4 = SRA_ri %r4, 63",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:41,optimiz,optimization,41,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,1,['optimiz'],['optimization']
Performance,// Check truncating stores and extending loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:41,load,loads,41,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['load'],['loads']
Performance,// Check we are loading i8 values from two loop invariant pointers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoopIdiomTransform.cpp:16,load,loading,16,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoopIdiomTransform.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoopIdiomTransform.cpp,1,['load'],['loading']
Performance,"// Check we've noticed that we're no longer parsing the initializer for every; // variable. If we miss cases, then at best we have a performance issue and; // at worst a rejects-valid bug.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:133,perform,performance,133,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['perform'],['performance']
Performance,"// Check whether C compares a floating-point value with zero and if that; // floating-point value is also negated. In this case we can use the; // negation to set CC, so avoiding separate LOAD AND TEST and; // LOAD (NEGATIVE/COMPLEMENT) instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:188,LOAD,LOAD,188,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,2,['LOAD'],['LOAD']
Performance,"// Check whether MI is a load candidate for folding into a later; // instruction. If MI is not a candidate, check whether we can fold an; // earlier load into MI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:25,load,load,25,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,2,['load'],['load']
Performance,"// Check whether MI uses a vector length operand. If so, we prepare for VL; // register. We would like to reuse VL register as much as possible. We; // also would like to keep the number of LEA instructions as fewer as; // possible. Therefore, we use a regular scalar register to hold immediate; // values to load VL register. And try to reuse identical scalar registers; // to avoid new LVLr instructions as much as possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp:309,load,load,309,interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp,1,['load'],['load']
Performance,// Check whether VT is a fixed-length SVE vector. These types are; // represented as scalable vectors in function args/return and must be; // coerced from fixed vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/AArch64.cpp:85,scalab,scalable,85,interpreter/llvm-project/clang/lib/CodeGen/Targets/AArch64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/AArch64.cpp,1,['scalab'],['scalable']
Performance,"// Check whether any matched node could raise an FP exception. Since all; // such nodes must have a chain, it suffices to check ChainNodesMatched.; // We need to perform this check before potentially modifying one of the; // nodes via MorphNode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:162,perform,perform,162,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['perform'],['perform']
Performance,// Check whether or not the chain ending in StoreNode is suitable for doing; // the {load; op; store} to modify transformation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:85,load,load,85,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['load'],['load']
Performance,// Check whether or not we want to do any promotion. The reason we have; // this check inside the for loop is to catch the case where an extension; // is directly fed by a load because in such case the extension can be moved; // up without any promotion on its operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:172,load,load,172,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['load'],['load']
Performance,"// Check whether the SCEV difference is the same as the induction step,; // thus we load the value in the next iteration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:84,load,load,84,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['load'],['load']
Performance,// Check whether the call is eligible for tail call optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:52,optimiz,optimization,52,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['optimiz'],['optimization']
Performance,"// Check whether the class is available for auto-loading first:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:49,load,loading,49,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['load'],['loading']
Performance,"// Check whether the entire set of values fit in the buffer. If so, we'll; // use the optimized short hashing routine and skip state entirely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:86,optimiz,optimized,86,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,1,['optimiz'],['optimized']
Performance,// Check whether the loop satisfies the basic conditions needed to perform; // Counter Promotions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:67,perform,perform,67,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['perform'],['perform']
Performance,// Check whether the profiled binary was built with position independent code; // (PIC). Perform sanity checks for assumptions we rely on to simplify; // symbolization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp:89,Perform,Perform,89,interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,1,['Perform'],['Perform']
Performance,"// Check whether the qualifying scope encloses the scope of the original; // declaration. For a template-id, we perform the checks in; // CheckTemplateSpecializationScope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:112,perform,perform,112,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['perform'],['perform']
Performance,// Check whether the target supports casts folded into loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:55,load,loads,55,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['loads']
Performance,// Check whether there's not a write between the two loads which would; // prevent them from being safely merged.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:53,load,loads,53,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,1,['load'],['loads']
Performance,"// Check whether this declaration can be used. Note that we suppress; // this check when we're going to perform argument-dependent lookup; // on this function name, because this might not be the function; // that overload resolution actually selects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:104,perform,perform,104,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['perform'],['perform']
Performance,"// Check whether this gather's offset is incremented by a constant - if so,; // and the load is of the right type, we can merge this into a QI gather",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:88,load,load,88,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,1,['load'],['load']
Performance,"// Check whether to generate an unordered atomic memcpy:; // If the load or store are atomic, then they must necessarily be unordered; // by previous checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:68,load,load,68,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['load'],['load']
Performance,"// Check whether we already loaded this module, before",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:28,load,loaded,28,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,1,['load'],['loaded']
Performance,"// Check whether we can merge loads/stores of some of the pieces of a; // flattened function parameter or return value into a single vector; // load/store.; //; // The flattened parameter is represented as a list of EVTs and; // offsets, and the whole structure is aligned to ParamAlignment. This; // function determines whether we can load/store pieces of the; // parameter starting at index Idx using a single vectorized op of; // size AccessSize. If so, it returns the number of param pieces; // covered by the vector op. Otherwise, it returns 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:30,load,loads,30,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,3,['load'],"['load', 'loads']"
Performance,// Check whether we have an already split load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:42,load,load,42,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['load'],['load']
Performance,"// Check whether we need to call objc_exception_try_exit.; // In optimized code, this branch will always be folded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:65,optimiz,optimized,65,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['optimiz'],['optimized']
Performance,// Check whether we've already cached a load of the thread id in this; // function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:31,cache,cached,31,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,2,"['cache', 'load']","['cached', 'load']"
Performance,// Check whether we've already cached the parent name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:31,cache,cached,31,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,1,['cache'],['cached']
Performance,"// Check whether we've already loaded this module map, and mark it as being; // loaded in case we recursively try to load it from itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:31,load,loaded,31,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,3,['load'],"['load', 'loaded']"
Performance,"// Checking X0 makes no sense. Instead of emitting a load, zero; // ScratchRegs[0].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:53,load,load,53,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,1,['load'],['load']
Performance,"// Checking XZR makes no sense. Instead of emitting a load, zero; // ScratchRegs[0] and use it for the ESR AddrIndex below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp:54,load,load,54,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,1,['load'],['load']
Performance,"// Checking for a single use of this load, we have to check for vector; // width (128 bits) / ElementSize uses (since each operand of the; // BUILD_VECTOR is a separate use of the value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,load,load,37,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['load'],['load']
Performance,// Checking whether we should reduce the load width.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:41,load,load,41,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['load'],['load']
Performance,// Checks if the cached collapsed shadow value dominates Pos.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:17,cache,cached,17,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,1,['cache'],['cached']
Performance,// Checks if the corresponding MOV immediate instruction is applicable for; // this peephole optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp:93,optimiz,optimization,93,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp,1,['optimiz'],['optimization']
Performance,// Checks if the current node (N) is used by any SELECT instruction and; // returns an empty SDValue to avoid applying the optimization to prevent; // incorrect results,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:123,optimiz,optimization,123,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['optimiz'],['optimization']
Performance,"// Checks if the current scope is contained within the target scope.; // Depending on the result, the callback may be performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVScope.h:118,perform,performed,118,interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVScope.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVScope.h,1,['perform'],['performed']
Performance,// Checks performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.h:10,perform,performed,10,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.h,1,['perform'],['performed']
Performance,"// Checks that for every predecessor Pred that can reach a VMEM load,; // none of Pred's successors can reach a VMEM load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSetWavePriority.cpp:64,load,load,64,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSetWavePriority.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSetWavePriority.cpp,2,['load'],['load']
Performance,"// Checks to make sure only first basket is loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/TBranch.cxx:44,load,loaded,44,tree/tree/test/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/TBranch.cxx,2,['load'],['loaded']
Performance,"// Checks to make sure the whole cluster is loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/TBranch.cxx:44,load,loaded,44,tree/tree/test/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/TBranch.cxx,1,['load'],['loaded']
Performance,"// Checks whether an argument of launch_bounds attribute is; // acceptable, performs implicit conversion to Rvalue, and returns; // non-nullptr Expr result on success. Otherwise, it returns nullptr; // and may output an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:76,perform,performs,76,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['perform'],['performs']
Performance,"// Choose better solution for the current VF, Note that Invalid; // costs compare as maximumal large. If both are invalid, we get; // scalable invalid which signals a failure and a vectorization abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:134,scalab,scalable,134,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['scalab'],['scalable']
Performance,// Choose between PassThru's and the loaded value's origins.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:37,load,loaded,37,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['load'],['loaded']
Performance,"// Choose same expensive object cache as input function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedReal.cxx:32,cache,cache,32,roofit/roofitcore/src/RooCachedReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedReal.cxx,2,['cache'],['cache']
Performance,"// Choose same expensive object cache as integrand",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:32,cache,cache,32,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['cache'],['cache']
Performance,// Choosing an out-of-range index leads to the lane being zeroed vs zero; // value where it would perform first lane duplication for out of; // index elements. For i8 elements an out-of-range index could be a valid; // for 2048-bit vector register size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:98,perform,perform,98,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['perform'],['perform']
Performance,"// Cint currently register all libraries that; // are loaded and have a dictionary in them, this; // includes all the libraries that are included; // in the list of (hard) linked libraries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:54,load,loaded,54,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['load'],['loaded']
Performance,// Clamp extending load results to 32-bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp:19,load,load,19,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp,1,['load'],['load']
Performance,"// Clamp the end offset to the end of the allocation. Note that this is; // formulated to handle even the case where ""BeginOffset + Size"" overflows.; // This may appear superficially to be something we could ignore entirely,; // but that is not so! There may be widened loads or PHI-node uses where; // some instructions are dead but not others. We can't completely ignore; // them, and so have to record at least the information here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:270,load,loads,270,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['load'],['loads']
Performance,"// Clamp the shift amount at the original width, and perform the shift.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp:53,perform,perform,53,interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp,1,['perform'],['perform']
Performance,"// Clang emits call of __read_pipe_2 or __read_pipe_4 for OpenCL read_pipe; // builtin, with appended type size and alignment arguments, where 2 or 4; // indicates the original number of arguments. The library has optimized version; // of __read_pipe_2/__read_pipe_4 when the type size and alignment has the same; // power of 2 value. This function transforms __read_pipe_2 to __read_pipe_2_N; // for such cases where N is the size in bytes of the type (N = 1, 2, 4, 8, ...,; // 128). The same for __read_pipe_4, write_pipe_2, and write_pipe_4.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp:214,optimiz,optimized,214,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,1,['optimiz'],['optimized']
Performance,// Clang stores the sret pointer provided by the caller in a static alloca.; // Use DW_OP_deref to tell the debugger to load the pointer and treat it as; // the address of the variable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:120,load,load,120,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,2,['load'],['load']
Performance,"// Clang will try to perform expression based completion as a; // fallback, which is confusing in case of member references. So we; // stop here without any completions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:21,perform,perform,21,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['perform'],['perform']
Performance,"// Class and union are not extendable, if we already; // loaded all the data member there is no need to recheck",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TListOfDataMembers.cxx:57,load,loaded,57,core/meta/src/TListOfDataMembers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TListOfDataMembers.cxx,2,['load'],['loaded']
Performance,"// Class to cache the information we gathered about the branch and its content",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TBranchProxyClassDescriptor.h:12,cache,cache,12,tree/treeplayer/inc/TBranchProxyClassDescriptor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TBranchProxyClassDescriptor.h,1,['cache'],['cache']
Performance,"// Class to encapsulate the types that define how the gradient test is; // performed; it also stores information strings about the types.; // DataType defines how to instantiate the gradient evaluation: Double_t,; // Double_v.; // ExecutionPolicyType defines the execution policy: kSerial, kMultithread...; // DataInfoStr points to a human-readable string describing DataType (e.g.,; // ""Scalar"", ""Vectorial""); // PolicyInfoStr points to a human-readable string describing; // ExecutionPolicyType (e.g., ""Serial"", ""Multithread"")",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testGradient.cxx:75,perform,performed,75,math/mathcore/test/testGradient.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testGradient.cxx,1,['perform'],['performed']
Performance,"// Class to make the Unit Testing. It is important than the test; // methods are inside the class as this in particular is defined as a; // friend of the TFitEditor. This way, we can access the private; // methods of TFitEditor to perform several types of tests.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/test/UnitTesting.cxx:231,perform,perform,231,gui/fitpanel/test/UnitTesting.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/test/UnitTesting.cxx,1,['perform'],['perform']
Performance,"// Class used to cache information (see fComp)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TStreamerInfo.h:17,cache,cache,17,io/io/inc/TStreamerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TStreamerInfo.h,1,['cache'],['cache']
Performance,// Classify instructions into groups to enable fine tuned control over the; // scheduler. These groups may be more specific than current SchedModel; // instruction classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:52,tune,tuned,52,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['tune'],['tuned']
Performance,// Classrefs pointing at Objective-C stub classes must be loaded by calling; // a special runtime function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:58,load,loaded,58,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['load'],['loaded']
Performance,"// Clean and load new batches, one batch for one slave net; //batches.clear();; //batches.reserve(nThreads);; //for (size_t j = 0; j < nThreads; j++) {; // batches.push_back(trainingData.GetTensorBatch());; //}",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:13,load,load,13,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,1,['load'],['load']
Performance,"// Clean current matrices from cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPhysicalNode.cxx:31,cache,cache,31,geom/geom/src/TGeoPhysicalNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPhysicalNode.cxx,1,['cache'],['cache']
Performance,// Cleanup after the loop optimization passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:26,optimiz,optimization,26,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['optimiz'],['optimization']
Performance,// Cleanup of redundant (identical) address/immediate loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:54,load,loads,54,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,1,['load'],['loads']
Performance,// Cleanup of redundant immediate/address loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:42,load,loads,42,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,1,['load'],['loads']
Performance,// Cleanup the code from the dead instructions: GEPs and BitCasts in between; // the original argument and its users: loads and stores. Retarget every; // user to the new created alloca.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:118,load,loads,118,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,1,['load'],['loads']
Performance,"// Clear Cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:9,Cache,Cache,9,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['Cache'],['Cache']
Performance,// Clear any cached analysis results for L if we removed it completely.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:13,cache,cached,13,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['cache'],['cached']
Performance,"// Clear any cached transaction states.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:13,cache,cached,13,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['cache'],['cached']
Performance,"// Clear associated memory cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:27,cache,cache,27,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,10,['cache'],['cache']
Performance,"// Clear cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:9,cache,cache,9,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['cache'],['cache']
Performance,"// Clear cache content",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:9,cache,cache,9,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['cache'],['cache']
Performance,"// Clear cached linkage for function template decls, too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:9,cache,cached,9,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,1,['cache'],['cached']
Performance,"// Clear caches",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:9,cache,caches,9,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['cache'],['caches']
