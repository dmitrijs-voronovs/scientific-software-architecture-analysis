quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Security,"ent b/c SCF option read in DFMP2; psi4.set_global_option('SCF_TYPE', 'DF'). if not psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 properties need DF-SCF reference, for now.'). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(psi4.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). psi4.dfmp2grad(); e_dfmp2 = psi4.get_variable('MP2 TOTAL ENERGY'); e_scs_dfmp2 = psi4.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:33528,Validat,ValidationError,33528,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"ent. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; rais",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:34498,validat,validator,34498,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,1,['validat'],['validator']
Security,"ents is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = qcel.molparse.contiguize_from_fragment_pattern(; frag_pattern, geom=cgeom, elez=celez, elem=celem, mass=cmass); molrec = qcel.molparse.fro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html:55712,Validat,ValidationError,55712,psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,7,['Validat'],['ValidationError']
Security,"epa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """""". optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # If RHF get MP2 NO's; # Why doesnt this work for conv?; if (('DF' in core.get_global_option('SCF_TYPE')) and (user_ref == 'RHF') and; (core.get_option('DETCI', 'MCSCF_TYPE') in ['DF', 'AO']) and; (core.get_option(""DETCI"", ""MCSCF_GUESS"") == ""MP2"")):; core.set_global_option('ONEPDM', True); core.set_global_option('OPDM_RELAX', False); ref_wfn = run_dfmp2_gradient(name, **kwargs); else:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; if (core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV'):; mints = core.MintsHelper(ref_wfn.basisset()); mints.set_print(1); mints.integrals(). ref_optstash.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:130112,Validat,ValidationError,130112,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"epa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # If RHF get MP2 NO's; # Why doesnt this work for conv?; if (('DF' in core.get_global_option('SCF_TYPE')) and (user_ref == 'RHF') and; (core.get_option('DETCI', 'MCSCF_TYPE') in ['DF', 'AO']) and; (core.get_option(""DETCI"", ""MCSCF_GUESS"") == ""MP2"")):; core.set_global_option('ONEPDM', True); core.set_global_option('OPDM_RELAX', False); ref_wfn = run_dfmp2_gradient(name, **kwargs); else:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; if (core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV'):; mints = core.MintsHelper(ref_wfn.basisset()); mints.set_print(1); mints.integrals(). ref_optstash.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:129137,Validat,ValidationError,129137,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"er default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; ra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:168058,Validat,ValidationError,168058,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"er version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #; from __future__ import absolute_import; from __future__ import print_function; import math; from .exceptions import *. [docs]def format_option_for_cfour(opt, val):; """"""Function to reformat value *val* for option *opt* from python; into cfour-speak. Arrays are the primary target. """"""; text = ''. # Transform list from [[3, 0, 1, 1], [2, 0, 1, 0]] --> 3-0-1-1/2-0-1-0; if isinstance(val, list):; if type(val[0]).__name__ == 'list':; if type(val[0][0]).__name__ == 'list':; raise ValidationError('Option has level of array nesting inconsistent with CFOUR.'); else:; # option is 2D array; for no in range(len(val)):; for ni in range(len(val[no])):; text += str(val[no][ni]); if ni < (len(val[no]) - 1):; text += '-'; if no < (len(val) - 1):; text += '/'; else:; # option is plain 1D array; for n in range(len(val)):; text += str(val[n]); if n < (len(val) - 1):; text += '-'. # Transform booleans into integers; elif str(val) == 'True':; text += '1'; elif str(val) == 'False':; text += '0'. # Transform the basis sets that *must* be lowercase (dratted c4 input); elif (opt == 'CFOUR_BASIS') and (val.upper() in ['SVP', 'DZP', 'TZP', 'TZP2P', 'QZ2P', 'PZ3D2F', '13S9P4D3F']):; text += str(val.lower()). # No Transform; else:; text += str(val). return opt[6:], text. [docs]def prepare_options_for_cfour(options):; """"""Function to take the full snapshot of the liboptions object; encoded in dictionary *options*, find the options directable toward; Cfour (options['CFOUR']['CFOUR_**']) that aren't default, the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/options.html:1454,Validat,ValidationError,1454,psi4manual/1.0.0/_modules/qcdb/options.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/options.html,1,['Validat'],['ValidationError']
Security,"er(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; # cbs_delta3_wfn_lesser = kwargs.get('delta3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:32300,Validat,ValidationError,32300,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"er(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_option('SCF', 'SCF_TYPE'), ref_wfn). return core.adc(ref_wfn). def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_local_option('SCF', 'SCF_TYPE', 'DF'). core.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = core.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). scf_wfn = run_scf(name, **kwargs); returnvalue = core.get_variable('CURRENT ENERGY'). for ssuper in dft_functional.superfunctional_list:; if ssuper.name().lower() == name:; dfun = ssuper. if dfun.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if dfun.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfun.c_alpha() * core.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = dfun.c_alpha() * core.get_variable('MP2 CORRELATION ENERGY'). # TODO: delete these variables, since they don't mean what they look to mea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:83601,Validat,ValidationError,83601,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"er)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:64301,Validat,ValidationError,64301,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,"er.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver.name} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.Matrix.from_array(ret); wfn.set_gradient(ret); elif self.driver == 'hessian':; ret = core.Matrix.from_array(ret); grad = core.Matrix.from_array(nbody_model.properties.return_gradient); wfn.set_hessian(ret); wfn.set_gradient(grad). if return_wfn:; return (ret, wfn); else:; return ret. # TODO questions to check:; # * can work with supersystem and embedding_charges?; # * can levels work with same method, different basis?. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.driver_nbody. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:92787,Validat,ValidationError,92787,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"erA', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerB', 'dimer'). activate(molecule); PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'MP2C'); PsiMod.print_out('\n'); banner('MP2C'); PsiMod.print_out('\n'). PsiMod.set_variable('MP2C DIMER MP2 ENERGY', e_dimer_mp2); PsiMod.set_variable('MP2C MONOMER A MP2 ENERGY', e_monomerA_mp2); PsiMod.set_variable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = PsiMod.sapt(). optstash.restore(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """""". molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); if (sapt_basis == 'dimer'):; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:32840,Validat,ValidationError,32840,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"eredDict(); self.oss = OrderedDict() # just in case oss replaces sset someday; for item in oSSET.keys():; if item == 'HRXN_SM':; label = 'small'; elif item == 'HRXN_LG':; label = 'large'; elif item == 'HRXN_EQ':; label = 'equilibrium'; elif item == 'HRXN':; label = 'default'; elif item.startswith('HRXN_'):; label = item.replace('HRXN_', '').lower(); else:; label = item.lower(). # subsets may have different ordering from HRXN; self.sset[label] = OrderedDict(); for rxn in oSSET[item]:; self.sset[label][rxn] = oHRXN[rxn]. # initialize subset objects with light info; try:; sstagl = database.TAGL[item]; except KeyError:; try:; sstagl = database.TAGL[label]; except KeyError:; sstagl = None; print(""""""Warning: TAGL missing for subset %s"""""" % (label)); self.oss[label] = Subset(name=label,; hrxn=self.sset[label].keys(),; tagl=sstagl). # Process axes; for axis in [item for item in pieces if item.startswith('AXIS_')]:; label = axis.replace('AXIS_', ''); try:; defn = getattr(database, axis); except AttributeError:; raise ValidationError(""""""Axis %s not importable."""""" % (label)); axisrxns = frozenset(defn.keys()); attached = False; for ss, rxns in self.sset.iteritems():; if frozenset(rxns).issubset(axisrxns):; ordered_floats = []; for rx in self.oss[ss].hrxn:; ordered_floats.append(defn[rx]); self.oss[ss].axis[label] = ordered_floats; attached = True; if not attached:; print(""""""Warning: AXIS %s not affiliated with a subset"""""" % (label)); pieces.remove(axis). print(""""""WrappedDatabase %s: Unparsed attributes"""""" % (self.dbse), pieces). def __str__(self):; text = ''; text += """""" ==> %s WrappedDatabase <==\n\n"""""" % (self.dbse); text += """""" Reagents: %s\n"""""" % (self.hrgt.keys()); text += """""" Reactions: %s\n"""""" % (self.hrxn.keys()); text += """""" Subsets: %s\n"""""" % (self.sset.keys()); text += """""" Reference: %s\n"""""" % (self.benchmark()); text += """"""\n""""""; return text. [docs] def add_ReactionDatum(self, dbse, rxn, method, mode, basis, value, units='kcal/mol', citation=None, comment=None,; ov",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:28598,Validat,ValidationError,28598,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"erence energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname : str; Name of the CBS component.; zLO : int; Lower zeta level.; valueLO : float; Lower value used for extrapolation.; zMD : int; Intermediate zeta level. Should be equal to zLO + 1.; valueMD : float; Intermediate value used for extrapolation.; zHI : int; Higher zeta level. Should be equal to zLO + 2.; valueHI : float; Higher value used for extrapolation.; alpha : float, optional; Not used. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [4]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0`. References; ----------. .. [4] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(""scf_xtpl_helgaker_3: Inputs must be of the same datatype! (%s, %s, %s)"" %; (type(valueLO), type(valueMD), type(valueHI))). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zMD].upper",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:17454,Validat,ValidationError,17454,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"erforms a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and input.yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:18656,Validat,ValidationError,18656,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"ergies(); ---------------------------------; assemble_dipder_from_dipoles(); ------------------------------. * form DD, G, H from lower derivative points. * place as many of DD, G, H as available onto reference entry. * pull qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union, TYPE_CHECKING. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import DriverEnum, AtomicResult; from qcelemental import constants. from psi4 import core; from psi4.driver import p4util, pp, qcdb, nppp10; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian disp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:4635,validat,validator,4635,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,2,['validat'],['validator']
Security,"ergy = energy(""hf""). compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, ""Nuclear repulsion energy"") #TEST; compare_values(refenergy, thisenergy, 9, ""Reference energy"") #TEST; compare_values(refenergy, variable('scf total energy'), 9, ""Reference energy"") #TEST. Of those small modifications, first, note the special comment at the top (starting with the #! comment marker). This should be descriptive since it is inlined into the manual (unless !nosample in the comment) as a sample input.; Reference values are often assigned to variables for later use.; The compare_values function (along with several relatives in psi4/psi4/driver/p4util/testing.py for comparing strings, matrices, etc.) checks that the computed values match these reference values to suitable precision. This function prints an error message and signals that the test failed to the make system, if the values don’t match. Any lines of the input associated with the validation process should be flagged with #TEST at the end of each line, so that they can be removed when copying from the tests to the samples directory. output.ref¶; When your test case is in final form, run it locally, rename the output to output.ref, and check it into the repository alongside input.dat.; While this isn’t used for any testing machinery (except for the nearly decommissioned psi4/tests/psitest.pl for CC tests; full decommission expected by v1.6), it can be handy for users or developers to consult. test_input.py¶; Starting March 2022, one can also run tests designed as above for CTest through pytest.; To bring the test to pytest’s notice, add a file to the directory named test_input.py.; Below is an example for the psi4/tests/ci-property/test_input.py; from addons import *. @ctest_labeler(""quick;ci;cas;properties;cart;noc1""); def test_ci_property():; ctest_runner(__file__, [""grid.dat""]). This file contains much the same information as the CMakeLists.txt.; The def test_ci_property contains the name of the test, now with und",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/add_tests.html:8196,validat,validation,8196,psi4manual/1.6.x/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/add_tests.html,1,['validat'],['validation']
Security,"ergy = energy(""hf""). compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, ""Nuclear repulsion energy"") #TEST; compare_values(refenergy, thisenergy, 9, ""Reference energy"") #TEST; compare_values(refenergy, variable('scf total energy'), 9, ""Reference energy"") #TEST. Of those small modifications, first, note the special comment at the top (starting with the #! comment marker). This should be descriptive since it is inlined into the manual (unless !nosample in the comment) as a sample input.; Reference values are often assigned to variables for later use.; The compare_values function (along with several relatives in psi4/psi4/driver/p4util/testing.py for comparing strings, matrices, etc.) checks that the computed values match these reference values to suitable precision. This function prints an error message and signals that the test failed to the make system, if the values don’t match. Any lines of the input associated with the validation process should be flagged with #TEST at the end of each line, so that they can be removed when copying from the tests to the samples directory. output.ref¶; When your test case is in final form, run it locally, rename the output to output.ref, and check it into the repository alongside input.dat.; While this isn’t used for any testing machinery, it can be handy for users or developers to consult. test_input.py¶; Starting March 2022, one can also run tests designed as above for CTest through pytest.; To bring the test to pytest’s notice, add a file to the directory named test_input.py.; Below is an example for the psi4/tests/ci-property/test_input.py; from addons import *. @ctest_labeler(""quick;ci;cas;properties;cart;noc1""); def test_ci_property():; ctest_runner(__file__, [""grid.dat""]). This file contains much the same information as the CMakeLists.txt.; The def test_ci_property contains the name of the test, now with underscores rather than hyphens.; def test_ identifies it to pytest as a test.; That part of the function name an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/add_tests.html:8205,validat,validation,8205,psi4manual/master/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/master/add_tests.html,4,['validat'],['validation']
Security,"ergy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:34121,Validat,ValidationError,34121,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"ergy, gradient, or Hessian value at the medium basis set in 3-point; extrapolation.; zHI; Zeta number of the larger basis set in 3-point extrapolation.; Must be `zLO + 2`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 3-point; extrapolation.; verbose; Controls volume of printing.; alpha; Not used. Returns; -------; float or ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [4]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0`. References; ----------. .. [4] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(; f""scf_xtpl_helgaker_3: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueMD)}, {type(valueHI)})""; ). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upper(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:14940,Validat,ValidationError,14940,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Validat'],['ValidationError']
Security,"ergy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.0`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [5]_:; :math:`E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}`. References; ----------. .. [5] Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson,; Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] CISD extrapolation; >>> energy('cbs', corl_wfn='cisd', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2'). """"""; if type(valueLO) != type(valueHI):; raise ValidationError(; f""corl_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.0. if isinstance(valueLO, float):; value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = f""""""\n\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n\n""""""; cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += f"""""" Beta (coefficient) Value: {beta: 16.12f}\n\n""""""; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; # Note that in energy-only days, this used to print SCF and Correlation, not Total, Energy. name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:19024,Validat,ValidationError,19024,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,4,['Validat'],['ValidationError']
Security,"erridden by ``embedding_charges``; if both are provided. :type charge_type: str; :param charge_type: ``MULLIKEN_CHARGES`` || ``LOWDIN_CHARGES``. Default is ``MULLIKEN_CHARGES``; """""". # Initialize dictionaries for easy data passing; metadata, component_results, nbody_results = {}, {}, {}. # Parse some kwargs; kwargs = p4util.kwargs_lower(kwargs); if kwargs.get('levels', False):; return driver_nbody_helper.multi_level(func, **kwargs); metadata['ptype'] = kwargs.pop('ptype', None); metadata['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', None); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['molecule'].fix_com(True); metadata['molecule'].fix_orientation(True); metadata['embedding_charges'] = kwargs.get('embedding_charges', False); metadata['kwargs'] = kwargs; core.clean_variables(). if metadata['ptype'] not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % metadata['ptype']). if metadata['return_total_data'] is None:; if metadata['ptype'] in ['gradient', 'hessian']:; metadata['return_total_data'] = True; else:; metadata['return_total_data'] = False. # Parse bsse_type, raise exception if not provided or unrecognized; metadata['bsse_type_list'] = kwargs.pop('bsse_type'); if metadata['bsse_type_list'] is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(metadata['bsse_type_list'], list):; metadata['bsse_type_list'] = [metadata['bsse_type_list']]. for num, btype in enumerate(metadata['bsse_type_list']):; metadata['bsse_type_list'][num] = btype.lower(); if btype.lower() not in ['cp', 'nocp', 'vmfc']:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). metadata['max_nbody'] = kwargs.get('max_nbody', -1); if metadata['molecule'].nfragments() == 1:; raise ValidationError(""N-Body requires active mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:7941,Validat,ValidationError,7941,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['Validat'],['ValidationError']
Security,"erridden by embedding_charges if both are provided. :type charge_type: string; :param charge_type: ``MULLIKEN_CHARGES`` || ``LOWDIN_CHARGES`` . Default is ``MULLIKEN_CHARGES``; """""". # Initialize dictionaries for easy data passing; metadata, component_results, nbody_results = {}, {}, {}. # Parse some kwargs; kwargs = p4util.kwargs_lower(kwargs); if kwargs.get('levels', False):; return driver_nbody_helper.multi_level(func, **kwargs); metadata['ptype'] = kwargs.pop('ptype', None); metadata['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', False); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['molecule'].fix_com(True); metadata['molecule'].fix_orientation(True); metadata['embedding_charges'] = kwargs.get('embedding_charges', False); metadata['kwargs'] = kwargs; core.clean_variables(). if metadata['ptype'] not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % metadata['ptype']). # Parse bsse_type, raise exception if not provided or unrecognized; metadata['bsse_type_list'] = kwargs.pop('bsse_type'); if metadata['bsse_type_list'] is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(metadata['bsse_type_list'], list):; metadata['bsse_type_list'] = [metadata['bsse_type_list']]. for num, btype in enumerate(metadata['bsse_type_list']):; metadata['bsse_type_list'][num] = btype.lower(); if btype.lower() not in ['cp', 'nocp', 'vmfc']:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). metadata['max_nbody'] = kwargs.get('max_nbody', -1); metadata['max_frag'] = metadata['molecule'].nfragments(); if metadata['max_nbody'] == -1:; metadata['max_nbody'] = metadata['molecule'].nfragments(); else:; metadata['max_nbody'] = min(metadata['max_nbody'], metadata['max_frag']). # Flip this off for now, needs more te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:7124,Validat,ValidationError,7124,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"ers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; The SCF iteration functions; """""". import numpy as np. from psi4.driver import p4util; from psi4.driver import constants; from psi4.driver.p4util.exceptions import SCFConvergenceError, ValidationError; from psi4 import core. from .efp import get_qm_atoms_opts, modify_Fock_permanent, modify_Fock_induced. #import logging; #logger = logging.getLogger(""scf.scf_iterator""); #logger.setLevel(logging.DEBUG). # Q: I expect more local settings of options for part of SCF.; # For convcrit, do we want:; # (A) easy to grep; # with p4util.OptionsStateCM(['SCF', 'E_CONVERGENCE'], ['SCF', 'D_CONVERGENCE']):; # core.set_local_option('SCF', 'E_CONVERGENCE', 1.e-5); # core.set_local_option('SCF', 'D_CONVERGENCE', 1.e-4); # self.iterations(); #; # or (B) functional. options never touched; # self.iterations(e_conv=1.e-5, d_conv=1.e-4). def scf_compute_energy(self):; """"""Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). """"""; if core.get_option('SCF', 'DF_SCF_GUESS') and (core.get_global_option('SCF_TYPE') == 'DIRECT'):; # speed up DIRECT algorithm (recom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:1314,Validat,ValidationError,1314,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security,"er¶. inputparser¶. bad_option_syntax(line)[source]¶; Function to report bad syntax to screen and output file. check_parentheses_and_brackets(input_string, exit_on_error)[source]¶; Function to check that all parenthesis and brackets; in input_string are paired. On that condition, exit_on_error =1,; otherwise 0. parse_multiline_array(input_list)[source]¶; Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. process_basis_block(matchobj)[source]¶; Function to process match of basis name { ... }. process_basis_file(matchobj)[source]¶; Function to process match of basis file .... process_external_command(matchobj)[source]¶; Function to process match of external name? { ... }. process_extract_command(matchobj)[source]¶; Function to process match of extract_subsets. process_filename(matchobj)[source]¶; Function to process match of filename .... process_input(raw_input, print_level=1)[source]¶; Function to preprocess raw input, the text of the input file, then; parse it, validate it for format, and convert it into legitimate Python.; raw_input is printed to the output file unless print_level =0. Does; a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user’s .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed raw_input. process_memory_command(matchobj)[source]¶; Function to process match of memory .... process_molecule_command(matchobj)[source]¶; Function to process match of molecule name? { ... }. process_multiline_arrays(inputfile)[source]¶; Function to find array inputs that are spread across multiple; lines and squash them into a single line. process_option(spaces, module, key, value, line)[source]¶; Function to process a line with set or in a set block; into global/local domain and keyword/value. process_p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:1174,validat,validate,1174,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['validat'],['validate']
Security,"es += linefmt.format('total', 'CBS', '', '', '', finalenergy, ''); tables += delimit. return tables. class CompositeComputer(BaseComputer):. molecule: Any; basis: str = ""(auto)""; method: str = ""(auto)""; driver: DriverEnum; keywords: Dict[str, Any] = {}; metadata: Any; metameta: Dict[str, Any] = {}. verbose: int = 1. # List of model chemistries with extrapolation scheme applied. Can reconstruct CBS. Keys are d_fields. Formerly GRAND_NEED.; cbsrec: List[Dict[str, Any]] = []. # Maximal list of model chemistries extractable from running `compute_list`. Keys are _f_fields. Formerly JOBS_EXT.; trove: List[Dict[str, Any]] = []. # Minimal (enlightened) list of jobs to run to satisfy full CBS. Keys are _f_fields. Formerly JOBS.; compute_list: List[Dict[str, Any]] = []. # One-to-One list of AtomicComputer-s corresponding to `compute_list`.; task_list: List[AtomicComputer] = []. # One-to-One list of QCSchema corresponding to `task_list`.; results_list: List[Any] = []. @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; data = p4util.kwargs_lower(data); data[""metadata""] = _process_cbs_kwargs(data); BaseComputer.__init__(self, **data). self.metameta = {; 'kwargs': data,; 'ptype': self.driver,; 'verbose': self.verbose,; 'label': None,; 'molecule': self.molecule,; }; # logger.debug(""METAMETA\n"" + pp.pformat(self.metameta)). if data['metadata']:; if data['metadata'][0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in driver_cbs.py to proceed."""""" %; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested less",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:53331,validat,validator,53331,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['validat'],['validator']
Security,"es'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""SCF Property: Feature '%s' is not recognized. %s"" % (unknown_property[0], alternatives)). # Validate OEProp; if len(oe_properties):; proc_util.oeprop_validator(oe_properties). if len(linear_response):; optstash_jk = p4util.OptionsState([""SAVE_JK""]); core.set_global_option(""SAVE_JK"", True). # Compute the Wavefunction; scf_wfn = run_scf(name, scf_do_dipole=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in oe_properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.oeprop = oe. # Always must set SCF dipole; for cart in [""X"", ""Y"", ""Z""]:; core.set_variable(""SCF DIPOLE "" + cart, core.get_variable(name + "" DIPOLE "" + cart)). # Run Linear Respsonse; if len(linear_response):; core.prepare_options_for_module(""SCF""); ret = response.scf_response.cpscf_linear_response(scf_wfn, *linear_response,; conv_tol = core.get_global_option(""SOLVER_CONVERGENCE""),; max_iter = core.get_global_option(""SOLVER_MAXITER""),; print_lvl = (core.get_global_option(""PRINT"") + 1)); optstash_jk.restore(). core.tstop(); optstash.restore(); return scf_wfn. def run_cc_property(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:75541,Validat,Validate,75541,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['Validate']
Security,"es'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""SCF Property: Feature '%s' is not recognized. %s"" % (unknown_property[0], alternatives)). # Validate OEProp; if len(oe_properties):; proc_util.oeprop_validator(oe_properties). if len(linear_response):; optstash_jk = p4util.OptionsState([""SAVE_JK""]); core.set_global_option(""SAVE_JK"", True). # Compute the Wavefunction; scf_wfn = run_scf(name, scf_do_properties=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in oe_properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.oeprop = oe. # Always must set SCF dipole (retire components at v1.5); with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for cart in [""X"", ""Y"", ""Z""]:; core.set_variable(""SCF DIPOLE "" + cart, core.variable(name + "" DIPOLE "" + cart)); core.set_variable(""SCF DIPOLE"", core.variable(name + "" DIPOLE"")) # P::e SCF. # Run Linear Respsonse; if len(linear_response):; core.prepare_options_for_module(""SCF""); ret = response.scf_response.cpscf_linear_response(scf_wfn, *linear_response,; conv_tol = core.get_global_option(""SOLVER_CONVERGENCE""),; max_iter = core.get_global_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:95221,Validat,Validate,95221,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['Validate']
Security,"es'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""SCF Property: Feature '%s' is not recognized. %s"" % (unknown_property[0], alternatives)). # Validate OEProp; if len(oe_properties):; proc_util.oeprop_validator(oe_properties). if len(linear_response):; optstash_jk = p4util.OptionsState([""SAVE_JK""]); core.set_global_option(""SAVE_JK"", True). # Compute the Wavefunction; scf_wfn = run_scf(name, scf_do_properties=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in oe_properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.oeprop = oe. # Always must set SCF dipole; for cart in [""X"", ""Y"", ""Z""]:; core.set_variable(""SCF DIPOLE "" + cart, core.variable(name + "" DIPOLE "" + cart)). # Run Linear Respsonse; if len(linear_response):; core.prepare_options_for_module(""SCF""); ret = response.scf_response.cpscf_linear_response(scf_wfn, *linear_response,; conv_tol = core.get_global_option(""SOLVER_CONVERGENCE""),; max_iter = core.get_global_option(""SOLVER_MAXITER""),; print_lvl = (core.get_global_option(""PRINT"") + 1)); optstash_jk.restore(). core.tstop(); optstash.restore(); return scf_wfn. def run_cc_property(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:74639,Validat,Validate,74639,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['Validate']
Security,"es'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""SCF Property: Feature '%s' is not recognized. %s"" % (unknown_property[0], alternatives)). # Validate OEProp; if len(oe_properties):; proc_util.oeprop_validator(oe_properties). if len(linear_response):; optstash_jk = p4util.OptionsState([""SAVE_JK""]); core.set_global_option(""SAVE_JK"", True). # Compute the Wavefunction; scf_wfn = run_scf(name, scf_do_properties=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in oe_properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.oeprop = oe. core.set_variable(""SCF DIPOLE"", core.variable(name + "" DIPOLE"")) # P::e SCF. # Run Linear Respsonse; if len(linear_response):; core.prepare_options_for_module(""SCF""); ret = response.scf_response.cpscf_linear_response(scf_wfn, *linear_response,; conv_tol = core.get_global_option(""SOLVER_CONVERGENCE""),; max_iter = core.get_global_option(""SOLVER_MAXITER""),; print_lvl = (core.get_global_option(""PRINT"") + 1)); optstash_jk.restore(). core.tstop(); optstash.restore(); return scf_wfn. def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module cal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:96354,Validat,Validate,96354,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['Validat'],['Validate']
Security,"es.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import absolute_import. from psi4 import core; from psi4 import extras. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/exceptions.html:1347,Validat,ValidationError,1347,psi4manual/1.2.1/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/exceptions.html,1,['Validat'],['ValidationError']
Security,"es.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import absolute_import; from psi4 import core; from psi4 import extras. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/exceptions.html:1345,Validat,ValidationError,1345,psi4manual/1.1.0/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/exceptions.html,1,['Validat'],['ValidationError']
Security,es_from_fcidump; energies_from_fcidump; energy; energy; fchk; fchk; fcidump; fcidump; fcidump_from_file; fcidump_from_file; find_approximate_string_matches; find_approximate_string_matches; freq; freq; frequencies; frequencies; frequency; frequency; gdma; gdma; geometry; geometry; get_memory; get_memory; getFromDict; gradient; gradient; hessian; hessian; join_path; join_path; levenshtein; levenshtein; ManagedMethodError; molden; molden; driver.molecule_from_arrays; driver.molecule_from_arrays; driver.molecule_from_schema; driver.molecule_from_schema; driver.molecule_from_string; driver.molecule_from_string; molecule_get_attr; molecule_get_attr; molecule_set_attr; molecule_set_attr; oeprop; oeprop; opt; opt; OptimizationConvergenceError; optimize; optimize; ParsingError; PastureRequiredError; pcm_helper; pcm_helper; print_stderr; print_stderr; print_stdout; print_stdout; process_input; process_input; prop; prop; properties; properties; PsiException; PsiImportError; QMMM; sanitize_name; sanitize_name; scf_helper; scf_helper; scf_wavefunction_factory; scf_wavefunction_factory; SCFConvergenceError; set_memory; set_memory; set_module_options; set_module_options; set_options; set_options; success; success; Table; temp_circular_import_blocker; temp_circular_import_blocker; TestComparisonError; ValidationError; vibanal_wfn; vibanal_wfn; write_eigenvalues; write_eigenvalues; xml2dict; xml2dict. Appendices; Appendices. /autodir_options_c; ; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no ti,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:509681,Validat,ValidationError,509681,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['Validat'],['ValidationError']
Security,es_from_fcidump; energies_from_fcidump; energy; energy; fchk; fchk; fcidump; fcidump; fcidump_from_file; fcidump_from_file; find_approximate_string_matches; find_approximate_string_matches; freq; freq; frequencies; frequencies; frequency; frequency; gdma; gdma; geometry; geometry; get_memory; get_memory; getFromDict; gradient; gradient; hessian; hessian; join_path; join_path; levenshtein; levenshtein; ManagedMethodError; molden; molden; driver.molecule_from_arrays; driver.molecule_from_arrays; driver.molecule_from_schema; driver.molecule_from_schema; driver.molecule_from_string; driver.molecule_from_string; molecule_get_attr; molecule_get_attr; molecule_set_attr; molecule_set_attr; oeprop; oeprop; opt; opt; OptimizationConvergenceError; optimize; optimize; ParsingError; PastureRequiredError; pcm_helper; pcm_helper; print_stderr; print_stderr; print_stdout; print_stdout; process_input; process_input; prop; prop; properties; properties; PsiException; PsiImportError; QMMM; sanitize_name; sanitize_name; scf_helper; scf_helper; scf_wavefunction_factory; scf_wavefunction_factory; SCFConvergenceError; set_memory; set_memory; set_module_options; set_module_options; set_options; set_options; success; success; Table; temp_circular_import_blocker; temp_circular_import_blocker; TestComparisonError; ValidationError; vibanal_wfn; vibanal_wfn; write_eigenvalues; write_eigenvalues; xml2dict; xml2dict. Appendices; Appendices. autodir_options_c; ; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no tit,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:466655,Validat,ValidationError,466655,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['Validat'],['ValidationError']
Security,"esearch site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When `psi4` the python module is importable at `import qcdb`; time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o'lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar ""DISPERSION CORRECTION ENERGY"" is set; * `verbose` triggered when PRINT keywork of SCF module >=3. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, (Molecule, core.Molecule)):; # 1st: called on a qcdb.Molecule; # 2nd: called on a python export of a psi4.Molecule (py-side through Psi4's driver); pass; elif isinstance(mol, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); mol = Molecule(mol); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # Validate arguments; if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError(""""""Requested derivative level 'dertype' %s not valid for run_dftd3."""""" % (dertype)); else:; raise ValidationError(""""""Requested derivative level 'dertype' %s not valid for run_dftd3."""""" % (dertype)). if dashlvl is not None:; dashlvl = dashlvl.lower(); dashlvl = get_dispersion_aliases()[dashlvl] if dashlvl in get_dispersion_aliases() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())); else:; raise ValidationError(""""""Must specify a dashlvl""""""). if func is not None:; dftd3_params = dash_server(func, dashlvl); else:; dftd3_params = {}. if dashparam is not None:; dftd3_params.update(dashparam). # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dft",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html:4753,Validat,Validate,4753,psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,1,['Validat'],['Validate']
Security,"esian"", None) is not None:; c1_molecule._initial_cartesian = scf_molecule._initial_cartesian.clone(); c1_molecule.set_geometry(c1_molecule._initial_cartesian); c1_molecule.reset_point_group(""c1""); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); else:; raise ValidationError(""Set no_com/no_reorient/symmetry c1 by hand for PE or external potentials on non-Cartesian molecules.""). scf_molecule = c1_molecule; core.print_out("""""" PE does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); core.print_out("""""" PE geometry must align with POTFILE keyword: """"""; """"""resetting coordinates with fixed origin and orientation.\n""""""). # SCF Banner data; banner = kwargs.pop('banner', None); bannername = name. # Did we pass in a DFT functional?; dft_func = kwargs.pop('dft_functional', None); if dft_func is not None:; if name.lower() != ""scf"":; raise ValidationError(""dft_functional was supplied to SCF, but method name was not SCF ('%s')"" % name); name = dft_func; bannername = name; if isinstance(name, dict):; bannername = name.get(""name"", ""custom functional""). p4util.libint2_print_out(). # Setup the timer; if do_timer:; core.tstart(). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('SCF', 'SOSCF'):; proc_util.check_non_symmetric_jk_density(""Second-order SCF""). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if core.has_option_changed('SCF', 'BASIS_GUESS'):; cast = core.get_option('SCF', 'BASIS_GUESS'); if p4util.yes.match(str(cast)):; cast = True; elif p4util.no.match(str(cast)):; cast = False. if cast:. # A user can set ""BASIS_GUESS"" to True and we default to 3-21G; if cast is True:; guessbasis = corresponding_basis(core.get_global_option('BASIS'), 'GUESS')[0]; if guessbasis is None:; guessbasis = '3-21G' # guess of last resort; else:; guessbasis = cast; core.set_global_option('BASIS', guessbasis). castdf = 'DF' in core.get",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:48103,Validat,ValidationError,48103,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"esser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; Module with database functionality. """""". __all__ = [; ""database"",; ""db"",; ""DB_RGT"",; ""DB_RXN"",; ]. import collections; import math; import os; import re; import sys. from psi4 import core. from . import p4util; from .constants import constants; from .driver import *. # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]; def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/wrapper_database.html:2012,access,accessible,2012,psi4manual/1.9.x/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/wrapper_database.html,2,['access'],['accessible']
Security,"essian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:69228,Validat,ValidationError,69228,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"essian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:64485,Validat,ValidationError,64485,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"est; zeta-level among an array of bases. Used by :py:func:`~driver_cbs.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; if isinstance(valueHI, float):. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname.upper()); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI). psi4.print_out(cbsscheme). return valueHI. elif isinstance(valueHI, (psi4.Matrix, psi4.Vector)):. if verbose > 2:; psi4.print_out("""""" HI-zeta (%s) Total Energy:\n"""""" % (str(zHI))); valueHI.print_out(). return valueHI. [docs]def scf_xtpl_helgaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=1.63):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~driver_cbs.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """""". if type(valueLO) != type(valueHI):; raise ValidationError(""scf_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). beta_division = 1 / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); beta_mult = math.exp(-1 * alpha * zHI). if isinstance(valueLO, float):; beta = (valueHI - valueLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 2-point SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += na",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:5231,Validat,ValidationError,5231,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"ests. If pytest-xdist installed, parallel with -n. -v, --verbose¶; Print the Psithon to Python translation of the input file. -V, --version¶; Print version information.; # stable release; >>> psi4 --version; 1.3.2. # development snapshot between 1.3 and 1.4; >>> psi4 --version; 1.4a2.dev525. Environment Variables¶; These environment variables will influence PSI4‘s behavior. CONDA_PREFIX¶; Set when a conda environment is activated. Note that if PSI4 has been; built against any library in CONDA_PREFIX, the path has been baked into the; program, so any available dependencies are liable to been loaded from the environment. HOST¶; Set when a conda environment with conda compilers is activated. Used; when compatibly building PSI4 from source against conda; dependencies. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; While once configuring PSI4 through PSIPATH was preferred; to modifying this environment variable, now PATH is preferred for; executables to accommodate QCEngine. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that PSI4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external.html:20979,access,access,20979,psi4manual/master/external.html,https://psicode.org,https://psicode.org/psi4manual/master/external.html,9,['access'],['access']
Security,"esults from TROVE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:5038,validat,validator,5038,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['validat'],['validator']
Security,"et -n4 below.; The next step is then to actually run the computation:; /psi/install/directory/bin/psi4 -i input.in -o input.out -n 4. And then to clean up the scratch directories previously created:; foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Removing scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; end. Note again that the specific commands for your PBS system may differ. Refer; to your system administrator. Command Line Options¶; PSI4 can be invoked with no command line arguments, as it takes as input; by default the file “input.dat” and directs output by default to “output.dat”.; Each set of three commands below is completely equivalent, while the second set,; perhaps, is the most common usage.; >>> psi4; >>> psi4 -i input.dat -o output.dat; >>> psi4 input.dat output.dat. >>> psi4 descriptive_filename.in; >>> psi4 -i descriptive_filename.in -o descriptive_filename.out; >>> psi4 descriptive_filename.in descriptive_filename.out. Command-line arguments to PSI4 can be accessed through psi4 --help. -a, --append¶; Append results to output file. Default: Truncate first. -h, --help¶; Display the command-line options and usage information. -i <filename>, --input <filename>¶; Input file name. Default: input.dat. --inplace¶; Runs PSI4 with compiled code from <objdir> but driver code from source,; so no need to make between Python edits. Expert mode. -k, --skip-preprocessor¶; Skips input preprocessing. Expert mode. -l <name>, --psidatadir <name>¶; Overrides the value of; PSIDATADIR and specifies the path to the Psi data; library (ends in share/psi4). Expert mode. --loglevel <int>¶; Sets logging level: WARN=30, INFO=20, DEBUG=10. -m, --messy¶; Leave temporary files after the run is completed. --memory <memory>¶; The amount of memory to use. Can be specified with units (e.g., ‘10MB’) otherwise bytes is assumed. --module¶. The location of the associated PSI4 Python module. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external.html:18262,access,accessed,18262,psi4manual/master/external.html,https://psicode.org,https://psicode.org/psi4manual/master/external.html,5,['access'],['accessed']
Security,"et -n4 below.; The next step is then to actually run the computation:; /psi/install/directory/bin/psi4 -i input.in -o input.out -n 4. And then to clean up the scratch directories previously created:; foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Removing scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; end. Note again that the specific commands for your PBS system may differ. Refer; to your system administrator. Command Line Options¶; PSI4 can be invoked with no command line arguments, as it takes as input; by default the file “input.dat” and directs output by default to “output.dat”.; Each set of three commands below is completely equivalent, while the second set,; perhaps, is the most common usage.; >>> psi4; >>> psi4 -i input.dat -o output.dat; >>> psi4 input.dat output.dat. >>> psi4 descriptive_filename.in; >>> psi4 -i descriptive_filename.in -o descriptive_filename.out; >>> psi4 descriptive_filename.in descriptive_filename.out. Command-line arguments to PSI4 can be accessed through psi4 --help. -a, --append¶; Append results to output file. Default: Truncate first. -h, --help¶; Display the command-line options and usage information. -i <filename>, --input <filename>¶; Input file name. Default: input.dat. --inplace¶; Runs PSI4 with compiled code from <objdir> but driver code from source,; so no need to make between Python edits. Expert mode. -k, --skip-preprocessor¶; Skips input preprocessing. Expert mode. -l <name>, --psidatadir <name>¶; Overrides the value of; PSIDATADIR and specifies the path to the Psi data; library (ends in share/psi4). Expert mode. -m, --messy¶; Leave temporary files after the run is completed. --memory <memory>¶. The amount of memory to use. Can be specified with units (e.g., ‘10MB’) otherwise bytes is assumed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS).; Also controls the testing parallelism with pytest. -o <filename>, --output <filename>¶; Output file name. Use stdout as <",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:18161,access,accessed,18161,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,4,['access'],['accessed']
Security,"et = core.Dimension(irreps, name); for i in range(irreps):; ret[i] = dims[i]; return ret. def _dimension_to_tuple(self: core.Dimension) -> Tuple[int]:; """"""Serializes :class:`~psi4.core.Dimension` to a tuple."""""". if isinstance(self, (tuple, list)):; return tuple(self). irreps = self.n(); ret = []; for i in range(irreps):; ret.append(self[i]); return tuple(ret). def _dimension_iter(dim) -> Iterator[int]:; """"""; Provides an iterator class for the Dimension object. Example; -------; >>> dim = psi4.core.Dimension(...); >>> list(dim). """"""; for i in range(dim.n()):; yield dim[i]. # Dimension attributes; core.Dimension.from_list = _dimension_from_list; core.Dimension.to_tuple = _dimension_to_tuple; core.Dimension.__iter__ = _dimension_iter. # General functions for NumPy array manipulation. [docs]; def block_diagonal_array(*args: List[np.ndarray]) -> np.ndarray:; """"""; Convert square NumPy array to a single block diagonal array.; Mimic of SciPy's :func:`scipy.linalg.block_diag`. Parameters; ----------; args; Arbitrary number of square arrays.; """""". # Validate the input matrices.; dim = 0; for matrix in args:; try:; shape = matrix.shape; dim += shape[0]; except (AttributeError, TypeError):; raise ValidationError(""Cannot construct block diagonal from non-arrays.""); if len(shape) != 2:; raise ValidationError(""Cannot construct block diagonal from non-2D arrays.""); if shape[0] != shape[1]:; raise ValidationError(""Cannot construct block diagonal from non-square arrays.""). # If this is too slow, try a sparse matrix?; block_diag = np.zeros((dim, dim)); start = 0; for matrix in args:; next_block = slice(start, start + matrix.shape[0]); block_diag[next_block, next_block] = matrix; start += matrix.shape[0]. return block_diag. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; psi4.driver.p4util.numpy_helper. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:17592,Validat,Validate,17592,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,4,['Validat'],"['Validate', 'ValidationError']"
Security,"et the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dictionary. success(label); Function to print a ‘label…PASSED’ line to screen. vibanal_wfn(wfn[, hess, irrep, molecule, …]). write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. xml2dict([filename]); Read XML filename into nested OrderedDict-s. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, maxit); Error called for problems with converging and iterative method. Dftd3Error(msg). EmpericalDispersion(alias, dtype, **kwargs). ManagedMethodError(circs). OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. ValidationError(msg); Error called for problems with the input file. datetime(year, month, day[, hour[, minute[, …); The year, month and day arguments are required. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:263884,Validat,ValidationError,263884,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['Validat'],['ValidationError']
Security,"et(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return (metadata). def _process_cbs_kwargs(kwargs):; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs : dict; kwargs containing the CBS function specification. Returns; -------; list; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}_basis"" in kwargs:; # either both *_wfn and *_basis have to be specified; stage = {""wfn"": kwargs[f""{sn}_wfn""], ""basis"": kwargs[f""{sn}_basis""]}; elif sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis"": kwargs[f""{sn}_basis""]}; else:; # otherwise go to the next possible stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwargs:; stage[""wfn_lo""] = kwargs[f""{sn}_wfn_lesser""]; if f""cbs_{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""cbs_{sn}_alpha""]; elif f""{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""{sn}_alpha""]; cbs_metadata.append(stage); if sn =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:32762,Validat,ValidationError,32762,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"et_default_path('/scratch/user'). To set up the scratch path from a variable $MYSCRATCH:; 1; 2; 3; 4import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). To set up a specific path for the checkpoint file and instruct PSI4 not to delete it:; 1; 2; 3; 4; 5; 6psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). # equivalent to above; psi4_io.set_specific_path(PSIF_CHKPT, './'); psi4_io.set_specific_retention(PSIF_CHKPT, True). The Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. As a consequence, the commands in the input files supersede; any instructions in the ~/.psi4rc file. During; execution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed.; The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and C++; std::thread for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or other threaded BLAS. Less; than 20% of the threaded code in PSI4 uses OpenMP, the rest is handled by; parallel DGEMM and other library routines. From this point forward, it is; assumed that you have compiled PSI4 with OpenMP and MKL (Note that it is; possible to use g++ or another compiler and yet still link against MKL).; Control of threading in PSI4 can be accomplished ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:9291,access,accessible,9291,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,6,['access'],['accessible']
Security,"et_global_option('MODULE', 'RTDDFT'). PsiMod.libfock(). [docs]def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; return PsiMod.mcscf(). [docs]def scf_helper(name, **kwargs):; """"""Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). """"""; optstash = OptionsState(; ['PUREAM'],; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO']). # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). optstash2 = OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO']). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if PsiMod.has_option_changed('SCF', 'BASIS_GUESS'):; cast = PsiMod.get_option('SCF', 'BASIS_GUESS'); if yes.match(str(cast)):; cast = True; elif no.match(str(cast)):; cast = False. if PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; castdf = True; else:; castdf = False. if PsiMod.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = PsiMod.get_option('SCF', 'DF_BASIS_GUESS'); if yes.match(str(castdf)):; castdf = True; elif no.match(str(castdf)):; castdf = False. # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; molecule = PsiMod.get_active_molecule(); multp = molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if PsiMod.get_option('SCF','R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:15013,Validat,ValidationError,15013,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"et_global_option('MODULE', 'RTDDFT'). PsiMod.libfock(). [docs]def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; return PsiMod.mcscf(). [docs]def scf_helper(name, **kwargs):; """"""Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). """"""; optstash = OptionsState(; ['PUREAM'],; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO']). # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). optstash2 = OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO']). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if PsiMod.has_option_changed('SCF', 'BASIS_GUESS'):; cast = PsiMod.get_option('SCF', 'BASIS_GUESS'); if yes.match(str(cast)):; cast = True; elif no.match(str(cast)):; cast = False. if PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; castdf = True; else:; castdf = False. if PsiMod.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = PsiMod.get_option('SCF', 'DF_BASIS_GUESS'); if yes.match(str(castdf)):; castdf = True; elif no.match(str(castdf)):; castdf = False. precallback = None; if 'precallback' in kwargs:; precallback = kwargs.pop('precallback'). postcallback = None; if 'postcallback' in kwargs:; postcallback = kwargs.pop('postcallback'). # Hack to ensure cartesian or pure are used throughout; # Note that c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:6715,Validat,ValidationError,6715,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"et_local_option('CCEOM','R_CONVERGENCE',1e-4); core.set_local_option('CCEOM','E_CONVERGENCE',1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX'],; ['SCF_TYPE']). core.set_global_option('ONEPDM', 'TRUE'); core.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if not core.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_dipole=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; core.set_variable('CURRENT ENERGY', core.get_variable('SCS-MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.get_variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; core.set_variable('CURRENT ENERGY', core.get_variable('MP2 TOTAL ENERGY')); core.set_variable('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:75936,Validat,ValidationError,75936,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"et_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); PsiMod.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); PsiMod.dfmp2(); returnvalue += dfun.c_alpha() * PsiMod.get_variable('SCS-DF-MP2 CORRELATION ENERGY'). else:; PsiMod.dfmp2(); returnvalue += dfun.c_alpha() * PsiMod.get_variable('DF-MP2 CORRELATION ENERGY'). PsiMod.set_variable('DFT TOTAL ENERGY', returnvalue); PsiMod.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(); return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE']). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). if (PsiMod.get_option('SCF', 'SCF_TYPE') != 'DF'):; raise ValidationError('SCF_TYPE must be DF for DFT gradient (for now).'). returnvalue = run_scf_gradient(name, **kwargs). optstash.restore(); return returnvalue. [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if (name.lower() == 'zapt'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'ZAPTN'); PsiMod.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_local_option('DETCI', 'MAX_NUM_VECS', maxnve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:24515,Validat,ValidationError,24515,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"et_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp3_gradient'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:8839,access,access,8839,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,3,['access'],['access']
Security,"et_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; psi4.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp3_gra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:8951,access,access,8951,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['access'],['access']
Security,"et_variable(""CURRENT CORRELATION ENERGY"", cemp4). optstash.restore(); return fnocc_wfn. [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). psi4.set_local_option('FNOCC', 'RUN_CEPA', True); psi4.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; psi4.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; psi4.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). psi4.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level.upper()). if name in ['fno-lccd', 'fno-lccsd', 'fno-cepa(0)', 'fno-cepa(1)', 'fno-cepa(3)',; 'fno-acpf', 'fno-aqcc', 'fno-cisd']:; psi4.set_local_option('FNOCC', 'NAT_ORBS', True). # throw an exception for open-shells; if psi4.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). fnocc_wfn = psi4.fnocc(ref_wfn). # one-electron properties; if psi4.get_option('FNOCC', 'DIPMOM'):",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:106108,Validat,ValidationError,106108,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"et_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* from global memory if present. Para",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:40462,Validat,ValidationError,40462,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"etc.; For the moment, so-called “best-practices” keywords are summarized at; Best Practices.; For the type of computation intended, find appropriate options at; Keywords. These keyword summaries contain the same; information as the proper CFOUR options list; plus notes on keyword relevance when run through PSI4. Information; at the CFOUR manual may; also be useful, as may the many samples at psi4/samples/cfour.; Set Cfour keywords just like PSI4 keywords. The names of keywords; are unchanged beyond a prepended “cfour_”. (Though be aware that common; abbreviations like CALC and REF must be fully spelled out as; CFOUR_CALC_LEVEL and CFOUR_REFERENCE when used in; PSI4.); In limited trial cases, keywords nominally directed at non-Cfour modules; are translated into their Cfour counterparts. For example, setting; REFERENCE will appropriately set CFOUR_REFERENCE. For a; list of applicable keywords, see source of; qcdb.cfour.muster_psi4options().; Consult Functionality for information on what Cfour; functionality is accessible through PSI4. PSI4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a PSI4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/share/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into PSI4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of result",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:2820,access,accessible,2820,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,6,['access'],['accessible']
Security,"etc.; For the moment, so-called “best-practices” keywords are summarized at; Best Practices.; For the type of computation intended, find appropriate options at; Keywords. These keyword summaries contain the same; information as the proper CFOUR options list; plus notes on keyword relevance when run through Psi4. Information; at the CFOUR manual may; also be useful, as may the many samples at psi4/samples/cfour.; Set Cfour keywords just like Psi4 keywords. The names of keywords; are unchanged beyond a prepended “cfour_”. (Though be aware that common; abbreviations like CALC and REF must be fully spelled out as; CFOUR_CALC_LEVEL and CFOUR_REFERENCE when used in; Psi4.); In limited trial cases, keywords nominally directed at non-Cfour modules; are translated into their Cfour counterparts. For example, setting; REFERENCE will appropriately set CFOUR_REFERENCE. For a; list of applicable keywords, see source of; qcdb.cfour.muster_psi4options().; Consult Functionality for information on what Cfour; functionality is accessible through Psi4. Psi4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a Psi4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/share/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into Psi4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:2876,access,accessible,2876,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['access'],['accessible']
Security,"etci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/proc_py-1.html:6544,access,access,6544,psi4manual/1.4.0/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/proc_py-1.html,2,['access'],['access']
Security,"etci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/proc_py-1.html:6544,access,access,6544,psi4manual/1.5.0/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/proc_py-1.html,2,['access'],['access']
Security,"eters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH` or :envvar:`PSIPATH`.; *self* may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, psi4.Molecule):; # called on a python export of a psi4.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must h",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:2777,Validat,ValidationError,2777,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"ethod, **kwargs); Begin functioning as an MDI engine. message_box([message, max_width, min_width]); put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, ...); Builds the correct (R/U/RO/CU HF/KS) wavefunction from the provided information, sets relevant auxiliary basis sets on it, and prepares any empirical dispersion. set_memory(inputval[, execute, quiet]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict[, verbose]); Sets Psi4 option",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:20325,validat,validate,20325,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,3,['validat'],['validate']
Security,"etry'],; elea=None,; elez=None,; elem=ms['symbols'],; mass=ms.get('masses', None),; real=ms.get('real', None),; elbl=None,; throw_reorder=True). molrec = qcdb.molparse.from_arrays(geom=dcontig['geom'],; elea=None,; elez=None,; elem=dcontig['elem'],; mass=dcontig['mass'],; real=dcontig['real'],; elbl=None,; name=ms.get('name', None),; units='Bohr',; input_units_to_au=None,; fix_com=ms.get('fix_com', None),; fix_orientation=ms.get('fix_orientation', None),; fix_symmetry=None,; fragment_separators=dcontig['fragment_separators'],; fragment_charges=ms.get('fragment_charges', None),; fragment_multiplicities=ms.get('fragment_multiplicities', None),; molecular_charge=ms.get('molecular_charge', None),; molecular_multiplicity=ms.get('molecular_multiplicity', None),; domain='qm',; #missing_enabled_return=missing_enabled_return,; #tooclose=tooclose,; #zero_ghost_fragments=zero_ghost_fragments,; #nonphysical=nonphysical,; #mtol=mtol,; verbose=verbose). else:; raise ValidationError(""""""Schema not recognized, schema_name/schema_version: {}/{} """""".format(molschema.get('schema_name', 'NA'), molschema.get('schema_version', 'NA'))). if return_dict:; return core.Molecule.from_dict(molrec), molrec; else:; return core.Molecule.from_dict(molrec). [docs]def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the core.Molecule class. """"""; cls.__setattr__ = molecule_set_attr; cls.__getattr__ = molecule_get_attr. # for py3-only, all these `cls.fn = qcdb.Molecule._raw_fn` can be; # replaced by `cls.fn = qcdb.Molecule.fn` and in qcdb/molecule.py; # itself, the raw, staticmethod fns can use their official names again; # and not need the append line at bottom of file. what I do for you,; # py2 ...; cls.to_arrays = qcdb.Molecule._raw_to_arrays; cls.to_dict = qcdb.Molecule._raw_to_dict; cls.BFS = qcdb.Molecule._raw_BFS; cls.B787 = qcdb.Molecule._raw_B787; cls.scramble = qcdb.Molecule._raw_scramble; cls.from_arrays = molecule_from_arrays; cls.from_string = molecule_from_stri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/molutil.html:6432,Validat,ValidationError,6432,psi4manual/1.2.1/_modules/psi4/driver/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/molutil.html,1,['Validat'],['ValidationError']
Security,"etry, extern)); else:; if fix_symmetry is not None:; symm = fix_symmetry.lower(). molinit = {}; molinit[""fix_com""] = com; molinit[""fix_orientation""] = orient; if symm:; molinit[""fix_symmetry""] = symm. return molinit. def validate_and_fill_efp(fragment_files=None, hint_types=None, geom_hints=None):. if (; fragment_files is None; or hint_types is None; or geom_hints is None; or fragment_files == [None]; or hint_types == [None]; or geom_hints == [None]; or not (len(fragment_files) == len(hint_types) == len(geom_hints)); ):. raise ValidationError(; """"""Missing or inconsistent length among efp quantities: fragment_files ({}), hint_types ({}), and geom_hints ({})"""""".format(; fragment_files, hint_types, geom_hints; ); ). # NOTE: imposing case on file; try:; files = [f.lower() for f in fragment_files]; except AttributeError:; raise ValidationError(""""""fragment_files not strings: {}"""""".format(fragment_files)). if all(f in [""xyzabc"", ""points"", ""rotmat""] for f in hint_types):; types = hint_types; else:; raise ValidationError(""""""hint_types not among 'xyzabc', 'points', 'rotmat': {}"""""".format(hint_types)). hints = []; hlen = {""xyzabc"": 6, ""points"": 9, ""rotmat"": 12}; for ifr, fr in enumerate(geom_hints):; try:; hint = [float(f) for f in fr]; except (ValueError, TypeError):; raise ValidationError(""""""Un float-able elements in geom_hints[{}]: {}"""""".format(ifr, fr)). htype = hint_types[ifr]; if len(hint) == hlen[htype]:; hints.append(hint); else:; raise ValidationError(""""""EFP hint type {} not {} elements: {}"""""".format(htype, hlen[htype], hint)). return {""fragment_files"": files, ""hint_types"": types, ""geom_hints"": hints}. def validate_and_fill_geometry(geom=None, tooclose=0.1, copy=True):; """"""Check `geom` for overlapping atoms. Return flattened"""""". npgeom = np.array(geom, copy=copy, dtype=float).reshape((-1, 3)). # Upper triangular; metric = tooclose ** 2; tooclose_inds = []; for x in range(npgeom.shape[0]):; diffs = npgeom[x] - npgeom[x + 1 :]; dists = np.einsum(""ij,ij->i"", diffs, diffs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:16901,Validat,ValidationError,16901,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"eturn f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Møller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""current dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""MP2 dipole"", mp.dipole_moment(2)); adc_wfn.set_variable(""current dipole"", mp.dipole_moment(2)); lines += [""""]; core.print_out(""\n"".join(lines) + ""\n""). gauge = core.get_option(""ADC"", ""GAUGE"").lower(); if gauge == ""velocity"":; gauge_short = ""VEL""; elif gauge == ""length"":; gauge_short = ""LEN""; else:; raise ValidationError(f""Gauge {gauge} not recognised for ADC calculations.""). computed = []; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; props = {}; if any(prop in properties for prop in (""TRANSITION_DIPOLE"", ""OSCILLATOR_STRENGTH"")):; data = excitation.transition_dipole_moment; props[""Transition dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) ""; ""ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"", data_mat); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) ""; ""ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"", data_mat); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ELECTRIC TRANSITION DIPOLE MOMENT (LEN)"", data_mat); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} ""; ""ELECTRIC TRANSITION DIPOLE MOMENT (LEN) - A TRANSITION"", data_mat). if ""OSCILLATOR_STRENGTH"" in pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:122395,Validat,ValidationError,122395,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['Validat'],['ValidationError']
Security,"eturn f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Møller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""current dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""MP2 dipole"", mp.dipole_moment(2)); adc_wfn.set_variable(""current dipole"", mp.dipole_moment(2)); lines += [""""]; core.print_out(""\n"".join(lines) + ""\n""). gauge = core.get_option(""ADC"", ""GAUGE"").lower(); if gauge == ""velocity"":; gauge_short = ""VEL""; elif gauge == ""length"":; gauge_short = ""LEN""; else:; raise ValidationError(f""Gauge {gauge} not recognised for ADC calculations.""). computed = {}; if any(prop in properties for prop in (""TRANSITION_DIPOLE"", ""OSCILLATOR_STRENGTH"")):; data = state.transition_dipole_moment; computed[""Transition dipole moment (in a.u.)""] = data; adc_wfn.set_variable(f""{name} transition dipoles"", core.Matrix.from_array(data)). if ""OSCILLATOR_STRENGTH"" in properties:; if gauge == ""velocity"":; data = state.oscillator_strength_velocity.reshape(-1, 1); else:; data = state.oscillator_strength.reshape(-1, 1); computed[f""Oscillator strength ({gauge} gauge)""] = data; adc_wfn.set_variable(f""{name} oscillator strengths ({gauge_short})"",; core.Matrix.from_array(data)). if ""ROTATIONAL_STRENGTH"" in properties:; data = state.rotatory_strength.reshape(-1, 1); computed[""Rotational strength (velocity gauge)""] = data; adc_wfn.set_variable(f""{name} rotational strengths (VEL)"",; core.Matrix.from_array(data)). if ""DIPOLE"" in properties:; data = state.state_dipole_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:119621,Validat,ValidationError,119621,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"eturns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH`. """"""; # Validate arguments; if self is None:; self = psi4.get_active_molecule(). dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:8536,Validat,ValidationError,8536,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"eturns:(Matrix, Wavefunction) – Hessian and wavefunction when return_wfn specified. Examples:. 1; 2>>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). 1; 2; 3; 4; 5; 6>>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). It’s handy to collect the wavefunction after a frequency; calculation through e, wfn = psi4.frequency(...,; return_wfn=True) as the frequencies can be accessed through; psi4.core.Wavefunction.frequencies(), the Hessian through; psi4.core.Wavefunction.hessian(), and much other computation; info through psi4.core.Wavefunction.frequency_analysis; (note no parentheses). Examples of using this data; structure can be found fd-freq-gradient and; python/vibanalysis. Formatted printing of vibrational; results is available through qcdb.vib.print_vibs(). Results accessible through psi4.core.Wavefunction.frequency_analysis¶. key; description (lbl & comment); units; data (real/imaginary modes). omega; frequency; cm^-1; nd.array(ndof) complex (real/imag). q; normal mode, normalized mass-weighted; a0 u^1/2; ndarray(ndof, ndof) float. w; normal mode, un-mass-weighted; a0; ndarray(ndof, ndof) float. x; normal mode, normalized un-mass-weighted; a0; ndarray(ndof, ndof) float. degeneracy; degree of degeneracy;  ; ndarray(ndof) int. TRV; translation/rotation/vibration;  ; ndarray(ndof) str ‘TR’ or ‘V’ or ‘-‘ for partial. gamma; irreducible representation;  ; ndarray(ndof) str irrep or None if unclassifiable. mu; reduced mass; u; ndarray(ndof) float (+/+). k; force constant; mDyne/A; ndarray(ndof) float (+/-). DQ0; RMS deviation v=0; a0 u^1/2; ndarray(ndof) float (+/0). Qtp0; Turning point v=0; a0 u^1/2; ndarray(ndof) float (+/0). Xtp0; Turning point v=0; a0; ndarray(ndof) float (+/0). theta_vib; char temp; K; ndarray(ndof) float (+/0). Visualization of Normal M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/freq-1.html:5308,access,accessible,5308,psi4manual/1.2.1/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/freq-1.html,2,['access'],['accessible']
Security,"ew core.Matrix; dim1 : list, tuple, or core.Dimension (optional); If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 :; Same as dim1 only if using a Psi4.Dimension object. Returns; -------; matrix : :py:class:`~psi4.core.Matrix` or :py:class:`~psi4.core.Vector`; Returns the given Psi4 object. Notes; -----; This is a generalized function to convert a NumPy array to a Psi4 object. Examples; --------. >>> data = np.random.rand(20); >>> vector = array_to_matrix(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4); """""". # What type is it? MRO can help.; arr_type = self.__mro__[0]. # Irreped case; if isinstance(arr, (list, tuple)):; if (dim1 is not None) or (dim2 is not None):; raise ValidationError(""Array_to_Matrix: If passed input is list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == core.Matrix:; sdim1 = core.Dimension(irreps); sdim2 = core.Dimension(irreps). for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError (""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:4004,Validat,ValidationError,4004,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"ewidth=5, color='k'); axt.axvline(x=8.75, linewidth=5, color='k'); axt.axvline(x=11.6, linewidth=5, color='k'); axt.axhline(y=4.8, linewidth=5, color='k'); axt.axhline(y=8.75, linewidth=5, color='k'); axt.axhline(y=11.6, linewidth=5, color='k'); axt.set_zorder(100). # save and show; pltuid = title + '_' + hashlib.sha1(title + str(xlimit)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='iowa_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); #plt.savefig(savefile, transparent=False, format=ext, bbox_inches='tight') # for quick nolabel, whiteback; files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. [docs]def liliowa(mcdat, title='', xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Saves a plot with a heatmap representation of *mcdat*. """"""; import numpy as np; import hashlib; import matplotlib; import matplotlib.pyplot as plt. # handle for frame, overall axis; fig, axt = plt.subplots(figsize=(1, 1)). axt.set_xticks([]); axt.set_yticks([]); axt.invert_yaxis(); axt.xaxis.set_tick_params(width=0, length=0); axt.yaxis.set_tick_params(width=0, length=0); axt.set_aspect('equal'). # remove figure outline; axt.spines['top'].set_visible(False); axt.spines['right'].set_visible(False); axt.spines['bottom'].set_visible(False); axt.spines['left'].set_visible(False). tiles = mcdat; dim = int(np.ceil(np.sqrt(len(tiles)))); pad = dim * dim - len(tiles); tiles += [0] * pad; cb = np.reshape(np.array(tiles), (dim, dim)). heatmap = axt.pcolor(cb, vmin=-xlimit, vmax=xlimit, cmap=plt.cm.PRGn). # save and show; pltuid = title + '_' + hashlib.sha1(title + str(xlimit)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='liliowa_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:33532,hash,hashlib,33532,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['hash'],['hashlib']
Security,"exceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if p4util.yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:9644,Validat,ValidationError,9644,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,7,['Validat'],['ValidationError']
Security,"exceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:9727,Validat,ValidationError,9727,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs['properties']. for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(""""""CC property name %s not recognized"""""" % name.upper()). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:73004,Validat,ValidationError,73004,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs['properties']. for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); psi4.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); psi4.set_global_option('WFN', this_name); else:; raise ValidationError(""""""CC property name %s not recognized"""""" % name.upper()). # Need cchbar for everything; psi4.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; psi4.set_global_option('WFN', 'EOM_CCSD'); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cceom(ccwfn); elif name == 'eom-cc2':; psi4.set_global_option('WFN', 'EOM_CC2'); psi4.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:60346,Validat,ValidationError,60346,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"ey'; elif saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = rxncolor; elif argcolor == 'sapt':; # sapt color from rxn if available; if saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = 'grey'; elif argcolor == 'rgb':; # HB/MX/DD sapt color from rxn if available; if saptcolor is not None:; if saptcolor < 0.333:; clr = 'blue'; elif saptcolor < 0.667:; clr = 'green'; else:; clr = 'red'; else:; clr = 'grey'; else:; # color argument is name of mpl color; clr = argcolor. return clr. [docs]def bars(data, title='', saveas=None, relpath=False, graphicsformat=['pdf'], view=True):; """"""Generates a 'gray-bars' diagram between model chemistries with error; statistics in list *data*, which is supplied as part of the dictionary; for each participating bar/modelchem, along with *mc* keys in argument; *data*. The plot is labeled with *title* and each bar with *mc* key and; plotted at a fixed scale to facilitate comparison across projects. """"""; import hashlib; import matplotlib.pyplot as plt. # initialize plot, fix dimensions for consistent Illustrator import; fig, ax = plt.subplots(figsize=(12, 7)); plt.ylim([0, 4.86]); plt.xlim([0, 6]); plt.xticks([]). # label plot and tiers; ax.text(0.4, 4.6, title,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=12). widths = [0.15, 0.02, 0.02, 0.02] # TT, HB, MX, DD; xval = 0.1 # starting posn along x-axis. # plot bar sets; for bar in data:; if bar is not None:; lefts = [xval, xval + 0.025, xval + 0.065, xval + 0.105]. rect = ax.bar(lefts, bar['data'], widths, linewidth=0); rect[0].set_color('grey'); rect[1].set_color('red'); rect[2].set_color('green'); rect[3].set_color('blue'). ax.text(xval + .08, 4.3, bar['mc'],; verticalalignment='center', horizontalalignment='right', rotation='vertical',; family='Times New Roman', fontsize=8); xval += 0.20. # save and show; pltuid = title + '_' + hashlib.sha1(title + repr([bar['mc'] for bar in data if ba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:2834,hash,hashlib,2834,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['hash'],['hashlib']
Security,"eys():; text += """"""{}"""""".format('_' * 44 if ul else ' ' * 44); ul = not ul; text += '\n'. for ss in self.sset.keys():; text += """""" => %s <=\n"""""" % (ss); for mc in modelchem:; perr = errors[mc][ss]; text += """"""%20s %44s"""""" % (mid[modelchem.index(mc)],; format_errors(perr[self.dbse])); for db in self.dbdict.keys():; text += """"""%44s"""""" % ('' if perr[db] is None else format_errors(perr[db])); text += '\n'; print(text). [docs] def plot_bars(self, modelchem, benchmark='default', sset=['default', 'hb', 'mx', 'dd'],; failoninc=True, verbose=False, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Prepares 'grey bars' diagram for each model chemistry in array; *modelchem* versus *benchmark* over all component databases. A wide bar; is plotted with three smaller bars, corresponding to the 'mae'; summary statistic of the four subsets in *sset*. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares bars diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>> asdf.plot_bars(['MP2-CP-adz', 'MP2-CP-adtz'], sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']); """"""; # compute errors; errors = {}; for mc in modelchem:; if mc is not None:; errors[mc] = {}; for ss in sset:; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # repackage; pre, suf, mid = string_contrast(modelchem); dbdat = []; for mc in modelchem:; if mc is None:; dbdat.append(None); else:; dbdat.append({'mc': mid[modelchem.index(mc)],; 'data': [errors[mc][ss][self.dbse]['mae'] for ss in sset]}); title = self.dbse + ' ' + pre + '[]' +",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:59928,access,accessible,59928,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['access'],['accessible']
Security,"ez, uniq : numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray; (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost. Usage; -----; geom, mass, elem, elez, uniq = molinstance.to_arrays(). """"""; self.update_geometry(). if dummy:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.geometry()); mass = np.asarray([self.mass(at) for at in range(self.natom())]); elem = np.asarray([self.symbol(at) for at in range(self.natom())]); elez = np.asarray([self.Z(at) for at in range(self.natom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest() for at in range(self.natom()); ]). return geom, mass, elem, elez, uniq. @staticmethod; def from_string(molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = qcel.molparse.from_string(; molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html:35943,hash,hashlib,35943,psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,7,['hash'],['hashlib']
Security,"e¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val)¶; Sets scalar or array QCVariable key to val on self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float]) – Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError – If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction) – Wavefunction or inherited class instance.; filename (Optional[str]) – An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key)¶; Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:24604,Validat,ValidationError,24604,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,1,['Validat'],['ValidationError']
Security,"f SAD basis sets; if (core.get_option(""SCF"", ""GUESS"") in [""SAD"", ""SADNO"", ""HUCKEL""]):; sad_basis_list = core.BasisSet.build(wfn.molecule(), ""ORBITAL"",; core.get_global_option(""BASIS""),; puream=wfn.basisset().has_puream(),; return_atomlist=True); wfn.set_sad_basissets(sad_basis_list). if (""DF"" in core.get_option(""SCF"", ""SAD_SCF_TYPE"")):; # We need to force this to spherical regardless of any user or other demands.; optstash = p4util.OptionsState(['PUREAM']); core.set_global_option('PUREAM', True); sad_fitting_list = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SAD"",; core.get_option(""SCF"", ""DF_BASIS_SAD""),; puream=True,; return_atomlist=True); wfn.set_sad_fitting_basissets(sad_fitting_list); optstash.restore(). if hasattr(core, ""EXTERN"") and 'external_potentials' in kwargs: ; core.print_out(""\n Warning! Both an external potential EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:35816,Validat,ValidationError,35816,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"f __init__(self, max_vec: int = 6, removal_policy: str = ""OLDEST""):; self.error = []; self.state = []; self.max_vec = max_vec; self.removal_policy = removal_policy.upper(). if self.removal_policy not in [""LARGEST"", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs] def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs] def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del self.error[pos]; diis_count -= 1. # Build error matrix B; B = np.empty((diis_count + 1, diis_count + 1)); B[-1, :] = 1; B[:, -1] = 1; B[-1, -1] = 0; for num1, e1 in enumerate(self.error):; B[num1, num1] = e1.vector_dot(e1); for num2, e2 in enumerate(self.error):; if num2 >= num1:; continue; val = e1.vector_dot(e2); B[num1, num2] = B[num2, num1] = val. # Build residual vector; resid = np.zeros(diis_count + 1); resid[-1] = 1. # Solve pulay equations. # Yea, yea this is unstable make it stable; iszero = np.any(np.diag(B)[:-1] <= 0.0); if iszero:; S = np.ones((diis_count + 1)); else:; S = np.diag(B).copy(); S[:-1] **= -0.5; S[-1] = 1. # Then we gotta do a custom inverse; B *= S[:, None] * S; invB = core.Matrix.from_array(B); invB.power(-1.0, 1.e-12). ci =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:7360,Validat,ValidationError,7360,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,1,['Validat'],['ValidationError']
Security,"f a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_option('SCF', 'SCF_TYPE'), ref_wfn). return core.adc(ref_wfn). def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_local_option('SCF', 'SCF_TYPE', 'DF'). core.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = core.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). scf_wfn = run_scf(name, **kwargs); returnvalue = core.get_variable('CURRENT ENERGY'). for ssuper in dft_functional.superfunctional_list:; if ssuper.name().lower() == name:; dfun = ssuper. if dfun.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if dfun.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfun.c_alpha() * core.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = dfun.c_alpha() * core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:83506,Validat,ValidationError,83506,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"f all roots were converged; """""". def __init__(self, iteration, wfn, what, stats):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nCSXException: %s\n\n' % msg. [docs]class MissingMethodError(ValidationError):; """"""Error called when method not available. """""". def __init__(self, msg):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; modulemsg = ""not available""; else:; modulemsg = f""not directable to QC_MODULE '{circs[5]}'"". if len(circs) == 7:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}', FREEZE_CORE '{not circs[6]}', and REFERENCE '{circs[4]}' {modulemsg}""""""; else:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}' and REFERENCE '{circs[4]}' {modulemsg}""""""; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class Dftd3Error(PsiException):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; module(s) from Psi4Pasture, but could not be imported.; """"""; msg_tmpl = """"""Psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:6288,Validat,ValidationError,6288,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,3,['Validat'],['ValidationError']
Security,"f and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); try:; database = __import__(db_name); except ImportError:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_option('BASIS'); user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); user_df_basi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:29422,Validat,ValidationError,29422,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"f dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def _to_array(matrix, copy=True, dense=False):; """"""; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters; ----------; matrix : :py:class:`~psi4.core.Matrix` or :py:class:`~psi4.core.Vector`; Pointers to which Psi4 core class should be used in the construction.; copy : bool, optional; Copy the data if `True`, return a view otherwise; dense : bool, optional; Converts irreped Psi4 objects to diagonally blocked dense arrays if `True`. Returns a list of arrays otherwise. Returns; -------; array : ndarray or list of ndarray; Returns either a list of np.array's or the base array depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html:5301,Validat,ValidationError,5301,psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,2,['Validat'],['ValidationError']
Security,"f dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def _to_array(matrix: Union[core.Matrix, core.Vector], copy: bool = True, dense: bool = False) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irreped Psi4 objects to diagonally blocked dense arrays if `True`. Returns a list of arrays otherwise. Returns; -------; numpy.ndarray; Returns either a list of np.array's or the base array depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:5414,Validat,ValidationError,5414,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,3,['Validat'],['ValidationError']
Security,"f do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:76652,Validat,ValidationError,76652,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"f lowername in procedures['energy']:; dertype = 0; func = energy. if (PsiMod.get_global_option('REFERENCE').lower() == 'rks') or (PsiMod.get_global_option('REFERENCE').lower() == 'uks'):; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if input.der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif input.der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:21822,validat,validation,21822,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,"['Validat', 'validat']","['ValidationError', 'validation']"
Security,"f model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if mcset == 'default':; lsslist = self.data.keys(); elif callable(mcset):; # mcset is function that will generate subset of HRXN from sset(self); lsslist = [mc for mc in self.data.keys() if mc in mcset(self)] # untested; else:; # mcset is array containing modelchemistries; lsslist = [mc for mc in self.data.keys() if mc in mcset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for mc in lsslist:; lsset[mc] = self.data[mc]. lbench = self.benchmark if benchmark == 'default' else benchmark; try:; mcGreater = self.data[lbench].value; except KeyError as e:; raise ValidationError(""""""Reaction %s missing benchmark datum %s."""""" % (self.name, str(e))). err = {}; for label, datum in lsset.iteritems():; try:; mcLesser = datum.value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (label, str(e))); else:; continue. err[label] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater)] # TODO define BER; if verbose:; print(""""""p = %6.2f, pe = %6.1f%%, bpe = %6.1f%% modelchem %s."""""" %; (err[label][0], 100 * err[label][1], 100 * err[label][2], label)). return err. [docs] def plot(self, benchmark='default', mcset='default',; failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors over model chemistries in *mcset* (which; may be default or an array or a function generating an array) versus; *benchmark*. Thread *color* can be 'rgb' for old coloring, a color; name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. Fi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:16927,Validat,ValidationError,16927,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"f name == 'mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'conv-omp2']:; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'lccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); else:; raise ValidationError(""""""Invalid method %s"""""" % name). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'DO_SCS', 'FALSE'); core.set_local_option('OCC', 'DO_SOS', 'FALSE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:59309,Validat,ValidationError,59309,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"f name == 'mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'conv-omp2']:; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'lccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); else:; raise ValidationError(""""""Invalid method %s"""""" % name). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'DO_SCS', 'FALSE'); core.set_local_option('OCC', 'DO_SOS', 'FALSE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_option('SCF', 'SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. """""". op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:57427,Validat,ValidationError,57427,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"f name == 'mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'conv-omp2']:; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'lccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); else:; raise ValidationError(""""""Invalid method %s"""""" % name). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:73845,Validat,ValidationError,73845,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"f name == 'mp2':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'conv-omp2']:; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp2.5':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp3':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp3':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'lccd':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'olccd':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'); else:; raise ValidationError(""""""Invalid method %s"""""" % name). psi4.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; psi4.set_local_option('OCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('OCC', 'DO_SOS', 'FALSE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = psi4.occ(ref_wfn). derivobj = psi4.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad). optstash.restore(); return occ_wfn. [docs]def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:47786,Validat,ValidationError,47786,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"f number >= self.natom():; raise ValidationError(""Molecule::set_shell_by_number: Basis specified for atom %d, but there are only %d atoms in this molecule."" % \; (number, self.natom())); self.atoms[number].set_shell(bshash, role). [docs] def nfrozen_core(self, depth=False):; """"""Number of frozen core for molecule given freezing state. >>> print H2OH2O.nfrozen_core(); 2. """"""; if depth == False or depth.upper() == 'FALSE':; return 0. elif depth == True or depth.upper() == 'TRUE':; # Freeze the number of core electrons corresponding to the; # nearest previous noble gas atom. This means that the 4p block; # will still have 3d electrons active. Alkali earth atoms will; # have one valence electron in this scheme.; nfzc = 0; for A in range(self.natom()):; if self.Z(A) > 2:; nfzc += 1; if self.Z(A) > 10:; nfzc += 4; if self.Z(A) > 18:; nfzc += 4; if self.Z(A) > 36:; nfzc += 9; if self.Z(A) > 54:; nfzc += 9; if self.Z(A) > 86:; nfzc += 16; if self.Z(A) > 108:; raise ValidationError(""Molecule::nfrozen_core: Invalid atomic number""); return nfzc. else:; raise ValidationError(""Molecule::nfrozen_core: Frozen core '%s' is not supported, options are {true, false}."" % (depth)). # <<< Involved Methods for Frame >>>. [docs] def translate(self, r):; """"""Translates molecule by r. >>> H2OH2O.translate([1.0, 1.0, 0.0]). """"""; temp = [None, None, None]; for at in range(self.nallatom()):; temp = scale(self.full_atoms[at].compute(), self.input_units_to_au); temp = add(temp, r); temp = scale(temp, 1.0 / self.input_units_to_au); self.full_atoms[at].set_coordinates(temp[0], temp[1], temp[2]). [docs] def center_of_mass(self):; """"""Computes center of mass of molecule (does not translate molecule). >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_m = 0.0. for at in range(self.natom()):; m = self.mass(at); ret = add(ret, scale(self.xyz(at), m)); total_m += m. ret = scale(ret, 1.0 / total_m); return ret. [docs] def move_to_com(self):; """"""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:53349,Validat,ValidationError,53349,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"f p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(""""""Stability analysis root following is only available for UHF""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:32797,Validat,ValidationError,32797,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"f p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:43138,Validat,ValidationError,43138,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"f path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise ValidationError(; ""Reactions pickle file for loading database data from file %s does not exist"" % (pklfile)). with open(pklfile, 'rb') as handle:; hrxns = pickle.load(handle); # no error checking for speed; for rxn, data in hrxns.iteritems():; self.hrxn[rxn].data.update(data). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; hdf5file = os.path.abspath(path) + os.sep + self.dbse + '_' + project + '.h5'; if not os.path.isfile(hdf5file):; raise ValidationError(""HDF5 file for loading database data from file %s does not exist"" % (hdf5file)); try:; import pandas as pd; except ImportError:; raise ValidationError(""Pandas data managment module must be available for import""). try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; intrxn = False; else:; intrxn = True. with pd.get_store(hdf5file) as handle:; for mc in handle['pdie'].keys():; lmc = mc.split('-') # TODO could be done better; method = lmc[0]; bsse = '_'.join(lmc[1:-1]); basis = lmc[-1]. df = handle['pdie'][mc]; for dbrxn in df.index[df.notnull()].values:; [dbse, rxn] = dbrxn.split('-', 1); if intrxn:; rxn = int(rxn); self.hrxn[rxn].data[mc] = ReactionDatum.library_modelchem(dbse=dbse, rxn=rxn,; method=method, mode=bsse, basis=basis,; value=df[dbrxn]). [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; return False; else:; return True. @staticmethod; [docs] def load_pickled(dbname, path=None):; """""". """"""; if path is None:; path = os.path.dirname(__file__",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:39918,Validat,ValidationError,39918,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,2,['Validat'],['ValidationError']
Security,"f set_basis_all_atoms(self, name, role=""BASIS""):; """"""Assigns basis *name* to all atoms.""""""; uc = name.upper(); if uc in ['SPECIAL', 'GENERAL', 'CUSTOM']:; # These aren't really basis set specifications, just return.; return; for atom in self.full_atoms:; atom.set_basisset(name, role). [docs] def set_basis_by_symbol(self, symbol, name, role=""BASIS""):; """"""Assigns basis *name* to all *symbol* atoms.""""""; for atom in self.full_atoms:; if symbol.upper() == atom.symbol():; atom.set_basisset(name, role). [docs] def clear_basis_all_atoms(self):; """"""Remove all basis information from atoms.""""""; for atom in self.full_atoms:; atom.PYbasissets = OrderedDict(). [docs] def set_basis_by_number(self, number, name, role=""BASIS""):; """"""Assigns basis *name* to atom number *number* (0-indexed, excludes dummies).""""""; # change from libmints to 0-indexing and to real/ghost numbering, dummies not included (libmints >= error); if number >= self.natom():; raise ValidationError(""Molecule::set_basis_by_number: Basis specified for atom %d, but there are only %d atoms in this molecule."" % \; (number, self.natom())); self.atoms[number].set_basisset(name, role). [docs] def set_basis_by_label(self, label, name, role=""BASIS""):; """"""Assigns basis *name* to all atoms with *label*.""""""; for atom in self.full_atoms:; if label.upper() == atom.label():; atom.set_basisset(name, role). [docs] def set_shell_by_number(self, number, bshash, role=""BASIS""):; """"""Assigns BasisSet *bshash* to atom number *number* (0-indexed, excludes dummies).""""""; self.lock_frame = False; if number >= self.natom():; raise ValidationError(""Molecule::set_shell_by_number: Basis specified for atom %d, but there are only %d atoms in this molecule."" % \; (number, self.natom())); self.atoms[number].set_shell(bshash, role). [docs] def nfrozen_core(self, depth=False):; """"""Number of frozen core for molecule given freezing state. >>> print H2OH2O.nfrozen_core(); 2. """"""; if depth == False or depth.upper() == 'FALSE':; return 0. elif depth == True o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:51780,Validat,ValidationError,51780,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"f user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()); # exec(commands); #; # psioh.set_specific_retention(psif.PSIF_SCF_MOS, False). def _expand_scheme_orders(scheme: str, basisname: List[str], basiszeta: List[int], wfnname: str, options: Dict) -> Dict[str, Dict[str, Any]]:; """"""Check that the length of *basiszeta* array matches the implied degree of; extrapolation in *scheme* name. Return a dictionary of same length as; basiszeta, with *basisname* and *basiszeta* distributed therein. """"""; Nxtpl = len(basiszeta). try:; scheme.split(); except AttributeError:; raise UpgradeHelper(scheme, repr(scheme.__name__), 1.6, ' Replace extrapolation function with function name.'). if scheme not in xtpl_procedures:; raise ValidationError(f""Extrapolation function ({scheme}) not among registered extrapolation schemes: {list(xtpl_procedures.keys())}. Use 'register_xtpl_function' function.""). if int(scheme.split(""_"")[-1]) != Nxtpl:; raise ValidationError(f""""""Call to '{scheme}' not valid with '{len(basiszeta)}' basis sets.""""""). NEED = {}; for idx in range(Nxtpl):; NEED[_lmh_labels[Nxtpl][idx]] = dict(; zip(_f_fields, [wfnname, basisname[idx], basiszeta[idx], options, 0.0, None, None, None, None])); return NEED. def _contract_scheme_orders(needdict, datakey: str = 'f_energy') -> Dict[str, Any]:; """"""Prepared named arguments for extrapolation functions by; extracting zetas and values (which one determined by *datakey*) out; of *needdict* and returning a dictionary whose keys are constructed; from _lmh_labels. """"""; largs = {}; largs['functionname'] = needdict['HI']['f_wfn']; Nxtpl = len(needdict); zlabels = _lmh_labels[Nxtpl] # e.g., ['LO', 'HI']. for zeta in range(Nxtpl):; zlab = zlabels[zeta] # e.g., LO; largs['z' + zlab] = needdict[zlab]['f_zeta']; largs['value' + zlab] = needdict[zlab][datakey]. return largs. def _parse_cbs_gufunc_string(method_name: str):; """""" A helper function that parses a ``""method/basis""`` input string; into separate method ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:37261,Validat,ValidationError,37261,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,5,['Validat'],['ValidationError']
Security,"f val['has_changed']:; if not text:; text += """"""$rem\n""""""; text += """"""%-20s %s\n"""""" % (opt[6:], val['value']); #text += """"""%s=%s\n"""""" % (format_option_for_cfour(opt, val['value'])); if text:; text += """"""$end\n\n"""""". return text. [docs]def reconcile_options(full, partial):; """"""Function to take the full snapshot of the liboptions object; encoded in dictionary *full* and reconcile it with proposed options; value changes in *partial*. Overwrites *full* with *partial* if; option untouched, touches *full* if *full* and *partial* are in; agreement, balks if *full* and *partial* conflict. Returns *full*. """"""; try:; for module, modopts in partial.items():; for kw, kwprop in modopts.items():; if full[module][kw]['has_changed']:; if full[module][kw]['value'] != kwprop['value']:; if 'clobber' in kwprop and kwprop['clobber']:; if 'superclobber' in kwprop and kwprop['superclobber']:; # kw in full is touched, conflicts with value in partial,; # but value in partial is paramount, overwrite full with; # value in partial; full[module][kw]['value'] = kwprop['value']; full[module][kw]['has_changed'] = True; #print '@P4C4 Overwriting %s with %s' % (kw, kwprop['value']); else:; raise ValidationError(""""""; Option %s value `%s` set by options block incompatible with; value `%s` in memory/molecule/command/psi4options block."""""" %; (kw, full[module][kw]['value'], kwprop['value'])); else:; # kw in full is touched, conflicts with value in partial,; # but value in partial is recommended, not required, no change; pass; else:; # kw in full is touched, but in agreement with value in partial, no change; pass; else:; # If kw in full is untouched, overwrite it with value in partial; full[module][kw]['value'] = kwprop['value']; full[module][kw]['has_changed'] = True; #print '@P4C4 Overwriting %s with %s' % (kw, kwprop['value']). except KeyError as e: # not expected but want to trap; raise ValidationError(""""""Unexpected KeyError reconciling keywords: %s."""""" % (repr(e))). return full. [docs]def reconcile_op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/options.html:5640,Validat,ValidationError,5640,psi4manual/1.0.0/_modules/qcdb/options.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/options.html,1,['Validat'],['ValidationError']
Security,"f"": ""cc-pvtz-jkfit"",; ""scf__reference"": ""uhf"",; ""print"": 2}). """"""; optionre = re.compile(r'\A(?P<module>\w+__)?(?P<option>\w+)\Z', re.IGNORECASE); rejected = {}. for k, v, in options_dict.items():. mobj = optionre.match(k.strip()); module = mobj.group('module').upper()[:-2] if mobj.group('module') else None; option = mobj.group('option').upper(). if module:; if ((module, option, v) not in [('SCF', 'GUESS', 'READ')]) and ((module, option) not in [('PCM', 'INPUT')]):; # TODO guess/read exception is for distributed driver. should be handled differently.; try:; core.set_local_option(module, option, v); except RuntimeError as err:; rejected[k] = (v, err); if verbose > 1:; print('Setting: core.set_local_option', module, option, v). if (module, option) == (""PCM"", ""INPUT""):; pcm_helper(v). else:; try:; core.set_global_option(option, v); except RuntimeError as err:; rejected[k] = (v, err); if verbose > 1:; print('Setting: core.set_global_option', option, v). if rejected:; raise ValidationError(f'Error setting options: {rejected}'). # TODO could subclass ValidationError and append rejected so that run_json could handle remanants. [docs]; def set_module_options(module: str, options_dict: Dict[str, Any]) -> None:; """"""; Sets Psi4 module options from a module specification and input dictionary. .. deprecated:: 1.5; Use :py:func:`psi4.driver.p4util.set_options` instead. """"""; warnings.warn(; ""Using `psi4.set_module_options(<module>, {<key>: <val>})` instead of `psi4.set_options({<module>__<key>: <val>})` is deprecated, and as soon as 1.5 it will stop working\n"",; category=FutureWarning,; stacklevel=2). for k, v, in options_dict.items():; core.set_local_option(module.upper(), k.upper(), v). ## OEProp helpers. [docs]; def pcm_helper(block: str):; """"""Helper to specify the multiline PCMSolver syntax for PCM.; Prefer to use :py:func:`set_options` with key ``""PCM__INPUT""``. Parameters; ----------; block; Text that goes in a PSIthon ``pcm = {...}`` block. """"""; import pcmsolver. # delete=Tr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:17751,Validat,ValidationError,17751,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,3,['Validat'],['ValidationError']
Security,"f"": [; {; ""$ref"": ""#/definitions/DriverEnum""; }; ]; },; ""keywords"": {; ""title"": ""Keywords"",; ""description"": ""The keywords to use in the computation."",; ""type"": ""object""; },; ""computed"": {; ""title"": ""Computed"",; ""description"": ""Whether quantum chemistry has been run on this task."",; ""default"": false,; ""type"": ""boolean""; },; ""result"": {; ""title"": ""Result"",; ""description"": "":py:class:`~qcelemental.models.AtomicResult` return.""; },; ""result_id"": {; ""title"": ""Result Id"",; ""description"": ""The optional ID for the computation."",; ""type"": ""string""; }; },; ""required"": [; ""molecule"",; ""basis"",; ""method"",; ""driver""; ]; }; }; }. Fields:. basis (str); cbsrec (List[Dict[str, Any]]); compute_list (List[Dict[str, Any]]); driver (qcelemental.models.common_models.DriverEnum); keywords (Dict[str, Any]); metadata (Any); metameta (Dict[str, Any]); method (str); molecule (Any); results_list (List[Any]); task_list (List[psi4.driver.task_base.AtomicComputer]); trove (List[Dict[str, Any]]); verbose (int). Validators:. set_molecule » molecule. field basis: str = '(auto)'¶. field cbsrec: List[Dict[str, Any]] = []¶. field compute_list: List[Dict[str, Any]] = []¶. field driver: DriverEnum [Required]¶. field keywords: Dict[str, Any] = {}¶. field metadata: Any = None¶. field metameta: Dict[str, Any] = {}¶. field method: str = '(auto)'¶. field molecule: Any = None¶. Validated by:. set_molecule. field results_list: List[Any] = []¶. field task_list: List[AtomicComputer] = []¶. field trove: List[Dict[str, Any]] = []¶. field verbose: int = 1¶. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶. Parameters:; client (Optional[FractalClient]) – . get_psi_results(return_wfn=False)[source]¶; Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:; return_wfn (bool) – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cbs.html:36292,Validat,Validators,36292,psi4manual/1.7.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cbs.html,1,['Validat'],['Validators']
Security,"f' % (item[0], item[1], item[2])). # Clean up cfour scratch directory unless user instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:13066,Validat,ValidationError,13066,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,4,['Validat'],['ValidationError']
Security,"f-b3lyp-d'; #'df-b3lyp-d3'; #'df-wb97x-d'. [docs]def muster_cdsgroup_options():; text = ''; options = defaultdict(lambda: defaultdict(dict)); options['GLOBALS']['E_CONVERGENCE']['value'] = 8; options['SCF']['GUESS']['value'] = 'sad'; options['SCF']['MAXITER']['value'] = 200. return text, options. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; text += """"""energy('""""""; else:; raise ValidationError(""""""Requested Psi4 dertype %d is not available."""""" % (dertype)). if lowername == 'mp2':; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'direct'; options['MP2']['MP2_TYPE']['value'] = 'conv'; text += """"""mp2')\n\n"""""". elif lowername == 'df-mp2':; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'df'; options['MP2']['MP2_TYPE']['value'] = 'df'; text += """"""mp2')\n\n"""""". elif lowername == 'sapt0':; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'df'; text += """"""sapt0')\n\n"""""". elif lowername == 'sapt2+':; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'df'; options['SAPT']['NAT_ORBS_T2']['value'] = True; options['SAPT']['NAT_ORBS_T3']['value'] = True; options['SAPT']['NAT_ORBS_V4']['value'] = True; options['SAPT']['OCC_TOLERANCE']['value'] = 1.0e-6; text += """"""sapt2+')\n\n"""""". elif lowername == 'sapt2+(3)':; option",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html:6147,Validat,ValidationError,6147,psi4manual/1.0.0/_modules/qcdb/psi4.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html,1,['Validat'],['ValidationError']
Security,"f.__dict__. # def __setstate__(self, d):; # print 'im being unpickled with these values', d; # self.__dict__ = d. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzN = re.compile(r'(?:\s*)([A-Z](?:[a-z])?)(?:\s+)' +; NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s*)', re.IGNORECASE); xyzC = re.compile(r'(?:\s*)(\d+\.?\d*)(?:\s+)' +; NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s*)', re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:2995,Validat,ValidationError,2995,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"f.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:31759,Validat,ValidationError,31759,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,3,['Validat'],['ValidationError']
Security,"f.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:36955,Validat,ValidationError,36955,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"f: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; add string option. get_bool(self: psi4.core.Options, arg0: str) → bool¶; get boolean option. get_current_module(self: psi4.core.Options) → str¶; gets current module. get_double(self: psi4.core.Options, arg0: str) → float¶; get double option. get_int(self: psi4.core.Options, arg0: str) → int¶; get integer option. get_int_vector(self: psi4.core.Options, arg0: str) → List[int]¶; get int vector option. get_str(*args, **kwargs)¶; Overloaded function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. print_global_options(self: psi4.core.Options) → None¶; print the global, cross-module options. print_module_options(self: psi4.core.Options) → None¶; print global and local options prepared for current module. read_globals(self: psi4.core.Options) → bool¶; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str) → None¶; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool) → None¶; set bool option. set_current_module(self: psi4.core.Options, arg0: str) → None¶; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float) → None¶; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int) → None¶; set int option. set_read_globals(self: psi4.core.Options, arg0: bool) → None¶; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; Options. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Options.html:3466,validat,validate,3466,psi4manual/1.6.x/api/psi4.core.Options.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Options.html,1,['validat'],['validate']
Security,"f; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for FCHK files."""""". import re; from typing import Union. import numpy as np. from psi4 import core. from ..p4util.testing import compare_arrays, compare_integers, compare_strings, compare_values; from .exceptions import ValidationError. __all__ = [; ""compare_fchkfiles"",; ""compare_moldenfiles"",; ]. def _consume_fchk_section(input_list, index):; """"""compare a float or integer matrix section"""""". n = int(input_list[index].split()[-1]); kind = input_list[index].split()[-3]. if ""R"" in kind:; dtype = np.float64; format_counter = 5; elif ""I"" in kind:; dtype = np.float64; format_counter = 6; else:; raise ValidationError('Unknow field type in FCHK reader\n'). extra = 0 if n <= format_counter else n % format_counter; lines = 1 if n <= format_counter else int(n / format_counter); offset = lines + 1 if extra > 0 else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. def _fchkfile_to_string(fname: str) -> str:; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read(); return fchk_string. [docs]; def compare_fchkfiles(expected: str, computed: str, atol_exponent: Union[int, float], label: str):; """"""Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient. Note only Psi4-style signature (``(expected, c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/fchk.html:1741,Validat,ValidationError,1741,psi4manual/1.9.x/_modules/psi4/driver/p4util/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/fchk.html,2,['Validat'],['ValidationError']
Security,"f; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:24238,access,access,24238,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['access'],['access']
Security,"f_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if core.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['mp2.5', 'omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['mp3', 'omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); elif name in ['ccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); elif name in ['ccsd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); else:; raise ValidationError('Unidentified method %s' % (name)). if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccd', 'ccsd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_global_option('DERTYPE', 'FIRST'); core.s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:45901,Validat,ValidationError,45901,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"fault_path('/scratch/user'). to set up the scratch path,; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). to set up the scratch path from a variable $MYSCRATCH,; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). which is equivalent to; psi4_io.set_specific_path(PSIF_CHKPT, './'); psi4_io.set_specific_retention(PSIF_CHKPT, True). to set up a specific path for the checkpoint file and instruct Psi4 not to delete it.; The Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. As a consequence, the commands in the input files supersede; any instructions in the ~/.psi4rc file. During; excecution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed.; The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every Psi4 instance. Threading¶; Most new modules in Psi4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for Psi4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and Boost; Threads for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or other threaded BLAS. Less; than 20% of the threaded code in Psi4 uses OpenMP, the rest is handled by; parallel DGEMM and other library routines. From this point forward, it is; assumed that you have compiled Psi4 with OpenMP and MKL (Note that it is; possible to use g++ or another compiler and yet still link against MKL).; Control of threading in Psi4 can be accomplished at",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:6420,access,accessible,6420,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['access'],['accessible']
Security,"fault_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Convert wrapper directives from options (where ppl know to find them) to kwargs (suitable for non-globals transmitting); kwargs['findif_verbose'] = core.get_option(""FINDIF"", ""PRINT""); kwargs['findif_stencil_size'] = core.get_option(""FINDIF"", ""POINTS""); kwargs['findif_step_size'] = core.get_option(""FINDIF"", ""DISP_SIZE""). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name); _filter_renamed_methods(""gradient"", lowername). # * Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # * Prevent methods that do not have associated derivatives; if lowername in energy_only_methods:; raise ValidationError(f""`gradient('{name}')` does not have an associated gradient.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:36690,Validat,ValidationError,36690,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"ference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). return psi4.adc(ref_wfn). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). scf_wfn = run_scf(name, **kwargs); returnvalue = psi4.get_variable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name:; dfun = ssuper. if dfun.is_c_hybrid():; if dfun.is_c_scs_hybrid():; psi4.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); psi4.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); dfmp2_wfn = psi4.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfun.c_alpha() * psi4.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = psi4.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = dfun.c_alpha() * psi4.get_variable('MP2 CORRELATION ENERGY'). # TODO: delete these variables, since they don't mean what they look to mean?; # 'MP2 TOTAL ENERGY',; # 'MP2 CORRELATION ENERGY',; # 'MP2 SAME-SPIN CORRELATION ENERGY']. psi4.set_variable('DOUBLE-HYBRID ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:70673,Validat,ValidationError,70673,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"ff_supplement; self.save_pairwise_disp = save_pairwise_disp. resolved = qcng.programs.empirical_dispersion_resources.from_arrays(; name_hint=name_hint,; level_hint=level_hint,; param_tweaks=param_tweaks,; dashcoeff_supplement=self.dashcoeff_supplement); self.fctldash = resolved['fctldash']; self.dashlevel = resolved['dashlevel']; self.dashparams = resolved['dashparams']; self.description = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['description']; self.ordered_params = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['default'].keys(); self.dashlevel_citation = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['citation']; self.dashparams_citation = resolved['dashparams_citation']. capable_engines_for_disp = _capable_engines_for_disp(); if engine is None:; self.engine = capable_engines_for_disp[self.dashlevel][0]; else:; if self.dashlevel in _engine_can_do[engine]:; self.engine = engine; else:; raise ValidationError(f""This little engine ({engine}) can't ({self.dashlevel})""). if self.engine == 'libdisp':; self.disp = core.Dispersion.build(self.dashlevel, **resolved['dashparams']). if gcp_engine is None:; self.gcp_engine = capable_engines_for_disp[""3c""][0]; else:; if ""3c"" in _engine_can_do[gcp_engine]:; self.gcp_engine = gcp_engine; else:; raise ValidationError(f""This little engine ({engine}) can't (3c)""). [docs] def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:7520,Validat,ValidationError,7520,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['Validat'],['ValidationError']
Security,"ff_supplement; self.save_pairwise_disp = save_pairwise_disp. resolved = qcng.programs.empirical_dispersion_resources.from_arrays(; name_hint=name_hint,; level_hint=level_hint,; param_tweaks=param_tweaks,; dashcoeff_supplement=self.dashcoeff_supplement); self.fctldash = resolved['fctldash']; self.dashlevel = resolved['dashlevel']; self.dashparams = resolved['dashparams']; self.description = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['description']; self.ordered_params = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['default'].keys(); self.dashlevel_citation = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['citation']; self.dashparams_citation = resolved['dashparams_citation']. capable_engines_for_disp = _capable_engines_for_disp(); if engine is None:; self.engine = capable_engines_for_disp[self.dashlevel][0]; else:; if self.dashlevel in _engine_can_do[engine]:; self.engine = engine; else:; raise ValidationError(f""This little engine ({engine}) can't ({self.dashlevel})""). if self.engine == 'libdisp':; self.disp = core.Dispersion.build(self.dashlevel, **resolved['dashparams']). if gcp_engine is None:; self.gcp_engine = capable_engines_for_disp[""3c""][0]; else:; if ""3c"" in _engine_can_do[gcp_engine]:; self.gcp_engine = gcp_engine; else:; raise ValidationError(f""This little engine ({engine}) can't (3c)""). [docs]; def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs]; def ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:8029,Validat,ValidationError,8029,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,3,['Validat'],['ValidationError']
Security,"ffdiag_en(7) + E[i][0] - 7 * E[i][1] - 7 * E[i][2] +; E[i][3] + E[j][0] - 7 * E[j][1] - 7 * E[j][2] + E[j][3] +; 12 * ref_energy) / (12 * findifrec[""step""][""size""]**2); H_irr[i, j] = fc; H_irr[j, i] = fc. B_pi.append(data[""salc_list""].matrix_irrep(h)); H_pi.append(_process_hessian_symmetry_block(H_irr, B_pi[-1], massweighter, irrep_lbls[h], data[""print_lvl""])). # All blocks of the Hessian are now constructed!; return _process_hessian(H_pi, B_pi, massweighter, data[""print_lvl""]). [docs]class FiniteDifferenceComputer(BaseComputer):. molecule: Any; driver: DriverEnum; metameta: Dict[str, Any] = {}; task_list: Dict[str, BaseComputer] = {}; findifrec: Dict[str, Any] = {}; computer: BaseComputer = AtomicComputer; method: str. [docs] @validator('driver'); def set_driver(cls, driver):; egh = ['energy', 'gradient', 'hessian']; if driver not in egh:; raise ValidationError(f""""""Wrapper is unhappy to be calling function ({driver}) not among {egh}.""""""). return driver. [docs] @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; """"""Initialize FiniteDifference class. data keywords include; * general AtomicInput keys like molecule, driver, method, basis, and keywords.; * specialized findif keys like findif_mode, findif_irrep, and those converted from keywords to kwargs:; findif_stencil_size, findif_step_size, and findif_verbose.; * TODO hangers-on keys present at class initiation get automatically attached to class since `extra = ""allow""` but should be pruned. """"""; findif_stencil_size = data.pop('findif_stencil_size'); findif_step_size = data.pop('findif_step_size'). BaseComputer.__init__(self, **data). translations_projection_sound = (not ""external_potentials"" in data['keywords']['function_kwargs']; and not core.get_option('SCF', 'PERTURB_H'); and not hasattr(self.molecule, 'EFP')); if 'ref_gradient' in data:; logger.info(""""""hessian() using ref_gradient to assess stationary p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:40984,validat,validator,40984,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,1,['validat'],['validator']
Security,"fically. write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, …]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). SCFConvergenceError(eqn_description, …); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, …); Error called for problems with TDSCF iterations. Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn’t and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:22804,Validat,ValidationError,22804,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['Validat'],['ValidationError']
Security,"ficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scft",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:85312,Validat,ValidationError,85312,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,"fied_direction = True if user[-1] in ['X', 'x', 'Y', 'y', 'Z', 'z'] else False. if self.symmetry_from_input() != pg.symbol():; user = PointGroup(self.symmetry_from_input()). if user_specified_direction:; # Assume the user knows what they're doing.; # Make sure user is subgroup of pg; if (pg.bits() & user.bits()) != user.bits():; raise ValidationError(""Molecule::find_point_group: User specified point group (%s) is not a subgroup of the highest detected point group (%s)"" % (PointGroup.bits_to_full_name(user.bits()), PointGroup.bits_to_full_name(pg.bits()))). else:; similars, count = similar(user.bits()); found = False; for typ in range(count):; # If what the user specified and the similar type; # matches the full point group we've got a match; if (similars[typ] & pg.bits()) == similars[typ]:; found = True; break. if found:; # Construct a point group object using the found similar; user = PointGroup(similars[typ]). else:; raise ValidationError(""Molecule::find_point_group: User specified point group (%s) is not a subgroup of the highest detected point group (%s). If this is because the symmetry increased, try to start the calculation again from the last geometry, after checking any symmetry-dependent input, such as DOCC."" % (PointGroup.bits_to_full_name(user.bits()), PointGroup.bits_to_full_name(pg.bits()))). # If we make it here, what the user specified is good.; pg = user. return pg. [docs] def reset_point_group(self, pgname):; """"""Override symmetry from outside the molecule string""""""; self.PYsymmetry_from_input = pgname.lower(); self.set_point_group(self.find_point_group()). [docs] def find_highest_point_group(self, tol=DEFAULT_SYM_TOL):; """"""Find the highest D2h point group from Jet and Ed's code: c1; ci c2 cs d2 c2v c2h d2h. Ignore the user-specified subgroup in; this case. """"""; pg_bits = 0. # The order of the next 2 arrays MUST match!; symm_bit = [; SymmOps['C2_z'],; SymmOps['C2_y'],; SymmOps['C2_x'],; SymmOps['i'],; SymmOps['Sigma_xy'],; SymmOps['Sigma_xz'],; SymmO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:74453,Validat,ValidationError,74453,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"file; PsiMod.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; PsiMod.print_out('\nMRCC scratch files have been kept.\n'); PsiMod.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; PsiMod.print_out('\n'); banner('Full results from MRCC'); PsiMod.print_out('\n'); PsiMod.print_out(iface_contents). return e. [docs]def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> energy('df-ccsd(t)'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # stash user options; optstash = OptionsState(; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','DFCC'],; ['FNOCC','NAT_ORBS'],; ['FNOCC','RUN_CEPA'],; ['SCF','SCF_TYPE']). PsiMod.set_local_option('FNOCC', 'DFCC', True); PsiMod.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if (PsiMod.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""Error: %s requires \""reference rhf\""."" % lowername). # override symmetry:; molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(1); molecule.update_geometry(); if user_pg != 'c1':; PsiMod.print_out(' FNOCC does not make use of molecular symmetry, further calculations in C1 point group.\n'). # triples?; if (lowername == 'df-ccsd'):; PsiMod.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); if (lowername == 'df-ccsd(t)'):; PsiMod.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); if (lowername == 'fno-df-ccsd'):; PsiMod.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); if (lowername == 'fno-df-ccsd(t)'):; PsiMod.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True). # set scf-type to df unless the user wants something else; if PsiMod.has_option_changed('SCF','SCF_TYPE') == False:; P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:68547,Validat,ValidationError,68547,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"filename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(r'^(?:\s*)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER +; '(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)', re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.mat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:7995,Validat,ValidationError,7995,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). core.set_local_option('FNOCC', 'DFCC', True); core.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). def set_cholesky_from(mtd_type):; type_val = core.get_global_option(mtd_type); if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(""""""Invalid type '%s' for DFCC"""""" % type_val). # triples?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:118959,Validat,ValidationError,118959,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"fill in the list up to the highest atomic number included in any calculations. This option is only used if FREEZE_CORE is set to POLICY. Type: array; Default: No Default. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. INTEGRAL_PACKAGE¶. Integral package to use. If compiled with Simint support, change this option to use them; LibInt2 is used otherwise. Type: string; Possible Values: LIBINT2, SIMINT; Default: LIBINT2. LITERAL_CFOUR¶. Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through cfour {...} block. Type: string; Default: No Default. LS_THC_DF¶. Use DF approximation when computing LS-THC factorization?. Type: boolean; Default: true. LS_THC_RADIAL_POINTS¶. Number of radial points in LS-THC grid. Type: integer; Default: 10. LS_THC_SPHERICAL_POINTS¶. Number of spherical points in LS-THC grid. Type: integer; Default: 50. MAX_RADIAL_MOMENT¶. Maximum Radial Moment to Calculate. Type: integer; Default: 4. MBIS_D_CONVERGENCE¶. MBIS Convergence Criteria. Type: conv double; Default: 1.0e-8. MBIS_MAXITER¶. Maximum Number of MBIS Iterations. Type: integer; Default: 500. MBIS_PRUNING_SCHEME¶. Pruning scheme for MBIS Grid. Type: string; Default: ROBUST. MBIS_RADIAL_POINTS¶. MBIS Number of Radial Points. Type: integer; Default: 75. MBIS_SPHERICAL_POINTS¶. MBIS Number of Spherical Points. Type: integer; Default: 302. MOLDEN_WITH_VIRTUAL¶. Write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs (false). Type: boolean; Default: true. MP2_TYPE¶. Algorithm to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__globals.html:5232,Access,Access,5232,psi4manual/master/autodir_options_c/module__globals.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__globals.html,1,['Access'],['Access']
Security,"finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor from basis set strings, 'cc-pv[q5]z' from [cc-pvqz, cc-pv5z]; [docs]def reconstitute_bracketed_basis(needarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:75517,Validat,ValidationError,75517,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,4,['Validat'],['ValidationError']
Security,"findifrec[""stencil_size""] == 5:; fc = (-offdiag_en(0) - offdiag_en(1) + 9 * offdiag_en(2) - offdiag_en(3) - offdiag_en(4) +; 9 * offdiag_en(5) - offdiag_en(6) - offdiag_en(7) + E[i][0] - 7 * E[i][1] - 7 * E[i][2] +; E[i][3] + E[j][0] - 7 * E[j][1] - 7 * E[j][2] + E[j][3] +; 12 * ref_energy) / (12 * findifrec[""step""][""size""]**2); H_irr[i, j] = fc; H_irr[j, i] = fc. B_pi.append(data[""salc_list""].matrix_irrep(h)); H_pi.append(_process_hessian_symmetry_block(H_irr, B_pi[-1], massweighter, irrep_lbls[h], data[""print_lvl""])). # All blocks of the Hessian are now constructed!; return _process_hessian(H_pi, B_pi, massweighter, data[""print_lvl""]). [docs]class FiniteDifferenceComputer(BaseComputer):. molecule: Any; driver: DriverEnum; metameta: Dict[str, Any] = {}; task_list: Dict[str, BaseComputer] = {}; findifrec: Dict[str, Any] = {}; computer: BaseComputer = AtomicComputer; method: str. [docs] @validator('driver'); def set_driver(cls, driver):; egh = ['energy', 'gradient', 'hessian']; if driver not in egh:; raise ValidationError(f""""""Wrapper is unhappy to be calling function ({driver}) not among {egh}.""""""). return driver. [docs] @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; """"""Initialize FiniteDifference class. data keywords include; * general AtomicInput keys like molecule, driver, method, basis, and keywords.; * specialized findif keys like findif_mode, findif_irrep, and those converted from keywords to kwargs:; findif_stencil_size, findif_step_size, and findif_verbose.; * TODO hangers-on keys present at class initiation get automatically attached to class since `extra = ""allow""` but should be pruned. """"""; findif_stencil_size = data.pop('findif_stencil_size'); findif_step_size = data.pop('findif_step_size'). BaseComputer.__init__(self, **data). translations_projection_sound = (not ""external_potentials"" in data['keywords']['function_kwargs']; and not core.get_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:40745,validat,validator,40745,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,2,"['Validat', 'validat']","['ValidationError', 'validator']"
Security,"finite difference of gradients; >>> frequencies('scf', dertype=1, irrep=4). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Compute the hessian; hessian(name, **kwargs). if not (('mode' in kwargs) and (kwargs['mode'].lower() == 'sow')):; # call thermo module; psi4.thermo(). #TODO add return current energy once satisfied that's set to energy at eq, not a findif; return psi4.get_variable('CURRENT ENERGY'). ## Aliases ##; frequencies = frequency; freq = frequency. [docs]def molden(filename):; """"""Function to write wavefunction information in molden; format to *filename*. """"""; m = psi4.MoldenWriter(psi4.wavefunction()); m.write(filename). [docs]def parse_cotton_irreps(irrep):; r""""""Function to return validated Cotton ordering index from string or integer; irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2v': {; 'a1': 1,; 'a2': 2,; 'b1': 3,; 'b2': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2h': {; 'ag': 1,; 'bg': 2,; 'au': 3,; 'bu': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; },; 'd2h': {; 'ag': 1,; 'b1g': 2,; 'b2g': 3,; 'b3g': 4,; 'au': 5,; 'b1u': 6,; 'b2u': 7,; 'b3u': 8,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; '5': 5,; '6': 6,; '7': 7,; '8': 8; }; }. point_group = psi4.get_active_molecule().schoenflies_symbol().lower(); irreducible_representation = str(irrep).lower(). try:; return cotton[point_group][irreducible_representation]; except KeyError:; raise ValidationError(""Irrep \'%s\' not valid for point group \'%s\'."" % (str(irrep), point_group)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta5] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:74906,Validat,ValidationError,74906,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(""""""Stability analysis root following is only available for UHF""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') == '':; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:32960,Validat,ValidationError,32960,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(""""""Stability analysis root following is only available for UHF""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in [",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:41322,Validat,ValidationError,41322,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in [",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:43301,Validat,ValidationError,43301,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"fn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = psi4.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. [docs]def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if psi4.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2', 'omp2']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['mp2.5', 'omp2.5']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['mp3', 'omp3']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['lccd', 'olccd']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); elif name in ['ccd']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); psi4.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); elif name in ['ccsd']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); psi4.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); else:; raise ValidationError('Unidentified method %s' % (name)). if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccd', 'ccsd']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). psi4.set_global_option('DERTYPE', 'FIRST'); psi4.s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:37136,Validat,ValidationError,37136,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"fn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xtpl(len(scf[""basis""][1]), scf[""treatment""]); scf[""alpha""] = None; scf[""options""] = False; scf[""options_lo""] = False; metadata.append(scf); # 2c) keep processing current stage; stage[""treatment""] = item.get(""treatment"", ""scf"" if len(metadata) == 0 else ""corl""); stage[""stage""] = item.get(""stage"", False); if not stage[""stage""]:; if len(metadata) == 0:; stage[""stage""] = ""scf""; elif len(metadata) == 1:; stage[""stage""] = ""corl""; else:; stage[""stage""] = f""delta{len(metadata) - 1}""; stage[""scheme""] = item.get(""scheme"", _get_default_xtpl(len(stage[""basis""][1]), stage[""treatment""])); if len(metadata) > 0:; stage[""wfn_lo""] = item.get(""wfn_lo"", metadata[-1].get(""wfn"")).lower(); stage[""basis_lo""] = _expand_bracketed_basis(item.get(""basis_lo"", item[""basis""]).lower(), molecule); if len(stage[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return (metadata). def _process_cbs_kwargs(kwargs):; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs : dict; kwargs containing the CBS function specification. Returns; -------; list; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwarg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:31584,Validat,ValidationError,31584,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"fn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xtpl(len(scf[""basis""][1]), scf[""treatment""]); scf[""alpha""] = None; scf[""options""] = False; scf[""options_lo""] = False; metadata.append(scf); # 2c) keep processing current stage; stage[""treatment""] = item.get(""treatment"", ""scf"" if len(metadata) == 0 else ""corl""); stage[""stage""] = item.get(""stage"", False); if not stage[""stage""]:; if len(metadata) == 0:; stage[""stage""] = ""scf""; elif len(metadata) == 1:; stage[""stage""] = ""corl""; else:; stage[""stage""] = f""delta{len(metadata) - 1}""; stage[""scheme""] = item.get(""scheme"", _get_default_xtpl(len(stage[""basis""][1]), stage[""treatment""])); if len(metadata) > 0:; stage[""wfn_lo""] = item.get(""wfn_lo"", metadata[-1].get(""wfn"")).lower(); stage[""basis_lo""] = _expand_bracketed_basis(item.get(""basis_lo"", item[""basis""]).lower(), molecule); if len(stage[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return metadata. def _process_cbs_kwargs(kwargs: Dict) -> CBSMetadata:; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs; kwargs containing the CBS function specification. Returns; -------; cbs_metadata; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:19347,Validat,ValidationError,19347,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,5,['Validat'],['ValidationError']
Security,"fn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # If RHF get MP2 NO's; # Why doesnt this work for conv?; if (('DF' in core.get_global_option('SCF_TYPE')) and (user_ref == 'RHF') and; (core.get_option('DETCI', 'MCSCF_TYPE') in ['DF', 'AO']) and; (core.get_option(""DETCI"", ""MCSCF_GUESS"") == ""MP2"")):; core.set_global_option('ONEPDM', True); core.set_global_option('OPDM_RELAX', False); ref_wfn = run_dfmp2_gradient(name, **kwarg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:179769,Validat,ValidationError,179769,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"fn.startswith('c4-'):; default_scf = 'c4-hf'; else:; default_scf = 'hf'; cbs_scf_wfn = kwargs.pop('scf_wfn', default_scf).lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # ... resume correlation logic; if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:40206,Validat,ValidationError,40206,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"fn='mp2', corl_basis='cc-pv[dt]z'); energy(""cbs"", cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvtz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[dt]z"", ""scheme"": ""corl_xtpl_helgaker_2""}]). Caution; In PSI4 previous to Spring 2022 and v1.6, calling certain; cbs-related functions like the above looked like; energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z'). energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvtz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[dt]z"", ""scheme"": corl_xtpl_helgaker_2}]). The difference is that the main function; psi4.cbs() and extrapolation schemes like; psi4.driver.driver_cbs_helper.xtpl_highest_1() and; psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2() and composite; aliases like psi4.driver.aliases.sherrill_gold_standard(); and psi4.driver.aliases.allen_focal_point() in the old way; passed the Python function directly, whereas the new way uses the; string of the function name. A CCSD(T) DT coupled-cluster correction atop a TQ MP2 extrapolation; geometry optimization can also be accessed through the first item below more; conveniently than the equivalent second and third items. optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz'); optimize(""cbs"", corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz'); optimize(""cbs"", cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvqz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvdz""}]). Many examples can be found at cbs-xtpl-energy,; cbs-xtpl-gradient, cbs-xtpl-opt,; cbs-xtpl-freq, cbs-xtpl-func,; cbs-xtpl-wrapper, cbs-xtpl-dict. psi4.cbs(name[, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, cbs_metadata])[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases; complete_basis_set(). Returns; (float) – Total el",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cbs.html:1698,access,accessed,1698,psi4manual/1.6.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cbs.html,1,['access'],['accessed']
Security,"force the correct result; if numAtoms == 1:; dashd = 0.0; dashdderiv = core.Matrix(1, 3). if dertype == -1:; return dashd, dashdderiv; elif dertype == 0:; return dashd; elif dertype == 1:; return dashdderiv. geom = self.save_string_xyz(); reals = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; numAtoms -= 1; else:; reals.append(line). geomtext = str(numAtoms) + '\n\n'; for line in reals:; geomtext += line.strip() + '\n'; geomfile = './dftd3_geometry.xyz'; with open(geomfile, 'w') as handle:; handle.write(geomtext); # TODO somehow the variations on save_string_xyz and; # whether natom and chgmult does or doesn't get written; # have gotten all tangled. I fear this doesn't work; # the same btwn libmints and qcdb or for ghosts. # Call dftd3 program; command = ['dftd3', geomfile]; if dertype != 0:; command.append('-grad'); try:; dashout = subprocess.Popen(command, stdout=subprocess.PIPE, env=lenv); except OSError as e:; raise ValidationError('Program dftd3 not found in path. %s' % e); out, err = dashout.communicate(). # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; line = line.decode('utf-8'); if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; os.chdir(current_directory); raise Dftd3Error(""""""Unsuccessful run. Possibly -D variant not available in dftd3 version.""""""). # Parse grad output; if dertype != 0:; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html:6842,Validat,ValidationError,6842,psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"format; array requests among ‘png’, ‘pdf’, and ‘eps’ formats. relpath; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary.; Prepares bars diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames.; >>> asdf.plot_bars(['MP2-CP-adz', 'MP2-CP-adtz'], sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']). plot_disthist(modelchem, benchmark='default', sset='default', failoninc=True, verbose=False, xtitle='', view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Computes individual errors and summary statistics for single; model chemistry modelchem versus benchmark over; subset sset over all component databases. Computes histogram; of errors and gaussian distribution.; saveas conveys directory (‘/’) and/or filename for saving the; resulting plot. File extension is not accessible, but graphicsformat; array requests among ‘png’, ‘pdf’, and ‘eps’ formats. relpath; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary.; Prepares disthist diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames.; >>>. plot_flat(modelchem, benchmark='default', sset='default', failoninc=True, verbose=False, color='sapt', xlimit=4.0, xlines=[0.0, 0.3, 1.0], view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Computes individual errors and summary statistics for single; model chemistry modelchem versus benchmark over; subset sset over all component databases. Thread color can be; ‘rgb’ for old coloring, a color name or ‘sapt’ for spectrum coloring.; saveas conveys directory (‘/’) and/or filename for saving the; resulting plot. File extension is not accessible, but graphicsformat; array requests among ‘png’, ‘p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:36022,access,accessible,36022,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['access'],['accessible']
Security,"formation matrices, and a point of origin. The origin is not; respected by the symmetry operations, so if you want to use a point; group with a nonzero origin, first translate all your coordinates to; the origin and then set the origin to zero. """""". def __init__(self, *args):; """"""Constructor"""""". # Schoenflies symbol; self.symb = 'c1'; # point of origin; self.PYorigin = [0.0, 0.0, 0.0]; # bit representation of point group; self.PYbits = 0. # Divert to constructor functions; # if len(args) == 0:; # self.constructor_zero_ao_basis(); if len(args) == 1 and \; isinstance(args[0], basestring):; self.constructor_schoenflies(*args); elif len(args) == 1 and \; isinstance(args[0], int):; self.constructor_bits(*args); elif len(args) == 2 and \; isinstance(args[0], basestring) and \; len(args[1]) == 3:; self.constructor_schoenflies_origin(*args); elif len(args) == 2 and \; isinstance(args[0], int) and \; len(args[1]) == 3:; self.constructor_bits_origin(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. # libmints: These 2 constructors do not work right now.; [docs] def constructor_schoenflies(self, s):; """"""This constructor takes a string containing the Schoenflies; symbol of the point group as its only argument. """"""; self.PYbits = self.full_name_to_bits(s); if self.PYbits is None:; raise ValidationError('PointGroup: Unknown point group name provided.'); self.symb = self.bits_to_basic_name(self.PYbits); self.PYorigin = [0.0, 0.0, 0.0]. [docs] def constructor_schoenflies_origin(self, s, origin):; """"""Like the above, but this constructor also takes a point of; origin as an argument. """"""; self.PYbits = self.full_name_to_bits(s); if self.PYbits is None:; raise ValidationError('PointGroup: Unknown point group name provided.'); self.symb = self.bits_to_basic_name(self.PYbits); self.PYorigin = origin. [docs] def constructor_bits(self, bits):; """"""Using the bitwise representation construct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:39016,Validat,ValidationError,39016,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security,"found %d"""""" % (len(matches))). url = ""http://pubchem.ncbi.nlm.nih.gov/pug/pug.cgi""; initial_request = """"""; <PCT-Data>; <PCT-Data_input>; <PCT-InputData>; <PCT-InputData_download>; <PCT-Download>; <PCT-Download_uids>; <PCT-QueryUids>; <PCT-QueryUids_ids>; <PCT-ID-List>; <PCT-ID-List_db>pccompound</PCT-ID-List_db>; <PCT-ID-List_uids>; <PCT-ID-List_uids_E>%d</PCT-ID-List_uids_E>; </PCT-ID-List_uids>; </PCT-ID-List>; </PCT-QueryUids_ids>; </PCT-QueryUids>; </PCT-Download_uids>; <PCT-Download_format value=""sdf""/>; <PCT-Download_use-3d value=""true""/>; <PCT-Download_n-3d-conformers>%d</PCT-Download_n-3d-conformers>; </PCT-Download>; </PCT-InputData_download>; </PCT-InputData>; </PCT-Data_input>; </PCT-Data>; """""" % (self.cid, 1). print(""\tPosting PubChem request for CID %d"" % self.cid); server_response = urlopen(url, initial_request).read(); xml = ET.fromstring(server_response); for attempt in range(4):; if attempt == 3:; raise ValidationError(""""""PubChem: timed out""""""); # Look for a download location in the XML response; download_url = extract_xml_keyval(xml, 'PCT-Download-URL_url'); if download_url:; print(""\tDownloading from PubChem...""); # We have a download location; gogetit; file_name = '_psi4_pubchem_temp_download_.tgz'; response = urlopen(download_url); data = response.read(); fh = open(file_name, 'wb'); fh.write(data); fh.close(); unzipped = gzip.open(file_name); self.dataSDF = unzipped.read(); unzipped.close(); try:; os.remove(file_name); except:; pass; print(""\tDone!""); break; # We didn't find a download location yet.; if attempt == 0:; # If this is the first try, take a ticket; ticket = extract_xml_keyval(xml, 'PCT-Waiting_reqid'); #print(""ticket = "" + ticket); statusrequest = """"""<PCT-Data>; <PCT-Data_input>; <PCT-InputData>; <PCT-InputData_request>; <PCT-Request>; <PCT-Request_reqid>%d</PCT-Request_reqid>; <PCT-Request_type value=""status""/>; </PCT-Request>; </PCT-InputData_request>; </PCT-InputData>; </PCT-Data_input>; </PCT-Data>; """""" % int(ticket); if ticket:;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:3902,Validat,ValidationError,3902,psi4manual/1.0.0/_modules/pubchem.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html,1,['Validat'],['ValidationError']
Security,"fr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.molp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:22495,Validat,ValidationError,22495,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,1,['Validat'],['ValidationError']
Security,"fr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.5;  · . PSI4. Module code; qcelemental.molp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/qcelemental/molparse/from_arrays.html:22495,Validat,ValidationError,22495,psi4manual/1.5.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/qcelemental/molparse/from_arrays.html,1,['Validat'],['ValidationError']
Security,"fr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.6;  · . PSI4. Module code; qcelemental.molp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:22495,Validat,ValidationError,22495,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,1,['Validat'],['ValidationError']
Security,"frag[-1]]); self.fragment_types.append('Real'); self.set_has_zmatrix(zmatrix). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:23379,Validat,ValidationError,23379,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,2,['Validat'],['ValidationError']
Security,"fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; 1; 2; 3; 4; 5; 6; 7mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle option_molecule_name in; molecule optional_molecule_name {...}. The molecular geometry can be got and set and manipulated as a; Matrix object. Below shows how to access; coordinates in an input file in Python.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms as Python array. geom2psi = psi4.Matrix(4, 3) # initialize psi4.Matrix; geom2psi.set(geom2py) # load Python array into psi4.Matrix; geom2psi.scale(1.0/psi_bohr2angstroms) # scale into bohr; geom2psi.print_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:17180,access,access,17180,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['access'],['access']
Security,"freq. freq¶. psi4.driver.freq(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.freq.html:1073,access,accesses,1073,psi4manual/1.7.x/api/psi4.driver.freq.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.freq.html,4,['access'],['accesses']
Security,"from Psi4 LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = qcdb.options.reconcile_options(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = qcdb.options.prepare_options_for_cfour(userkw). # Handle text to be passed untouched to cfour; litcmd = core.get_global_option('LITERAL_CFOUR'). # Assemble ZMAT pieces; zmat = memcmd + molcmd + optcmd + mdccmd + psicmd + bascmd + litcmd. if len(re.findall(r'^\*(ACES2|CFOUR|CRAPS)\(', zmat, re.MULTILINE)) != 1:; core.print_out('\n Faulty ZMAT constructed:\n%s' % (zmat)); raise ValidationError(""""""; Multiple *CFOUR(...) blocks in input. This usually arises; because molecule or options are specified both the psi4 way through; molecule {...} and set ... and the cfour way through cfour {...}.""""""). return zmat. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.procrouting.interface_cfour. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:17485,Validat,ValidationError,17485,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,1,['Validat'],['ValidationError']
Security,"ftware Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import numpy as np; import psi4; from exceptions import *. def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; try:; arr.shape; except:; raise ValidationError(""Expected numpy array, found object of type '%s'"", type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). @classmethod; def _dimension_from_list(self, dims, name=""New Dimension""):; """"""; Builds a psi4.Dimension object from a python list or tuple. If a dimension; object is passed a copy will be returned.; """""". if isinstance(dims, (tuple, list)):; irreps = len(dims); elif isinstance(dims, psi4.Dimension):; irreps = dims.n(); else:; raise ValidationError(""Dimension from list: Type '%s' not understood"" % type(dims)). ret = psi4.Dimension(irreps, name); for i in range(irreps):; ret[i] = dims[i]; return ret. def _dimension_to_tuple(dim):; """"""; Converts a psi4.Dimension object to a tuple.; """""". if isinstance(dim, (tuple, list)):; return tuple(dim); ; irreps = dim.n(); ret = []; for i in range(irreps):; ret.append(dim[i]); return tuple(ret). @classmethod; def array_to_matrix(self, arr, name=""New Matrix"", dim1=None, dim2=None):; """"""; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list).; ; Parameters; ----------; arr : array or list of arrays; Numpy array or list of arrays to use as the data for a new psi4.Matrix; name : str; Name to give the new psi4.Matrix; dim1 : list, tuple, or psi4.Dimension (optional); If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:2002,Validat,ValidationError,2002,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"ful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys. import numpy as np. from psi4 import core; from .exceptions import *. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(self, arr, name=""New Matrix"", dim1=None, dim2=None):; """"""; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters; ----------; arr : array or list of arrays; Numpy array or list of arrays to use as the data for a new core.Matrix; name : str; Name to give the new core.Matrix; dim1 : list, tuple, or core.Dimension (optional); If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 :; Same as dim1 only if using a psi4.core.Dimension object. Returns; -------; matrix : :py:class:`~psi4.core.Matrix` or :py:class:`~psi4.core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html:1672,Validat,ValidationError,1672,psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"func':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; for method in cbs_methods:; _filter_renamed_methods(""gradient"", method); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); _filter_renamed_methods(""gradient"", lowername); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calcu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:41786,Validat,ValidationError,41786,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"function when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:48987,access,accesses,48987,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['access'],['accesses']
Security,"function, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:38628,Validat,ValidationError,38628,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,fy() psi4.core.FISAPT method. unit() psi4.core.SymmetryOperation method. units. ; molecule. units qcelemental.datum.Datum attribute. units() psi4.core.Molecule method. Unnormalized psi4.core.PrimitiveType attribute. UPDATE (DETCI). update() psi4.core.DFSOMCSCF method. psi4.core.DiskSOMCSCF method. psi4.core.SOMCSCF method. update_density() psi4.core.ERI method. psi4.core.TwoBodyAOInt method. psi4.core.TwoElectronInt method. update_geometry() psi4.core.Molecule method. update_orbitals() psi4.core.IntegralTransform method. UpgradeHelper. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. v2rdm_casscf. ; plugin. V_potential() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. Va() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. VAL_EX_LEVEL (DETCI). valid_methods psi4.core.OEProp attribute. validate_options() psi4.core.Options method. ValidationError. class in qcelemental. value psi4.core.DerivCalcType attribute. psi4.core.DiagonalizeOrder attribute. psi4.core.FragmentType attribute. psi4.core.GaussianType attribute. psi4.core.GeometryUnits attribute. psi4.core.PrimitiveType attribute. psi4.core.PsiReturnType attribute. psi4.core.SaveType attribute. value() psi4.core.SuperFunctional method. values() psi4.core.SuperFunctional method. variable() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. variables() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. Vb() psi4.core.CUHF method. psi4.core.HF method. ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:147853,Validat,ValidationError,147853,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['Validat'],['ValidationError']
Security,"g the following transformations. All letters lowercase; Replace all * with s; Replace all + with p; Replace all ( ) , with _ (underscores replace parentheses and commas). For example, basis 6-31++G** is stored in psi4/psi4/share/psi4/basis/6-31ppgss.gbs,; and cc-pV(D+d)Z is stored in psi4/psi4/share/psi4/basis/cc-pv_dpd_z.gbs.; Only one basis set may be specified per file.; Copy the new basis set file into psi4/psi4/share/psi4/basis.; Request the new basis set in an input file in the usual manner.; 1set basis new_basis_name. (2) Use new basis set file in arbitrary location.; Prepare a basis set file exactly as above. Append the directory; containing the basis set file to the environment variable; PSIPATH.; Request the new basis set in an input file in the usual manner.; 1set basis new_basis_name. (3) Include new basis set in input file.; Construct for a basis set a section like the one below that includes; [basis name], PUREAM value, and element basis set; specifications. Hash signs denote comments. This format is exactly like; the stand-alone basis file except for the addition of the basis name in; brackets.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19[ sto-3g ]; cartesian; ****; H 0; S 3 1.00; 3.42525091 0.15432897; 0.62391373 0.53532814; 0.16885540 0.44463454; ****; O 0; S 3 1.00; 130.7093200 0.15432897; 23.8088610 0.53532814; 6.4436083 0.44463454; SP 3 1.00; 5.0331513 -0.09996723 0.15591627; 1.1695961 0.39951283 0.60768372; 0.3803890 0.70011547 0.39195739; ****. Copy the section into a PSI4 input file and surround it with the; command basis {...}, as shown below. Multiple basis sets can be; specified by adding additional sections within the surrounding brackets.; Use assign statements to actually request the basis set. (See; mints2 for an example.); 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14basis {. # assign basset to all atoms and addl to hydrogens; assign basset; assign H addl. # basis set section like in snippet above goes here; [bass",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/basissets-1.html:8612,Hash,Hash,8612,psi4manual/1.1.0/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/basissets-1.html,2,['Hash'],['Hash']
Security,"g the following transformations. All letters lowercase; Replace all * with s; Replace all + with p; Replace all ( ) , with _ (underscores replace parentheses and commas). For example, basis 6-31++G** is stored in psi4/psi4/share/psi4/basis/6-31ppgss.gbs,; and cc-pV(D+d)Z is stored in psi4/psi4/share/psi4/basis/cc-pv_dpd_z.gbs.; Only one basis set may be specified per file.; Copy the new basis set file into psi4/psi4/share/psi4/basis.; Request the new basis set in an input file in the usual manner.; 1set basis new_basis_name. (2) Use new basis set file in arbitrary location.; Prepare a basis set file exactly as above. Append the directory; containing the basis set file to the environment variable; PSIPATH.; Request the new basis set in an input file in the usual manner.; 1set basis new_basis_name. (3) Include new basis set in input file.; Construct for a basis set a section like the one below that includes; [basis name], PUREAM value, and element basis set; specifications. Hash signs denote comments. This format is exactly like; the stand-alone basis file except for the addition of the basis name in; brackets.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19[ sto-3g ]; cartesian; ****; H 0; S 3 1.00; 3.42525091 0.15432897; 0.62391373 0.53532814; 0.16885540 0.44463454; ****; O 0; S 3 1.00; 130.7093200 0.15432897; 23.8088610 0.53532814; 6.4436083 0.44463454; SP 3 1.00; 5.0331513 -0.09996723 0.15591627; 1.1695961 0.39951283 0.60768372; 0.3803890 0.70011547 0.39195739; ****. Copy the section into a PSI4 input file and surround it with the; command basis {...}, as shown below. Multiple basis sets can be; specified by adding additional sections within the surrounding brackets.; Use assign statements to actually request the basis set. This; basis {...} section replaces the usual set basis XXX line.; In a more complex input, if the user needs to call the user-defined; basis by name, this can be achieved using the syntax basis mybas {...},; and then the basi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/basissets-1.html:8614,Hash,Hash,8614,psi4manual/1.2.1/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/basissets-1.html,4,['Hash'],['Hash']
Security,"g to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.Matrix.from_array(ret); wfn.set_gradient(ret); elif self.driver == 'hessian':; ret = core.Matrix.from_array(ret); grad = core.Matrix.from_array(nbody_model.properties.return_gradient); wfn.set_hessian(ret); wfn.set_gradient(grad). if return_wfn:; return (ret, wfn); else:; return ret. # TODO questions to check:; # * can work with supersystem and embedding_charges?; # * can levels work with same method, different basis?. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.6;  · . PSI4. Module code; psi4.driver.driver_nbody. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:92353,Validat,ValidationError,92353,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"g; Methods Summary. add_array(self, arg0); add array option. add_bool(self, arg0, arg1); add bool option. add_int(self, arg0, arg1); add int option. add_str(self, arg0, arg1, arg2); add string option. add_str_i(self, arg0, arg1, arg2); add string option. get_bool(self, arg0); get boolean option. get_current_module(self); gets current module. get_double(self, arg0); get double option. get_int(self, arg0); get integer option. get_int_vector(self, arg0); get int vector option. get_str(*args, **kwargs); Overloaded function. read_globals(self); expert. set_array(self, arg0, arg1); set array option. set_bool(self, arg0, arg1, arg2); set bool option. set_current_module(self, arg0); sets arg0 (all CAPS) as current module. set_double(self, arg0, arg1, arg2); set double option. set_int(self, arg0, arg1, arg2); set int option. set_read_globals(self, arg0); expert. set_str(self, arg0, arg1, arg2); set string option. set_str_i(self, arg0, arg1, arg2); set string option. validate_options(self); validate options for arg0 module. Methods Documentation. add_array(self: psi4.core.Options, arg0: str) → None¶; add array option. add_bool(self: psi4.core.Options, arg0: str, arg1: bool) → None¶; add bool option. add_int(self: psi4.core.Options, arg0: str, arg1: int) → None¶; add int option. add_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; add string option. add_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; add string option. get_bool(self: psi4.core.Options, arg0: str) → bool¶; get boolean option. get_current_module(self: psi4.core.Options) → str¶; gets current module. get_double(self: psi4.core.Options, arg0: str) → float¶; get double option. get_int(self: psi4.core.Options, arg0: str) → int¶; get integer option. get_int_vector(self: psi4.core.Options, arg0: str) → List[int]¶; get int vector option. get_str(*args, **kwargs)¶; Overloaded function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.options.html:1198,validat,validate,1198,psi4manual/1.2.1/api/psi4.core.options.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.options.html,1,['validat'],['validate']
Security,"g]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1). # Now go through the rest of the lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; zmatrix = False; for line in glines:. # handle fragment markers; if frag.match(line):; ifrag += 1; self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); tempfrag = []. # handle atom markers; elif atom.match(line):; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomLabel = entries[0]. # handle ghost atoms; ghostAtom = False; if ghost.match(atomLabel):; # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; atomLabel = ghost.match(atomLabel).group(2) if not ghost.match(atomLabel).group(1) \; else ghost.match(atomLabel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:17901,Validat,ValidationError,17901,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"g_charges » embedding_charges; set_max_nbody » max_nbody; set_molecule » molecule; set_nfragments » nfragments; set_return_total_data » return_total_data. field basis: str = '(auto)'¶. field bsse_type: List[BsseEnum] = [BsseEnum.cp]¶; Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned. Validated by:. set_bsse_type. field driver: DriverEnum [Required]¶; The computation driver; i.e., energy, gradient, hessian. field embedding_charges: Dict[int, List[float]] = {}¶; Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment. Validated by:. set_embedding_charges. field keywords: Dict[str, Any] = {}¶; The computation keywords/options. field max_nbody: int = -1¶; Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments. Validated by:. set_max_nbody. field method: str = '(auto)'¶. field molecule: Any [Required]¶; The target molecule, if not the last molecule defined. Validated by:. set_molecule. field nbodies_per_mc_level: List[List[Union[int, Literal['supersystem']]]] = []¶; Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry ‘supersystem’ means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any ‘supersystem’ element is at the end. field nfragments: int = -1¶; Number of distinct fragments c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/nbody.html:16022,Validat,Validated,16022,psi4manual/master/nbody.html,https://psicode.org,https://psicode.org/psi4manual/master/nbody.html,3,['Validat'],['Validated']
Security,"ge, allvital=False, label='electronic energy'):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.strip().split(None, 10); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if label == 'electronic energy' and s[8:10] == ['electronic', 'energy']:; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); if label == 'electronic gradient' and s[8:10] == ['electronic', 'gradient']:; E = ast.literal_eval(s[-1]); psi4.print_out('%s RESULT: electronic gradient = %r\n' % (quantity, E)); frea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:8736,Validat,ValidationError,8736,psi4manual/1.0.0/_modules/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html,1,['Validat'],['ValidationError']
Security,"ge, mass, symbol, label="""", basis=None, shells=None):; """"""Constructor""""""; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]; # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False; # Different types of basis sets that can be assigned to this atom.; self.PYbasissets = basis if basis is not None else OrderedDict(); # Hash of one-atom BasisSet attached to this atom; self.PYshells = shells if shells is not None else OrderedDict(). @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:6587,Validat,ValidationError,6587,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['Validat'],['ValidationError']
Security,"gence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(); core.clean(); optstash.restore(). opt_data = opt_object.to_dict(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). core.print_out('\n Structure for next step:\n');",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:76370,validat,validated,76370,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['validat'],['validated']
Security,"get_option(""OCC"", ""MP2_TYPE"") == ""CONV""):; return run_mp2(name, **kwargs); else:; return run_dfmp2(name, **kwargs). [docs]def run_mp2_select_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2 gradient call; and directing toward the OCC (conv MP2) or the DFMP2 modules. """"""; if (PsiMod.get_option(""DFMP2"", ""MP2_TYPE"") == ""CONV"") or (PsiMod.get_option(""OCC"", ""MP2_TYPE"") == ""CONV""):; return run_mp2_gradient(name, **kwargs); else:; return run_dfmp2_gradient(name, **kwargs). [docs]def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; #PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF') # insufficient b/c SCF option read in DFMP2; PsiMod.set_global_option('SCF_TYPE', 'DF'). if not PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 gradients need DF-SCF reference, for now.'). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = PsiMod.IOManager.shared_object(); psio = PsiMod.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(PsiMod.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). PsiMod.print_out('\n'); bann",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:19699,Validat,ValidationError,19699,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"gies. .. _`table:freq_gen`:. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce (someday) if name is function; if hasattr(name, '__call__'):; raise ValidationError(""Frequency: Cannot use custom function""). lowername = name.lower(). old_global_basis = None; if ""/"" in lowername:; if (""+"" in lowername) or (""["" in lowername) or (lowername.count('/') > 1):; raise ValidationError(""Frequency: Cannot extrapolate or delta correct frequencies yet.""); else:; old_global_basis = psi4.get_global_option(""BASIS""); lowername, new_basis = lowername.split('/'); psi4.set_global_option('BASIS', new_basis). if kwargs.get('bsse_type', None) is not None:; raise ValdiationError(""Frequency: Does not currently support 'bsse_type' arguements""). return_wfn = kwargs.pop('return_wfn', False). # are we in sow/reap mode?; freq_mode = kwargs.get('mode', 'continuous').lower(); if freq_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(lowername, return_wfn=True, molecule=molecule, **kwargs). # S/R: Quit after getting new displacements; if freq_mode == 'sow':; return 0.0. wfn.frequencies().print_out(); psi4.thermo(wfn, wfn.frequencies()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:82352,Validat,ValidationError,82352,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". derivatives = {""gradient"": 1, ""hessian"": 2}. if ptype not in derivatives:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; core.print_out(""\nRelativistic analytic gradients are not implemented yet, re-routing to finite differences.\n""); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_meth",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:2974,Validat,ValidationError,2974,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"gle point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). fcidump; test FCIDUMP functionality for rhf/uhf. fnocc5; Test FNO-DF-CCSD(T) energy. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc12; Single point energies of multiple excited states with EOM-CCSD. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. fnocc4; Test FNO-DF-CCSD(T) energy. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc54; CCSD dipole with user-specified basis set. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-pt2; Mk-MRP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:8238,validat,validate,8238,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['validat'],['validate']
Security,"glet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:115933,Validat,ValidationError,115933,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"glet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:119666,Validat,ValidationError,119666,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"glet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and not ""cvs"" in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; try:; adcc.set_n_threads(core.get_num_threads()); except AttributeError:; # Before adcc 0.13.3:; adcc.thread_pool.reinit(core.get_num_threads(), core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:113648,Validat,ValidationError,113648,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"global_option('QMEFP', True) # apt to go haywire if set locally to efp; psi4.efp_set_options(); efp.set_qm_atoms(); efp.print_out(). # the SECOND scf call; ref_wfn = psi4.new_wavefunction(scf_molecule, psi4.get_global_option('BASIS')); scf_wfn = psi4.scf(ref_wfn, precallback, postcallback); e_scf = psi4.get_variable('CURRENT ENERGY'). # We always would like to print a little dipole information; if kwargs.get('scf_do_dipole', True):; oeprop = psi4.OEProp(scf_wfn); oeprop.set_title(""SCF""); oeprop.add(""DIPOLE""); oeprop.compute(); psi4.set_variable(""CURRENT DIPOLE X"", psi4.get_variable(""SCF DIPOLE X"")); psi4.set_variable(""CURRENT DIPOLE Y"", psi4.get_variable(""SCF DIPOLE Y"")); psi4.set_variable(""CURRENT DIPOLE Z"", psi4.get_variable(""SCF DIPOLE Z"")). optstash.restore(); return scf_wfn. [docs]def run_dcft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. """""". if (psi4.get_global_option('FREEZE_CORE') == 'TRUE'):; raise ValidationError('Frozen core is not available for DCFT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). dcft_wfn = psi4.dcft(ref_wfn); return dcft_wfn. [docs]def run_dcft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCFT gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE']). psi4.set_global_option('DERTYPE', 'FIRST'); dcft_wfn = run_dcft(name, **kwargs). derivobj = psi4.Deriv(dcft_wfn); derivobj.set_tpdm_presorted(True); grad = derivobj.compute(). dcft_wfn.set_gradient(grad). optstash.restore(); return dcft_wfn. [docs]def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:32496,Validat,ValidationError,32496,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! FISAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' FISAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); _ini_cart = getattr(sapt_dimer, ""_initial_cartesian"", None); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(); if _ini_cart:; sapt_dimer._initial_cartesian = _ini_cart. if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('FISAPT requires requires \""reference rhf\"".'). if ref_wfn is None:; core.timer_on(""FISAPT: Dimer SCF""); ref_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""FISAPT: Dimer SCF""). core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(),; ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"",; core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). sapt_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SAPT"", core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS""),; ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SAPT"", sapt_basis). minao = core.BasisSet.build(ref_wfn.molecule(), ""BASIS"", core.get_global_option(""MINAO_BASIS"")); ref_wfn.set_basisset(""MINAO"", minao). # Turn of dispersion for -d; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:160180,Validat,ValidationError,160180,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"gma^+\) state of the CN radical, with Z-matrix input. fnocc3; Test FNO-QCISD(T) computation. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. aediis-1; ADIIS test case, from 10.1063/1.3304922. scf-response2; Compute the dipole polarizability for water with custom basis set. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. scf-coverage; Lithium test for coverage. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. cisd-sp; 6-31G** H2O Test CISD Energy Point. tdscf-7; TD-HF test variable access. mbis-2; MBIS calculation on OH- (Expanded Arrays). sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. mints3; Test individual integral objects for correctness. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. pubchem2; Superficial test of PubChem interface. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. sap",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:5545,access,access,5545,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['access'],['access']
Security,"gma_xy(); self.symop[3].sigma_xz(). elif self.PYbits == PointGroups['C2vY']:; self.symop[1].c2_y(); self.symop[2].sigma_xy(); self.symop[3].sigma_yz(). elif self.PYbits == PointGroups['C2vZ']:; self.symop[1].rotation(2); self.symop[2].sigma_xz(); self.symop[3].sigma_yz(). elif self.PYbits == PointGroups['D2']:; self.symop[1].rotation(2); self.symop[2].c2_y(); self.symop[3].c2_x(). elif self.PYbits == PointGroups['D2h']:; self.symop[1].rotation(2); self.symop[2].c2_y(); self.symop[3].c2_x(); self.symop[4].i(); self.symop[5].sigma_xy(); self.symop[6].sigma_xz(); self.symop[7].sigma_yz(). else:; return -1. # now find the inverse of each symop; for gi in range(self.PYnirrep):; for gj in range(self.PYnirrep):; so = self.symop[gi].operate(self.symop[gj]). # is so a unit matrix?; if abs(1.0 - so[0][0]) < 1.0e-8 and \; abs(1.0 - so[1][1]) < 1.0e-8 and \; abs(1.0 - so[2][2]) < 1.0e-8:; break. if gj == self.PYnirrep:; # ExEnv::err0() << indent; # << ""make_table: uh oh, can't find inverse of "" << gi << endl;; # abort();; raise ValidationError(""make_table: uh oh, can't find inverse""). self.inv[gi] = gj. # Check the bits of the operator make sure they make what; # we were given.; sym_bits = 0; for i in range(self.PYnirrep):; sym_bits |= self.symop[i].bit(). if sym_bits != self.PYbits:; raise ValidationError(""make_table: Symmetry operators did not match the point group given.""). return 0. # <<< Methods for Printing >>>. def __str__(self, out=None):; """"""This prints the irrep to the given file, or stdout if none is; given. """"""; text = ''; if not self.PYnirrep:; return. text += ' point group %s\n\n' % (self.symb); for i in range(self.PYnirrep):; text += self.PYgamma[i].__str__(out=None). text += '\n symmetry operation matrices:\n\n'; for i in range(self.PYnirrep):; text += self.symop[i].__str__(out=None). text += '\n inverse symmetry operation matrices:\n\n'; for i in range(self.PYnirrep):; text += self.symop[self.inverse(i)].__str__(out=None). if out is None:; return text; else:; w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:36777,Validat,ValidationError,36777,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security,"gments (int); quiet (bool); return_total_data (bool | None); task_list (Dict[str, psi4.driver.task_base.AtomicComputer | psi4.driver.driver_cbs.CompositeComputer | psi4.driver.driver_findif.FiniteDifferenceComputer]). Validators:. set_bsse_type » bsse_type; set_embedding_charges » embedding_charges; set_max_nbody » max_nbody; set_molecule » molecule; set_nfragments » nfragments; set_return_total_data » return_total_data. field basis: str = '(auto)'¶. field bsse_type: List[BsseEnum] = [BsseEnum.cp]¶; Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned. Validated by:. set_bsse_type. field driver: DriverEnum [Required]¶; The computation driver; i.e., energy, gradient, hessian. field embedding_charges: Dict[int, List[float]] = {}¶; Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment. Validated by:. set_embedding_charges. field keywords: Dict[str, Any] = {}¶; The computation keywords/options. field max_nbody: int = -1¶; Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments. Validated by:. set_max_nbody. field method: str = '(auto)'¶. field molecule: Any [Required]¶; The target molecule, if not the last molecule defined. Validated by:. set_molecule. field nbodies_per_mc_level: List[List[Union[int, Literal['supersystem']]]] = []¶; Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbody=2 and 1-body and 2-body contributions computed at different leve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/nbody.html:15752,Validat,Validated,15752,psi4manual/master/nbody.html,https://psicode.org,https://psicode.org/psi4manual/master/nbody.html,3,['Validat'],['Validated']
Security,"gradient""). # throw exception for CONV (approximately); if (corl_type := method_algorithm_type(name).now) not in [""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for DFOCC gradient. See Capabilities Table at {dtl}""). proc_util.check_disk_df(name.upper(), optstash). # throw exception for SCF_TYPE; if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); retu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:68853,Validat,ValidationError,68853,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite differ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:38529,Validat,ValidationError,38529,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite differ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:37356,Validat,ValidationError,37356,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(). # no analytic derivatives for scf_type cd; if psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; psi4.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; psi4.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite differ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:36125,Validat,ValidationError,36125,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix) → psi4.core.Matrix¶; Creates a new matrix that is the transpose of this matrix. transpose_this(self: psi4.core.Matrix) → None¶; Transpose the matrix in-place. triplet(A: psi4.core.Matrix, B: psi4.core.Matrix, C: psi4.core.Matrix, transA: bool=False, transB: bool=False, transC: bool=False) → psi4.core.Matrix¶; Returns the multiplication of three matrics A, B, and C, with options to transpose each beforehand. vector_dot(self: psi4.core.Matrix, rhs: psi4.core.Matrix) → float¶; Returns the vector dot product of this with rhs. zero(self: psi4.core.Matrix) → None¶; Zero all elements",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html:15278,access,accessor,15278,psi4manual/1.2.1/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html,3,['access'],['accessor']
Security,"gradient; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; freq_dertype = kwargs['dertype']. if der0th.match(str(freq_dertype)):; dertype = 0; func = energy; elif der1st.match(str(freq_dertype)):; dertype = 1; func = gradient; elif der2nd.match(str(freq_dertype)):; dertype = 2; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function frequency.' % (freq_dertype)). # 3. if the user provides a custom function THAT takes precedence; if ('freq_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['freq_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['freq_func']. # Summary validation; if (dertype == 2) and (lowername in procedures['hessian']):; pass; elif (dertype == 1) and (func is gradient) and (lowername in procedures['gradient']):; pass; elif (dertype == 1) and not(func is gradient):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:60821,validat,validation,60821,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,"['Validat', 'validat']","['ValidationError', 'validation']"
Security,"gradient; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; freq_dertype = kwargs['dertype']. if der0th.match(str(freq_dertype)):; dertype = 0; func = energy; elif der1st.match(str(freq_dertype)):; dertype = 1; func = gradient; elif der2nd.match(str(freq_dertype)):; dertype = 2; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function frequency.' % (freq_dertype)). # 3. if the user provides a custom function THAT takes precedence; if ('freq_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['freq_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['freq_func']. # Summary validation; if (dertype == 2) and (lowername in procedures['hessian']):; pass; elif (dertype == 1) and (func is gradient) and (lowername in procedures['gradient']):; pass; elif (dertype == 1) and not(func is gradient):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; freq_mode = 'continuous'; if ('mode' in kwargs) and ((dertype == 0) or (dertype == 1)):; freq_mode = kwargs['mode']. if (freq_mode.lower() == 'continuous'):; pass; elif (freq_mode.lower() == 'sow'):; pass; elif (freq_mode.lower() == 'reap'):; if('linkage' in kwargs):; freq_linkage = kwargs['linkage']; else:; raise ValidationError('Frequency execution mode ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:59521,validat,validation,59521,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,"['Validat', 'validat']","['ValidationError', 'validation']"
Security,"gram picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE; Default: FALSE. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. INTEGRAL_PACKAGE¶. Integral package to use. If compiled with ERD support, ERD is used where possible; LibInt is used otherwise. Type: string; Possible Values: ERD, LIBINT; Default: ERD. LITERAL_CFOUR¶. Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through cfour {...} block. Type: string; Default: No Default. MP2_TYPE¶. Algorithm to use for MP2 computation. See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: DF. MP_TYPE¶. Algorithm to use for MPn ( ) computation (e.g., MP3 or MP2.5 or MP4(SDQ)). See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: CONV. NUM_FROZEN_DOCC¶. The number of core orbitals to freeze in later correlated computations. This trumps FREEZE_CORE. Type: integer; Default: 0. NUM_FROZEN_UOCC¶. The number of virtual orbitals to freeze in later correlated computations. Type: integer; Default: 0. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PRINT¶. The amount of information to print to the output file. 1 prints basic information, and higher levels print more information. A value of 5 will print very large amounts of debugging information. Type: integer; Default: 1. PROPERTIES¶. List of properties to compute",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__globals-1.html:3520,Access,Access,3520,psi4manual/1.0.0/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__globals-1.html,2,['Access'],['Access']
Security,"group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:4307,Validat,ValidationError,4307,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"gs. no need to stash these since only read, never reset; cast = False; if core.has_option_changed('SCF', 'BASIS_GUESS'):; cast = core.get_option('SCF', 'BASIS_GUESS'); if p4util.yes.match(str(cast)):; cast = True; elif p4util.no.match(str(cast)):; cast = False. if cast:. # A user can set ""BASIS_GUESS"" to True and we default to 3-21G; if cast is True:; guessbasis = '3-21G'; else:; guessbasis = cast; core.set_global_option('BASIS', guessbasis). castdf = 'DF' in core.get_global_option('SCF_TYPE'). if core.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = core.get_option('SCF', 'DF_BASIS_GUESS'); if p4util.yes.match(str(castdf)):; castdf = True; elif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:32153,Validat,ValidationError,32153,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"gs.; algorithm; {'hungarian_uno', 'permutative'}; When `atoms_map=False`, screening algorithm for plausible atom mappings.; `permutative` suitable only for small systems.; uno_cutoff; TODO; run_mirror; Run alternate geometries potentially allowing best match to `rgeom`; from mirror image of `cgeom`. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns; -------; float, tuple; First item is RMSD [A] between `rgeom` and the optimally aligned; geometry computed.; Second item is a AlignmentMill with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from `cgeom` and the optimally aligned geometry. """"""; # validation; if rgeom.shape != cgeom.shape or rgeom.shape[1] != 3:; raise ValidationError(""""""natom doesn't match: {} != {}"""""".format(rgeom.shape, cgeom.shape)); nat = rgeom.shape[0]; if atoms_map and runiq is None and cuniq is None:; runiq = np.array([""""] * nat); cuniq = np.array([""""] * nat); if sorted(runiq) != sorted(cuniq):; raise ValidationError(""""""atom subclasses unequal:\n {}\n {}"""""".format(runiq, cuniq)). if run_mirror:; # use aligner to check if system and its (xz-plane) mirror image are; # superimposible and hence whether its worth doubling the number of Kabsch; # runs below to check for mirror-image matches; mcgeom = np.copy(cgeom); mcgeom[:, 1] *= -1.0; exact = 1.0e-6; mrmsd, msolution = B787(; mcgeom,; cgeom,; cuniq,; cuniq,; do_plot=False,; verbose=0,; atoms_map=False,; mols_align=exact,; run_mirror=False,; uno_cutoff=0.1,; ); superimposable = mrmsd < exact; if verbose >= 1 and superimposable:; print(; ""Not testing for mirror-image matches (despite `run_mirror`) since system and its mirror are superimposable""; ). # initialization; best_rmsd = 100.0 # [A]; ocount = 0; hold_solution = None; run_resorting = run_resorting or not atoms_map; if mols_align is True:; a_convergence = 1.0e-3; elif mols_align is False:; a_convergence = 0.0; else:; a_convergence = mols_align. # initial presentation; atomfmt2 = """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html:4024,Validat,ValidationError,4024,psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,3,['Validat'],['ValidationError']
Security,"guess, diis, etc.; For the moment, so-called “best-practices” keywords are summarized at; Best Practices.; For the type of computation intended, find appropriate options at; Keywords. These keyword summaries contain the same; information as the proper CFOUR options list; plus notes on keyword relevance when run through PSI4. Information; at the CFOUR manual may; also be useful, as may the many samples at psi4/samples/cfour.; Set Cfour keywords just like PSI4 keywords. The names of keywords; are unchanged beyond a prepended “cfour_”. (Though be aware that common; abbreviations like CALC and REF must be fully spelled out as; CFOUR_CALC_LEVEL and CFOUR_REFERENCE when used in; PSI4.); In limited trial cases, keywords nominally directed at non-Cfour modules; are translated into their Cfour counterparts. For example, setting; REFERENCE will appropriately set CFOUR_REFERENCE. For a; list of applicable keywords, see source of; muster_psi4options.; Consult Functionality for information on what Cfour; functionality is accessible through PSI4. PSI4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a PSI4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/psi4/share/psi4/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into PSI4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the du",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cfour.html:2861,access,accessible,2861,psi4manual/master/cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/cfour.html,9,['access'],['accessible']
Security,"gy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:63926,Validat,ValidationError,63926,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"gy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. tdscf-6; td-camb3lyp with DiskDF and method/basis specification. dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. cubeprop; RHF orbitals and density for water. dft-smoke; DFT Functional Smoke Test. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). scf-ecp; Water-Argon complex with ECP present; check of energies and forces. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. fci-h2o; 6-31G H2O Test FCI Energy Point. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. scf-level-shift-uhf; SCF level shift on a UHF computation. linK-2; RKS Linear Exchange Algorithm test for benzene. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. sapt11; sapt example with orbital freezing with alkali metal and dMP2. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:7069,validat,validate,7069,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['validat'],['validate']
Security,"h Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; Module with PsiAPI helpers for PSIthon `{...}` syntax.; Also, many Python extensions to core classes:. - core (variable-related, gradient, python option),; - Wavefunction (variable-related, freq, Lagrangian, constructor, scratch file, serialization),; - Matrix (doublet, triplet),; - BasisSet (constructor); - JK (constructor); - VBase (grid); - OEProp (avail prop). """""". __all__ = [; ""basis_helper"",; ""pcm_helper"",; ""set_options"",; ""set_module_options"",; ""temp_circular_import_blocker"", # retire ASAP; ]. import os; import re; import sys; import uuid; import warnings; from collections import Counter; from itertools import product; from pathlib import Path; from tempfile import NamedTemporaryFile; from typing import Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel; from psi4 import core; from psi4.driver import qcdb. from . import optproc; from .exceptions import TestComparisonError, ValidationError, UpgradeHelper. ## Python basis helps. @staticmethod; def _pybuild_basis(; mol: core.Molecule,; key: Optional[str] = None,; target: Optional[Union[str, Callable]] = None,; fitrole: str = ""ORBITAL"",; other: Optional[Union[str, Callable]] = None,; puream: int = -1,; return_atomlist: bool = False,; *,; quiet: bool = False,; ) -> Union[core.BasisSet, List[core.BasisSet]]:; """"""Build a primary or auxiliary basis set. Parameters; ----------; mol; Molecule for which to build the basis set instance.; key; {'BASIS', 'ORBITAL', 'DF_BASIS_SCF', 'DF_BASIS_MP2', 'DF_BASIS_CC', 'BASIS_RELATIVISTIC', 'DF_BASIS_SAD'}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ``""ORBITAL""`` or ``""BASIS""``.; target; Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:2079,Validat,ValidationError,2079,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"h can be computed by; libdisp or dftd3. """""". def __init__(self, name_hint=None, level_hint=None, param_tweaks=None, **kwargs):; from .dft import dashcoeff_supplement; self.dashcoeff_supplement = dashcoeff_supplement. resolved = intf_dftd3.from_arrays(; name_hint=name_hint,; level_hint=level_hint,; param_tweaks=param_tweaks,; dashcoeff_supplement=self.dashcoeff_supplement); self.fctldash = resolved['fctldash']; self.dashlevel = resolved['dashlevel']; self.dashparams = resolved['dashparams']; self.description = intf_dftd3.dashcoeff[self.dashlevel]['description']; self.ordered_params = intf_dftd3.dashcoeff[self.dashlevel]['default'].keys(); self.dashlevel_citation = intf_dftd3.dashcoeff[self.dashlevel]['citation']; self.dashparams_citation = resolved['dashparams_citation']. engine = kwargs.pop('engine', None); if engine is None:; self.engine = _capable_engines_for_disp[self.dashlevel][0]; else:; if self.dashlevel in _engine_can_do[engine]:; self.engine = engine; else:; raise ValidationError(""""""This little engine ({}) can't ({})"""""".format(engine, self.dashlevel)). if self.engine == 'libdisp':; self.disp = core.Dispersion.build(self.dashlevel, **resolved['dashparams']). [docs] def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => %s: Empirical Dispersion <="" % (self.fctldash.upper() if self.fctldash.upper() else 'Custom')); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule):; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule : psi4.core.Molecule; System for which to compute empirical dispers",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/empirical_dispersion.html:5628,Validat,ValidationError,5628,psi4manual/1.3.2/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['Validat'],['ValidationError']
Security,"h energies are; provided, of length at least 5 and equal to the length of the energies array. :type energies: list; :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :type plot_fit: string; :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to 'screen' to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supported file types. :returns: (*dict*) Keys: ""re"", ""r0"", ""we"", ""wexe"", ""nu"", ""ZPVE(harmonic)"", ""ZPVE(anharmonic)"", ""Be"", ""B0"", ""ae"", ""De""; corresponding to the spectroscopic constants in cm-1; """""". angstrom_to_bohr = 1.0 / constants.bohr2angstroms; angstrom_to_meter = 10e-10;. # Make sure the input is valid; if len(rvals) != len(energies):; raise ValidationError(""The number of energies must match the number of distances""); npoints = len(rvals); if npoints < 5:; raise ValidationError(""At least 5 data points must be provided to compute anharmonicity""); core.print_out(""\n\nPerforming a fit to %d data points\n"" % npoints). # Make sure the molecule the user provided is the active one; molecule = mol if mol is not None else core.get_active_molecule(); molecule.update_geometry(); natoms = molecule.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = molecule.mass(0); m2 = molecule.mass(1). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n"");; re = np.mean(rvals); maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H;; if i == maxit-1:; raise Convergen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/diatomic.html:3825,Validat,ValidationError,3825,psi4manual/1.1.0/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/diatomic.html,6,['Validat'],['ValidationError']
Security,"h functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; from __future__ import print_function; from __future__ import absolute_import; import os; import re; import math; import pickle; import collections. from psi4.driver import constants; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`share/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html:2245,access,accessible,2245,psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,1,['access'],['accessible']
Security,"h(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); E0r, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Right Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); E_HOMOr = E_HOMO; core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); E1r = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Right Endpoint', **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r; kIPr = -E_HOMOr; delta_r = IPr - kIPr. if IPr > kIPr:; raise ValidationError(""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP: {} !> {}"""""".format(kIPr, IPr)). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Left endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_l). # Neutral; core.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0l, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Left Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); E_HOMOl = E_HOMO; core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; core.IO.ch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:18725,Validat,ValidationError,18725,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,4,['Validat'],['ValidationError']
Security,"h.shape:; dim1.append(0); dim2.append(0); else:; dim1.append(h.shape[0]); if ret_type == '2D':; dim2.append(h.shape[1]). ndim1 = np.sum(dim1); ndim2 = np.sum(dim2); if ret_type == '1D':; dense_ret = np.zeros(shape=(ndim1)); start = 0; for d1, arr in zip(dim1, matrix_views):; if d1 == 0: continue; dense_ret[start:start + d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, matrix_views):; if (d1 == 0) or (d2 == 0): continue. dense_ret[start1:start1 + d1, start2:start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; return _get_raw_views(matrix, copy=copy)[0]. @property; def _np_shape(self):; """"""; Shape of the Psi4 data object; """"""; view_data = _get_raw_views(self); if self.nirrep() > 1:; return tuple(view_data[x].shape for x in range(self.nirrep())); else:; return view_data[0].shape. @property; def _np_view(self):; """"""; View without only one irrep; """"""; if self.nirrep() > 1:; raise ValidationError(""Attempted to call .np on a Psi4 data object with multiple irreps.""; ""Please use .nph for objects with irreps.""); return _get_raw_views(self)[0]. @property; def _nph_view(self):; """"""; View with irreps.; """"""; return _get_raw_views(self). @property; def _array_conversion(self):; """"""; Provides the array interface to simply classes so that np.array(core.Matrix(5, 5)) works flawlessly.; """"""; if self.nirrep() > 1:; raise ValidationError(""__array__interface__ can only be called on Psi4 data object with only one irrep!""); else:; return self.np.__array_interface__. def _np_write(self, filename=None, prefix=""""):; """"""; Writes the irreped matrix to a NumPy zipped file. Can return the packed data for saving many matrices into the same file.; """""". ret = {}; ret[prefix + ""Irreps""] = self.nirrep(); ret[prefix + ""Name""] = self.name; for h, v in enumerate(self.nph):; # If returning arrays to user, we want to return copies (snapshot), not; # views of the core.Matrix's memory.; if filename is None",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html:7775,Validat,ValidationError,7775,psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,2,['Validat'],['ValidationError']
Security,"h][:] = ret_data[h]. return ret. def _to_serial(data):; """"""; Converts an object with a .nph accessor to a serialized dictionary; """""". json_data = {}; json_data[""shape""] = []; json_data[""data""] = []. for view in data.nph:; json_data[""shape""].append(view.shape); json_data[""data""].append(view.tostring()). if len(json_data[""shape""][0]) == 1:; json_data[""type""] = ""vector""; elif len(json_data[""shape""][0]) == 2:; json_data[""type""] = ""matrix""; else:; raise ValidationError(""_to_json is only used for vector and matrix objects.""). return json_data. def _from_serial(self, json_data):; """"""; Converts serialized data to the correct Psi4 data type; """""". if json_data[""type""] == ""vector"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); ret = self(""Vector from JSON"", dim1); elif json_data[""type""] == ""matrix"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); dim2 = core.Dimension.from_list([x[1] for x in json_data[""shape""]]); ret = self(""Matrix from JSON"", dim1, dim2); else:; raise ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.frombuffer(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs):; """"""; Chains dot products together from a series of Psi4 Matrix classes. By default there is no transposes, an optional vector of booleans can be passed in.; """""". trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[n + 1]). return ret. def _irrep_access(self, *args, **kwargs):; """"""; Warns user when iterating/accessing an irreped object.; """"""; raise ValidationError(""Attempted to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html:11233,Validat,ValidationError,11233,psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,4,['Validat'],['ValidationError']
Security,"h][:] = ret_data[h]. return ret. def _to_serial(data):; """"""; Converts an object with a .nph accessor to a serialized dictionary; """""". json_data = {}; json_data[""shape""] = []; json_data[""data""] = []. for view in data.nph:; json_data[""shape""].append(view.shape); json_data[""data""].append(view.tostring()). if len(json_data[""shape""][0]) == 1:; json_data[""type""] = ""vector""; elif len(json_data[""shape""][0]) == 2:; json_data[""type""] = ""matrix""; else:; raise ValidationError(""_to_json is only used for vector and matrix objects.""). return json_data. def _from_serial(self, json_data):; """"""; Converts serialized data to the correct Psi4 data type; """""". if json_data[""type""] == ""vector"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); ret = self(""Vector from JSON"", dim1); elif json_data[""type""] == ""matrix"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); dim2 = core.Dimension.from_list([x[1] for x in json_data[""shape""]]); ret = self(""Matrix from JSON"", dim1, dim2); else:; raise ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.fromstring(json_data[""data""][n], dtype=np.double). return ret. # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_serial = _to_serial; core.Matrix.from_serial = classmethod(_from_serial). # Vector attributes; core.Vector.from_array = classmethod(array_to_matrix); core.Vector.to_array = _to_array; core.Vector.shape = _np_shape; core.Vector.np = _np_view; core.Vector.nph = _nph_view; core.Vector.__array_interface__ = _array_conversion; core.Vector.np_write = _np_write; core.Vector.np_read = classmethod(_np_read); core.Vector.to_serial ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:12037,Validat,ValidationError,12037,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"h][:] = ret_data[h]. return ret. def _to_serial(data):; """"""; Converts an object with a .nph accessor to a serialized dictionary; """""". json_data = {}; json_data[""shape""] = []; json_data[""data""] = []. for view in data.nph:; json_data[""shape""].append(view.shape); json_data[""data""].append(view.tostring()). if len(json_data[""shape""][0]) == 1:; json_data[""type""] = ""vector""; elif len(json_data[""shape""][0]) == 2:; json_data[""type""] = ""matrix""; else:; raise ValidationError(""_to_json is only used for vector and matrix objects.""). return json_data. def _from_serial(self, json_data):; """"""; Converts serialized data to the correct Psi4 data type; """""". if json_data[""type""] == ""vector"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); ret = self(""Vector from JSON"", dim1); elif json_data[""type""] == ""matrix"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); dim2 = core.Dimension.from_list([x[1] for x in json_data[""shape""]]); ret = self(""Matrix from JSON"", dim1, dim2); else:; raise ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.fromstring(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs):; """"""; Chains dot products together from a series of Psi4 Matrix classes. By default there is no transposes, an optional vector of booleans can be passed in.; """""". trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.Matrix.doublet(ret, mat, False, trans[n + 1]). return ret. # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html:11415,Validat,ValidationError,11415,psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"handles delta corrections. Parameters; ----------; method_name : str; A ``""method/basis""`` style string defining the calculation. Returns; -------; tuple; Tuple in the ``(method_list, basis_list)`` format, where ``method_list``; is the list of the component methods, and ``basis_list`` is the list of; basis sets forming the extrapolation for each specified method.; E.g. ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""`` would return:; ``([""mp2"", ""ccsd(t)""], [""cc-pv[tq]z"", ""cc-pvtz""])``.; """""". method_name_list = re.split(r""""""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; func : function; Function to be called (energy, gradient, frequency or cbs).; total_method_name : str; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:64045,Validat,ValidationError,64045,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"harges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.molparse.from_arrays. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:22644,Validat,ValidationError,22644,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"harges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.5;  · . PSI4. Module code; qcelemental.molparse.from_arrays. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/qcelemental/molparse/from_arrays.html:22644,Validat,ValidationError,22644,psi4manual/1.5.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"has_option_changed('SCF', 'SCF_TYPE'):; core.set_local_option('SCF', 'SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e; sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True). # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(). if (core.get_option('SCF', 'REFERENCE') != 'RHF') and (name.upper() != ""SAPT0""):; raise ValidationError('Only SAPT0 supports a reference different from \""reference rhf\"".'). nfrag = sapt_dimer.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). do_delta_mp2 = True if name.endswith('dmp2') else False. sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if sapt_basis == 'dimer':; monomerA = sapt_dimer.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif sapt_basis == 'monomer':; monomerA = sapt_dimer.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2); monomerB.set_name('monomerB'). ri = core.get_option('SCF', 'SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:94243,Validat,ValidationError,94243,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"hat quacked; # like a list rather than the more common dict handled above. if; # ever again sighted, make an issue so this code can accommodate. _disp_functor.print_out(); return superfunc, _disp_functor. else:; return superfunc, None. [docs]; def scf_wavefunction_factory(name, ref_wfn, reference, **kwargs):; """"""Builds the correct (R/U/RO/CU HF/KS) wavefunction from the; provided information, sets relevant auxiliary basis sets on it,; and prepares any empirical dispersion. """"""; # Figure out functional and dispersion; superfunc, _disp_functor = build_functional_and_disp(name, restricted=(reference in [""RKS"", ""RHF""]), **kwargs). # Build the wavefunction; core.prepare_options_for_module(""SCF""); if reference in [""RHF"", ""RKS""]:; wfn = core.RHF(ref_wfn, superfunc); elif reference == ""ROHF"":; wfn = core.ROHF(ref_wfn, superfunc); elif reference in [""UHF"", ""UKS""]:; wfn = core.UHF(ref_wfn, superfunc); elif reference == ""CUHF"":; wfn = core.CUHF(ref_wfn, superfunc); else:; raise ValidationError(""SCF: Unknown reference (%s) when building the Wavefunction."" % reference). if _disp_functor and _disp_functor.engine != 'nl':; wfn._disp_functor = _disp_functor. # Set the DF basis sets; df_needed = core.get_global_option(""SCF_TYPE"") in [""DF"", ""MEM_DF"", ""DISK_DF"" ]; df_needed |= ""DFDIRJ"" in core.get_global_option(""SCF_TYPE""); df_needed |= (core.get_global_option(""SCF_TYPE"") == ""DIRECT"" and core.get_option(""SCF"", ""DF_SCF_GUESS"")); if df_needed:; aux_basis = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); wfn.set_basisset(""DF_BASIS_SCF"", aux_basis); else:; wfn.set_basisset(""DF_BASIS_SCF"", core.BasisSet.zero_ao_basis_set()). # Set the relativistic basis sets; if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; decon_basis = core.BasisSet.build(wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:40380,Validat,ValidationError,40380,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"he GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import math; import re; import sys; from typing import Callable, List. import numpy as np. from psi4 import core; from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver import driver_util; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list. zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }. def _expand_bracketed_basis(basisstring: str, molecule=None):; """"""Function to transform and validate basis series specification for cbs(). Parameters; ----------; basisstring; A string containing the basis sets to be expanded.; A basis set with no paired square brackets is passed through; with zeta level 0 (e.g., ``'6-31+G(d,p)'`` is returned as; ``([""6-31+G(d,p)""], [0])``). A basis set with square brackets is checked; for sensible sequence and returned as separate basis sets; (e.g., ``'cc-pV[Q5]Z'` is returned as ``([""cc-pVQZ"", ""cc-pV5Z""], [4, 5])``).; Allows out-of-order zeta specification (e.g., ``[qtd]``) and numeral for; number (e.g., ``[23]``). Does not allow skipped zetas (e.g., ``[dq]``), zetas; outside the [2,8] range, non-Dunning, non-Ahlrichs, or non-Jensen sets,; or non-findable .gbs sets.; molecule : qcdb.molecule or psi4.core.Molecule; This function checks that the basis is valid by trying to build; the qcdb.BasisSet object for *molecule* or for H2 if None. Returns; -------; tuple; Tuple in the ``([basis set names], [basis set zetas])`` fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:1929,validat,validate,1929,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['validat'],['validate']
Security,"he KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Advanced Functional Use and Manipulation¶; New DFT functionals can be created from scratch from within the input; file and accessed using the dft_functional keyword argument in the; energy call:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28# DFT Custom Functional. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis sto-3g; dft_spherical_points 302; dft_radial_points 99; reference rks; }. pbe0 = {; ""name"": ""my_PBE0"",; ""x_functionals"": {""GGA_X_PBE"": {""alpha"": 0.75}},; ""x_hf"": {""alpha"": 0.25},; ""c_functionals"": {""GGA_C_PBE"": {}}; }. func_call = energy('SCF', dft_functional=pbe0). # as PBE0 is a pre-defined functional, the call above is equivalent to both below:; func_call = energy('SCF', dft_functional=""PBE0""); func_call = energy('PBE0'). Supported keywords include:. name: string, name of the functional. for custom defined functionals used for printing only.; xc_functionals: dict, definition of a complete (X + C) functional based in LibXC name; x_functionals: dict, definition of exchange functionals using LibXC names; c_functionals: dict, definition of correlation functionals",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:27279,access,accessed,27279,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,2,['access'],['accessed']
Security,"he active molecule; scf_molecule.update_geometry(); core.print_out(""""""\n A requested method does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n\n""""""); c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); c1_basis = core.BasisSet.build(c1_molecule, ""ORBITAL"", core.get_global_option('BASIS'), quiet=True); tmp = scf_wfn.c1_deep_copy(c1_basis); if not scf_wfn.has_variable(""-D ENERGY""):; tmp.del_variable(""-D ENERGY""); c1_jkbasis = core.BasisSet.build(c1_molecule, ""DF_BASIS_SCF"",; core.get_global_option(""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'), quiet=True); tmp.set_basisset(""DF_BASIS_SCF"", c1_jkbasis); c1_optstash.restore(); return tmp. def run_dct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant theory calculation. """""". if (core.get_global_option('FREEZE_CORE') == 'TRUE'):; raise ValidationError('Frozen core is not available for DCT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). if (core.get_global_option(""DCT_TYPE"") == ""DF""):; core.print_out("" Constructing Basis Sets for DCT...\n\n""); aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_DCT"",; core.get_global_option(""DF_BASIS_DCT""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_DCT"", aux_basis). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis); dct_wfn = core.dct(ref_wfn). else:; # Ensure IWL files have been written for non DF-DCT; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); dct_wfn = core.dct(ref_wfn). for k, v in dct_wfn.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:59760,Validat,ValidationError,59760,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"he copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for use in input files."""""". import os; import re; import sys; import math; import warnings. import numpy as np. from psi4 import core; from .exceptions import ValidationError, TestComparisonError. [docs]def oeprop(wfn, *args, **kwargs):; """"""Evaluate one-electron properties. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. :type title: string; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html:1273,Validat,ValidationError,1273,psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security,"he ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exported via Boost Python) documented thereat; are accessible through the handle option_molecule_name in; molecule optional_molecule_name {...}. The molecular geometry can be got and set and manipulated as a; psi4.Matrix object. Below shows how to access; coordinates in an input file in Python.; molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms as Python array. geom2psi = psi4.Matrix(4, 3) # initialize psi4.Matrix; geom2psi.set(geom2py) # load Python array into psi4.Matrix; geom2psi.scale(1.0/psi_bohr2angstroms) # scale into bohr; geom2psi.print_out() # print alternate coord array to output file. formaldehyde.set_geometry(geom2psi) # load alternate c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:16135,access,access,16135,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,2,['access'],['access']
Security,"he irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. save(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Save the vector to disk. scale(self: psi4.core.Vector, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns; Returns either a list of np.array’s or the base array depending on options. Return type; numpy.ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. vector_dot(self: psi4.core.Vector, other: psi4.core.Vector) → float¶; Take the dot product of two vectors. zero(self: psi4.core.Vector) → None¶; Zeros the vector. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; Vector. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Vector.html:5847,access,accessor,5847,psi4manual/1.6.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Vector.html,1,['access'],['accessor']
Security,"he order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def set_basisset(self, name, role='BASIS'):; """"""Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. """"""; self.PYbasissets[role] = name. [docs] def basisset(self, role='BASIS'):; """"""Returns the basis name for the provided type.; * @param type Keyword from input file.; * @returns the value from input. """"""; try:; return self.PYbasissets[role]; except ValueError:; raise ValidationError('CoordEntry::basisset: Basisset not set for %s and type of %s' % \; (self.PYlabel, role)). [docs] def basissets(self):; """"""Returns basisset to atom map""""""; return self.PYbasissets. [docs] def set_shell(self, bshash, key='BASIS'):; """"""Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. """"""; self.PYshells[key] = bshash. [docs] def shell(self, key='BASIS'):; """"""Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. """"""; try:; return self.PYshells[key]; except (ValueError, KeyError):; raise ValidationError('CoordEntry::shells: Shells not set for %s and type of %s' % \; (self.PYlabel, key)). [docs] def shells(self):; """"""Returns shells sets to atom map""""""; return self.PYshells. [docs] def everything(self):; print('\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n Basissets = %s\n\n Shells = %s\n\n' %; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """""". def __init__(self, entry_number, Z, charge, mass, symb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:10691,hash,hash,10691,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['hash'],['hash']
Security,"he system. :type properties: array of strings; :param properties: |dl| ``[]`` |dr| || ``['rotation', 'polarizability', 'oscillator_strength', 'roa']`` || etc. Indicates which properties should be computed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['property'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) |; +-------------------------+---------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:32695,Validat,ValidationError,32695,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"he user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); core.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for unsupported calls; if ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype != None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; stage['scheme'] = kwargs.pop('scf_scheme'); stage['stage'] = ""scf""; stage['treatment'] = ""scf""; else:; # _validate_cbs_inputs will produce scf stage automatically; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'corl_scheme' in kwargs:; stage['scheme'] =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:64895,Validat,ValidationError,64895,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"he; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; 1; 2; 3; 4; 5; 6; 7mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle option_molecule_name in; molecule optional_molecule_name {...}. The molecular geometry can be got and set and manipulated as a; Matrix object. Below shows how to access; coordinates in an input file in Python.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:16988,access,accessible,16988,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['access'],['accessible']
Security,"hemistry software package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys; from typing import List, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(self, arr: Union[np.ndarray, List[np.ndarray]], name: str = ""New Matrix"", dim1: Union[List, Tuple, core.Dimension] = None, dim2: core.Dimension = None) -> Union[core.Matrix, core.Vector]:; """"""; Converts a numpy array or list of numpy arr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:1246,Validat,ValidationError,1246,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,2,['Validat'],['ValidationError']
Security,"hemistry software package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys; from typing import List, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(self, arr: Union[np.ndarray, List[np.ndarray]], name: str = ""New Matrix"", dim1: Union[List, Tuple, core.Dimension] = None, dim2: core.Dimension = None) -> Union[core.Matrix, core.Vector]:; """"""; Converts a numpy array or list of numpy arr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/numpy_helper.html:1246,Validat,ValidationError,1246,psi4manual/1.6.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"her parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for FCHK files."""""". import re; import numpy as np; from psi4.driver.p4util.testing import compare_strings, compare_arrays, compare_values, compare_integers; from psi4 import core; from .exceptions import ValidationError. __all__ = ['fchkfile_to_string','compare_fchkfiles', ""compare_moldenfiles""]. def _consume_fchk_section(input_list, index):; """"""compare a float or integer matrix section"""""". n = int(input_list[index].split()[-1]); kind = input_list[index].split()[-3]. if ""R"" in kind:; dtype = np.float64; format_counter = 5; elif ""I"" in kind:; dtype = np.float64; format_counter = 6; else:; raise ValidationError('Unknow field type in FCHK reader\n'). extra = 0 if n <= format_counter else n % format_counter; lines = 1 if n <= format_counter else int(n / format_counter); offset = lines + 1 if extra > 0 else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. [docs]def fchkfile_to_string(fname):; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = han",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fchk.html:1341,Validat,ValidationError,1341,psi4manual/1.6.x/_modules/psi4/driver/p4util/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fchk.html,1,['Validat'],['ValidationError']
Security,"her, missing slots are filled with `None` for later processing. """"""; if fragment_separators is None:; if fragment_charges is None and fragment_multiplicities is None:; frs = [] # np.array([], dtype=int) # if empty, needs to be both ndarray and int; frc = [None]; frm = [None]; else:; raise ValidationError(; """"""Fragment quantities given without separation info: sep ({}), chg ({}), and mult ({})"""""".format(; fragment_separators, fragment_charges, fragment_multiplicities; ); ); else:; trial_geom = np.zeros((nat, 3)); try:; split_geom = np.split(trial_geom, fragment_separators, axis=0); except TypeError:; raise ValidationError(; """"""fragment_separators ({}) unable to perform trial np.split on geometry."""""".format(fragment_separators); ); if any(len(f) == 0 for f in split_geom):; if nat != 0:; raise ValidationError(; """"""fragment_separators ({}) yields zero-length fragment(s) after trial np.split on geometry."""""".format(; split_geom; ); ); if sum(len(f) for f in split_geom) != nat:; raise ValidationError(; """"""fragment_separators ({}) yields overlapping fragment(s) after trial np.split on geometry, possibly unsorted."""""".format(; split_geom; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:21253,Validat,ValidationError,21253,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % metadata['ptype']). if metadata['return_total_data'] is None:; if metadata['ptype'] in ['gradient', 'hessian']:; metadata['return_total_data'] = True; else:; metadata['return_total_data'] = False. # Parse bsse_type, raise exception if not provided or unrecognized; metadata['bsse_type_list'] = kwargs.pop('bsse_type'); if metadata['bsse_type_list'] is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(metadata['bsse_type_list'], list):; metadata['bsse_type_list'] = [metadata['bsse_type_list']]. for num, btype in enumerate(metadata['bsse_type_list']):; metadata['bsse_type_list'][num] = btype.lower(); if btype.lower() not in ['cp', 'nocp', 'vmfc']:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). metadata['max_nbody'] = kwargs.get('max_nbody', -1); if metadata['molecule'].nfragments() == 1:; raise ValidationError(""N-Body requires active molecule to have more than 1 fragment.""); metadata['max_frag'] = metadata['molecule'].nfragments(); if metadata['max_nbody'] == -1:; metadata['max_nbody'] = metadata['molecule'].nfragments(); else:; metadata['max_nbody'] = min(metadata['max_nbody'], metadata['max_frag']). # Flip this off for now, needs more testing; # If we are doing CP lets save them integrals; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # # Set to save RI integrals for repeated full-basis computations; # ri_ints_io = core.get_global_option('DF_INTS_IO'). # # inquire if above at all applies to dfmp2 or just scf; # core.set_global_option('DF_INTS_IO', 'SAVE'); # psioh = core.IOManager.shared_object(); # psioh.set_specific_retention(97, True). bsse_str = metadata['bsse_type_list'][0]; if len(metadata['bsse_type_list']) > 1:; bsse_str = str(metadata['bsse_type_list']); core.print_out(""\n\n""); core.print_out("" ===> N-Body Interaction Abacus <===\n""); core.print_out("" BSSE Treatment: %s\n"" % b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:8897,Validat,ValidationError,8897,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['Validat'],['ValidationError']
Security,"hf':; PsiMod.set_local_option('SCF', 'REFERENCE', 'ROHF'); elif lowername == 'rscf':; if (len(PsiMod.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); else:; PsiMod.set_local_option('SCF', 'REFERENCE', 'RHF'); elif lowername == 'uscf':; if (len(PsiMod.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); else:; PsiMod.set_local_option('SCF', 'REFERENCE', 'UHF'); elif lowername == 'roscf':; if (len(PsiMod.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; raise ValidationError('ROHF reference for DFT is not available.'); else:; PsiMod.set_local_option('SCF', 'REFERENCE', 'ROHF'); ; if 'brokensymmetry' in kwargs:; molecule = PsiMod.get_active_molecule(); multp = molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if PsiMod.get_option('SCF','REFERENCE') != 'UHF' and lowername != 'UHF':; raise ValidationError('You must specify ""set reference uhf"" to use broken symmetry.'); molecule.set_multiplicity(3); PsiMod.print_out(""\n\n\tComputing high-spin triplet guess\n\n""); scf_helper(name, **kwargs); molecule.set_multiplicity(1); PsiMod.set_local_option('SCF', 'GUESS', 'READ'); PsiMod.print_out(""\n\n\tComputing broken symmetry solution from high-spin triplet guess\n\n""); ; returnvalue = scf_helper(name, **kwargs); ; optstash.restore(); return returnvalue. [docs]def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """"""; optstash = OptionsState(; ['DF_BASIS_SCF']). returnvalue = run_scf(name, **kwargs). if (PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF'):. # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:3740,Validat,ValidationError,3740,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"hifting to C1 so we need to copy the active molecule; sapt_dimer = sapt_dimer.clone(); if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(); else:; sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e; sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True). nfrag = sapt_dimer.nfragments(). if nfrag == 3:; # Midbond case; if sapt_basis == 'monomer':; raise ValidationError(""SAPT basis cannot both be monomer centered and have midbond functions.""). midbond = sapt_dimer.extract_subsets(3); ztotal = 0; for n in range(midbond.natom()):; ztotal += midbond.Z(n). if ztotal > 0:; raise ValidationError(""SAPT third monomer must be a midbond function (all ghosts).""). ghosts = ([2, 3], [1, 3]); elif nfrag == 2:; # Classical dimer case; ghosts = (2, 1); else:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). if sapt_basis == 'dimer':; monomerA = sapt_dimer.extract_subsets(1, ghosts[0]); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, ghosts[1]); monomerB.set_name('monomerB'); elif sapt_basis == 'monomer':; monomerA = sapt_dimer.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2); monomerB.set_name('monomerB'); else:; raise ValidationError(""SAPT basis %s not recognized"" % sapt_basis). return (sapt_dimer, monomerA, monomerB). def sapt_empirical_dispersion(name, dimer_wfn, **kwargs):; sapt_dimer = dimer_wfn.molecule(); sapt_dimer, monomerA, monomerB = prepare_sapt_molecule(sapt_dimer, ""dimer""); disp_name = name.split(""-"")[1]. # Get the names right between SAPT0 and FISAPT0; saptd_name = name.split('-')[0].upper(); if saptd_name == ""SAPT0"":; sapt0_name = ""SAPT0""; else:; sapt0_name = ""SAPT"". save_pair = (saptd_name == ""FISAPT0""). fr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:7725,Validat,ValidationError,7725,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,3,['Validat'],['ValidationError']
Security,"hmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:36444,Validat,ValidationError,36444,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"hod_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:40374,Sanitiz,Sanitize,40374,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['Sanitiz'],['Sanitize']
Security,"hon.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshift__(y) <==> x<<y; | ; | __mod__(...); | x.__mod__(y) <==> x%y; | ; | __mul__(...); | x.__mul__(y) <==> x*y; | ; | __neg__(...); | x.__neg__() <==> -x; | ; | __nonzero__(...); | x.__nonzero__() <==> x != 0; | ; | __oct__(...); | x.__oct__() <==> oct(x); | ; | __or__(...); | x.__or__(y) <==> x|y; | ; | __pos__(...); | x.__pos__() <==> +x; | ; | __pow__(...); | x.__pow__(y[, z]) <==> pow(x, y[, z]); | ; | __radd__(...); | x.__radd__(y) <==> y+x; | ; | __rand__(...); | x.__rand__(y) <==> y&x; | ; | __rdiv__(...); | x.__rdiv__(y) <==> y/x; | ; | __rdivmod__(...); | x.__rdivmod__(y) <==> divmod(y, x); | ; | __rfloordiv__(...); | x.__rfloordiv__(y) <==> y//x; | ; | __rlshift__(...); | x.__rlshift__",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:11151,hash,hash,11151,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,22,['hash'],['hash']
Security,"horde[name.upper()] = anon; if set_option:; core.set_global_option(key, name). core.OEProp.valid_methods = [; 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES',; 'MBIS_CHARGES','MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS'; ]. ## Option helpers. def _core_set_global_option_python(key, EXTERN):; """"""; This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul.; """"""; if (key != ""EXTERN""):; raise ValidationError(""Options: set_global_option_python does not recognize keyword %s"" % key). if EXTERN is None:; core.EXTERN = None; core.set_global_option(""EXTERN"", False); elif isinstance(EXTERN, core.ExternalPotential):; # Well this is probably the worst hack I have done, thats saying something; core.EXTERN = EXTERN; core.set_global_option(""EXTERN"", True); else:; raise ValidationError(""Options: set_global_option_python can either be a NULL or External Potential object""). core.set_global_option_python = _core_set_global_option_python. ## QCvar helps. _qcvar_transitions = {; # old: (replacement, release after next); ""SCSN-MP2 CORRELATION ENERGY"": (""SCS(N)-MP2 CORRELATION ENERGY"", 1.5),; ""SCSN-MP2 TOTAL ENERGY"": (""SCS(N)-MP2 TOTAL ENERGY"", 1.5),; ""MAYER_INDICES"": (""MAYER INDICES"", 1.5),; ""WIBERG_LOWDIN_INDICES"": (""WIBERG LOWDIN INDICES"", 1.5),; ""LOWDIN_CHARGES"": (""LOWDIN CHARGES"", 1.5),; ""MULLIKEN_CHARGES"": (""MULLIKEN CHARGES"", 1.5),; ""(AT) CORRECTION ENERGY"": (""A-(T) CORRECTION ENERGY"", 1.5),; ""CCSD(AT) TOTAL ENERGY"": (""A-CCSD(T) TOTAL ENERGY"", 1.5),; ""CCSD(AT) CORRELATION ENERGY"": (""A-CCSD(T) CORRELATION ENERGY"", 1.5),; ""CP-CORRECTED 2-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""CP-CORRECTED 3-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""CP-CORRECTED 4-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:18349,Validat,ValidationError,18349,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,5,['Validat'],['ValidationError']
Security,"hould translations be projected in the harmonic analysis?; project_rot : boolean; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : dict; A dictionary of vibrational information. See :py:func:`~psi4.driver.qcdb.vib.harmonic_analysis`; """""". if hess is None:; nmwhess = np.asarray(wfn.hessian()); else:; nmwhess = hess. dipder = wfn.variables().get(""CURRENT DIPOLE GRADIENT"", None); if dipder is not None:; dipder = np.asarray(dipder).T. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False), 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(; nmwhess, geom, m, wfn.basisset(), irrep_labels, dipder=dipder, project_trans=project_trans, project_rot=project_rot); vibrec.update({k: qca.to_dict() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:75480,Validat,ValidationError,75480,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"i += 1; else:; if line.split()[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; temp = dfile.readline(); dashdderiv.append([float(x.replace('D', 'E')) for x in temp.split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())); psi_dashdderiv = PsiMod.Matrix(self.natom(), 3); psi_dashdderiv.set(dashdderiv). # Print program output to file if verbose; verbose = PsiMod.get_option('SCF', 'PRINT'); if verbose >= 3:; PsiMod.print_out('\n ==> DFTD3 Output <==\n'); PsiMod.print_out(out); dfile = open(derivfile, 'r'); PsiMod.print_out(dfile.read().replace('D', 'E')); dfile.close(); PsiMod.print_out('\n'). # Clean up files and remove scratch directory; os.unlink(paramfile); os.unlink(geomfile); os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); try:; shutil.rmtree(dftd3_tmpdir); except OSError as e:; ValidationError('Unable to remove dftd3 temporary directory %s' % e, file=sys.stderr); os.chdir(current_directory). # return -D & d(-D)/dx; PsiMod.set_variable('DISPERSION CORRECTION ENERGY', dashd); if dertype == -1:; return dashd, dashdderiv; elif dertype == 0:; return dashd; elif dertype == 1:; return psi_dashdderiv. [docs]def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the PsiMod.Molecule class. """"""; cls.__setattr__ = new_set_attr; cls.__getattr__ = new_get_attr; cls.BFS = BFS; cls.run_dftd3 = run_dftd3. dynamic_variable_bind(PsiMod.Molecule) # pass class type, not class instance. #; # Define geometry to be used by PSI4.; # The molecule created by this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name*; from the geometry in string *geom*. """"""; molecule = PsiMod.Molecule.create_molecule_from_string(geom); molecule.set_name(na",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:11761,Validat,ValidationError,11761,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"i4.DiagonalizeOrder.Descending. names = {‘Ascending’: psi4.DiagonalizeOrder.Ascending, ‘Descending’: p... values = {1: psi4.DiagonalizeOrder.Ascending, 3: psi4.DiagonalizeOrder... ———————————————————————-. Methods inherited from Boost.Python.enum:. __repr__(...). x.__repr__() <==> repr(x). __str__(...). x.__str__() <==> str(x). ———————————————————————-. Data descriptors inherited from Boost.Python.enum:. name. ———————————————————————-. Methods inherited from __builtin__.int:. __abs__(...). x.__abs__() <==> abs(x). __add__(...). x.__add__(y) <==> x+y. __and__(...). x.__and__(y) <==> x&y. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __coerce__(...). x.__coerce__(y) <==> coerce(x, y). __div__(...). x.__div__(y) <==> x/y. __divmod__(...). x.__divmod__(y) <==> divmod(x, y). __float__(...). x.__float__() <==> float(x). __floordiv__(...). x.__floordiv__(y) <==> x//y. __format__(...). __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getnewargs__(...). __hash__(...). x.__hash__() <==> hash(x). __hex__(...). x.__hex__() <==> hex(x). __index__(...). x[y:z] <==> x[y.__index__():z.__index__()]. __int__(...). x.__int__() <==> int(x). __invert__(...). x.__invert__() <==> ~x. __long__(...). x.__long__() <==> long(x). __lshift__(...). x.__lshift__(y) <==> x<<y. __mod__(...). x.__mod__(y) <==> x%y. __mul__(...). x.__mul__(y) <==> x*y. __neg__(...). x.__neg__() <==> -x. __nonzero__(...). x.__nonzero__() <==> x != 0. __oct__(...). x.__oct__() <==> oct(x). __or__(...). x.__or__(y) <==> x|y. __pos__(...). x.__pos__() <==> +x. __pow__(...). x.__pow__(y[, z]) <==> pow(x, y[, z]). __radd__(...). x.__radd__(y) <==> y+x. __rand__(...). x.__rand__(y) <==> y&x. __rdiv__(...). x.__rdiv__(y) <==> y/x. __rdivmod__(...). x.__rdivmod__(y) <==> divmod(y, x). __rfloordiv__(...). x.__rfloordiv__(y) <==> y//x. __rlshift__(...). x.__rlshift__(y) <==> y<<x. __rmod__(...). x.__rmod__(y) <==> y%x. __rmul__(...). x.__rmul__(y) <==> y*x. __ror__(...). x.__ror__(y) <==> y|x. __rpow__(...). y.__rpo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:107632,hash,hash,107632,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['hash'],['hash']
Security,"i4.Molecule):; # called on a python export of a psi4.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:3453,Validat,ValidationError,3453,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"i4.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float or ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ----------. .. [2] Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_truhlar_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI**(-1 * alpha) - zLO**(-1 * alpha)); beta_mult = zHI**(-1 * alpha). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:7900,Validat,ValidationError,7900,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Validat'],['ValidationError']
Security,"i4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : ~typing.Dict[str, ~numpy.ndarray]; A dictionary of vibrational information. See :py:func:`~psi4.driver.qcdb.vib.harmonic_analysis`. """""". if hess is None:; nmwhess = np.asarray(wfn.hessian()); else:; nmwhess = hess. dipder = wfn.variables().get(""CURRENT DIPOLE GRADIENT"", None); if dipder is not None:; dipder = np.asarray(dipder).T. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False), 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess,; geom,; m,; wfn.basisset(),; irrep_labels,; dipder=dipder,; project_trans=project_trans,; project_rot=project_rot); vib",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:89702,Validat,ValidationError,89702,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['Validat'],['ValidationError']
Security,"i4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting.dft import functionals, build_superfunctional_from_dictionary; from psi4.driver.procrouting.sapt import fisapt_proc. def scf_set_reference_local(name, is_dft=False):; """"""; Figures out the correct SCF reference to set locally; """""". optstash = p4util.OptionsState(['SCF_TYPE'], ['SCF', 'REFERENCE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Alter reference name if needed; user_ref = core.get_option('SCF', 'REFERENCE'). sup = build_superfunctional_from_dictionary(functionals[name], 1, 1, True)[0]; if sup.needs_xc() or is_dft:; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop, oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.ba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:2236,Validat,ValidationError,2236,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,3,['Validat'],['ValidationError']
Security,"i4.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:71373,Validat,ValidationError,71373,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"i4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf_gradient(name, **kwargs). optstash.restore(). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). user_ref = psi4.get_option('DETCI', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'ROHF'):; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if (name.lower() == 'zapt'):; psi4.set_local_option('TRANSQT2', 'WFN', 'ZAPTN'); psi4.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; psi4.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif (name.lower() == 'detci-mp') or (name.lower() == 'mp'):; psi4.set_local_option('TRANSQT2', 'WFN', 'DETCI'); psi4.set_local_option('DETCI', 'WFN', 'DETCI'); psi4.set_local_option('DETCI', 'MPN', 'TRUE'). level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; psi4.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif (name.lower() == 'fci'):; psi4.set_local",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:40736,Validat,ValidationError,40736,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"i4/issues/1677. Caution; August 2021, the number of frozen core orbitals used in the dMP2 computations; is now standardized. Specifically, we now rigorously enforce that the number of core orbitals; frozen in dimer computations is equal to the sum of frozen orbitals of each monomer. Prior to; this, a discrepency between these values was possible when one of the monomers was (exclusively); a charged alkali metal. Caution; May 2022 c. v1.6, the default for DF_BASIS_ELST; changed from the value of DF_BASIS_SAPT (which itself; defaults to the RI of the orbital basis) to the JKFIT of the orbital; basis. This affects SAPT0 and sSAPT0 computed with the SAPT; module (the default code for energy(""sapt0"") that; can also compute higher-order SAPT). Electostatics, exchange,; and induction terms for SAPT0 and sSAPT0 accessed through; energy(""sapt0"") or energy(""ssapt0"") change; the dispersion; term does not change. The SAPT0 and sSAPT0 terms accessed as; subsidiary calculations of higher-order SAPT do not change; that is,; the SAPT module breaks the consistency of its SAPT0; results. The reasoning and reward behind this change is that the JKFIT; basis better describes the physics (see fitting changes ) and the; default SAPT0 results from the SAPT module are now; consistent with those from the FISAPT module and; the sapt(dft) module. See sapt-compare for an example.; To reproduce former behavior, set DF_BASIS_ELST to the; orbital basis set’s RI auxiliary basis. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sapt.html:2482,access,accessed,2482,psi4manual/master/sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/sapt.html,5,['access'],['accessed']
Security,"i4OptionsTools); option_with_print(BUILD_SHARED_LIBS ""Build internally built Psi4 add-on libraries as shared, not static"" OFF); option_with_print(ENABLE_OPENMP ""Enables OpenMP parallelization"" ON); option_with_print(ENABLE_AUTO_BLAS ""Enables CMake to auto-detect BLAS"" ON); option_with_print(ENABLE_AUTO_LAPACK ""Enables CMake to auto-detect LAPACK"" ON); option_with_print(ENABLE_PLUGIN_TESTING ""Test the plugin templates build and run"" OFF); option_with_flags(ENABLE_XHOST ""Enables processor-specific optimization"" ON; ""-xHost"" ""-march=native""); option_with_flags(ENABLE_CODE_COVERAGE ""Enables details on code coverage"" OFF; ""-ftest-coverage""); option_with_flags(ENABLE_BOUNDS_CHECK ""Enables bounds check in Fortran"" OFF; ""-ftrapuv -check all -fpstkchk"" ""-fcheck=all"" ""-fbounds-check -fcheck-array-temporaries""); option_with_flags(ENABLE_ASAN ""Enables address sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=address -fno-omit-frame-pointer""); option_with_flags(ENABLE_TSAN ""Enables thread sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=thread -fPIE -pie -fno-omit-frame-pointer""); option_with_flags(ENABLE_UBSAN ""Enables undefined behavior sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=undefined -fno-omit-frame-pointer""); option_with_flags(ENABLE_MSAN ""Enables memory sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=memory -fPIE -pie -fno-omit-frame-pointer""); option_with_default(MAX_AM_ERI ""Maximum angular momentum for integrals"" 5); option_with_default(CMAKE_BUILD_TYPE ""Build type (Release or Debug)"" Release); option_with_default(FC_SYMBOL ""The type of Fortran name mangling"" 2); option_with_default(BUILD_FPIC ""Compile static libraries with position independent code"" ON); option_with_default(CMAKE_INSTALL_LIBDIR ""Directory to which libraries installed"" lib); option_with_default(PYMOD_INSTALL_LIBDIR ""Location within CMAKE_INSTALL_LIBDIR to which python modules are installed"" /).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:15934,sanitiz,sanitizer,15934,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,6,['sanitiz'],['sanitizer']
Security,"iable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = psi4.sapt(). optstash.restore(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = psi4.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.fix_com(True) # This should always have been set, very dangerous bug here; molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; #molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; #molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SCF', 'SAPT', '2-dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'); if (sapt_basis == 'dimer'):; psi4.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:49126,Validat,ValidationError,49126,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"iable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():. # throw exception for CONV/CD MP2; if (mp2_type := core.get_global_option(""MP2_TYPE"")) != ""DF"":; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:80978,Validat,ValidationError,80978,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"iables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int) → str¶; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]¶; Exports coordinate info into NumPy arrays. Parameters:. dummy (bool) – Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool) – Whether or not to treat ghost atoms as dummies. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns:. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]¶; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with cur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:37939,hash,hash,37939,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,4,['hash'],['hash']
Security,"ian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p] = contraction. # Do the other contraction; contraction = float(what.group(3)). # Scale the contraction and save the information; contraction *= scale; contractions2[p] = contraction. shell_list.append(ShellInfo(am1, contractions1, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); shell_list.append(ShellInfo(am2, contractions2, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to parse basis sets with spd, or higher grouping""""""); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Expected shell information, but got: line %d: %s"""""" % (lineno, line)); line = lines[lineno]; lineno += 1. break. if not found:; #raise BasisSetNotFound(""Gaussian94BasisSetParser::parser: Unable to find the basis set for %s in %s"" % \; # (symbol, self.filename), silent=True); return None, None. return shell_list, msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:7964,Validat,ValidationError,7964,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,2,['Validat'],['ValidationError']
Security,"ible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False, label='electronic energy'):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.strip().split(None, 10); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if label == 'electronic energy' and s[8:10] == ['electron",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:8459,Validat,ValidationError,8459,psi4manual/1.0.0/_modules/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html,1,['Validat'],['ValidationError']
Security,"ibmintsbasisset.basishorde[name.upper()] = anon; if set_option:; core.set_global_option(key, name). core.OEProp.valid_methods = [; 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES',; 'MBIS_CHARGES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS'; ]. ## Option helpers. def _core_set_global_option_python(key, EXTERN):; """"""; This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul.; """"""; if (key != ""EXTERN""):; raise ValidationError(""Options: set_global_option_python does not recognize keyword %s"" % key). if EXTERN is None:; core.EXTERN = None; core.set_global_option(""EXTERN"", False); elif isinstance(EXTERN, core.ExternalPotential):; # Well this is probably the worst hack I have done, thats saying something; core.EXTERN = EXTERN; core.set_global_option(""EXTERN"", True); else:; raise ValidationError(""Options: set_global_option_python can either be a NULL or External Potential object""). core.set_global_option_python = _core_set_global_option_python. ## QCvar helps. _qcvar_transitions = {; ""SCSN-MP2 CORRELATION ENERGY"": ""SCS(N)-MP2 CORRELATION ENERGY"",; ""SCSN-MP2 TOTAL ENERGY"": ""SCS(N)-MP2 TOTAL ENERGY"",; ""MAYER_INDICES"": ""MAYER INDICES"",; ""WIBERG_LOWDIN_INDICES"": ""WIBERG LOWDIN INDICES"",; ""LOWDIN_CHARGES"": ""LOWDIN CHARGES"",; ""MULLIKEN_CHARGES"": ""MULLIKEN CHARGES"",; ""(AT) CORRECTION ENERGY"": ""A-(T) CORRECTION ENERGY"",; ""CCSD(AT) TOTAL ENERGY"": ""A-CCSD(T) TOTAL ENERGY"",; ""CCSD(AT) CORRELATION ENERGY"": ""A-CCSD(T) CORRELATION ENERGY"",; }. _qcvar_cancellations = {; ""SCSN-MP2 SAME-SPIN CORRELATION ENERGY"": [""MP2 SAME-SPIN CORRELATION ENERGY""],; ""SCSN-MP2 OPPOSITE-SPIN CORRELATION ENERGY"": [""MP2 OPPOSITE-SPIN CORRELATION ENERGY""],; ""SCS-CCSD SAME-SPIN CORRELATION ENERGY"": [""CCSD SAME-SPIN CORRELATION ENERGY""],; ""SCS-CCSD OPPOSITE-SPIN CORRELATION ENERGY"": [""CCSD OPPOSITE-SPIN CORRELATION ENERGY""],; """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:18266,Validat,ValidationError,18266,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"ibuteError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:13006,Validat,ValidationError,13006,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,11,['Validat'],['ValidationError']
Security,"ibutions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of the same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; different BLAS and LAPACK libraries, but its ability to do this; automatically depends on a number of factors, including correspondence; between the compiler used for PSI4 and the compiler used to build; BLAS/LAPACK, placement of the libraries in commonly searched directories,; etc. PSI4’s configure script will find your BLAS and LAPACK if any of the; the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:21783,access,access,21783,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,2,['access'],['access']
Security,"ibutions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well.; If you prefer to use the ACML; (http://developer.amd.com/tools/cpu-development/amd-core-math-library-acml/); we highly recommend using the latest version. Older versions; of ACML have been known to cause problems. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of the same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; different BLAS and LAPACK libraries, but its ability to do this; automatically depends on a number of factors, including correspondence; betwee",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:21549,access,access,21549,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,1,['access'],['access']
Security,"icense along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; Module with database functionality. """""". __all__ = [; ""database"",; ""db"",; ""DB_RGT"",; ""DB_RXN"",; ]. import collections; import math; import os; import re; import sys. from psi4 import core; from psi4.driver import constants; from psi4.driver import p4util; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]; def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:2034,access,accessible,2034,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,1,['access'],['accessible']
Security,"icense as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]; def array_to_matrix(; self: Union[core.Matrix, core.Vector],; arr: Union[np.ndarray, List[np.ndarray]],; name: str = ""New Matrix"",; dim1: Optional[Union[List, Tuple, core.Dimension]] = None,; dim2: Optional[core.Dimension] = None,; ) -> Union[core.Matrix,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html:1579,Validat,ValidationError,1579,psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,2,['Validat'],['ValidationError']
Security,"ich; is printed below and passed on to Optking.; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Cfour c4-scf Gradient Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. ... Irrep: 1 Size: 4 x 3. 1 2 3. 1 0.0000000 -0.0122978 0.0000000; 2 -0.0051192 0.0040993 -0.0088667; 3 -0.0051192 0.0040993 0.0088667; 4 0.0102384 0.0040993 0.0000000. CFOUR scratch file GRD has been read; 4 0.0000000000; 7.0000000000 -0.0880964705 0.0000000000 0.0000000000; 1.0000000000 0.4080144050 -0.9178691296 -1.5897959670; 1.0000000000 0.4080144050 -0.9178691296 1.5897959670; 1.0000000000 0.4080144050 1.8357382590 0.0000000001; 7.0000000000 -0.0122978407 0.0000000000 0.0000000000; 1.0000000000 0.0040992802 -0.0051191833 -0.0088666856; 1.0000000000 0.0040992802 -0.0051191833 0.0088666856; 1.0000000000 0.0040992802 0.0102383666 0.0000000000. The gradient can also be accessed from the input file as a; Matrix object through; psi4.core.get_gradient().; Cfour Files; The contents of all files associated with Cfour are accessible from the; input file through the Python dictionary P4C4_INFO. That is,; P4C4_INFO['zmat'] returns a string of the input file sent to Cfour.; Accessible arguments are zmat, output, and any that have been; produced of grd. For example, to print to the screen if CC convergence; is reached, the following could be placed in the PSI4 input file.; energy('c4-ccsd'); print 'miracle?', 'miracle' in P4C4_INFO['output']. Scratch Files; By default, a separate subdirectory for each Cfour call is created within; the job’s scratch directory. To explicitly specify the location of the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the default) energy('cfour', keep=False). path and keep are; keyword arguments that get interpreted by the; run_cfour() function documented ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:22412,access,accessible,22412,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,5,['access'],['accessible']
Security,"ich; is printed below and passed on to Optking.; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Cfour c4-scf Gradient Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. ... Irrep: 1 Size: 4 x 3. 1 2 3. 1 0.0000000 -0.0122978 0.0000000; 2 -0.0051192 0.0040993 -0.0088667; 3 -0.0051192 0.0040993 0.0088667; 4 0.0102384 0.0040993 0.0000000. CFOUR scratch file GRD has been read; 4 0.0000000000; 7.0000000000 -0.0880964705 0.0000000000 0.0000000000; 1.0000000000 0.4080144050 -0.9178691296 -1.5897959670; 1.0000000000 0.4080144050 -0.9178691296 1.5897959670; 1.0000000000 0.4080144050 1.8357382590 0.0000000001; 7.0000000000 -0.0122978407 0.0000000000 0.0000000000; 1.0000000000 0.0040992802 -0.0051191833 -0.0088666856; 1.0000000000 0.0040992802 -0.0051191833 0.0088666856; 1.0000000000 0.0040992802 0.0102383666 0.0000000000. The gradient can also be accessed from the input file as a; psi4.Matrix object through; psi4.get_gradient().; Cfour Files; The contents of all files associated with Cfour are accessible from the; input file through the Python dictionary P4C4_INFO. That is,; P4C4_INFO['zmat'] returns a string of the input file sent to Cfour.; Accessible arguments are zmat, output, and any that have been; produced of grd. For example, to print to the screen if CC convergence; is reached, the following could be placed in the Psi4 input file.; energy('c4-ccsd'); print 'miracle?', 'miracle' in P4C4_INFO['output']. Scratch Files; By default, a separate subdirectory for each Cfour call is created within; the job’s scratch directory. To explicitly specify the location of the the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the default) energy('cfour', keep=False). path and keep are; keyword arguments that get interpreted by the; run_cfour() function documen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:22477,access,accessible,22477,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['access'],['accessible']
Security,"icity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:4494,access,accessing,4494,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,8,['access'],['accessing']
Security,"ict); zlabels = _lmh_labels[Nxtpl] # e.g., ['LO', 'HI']. for zeta in range(Nxtpl):; zlab = zlabels[zeta] # e.g., LO; largs['z' + zlab] = needdict[zlab]['f_zeta']; largs['value' + zlab] = needdict[zlab][datakey]. return largs. ## Aliases ##; complete_basis_set = cbs. def _cbs_wrapper_methods(**kwargs):; cbs_method_kwargs = ['scf_wfn', 'corl_wfn', 'delta_wfn']; cbs_method_kwargs += ['delta%d_wfn' % x for x in range(2, 6)]. cbs_methods = []; for method in cbs_method_kwargs:; if method in kwargs:; cbs_methods.append(kwargs[method]); return cbs_methods. def _parse_cbs_gufunc_string(method_name):; method_name_list = re.split( """"""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:65448,Validat,ValidationError,65448,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"ict[metadata['max_nbody']]; nbody_dict['VMFC-CORRECTED INTERACTION ENERGY'] = vmfc_interaction_energy. for nb in nbodies[1:]:; nbody_dict[f""VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb] - vmfc_body_dict[1]; nbody_dict[f""VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = vmfc_body_dict[nb] - vmfc_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb]. # Collect specific and generalized returns; results = {; f""cp_{ptype}_body_dict"" : {f""{nb}cp"": j for nb, j in cp_body_dict.items()},; f""nocp_{ptype}_body_dict"": {f""{nb}nocp"": j for nb, j in nocp_body_dict.items()},; f""vmfc_{ptype}_body_dict"": {f""{nb}vmfc"": j for nb, j in vmfc_body_dict.items()},; }. if ptype == ""energy"":; results['nbody'] = nbody_dict. return_bsse_type = metadata[""bsse_type""][0]. if return_bsse_type == ""cp"":; results[f""{ptype}_body_dict""] = cp_body_dict; elif return_bsse_type == ""nocp"":; results[f""{ptype}_body_dict""] = nocp_body_dict; elif return_bsse_type == ""vmfc"":; results[f""{ptype}_body_dict""] = vmfc_body_dict; else:; raise ValidationError(; ""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). if ptype == ""energy"":; piece = results[f""{ptype}_body_dict""][metadata['max_nbody']]; else:; piece = results[f""{ptype}_body_dict""][metadata['max_nbody']].copy(). if metadata['return_total_data']:; results[f""ret_{ptype}""] = piece; else:; results[f""ret_{ptype}""] = piece; results[f""ret_{ptype}""] -= results[f""{ptype}_body_dict""][1]. results['ret_ptype'] = results[f""ret_{ptype}""]. return results. [docs]; class ManyBodyComputer(BaseComputer):; # user kwargs (all but levels become fields); # ------------------------------------------; # * bsse_type; # * levels; # * max_nbody; # * molecule -- general; # * return_total_data; # * return_wfn -- general. # fields set in construction; # --------------------------; # * nfragments (<- max_frag) -- from molecule. # fields set in task_planner;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:30762,Validat,ValidationError,30762,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,3,['Validat'],['ValidationError']
Security,"ict[metadata['max_nbody']]; nbody_dict['VMFC-CORRECTED INTERACTION ENERGY'] = vmfc_interaction_energy. for nb in nbodies[1:]:; nbody_dict[f""VMFC-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb] - vmfc_body_dict[1]; nbody_dict[f""VMFC-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY""] = vmfc_body_dict[nb] - vmfc_body_dict[nb-1]; for nb in nbodies:; nbody_dict[f""VMFC-CORRECTED TOTAL ENERGY THROUGH {nb}-BODY""] = vmfc_body_dict[nb]. # Collect specific and generalized returns; results = {; f""cp_{ptype}_body_dict"" : {f""{nb}cp"": j for nb, j in cp_body_dict.items()},; f""nocp_{ptype}_body_dict"": {f""{nb}nocp"": j for nb, j in nocp_body_dict.items()},; f""vmfc_{ptype}_body_dict"": {f""{nb}vmfc"": j for nb, j in vmfc_body_dict.items()},; }. if ptype == ""energy"":; results['nbody'] = nbody_dict. return_bsse_type = metadata[""bsse_type""][0]. if return_bsse_type == ""cp"":; results[f""{ptype}_body_dict""] = cp_body_dict; elif return_bsse_type == ""nocp"":; results[f""{ptype}_body_dict""] = nocp_body_dict; elif return_bsse_type == ""vmfc"":; results[f""{ptype}_body_dict""] = vmfc_body_dict; else:; raise ValidationError(; ""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). if ptype == ""energy"":; piece = results[f""{ptype}_body_dict""][metadata['max_nbody']]; else:; piece = results[f""{ptype}_body_dict""][metadata['max_nbody']].copy(). if metadata['return_total_data']:; results[f""ret_{ptype}""] = piece; else:; results[f""ret_{ptype}""] = piece; results[f""ret_{ptype}""] -= results[f""{ptype}_body_dict""][1]. results['ret_ptype'] = results[f""ret_{ptype}""]. return results. [docs]class ManyBodyComputer(BaseComputer):; # user kwargs (all but levels become fields); # ------------------------------------------; # * bsse_type; # * levels; # * max_nbody; # * molecule -- general; # * return_total_data; # * return_wfn -- general. # fields set in construction; # --------------------------; # * nfragments (<- max_frag) -- from molecule. # fields set in task_planner; #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:30479,Validat,ValidationError,30479,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,2,['Validat'],['ValidationError']
Security,"idationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" %; (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (opt_mode == 'continuous') and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.get_variable('CURRENT ENERGY'). # Compute the gradient; G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.get_variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimiza",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:60839,Validat,ValidationError,60839,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"idationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_schoenflies(self, cpg):; """"""This constructor takes the Schoenflies symbol of a point group; as input. """"""; self.symb = cpg; # Check the symbol coming in; self.PYbits = PointGroup.full_name_to_bits(cpg); if self.PYbits is None:; raise ValidationError('CharacterTable: Invalid point group name: %s\n' % (cpg)); self.common_init(). [docs] def constructor_bits(self, bits):; """"""This constructor takes the bitswise representation of a point; group as input. """"""; self.PYbits = bits; self.symb = PointGroup.bits_to_basic_name(bits); self.common_init(). [docs] def common_init(self):; """"""First parse the point group symbol, this will give us the; order of the point group(g), the type of point group (pg), the; order of the principle rotation axis (nt), and the number of; irreps (nirrep). """"""; if len(self.symb) == 0:; raise ValidationError('CharacterTable::CharacterTable: null point group'); if self.make_table() < 0:; raise ValidationError('CharacterTable::CharacterTable: could not make table'). # CharacterTable(const CharacterTable&);; #CharacterTable::CharacterTable(const CharacterTable& ct); # : nt(0), pg(PointGroups::C1), nirrep_(0), gamma_(0), symop(0), _inv(0), symb(0),; # bits_(0); #{; # *this = ct;; #}; #; #; # CharacterTable& operator=(const CharacterTable&);; #CharacterTable&; #CharacterTable::operator=(const CharacterTable& ct); #{; # nt=ct.nt; pg=ct.pg; nirrep_=ct.nirrep_;; #; # symb = ct.symb;; #; # if (gamma_) delete[] gamma_; gamma_=0;; # if (ct.gamma_) {; # gamma_ = new IrreducibleRepresentation[nirrep_];; # for (int i=0; i < nirrep_; i++) {; # gamma_[i].init();; # gamma_[i] = ct.gamma_[i];; # }; # }; #; # if (symop); # delete[] symop;; # symop=0;; #; # if (ct.symop) {; # symop = new SymmetryOperation[nirrep_];; # for (int i=0; i < nirrep_; i++) {; # symop[i] = ct.symop[i];; # }; # }; #; # if (_inv); # delete[] _inv;;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:22162,Validat,ValidationError,22162,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security,"idationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:35238,Validat,ValidationError,35238,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"ided a path, do nothing.; if (keep != False or ('path' in kwargs)):; PsiMod.print_out('\nMRCC scratch files have been kept.\n'); PsiMod.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; PsiMod.print_out('\n'); banner('Full results from MRCC'); PsiMod.print_out('\n'); PsiMod.print_out(iface_contents). return e. [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # save user options; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['CEPA', 'CEPA_NO_SINGLES']). # override symmetry if integral direct; if PsiMod.get_option('CEPA', 'CEPA_VABCD_DIRECT'):; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); molecule.reset_point_group('c1'); #molecule.fix_orientation(1); #molecule.update_geometry(). # throw an exception for open-shells; if (PsiMod.get_option('SCF', 'REFERENCE') != 'RHF'):; raise ValidationError(""Error: %s requires \""reference rhf\""."" % lowername). # what type of cepa?; if (lowername == 'cepa(0)'):; PsiMod.set_local_option('CEPA', 'CEPA_LEVEL', 'CEPA0'); if (lowername == 'cepa(1)'):; PsiMod.set_local_option('CEPA', 'CEPA_LEVEL', 'CEPA1'); if (lowername == 'cepa(2)'):; #PsiMod.set_local_option('CEPA', 'CEPA_LEVEL', 'CEPA2'); # throw an exception for cepa(2); PsiMod.print_out(""\n""); PsiMod.print_out(""Error: %s not implemented\n"" % lowername); PsiMod.print_out(""\n""); if (lowername == 'cepa(3)'):; PsiMod.set_local_option('CEPA', 'CEPA_LEVEL', 'CEPA3'); if (lowername == 'sdci'):; PsiMod.set_local_option('CEPA', 'CEPA_LEVEL', 'CISD'); if (lowername == 'dci'):; PsiMod.set_local_option('CEPA', 'CEPA_LEVEL', 'CISD'); PsiMod.set_local_option('CEPA', 'CEPA_NO_SINGLES', True); if (lowername == 'acpf'):; PsiMod.set_local_option('CEPA', 'CEPA_LEVEL', 'ACPF'); if (lowername == 'aqcc'):; PsiMod.set_local_option('CEPA', 'CEPA_LEVEL', 'AQCC'). PsiMod.set_local_option('TRANSQT2', 'W",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:45966,Validat,ValidationError,45966,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"ided a path, do nothing.; if (keep != False or ('path' in kwargs)):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'SCF_TYPE']). core.set_local_option('FNOCC', 'DFCC', True); core.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). def set_cholesky_from(mtd_type):; type_val = core.get_global_option(mtd_type); if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); elif type_val == 'DF':; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''); # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""); else:; raise ValidationError(""""""Invalid type '%s' for DFCC"""""" % type_val). # triples?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:113445,Validat,ValidationError,113445,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"ids *aa1*; and *aa2* and returns a square array of all errors for that amino; acid pair, buffered by zeros. """"""; import re; import numpy as np; bfdbpattern = re.compile(""\d\d\d([A-Z][A-Z][A-Z])-\d\d\d([A-Z][A-Z][A-Z])-\d""). tiles = []; for key, val in db.items():; bfdbname = bfdbpattern.match(key); if (bfdbname.group(1) == aa1 and bfdbname.group(2) == aa2) or \; (bfdbname.group(2) == aa1 and bfdbname.group(1) == aa2):; tiles.append(val). if not tiles:; # fill in background when no data. only sensible for neutral center colormaps; tiles = [0]; dim = int(np.ceil(np.sqrt(len(tiles)))); pad = dim * dim - len(tiles); tiles += [0] * pad. return np.reshape(np.array(tiles), (dim, dim)). [docs]def iowa(mcdat, mclbl, title='', xtitle='', xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Saves a plot with (extensionless) name *pltfile* with an Iowa; representation of the modelchems errors in *mcdat* for BBI/SSI-style; *labels*. """"""; import numpy as np; import hashlib; import matplotlib; import matplotlib.pyplot as plt. aa = ['ARG', 'HIE', 'LYS', 'ASP', 'GLU', 'SER', 'THR', 'ASN', 'GLN', 'CYS', 'MET', 'GLY', 'ALA', 'VAL', 'ILE', 'LEU', 'PRO', 'PHE', 'TYR', 'TRP']; #aa = ['ILE', 'LEU', 'ASP', 'GLU', 'PHE']; err = dict(zip(mclbl, mcdat)). # handle for frame, overall axis; fig, axt = plt.subplots(figsize=(6, 6)). #axt.set_xticks([]) # for quick nolabel, whiteback; #axt.set_yticks([]) # for quick nolabel, whiteback; axt.set_xticks(np.arange(len(aa)) + 0.3, minor=False); axt.set_yticks(np.arange(len(aa)) + 0.3, minor=False); axt.invert_yaxis(); axt.xaxis.tick_top() # comment for quick nolabel, whiteback; axt.set_xticklabels(aa, minor=False, rotation=60, size='small') # comment for quick nolabel, whiteback; axt.set_yticklabels(aa, minor=False, size='small') # comment for quick nolabel, whiteback; axt.xaxis.set_tick_params(width=0, length=0); axt.yaxis.set_tick_params(width=0, length=0); #axt.set_title('%s' % (title), fontsize=16, verticalalignment='botto",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:31042,hash,hashlib,31042,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['hash'],['hashlib']
Security,"ient b/c SCF option read in DFMP2; psi4.set_global_option('SCF_TYPE', 'DF'). if not psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 gradients need DF-SCF reference, for now.'). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(psi4.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). psi4.dfmp2grad(); e_dfmp2 = psi4.get_variable('MP2 TOTAL ENERGY'); e_scs_dfmp2 = psi4.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:22324,Validat,ValidationError,22324,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"ies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.frequencies.html:1101,access,accesses,1101,psi4manual/1.7.x/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.frequencies.html,4,['access'],['accesses']
Security,"iet (bool); return_total_data (Optional[bool]); task_list (Dict[str, Union[psi4.driver.task_base.AtomicComputer, psi4.driver.driver_cbs.CompositeComputer, psi4.driver.driver_findif.FiniteDifferenceComputer]]). Validators:. set_bsse_type » bsse_type; set_embedding_charges » embedding_charges; set_max_nbody » max_nbody; set_molecule » molecule; set_nfragments » nfragments; set_return_total_data » return_total_data. field basis: str = '(auto)'¶. field bsse_type: List[BsseEnum] = [<BsseEnum.cp: 'cp'>]¶; Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned. Validated by:. set_bsse_type. field driver: DriverEnum [Required]¶; The computation driver; i.e., energy, gradient, hessian. field embedding_charges: Dict[int, List[float]] = {}¶; Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment. Validated by:. set_embedding_charges. field keywords: Dict[str, Any] = {}¶; The computation keywords/options. field max_nbody: int = -1¶; Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments. Validated by:. set_max_nbody. field method: str = '(auto)'¶. field molecule: Any [Required]¶; The target molecule, if not the last molecule defined. Validated by:. set_molecule. field nbodies_per_mc_level: List[List[Union[int, Literal['supersystem']]]] = []¶; Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbody=2 and 1-body and 2-body contributions computed at different leve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/nbody.html:12964,Validat,Validated,12964,psi4manual/1.7.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/nbody.html,1,['Validat'],['Validated']
Security,"if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationnError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop,; oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.basisset()); if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); mints.set_rel_basisset(rel_bas). mints.set_print(1); mints.integrals(). def check_non_symmetric_jk_density(name):; """"""; Ensure non-symmetric density matrices are supported for the selected JK routine.; """"""; scf_type = core.get_global_option('SCF_TYPE'); supp_jk_type = ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT', 'OUT_OF_CORE']; supp_string = ', '.join(supp_jk_type[:-1]) + ', or ' + supp_jk_type[-1] + '.'. if scf_type not in supp_j",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html:2917,Validat,ValidationError,2917,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,2,['Validat'],['ValidationError']
Security,"if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, core.Molecule):; # called on a python export of a psi4.core.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, str):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # # Validate arguments; # dashlvl = dashlvl.lower(); # dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; # if dashlvl not in dashcoeff.keys():; # raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). # if func is None:; # if dashparam is None:; # # defunct case; # raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); # else:; # # case where all param read from dashparam dict (which must have all correct keys); # func = 'custom'; # dashcoeff[dashlvl][func] = {}; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # for key in dashcoeff[dashlvl]['b3lyp'].keys():; # if key in dashparam.keys():; # dashcoeff[dashlvl][func][key] = dashparam[key]; # else:; # raise ValidationError(""""""Parameter %s is missing from dashp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html:2818,Validat,Validate,2818,psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,1,['Validat'],['Validate']
Security,"if i == 0:; i += 1; else:; if line.split()[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; temp = dfile.readline(); dashdderiv.append([float(x.replace('D', 'E')) for x in temp.split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())); psi_dashdderiv = psi4.Matrix(self.natom(), 3); psi_dashdderiv.set(dashdderiv). # Print program output to file if verbose; verbose = psi4.get_option('SCF', 'PRINT'); if verbose >= 3:; psi4.print_out('\n ==> DFTD3 Output <==\n'); psi4.print_out(out); dfile = open(derivfile, 'r'); psi4.print_out(dfile.read().replace('D', 'E')); dfile.close(); psi4.print_out('\n'). # Clean up files and remove scratch directory; os.unlink(paramfile); os.unlink(geomfile); os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); try:; shutil.rmtree(dftd3_tmpdir); except OSError as e:; ValidationError('Unable to remove dftd3 temporary directory %s' % e, file=sys.stderr); os.chdir(current_directory). # return -D & d(-D)/dx; psi4.set_variable('DISPERSION CORRECTION ENERGY', dashd); if dertype == -1:; return dashd, dashdderiv; elif dertype == 0:; return dashd; elif dertype == 1:; return psi_dashdderiv. [docs]def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the psi4.Molecule class. """"""; cls.__setattr__ = new_set_attr; cls.__getattr__ = new_get_attr; cls.BFS = BFS; cls.run_dftd3 = run_dftd3. dynamic_variable_bind(psi4.Molecule) # pass class type, not class instance. #; # Define geometry to be used by PSI4.; # The molecule created by this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name*; from the geometry in string *geom*. """"""; molecule = psi4.Molecule.create_molecule_from_string(geom); molecule.set_name(name). act",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:12580,Validat,ValidationError,12580,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; psi4.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def scf_helper(name, **kwargs):; """"""Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). """""". optstash = p4util.OptionsState(; ['PUREAM'],; ['BASIS'],; ['QMEFP'],; ['DF_BASIS_SCF'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'SCF_TYPE'] # Hack: scope gets changed internally with the Andy trick; ). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO']). # Grab a few kwargs; use_c1 = kwargs.get('use_c1', False); scf_molecule = kwargs.get('molecule', psi4.get_active_molecule()); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:25906,access,access,25906,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['access'],['access']
Security,"if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'). if core.get_option('SCF', 'SCF_TYPE') not in ['CD', 'DF']:; raise ValidationError(""""""Invalid scf_type for DFCC.""""""). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). fnocc_wfn = core.fnocc(ref_wfn). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); level = kwargs.get('level', 0). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:115219,Validat,ValidationError,115219,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"if name == 'ccsd':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); psi4.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd(t)':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); psi4.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'). if psi4.get_option('SCF', 'SCF_TYPE') not in ['CD', 'DF']:; raise ValidationError(""""""Invalid scf_type for DFCC.""""""). # save DF or CD ints generated by SCF for use in CC; psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). fnocc_wfn = psi4.fnocc(ref_wfn). optstash.restore(); return fnocc_wfn. [docs]def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); level = kwargs.get('level', 0). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). psi4.set_local_option('FNOCC', 'DFCC', False); psi4.set_local_option('FNOCC', 'RUN_CEPA', False); psi4.set_local_option('FNOCC', 'USE_DF_INTS', False). # which method?; if name == 'ccsd':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); psi4.set_local_optio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:99653,Validat,ValidationError,99653,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"if not os.path.exists(cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir) # psi_scratch/cfour; if not os.path.exists('harm'):; os.mkdir('harm'); os.chdir('harm') # psi_scratch/cfour/harm. psioh.set_specific_retention(32, True) # temporary, to track p4 scratch; #shelf['status'] = 'anharm_jobs_sown' # temporary to force backtrack; print('STAT', shelf['status']) # temporary. # Generate the ZMAT input file in scratch; with open('ZMAT', 'w') as handle:; cfour_infile = write_zmat(skelname, 1); handle.write(cfour_infile); print('\n====== Begin ZMAT input for CFOUR ======'); print(open('ZMAT', 'r').read()); print('======= End ZMAT input for CFOUR =======\n'); shelf['genbas'] = open('GENBAS', 'r').read(). # Check existing shelf consistent with generated ZMAT, store; if ('000-000' in shelf['zmat']) and (shelf['zmat']['000-000'] != cfour_infile):; diff = difflib.Differ().compare(shelf['zmat']['000-000'].splitlines(), cfour_infile.splitlines()); raise ValidationError(""""""Input file translated to Cfour ZMAT does not match ZMAT stored in shelf.\n\n"""""" +; '\n'.join(list(diff))); shelf['zmat']['000-000'] = cfour_infile; shelf.sync(). # Reset basis after Cfour skeleton seeded; psi4.set_global_option('BASIS', user_basis). if shelf['status'] == 'initialized':; p4util.banner(' VPT2 Setup: Harmonic '). # Generate the displacements that will form the harmonic freq; os.chdir(psioh.get_default_path() + cfour_tmpdir + '/harm') # psi_scratch/cfour/harm; with open('partial.out', 'w') as handle:; handle.write(run_cfour_module('xjoda')); handle.write(run_cfour_module('xsymcor')). # Read the displacements that will form the harmonic freq; zmats0N = ['000-' + item[-3:] for item in sorted(glob.glob('zmat*'))]; for zm12 in zmats0N:; zm1, zm2 = zm12.split('-'); with open('zmat' + zm2, 'r') as handle:; shelf['zmat'][zm12] = handle.read(); shelf.sync(); psi4.print_out(' CFOUR scratch file %s for %s-%s has been read\n' % ('zmat' + zm2, zm1, zm2)); psi4.print_out('%s\n' % shelf['zmat'][zm12]).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:7999,Validat,ValidationError,7999,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,1,['Validat'],['ValidationError']
Security,"if not self.haschanged_local:; core.revoke_local_option_changed(self.module, self.option). [docs]; class OptionsState():; """"""Store multiple :py:func:`OptionState` objects.; Use in driver functions to collect several keywords before altering them,; then restore them before function return. Parameters; ----------; largs; Specify which keywords to store value and has_changed state. Examples; --------; >>> optstash = OptionsState(; ['DF_BASIS_SCF'],; ['SCF_TYPE'],; ['SCF', 'REFERENCE']). >>> print(optstash). >>> optstash.restore(). """""". def __init__(self, *largs: List[List[str]]):; self.data = {}; for item in largs:; self.add_option(item). [docs]; def add_option(self, item: List[str]):; """"""Store info for another keyword, `item`. Parameters; ----------; item; A one-membered list with a global keyword or a two-membered list; with a module keyword and module. """"""; if len(item) == 2:; key = (item[1], item[0]); elif len(item) == 1:; key = (item[0], ); else:; raise ValidationError(; 'Each argument to OptionsState should be an array, the first element of which is the module scope and the second element of which is the module name. Bad argument: %s'; % (item)). if key in self.data:; raise ValidationError(; 'Malformed options state, duplicate key adds of ""{}"". This should not happen, please raise a issue on github.com/psi4/psi4'.format(key)); else:; self.data[key] = OptionState(*key). def __str__(self):; text = ''; for key, item in self.data.items():; text += str(item); return text. [docs]; def restore(self):; """"""Restore value and has_changed status of each keyword to saved condition.""""""; for key, item in self.data.items():; item.restore(). [docs]; @contextmanager; def OptionsStateCM(osd) -> Iterator[None]:; """"""Return a context manager that will collect the state (value and changed; status) of a list of keywords `osd` that can initialize; :py:class:`OptionsState` on entry to the with-statement and restore the; collected state when exiting the with-statement. """"""; oso = OptionsSta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/optproc.html:4624,Validat,ValidationError,4624,psi4manual/1.8.x/_modules/psi4/driver/p4util/optproc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/optproc.html,3,['Validat'],['ValidationError']
Security,"if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (function",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html:1737,access,accesses,1737,psi4manual/1.4.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html,15,['access'],['accesses']
Security,"if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)); return; else:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""""""Python module loading problem for database data """""" + str(modname)); try:; getattr(datamodule, funcname)(self); except AttributeError:; if not failoninc:; print(""""""%s %s data unavailable for database %s.\n"""""" % (modname, funcname, self.dbse)); return; else:; raise ValidationError(""Python module missing function %s for loading data "" % (str(funcname))). print(""""""WrappedDatabase %s: %s %s results loaded"""""" % (self.dbse, modname, funcname)). [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""Loads qcdb.ReactionDatums from standard location for *project*; :module dbse_project and function load_project. Module search path; can be prepended with *pythonpath*. """"""; mod = self.dbse + '_' + project; func = 'load_' + project; self.load_qcdata(modname=mod, funcname=func, pythonpath=pythonpath). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; """"""""""""; if path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise Valida",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:38111,Validat,ValidationError,38111,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"if view:; plt.show(); plt.close(); return files_saved. [docs]def liliowa(mcdat, title='', xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Saves a plot with a heatmap representation of *mcdat*. """"""; import numpy as np; import hashlib; import matplotlib; import matplotlib.pyplot as plt. # handle for frame, overall axis; fig, axt = plt.subplots(figsize=(1, 1)). axt.set_xticks([]); axt.set_yticks([]); axt.invert_yaxis(); axt.xaxis.set_tick_params(width=0, length=0); axt.yaxis.set_tick_params(width=0, length=0); axt.set_aspect('equal'). # remove figure outline; axt.spines['top'].set_visible(False); axt.spines['right'].set_visible(False); axt.spines['bottom'].set_visible(False); axt.spines['left'].set_visible(False). tiles = mcdat; dim = int(np.ceil(np.sqrt(len(tiles)))); pad = dim * dim - len(tiles); tiles += [0] * pad; cb = np.reshape(np.array(tiles), (dim, dim)). heatmap = axt.pcolor(cb, vmin=-xlimit, vmax=xlimit, cmap=plt.cm.PRGn). # save and show; pltuid = title + '_' + hashlib.sha1(title + str(xlimit)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='liliowa_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight',; frameon=False, pad_inches=0.0); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. if __name__ == ""__main__"":. merge_dats = [; {'show':'a', 'db':'HSG', 'sys':'1', 'data':[0.3508, 0.1234, 0.0364, 0.0731, 0.0388]},; {'show':'b', 'db':'HSG', 'sys':'3', 'data':[0.2036, -0.0736, -0.1650, -0.1380, -0.1806]},; #{'show':'', 'db':'S22', 'sys':'14', 'data':[np.nan, -3.2144, np.nan, np.nan, np.nan]},; {'show':'c', 'db':'S22', 'sys':'14', 'data':[None, -3.2144, None, None, None]},; {'show':'d', 'db':'S22', 'sys':'15', 'data':[-1.5090, -2.5263, -2.9452, -2.8633, -3.1059]},; {'show':'e', 'db':'S22', 'sys':'22', 'data':[0.3046, -0.2632, -0.5070, -0.4925, -0.6359",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:34291,hash,hashlib,34291,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['hash'],['hashlib']
Security,"ify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import numpy as np; import psi4; from exceptions import *. def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; try:; arr.shape; except:; raise ValidationError(""Expected numpy array, found object of type '%s'"", type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). @classmethod; def _dimension_from_list(self, dims, name=""New Dimension""):; """"""; Builds a psi4.Dimension object from a python list or tuple. If a dimension; object is passed a copy will be returned.; """""". if isinstance(dims, (tuple, list)):; irreps = len(dims); elif isinstance(dims, psi4.Dimension):; irreps = dims.n(); else:; raise ValidationError(""Dimension from list: Type '%s' not understood"" % type(dims)). ret = psi4.Dimension(irreps, name); for i in range(irreps):; ret[i] = dims[i]; return ret. def _dimension_to_tuple(dim):; """"""; Converts a psi4.Dimension object to a tuple.; """""". if isinstance(dim, (tuple, list)):; return tuple(dim); ; irreps = dim.n(); ret = []; for i in range(irreps):; ret.append(dim[i]); return tuple(ret). @classmethod; def array_to_matrix(self, arr, name=""New Matrix"", ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:1444,Validat,ValidationError,1444,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"igh:2, normal:1, low:0}"",; ""default"": 1,; ""type"": ""string""; },; ""owner_group"": {; ""title"": ""Owner Group"",; ""description"": ""group in the chown sense."",; ""type"": ""string""; },; ""computed"": {; ""title"": ""Computed"",; ""description"": ""Whether quantum chemistry has been run on this task."",; ""default"": false,; ""type"": ""boolean""; },; ""result"": {; ""title"": ""Result"",; ""description"": "":py:class:`~qcelemental.models.AtomicResult` return.""; },; ""result_id"": {; ""title"": ""Result Id"",; ""description"": ""The optional ID for the computation."",; ""type"": ""string""; }; },; ""required"": [; ""molecule"",; ""basis"",; ""method"",; ""driver""; ]; }; }; }. Fields:. basis (str); cbsrec (List[Dict[str, Any]]); compute_list (List[Dict[str, Any]]); driver (qcelemental.models.common_models.DriverEnum); keywords (Dict[str, Any]); metadata (Any); metameta (Dict[str, Any]); method (str); molecule (Any); results_list (List[Any]); task_list (List[psi4.driver.task_base.AtomicComputer]); trove (List[Dict[str, Any]]); verbose (int). Validators:. set_molecule » molecule. field basis: str = '(auto)'¶. field cbsrec: List[Dict[str, Any]] = []¶. field compute_list: List[Dict[str, Any]] = []¶. field driver: DriverEnum [Required]¶. field keywords: Dict[str, Any] = {}¶. field metadata: Any = None¶. field metameta: Dict[str, Any] = {}¶. field method: str = '(auto)'¶. field molecule: Any = None¶. Validated by:. set_molecule. field results_list: List[Any] = []¶. field task_list: List[AtomicComputer] = []¶. field trove: List[Dict[str, Any]] = []¶. field verbose: int = 1¶. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶. Parameters:; client (qcportal.FractalClient | None) – . get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/cbs.html:39099,Validat,Validators,39099,psi4manual/1.8.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/cbs.html,2,['Validat'],['Validators']
Security,"igh:2, normal:1, low:0}"",; ""default"": 1,; ""type"": ""string""; },; ""owner_group"": {; ""title"": ""Owner Group"",; ""description"": ""group in the chown sense."",; ""type"": ""string""; },; ""computed"": {; ""title"": ""Computed"",; ""description"": ""Whether quantum chemistry has been run on this task."",; ""default"": false,; ""type"": ""boolean""; },; ""result"": {; ""title"": ""Result"",; ""description"": "":py:class:`~qcelemental.models.AtomicResult` return.""; },; ""result_id"": {; ""title"": ""Result Id"",; ""description"": ""The optional ID for the computation."",; ""type"": ""string""; }; },; ""required"": [; ""molecule"",; ""basis"",; ""method"",; ""driver""; ]; }; }; }. Fields:. basis (str); cbsrec (List[Dict[str, Any]]); compute_list (List[Dict[str, Any]]); driver (qcelemental.models.common_models.DriverEnum); keywords (Dict[str, Any]); metadata (Any); metameta (Dict[str, Any]); method (str); molecule (Any); results_list (List[Any]); task_list (List[psi4.driver.task_base.AtomicComputer]); trove (List[Dict[str, Any]]); verbose (int). Validators:. set_molecule » molecule. field basis: str = '(auto)'¶. field cbsrec: List[Dict[str, Any]] = []¶. field compute_list: List[Dict[str, Any]] = []¶. field driver: DriverEnum [Required]¶. field keywords: Dict[str, Any] = {}¶. field metadata: Any = None¶. field metameta: Dict[str, Any] = {}¶. field method: str = '(auto)'¶. field molecule: Any = None¶. Validated by:. set_molecule. field results_list: List[Any] = []¶. field task_list: List[AtomicComputer] = []¶. field trove: List[Dict[str, Any]] = []¶. field verbose: int = 1¶. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶. Parameters:; client (qcportal.FractalClient | None). get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cbs.html:39138,Validat,Validators,39138,psi4manual/master/cbs.html,https://psicode.org,https://psicode.org/psi4manual/master/cbs.html,1,['Validat'],['Validators']
Security,"ile = True; filename = kwargs.get('write_orbitals'); core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif _chkfile is True:; write_checkpoint_file = True. # PCM needs to be run w/o symmetry; if core.get_option(""SCF"", ""PCM""):; c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.update_geometry(). scf_molecule = c1_molecule; core.print_out("""""" PCM does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""). # PE needs to use exactly input orientation to correspond to potfile; if core.get_option(""SCF"", ""PE""):; c1_molecule = scf_molecule.clone(); if getattr(scf_molecule, ""_initial_cartesian"", None) is not None:; c1_molecule._initial_cartesian = scf_molecule._initial_cartesian.clone(); c1_molecule.set_geometry(c1_molecule._initial_cartesian); c1_molecule.reset_point_group(""c1""); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); else:; raise ValidationError(""Set no_com/no_reorient/symmetry c1 by hand for PE on non-Cartesian molecules.""). scf_molecule = c1_molecule; core.print_out("""""" PE does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); core.print_out("""""" PE geometry must align with POTFILE keyword: """"""; """"""resetting coordinates with fixed origin and orientation.\n""""""). # SCF Banner data; banner = kwargs.pop('banner', None); bannername = name. # Did we pass in a DFT functional?; dft_func = kwargs.pop('dft_functional', None); if dft_func is not None:; if name.lower() != ""scf"":; raise ValidationError(""dft_functional was supplied to SCF, but method name was not SCF ('%s')"" % name); name = dft_func; bannername = name; if isinstance(name, dict):; bannername = name.get(""name"", ""custom functional""). # Setup the timer; if do_timer:; core.tstart(). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('SCF', 'SOSCF'):; proc_util.check_non_symmetric_jk_density(""Second-order SCF""). # sort ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:38335,Validat,ValidationError,38335,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"ilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" %; (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(r'^(?:\s*)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER +; '(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)', re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.mat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:10693,Validat,ValidationError,10693,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"ility analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. sapt11; sapt example with orbital freezing with alkali metal and dMP2. scf-guess-read2; Test if the the guess read in the same basis converges. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. mints-benchmark; run some BLAS benchmarks. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. linK-1; RHF Linear Exchange Algorithm test for water. fci-h2o-2; 6-31G H2O Test FCI Energy Point. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. psithon1; Spectroscopic constants of H2, and the full ci ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:2530,validat,validate,2530,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['validat'],['validate']
Security,"ils.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility function for dumping the Hamiltonian to file in FCIDUMP format."""""". from datetime import datetime. import numpy as np. from psi4.driver import psifiles as psif; from psi4.driver.p4util.util import compare_values, success; from psi4.driver.procrouting.proc_util import check_iwl_file_from_scf_type. from psi4 import core; from .exceptions import ValidationError, TestComparisonError. [docs]def fcidump(wfn, fname='INTDUMP', oe_ints=None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989); Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. :returns: None. :raises: ValidationError when SCF wavefunction is not RHF. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files; :param fname: name of the integrals file, defaults to INTDUMP; :param oe_ints: list of additional one-electron integrals to save to file.; So far only EIGENVALUES is a valid option. :examples:. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html:1825,Validat,ValidationError,1825,psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,1,['Validat'],['ValidationError']
Security,"ils.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility function for dumping the Hamiltonian to file in FCIDUMP format."""""". import numpy as np. from psi4.driver import psifiles as psif; from psi4.driver.p4util.testing import compare_integers, compare_values, compare_recursive; from psi4.driver.procrouting.proc_util import check_iwl_file_from_scf_type. from psi4 import core; from .exceptions import ValidationError, TestComparisonError. [docs]def fcidump(wfn, fname='INTDUMP', oe_ints=None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989); Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. :returns: None. :raises: ValidationError when SCF wavefunction is not RHF. :type wfn: :py:class:`~psi4.core.Wavefunction`. :param wfn: set of molecule, basis, orbitals from which to generate cube files; :param fname: name of the integrals file, defaults to INTDUMP; :param oe_ints: list of additional one-electron integrals to save to file. So far only EIGENVALUES is a valid option. :examples:. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:1851,Validat,ValidationError,1851,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,3,['Validat'],['ValidationError']
Security,"ilt-in `adc` module instead of add-on `adcc` interface is deprecated due ""; ""to certain wrong results, and as soon as 1.7, it will stop working."", category=FutureWarning). error_msg = (""\n\t\t\t\t!!!!! WARNING !!!!!\n"" +; ""\t\tThe built-in ADC(2) method may give incorrect results if\n""; ""\t\tmultiple roots are requested, due to an error in the Davidson solver,\n""; ""\t\tand is no longer maintained. It is slated for removal in Psi4 1.7.\n""; ""\t\tUse of the Psi interface to `adcc` instead is strongly recommended.\n""). core.print_out(error_msg). wfn = core.adc(ref_wfn). core.print_out(error_msg). return wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") <",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:113074,Validat,ValidationError,113074,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"imization; # This has not been well tested - Experimental; opt_object = optking.opt_helper.CustomHelper(molecule); with open(f""{core.get_writer_file_prefix(molecule.name())}.1.dat"", 'r') as f:; stashed_opt = json.load(f); opt_object.from_dict(stashed_opt); else:; # create an OptHelper to run an optimization through; # Optking will ignore any keywords it doesn't recognize.; params = p4util.prepare_options_for_modules(); optimizer_params = {k: v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmetrize cannot be called while cartesian constraints are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slightly broken.; molecule.symmetrize(core.get_option(""OPTKING"", ""CARTESIAN_SYM_TOLERANCE"")). if molecule.schoenflies_symbol() != initial_sym:; raise ValidationError(""Point group changed! (%s <-- %s) You should restart ""; ""using the last geometry in the output, after ""; ""carefully making sure all symmetry-dependent ""; ""input, such as DOCC, is correct."" % (current_sym, initial_sym)). kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # We'll currently ignore the possibility that the gradient isn't needed; opt_calcs = opt_obj",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:72501,Validat,ValidationError,72501,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['Validat'],['ValidationError']
Security,"import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:7079,Validat,ValidationError,7079,psi4manual/4.0b5/_modules/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html,1,['Validat'],['ValidationError']
Security,"import absolute_import; import os; import shutil; import subprocess. import numpy as np. from psi4 import extras; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import constants; from psi4.driver.p4util.exceptions import *; from psi4.driver.molutil import *; # never import driver, wrappers, or aliases into this file. from .roa import *; from . import proc_util; from . import empirical_dispersion; from . import dft_funcs; from . import mcscf; from . import response. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:2416,validat,validation,2416,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['validat'],['validation']
Security,"imum n-body to compute, cannot exceed the number of fragments in the moleucle. :type ptype: string; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data.; """""". # Initialize dictionaries for easy data passing; metadata, component_results, nbody_results = {}, {}, {}. # Parse some kwargs; kwargs = p4util.kwargs_lower(kwargs); metadata['ptype'] = kwargs.pop('ptype', None); metadata['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', False); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['kwargs'] = kwargs; core.clean_variables(). if metadata['ptype'] not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % metadata['ptype']). # Parse bsse_type, raise exception if not provided or unrecognized; metadata['bsse_type_list'] = kwargs.pop('bsse_type'); if metadata['bsse_type_list'] is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(metadata['bsse_type_list'], list):; metadata['bsse_type_list'] = [metadata['bsse_type_list']]. for num, btype in enumerate(metadata['bsse_type_list']):; metadata['bsse_type_list'][num] = btype.lower(); if btype.lower() not in ['cp', 'nocp', 'vmfc']:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). metadata['max_nbody'] = kwargs.get('max_nbody', -1); metadata['max_frag'] = metadata['molecule'].nfragments(); if metadata['max_nbody'] == -1:; metadata['max_nbody'] = metadata['molecule'].nfragments(); else:; metadata['max_nbody'] = min(metadata['max_nbody'], metadata['max_frag']). # Flip this off for now, needs more te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html:6015,Validat,ValidationError,6015,psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:62841,Validat,ValidationError,62841,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\',MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:71707,Validat,ValidationError,71707,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv] = 0.0; exec banners; exec actives; try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; if (s[13:] == envv.upper().split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv.upper(), VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:44976,Validat,ValidationError,44976,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"in h.shape:; dim1.append(0); dim2.append(0); else:; dim1.append(h.shape[0]); if ret_type == '2D':; dim2.append(h.shape[1]). ndim1 = np.sum(dim1); ndim2 = np.sum(dim2); if ret_type == '1D':; dense_ret = np.zeros(shape=(ndim1)); start = 0; for d1, arr in zip(dim1, matrix_views):; if d1 == 0: continue; dense_ret[start:start + d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, matrix_views):; if (d1 == 0) or (d2 == 0): continue. dense_ret[start1:start1 + d1, start2:start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; return _get_raw_views(matrix, copy=copy)[0]. @property; def _np_shape(self):; """"""; Shape of the Psi4 data object.; """"""; view_data = _get_raw_views(self); if self.nirrep() > 1:; return tuple(view_data[x].shape for x in range(self.nirrep())); else:; return view_data[0].shape. @property; def _np_view(self):; """"""; View with single irrep.; """"""; if self.nirrep() > 1:; raise ValidationError(""Attempted to call .np on a Psi4 data object with multiple irreps.""; ""Please use .nph for objects with irreps.""); return _get_raw_views(self)[0]. @property; def _nph_view(self):; """"""; View with irreps.; """"""; return _get_raw_views(self). @property; def _array_conversion(self):; """"""; Provides the array interface to simply classes so that np.array(core.Matrix(5, 5)) works flawlessly.; """"""; if self.nirrep() > 1:; raise ValidationError(""__array__interface__ can only be called on Psi4 data object with only one irrep!""); else:; return self.np.__array_interface__. def _np_write(; self: Union[core.Matrix, core.Vector],; filename: Optional[str] = None,; prefix: str = """",; ) -> Optional[Dict[str, Any]]:; """"""; Writes the irrepped matrix to a NumPy uncompressed file using :func:`numpy.savez`. Can return the packed data for saving many matrices into the same file. Parameters; ----------; self; Instance to be serialized.; filename; File name where the data will be saved.; prefix; Name of inst",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:8538,Validat,ValidationError,8538,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,4,['Validat'],['ValidationError']
Security,"in h.shape:; dim1.append(0); dim2.append(0); else:; dim1.append(h.shape[0]); if ret_type == '2D':; dim2.append(h.shape[1]). ndim1 = np.sum(dim1); ndim2 = np.sum(dim2); if ret_type == '1D':; dense_ret = np.zeros(shape=(ndim1)); start = 0; for d1, arr in zip(dim1, matrix_views):; if d1 == 0: continue; dense_ret[start:start + d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, matrix_views):; if (d1 == 0) or (d2 == 0): continue. dense_ret[start1:start1 + d1, start2:start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; return _get_raw_views(matrix, copy=copy)[0]. @property; def _np_shape(self):; """"""; Shape of the Psi4 data object.; """"""; view_data = _get_raw_views(self); if self.nirrep() > 1:; return tuple(view_data[x].shape for x in range(self.nirrep())); else:; return view_data[0].shape. @property; def _np_view(self):; """"""; View with single irrep.; """"""; if self.nirrep() > 1:; raise ValidationError(""Attempted to call .np on a Psi4 data object with multiple irreps.""; ""Please use .nph for objects with irreps.""); return _get_raw_views(self)[0]. @property; def _nph_view(self):; """"""; View with irreps.; """"""; return _get_raw_views(self). @property; def _array_conversion(self):; """"""; Provides the array interface to simply classes so that np.array(core.Matrix(5, 5)) works flawlessly.; """"""; if self.nirrep() > 1:; raise ValidationError(""__array__interface__ can only be called on Psi4 data object with only one irrep!""); else:; return self.np.__array_interface__. def _np_write(self, filename=None, prefix=""""):; """"""; Writes the irreped matrix to a NumPy zipped file. Can return the packed data for saving many matrices into the same file.; """""". ret = {}; ret[prefix + ""Irreps""] = self.nirrep(); ret[prefix + ""Name""] = self.name; for h, v in enumerate(self.nph):; # If returning arrays to user, we want to return copies (snapshot), not; # views of the core.Matrix's memory.; if filename is None",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:7858,Validat,ValidationError,7858,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,3,['Validat'],['ValidationError']
Security,"in range(5, 99):; VARH[f'mp{mplevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'mp{mplevel}': f'MP{mplevel} TOTAL ENERGY'}; for mplevel2 in range(2, mplevel):; VARH[f'mp{mplevel}'][f'mp{mplevel2}'] = f'MP{mplevel2} TOTAL ENERGY'. # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH; # yapf: enable. VARH = return_energy_components(). [docs]; def _get_default_xtpl(nbasis: int, xtpl_type: str) -> Callable:; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return ""xtpl_highest_1""; elif xtpl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata; List of dicts containing CBS stage keywords.; molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". # TODO: split options into mixable (qc_module=ccenergy/"""") or non-mixable (freeze_core=true/false). metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) al",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:16811,Validat,ValidationError,16811,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,9,['Validat'],['ValidationError']
Security,"in the; GDMA manual.; If more advanced usage is desired, which is not is permitted by the options; listed below, the user may provide their own data file containing keywords to; control the GDMA code. Simply place the data file in the directory PSI4; is called from, and provide the file name as the datafile argument to the; gdma() routine. For example, if GDMA data file is called; control.dma, the GDMA code is called as follows:; grad, wfn = gradient('mp2', return_wfn=True); gdma(wfn, datafile='control.dma'). An FCHK file will be generated for the GDMA code to read; this file will have; the prefix given by WRITER_FILE_LABEL (if set), or else by the name; of the output file plus the name of the current molecule, and the suffix will; be ‘.fchk’. This FCHK file name should be passed to the ‘File’ keyword in the; DGMA data file, to ensure that the GDMA code reads the correct wavefunction; information.; After running, two matrices of results can be accessed:; dma_results = get_array_variable('DMA DISTRIBUTED MULTIPOLES'); tot_results = get_array_variable('DMA TOTAL MULTIPOLES'). The first contains distributed multipoles, in units given by; GDMA_MULTIPOLE_UNITS, with the row index corresponding to the site and; the column index referencing the multipole component. Both indices are zero; based, and the \(Q^l_m\) components of the multipoles are ordered as; \(Q^0_0, Q^1_0, Q^1_{1c}, Q^1_{1s}, Q^2_0, Q^2_{1c}, Q^2_{1s}, Q^2_{2c},; Q^2_{2s}, \ldots\) The second matrix returned has a single row, whose columns; are the total multipoles, translated to GDMA_ORIGIN, and summed. psi4.gdma(wfn)[source]; Function to use wavefunction information in wfn and, if specified,; additional commands in filename to run GDMA analysis with A. J. Stone’s program. Added in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate DMA analysis; datafile (str) – optional control file (see GDMA manual) to peform more complicated DMA; analys",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/gdma.html:2786,access,accessed,2786,psi4manual/master/gdma.html,https://psicode.org,https://psicode.org/psi4manual/master/gdma.html,1,['access'],['accessed']
Security,"in the; GDMA manual.; If more advanced usage is desired, which is not is permitted by the options; listed below, the user may provide their own data file containing keywords to; control the GDMA code. Simply place the data file in the directory PSI4; is called from, and provide the file name as the datafile argument to the; gdma() routine. For example, if GDMA data file is called; control.dma, the GDMA code is called as follows:; grad, wfn = gradient('mp2', return_wfn=True); gdma(wfn, datafile='control.dma'). An FCHK file will be generated for the GDMA code to read; this file will have; the prefix given by WRITER_FILE_LABEL (if set), or else by the name; of the output file plus the name of the current molecule, and the suffix will; be ‘.fchk’. This FCHK file name should be passed to the ‘File’ keyword in the; DGMA data file, to ensure that the GDMA code reads the correct wavefunction; information.; After running, two matrices of results can be accessed:; dma_results = get_array_variable('DMA DISTRIBUTED MULTIPOLES'); tot_results = get_array_variable('DMA TOTAL MULTIPOLES'). The first contains distributed multipoles, in units given by; GDMA_MULTIPOLE_UNITS, with the row index corresponding to the site and; the column index referencing the multipole component. Both indices are zero; based, and the \(Q^l_m\) components of the multipoles are ordered as; \(Q^0_0, Q^1_0, Q^1_{1c}, Q^1_{1s}, Q^2_0, Q^2_{1c}, Q^2_{1s}, Q^2_{2c},; Q^2_{2s}, \ldots\) The second matrix returned has a single row, whose columns; are the total multipoles, translated to GDMA_ORIGIN, and summed. psi4.gdma(wfn)[source]; Function to use wavefunction information in wfn and, if specified,; additional commands in filename to run GDMA analysis with A. J. Stone’s program. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate DMA analysis; datafile (str) – optional control file (see GDMA manual) to peform more complicated DMA; analyses",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/gdma.html:2779,access,accessed,2779,psi4manual/1.9.x/gdma.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/gdma.html,1,['access'],['accessed']
Security,"in the; GDMA manual.; If more advanced usage is desired, which is not is permitted by the options; listed below, the user may provide their own data file containing keywords to; control the GDMA code. Simply place the data file in the directory PSI4; is called from, and provide the file name as the datafile argument to the; gdma() routine. For example, if GDMA data file is called; control.dma, the GDMA code is called as follows:; grad, wfn = gradient('mp2', return_wfn=True); gdma(wfn, datafile='control.dma'). An FCHK file will be generated for the GDMA code to read; this file will have; the prefix given by WRITER_FILE_LABEL (if set), or else by the name; of the output file plus the name of the current molecule, and the suffix will; be ‘.fchk’. This FCHK file name should be passed to the ‘File’ keyword in the; DGMA data file, to ensure that the GDMA code reads the correct wavefunction; information.; After running, two matrices of results can be accessed:; dma_results = get_array_variable('DMA DISTRIBUTED MULTIPOLES'); tot_results = get_array_variable('DMA TOTAL MULTIPOLES'). The first contains distributed multipoles, in units given by; GDMA_MULTIPOLE_UNITS, with the row index corresponding to the site and; the column index referencing the multipole component. Both indices are zero; based, and the \(Q^l_m\) components of the multipoles are ordered as; \(Q^0_0, Q^1_0, Q^1_{1c}, Q^1_{1s}, Q^2_0, Q^2_{1c}, Q^2_{1s}, Q^2_{2c},; Q^2_{2s}, \ldots\) The second matrix returned has a single row, whose columns; are the total multipoles, translated to GDMA_ORIGIN, and summed. psi4.gdma(wfn)[source]; Function to use wavefunction information in wfn and, if specified,; additional commands in filename to run GDMA analysis. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate DMA analysis; datafile (str) – optional control file (see GDMA manual) to peform more complicated DMA; analyses. If this option is used, t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/gdma.html:2777,access,accessed,2777,psi4manual/1.7.x/gdma.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/gdma.html,2,['access'],['accessed']
Security,"in the; GDMA manual.; If more advanced usage is desired, which is not is permitted by the options; listed below, the user may provide their own data file containing keywords to; control the GDMA code. Simply place the data file in the directory PSI4; is called from, and provide the file name as the datafile argument to the; gdma() routine. For example, if GDMA data file is called; control.dma, the GDMA code is called as follows:; grad, wfn = gradient('mp2', return_wfn=True); gdma(wfn, datafile='control.dma'). An FCHK file will be generated for the GDMA code to read; this file will have; the prefix given by WRITER_FILE_LABEL (if set), or else by the name; of the output file plus the name of the current molecule, and the suffix will; be ‘.fchk’. This FCHK file name should be passed to the ‘File’ keyword in the; DGMA data file, to ensure that the GDMA code reads the correct wavefunction; information.; After running, two matrices of results can be accessed:; dma_results = get_array_variable('DMA DISTRIBUTED MULTIPOLES'); tot_results = get_array_variable('DMA TOTAL MULTIPOLES'). The first contains distributed multipoles, in units given by; GDMA_MULTIPOLE_UNITS, with the row index corresponding to the site and; the column index referencing the multipole component. Both indices are zero; based, and the \(Q^l_m\) components of the multipoles are ordered as; \(Q^0_0, Q^1_0, Q^1_{1c}, Q^1_{1s}, Q^2_0, Q^2_{1c}, Q^2_{1s}, Q^2_{2c},; Q^2_{2s}, \ldots\) The second matrix returned has a single row, whose columns; are the total multipoles, translated to GDMA_ORIGIN, and summed. psi4.gdma(wfn)[source]; Function to use wavefunction information in wfn and, if specified,; additional commands in filename to run GDMA analysis. New in version 0.6. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate DMA analysis; datafile (str) – optional control file (see GDMA manual) to peform more complicated DMA; analyses. If this option is used, the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/gdma-1.html:2777,access,accessed,2777,psi4manual/1.4.0/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/gdma-1.html,5,['access'],['accessed']
Security,"in the; GDMA manual.; If more advanced usage is desired, which is not is permitted by the options; listed below, the user may provide their own data file containing keywords to; control the GDMA code. Simply place the data file in the directory Psi4; is called from, and provide the file name as the datafile argument to the; gdma() routine. For example, if GDMA data file is called; control.dma, the GDMA code is called as follows:; grad, wfn = gradient('mp2', return_wfn=True); gdma(wfn, datafile='control.dma'). An FCHK file will be generated for the GDMA code to read; this file will have; the prefix given by WRITER_FILE_LABEL (if set), or else by the name; of the output file plus the name of the current molecule, and the suffix will; be ‘.fchk’. This FCHK file name should be passed to the ‘File’ keyword in the; DGMA data file, to ensure that the GDMA code reads the correct wavefunction; information.; After running, two matrices of results can be accessed:; dma_results = get_array_variable('DMA DISTRIBUTED MULTIPOLES'); tot_results = get_array_variable('DMA TOTAL MULTIPOLES'). The first contains distributed multipoles, in units given by; GDMA_MULTIPOLE_UNITS, with the row index corresponding to the site and; the column index referencing the multipole component. Both indices are zero; based, and the components of the multipoles are ordered as; The second matrix returned has a single row, whose columns; are the total multipoles, translated to GDMA_ORIGIN, and summed. gdma(wfn)[source]¶; Function to use wavefunction information in wfn and, if specified,; additional commands in filename to run GDMA analysis. New in version 0.6. Returns:None. Parameters:; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate DMA analysis; datafile (string) – optional control file (see GDMA manual) to peform more complicated DMA; analyses. If this option is used, the File keyword must be set to read; a filename.fchk, where filename is provided by WRITER_FILE_LABEL . Ex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/gdma-1.html:1970,access,accessed,1970,psi4manual/1.0.0/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/gdma-1.html,2,['access'],['accessed']
Security,"inc=failoninc,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); filedict[mc] = minifiledict; return filedict. [docs] def get_hrxn(self, sset='default'):; """""". """"""; rhrxn = OrderedDict(); for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); lss = self.sset[sset][dbix]; if lss is not None:; for rxn in odb.hrxn:; if rxn in odb.sset[lss]:; orxn = odb.hrxn[rxn]; rhrxn[orxn.dbrxn] = orxn # this is a change and conflict with vergil version; return rhrxn. [docs] def get_hrgt(self, sset='default', actv='default'):; """""". """"""; rhrxn = self.get_hrxn(sset=sset); rhrgt = OrderedDict(); for rxn, orxn in rhrxn.iteritems():; for orgt in orxn.rxnm[actv].keys():; rhrgt[orgt.name] = orgt; # TODO prob need to avoid duplicates or pass. return rhrgt. [docs] def get_reactions(self, modelchem, sset='default', benchmark='default',; failoninc=True):; """"""Collects the reactions present in *sset* from each WrappedDatabase,; checks that *modelchem* and *benchmark* ReactionDatum are present; (fails if *failoninc* True), then returns in an array a tuple for; each reaction containing the modelchem key needed to access; *modelchem*, the modelchem key needed to access *benchmark*, and; the Reaction object. """"""; dbdat = []; rhrxn = self.get_hrxn(sset=sset); for orxn in rhrxn.itervalues():; dbix = self.dbdict.keys().index(orxn.dbrxn.split('-')[0]); lmc = self.mcs[modelchem][dbix]; lbm = self.mcs[benchmark][dbix]; try:; orxn.data[lbm]; except KeyError as e:; # not sure if should treat bm differently; lbm = None; try:; orxn.data[lmc]; except KeyError as e:; if failoninc:; raise e; else:; lmc = None; dbdat.append((lmc, lbm, orxn)); # this is diff in that returning empties not just pass over- may break bfdb; # try:; # orxn.data[lmc]; # orxn.data[lbm]; # except KeyError as e:; # if failoninc:; # raise e; # else:; # # not sure yet if should return empties or just pass over; # pass; # else:; # dbdat.append((lmc, lbm, orxn)); return dbdat. [docs] def get_missing_reactions(se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:72717,access,access,72717,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,2,['access'],['access']
Security,"ince that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; # print(""about to generate displacements""); displacements = cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:38728,Validat,ValidationError,38728,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"ince that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; # print(""about to generate displacements""); displacements = cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:37555,Validat,ValidationError,37555,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"ince that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(). # no analytic derivatives for scf_type cd; if psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; psi4.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; psi4.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = psi4.fd_geoms_1_0(moleculeclone); ndisp = len(d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:36324,Validat,ValidationError,36324,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for FCHK files."""""". import re; from typing import Union. import numpy as np. from psi4 import core. from ..p4util.testing import compare_arrays, compare_integers, compare_strings, compare_values; from .exceptions import ValidationError. __all__ = [; ""compare_fchkfiles"",; ""compare_moldenfiles"",; ]. def _consume_fchk_section(input_list, index):; """"""compare a float or integer matrix section"""""". n = int(input_list[index].split()[-1]); kind = input_list[index].split()[-3]. if ""R"" in kind:; dtype = np.float64; format_counter = 5; elif ""I"" in kind:; dtype = np.float64; format_counter = 6; else:; raise ValidationError('Unknow field type in FCHK reader\n'). extra = 0 if n <= format_counter else n % format_counter; lines = 1 if n <= format_counter else int(n / format_counter); offset = lines + 1 if extra > 0 else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. def _fchkfile_to_string(fname: str) -> str:; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/fchk.html:1359,Validat,ValidationError,1359,psi4manual/1.9.x/_modules/psi4/driver/p4util/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/fchk.html,2,['Validat'],['ValidationError']
Security,"index(z) + 2) in bn_gz)]; for b in zetas:; if ZSET and (int(ZSET[len(ZSET) - 1]) - zeta_values.index(b)) != 1:; raise ValidationError(""""""Basis set '%s' has skipped zeta level '%s'."""""" %; (basisstring, _zeta_val2sym[_zeta_sym2val[b] - 1])); # reassemble def2-svp* properly instead of def2-dzvp*; if def2_basis.match(basisname.group('pre')) and b == ""d"":; BSET.append(basisname.group('pre') + ""s"" + basisname.group('post')[1:]); # reassemble pc-n basis sets properly; elif pc_basis.match(basisname.group('pre')):; BSET.append(basisname.group('pre') + ""{0:d}"".format(_zeta_sym2val[b] - 1)); # assemble nZaPa basis sets; elif zapa_basis.match(basisname.group('post')):; bzapa = b.replace(""d"", ""2"").replace(""t"", ""3"").replace(""q"", ""4""); BSET.append(basisname.group('pre') + bzapa + basisname.group('post')); else:; BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(; """"""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z*'. or 'def2-[sdtq]zvp*' or '*pcs[s]eg-[1234]' or '[1234567]ZaPa' """""" %; (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n""""""; elif isinstance(molecule, core.Molecule):; molecule = qcdb.Molecule(molecule.to_dict()). for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound:; e = sys.exc_info()[1]; raise ValidationError(f""""""Basis set '{basis}' not available for molecule.""""""). return (BSET, ZSET). def _contract_bracketed_basis(basisarray: List):; """"""Function to reform a bracketed basis set string from a sequential series; of basis sets. Essentially the inverse of _expand_bracketed_basis(). Used to; print a nicely formatted basis set string in the results table. Parameters; ----------; basisarray; Basis set names, differing by zeta level, e.g. ``[""cc-pvqz"", ""cc-pv5z""]``. Returns; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:4834,Validat,ValidationError,4834,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"index(z) + 2) in bn_gz)]; for b in zetas:; if ZSET and (int(ZSET[len(ZSET) - 1]) - zeta_values.index(b)) != 1:; raise ValidationError(""""""Basis set '%s' has skipped zeta level '%s'."""""" %; (basisstring, _zeta_val2sym[_zeta_sym2val[b] - 1])); # reassemble def2-svp* properly instead of def2-dzvp*; if def2_basis.match(basisname.group('pre')) and b == ""d"":; BSET.append(basisname.group('pre') + ""s"" + basisname.group('post')[1:]); # reassemble pc-n basis sets properly; elif pc_basis.match(basisname.group('pre')):; BSET.append(basisname.group('pre') + ""{0:d}"".format(_zeta_sym2val[b] - 1)); # assemble nZaPa basis sets; elif zapa_basis.match(basisname.group('post')):; bzapa = b.replace(""d"", ""2"").replace(""t"", ""3"").replace(""q"", ""4""); BSET.append(basisname.group('pre') + bzapa + basisname.group('post')); else:; BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(; """"""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z*'. or 'def2-[sdtq]zvp*' or '*pcs[s]eg-[1234]' or '[1234567]ZaPa' """""" %; (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n""""""; elif isinstance(molecule, core.Molecule):; molecule = qcdb.Molecule(molecule.to_dict()). for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound:; e = sys.exc_info()[1]; raise ValidationError(f""""""Basis set '{basis}' not available for molecule.""""""). return (BSET, ZSET). def _contract_bracketed_basis(basisarray: List[str]) -> str:; """"""Function to re-form a bracketed basis set string from a sequential series; of basis sets. Essentially the inverse of _expand_bracketed_basis(). Used to; print a nicely formatted basis set string in the results table. Parameters; ----------; basisarray; Basis set names, differing by zeta level, e.g. ``[""cc-pvqz"", ""cc-pv5z""]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:9520,Validat,ValidationError,9520,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,5,['Validat'],['ValidationError']
Security,"individual energies.   1_((1, 2), (1, 2));   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_gradient; ntasks; when driver is g/h; all individual gradients.   1_((1, 2), (1, 2));   (nat, 3); when driver is g/h; total gradient for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat, 3); when driver is g/h; total gradient for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_hessian; ntasks; when driver is h; all individual Hessians.   1_((1, 2), (1, 2));   (nat*3, nat*3); when driver is h; total Hessian for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat*3, nat*3); when driver is h; total Hessian for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. validator set_bsse_type  »  bsse_type[source]¶. validator set_embedding_charges  »  embedding_charges[source]¶. validator set_max_nbody  »  max_nbody[source]¶. validator set_molecule  »  molecule[source]¶. validator set_nfragments  »  nfragments[source]¶. validator set_return_total_data  »  return_total_data[source]¶. table of contents. Basis Set Superposition Corrections; nbody(); API; BsseEnum; BsseEnum.cp; BsseEnum.nocp; BsseEnum.vmfc. ManyBodyComputer; ManyBodyComputer.basis; ManyBodyComputer.bsse_type; ManyBodyComputer.driver; ManyBodyComputer.embedding_charges; ManyBodyComputer.keywords; ManyBodyComputer.max_nbody; ManyBodyComputer.method; ManyBodyComputer.molecule; ManyBodyComputer.nbodies_per_mc_level; ManyBodyComputer.nfragments; ManyBodyComputer.quiet; ManyBodyComputer.return_total_data; ManyBodyComputer.task_list; ManyBodyComputer.build_tasks(); ManyBodyComputer.compute(); ManyBodyComputer.get_psi_results(); ManyBodyComputer.get_results(); ManyBodyComputer.plan(); ManyBodyComputer.prepare_results(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/nbody.html:34958,validat,validator,34958,psi4manual/master/nbody.html,https://psicode.org,https://psicode.org/psi4manual/master/nbody.html,3,['validat'],['validator']
Security,"ine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return ""xtpl_highest_1""; elif xtpl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata; List of dicts containing CBS stage keywords.; molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". # TODO: split options into mixable (qc_module=ccenergy/"""") or non-mixable (freeze_core=true/false). metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:17297,validat,validates,17297,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,3,['validat'],['validates']
Security,"ine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return ""xtpl_highest_1""; elif xtpl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata; List of dicts containing CBS stage keywords.; molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:17223,validat,validates,17223,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,2,['validat'],['validates']
Security,"ing and validator functions, so no class __init__ needed. [docs] @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs] @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs] @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs] @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs] @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs] @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs] def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*. Parameters; ----------; mb_computer; Class of task computers to instantiate and add to self.task_list. Usually :class:`~psi4.driver.AtomicComputer` but may be other when wrappers are layered.; mc_level_idx; Position in field self.nbodies_per_mc_level used to obtain ``nbodies``, the list of n-body; levels (e.g., `[1]` or `[1, 2]` or `[""supersyst",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:35552,validat,validator,35552,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,1,['validat'],['validator']
Security,"ing files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; r""""""Module to provide mechanism to store and restore option states in driver. """""". __all__ = [; ""OptionState"",; ""OptionsStateCM"",; ""OptionsState"",; ]. from contextlib import contextmanager; from typing import Iterator, List, Optional. from psi4 import core. from .exceptions import ValidationError. [docs]; class OptionState():; """"""Store the state (value and changed status) of a single `option`. Parameters; ----------; option; Name of read_options keyword. All caps.; module; Name of read_options module or None if global. All caps.; If `module` given, the `option` value and has_changed value is stored; for global, local to `module`, and used by `module` scopes. Otherwise; (used for BASIS keywords), only global scope is stored. Examples; --------; >>> OptionState('E_CONVERGENCE', 'SCF'). >>> print(OptionState('DF_BASIS_MP2')). """""". def __init__(self, option: str, module: Optional[str] = None):; self.option = option.upper(); if module:; self.module = module.upper(); else:; self.module = None. self.value_global = core.get_global_option(option); self.haschanged_global = core.has_global_option_changed(option); if self.module:; self.value_local = core.get_local_option(self.module, option); self.haschanged_local = core.has_local_option_changed(self.module, option); self.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/optproc.html:1397,Validat,ValidationError,1397,psi4manual/1.9.x/_modules/psi4/driver/p4util/optproc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/optproc.html,2,['Validat'],['ValidationError']
Security,"ing option. add_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None; add string option. get_bool(self: psi4.core.Options, arg0: str) → bool; get boolean option. get_current_module(self: psi4.core.Options) → str; gets current module. get_double(self: psi4.core.Options, arg0: str) → float; get double option. get_int(self: psi4.core.Options, arg0: str) → int; get integer option. get_int_vector(self: psi4.core.Options, arg0: str) → List[int]; get int vector option. get_str(*args, **kwargs); Overloaded function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. print_global_options(self: psi4.core.Options) → None; print the global, cross-module options. print_module_options(self: psi4.core.Options) → None; print global and local options prepared for current module. read_globals(self: psi4.core.Options) → bool; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str) → None; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool) → None; set bool option. set_current_module(self: psi4.core.Options, arg0: str) → None; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float) → None; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int) → None; set int option. set_read_globals(self: psi4.core.Options, arg0: bool) → None; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None; set string option. validate_options(self: psi4.core.Options) → None; validate options for arg0 module. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.options.html:5518,validat,validate,5518,psi4manual/1.3.2/api/psi4.core.options.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.options.html,1,['validat'],['validate']
Security,"ing(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); text += "" %d %s %d %s\n"" % (now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(10); text += "" %d %s %d %s %d %s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compute()); # Check for NaN, and don't update if we find one; # what is this? proper py traslation?; if val == val:; self.dval.rset(val * 180.0 / math.pi). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'ZMatrixCoord'. [docs] def clone(self):; """"""Returns new, independent ZMatrixEntry object.""""""; return copy.d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:17212,Validat,ValidationError,17212,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['Validat'],['ValidationError']
Security,"ing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False)¶; Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Returns. Return type; psi4.core.Molecule. static from_dict(arg0: dict) → psi4.core.Molecule¶; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1)¶; Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters. molschema (Dict) – Dictionary form of Molecule following known schema.; return_dict (bool) – Additionally return Molecule dictionary intermediate.; nonphysical (bool) – Do allow masses outside an element’s natural range to pass validation?; verbose (int) – Amount of printing. Return type; Union[Molecule, Tuple[Molecule, Dict]]. Returns. mol (psi4.core.Molecule); molrec (dict) – Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=True, enable_efp=True, missing_enabled_return_qm='none', missing_enabled_return_efp='none', verbose=1)¶. fsymbol(self: psi4.core.Molecule, atom: int) → str¶; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self: psi4.core.Molecule) → psi4.core.Matrix¶; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self: psi4.core.Molecule) → int¶; Gets n in Cnv, etc.; If there is no n (e.g. Td",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html:20925,validat,validation,20925,psi4manual/1.4.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html,2,['validat'],['validation']
Security,"input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. @classmethod; [docs] def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(r'^(?:\s*)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER +; '(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)', re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match hea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:7071,Validat,ValidationError,7071,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"int level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val)¶; Sets scalar or array QCVariable key to val on self.; :rtype: None. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float]) – Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError – If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction) – Wavefunction or inherited class instance.; filename (Optional[str]) – An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key)¶; Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:24799,Validat,ValidationError,24799,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,1,['Validat'],['ValidationError']
Security,"int volume. """"""; optionre = re.compile(r'\A(?P<module>\w+__)?(?P<option>\w+)\Z', re.IGNORECASE); rejected = {}. for k, v, in options_dict.items():. mobj = optionre.match(k.strip()); module = mobj.group('module').upper()[:-2] if mobj.group('module') else None; option = mobj.group('option').upper(). if module:; if ((module, option, v) not in [('SCF', 'GUESS', 'READ')]) and ((module, option) not in [('PCM', 'INPUT')]):; # TODO guess/read exception is for distributed driver. should be handled differently.; try:; core.set_local_option(module, option, v); except RuntimeError as err:; rejected[k] = (v, err); if verbose > 1:; print('Setting: core.set_local_option', module, option, v). if (module, option) == (""PCM"", ""INPUT""):; pcm_helper(v). else:; try:; core.set_global_option(option, v); except RuntimeError as err:; rejected[k] = (v, err); if verbose > 1:; print('Setting: core.set_global_option', option, v). if rejected:; raise ValidationError(f'Error setting options: {rejected}'); # TODO could subclass ValidationError and append rejected so that run_json could handle remanants. [docs]def set_module_options(module: str, options_dict: Dict[str, Any]) -> None:; """"""; Sets Psi4 module options from a module specification and input dictionary.; """"""; warnings.warn(; ""Using `psi4.set_module_options(<module>, {<key>: <val>})` instead of `psi4.set_options({<module>__<key>: <val>})` is deprecated, and as soon as 1.5 it will stop working\n"",; category=FutureWarning,; stacklevel=2). for k, v, in options_dict.items():; core.set_local_option(module.upper(), k.upper(), v). ## OEProp helpers. [docs]def pcm_helper(block: str):; """"""; Passes multiline string *block* to PCMSolver parser. Parameters; ----------; block; multiline string with PCM input in PCMSolver syntax.; """"""; import pcmsolver. with NamedTemporaryFile(mode=""w+t"", delete=True) as fl:; fl.write(block); fl.flush(); parsed_pcm = pcmsolver.parse_pcm_input(fl.name). with NamedTemporaryFile(mode=""w+t"", delete=False) as fl:; fl.write(pa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:13419,Validat,ValidationError,13419,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"int volume. """"""; optionre = re.compile(r'\A(?P<module>\w+__)?(?P<option>\w+)\Z', re.IGNORECASE); rejected = {}. for k, v, in options_dict.items():. mobj = optionre.match(k.strip()); module = mobj.group('module').upper()[:-2] if mobj.group('module') else None; option = mobj.group('option').upper(). if module:; if ((module, option, v) not in [('SCF', 'GUESS', 'READ')]) and ((module, option) not in [('PCM', 'INPUT')]):; # TODO guess/read exception is for distributed driver. should be handled differently.; try:; core.set_local_option(module, option, v); except RuntimeError as err:; rejected[k] = (v, err); if verbose > 1:; print('Setting: core.set_local_option', module, option, v). if (module, option) == (""PCM"", ""INPUT""):; pcm_helper(v). else:; try:; core.set_global_option(option, v); except RuntimeError as err:; rejected[k] = (v, err); if verbose > 1:; print('Setting: core.set_global_option', option, v). if rejected:; raise ValidationError(f'Error setting options: {rejected}'); # TODO could subclass ValidationError and append rejected so that run_json could handle remanants. [docs]def set_module_options(module: str, options_dict: Dict[str, Any]) -> None:; """"""; Sets Psi4 module options from a module specification and input dictionary.; """"""; warnings.warn(; ""Using `psi4.set_module_options(<module>, {<key>: <val>})` instead of `psi4.set_options({<module>__<key>: <val>})` is deprecated, and in 1.5 it will stop working\n"",; category=FutureWarning,; stacklevel=2). for k, v, in options_dict.items():; core.set_local_option(module.upper(), k.upper(), v). ## OEProp helpers. [docs]def pcm_helper(block: str):; """"""; Passes multiline string *block* to PCMSolver parser. Parameters; ----------; block; multiline string with PCM input in PCMSolver syntax.; """"""; import pcmsolver. with NamedTemporaryFile(mode=""w+t"", delete=True) as fl:; fl.write(block); fl.flush(); parsed_pcm = pcmsolver.parse_pcm_input(fl.name). with NamedTemporaryFile(mode=""w+t"", delete=False) as fl:; fl.write(parsed_pcm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:13365,Validat,ValidationError,13365,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['Validat'],['ValidationError']
Security,"int(; """"""Following warning is harmless if you've altered chgmult through `set_molecular_change` or `set_multiplicity`. Such alterations are an expert feature. Specifying in the original molecule string is preferred.""""""; ); molrec['fragment_charges'] = [None] * len(fragments); molrec['fragment_multiplicities'] = [None] * len(fragments); validated_molrec = qcel.molparse.from_arrays(speclabel=False, verbose=0, domain='qm', **molrec); forgive.append('fragment_charges'); forgive.append('fragment_multiplicities'); compare_molrecs(validated_molrec, molrec, 6, 'to_dict', forgive=forgive, verbose=0). # from_arrays overwrites provenance; validated_molrec['provenance'] = copy.deepcopy(molrec['provenance']). if not np_out:; validated_molrec = qcel.util.unnp(validated_molrec). return validated_molrec. @classmethod; def from_dict(cls, molrec, verbose=1):. mol = cls(); mol._internal_from_dict(molrec=molrec, verbose=verbose); return mol. def _internal_from_dict(self, molrec, verbose=1):; """"""Constructs instance from fully validated and defaulted dictionary `molrec`."""""". # Compromises for qcdb.Molecule; # * molecular_charge is int, not float; # * fragment_charges are int, not float. self.lock_frame = False. if 'name' in molrec:; self.set_name(molrec['name']). if 'comment' in molrec:; self.set_comment(molrec['comment']). self.set_provenance(copy.deepcopy(molrec['provenance'])). if 'connectivity' in molrec:; self.set_connectivity(copy.deepcopy(molrec['connectivity'])). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat], Z, label,; molrec['elea'][iat]); for var in molrec['variables']:; self.s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:47454,validat,validated,47454,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,1,['validat'],['validated']
Security,"int_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:168218,Validat,ValidationError,168218,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"interfragment stretching coordinate instead of R. Type: boolean; Default: false. INTERFRAG_HESS¶. Model Hessian to guess interfragment force constants. Type: string; Possible Values: DEFAULT, FISCHER_LIKE; Default: DEFAULT. INTERFRAG_MODE¶. When interfragment coordinates are present, use as reference points either principal axes or fixed linear combinations of atoms. Type: string; Possible Values: FIXED, PRINCIPAL_AXES; Default: FIXED. Misc.¶. OPT_RESTART¶. Restart the optimization from optking’s written history. Type: double; Default: 0. PRINT_TRAJECTORY_XYZ_FILE¶. Should an xyz trajectory file be kept (useful for visualization)?. Type: boolean; Default: false. SAVE_OPTIMIZATION¶. Save OptKing’s internal classes for possible restart upon error. Type: boolean; Default: false. TEST_B¶. Do test B matrix?. Type: boolean; Default: false. TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. WRITE_OPT_HISTORY¶. Write the full history to disk. Produces a non validated OptimizationResult. Type: boolean; Default: false. WRITE_OPT_RESULT¶. Write the optimization history / state to disc. Type: boolean; Default: false. WRITE_TRAJECTORY¶. Write Optimization Trajectory. Type: boolean; Default: false. table of contents. OPTKING; Optimization Algorithm; CARTESIAN_SYM_TOLERANCE; CONSECUTIVE_BACKSTEPS; CUSTOM_COORDS; DYNAMIC_LEVEL; ENSURE_BT_CONVERGENCE; EXT_FORCE_BEND; EXT_FORCE_CARTESIAN; EXT_FORCE_DIHEDRAL; EXT_FORCE_DISTANCE; EXT_FORCE_OOFP; FREEZE_ALL_DIHEDRALS; FROZEN_BEND; FROZEN_CARTESIAN; FROZEN_DIHEDRAL; FROZEN_DISTANCE; FROZEN_OOFP; GEOM_MAXITER; H_UPDATE_DEN_TOL; INTERFRAG_STEP_LIMIT; INTRAFRAG_STEP_LIMIT; INTRAFRAG_STEP_LIMIT_MAX; INTRAFRAG_STEP_LIMIT_MIN; IRC_DIRECTION; IRC_POINTS; IRC_STEP_SIZE; OPT_COORDINATES; OPT_TYPE; PRINT_OPT_PARAMS; RANGED_BEND; RANGED_DIHEDRAL; RANGED_DISTANCE; RANGED_OOFP; RFO_FOLLOW_ROOT; RFO_NORMALIZATION_MAX; RFO_ROOT; RSRFO_ALPHA_MAX; STEP_TYPE; UNFREEZE_DIHEDRALS. Convergence Control; FLEXIBLE_G_CONVERGENCE; G_C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__optking.html:11019,validat,validated,11019,psi4manual/master/autodir_options_c/module__optking.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__optking.html,1,['validat'],['validated']
Security,"interfragment stretching coordinate instead of R. Type: boolean; Default: false. INTERFRAG_HESS¶. Model Hessian to guess interfragment force constants. Type: string; Possible Values: DEFAULT, FISCHER_LIKE; Default: DEFAULT. INTERFRAG_MODE¶. When interfragment coordinates are present, use as reference points either principal axes or fixed linear combinations of atoms. Type: string; Possible Values: FIXED, PRINCIPAL_AXES; Default: FIXED. Misc.¶. OPT_RESTART¶. Restart the optimization from optking’s written history. Type: double; Default: 0. PRINT_TRAJECTORY_XYZ_FILE¶. Should an xyz trajectory file be kept (useful for visualization)?. Type: boolean; Default: false. SAVE_OPTIMIZATION¶. Save OptKing’s internal classes for possible restart upon error. Type: boolean; Default: false. TEST_B¶. Do test B matrix?. Type: boolean; Default: false. TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. WRITE_OPT_HISTORY¶. Write the full history to disk. Produces a non validated OptimizationResult. Type: boolean; Default: false. WRITE_OPT_RESULT¶. Write the optimization history / state to disc. Type: boolean; Default: false. WRITE_TRAJECTORY¶. Write Optimization Trajectory. Type: boolean; Default: false. table of contents. OPTKING; Optimization Algorithm; CARTESIAN_SYM_TOLERANCE; CONSECUTIVE_BACKSTEPS; DYNAMIC_LEVEL; ENSURE_BT_CONVERGENCE; EXT_FORCE_BEND; EXT_FORCE_CARTESIAN; EXT_FORCE_DIHEDRAL; EXT_FORCE_DISTANCE; EXT_FORCE_OOFP; FROZEN_BEND; FROZEN_CARTESIAN; FROZEN_DIHEDRAL; FROZEN_DISTANCE; FROZEN_OOFP; GEOM_MAXITER; H_UPDATE_DEN_TOL; INTERFRAG_STEP_LIMIT; INTRAFRAG_STEP_LIMIT; INTRAFRAG_STEP_LIMIT_MAX; INTRAFRAG_STEP_LIMIT_MIN; IRC_DIRECTION; IRC_POINTS; IRC_STEP_SIZE; OPT_COORDINATES; OPT_TYPE; PRINT_OPT_PARAMS; RANGED_BEND; RANGED_DIHEDRAL; RANGED_DISTANCE; RANGED_OOFP; RFO_FOLLOW_ROOT; RFO_NORMALIZATION_MAX; RFO_ROOT; RSRFO_ALPHA_MAX; STEP_TYPE. Convergence Control; FLEXIBLE_G_CONVERGENCE; G_CONVERGENCE; MAX_DISP_G_CONVERGENCE; MAX_ENERGY_G_CONVERGE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__optking.html:10496,validat,validated,10496,psi4manual/1.7.x/autodir_options_c/module__optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__optking.html,3,['validat'],['validated']
Security,"into a complete set (keys of; dashcoeff[dashlevel][‘default’]) from name_hint and/or; dashcoeff_supplement and/or user param_tweaks. Type:dict. fctldash¶; If dashparams for dashlevel corresponds to a defined,; named, untweaked “functional-dashlevel” set, then that; functional. Otherwise, empty string. Type:str. description¶; Tagline for dispersion dashlevel. Type:str. dashlevel_citation¶; Literature reference for dispersion dashlevel in general,; not necessarily for dashparams. Type:str. dashparams_citation¶; Literature reference for dispersion parameters, if dashparams; corresponds to a defined, named, untweaked “functional-dashlevel”; set with a citation. Otherwise, empty string. Type:str. dashcoeff_supplement¶; See description in qcdb.intf_dftd3.dashparam.from_arrays. Used; here to “bless” the dispersion definitions attached to; the procedures/dft/*_functionals-defined dictionaries; as legit, non-custom, and of equal validity to; qcdb.intf_dftd3.dashparam.dashcoeff itself for purposes of; validating fctldash. Type:dict. engine¶; Compute engine for dispersion. One of Psi4’s internal libdisp; library, Grimme’s DFTD3 executable, or nl. Type:{‘libdisp’, ‘dftd3’, ‘nl’}. disp¶; Only present for engine=libdisp. Psi4 class instance prepared; to compute dispersion. Type:psi4.core.Dispersion. ordered_params¶; Fixed-order list of relevant parameters for dashlevel. Matches; DFT_DISPERSION_PARAMETERS ordering. Used for printing. Type:list. Parameters:; name_hint (str, optional) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via `param_tweaks.; level_hint (str, optional) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; pa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.empiricaldispersion.html:1723,validat,validating,1723,psi4manual/1.3.2/api/psi4.driver.empiricaldispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.empiricaldispersion.html,1,['validat'],['validating']
Security,"ints = core.MintsHelper(ref_wfn.basisset()); mints.set_print(1); mints.integrals(). ref_optstash.restore(). # The DF case; if core.get_option('DETCI', 'MCSCF_TYPE') == 'DF':; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). # The AO case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'AO':; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_option('SCF', 'SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.set_oeprop(oeprop); core.set_variable(""CURRENT DIPOLE X"", core.get_variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.get_variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.get_variable(name.upper() + "" DIPOLE Z"")). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """"""; # initialize library; efp = core.get_active_efp().",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:126373,Validat,ValidationError,126373,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"ion (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * physconst.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * physconst.psi_hartree2kcalmol); line3 = ' SAPT Charge Transfer %10.4lf mH %10.4lf kcal mol^-1\n\n' % (CT * 1000.0, CT * physconst.psi_hartree2kcalmol); PsiMod.print_out(line1); PsiMod.print_out(line2); PsiMod.print_out(line3); PsiMod.set_variable('SAPT CT ENERGY', CT). molecule.reset_point_group(user_pg); molecule.update_geometry(). return e_sapt. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; # TODO: Check to see if we really need to run the SCF code.; run_scf(name, **kwargs). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to PsiMod.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = PsiMod.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) == False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); PsiMod.mrcc_generate_input(level). # Lo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:33139,Validat,ValidationError,33139,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,2,['Validat'],['ValidationError']
Security,"ion below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control Keywords, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to \(10^{-6} E_h\), the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Notes on Psivars¶. Note; Starting in 1.6, there are three standard ways to access an excited state; property. We give examples below, but the method name and property name may change.; * method ROOT 0 -> ROOT m property to get root m. method ROOT 0 -> ROOT m property - h TRANSITION to get root m andindependently specify that the total transition symmetry is h, e.g., A2. method ROOT 0 (h) -> ROOT m (i) property to get the transition; between two roots, specifying the symmetry of both states and the index of the target; roots among states of their own symmetry. For example, to target the second excited-state, which is also the lowest energy state; of its irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much more strongly than; with the molecular system. Changing the number of roots sought, the symmetry; subspace or the symmetry apportionment of roots under which the computation is run,; or the excited state method are all likely to sc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/notes_c.html:1233,access,access,1233,psi4manual/1.6.x/notes_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html,1,['access'],['access']
Security,"ion is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). psimrcc_e = core.psimrcc(ref_wfn). return ref_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). if (core.get_option('SCF', 'REFERENCE') != 'RHF') and (name.upper() != ""SAPT0""):; raise ValidationError('Only SAPT0 supports a reference different from \""reference rhf\"".'). do_delta_mp2 = True if name.endswith('dmp2') else False. # raise Exception(""""). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); if do_delta_mp2:; select_mp2(name, ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.get_variable('MP2 CORRELATION ENERGY'). if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:100642,Validat,ValidationError,100642,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"ion is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). psimrcc_e = core.psimrcc(ref_wfn). return ref_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). if (core.get_option('SCF', 'REFERENCE') != 'RHF') and (name.upper() != ""SAPT0""):; raise ValidationError('Only SAPT0 supports a reference different from \""reference rhf\"".'). do_delta_mp2 = True if name.endswith('dmp2') else False. # raise Exception(""""). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); if do_delta_mp2:; select_mp2(name, ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:99680,Validat,ValidationError,99680,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"ion is iffy; if np.count_nonzero(it - np.diag(np.diagonal(it))):; ar = '~' + ar. return ar. @staticmethod; def _raw_to_arrays(self):; """"""Exports coordinate info into NumPy arrays. Returns; -------; geom, mass, elem, elez, uniq : ndarray, ndarray, ndarray, ndarray, ndarray; (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost. Usage; -----; geom, mass, elem, elez, uniq = molinstance.to_arrays(). """"""; self.update_geometry(); if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.geometry()); mass = np.asarray([self.mass(at) for at in range(self.natom())]); elem = np.asarray([self.symbol(at) for at in range(self.natom())]); elez = np.asarray([self.Z(at) for at in range(self.natom())]); uniq = np.asarray(; [hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest() for at in range(self.natom())]). return geom, mass, elem, elez, uniq. @staticmethod; def from_string(molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = molparse.from_string(molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,. elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,. name=None,; u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:39708,hash,hashlib,39708,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['hash'],['hashlib']
Security,"ion mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:33851,Validat,ValidationError,33851,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"ion of TS for HCN to HNC Performs finite difference hessian calculation. Then optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the plane of symemtry, This test confirms that only the reference geometry, with the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. extern4; External potential calculation involving a TIP3P water and a QM water. Gradient on the external charges is compared to gradient on the QM atoms to validate the gradient on the charges. tdscf-7; TD-HF test variable access. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). mom-h2o-3; MOM excitation from LUMO HOMO+3. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. fsapt-ext-abc; FSAPT with external charge on trimer. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). mcscf1; ROHF 6-31G*",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:17246,validat,validate,17246,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['validat'],['validate']
Security,"ion on integral classes, derivatives, and AM from currently linked Libint2. libint2_print_out(). mdi_run(scf_method, **kwargs); Begin functioning as an MDI (MolSSI driver interface) engine. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Helper to specify the multiline PCMSolver syntax for PCM. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_method(name); Replace characters in method name so that suitable for function name or Sphinx table anchor (both as-is) or HTML table link (replace underscore in returned string by dash). sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, ...); Builds the correct (R/U/RO/CU HF/KS) wavefunction from the provided information, sets relevant auxiliary basis sets on it, and prepares any empirical dispersion. set_memory(inputval[, execute, quiet]); Reset the total memory",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:19594,validat,validate,19594,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,1,['validat'],['validate']
Security,"ion parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Corr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:81095,Validat,ValidationError,81095,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,"ion(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif kind not in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(tex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:115474,Validat,ValidationError,115474,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"ion(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif kind not in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:119207,Validat,ValidationError,119207,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['Validat'],['ValidationError']
Security,"ion(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif not kind in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif not kind in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and not ""cvs"" in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; try:; adcc.set_n_threads(core.get_num_threads()); except AttributeError:; # Before adcc 0.13.3:; adcc.thread_pool.reinit(core.get_num_threads(), core.get_num_threads()). # Hack to direct the stream-l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:113189,Validat,ValidationError,113189,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"ion('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); elif name == 'mp4(sdq)':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', False); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); elif name == 'fno-mp4(sdq)':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', False); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); elif name == 'mp3':; core.set_local_option('FNOCC', 'RUN_MP3', True); elif name == 'mp4':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""""""Error: {name} requires 'reference rhf'.""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:158745,Validat,ValidationError,158745,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"ion('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); elif name == 'mp4(sdq)':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', False); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); elif name == 'fno-mp4(sdq)':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', False); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); elif name == 'mp3':; core.set_local_option('FNOCC', 'RUN_MP3', True); elif name == 'mp4':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""""""Error: {name} requires 'reference rhf'.""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:167361,Validat,ValidationError,167361,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"ion('SCF', 'REFERENCE') == 'UKS':; PsiMod.set_global_option('REFERENCE', 'UHF'); else:; pass; elif lowername == 'rhf':; PsiMod.set_global_option('REFERENCE', 'RHF'); elif lowername == 'uhf':; PsiMod.set_global_option('REFERENCE', 'UHF'); elif lowername == 'rohf':; PsiMod.set_global_option('REFERENCE', 'ROHF'); elif lowername == 'rscf':; if (len(PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_local_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; PsiMod.set_global_option('REFERENCE', 'RKS'); else:; PsiMod.set_global_option('REFERENCE', 'RHF'); elif lowername == 'uscf':; if (len(PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_local_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; PsiMod.set_global_option('REFERENCE', 'UKS'); else:; PsiMod.set_global_option('REFERENCE', 'UHF'); elif lowername == 'roscf':; if (len(PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_local_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; raise ValidationError('ROHF reference for DFT is not available.'); else:; PsiMod.set_global_option('REFERENCE', 'ROHF'). returnvalue = scf_helper(name, **kwargs). PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'); PsiMod.set_global_option('SCF_TYPE', user_scftype); if not b_user_scftype:; PsiMod.revoke_global_option_changed('SCF_TYPE'). return returnvalue. [docs]def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". run_scf(name, **kwargs). if (PsiMod.get_global_option('SCF_TYPE') == 'DF'):; PsiMod.scfgrad(); else:; PsiMod.deriv(). [docs]def run_libfock(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a calculation through libfock, namely RCPHF,; RCIS, RTDHF, RTDA, and RTDDFT. """"""; if (name.lower",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:2995,Validat,ValidationError,2995,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"ion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calcu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:39773,Validat,ValidationError,39773,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"ion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 's",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:37511,Validat,ValidationError,37511,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"ion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 's",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:36338,Validat,ValidationError,36338,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"ion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='gradient', **kwargs); else:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(). # no analytic derivatives for scf_type cd; if psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 's",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:35107,Validat,ValidationError,35107,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"ion.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_legacy_frequencies(cls):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.legacy_frequencies` (accessing c-side member data) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.legacy_frequencies(). def _core_wavefunction_set_frequencies(cls, val):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_frequencies` (accessing c-side member data) instead of `psi4.core.Wavefunction.frequency_analysis` (py-side member data) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_legacy_frequencies(val). core.Wavefunction.frequencies = _core_wavefunction_frequencies; core.Wavefunction.legacy_frequencies = _core_wavefunction_legacy_frequencies; core.Wavefunction.set_frequencies = _core_wavefunction_set_frequencies. def _core_wavefunction_X(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.X` instead of `psi4.core.Wavefunction.lagrangian` is deprecated, and as soon as 1.5 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.lagrangian",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:38187,access,accessing,38187,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,1,['access'],['accessing']
Security,"ionError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2angstroms; fileY /= psi_bohr2angstroms; fileZ /= psi_bohr2angstroms. # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Molecule::init_with_xyz: Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out(self):; """"""Print the molecule.; (method name in libmints is print). >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.5996",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:24892,Validat,ValidationError,24892,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"ionError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:34184,Validat,ValidationError,34184,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"ionError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:34901,Validat,ValidationError,34901,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"ionally returns; Wavefunction. PSIthonPsiAPI# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). # power user returns; E, wfn = psi4.energy(..., return_wfn=True); E, wfn = psi4.optimize(..., return_wfn=True); E, wfn = psi4.frequency(..., return_wfn=True); G, wfn = psi4.gradient(..., return_wfn=True) # used by optimize(); H, wfn = psi4.hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print(wfn.gradient().rms()). # format output for other programs; psi4.molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:. PSIthonPsiAPIbasis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; psi4.set_options({""basis"": basis_set}); psi4.energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water. PSIthonPsiAPImolecule h2o{; O; H ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:12001,access,access,12001,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['access'],['access']
Security,"ions >>>. [docs] def make_table(self):; """"""This function will generate a character table for the point; group. This character table is in the order that symmetry; operations are generated, not in Cotton order. If this is a; problem, tough. Also generate the transformation matrices.; This fills in the irrep and symop arrays. """"""; # set nt and nirrep; if self.PYbits in [; PointGroups['C1']]:; self.PYnirrep = 1; self.nt = 1. elif self.PYbits in [; PointGroups['CsX'],; PointGroups['CsY'],; PointGroups['CsZ'],; PointGroups['Ci']]:; self.PYnirrep = 2; self.nt = 1. elif self.PYbits in [; PointGroups['C2X'],; PointGroups['C2Y'],; PointGroups['C2Z']]:; self.PYnirrep = 2; self.nt = 2. elif self.PYbits in [; PointGroups['C2hX'],; PointGroups['C2hY'],; PointGroups['C2hZ'],; PointGroups['C2vX'],; PointGroups['C2vY'],; PointGroups['C2vZ'],; PointGroups['D2']]:; self.PYnirrep = 4; self.nt = 2. elif self.PYbits in [; PointGroups['D2h']]:; self.PYnirrep = 8; self.nt = 2. else:; raise ValidationError(""Should not have receached here!""). if self.PYnirrep == 0:; return 0. so = SymmetryOperation(); self.PYgamma = []; self.symop = []; self.inv = []; for h in range(self.PYnirrep):; self.PYgamma.append(IrreducibleRepresentation()); self.symop.append(SymmetryOperation()); self.inv.append(0). # this array forms a reducible representation for rotations about x,y,z; rot = zero(self.PYnirrep, 1). # this array forms a reducible representation for translations along x,y,z; trans = zero(self.PYnirrep, 1). # the angle to rotate about the principal axis; theta = 2.0 * math.pi if self.nt == 0 else 2.0 * math.pi / self.nt. # Handle irreducible representations; set PYgamma; if self.PYbits in [; PointGroups['C1']]:; # no symmetry case; self.PYgamma[0].init(1, 1, ""A"", ""A""); self.PYgamma[0].PYnrot = 3; self.PYgamma[0].PYntrans = 3; self.PYgamma[0].rep[0][0][0] = 1.0. elif self.PYbits in [; PointGroups['CsX'], # reflection through the yz plane; PointGroups['CsY'], # reflection through the xz plane; PointGrou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:26170,Validat,ValidationError,26170,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security,"ions of the same class together. For example, in C3v; there are two distinct C3 rotations and 3 distinct reflections, each; with a separate character. Thus symop has 6 elements rather than the 3; you'll find in most published character tables. """""". def __init__(self, *args):; """"""Constructor"""""". # order of the principal rot axis; self.nt = 0; # the class of the point group; self.pg = PointGroups['C1']; # the number of irreps in this pg; self.PYnirrep = 0; # an array of irreps; self.PYgamma = 0; # the matrices describing sym ops; self.symop = 0; # index of the inverse symop; self.inv = 0; # the Schoenflies symbol for the pg; self.symb = 0; # Bitwise representation of the symmetry operations; self.PYbits = 0. # Divert to constructor functions; if len(args) == 0:; pass; elif len(args) == 1 and \; isinstance(args[0], basestring):; self.constructor_schoenflies(*args); elif len(args) == 1 and \; isinstance(args[0], int):; self.constructor_bits(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_schoenflies(self, cpg):; """"""This constructor takes the Schoenflies symbol of a point group; as input. """"""; self.symb = cpg; # Check the symbol coming in; self.PYbits = PointGroup.full_name_to_bits(cpg); if self.PYbits is None:; raise ValidationError('CharacterTable: Invalid point group name: %s\n' % (cpg)); self.common_init(). [docs] def constructor_bits(self, bits):; """"""This constructor takes the bitswise representation of a point; group as input. """"""; self.PYbits = bits; self.symb = PointGroup.bits_to_basic_name(bits); self.common_init(). [docs] def common_init(self):; """"""First parse the point group symbol, this will give us the; order of the point group(g), the type of point group (pg), the; order of the principle rotation axis (nt), and the number of; irreps (nirrep). """"""; if len(self.symb) == 0:; raise ValidationError('CharacterTable::CharacterTable: null p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:21188,Validat,ValidationError,21188,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security,"ions, as well as a possible search for a lower SCF solution. There are three possible options for this keyword. OFF (=0) does nothing, while ON (=1) performs a stability analysis and returns the number of negative eigenvalues in the orbital rotation Hessian. A third option, FOLLOW (=2) performs the stability analysis and then proceeds to rotate the SCF orbitals in the direction of a particular negative eigenvalue of the orbital rotation Hessian (see the explanation of keyword CFOUR_ROT_EVEC , after which the SCF is rerun. Type: string; Possible Values: OFF, ON, FOLLOW; Default: OFF. CFOUR_INCORE¶. This keyword can be used to significantly reduce disk i/o, and should be implemented very soon. The following options are available: OFF (= 0), no special algorithms are used (the default case); ALL (=1) all quantities except the \(\langle ab\vert\vert cd\rangle\) molecular integral lists are held in core; PARTIAL (= 2), the T2 and T1 vectors are held in core throughout the calculation; (=4) all quantities except the \(\langle ab\vert\vert cd\rangle\) and \(\langle ab\vert\vert ci\rangle\) integrals are held in core; (=5) \(\langle ij\vert\vert kl\rangle\) and \(\langle ij\vert\vert ka\rangle\) and two-index quantities are held in core; (=6) all direct access files (MOINTS, GAMLAM, etc.) are held in core. At present, these options have been implemented only in the energy code xvcc and the excitation energy code xvee. (Default: 0). Type: string; Possible Values: OFF, ALL, PARTIAL; Default: OFF. CFOUR_INPUT_MRCC¶. Specifies whether an input for mrcc is written (ON, =0) or not (OFF, =1) if CFOUR_CC_PROGRAM =EXTERNAL has been specified. Type: boolean; Default: true. CFOUR_INTEGRALS¶. This keyword defines what type of integral input will be written by xjoda. VMOL (=1) has to be used with the programs of CFOUR. Using ARGOS (=0), input for Pitzer’s ARGOS integral program will be written. (Default: VMOL). Type: string; Possible Values: VMOL, ARGOS; Default: VMOL. CFOUR_JODA_PRINT¶",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html:34503,access,access,34503,psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,15,['access'],['access']
Security,"iplet states, which is only valid for restricted references. Valid options: - none : No triplets computed (default) - also : lowest-energy triplets and singlets included, in 50-50 ratio. Note that singlets are privileged, i.e. if seeking to converge 5 states in total, 3 will be singlets and 2 will be triplets. - only : Only triplet states computed. Type: string; Possible Values: NONE, ALSO, ONLY; Default: NONE. TDSCF_TDA¶. Run with Tamm-Dancoff approximation (TDA), uses random-phase approximation (RPA) when false. Type: boolean; Default: false. TDSCF_R_CONVERGENCE¶. Convergence threshold for the norm of the residual vector. If unset, default based on D_CONVERGENCE. Type: conv double; Default: 1e-4. TDSCF_MAXITER¶. Maximum number of TDSCF solver iterations. Type: integer; Default: 60. TDSCF_GUESS¶. Guess type, only ‘denominators’ currently supported. Type: string; Default: DENOMINATORS. TDSCF_PRINT¶. Verbosity level in TDSCF. Type: integer; Default: 1. PsiAPI usage¶; The TDSCF functionality is also accessible from PsiAPI. The example calculation shown above can be carried out as follows:; import psi4. from psi4.driver.procrouting.response.scf_response import tdscf_excitations. psi4.core.set_output_file(""h2o2.out""). h2o2 = psi4.geometry(""""""0 1; O 0.000000 0.695000 -0.092486; O -0.000000 -0.695000 -0.092486; H -0.388142 0.895249 0.739888; H 0.388142 -0.895249 0.739888; symmetry c1; """""", name=""H2O2""). psi4.set_options({; 'save_jk': True,; }). e, wfn = psi4.energy(""HF/cc-pvdz"", return_wfn=True, molecule=h2o2); res = tdscf_excitations(wfn, states=10). Plotting one-photon absorption and electronic circular dichroism spectra¶; Excitation energies and corresponding spectroscopic observables can be used to; produce spectra for one-photon absorption (OPA) and electronic circular; dichroism (ECD) with phenomenological line broadening.; PSI4 provides the spectrum function for this purpose implementing the; recommendations of Rizzo et al. [Rizzo2011-to].; This function will not pl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tdscf-1.html:9958,access,accessible,9958,psi4manual/1.4.0/tdscf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tdscf-1.html,4,['access'],['accessible']
Security,"ipole moment computation, performed by applying a finite electric field and numerical differentiation. fci-dipole; 6-31G H2O Test FCI Energy Point. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. mints-helper; A general test of the MintsHelper function. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. cepa-module; routing check on lccd, lccsd, cepa(0). psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. scf-bs; U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:17553,validat,validate,17553,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['validat'],['validate']
Security,"ironment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH') + \; ':' + psi4.Process.environment[""PSIDATADIR""] + '/basis' + \; ':' + psi4.psi_top_srcdir() + '/share/basis',; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Call executable xcfour, directing cfour output to the psi4 output file; try:; retcode = subprocess.Popen([xmod], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); #p4out.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(message) . c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; #if psi4.outfile_name() == 'stdout':; # sys.stdout.write(data); #else:; # p4out.write(data); # p4out.flush(); c4out += data; #internal_p4c4_info['output'] = c4out; return c4out. [docs]def vpt2(name, **kwargs):; """"""Perform vibrational second-order perturbation computation through; Cfour to get anharmonic frequencies. This version uses c4 for the disp; and pt2 but gets gradients from p4. :type c4full: :ref:`boolean <op_py_boolean>`; :param c4full: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether when *name* indicates a Cfour method and *mode*; indicates a sow/reap approach, sown files are direct ZMAT files; and FJOBARC files are expected to reap, so that Cfour only, not; Cfour-through-Psi4, is needed for distributed jobs. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Presently uses all gradients. Could mix in analytic 2nd-derivs. - Collect resutls. - ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:3008,Validat,ValidationError,3008,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,1,['Validat'],['ValidationError']
Security,"irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); vibonly = qcdb.vib.filter_nonvib(vibinfo); wfn.set_frequencies(core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data))); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.get_variable('CURRENT ENERGY'), wfn); else:; return core.get_variable('CURRENT ENERGY'). [docs]def vibanal_wfn(wfn, hess=None, irrep=None, molecule=None, project_trans=True, project_rot=True):. if hess is None:; nmwhess = np.asarray(wfn.hessian()); else:; nmwhess = hess. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False),; 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out('Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess, geom, m, wfn.basisset(), irrep_labels,; project_trans=project_trans, project_rot=project_rot); vibrec.update({k: qca.to_dict() ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:90589,Validat,ValidationError,90589,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"is set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, (unicode, str)):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If we force c1 copy the active molecule; if use_c1:; scf_molecule.update_geometry(); if scf_molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" A requested method does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); scf_molecule = scf_molecule.clone(); scf_molecule.reset_point_group('c1'); scf_molecule.fix_orientation(True); scf_molecule.fix_com(True); scf_molecule.update_geometry(). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (core.get_option('SCF', 'REFERENCE') ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:31522,Validat,ValidationError,31522,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"is set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, (unicode, str)):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(""""""Stability analysis root following is only available for UHF""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (core.get_option('SCF', 'REFERENCE') in ['RHF', 'RKS']) and \; ((scf_molecule.natom() > 1) or core.get_option('SCF', 'SAD_FRAC_OCC')):; core.set_local_option('SCF', 'GUESS', 'SAD'); elif core.get_option('SCF', 'REFERENCE') in ['ROHF', 'ROKS', 'UHF', 'UKS']:; core.set_loc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:32416,Validat,ValidationError,32416,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"is sets; [self.unaugbasis, self.augbasis, self.auxbasis] = self.corresponding_aux_basis(). [docs] def muster_basis_options(self):; text = ''; lowername = self.method.lower(); options = defaultdict(lambda: defaultdict(dict)); ; options['BASIS']['ORBITAL']['value'] = self.basis; ; # this f12 basis setting may be totally messed up; if self.method in ['ccsd(t)-f12-optri']:; if self.basis == 'cc-pvdz-f12':; options['BASIS']['JKFIT']['value'] = 'aug-cc-pvtz/jkfit'; options['BASIS']['JKFITC']['value'] = self.basis + '/optri'; options['BASIS']['MP2FIT']['value'] = 'aug-cc-pvtz/mp2fit'; elif self.method in ['ccsd(t)-f12-cabsfit']:; if self.unaugbasis and self.auxbasis:; #options['BASIS']['JKFIT']['value'] = self.auxbasis + '/jkfit'; #options['BASIS']['JKFITB']['value'] = self.unaugbasis + '/jkfit'; #options['BASIS']['MP2FIT']['value'] = self.auxbasis + '/mp2fit'; #options['BASIS']['DFLHF']['value'] = self.auxbasis + '/jkfit'; options['BASIS']['JKFITC']['value'] = 'aug-cc-pv5z/mp2fit'; else:; raise ValidationError(""""""Auxiliary basis not predictable from orbital basis '%s'"""""" % (self.basis)); elif ('df-' in self.method) or ('f12' in self.method) or (self.method in ['mp2c', 'dft-sapt', 'dft-sapt-pbe0acalda']):; if self.unaugbasis and self.auxbasis:; options['BASIS']['JKFIT']['value'] = self.auxbasis + '/jkfit'; options['BASIS']['JKFITB']['value'] = self.unaugbasis + '/jkfit'; options['BASIS']['MP2FIT']['value'] = self.auxbasis + '/mp2fit'; options['BASIS']['DFLHF']['value'] = self.auxbasis + '/jkfit'; else:; raise ValidationError(""""""Auxiliary basis not predictable from orbital basis '%s'"""""" % (self.basis)); return text, options. [docs] def prepare_basis_for_molpro(self):; text = ''; ; for opt, val in self.options['BASIS'].items():; #print opt, val['value']; #print molpro_basissets.altbasis.keys(); if not text:; text += """"""basis={\n""""""; try:; # jaxz, maxz, etc.; for line in molpro_basissets.altbasis[val['value']]:; text += """"""%s\n"""""" % (line); text += '\n'; except KeyError:; # h",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:15838,Validat,ValidationError,15838,psi4manual/1.0.0/_modules/qcdb/molpro2.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html,1,['Validat'],['ValidationError']
Security,"isSetFileNotFound(msg)[source]¶. exception BasisSetNotDefined(msg)[source]¶. exception BasisSetNotFound(msg, silent=False)[source]¶. exception Dftd3Error(msg)[source]¶. exception FeatureNotImplemented(msg)[source]¶; Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. exception FragmentCountError(msg)[source]¶; Error called molecule has wrong number of fragments for method.; Prints error message msg to standard output stream. exception IncompleteAtomError(msg)[source]¶; Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. exception ParsingValidationError(msg)[source]¶; Error called for problems with syntax from a QC output file. Prints; error message msg to standard output stream. exception QcdbException[source]¶; Error class for QCDB. exception ValidationError(msg)[source]¶; Error called for problems with syntax input file. Prints; error message msg to standard output stream. class Infile(mem, mol, mtd, der, opt)[source]¶. format_infile_string()[source]¶. harvest_output(outtext)[source]¶; Function to separate portions of a Psi4 output file outtext. muster_basis(bas)[source]¶; Transform input mem in MB into psi4-type options. muster_cdsgroup_options()[source]¶. muster_memory(mem)[source]¶; Transform input mem in MB into psi4-type options. muster_modelchem(name, dertype)[source]¶; Transform calculation method name and derivative level dertype; into options for cfour. While deliberately requested pieces,; generally CFOUR_DERIV_LEVEL and CFOUR_CALC_LEVEL,; are set to complain if contradicted (‘clobber’ set to True), other; ‘recommended’ settings, like CFOUR_CC_PROGRAM, can be; countermanded by keywords in input file (‘clobber’ set to False).; Occasionally, want these pieces to actually overcome keywords in; input file (‘superclobber’ set to True). psi4_list()[sour",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:56920,Validat,ValidationError,56920,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['Validat'],['ValidationError']
Security,"ise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:64627,Validat,ValidationError,64627,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,"isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(val)); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). def _core_wavefunction_set_variable(cls, key, val):; if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(val)); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). def _core_del_variable(key):; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls, key):; if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables():; return {**core.scalar_variables(), **core.array_variables()}. def _core_wavefunction_variables(cls):; return {**cls.scalar_variables(), **cls.array_variables()}. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.W",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:19999,Validat,ValidationError,19999,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"issets = OrderedDict(). [docs] def set_basis_by_number(self, number, name, role=""BASIS""):; """"""Assigns basis *name* to atom number *number* (0-indexed, excludes dummies).""""""; # change from libmints to 0-indexing and to real/ghost numbering, dummies not included (libmints >= error); if number >= self.natom():; raise ValidationError(""Molecule::set_basis_by_number: Basis specified for atom %d, but there are only %d atoms in this molecule."" % \; (number, self.natom())); self.atoms[number].set_basisset(name, role). [docs] def set_basis_by_label(self, label, name, role=""BASIS""):; """"""Assigns basis *name* to all atoms with *label*.""""""; for atom in self.full_atoms:; if label.upper() == atom.label():; atom.set_basisset(name, role). [docs] def set_shell_by_number(self, number, bshash, role=""BASIS""):; """"""Assigns BasisSet *bshash* to atom number *number* (0-indexed, excludes dummies).""""""; self.lock_frame = False; if number >= self.natom():; raise ValidationError(""Molecule::set_shell_by_number: Basis specified for atom %d, but there are only %d atoms in this molecule."" % \; (number, self.natom())); self.atoms[number].set_shell(bshash, role). [docs] def nfrozen_core(self, depth=False):; """"""Number of frozen core for molecule given freezing state. >>> print H2OH2O.nfrozen_core(); 2. """"""; if depth == False or depth.upper() == 'FALSE':; return 0. elif depth == True or depth.upper() == 'TRUE':; # Freeze the number of core electrons corresponding to the; # nearest previous noble gas atom. This means that the 4p block; # will still have 3d electrons active. Alkali earth atoms will; # have one valence electron in this scheme.; nfzc = 0; for A in range(self.natom()):; if self.Z(A) > 2:; nfzc += 1; if self.Z(A) > 10:; nfzc += 4; if self.Z(A) > 18:; nfzc += 4; if self.Z(A) > 36:; nfzc += 9; if self.Z(A) > 54:; nfzc += 9; if self.Z(A) > 86:; nfzc += 16; if self.Z(A) > 108:; raise ValidationError(""Molecule::nfrozen_core: Invalid atomic number""); return nfzc. else:; raise ValidationError(""Molecu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:52411,Validat,ValidationError,52411,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"istribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta5] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html:1442,Validat,ValidationError,1442,psi4manual/4.0b5/_modules/qcdb/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html,1,['Validat'],['ValidationError']
Security,"ite -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in ; :envvar:`PATH`. """"""; # Validate arguments; if self is None:; self = PsiMod.get_active_molecule(). dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Para",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:7146,Validat,ValidationError,7146,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"ite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; psi4.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = psi4.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and psi4.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). # are we in sow/reap mode?; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()). # If we are feezing cartesian, do not orient or COM; if psi4.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone().",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:55575,Validat,ValidationError,55575,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"ite difference. hessian(name, **kwargs)[source]¶; Function complementary to frequency(). Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. molden(filename)[source]¶; Function to write wavefunction information in molden; format to filename. parse_arbitrary_order(name)[source]¶; Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. parse_cotton_irreps(irrep)[source]¶; Function to return validated Cotton ordering index from string or integer; irreducible representation irrep. gaussian_n¶. run_gaussian_2(name, **kwargs)[source]¶. pcmgetkw¶. class Getkw(top)[source]¶; Unified interface to sections and keywords.; Implements a path stack. find_sect(path)[source]¶. get_active_section()[source]¶. get_keyword(path)[source]¶. get_topsect()[source]¶. getkw(path)[source]¶. pop_sect()[source]¶. push_sect(path)[source]¶. run_callbacks(templ)[source]¶. sanitize(templ)[source]¶. setkw(path)[source]¶. class GetkwParser(templ=None)[source]¶; Implements a class to do the actual parsing of input files and store; the results in Sections and Keywords. The parseFile() method returns a; Getkw object. add_sect(s, l, t)[source]¶. bnf = None¶. caseless = False¶. check_type(arg, argt)[source]¶. conv_dval(s, loc, toks)[source]¶. conv_ival(s, loc, toks)[source]¶. conv_lval(s, loc, toks)[source]¶. fixate_type(arg)[source]¶. getkw_bnf()[source]¶. no = <_sre.SRE_Pattern object at 0x17bb7440>¶. parseFile(fil)[source]¶. parseString(str)[source]¶. pop_sect(s, l, t)[source]¶. push_sect(k)[source]¶. set_caseless(arg)[source]¶. store_data(s, l, t)[source]¶. store_key(s, l, t)[source]¶. store_vector(s, l, t)[source]¶. yes = <_sre.SRE_Pattern object at 0x190fef80>¶. class Keyword(name, typ, arg=None, req=False, callback=None)[source]¶; Placehoder for keyword objects. get()[source]¶. is_required()[source]¶. is_set()[source]¶. is_type(typ)[source]¶. sanity_check(path)[sour",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:14859,sanitiz,sanitize,14859,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['sanitiz'],['sanitize']
Security,"ith Reaction ~= Reagent databases; npmolD = omolD.format_molecule_for_numpy(); omolA = Molecule(orgts[1].mol) # TODO this is only going to work with Reaction ~= Reagent databases; omolA.update_geometry(); dictorxn['MonA'] = omolA.natom(). # this whole member fn not well defined for db of varying stoichiometry; if self.dbse in ['ACONF', 'SCONF', 'PCONF', 'CYCONF']:; npmolD = omolD.format_molecule_for_numpy(); npmolA = omolA.format_molecule_for_numpy(); dictorxn['Geometry'] = np.vstack([npmolD, npmolA]); else:; dictorxn['Geometry'] = omolD.format_molecule_for_numpy(); # print '\nD', npmolD.shape[0], npmolA.shape[0], dictorxn['MonA'], npmolD, npmolA, dictorxn['Geometry']. for mc in modelchem:; try:; wmc = self.mcs[mc][dbix]; except KeyError:; # modelchem not in Database at all; print(mc, 'not found'); continue; key = mc if modelchemlabels is None else modelchemlabels[modelchem.index(mc)]; try:; dictorxn[key] = orxn.data[wmc].value; except KeyError as e:; # reaction not in modelchem; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (key, str(e))); else:; print(mc, str(e), 'not found'); continue; listodicts.append(dictorxn). df = pd.DataFrame(listodicts); pd.set_option('display.width', 500); print(df.head(5)); print(df.tail(5)); return df. [docs] def table_reactions(self, modelchem, benchmark='default', sset='default',; failoninc=True,; columnplan=['indx', 'tagl', 'bm', 'mc', 'e', 'pe'],; title=""""""Reaction energies [kcal/mol] for {sset} $\subset$ {dbse} with {mc}"""""",; indextitle=""""""Detailed results for {sset} $\subset$ {dbse} with {mc}"""""",; plotpath='analysis/mols/',; standalone=True, theme='rxns', filename=None):; r""""""Prepare single LaTeX table to *filename* or return lines if None showing; the per-reaction results for reactions in *sset* for single or array; or 'all' *modelchem*, where the last uses self.mcs(), model chemistries; versus *benchmark*. Use *failoninc* to toggle between command failing; or blank lines in table. Use *standalone* to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:86439,Validat,ValidationError,86439,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"ity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). from pkg_resources import parse_version; min_version = ""0.15.16""; if parse_version(adcc.__version__) < parse_version(min_version):; raise ModuleNotFoundError(""adcc version {} is required at least. ""; ""Version {}""; "" was found."".format(min_version,; adcc.__version__)). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:117531,Validat,ValidationError,117531,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"iverEnum""; },; ""metameta"": {; ""title"": ""Metameta"",; ""default"": {},; ""type"": ""object""; },; ""task_list"": {; ""title"": ""Task List"",; ""default"": {},; ""type"": ""object"",; ""additionalProperties"": {; ""$ref"": ""#/definitions/BaseComputer""; }; },; ""findifrec"": {; ""title"": ""Findifrec"",; ""default"": {},; ""type"": ""object""; },; ""method"": {; ""title"": ""Method"",; ""type"": ""string""; }; },; ""required"": [; ""driver"",; ""method""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""BaseComputer"": {; ""title"": ""BaseComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {}; }; }; }. Fields:. driver (qcelemental.models.common_models.DriverEnum); findifrec (Dict[str, Any]); metameta (Dict[str, Any]); method (str); molecule (Any); task_list (Dict[str, psi4.driver.task_base.BaseComputer]). Validators:. set_driver » driver; set_molecule » molecule. field driver: DriverEnum [Required]¶. Validated by:. set_driver. field findifrec: Dict[str, Any] = {}¶. field metameta: Dict[str, Any] = {}¶. field method: str [Required]¶. field molecule: Any = None¶. Validated by:. set_molecule. field task_list: Dict[str, BaseComputer] = {}¶. computer¶; alias of AtomicComputer. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶; Run each job in task list. Parameters:; client (Optional[FractalClient]) – . get_psi_results(return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:; return_wfn (bool) – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. Return type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/freq.html:9286,Validat,Validators,9286,psi4manual/1.7.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/freq.html,1,['Validat'],['Validators']
Security,"iverEnum""; },; ""metameta"": {; ""title"": ""Metameta"",; ""default"": {},; ""type"": ""object""; },; ""task_list"": {; ""title"": ""Task List"",; ""default"": {},; ""type"": ""object"",; ""additionalProperties"": {; ""$ref"": ""#/definitions/BaseComputer""; }; },; ""findifrec"": {; ""title"": ""Findifrec"",; ""default"": {},; ""type"": ""object""; },; ""method"": {; ""title"": ""Method"",; ""type"": ""string""; }; },; ""required"": [; ""driver"",; ""method""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""BaseComputer"": {; ""title"": ""BaseComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {}; }; }; }. Fields:. driver (qcelemental.models.common_models.DriverEnum); findifrec (Dict[str, Any]); metameta (Dict[str, Any]); method (str); molecule (Any); task_list (Dict[str, psi4.driver.task_base.BaseComputer]). Validators:. set_driver » driver; set_molecule » molecule. field driver: DriverEnum [Required]¶. Validated by:. set_driver. field findifrec: Dict[str, Any] = {}¶. field metameta: Dict[str, Any] = {}¶. field method: str [Required]¶. field molecule: Any = None¶. Validated by:. set_molecule. field task_list: Dict[str, BaseComputer] = {}¶. computer¶; alias of AtomicComputer. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶; Run each job in task list. Parameters:; client (qcportal.FractalClient | None) – . get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; modu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/freq.html:9288,Validat,Validators,9288,psi4manual/1.8.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/freq.html,2,['Validat'],['Validators']
Security,"iverEnum""; },; ""metameta"": {; ""title"": ""Metameta"",; ""default"": {},; ""type"": ""object""; },; ""task_list"": {; ""title"": ""Task List"",; ""default"": {},; ""type"": ""object"",; ""additionalProperties"": {; ""$ref"": ""#/definitions/BaseComputer""; }; },; ""findifrec"": {; ""title"": ""Findifrec"",; ""default"": {},; ""type"": ""object""; },; ""method"": {; ""title"": ""Method"",; ""type"": ""string""; }; },; ""required"": [; ""driver"",; ""method""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""BaseComputer"": {; ""title"": ""BaseComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {}; }; }; }. Fields:. driver (qcelemental.models.common_models.DriverEnum); findifrec (Dict[str, Any]); metameta (Dict[str, Any]); method (str); molecule (Any); task_list (Dict[str, psi4.driver.task_base.BaseComputer]). Validators:. set_driver » driver; set_molecule » molecule. field driver: DriverEnum [Required]¶. Validated by:. set_driver. field findifrec: Dict[str, Any] = {}¶. field metameta: Dict[str, Any] = {}¶. field method: str [Required]¶. field molecule: Any = None¶. Validated by:. set_molecule. field task_list: Dict[str, BaseComputer] = {}¶. computer¶; alias of AtomicComputer. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶; Run each job in task list. Parameters:; client (qcportal.FractalClient | None). get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/freq.html:9295,Validat,Validators,9295,psi4manual/master/freq.html,https://psicode.org,https://psicode.org/psi4manual/master/freq.html,1,['Validat'],['Validators']
Security,"iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },; ""conv-omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },. ""mp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""TRUE"", },. ""mp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", },. ""oremp2"": {""wfn_type"": ""OREMP"", ""orb_opt"": ""TRUE"", },. ""lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC gradient""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:78024,Validat,ValidationError,78024,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). if name == 'mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'conv-omp2']:; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'lccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'olccd':; core.set_local_option('OCC', 'WFN_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:72772,Validat,ValidationError,72772,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"ix, Wavefunction) – Hessian and wavefunction when return_wfn specified. Examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). It’s handy to collect the wavefunction after a frequency; calculation through e, wfn = psi4.frequency(...,; return_wfn=True) as the frequencies can be accessed through; psi4.core.Wavefunction.frequencies(), the Hessian through; psi4.core.Wavefunction.hessian(), and much other computation; info through psi4.core.Wavefunction.frequency_analysis; (note no parentheses). Examples of using this data; structure can be found fd-freq-gradient and; psi4/tests/pytests/test_vibanalysis.py. Formatted printing of vibrational; results is available through psi4.driver.qcdb.vib.print_vibs(). Results accessible through psi4.core.Wavefunction.frequency_analysis¶. key; description (lbl & comment); units; data (real/imaginary modes). omega; frequency; cm^-1; ndarray(ndof) complex (real/imag). q; normal mode, normalized mass-weighted; a0 u^1/2; ndarray(ndof, ndof) float. w; normal mode, un-mass-weighted; a0; ndarray(ndof, ndof) float. x; normal mode, normalized un-mass-weighted; a0; ndarray(ndof, ndof) float. degeneracy; degree of degeneracy. ndarray(ndof) int. TRV; translation/rotation/vibration. ndarray(ndof) str ‘TR’ or ‘V’ or ‘-’ for partial. gamma; irreducible representation. ndarray(ndof) str irrep or None if unclassifiable. mu; reduced mass; u; ndarray(ndof) float (+/+). k; force constant; mDyne/A; ndarray(ndof) float (+/-). DQ0; RMS deviation v=0; a0 u^1/2; ndarray(ndof) float (+/0). Qtp0; Turning point v=0; a0 u^1/2; ndarray(ndof) float (+/0). Xtp0; Turning point v=0; a0; ndarray(ndof) float (+/0). theta_vib; char temp; K; ndarray(ndof) float (+/0). Visualization of Normal Modes¶; PSI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/freq.html:4954,access,accessible,4954,psi4manual/master/freq.html,https://psicode.org,https://psicode.org/psi4manual/master/freq.html,4,['access'],['accessible']
Security,"ix. rotate_columns(self, h, i, j, theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[, h]); Returns the rows in irrep h. save(*args, **kwargs); Overloaded function. scale(self, a); Scales the matrix by the floating point value a. scale_column(self, h, n, a); Scales column n of irrep h by a. scale_row(self, h, m, a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args, **kwargs); Overloaded function. set_block(self, rows, cols, block); Set a matrix block. subtract(self, arg0); Substract a matrix from this matrix. sum_of_squares(self); Returns the sum of the squares of this matrix. symmetrize_gradient(self, mol); Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self); Returns the overall symmetry of the matrix. to_array([copy, dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. trace(self); Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transpose(self); Creates a new matrix that is the transpose of this matrix. transpose_this(self); Transpose the matrix in-place. triplet(A, B, C, transA, transB, transC); Multiply three matrices together. vector_dot(self, rhs); Returns the vector dot product of this with rhs. zero(self); Zero all elements of the matrix. zero_diagonal(self); Zero the diagonal of the matrix. zero_lower(self); Zero the lower triangle. zero_upper(self); Zero the upper triangle. Attributes Documentation. name¶; The name of the Matrix. Used in printing. np¶; View with single irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. absmax(self: psi4.core.Matrix) → float¶; Returns the absolute maximum value. accumulate_product(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None¶; Multiplies two arguments and adds the result to this ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:4786,access,accessor,4786,psi4manual/1.7.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html,4,['access'],['accessor']
Security,"ix. rotate_columns(self, h, i, j, theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[, h]); Returns the rows in irrep h. save(*args, **kwargs); Overloaded function. scale(self, a); Scales the matrix by the floating point value a. scale_column(self, h, n, a); Scales column n of irrep h by a. scale_row(self, h, m, a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args, **kwargs); Overloaded function. set_block(self, rows, cols, block); Set a matrix block. subtract(self, arg0); Substract a matrix from this matrix. sum_of_squares(self); Returns the sum of the squares of this matrix. symmetrize_gradient(self, mol); Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self); Returns the overall symmetry of the matrix. to_array([copy, dense]); Converts a Psi4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. trace(self); Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transpose(self); Creates a new matrix that is the transpose of this matrix. transpose_this(self); Transpose the matrix in-place. triplet(A, B, C, transA, transB, transC); Multiply three matrices together. vector_dot(self, rhs); Returns the vector dot product of this with rhs. zero(self); Zero all elements of the matrix. zero_diagonal(self); Zero the diagonal of the matrix. zero_lower(self); Zero the lower triangle. zero_upper(self); Zero the upper triangle. Attributes Documentation. name¶; The name of the Matrix. Used in printing. np¶; View with single irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. absmax(self: psi4.core.Matrix) → float¶; Returns the absolute maximum value. accumulate_product(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None¶; Multiplies two arguments and adds the result to this ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Matrix.html:4748,access,accessor,4748,psi4manual/1.6.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Matrix.html,1,['access'],['accessor']
Security,"ix:; sdim1 = psi4.Dimension(irreps); sdim2 = psi4.Dimension(irreps); ; for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == psi4.Vector:; sdim1 = psi4.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for interface, vals in zip(ret.array_interfaces(), arr):; if 0 in interface.__array_interface__[""shape""]:; continue; else:; view = np.asarray(interface); view[:] = vals. return ret . # No irreps implied by list; else:; if arr_type == psi4.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError (""Array_to_Matrix: If dim1 is supplied must supply dim2 also""); ; dim1 = psi4.Dimension.from_list(dim1) ; dim2 = psi4.Dimension.from_list(dim2) . if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""); ; ret = self(name, dim1, dim2); ; start1 = 0; start2 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1 ; start2 += d2. return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. elif arr_type == psi4.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError (""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""); ; dim1 = psi4.Dimension.from_list(dim1) ; ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1 . return ret; ; # Simple case without",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:4815,Validat,ValidationError,4815,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"ix_orientation(True); metadata['embedding_charges'] = kwargs.get('embedding_charges', False); metadata['kwargs'] = kwargs; core.clean_variables(). if metadata['ptype'] not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % metadata['ptype']). if metadata['return_total_data'] is None:; if metadata['ptype'] in ['gradient', 'hessian']:; metadata['return_total_data'] = True; else:; metadata['return_total_data'] = False. # Parse bsse_type, raise exception if not provided or unrecognized; metadata['bsse_type_list'] = kwargs.pop('bsse_type'); if metadata['bsse_type_list'] is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(metadata['bsse_type_list'], list):; metadata['bsse_type_list'] = [metadata['bsse_type_list']]. for num, btype in enumerate(metadata['bsse_type_list']):; metadata['bsse_type_list'][num] = btype.lower(); if btype.lower() not in ['cp', 'nocp', 'vmfc']:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). metadata['max_nbody'] = kwargs.get('max_nbody', -1); if metadata['molecule'].nfragments() == 1:; raise ValidationError(""N-Body requires active molecule to have more than 1 fragment.""); metadata['max_frag'] = metadata['molecule'].nfragments(); if metadata['max_nbody'] == -1:; metadata['max_nbody'] = metadata['molecule'].nfragments(); else:; metadata['max_nbody'] = min(metadata['max_nbody'], metadata['max_frag']). # Flip this off for now, needs more testing; # If we are doing CP lets save them integrals; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # # Set to save RI integrals for repeated full-basis computations; # ri_ints_io = core.get_global_option('DF_INTS_IO'). # # inquire if above at all applies to dfmp2 or just scf; # core.set_global_option('DF_INTS_IO', 'SAVE'); # psioh = core.IOManager.shared_object(); # psioh.set_specific_retention(97, True). bsse_str = metadata['bsse_type_list'][0]; if len(met",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:8710,Validat,ValidationError,8710,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['Validat'],['ValidationError']
Security,"izationally, this module isolates qcdb code from psi4 code. """"""; import inspect; import os; import re; import shutil; import subprocess; import sys; import uuid. import qcelemental as qcel. from psi4 import core. from .. import p4util, qcdb; from ..p4util.exceptions import *. # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]; def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT within will be used. :type genbas: str; :param genbas:. Indicates that contents should be used for GENBAS file. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {...} block and basis is set through; |Psifours| BASIS keyword. In that case, a GENBAS is w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/interface_cfour.html:2390,access,accessible,2390,psi4manual/1.9.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/interface_cfour.html,2,['access'],['accessible']
Security,"ize=18); ax.text(-0.5, 0.9, u'Elst (+)',; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', weight='bold', fontsize=18). xvals = []; yvals = []; cvals = []; for sys in sapt:; [elst, indc, disp] = sys. # calc ternary posn and color; Ftop = abs(indc) / (abs(elst) + abs(indc) + abs(disp)); Fright = abs(elst) / (abs(elst) + abs(indc) + abs(disp)); xdot = 0.5 * Ftop + Fright; ydot = 0.866 * Ftop; cdot = 0.5 + (xdot - 0.5) / (1. - Ftop); if elst > 0.:; xdot = 0.5 * (Ftop - Fright); ydot = 0.866 * (Ftop + Fright); #print elst, indc, disp, '', xdot, ydot, cdot. xvals.append(xdot); yvals.append(ydot); cvals.append(cdot). sc = ax.scatter(xvals, yvals, c=cvals, s=15, marker=""o"", \; cmap=mpl.cm.jet, edgecolor='none', vmin=0, vmax=1, zorder=10). # remove figure outline; ax.spines['top'].set_visible(False); ax.spines['right'].set_visible(False); ax.spines['bottom'].set_visible(False); ax.spines['left'].set_visible(False). # save and show; pltuid = title + '_' + ('lbld' if labeled else 'bare') + '_' + hashlib.sha1(title + repr(sapt)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='tern_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight',; frameon=False, dpi=450, edgecolor='none', pad_inches=0.0); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. #def thread_mouseover_web(pltfile, dbid, dbname, xmin, xmax, mcdats, labels, titles):; # """"""Saves a plot with name *pltfile* with a slat representation of; # the modelchems errors in *mcdat*. Mouseover shows geometry and error; # from *labels* based on recipe of Andrew Dalke from; # http://www.dalkescientific.com/writings/diary/archive/2005/04/24/interactive_html.html; #; # """"""; # from matplotlib.backends.backend_agg import FigureCanvasAgg; # import matplotlib; # import sapt_colors; #; # cmpd_width = 200; # cmpd_height = 16",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:25938,hash,hashlib,25938,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['hash'],['hashlib']
Security,"ject(); os.chdir(psioh.get_default_path()); dftd3_tmpdir = 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.dftd3.' + str(random.randint(0, 99999)); if os.path.exists(dftd3_tmpdir) is False:; os.mkdir(dftd3_tmpdir); os.chdir(dftd3_tmpdir). # Write dftd3_parameters file that governs dispersion calc; paramfile = './dftd3_parameters'; pfile = open(paramfile, 'w'); pfile.write(dash_server(func, dashlvl, 'dftd3')); pfile.close(). # Write dftd3_geometry file that supplies geometry to dispersion calc; geomfile = './dftd3_geometry.xyz'; gfile = open(geomfile, 'w'); numAtoms = self.natom(); geom = self.save_string_xyz(); reals = []; for line in geom.splitlines():; if line.split()[0] == 'Gh':; numAtoms -= 1; else:; reals.append(line); ; gfile.write(str(numAtoms)+'\n'); for line in reals:; gfile.write(line.strip()+'\n'); gfile.close(). # Call dftd3 program; try:; dashout = subprocess.Popen(['dftd3', geomfile, '-grad'], stdout=subprocess.PIPE); except OSError:; raise ValidationError('Program dftd3 not found in path.'); out, err = dashout.communicate(). # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; raise ValidationError('Program dftd3 did not complete successfully.'). # Parse grad output; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; i = 0; for line in geom.splitlines():; if i == 0:; i += 1; else:; if line.split()[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; temp = dfile.readline(); dashdderiv.append([float(x.replace('D', 'E')) for x in temp.split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())); psi_dashdderiv = PsiMod.Matrix(self.natom(), 3); psi_d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:10175,Validat,ValidationError,10175,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"ject(); os.chdir(psioh.get_default_path()); dftd3_tmpdir = 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.dftd3.' + str(random.randint(0, 99999)); if os.path.exists(dftd3_tmpdir) is False:; os.mkdir(dftd3_tmpdir); os.chdir(dftd3_tmpdir). # Write dftd3_parameters file that governs dispersion calc; paramfile = './dftd3_parameters'; pfile = open(paramfile, 'w'); pfile.write(dash_server(func, dashlvl, 'dftd3')); pfile.close(). # Write dftd3_geometry file that supplies geometry to dispersion calc; geomfile = './dftd3_geometry.xyz'; gfile = open(geomfile, 'w'); numAtoms = self.natom(); geom = self.save_string_xyz(); reals = []; for line in geom.splitlines():; if line.split()[0] == 'Gh':; numAtoms -= 1; else:; reals.append(line); ; gfile.write(str(numAtoms)+'\n'); for line in reals:; gfile.write(line.strip()+'\n'); gfile.close(). # Call dftd3 program; try:; dashout = subprocess.Popen(['dftd3', geomfile, '-grad'], stdout=subprocess.PIPE); except OSError:; raise ValidationError('Program dftd3 not found in path.'); out, err = dashout.communicate(). # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; raise ValidationError('Program dftd3 did not complete successfully.'). # Parse grad output; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; i = 0; for line in geom.splitlines():; if i == 0:; i += 1; else:; if line.split()[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; temp = dfile.readline(); dashdderiv.append([float(x.replace('D', 'E')) for x in temp.split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())); psi_dashdderiv = psi4.Matrix(self.natom(), 3); psi_das",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:11006,Validat,ValidationError,11006,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"ject_rot=True):. if hess is None:; nmwhess = np.asarray(wfn.hessian()); else:; nmwhess = hess. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False),; 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out('Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess, geom, m, wfn.basisset(), irrep_labels,; project_trans=project_trans, project_rot=project_rot); vibrec.update({k: qca.to_dict() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rot",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:91169,Validat,ValidationError,91169,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"ke sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Convert wrapper directives from options (where ppl know to find them) to kwargs (suitable for non-globals transmitting); kwargs['findif_verbose'] = core.get_option(""FINDIF"", ""PRINT""); kwargs['findif_stencil_size'] = core.get_option(""FINDIF"", ""POINTS""); kwargs['findif_step_size'] = core.get_option(""FINDIF"", ""DISP_SIZE""). # Select certain irreps; irrep = kwargs.pop('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; kwargs['findif_irrep'] = irrep. ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name); _filter_renamed_methods(""hessian"", lowername). # * Prevent methods that do not have associated derivatives; if lowername in energy_only_methods:; raise ValidationError(f""`hessian('{name}')` does not have an associated Hessian.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""hessian"", lowername, molecule, **kwargs); logger.debug('HESSIAN PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 2nd derivative. _filter_renamed_methods(""frequency"", lowername); core.clean_variables(). optstash = p4util.Op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:79572,Validat,ValidationError,79572,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['Validat'],['ValidationError']
Security,"keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). core.set_local_option('FNOCC', 'DFCC', True); core.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""""""Error: {name} requires 'reference rhf'.""""""). def set_cholesky_from(mtd_type):; type_val = core.get_global_option(mtd_type); if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(""""""Invalid type '%s' for DFCC"""""" % type_val). # triples?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:161299,Validat,ValidationError,161299,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; cls.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array QCVariable *key* from global memory if present."""""". if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array QCVariable *key* from *cls* if present."""""". if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from global memory."""""". dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:31885,Validat,ValidationError,31885,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. PsiMod.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). PsiMod.print_out(""\n""); banner(""CP Computation: Results.""); PsiMod.print_out(""\n""). banner(""Hartree"", 2); PsiMod.print_out(""\n""). PsiMod.print_out(str(cp_table)). PsiMod.print_out(""\n""); banner(""kcal*mol^-1"", 2); PsiMod.print_out(""\n""). cp_table.scale(). PsiMod.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:22545,access,access,22545,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['access'],['access']
Security,"kw in full is touched, conflicts with value in partial,; # but value in partial is paramount, overwrite full with; # value in partial; full[module][kw]['value'] = kwprop['value']; full[module][kw]['has_changed'] = True; #print '@P4C4 Overwriting %s with %s' % (kw, kwprop['value']); else:; raise ValidationError(""""""; Option %s value `%s` set by options block incompatible with; value `%s` in memory/molecule/command/psi4options block."""""" %; (kw, full[module][kw]['value'], kwprop['value'])); else:; # kw in full is touched, conflicts with value in partial,; # but value in partial is recommended, not required, no change; pass; else:; # kw in full is touched, but in agreement with value in partial, no change; pass; else:; # If kw in full is untouched, overwrite it with value in partial; full[module][kw]['value'] = kwprop['value']; full[module][kw]['has_changed'] = True; #print '@P4C4 Overwriting %s with %s' % (kw, kwprop['value']). except KeyError as e: # not expected but want to trap; raise ValidationError(""""""Unexpected KeyError reconciling keywords: %s."""""" % (repr(e))). return full. [docs]def reconcile_options2(full, partial):; """"""Function to take the full snapshot of the liboptions object; encoded in dictionary *full* and reconcile it with proposed options; value changes in *partial*. Overwrites *full* with *partial* if; option untouched, touches *full* if *full* and *partial* are in; agreement, balks if *full* and *partial* conflict. Returns *full*.; Note: this is surprisingly similar to reconcile_options except; that full is essentially empty and lacking in has_changed keys; so presence is enough to satisfy has_changed. consider merging; once mature. """"""; try:; for module, modopts in partial.items():; for kw, kwprop in modopts.items():; #if full[module][kw]['has_changed']:; if full[module][kw]:; if full[module][kw]['value'] != kwprop['value']:; if 'clobber' in kwprop and kwprop['clobber']:; if 'superclobber' in kwprop and kwprop['superclobber']:; # kw in full is touche",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/options.html:6343,Validat,ValidationError,6343,psi4manual/1.0.0/_modules/qcdb/options.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/options.html,1,['Validat'],['ValidationError']
Security,"kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; return psi4.mcscf(). [docs]def scf_helper(name, **kwargs):; """"""Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). """"""; optstash = p4util.OptionsState(; ['PUREAM'],; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'SCF_TYPE'] # Hack: scope gets changed internally with the Andy trick; ). # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO']). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if psi4.has_option_changed('SCF', 'BASIS_GUESS'):; cast = psi4.get_option('SCF', 'BASIS_GUESS'); if yes.match(str(cast)):; cast = True; elif no.match(str(cast)):; cast = False. if psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; castdf = True; else:; castdf = False. if psi4.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = psi4.get_option('SCF', 'DF_BASIS_GUESS'); if yes.match(str(castdf)):; castdf = True; elif no.match(str(castdf)):; castdf = False. # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; molecule = psi4.get_active_molecule(); multp = molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if psi4.get_option('SCF','REFERENC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:16776,Validat,ValidationError,16776,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]; def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:44635,Validat,ValidationError,44635,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['Validat'],['ValidationError']
Security,"kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a deve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:37948,Validat,ValidationError,37948,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"l (in rad.) between four sets of coordinates. entry_number()[source]¶; The order in which this appears in the full atom list. everything()[source]¶. is_computed()[source]¶; Whether the current atom’s coordinates are up-to-date. is_equivalent_to(other)[source]¶; Whether this atom has the same mass and ghost status as atom other.; Also compares basis set assignment down to nbf(), has_puream() level; with code borrowed from Robert M. Parrish’s SAD guess in Psi4. is_ghosted()[source]¶; Whether the current atom is ghosted or not. label()[source]¶; The atom label. mass()[source]¶; The atomic mass of the current atom. static r(a1, a2)[source]¶; Computes the distance between two sets of coordinates. set_basisset(name, role='BASIS')[source]¶; Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. set_ghosted(gh)[source]¶; Flag the atom as either ghost or real. set_shell(bshash, key='BASIS')[source]¶; Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. shell(key='BASIS')[source]¶; Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. shells()[source]¶; Returns shells sets to atom map. symbol()[source]¶; The atomic symbol. class CoordValue(fixed=False, computed=False)[source]¶; An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. everything()[source]¶. fixed()[source]¶; Get whether the coordinate value is fixed or not. invalidate()[source]¶; Flag the current value as outdated. set_fixed(fixed)[source]¶; Set whether the coordinate value is fixed or not. class NumberValue(value, fixed=False)[source]¶; Specialization of CoordValue that is simply a number to be stored. clone()[source]¶; Returns new, independent Numbe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:115872,hash,hash,115872,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['hash'],['hash']
Security,"l be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. from __future__ import print_function; from __future__ import absolute_import; from __future__ import division; import re; import math; import numpy as np; import psi4; import qcdb; import p4util; import driver_util; import p4const; from p4util.exceptions import *; from procedures.interface_cfour import cfour_psivar_list. zeta_values = ['d', 't', 'q', '5', '6', '7', '8']; zeta_val2sym = {k + 2: v for k, v in zip(range(7), zeta_values)}; zeta_sym2val = {v: k for k, v in zeta_val2sym.items()}. def _expand_bracketed_basis(basisstring, molecule=None):; r""""""Function to transform and validate basis series specification; *basisstring* for cbs(). A basis set with no paired square brackets is; passed through with zeta level 0 (e.g., '6-31+G(d,p)' is returned as; [6-31+G(d,p)] and [0]). A basis set with square brackets is checked; for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4,; 5]). This function checks that the basis is valid by trying to build; the qcdb.BasisSet object for *molecule* or for H2 if None. Allows; out-of-order zeta specification (e.g., [qtd]) and numeral for number; (e.g., [23]) but not skipped zetas (e.g., [dq]) or zetas outside [2,; 8] or non-Dunning sets or non-findable .gbs sets. """"""; BSET = []; ZSET = []; legit_compound_basis = re.compile(r'^(?P<pre>.*cc-.*)\[(?P<zeta>[dtq2345678,]*)\](?P<post>.*z)$', re.IGNORECASE). if legit_compound_basis.match(basisstring):; basisname = legit_compound_basis.match(basisstring); # filter out commas and be forgiv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:1557,validat,validate,1557,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['validat'],['validate']
Security,"l be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import os; import sys; import shutil; import subprocess; import warnings. import numpy as np; from qcelemental import constants. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, ValidationError; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:1699,Validat,ValidationError,1699,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"l classes, derivatives, and AM from currently linked Libint2. libint2_print_out(). rtype:; None. mdi_run(scf_method, **kwargs); Begin functioning as an MDI (MolSSI driver interface) engine. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Helper to specify the multiline PCMSolver syntax for PCM. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_method(name); Replace characters in method name so that suitable for function name or Sphinx table anchor (both as-is) or HTML table link (replace underscore in returned string by dash). sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, ...); Builds the correct (R/U/RO/CU HF/KS) wavefunction from the provided information, sets relevant auxiliary basis sets on it, and prepares any empirical dispersion. set_memory(inputval[, execute, quiet]); Reset the total memory",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:19552,validat,validate,19552,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,1,['validat'],['validate']
Security,"l classes, derivatives, and AM from currently linked Libint2. libint2_print_out(). rtype:; None. mdi_run(scf_method, **kwargs); Begin functioning as an MDI (MolSSI driver interface) engine. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Helper to specify the multiline PCMSolver syntax for PCM. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_method(name); Replace characters in method name so that suitable for function name or Sphinx table anchor :rtype: str. sanitize_name(name); Function to return name in coded form, stripped of :rtype: str. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, ...); Builds the correct (R/U/RO/CU HF/KS) wavefunction from the provided information, sets relevant auxiliary basis sets on it, and prepares any empirical dispersion. set_memory(inputval[, execute, quiet]); Reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict[, verbo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:19651,validat,validate,19651,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,1,['validat'],['validate']
Security,"l in range(5, 99):; VARH[f'mp{mplevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'mp{mplevel}': f'MP{mplevel} TOTAL ENERGY'}; for mplevel2 in range(2, mplevel):; VARH[f'mp{mplevel}'][f'mp{mplevel2}'] = f'MP{mplevel2} TOTAL ENERGY'. # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH; # yapf: enable. VARH = return_energy_components(). [docs]def _get_default_xtpl(nbasis: int, xtpl_type: str) -> Callable:; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return ""xtpl_highest_1""; elif xtpl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata; List of dicts containing CBS stage keywords.; molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:16737,Validat,ValidationError,16737,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,6,['Validat'],['ValidationError']
Security,"l qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.geometry()); mass = np.asarray([self.mass(at) for at in range(self.natom())]); elem = np.asarray([self.symbol(at) for at in range(self.natom())]); elez = np.asarray([self.Z(at) for at in range(self.natom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest() for at in range(self.natom()); ]). return geom, mass, elem, elez, uniq. @staticmethod; def from_string(molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = qcel.molparse.from_string(; molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:36217,hash,hashlib,36217,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,8,['hash'],['hashlib']
Security,"l qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import p4util, qcdb; from .constants import constants, nppp10, pp; from .p4util.exceptions import ValidationError; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil size. Return",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_findif.html:4891,Validat,ValidationError,4891,psi4manual/1.9.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_findif.html,2,['Validat'],['ValidationError']
Security,"l to the geometry projection module. optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]¶; Function to perform a geometry optimization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || 'off' ; Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:1671,access,accesses,1671,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,2,['access'],['accesses']
Security,"l""); stage[""stage""] = item.get(""stage"", False); if not stage[""stage""]:; if len(metadata) == 0:; stage[""stage""] = ""scf""; elif len(metadata) == 1:; stage[""stage""] = ""corl""; else:; stage[""stage""] = f""delta{len(metadata) - 1}""; stage[""scheme""] = item.get(""scheme"", _get_default_xtpl(len(stage[""basis""][1]), stage[""treatment""])); if len(metadata) > 0:; stage[""wfn_lo""] = item.get(""wfn_lo"", metadata[-1].get(""wfn"")).lower(); stage[""basis_lo""] = _expand_bracketed_basis(item.get(""basis_lo"", item[""basis""]).lower(), molecule); if len(stage[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return (metadata). def _process_cbs_kwargs(kwargs):; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs : dict; kwargs containing the CBS function specification. Returns; -------; list; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}_basis"" in k",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:32068,validat,validation,32068,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['validat'],['validation']
Security,"l)[source]¶. reconstitute_bracketed_basis(needarray)[source]¶; Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form ‘cc-pv[q5]z’ from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the f_basis field of a NEED dictionary in; complete_basis_set(). Result is used to print a nicely; formatted basis set string in the results table. split_menial(menial)[source]¶; Function used by complete_basis_set() to separate; menial ‘scftot’ into [scf, tot] and ‘mp2corl’ into [mp2, corl]. tblhead(tbl_maxrgt, tbl_delimit, ttype)[source]¶; Function that prints the header for the changable-width results tables in db().; tbl_maxrgt is the number of reagent columns the table must plan for. tbl_delimit; is a string of dashes of the correct length to set off the table. ttype is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. validate_bracketed_basis(basisstring)[source]¶; Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., ‘6-31+G(d,p)’; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., ‘cc-pV[Q5]Z’ is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:23155,validat,validate,23155,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,8,['validat'],['validate']
Security,"l-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(mtd_type):; type_val = core.get_global_option(mtd_type); if type_val == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""); elif type_val == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_option('SCF', 'SCF_TYPE') != 'CD':; core.set_local_option('DFOCC', 'READ_SCF_3INDEX', 'FALSE'); else:; raise ValidationError(""""""Invalid type '%s' for DFOCC"""""" % type_val). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); set_cholesky_from('MP2_TYPE'); elif name in ['mp2.5', 'omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); set_cholesky_from('MP_TYPE'); elif name in ['mp3', 'omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); set_cholesky_from('MP_TYPE'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); set_cholesky_from('CC_TYPE'). elif name == 'ccd':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); set_cholesky_from('CC_TYPE'); elif name == 'ccsd':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(at)':; core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(AT)');",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:42735,Validat,ValidationError,42735,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"l-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(mtd_type):; type_val = psi4.get_global_option(mtd_type); if type_val == 'DF':; psi4.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""); elif type_val == 'CD':; psi4.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'CD'); psi4.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if psi4.get_option('SCF', 'SCF_TYPE') != 'CD':; psi4.set_local_option('DFOCC', 'READ_SCF_3INDEX', 'FALSE'); else:; raise ValidationError(""""""Invalid type '%s' for DFOCC"""""" % type_val). if name in ['mp2', 'omp2']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); set_cholesky_from('MP2_TYPE'); elif name in ['mp2.5', 'omp2.5']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); set_cholesky_from('MP_TYPE'); elif name in ['mp3', 'omp3']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); set_cholesky_from('MP_TYPE'); elif name in ['lccd', 'olccd']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); set_cholesky_from('CC_TYPE'). elif name == 'ccd':; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); set_cholesky_from('CC_TYPE'); elif name == 'ccsd':; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(at)':; psi4.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(AT)');",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:34466,Validat,ValidationError,34466,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"l.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Molecule::create_molecule_from_string: Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Molecule::create_molecule_from_string: Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); self.set_has_zmatrix(zmatrix). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:21569,Validat,ValidationError,21569,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"l2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Ato",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:18280,Validat,ValidationError,18280,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,2,['Validat'],['ValidationError']
Security,"l_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n"");; if banner:; core.print_out("" "" + banner.center(58));; if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58));; ref_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(ref_wfn). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(ref_wfn, ""_disp_functor""):; disp_energy = ref_wfn._disp_functor.compute_energy(ref_wfn.molecule()); ref_wfn.set_variable(""-D Energy"", disp_energy); ref_wfn.compute_energy(). # broken clean-up; if do_broken:; raise ValidationError(""Broken Symmetry computations are temporarily disabled.""); scf_molecule.set_multiplicity(1); core.set_local_option('SCF', 'GUESS', 'READ'); core.print_out('\n'); p4util.banner(' Computing broken symmetry solution from high-spin triplet guess '); core.print_out('\n'). # cast clean-up; if cast:. # Move files to proper namespace; core.IO.change_file_namespace(180, guesspace, namespace); core.IO.set_default_namespace(namespace). optstash2.restore(). # Print the banner for the standard operation; core.print_out('\n'); p4util.banner(bannername.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n"");; core.print_out("" "" + banner.center(58));. scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(scf_wfn). # The wfn from_file routine adds the npy s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:43200,Validat,ValidationError,43200,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"l_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed.""""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:31734,Validat,ValidationError,31734,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"l_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed.""""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:31381,Validat,ValidationError,31381,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"lable for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:35668,Validat,ValidationError,35668,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"lass:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans : boolean; Should translations be projected in the harmonic analysis?; project_rot : boolean; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : dict; A dictionary of vibrational information. See :py:func:`~psi4.driver.qcdb.vib.harmonic_analysis`; """""". if hess is None:; nmwhess = np.asarray(wfn.hessian()); else:; nmwhess = hess. dipder = wfn.variables().get(""CURRENT DIPOLE GRADIENT"", None); if dipder is not None:; dipder = np.asarray(dipder).T. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False), 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(; nmwhess, geom, m, wfn.basisset(), irrep_labels, dipder=dipder, project_trans=project_trans, project_rot=project_rot); vibrec.u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:75271,Validat,ValidationError,75271,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"late:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:45726,Validat,ValidationError,45726,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"lation. .. caution:: Get rid of madness-era restart file. """"""; optstash = OptionsState(; ['DF_BASIS_MP2']). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = PsiMod.IOManager.shared_object(); psio = PsiMod.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(PsiMod.me() == 0):; shutil.copy(restartfile, targetfile); else:; run_scf('RHF', **kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). e_dfmp2 = PsiMod.dfmp2(); e_scs_dfmp2 = PsiMod.get_variable('SCS-DF-MP2 ENERGY'). optstash.restore(). if (name.upper() == 'SCS-DFMP2') or (name.upper() == 'SCS-DF-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2'):; return e_dfmp2. [docs]def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; run_mcscf(name, **kwargs); PsiMod.psimrcc(); e_psimrcc = PsiMod.get_variable(""Current Energy""); return e_psimrcc. [docs]def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """""". run_scf(name, **kwargs); PsiMod.psimrcc(); e_psimrcc = PsiMod.get_variable(""Current Energy""); return e_psimrcc. [docs]def run_mp2c(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:28719,Validat,ValidationError,28719,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,lcComponent; sapt; SaveType; scalar_variable; scalar_variables; scatter; scfgrad; scfhess; set_active_molecule; set_array_variable; set_datadir; set_global_option; set_global_option_python; set_gradient; set_legacy_gradient; set_legacy_molecule; set_legacy_wavefunction; set_local_option; set_local_option_python; set_memory_bytes; set_num_threads; set_output_file; set_psi_file_prefix; set_scalar_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; ThreeCenterOverlapInt; timer_off; timer_on; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; variable; variables; VBase; Vector; Vector3; version; Wavefunction; activate; ancestor; AtomicComputer; banner; basis_helper; cbs; check_iwl_file_from_scf_type; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; ConvergenceError; copy_file_from_scratch; copy_file_to_scratch; create_plugin; CSXError; cubeprop; Dftd3Error; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fchkfile_to_string; fcidump; fcidump_from_file; find_approximate_string_matches; free_atom_volumes; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; join_path; levenshtein; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; ParsingError; PastureRequiredError; pcm_helper; print_stderr; print_stdout; process_input; prop; properties; PsiException; PsiImportError; compare_vibinfos; filter_nonvib; filter_omega_to_real; harmonic_analysis; hessian_symmetrize; print_molden_vibs; print_vibs; thermo; QMMM; QMMMbohr; sanitize_name; scf_helper; scf_wavefunction_factory; SCFConvergenceError; set_memory; set_module_options; set_options; Table; tdscf; TDSCFConvergenceError; temp_circular_import_blocker; TestComparisonError; UpgradeHelper; ValidationError; vibanal_wfn; write_eigenvalues.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:764585,Validat,ValidationError,764585,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['Validat'],['ValidationError']
Security,"ld(ref_wfn.molecule(), ""DF_BASIS_SAPT"",; core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS""),; ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SAPT"", sapt_basis). minao = core.BasisSet.build(ref_wfn.molecule(), ""BASIS"",; core.get_global_option(""MINAO_BASIS"")); ref_wfn.set_basisset(""MINAO"", minao). fisapt_wfn = core.FISAPT(ref_wfn); fisapt_wfn.compute_energy(). optstash.restore(); return fisapt_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = core.get_variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:114302,Validat,ValidationError,114302,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"le for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); core.print_out(""\n""). # write index of calcs to output file; if db_mode == 'continuous':; instructions = """"""\n The database single-job procedure has been selected through mode='continuo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:14672,Validat,ValidationError,14672,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"le for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); core.print_out(""\n""). # write index of calcs to output file; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """"",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:14596,Validat,ValidationError,14596,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,7,['Validat'],['ValidationError']
Security,"le is True:; write_checkpoint_file = True. # Continuum solvation needs to be run w/o symmetry; if core.get_option(""SCF"", ""PCM"") or core.get_option(""SCF"", ""DDX""):; c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.update_geometry(). scf_molecule = c1_molecule; core.print_out("""""" PCM or DDX continuum solvation does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""). # PE needs to use exactly input orientation to correspond to potfile; if core.get_option(""SCF"", ""PE"") or ""external_potentials"" in kwargs:; c1_molecule = scf_molecule.clone(); if getattr(scf_molecule, ""_initial_cartesian"", None) is not None:; c1_molecule._initial_cartesian = scf_molecule._initial_cartesian.clone(); c1_molecule.set_geometry(c1_molecule._initial_cartesian); c1_molecule.reset_point_group(""c1""); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); else:; raise ValidationError(""Set no_com/no_reorient/symmetry c1 by hand for PE or external potentials on non-Cartesian molecules.""). scf_molecule = c1_molecule; core.print_out("""""" PE does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); core.print_out("""""" PE geometry must align with POTFILE keyword: """"""; """"""resetting coordinates with fixed origin and orientation.\n""""""). # SCF Banner data; banner = kwargs.pop('banner', None); bannername = name. # Did we pass in a DFT functional?; dft_func = kwargs.pop('dft_functional', None); if dft_func is not None:; if name.lower() != ""scf"":; raise ValidationError(""dft_functional was supplied to SCF, but method name was not SCF ('%s')"" % name); name = dft_func; bannername = name; if isinstance(name, dict):; bannername = name.get(""name"", ""custom functional""). p4util.libint2_print_out(). # Setup the timer; if do_timer:; core.tstart(). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('SCF', 'SOSCF'):; proc_util.check_non_symmetric_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:47483,Validat,ValidationError,47483,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"le name. Use stdout as <filename> to redirect; to the screen. Default: output.dat. -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to PSI4 for available templates. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -v, --verbose¶; Print a lot of information. -d, --debug¶; Flush the outfile at every fprintf. Default: true iff --with-debug. -V, --version¶; Print version information. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for executables. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins (see Plugins: Adding New Functionality to PSI4) or databases.; Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shell commands. First line for C shell; second for bash.; setenv PYTHONPATH /home/user/psiadditions:$PYTHONPATH; PYTHONPATH=/home/user/psiadditions:$PYTHONPATH; export PYTHONPATH. Place the path in the ~/.psi4rc file so that it is available for; every PSI4 instance.; sys.path.i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/external-1.html:9812,access,access,9812,psi4manual/4.0b3/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/external-1.html,2,['access'],['access']
Security,"le name. Use stdout as <filename> to redirect; to the screen. Default: output.dat. -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to PSI4 for available templates. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -v, --verbose¶; Print a lot of information. -d, --debug¶; Flush the outfile at every fprintf. Default: true iff --with-debug. -V, --version¶; Print version information. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for executables. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins (see Plugins: Adding New Functionality to PSI4). Table Of Contents. Configuration: Preparing PSI4’s Environment; Scratch Files and the ~/.psi4rc File; Threading; Command Line Options; Environment Variables. Previous topic; A PSI4 Tutorial; Next topic; Psithon: Structuring an Input File; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/external-1.html:8806,access,access,8806,psi4manual/4.0b2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/external-1.html,2,['access'],['access']
Security,"le some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices includ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/introduction.html:1541,access,access,1541,psi4manual/master/introduction.html,https://psicode.org,https://psicode.org/psi4manual/master/introduction.html,15,['access'],['access']
Security,"le('CURRENT ENERGY', e_mp25). Once your python function is fairly stable on its own, it’s potential for interoperability with energy()/opt()/cp()/db()/cbs()/etc. should be evaluated. If it makes physical sense that it should work, you should strive to make that interoperability a reality. Some steps:. If any interoperability is possible, define an argument xx_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function.; # Establish function to call; if not('xx_func' in kwargs):; if ('func' in kwargs):; kwargs['xx_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['xx_func'] = energy; func = kwargs['xx_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper xx is unhappy to be calling function \'%s\'.' % (func.__name__)). If specific interoperabilities are known, code them in. For example, if xx shouldn’t call db, add the last two lines above to the xx function. If db shouldn’t call xx, add the following two lines below to the db function.; if (func is xx):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'.' % (func.__name__)). Create a multipart test case that runs some intercalls between your function and others (akin to pywrap_all). In trials, permute the order of calls a few times to expose any calls that don’t clean up after themselves and need further attention. When all is validated, add your findings to the great Permitted nesting of Psithon functions table in the documentat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/bestpractices_py-1.html:5536,Validat,ValidationError,5536,psi4manual/4.0b4/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/bestpractices_py-1.html,10,['Validat'],['ValidationError']
Security,"le, me=me, stde=stde,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_modelchems(self, modelchem, benchmark='default', mbenchmark=None,; sset='default', msset=None, failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics over all component; databases for each model chemistry in array *modelchem* versus *benchmark*; over subset *sset*. *mbenchmark* and *msset* are array options (same; length as *modelchem*) that override *benchmark* and *sset*, respectively,; for non-uniform specification. Thread *color* can be 'rgb' for old; coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # distribute benchmark; if mbenchmark is None:; lbenchmark = [benchmark] * len(modelchem) # normal bm modelchem name; else:; if isinstance(mbenchmark, basestring) or len(mbenchmark) != len(modelchem):; raise ValidationError(; """"""mbenchmark must be array of length distributable among modelchem"""""" % (str(mbenchmark))); else:; lbenchmark = mbenchmark # array of bm for each modelchem; # distribute sset; if msset is None:; lsset = [sset] * len(modelchem) #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:77394,access,accessible,77394,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['access'],['accessible']
Security,"lected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_SAPT is required.'). psi4.print_out('\n'); p4util.banner(name.upper()); psi4.print_out('\n'); e_sapt = psi4.sapt(). molecule.reset_point_group(user_pg); molecule.update_geometry(). optstash.restore(); return e_sapt. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = psi4.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SCF', 'SAPT', '2-dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'); psi4.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); psi4.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; psi4.IO.chan",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:53849,Validat,ValidationError,53849,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"lecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. select_omp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. select_omp3(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. select_omp3_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. check_iwl_file_from_scf_type(scf_type, wfn)[source]¶; Ensures that a IWL file has been written based on input SCF type. check_non_symmetric_jk_density(name)[source]¶; Ensure non-symmetric density matrices are supported for the selected JK routine. dft_set_reference_local(name)[source]¶; Figures out the correct DFT reference to set locally. oeprop_validator(prop_list)[source]¶; Validations a list of OEProp computations. Throws if not found. scf_set_reference_local(name)[source]¶; Figures out the correct SCF reference to set locally. run_roa(name, **kwargs)[source]¶; Main driver for managing Raman Optical activity computations with; CC response theory. Uses distributed finite differences approach –>. Sets up a database to keep track of running/finished/waiting; computations. Generates separate input files for displaced geometries. When all displacements are run, collects the necessary information; from each displaced computation, and computes final result. Table Of Contents. Python Driver; wrapper_database; diatomic; pcm_placeholder; dependency_check; gaussian_n; frac; molutil; driver_util; aliases; interactive; pubchem; inputparser; driver_nbody; driver_cbs; driver; wrapper_autofrag; qmmm; qcdb; p4util; p4const; procedures. Previous topic; BasisSet; Next topic; psi4: Linking C++ and Python. This Page. Show Source. Quick search. Enter search terms or a module, c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:171141,Validat,Validations,171141,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['Validat'],['Validations']
Security,"lecule""""""); self.update_geometry(). # # Validate arguments; # dashlvl = dashlvl.lower(); # dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; # if dashlvl not in dashcoeff.keys():; # raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). # if func is None:; # if dashparam is None:; # # defunct case; # raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); # else:; # # case where all param read from dashparam dict (which must have all correct keys); # func = 'custom'; # dashcoeff[dashlvl][func] = {}; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # for key in dashcoeff[dashlvl]['b3lyp'].keys():; # if key in dashparam.keys():; # dashcoeff[dashlvl][func][key] = dashparam[key]; # else:; # raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); # else:; # func = func.lower(); # if func not in dashcoeff[dashlvl].keys():; # raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); # if dashparam is None:; # # (normal) case where all param taken from dashcoeff above; # pass; # else:; # # case where items in dashparam dict can override param taken from dashcoeff above; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # for key in dashcoeff[dashlvl]['b3lyp'].keys():; # if key in dashparam.keys():; # dashcoeff[dashlvl][func][key] = dashparam[key]. # TODO temp until figure out paramfile; allowed_funcs = ['HF/MINIS', 'DFT/MINIS', 'HF/MINIX', 'DFT/MINIX',; 'HF/SV', 'DFT/SV', 'HF/def2-SV(P)', 'DFT/def2-SV(P)', 'HF/def2-SVP',; 'DFT/def2-SVP', 'HF/DZP', 'DFT/DZP', 'HF/def-TZVP', 'DFT/def-TZVP',; 'HF/def2-TZVP', 'DFT/def2-TZVP', 'HF/631Gd', 'DFT/631Gd',; 'HF/def2-TZVP', 'DFT/def2-TZVP',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html:3783,Validat,ValidationError,3783,psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,1,['Validat'],['ValidationError']
Security,"lecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n""""""); E0r, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0;; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; E_HOMOr = E_HOMO; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; if read:; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n""""""); E1r = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if IPr > kIPr:; message = (""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP""""""); raise ValidationError(message). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; psi4.set_global_option(""GUESS"", ""READ""). # Left endpoint; psi4.set_global_option('DFT_OMEGA', omega_l). # Neutral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n""""""); E0l, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; E_HOMOl = E_HOMO; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; psi4.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(char",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/frac.html:14521,Validat,ValidationError,14521,psi4manual/1.0.0/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html,1,['Validat'],['ValidationError']
Security,"lecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2angstroms; fileY /= psi_bohr2angstroms; fileZ /= psi_bohr2angstroms. # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:21648,Validat,ValidationError,21648,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,3,['Validat'],['ValidationError']
Security,"lecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2angstroms; fileY /= psi_bohr2angstroms; fileZ /= psi_bohr2angstroms. # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Molecule::init_with_xyz: Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise Validatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:23902,Validat,ValidationError,23902,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"led from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Mal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html:2099,Validat,ValidationError,2099,psi4manual/4.0b3/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html,3,['Validat'],['ValidationError']
Security,"len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; beta = valueHI.clone(); beta.name = 'Truhlar SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Truhlar SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Truhlar 2-point power from SCF extrapolation for method: %s <==\n\n"""""" %; (functionname.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_truhlar_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_karton_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname : str; Name of the CBS component.; zLO : int; Lower zeta level.; valueLO : float; Lower value used for extrapolation.; zHI : int; Higher zeta level. Should be equal to zLO + 1.; valueHI : float; Higher value used for extrapolation.; alpha : float, optional; Overrides the default :math:`\alpha = 6.3`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [3]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3`. References; ----------. .. [3] Karton, Martin, Theor. Chem. Acc. 115 (2006) 330-333,; DOI: 10.1007/s00214-005-0028-6. """""". if type(valueLO) != ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:13137,Validat,ValidationError,13137,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; beta = valueHI.clone(); beta.name = 'Truhlar SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Truhlar SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Truhlar 2-point power from SCF extrapolation for method: %s <==\n\n"""""" %; (functionname.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_truhlar_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: float, zHI: int, valueHI: float, verbose: bool = True, alpha: float = None):; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component.; zLO; Lower zeta level.; valueLO; Lower value used for extrapolation.; zHI; Higher zeta level. Should be equal to zLO + 1.; valueHI; Higher value used for extrapolation.; alpha; Overrides the default :math:`\alpha = 6.3`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [3]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3`. References; ----------. .. [3] Karton, Martin, Theor. Chem. Acc. 115 (2006) 330-333,; DOI: 10.1007/s00214-005-0028-6. """""". if type(valueLO) != type(v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:13372,Validat,ValidationError,13372,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"len(needdict); zlabels = _lmh_labels[Nxtpl] # e.g., ['LO', 'HI']. for zeta in range(Nxtpl):; zlab = zlabels[zeta] # e.g., LO; largs['z' + zlab] = needdict[zlab]['f_zeta']; largs['value' + zlab] = needdict[zlab][datakey]. return largs. def _parse_cbs_gufunc_string(method_name: str):; """""" A helper function that parses a ``""method/basis""`` input string; into separate method and basis components. Also handles delta corrections. Parameters; ----------; method_name; A ``""method/basis""`` style string defining the calculation. Returns; -------; tuple; Tuple in the ``(method_list, basis_list)`` format, where ``method_list``; is the list of the component methods, and ``basis_list`` is the list of; basis sets forming the extrapolation for each specified method.; E.g. ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""`` would return:; ``([""mp2"", ""ccsd(t)""], [""cc-pv[tq]z"", ""cc-pvtz""])``.; """""". method_name_list = re.split(r""""""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:38895,Validat,ValidationError,38895,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,5,['Validat'],['ValidationError']
Security,"len(psi4.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or psi4.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; pass; else:; psi4.set_local_option('SCF','REFERENCE','UHF'); return optstash. [docs]def dft_set_reference_local(name):; """"""; Figures out the correct DFT reference to set locally; """""". optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). return optstash. [docs]def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES',; 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES',; 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI',; 'NO_OCCUPATIONS']. if not len(prop_list):; raise ValidationnError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop,; oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)); . [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written base",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html:3188,Validat,ValidationError,3188,psi4manual/1.0.0/_modules/procedures/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html,1,['Validat'],['ValidationError']
Security,"les or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). core.set_local_option('FNOCC', 'DFCC', True); core.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""""""Error: {name} requires 'reference rhf'.""""""). def set_cholesky_from(mtd_type):; type_val = core.get_global_option(mtd_type); if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(""""""Invalid type '%s' for DFCC"""""" % type_val). # triples?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:152683,Validat,ValidationError,152683,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Es",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:63998,Validat,ValidationError,63998,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,"leted. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to PSI4 for available templates. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -d, --debug¶; Flush the outfile at every fprintf. Default: true iff --with-debug. -V, --version¶; Print version information. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for executables. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins (see Plugins: Adding New Functionality to PSI4) or databases.; Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shell commands. First line for C shell; second for bash.; setenv PYTHONPATH /home/user/psiadditions:$PYTHONPATH; PYTHONPATH=/home/user/psiadditions:$PYTHONPATH; export PYTHONPATH. Place the path in the ~/.psi4rc file so that it is available for; every PSI4 instance.; sys.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/external-1.html:10281,access,access,10281,psi4manual/4.0b4/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/external-1.html,4,['access'],['access']
Security,"level in range(5, 99):; VARH[f'mp{mplevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'mp{mplevel}': f'MP{mplevel} TOTAL ENERGY'}; for mplevel2 in range(2, mplevel):; VARH[f'mp{mplevel}'][f'mp{mplevel2}'] = f'MP{mplevel2} TOTAL ENERGY'. # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH; # yapf: enable. VARH = return_energy_components(). [docs]def _get_default_xtpl(nbasis: int, xtpl_type: str) -> Callable:; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return xtpl_highest_1; elif xtpl_type == ""scf"":; if nbasis == 2:; return scf_xtpl_helgaker_2; elif nbasis == 3:; return scf_xtpl_helgaker_3; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return corl_xtpl_helgaker_2; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata, molecule):; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata : list; List of dicts containing CBS stage keywords.; molecule : qcdb.molecule or psi4.core.Molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:28998,Validat,ValidationError,28998,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,6,['Validat'],['ValidationError']
Security,"level))] = {; 'hf': 'HF TOTAL ENERGY',; 'mp%s' % (str(mplevel)): 'MP%s TOTAL ENERGY' % (str(mplevel))}; for mplevel2 in range(2, mplevel):; VARH['mp%s' % (str(mplevel))]['mp%s' % (str(mplevel2))] = \; 'MP%s TOTAL ENERGY' % (str(mplevel2)). # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH; # yapf: enable. VARH = return_energy_components(). [docs]def _get_default_xtpl(nbasis, xtpl_type):; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis : int; Number of basis sets; xtpl_type : {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; function; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return xtpl_highest_1; elif xtpl_type == ""scf"":; if nbasis == 2:; return scf_xtpl_helgaker_2; elif nbasis == 3:; return scf_xtpl_helgaker_3; else:; raise ValidationError(""Wrong number of basis sets supplied to scf_xtpl: %d"" % nbasis); elif xtpl_type == ""corl"":; if nbasis == 2:; return corl_xtpl_helgaker_2; else:; raise ValidationError(""Wrong number of basis sets supplied to corl_xtpl: %d"" % nbasis); else:; raise ValidationError(""Stage treatment must be 'corl' or 'scf', not '%s'"" % xtpl_type). def _validate_cbs_inputs(cbs_metadata, molecule):; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata : list; List of dicts containing CBS stage keywords.; molecule : qcdb.molecule or psi4.core.Molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for item in cbs_metadata:; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(""Stage {:d} doesn't have defined level of theory!"".format(cbs_metadata.in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:28489,Validat,ValidationError,28489,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"lf.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:39027,Validat,ValidationError,39027,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"lgorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(psi4.me() == 0):; shutil.copy(restartfile, targetfile); else:; scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). e_dfmp2 = psi4.dfmp2(); e_scs_dfmp2 = psi4.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; run_mcscf(name, **kwargs); psi4.psimrcc(); return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). psi4.psimrcc(); return psi4.get_variable(""CURRENT ENERGY""). [docs]d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:44382,Validat,ValidationError,44382,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"lgorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cbs-xtpl-func; optimization with method defined via cbs. fcidump; test FCIDUMP functionality for rhf/uhf. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. scf-level-shift-rohf; SCF level shift on an ROHF computation. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. dforemp-grad2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. scf3; File retention, docc, socc, and bond distances specified explicitly. opt16; SCF 6-31G(d) optimization of TS for HCN to HNC Performs finite difference hessian calculation. Then optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the plane of symemtry, This test confirms that only the reference geometry, with the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. nbo; Generation of NBO file. fnocc6; Test method/basis with disk_df. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. remp-energy2; integral conventional unrestricted REMP/cc-pVDZ energies for the H2O+ molecule. results were independently verified against the initial wavels implementation. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. decontract; RHF/cc-pvdz-decontract HCl single-point energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:34986,Validat,ValidationError,34986,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['Validat'],['ValidationError']
Security,"lidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are feezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" %; (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (opt_mode == 'continuous') and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.get_variable('CURRENT ENERGY'). # Compute the gradient; G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.get_variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # S/R: Quit after",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:58616,Validat,ValidationError,58616,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"lidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()). # If we are feezing cartesian, do not orient or COM; if psi4.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= psi4.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" %; (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (opt_mode == 'continuous') and (not psi4.get_option('SCF', 'GUESS_PERSIST')):; psi4.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (psi4.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = psi4.get_variable('CURRENT ENERGY'). # Compute the gradient; G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = psi4.get_variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # S/R: Quit after",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:56774,Validat,ValidationError,56774,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"lied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. from __future__ import print_function; import math; import re; import psi4; import qcdb; import p4util; from p4util.exceptions import *; from procedures import *. def _method_exists(ptype, method_name):; r""""""; Quick check to see if this method exists, if it does not exist we raise a convenient flag.; """"""; if method_name not in procedures[ptype].keys():; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(method_name,; procedures[ptype].keys(), 2); if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)); Cptype = ptype[0].upper() + ptype[1:]; raise ValidationError('%s method ""%s"" is not available.%s' % (Cptype, method_name, alternatives)). def _set_convergence_criterion(ptype, method_name, scf_Ec, pscf_Ec, scf_Dc, pscf_Dc, gen_Ec, verbose=1):; r""""""; This function will set local SCF and global energy convergence criterion; to the defaults listed at:; http://www.psicode.org/psi4manual/master/scf.html#convergence-and-; algorithm-defaults. SCF will be converged more tightly if a post-SCF; method is select (pscf_Ec, and pscf_Dc) else the looser (scf_Ec, and; scf_Dc convergence criterion will be used). ptype - Procedure type (energy, gradient, etc). Nearly always test on; procedures['energy'] since that's guaranteed to exist for a method.; method_name - Name of the method; scf_Ec - E convergence criterion for scf target method; pscf_Ec - E convergence criterion for scf of post-scf target method; scf_Dc - D convergence criterion for scf target method; pscf_Dc - D convergence criterion for scf of post-scf target method; gen_Ec - E convergence crite",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:1596,Validat,ValidationError,1596,psi4manual/1.0.0/_modules/driver_util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html,1,['Validat'],['ValidationError']
Security,"lif isinstance(valueLO, (core.Matrix, core.Vector)):. beta = valueHI.clone(); beta.subtract(valueLO); beta.scale(1 / (zHI ** (-alpha) - zLO ** (-alpha))); beta.name = 'Helgaker Corl (%s, %s) beta' % (zLO, zHI). value = valueHI.clone(); value.scale(zHI ** alpha). tmp = valueLO.clone(); tmp.scale(zLO ** alpha); value.subtract(tmp). value.scale(1 / (zHI ** alpha - zLO ** alpha)); value.name = 'Helgaker Corr (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Helgaker 2-point correlated extrapolation for """"""; """"""method: %s <==\n\n"""""" % (functionname.upper())); core.print_out("""""" LO-zeta (%s) Data\n"""""" % (str(zLO))); valueLO.print_out(); core.print_out("""""" HI-zeta (%s) Data\n"""""" % (str(zHI))); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % alpha); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). # value.add(valueSCF); return value. else:; raise ValidationError(""corl_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). def return_energy_components():; VARH = {}; VARH['scf'] = {; 'scf': 'SCF TOTAL ENERGY'}; VARH['hf'] = {; 'hf': 'HF TOTAL ENERGY'}; VARH['mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY',; 'mp4': 'MP4(SDTQ) TOTAL ENERGY'}; VARH['omp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'omp2': 'OMP2 TOTAL ENE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:19356,Validat,ValidationError,19356,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"lif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast:; # Cast is a special case; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n""); if banner:; core.print_out("" "" + banner.center(58)); if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58)); ref_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:49945,Validat,ValidationError,49945,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"lif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'); elif name in ['r2scan3c', 'r2scan-3c']:; core.set_global_option('BASIS', 'def2-mTZVPP'); elif name in ['b973c', 'b97-3c']:; core.set_global_option('BASIS', 'def2-mTZVP'); elif name in ['wb97x3c', 'wb97x-3c']:; core.set_global_option('BASIS', 'vdzp'). # the FIRST scf call; if cast:; # Cast is a special case; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:50234,Validat,ValidationError,50234,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"list (List[psi4.driver.task_base.AtomicComputer]); trove (List[Dict[str, Any]]); verbose (int). Validators:. set_molecule » molecule. field basis: str = '(auto)'¶. field cbsrec: List[Dict[str, Any]] = []¶. field compute_list: List[Dict[str, Any]] = []¶. field driver: DriverEnum [Required]¶. field keywords: Dict[str, Any] = {}¶. field metadata: Any = None¶. field metameta: Dict[str, Any] = {}¶. field method: str = '(auto)'¶. field molecule: Any = None¶. Validated by:. set_molecule. field results_list: List[Any] = []¶. field task_list: List[AtomicComputer] = []¶. field trove: List[Dict[str, Any]] = []¶. field verbose: int = 1¶. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶. Parameters:; client (Optional[FractalClient]) – . get_psi_results(return_wfn=False)[source]¶; Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:; return_wfn (bool) – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. molecule; dummy basis, def2-svp; e/g/h member data; QCVariables; module if simple. Return type:; Union[float, Matrix, Tuple[Union[float, Matrix], Wavefunction]]. Returns:. ret – Energy, gradient, or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. get_results(client=None)[source]¶; Return results as Composite-flavored QCSchema. Return type:; AtomicResult. Parameters:; client (Optional[FractalClient]) – . plan()[source]¶. validator set_molecule  »  molecule[source]¶. table of contents. Complete Basis Set; Output; Extrapolation Schemes; Aliases; API. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Complete Basis Set. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cbs.html:37776,validat,validator,37776,psi4manual/1.7.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cbs.html,1,['validat'],['validator']
Security,"ll dftd3 program; try:; dashout = subprocess.Popen(['dftd3', geomfile, '-grad'], stdout=subprocess.PIPE); except OSError:; raise ValidationError('Program dftd3 not found in path.'); out, err = dashout.communicate(). # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; raise ValidationError('Program dftd3 did not complete successfully.'). # Parse grad output; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; i = 0; for line in geom.splitlines():; if i == 0:; i += 1; else:; if line.split()[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; temp = dfile.readline(); dashdderiv.append([float(x.replace('D', 'E')) for x in temp.split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())); psi_dashdderiv = PsiMod.Matrix(self.natom(), 3); psi_dashdderiv.set(dashdderiv). # Print program output to file if verbose; verbose = PsiMod.get_option('SCF', 'PRINT'); if verbose >= 3:; PsiMod.print_out('\n ==> DFTD3 Output <==\n'); PsiMod.print_out(out); dfile = open(derivfile, 'r'); PsiMod.print_out(dfile.read().replace('D', 'E')); dfile.close(); PsiMod.print_out('\n'). # Clean up files and remove scratch directory; os.unlink(paramfile); os.unlink(geomfile); os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); try:; shutil.rmtree(dftd3_tmpdir); except OSError as e:; ValidationError('Unable to remove dftd3 temporary directory %s' % e, file=sys.stderr); os.chdir(current_directory). # return -D & d(-D)/dx; PsiMod.set_variable('DISPERSION CORRECTION ENERGY', dashd); if dertype == -1:; return dashd, dashdderiv; elif dertype == 0:; return dashd; elif de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:11019,Validat,ValidationError,11019,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"ll dftd3 program; try:; dashout = subprocess.Popen(['dftd3', geomfile, '-grad'], stdout=subprocess.PIPE); except OSError:; raise ValidationError('Program dftd3 not found in path.'); out, err = dashout.communicate(). # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; raise ValidationError('Program dftd3 did not complete successfully.'). # Parse grad output; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; i = 0; for line in geom.splitlines():; if i == 0:; i += 1; else:; if line.split()[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; temp = dfile.readline(); dashdderiv.append([float(x.replace('D', 'E')) for x in temp.split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())); psi_dashdderiv = psi4.Matrix(self.natom(), 3); psi_dashdderiv.set(dashdderiv). # Print program output to file if verbose; verbose = psi4.get_option('SCF', 'PRINT'); if verbose >= 3:; psi4.print_out('\n ==> DFTD3 Output <==\n'); psi4.print_out(out); dfile = open(derivfile, 'r'); psi4.print_out(dfile.read().replace('D', 'E')); dfile.close(); psi4.print_out('\n'). # Clean up files and remove scratch directory; os.unlink(paramfile); os.unlink(geomfile); os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); try:; shutil.rmtree(dftd3_tmpdir); except OSError as e:; ValidationError('Unable to remove dftd3 temporary directory %s' % e, file=sys.stderr); os.chdir(current_directory). # return -D & d(-D)/dx; psi4.set_variable('DISPERSION CORRECTION ENERGY', dashd); if dertype == -1:; return dashd, dashdderiv; elif dertype == 0:; return dashd; elif dertype == 1:; r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:11850,Validat,ValidationError,11850,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"lled on a python export of a psi4.core.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # # Validate arguments; # dashlvl = dashlvl.lower(); # dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; # if dashlvl not in dashcoeff.keys():; # raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; # elif der2nd.match(str(dertype)):; # raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). # if func is None:; # if dashparam is None:; # # defunct case; # raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); # else:; # # case where all param read from dashparam dict (which must have all correct keys); # func = 'custom'; # dashcoeff[dashlvl][func] = {}; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # for key in dashcoeff[dashlvl]['b3lyp'].keys():; # if key in dashparam.keys():; # dashcoeff[dashlvl][func][key] = dashparam[key]; # else:; # raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); # else:; # func = func.lower(); # if func not in dashcoeff[dashlvl].keys():; # raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); # if dashparam is None:; # # (normal) case where all param taken from dashcoeff above; # pass; # else:; # # case where items in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html:3519,Validat,ValidationError,3519,psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,2,['Validat'],['ValidationError']
Security,"llname': 'CC6' },; 'sdt-3' : { 'method': 8, 'order': 3, 'fullname': 'CCSDT-3' },; 'sdtq-3' : { 'method': 8, 'order': 4, 'fullname': 'CCSDTQ-3' },; 'sdtqp-3' : { 'method': 8, 'order': 5, 'fullname': 'CCSDTQP-3' },; 'sdtqph-3' : { 'method': 8, 'order': 6, 'fullname': 'CCSDTQPH-3' }; }. # looks for 'sdt(q)' in dictionary; if ccfullname in methods:; return 'mrcc', methods[ccfullname]; else:; raise ValidationError('MRCC method \'%s\' invalid.' % (name)). elif re.match(r'^[a-z]+\d+$', name):; decompose = re.compile(r'^([a-z]+)(\d+)$').match(name); namestump = decompose.group(1); namelevel = int(decompose.group(2)). if namestump in ['mp', 'zapt', 'ci']:; # Let mp2, mp3, mp4 pass through to select functions; if namestump == 'mp' and namelevel in [2, 3, 4]:; return name, None; # Otherwise return method and order; else:; return namestump, namelevel; else:; return name, None; else:; return name, None. [docs]def parse_cotton_irreps(irrep, point_group):; r""""""Function to return validated Cotton ordering index for molecular; *point_group* from string or integer irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2v': {; 'a1': 1,; 'a2': 2,; 'b1': 3,; 'b2': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2h': {; 'ag': 1,; 'bg': 2,; 'au': 3,; 'bu': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; },; 'd2h': {; 'ag': 1,; 'b1g': 2,; 'b2g': 3,; 'b3g': 4,; 'au': 5,; 'b1u': 6,; 'b2u': 7,; 'b3u': 8,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; '5': 5,; '6': 6,; '7': 7,; '8': 8; }; }. try:; return cotton[point_group.lower()][str(irrep).lower()]; except KeyError:; raise ValidationError(""""""Irrep '%s' not valid for point group '%s'."""""" % (str(irrep), point_group)). Quick search. Enter search terms or a module, class or function name.; . Navigation. i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:7411,validat,validated,7411,psi4manual/1.0.0/_modules/driver_util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html,1,['validat'],['validated']
Security,"lls at center i (0-index); * Used for Atomic HF computations for SAD Guesses; * @param center Atomic center to provide a basis object for.; * @returns A new basis set object for the atomic center. """"""; return BasisSet(self, center). @staticmethod; [docs] def build(molecule, shells):; """"""Builder factory method; * @param molecule the molecule to build the BasisSet around; * @param shells array of *atom-numbered* GaussianShells to build the BasisSet from; * @return BasisSet corresponding to this molecule and set of shells. """"""; raise FeatureNotImplemented('BasisSet::build'). @staticmethod; [docs] def pyconstruct_combined(mol, keys, targets, fitroles, others):. # make sure the lengths are all the same; if len(keys) != len(targets) or len(keys) != len(fitroles):; raise ValidationError(""""""Lengths of keys, targets, and fitroles must be equal""""""). # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, basestring):; mol = Molecule(mol); returnBasisSet = False; elif isinstance(mol, Molecule):; returnBasisSet = True; else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # load in the basis sets; sets = []; name = """"; for at in range(len(keys)):; bas = BasisSet.pyconstruct(mol, keys[at], targets[at], fitroles[at], others[at]); name += targets[at] + "" + ""; sets.append(bas). name = name[:-3].strip(); # work our way through the sets merging them; combined_atom_basis_shell = OrderedDict(); for at in range(len(sets)):; atom_basis_shell = sets[at].atom_basis_shell. for label, basis_map in atom_basis_shell.items():; if label not in combined_atom_basis_shell:; combined_atom_basis_shell[label] = OrderedDict(); combined_atom_basis_shell[label][name] = []; for basis, shells in basis_map.items():; combined_atom_basis_shell[label][name].extend(shells). #for label, basis_map in combined_atom_basis_shell.items():; # # sort the shells by angular momentum; # combined_atom_basis_shell[label][name] = sorted(combined_atom_basis_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:15432,Validat,ValidationError,15432,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['Validat'],['ValidationError']
Security,"lly; """""". optstash = p4util.OptionsState(['SCF_TYPE'], ['SCF', 'REFERENCE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Alter reference name if needed; user_ref = core.get_option('SCF', 'REFERENCE'). sup = build_superfunctional_from_dictionary(functionals[name], 1, 1, True)[0]; if sup.needs_xc() or is_dft:; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop, oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.basisset()); if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(wfn.molecule(),; ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"",; core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); mints.set_basisset('BASIS_RELATIVISTIC', rel_bas)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:2555,Validat,ValidationError,2555,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,3,['Validat'],['ValidationError']
Security,"lobal_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; core.cctriples(ref_wfn). optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:93601,Validat,ValidationError,93601,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"lobal_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if (core.variable('BRUECKNER CONVERGED') == True):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; core.cctriples(ref_wfn). optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:92468,Validat,ValidationError,92468,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"lobal_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'). return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). if (PsiMod.get_global_option('SCF_TYPE') != 'DF'):; raise ValidationError('SCF_TYPE must be DF for DFT gradient (for now).'). run_scf_gradient(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); PsiMod.revoke_global_option_changed('REFERENCE'). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; if (name.lower() == 'zapt'):; PsiMod.set_global_option('WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_option('MPN_ORDER_SAVE', 1); elif (name.lower() == 'mp'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('MPN', 'TRUE'). level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:18269,Validat,ValidationError,18269,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"lobal_option_changed('WFN'); user_wfn = PsiMod.get_option('WFN'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:62196,Validat,ValidationError,62196,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"low; and indexed in Keywords by Module are placed in set blocks as; described in Job Control Keywords, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to \(10^{-6} E_h\), the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Notes on PSI Variables¶. Note; Starting in 1.6, there are three standard ways to access an excited state; property. We give examples below, but the method name and property name may change. method ROOT 0 -> ROOT m property to get root m.; method ROOT 0 -> ROOT m property - h TRANSITION to get root m and; independently specify that the total transition symmetry is h, e.g., A2.; method ROOT 0 (h) -> ROOT m (i) property to get the transition; between two roots, specifying the symmetry of both states and the index of the target; roots among states of their own symmetry. For example, to target the second excited-state, which is also the lowest energy state; of its irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much more strongly than; with the molecular system. Changing the number of roots sought, the symmetry; subspace or the symmetry apportionment of roots under which the computation is run,; or the excited state method are all likely to s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/notes_c.html:1248,access,access,1248,psi4manual/master/notes_c.html,https://psicode.org,https://psicode.org/psi4manual/master/notes_c.html,4,['access'],['access']
Security,"lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA basis sets through keyword '%s' are required."""""" % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')); #; # # Establish list of valid basis sets for fifth delta correction energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_3; elif (len(BSTR) == 2) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot be handled."""""" % (len(BSTR))); elif do_corl:; cbs_scf_scheme = xtpl_highest_1; BSTR = [BSTC[-1]]; ZETR = [ZETC[-1]]; if 'scf_scheme' in kwargs:; cbs_scf_sche",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:37649,Validat,ValidationError,37649,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"lows rows to be in a different order.; @param rhs Matrix to compare to.; @returns true if equal, otherwise false. """"""; for m in range(len(mat)):; for m_rhs in range(len(mat)):. for n in range(len(mat[m])):; if abs(mat[m][n] - rhs[m_rhs][n]) > tol:; break # from n; else:; # whole row matched, goto next m row; break # from m_rhs; else:; # no matching row was found; return False; else:; return True. [docs]def compute_atom_map(mol):; """"""Computes atom mappings during symmetry operations. Useful in; generating SO information and Cartesian displacement SALCs.; param mol Molecule to form mapping matrix from.; returns Integer matrix of dimension natoms X nirreps. """"""; # create the character table for the point group; ct = mol.point_group().char_table(). natom = mol.natom(); ng = ct.order(); atom_map = [0] * natom; for i in range(natom):; atom_map[i] = [0] * ng. np = [0.0, 0.0, 0.0]; so = SymmetryOperation(). # loop over all centers; for i in range(natom):; ac = mol.xyz(i). # then for each symop in the pointgroup, transform the coordinates of; # center ""i"" and see which atom it maps into; for g in range(ng):; so = ct.symm_operation(g). for ii in range(3):; np[ii] = 0; for jj in range(3):; np[ii] += so[ii][jj] * ac[jj]. atom_map[i][g] = mol.atom_at_position(np, 0.05); if atom_map[i][g] < 0:; print("""""" Molecule:\n""""""); mol.print_out(); print("""""" attempted to find atom at\n""""""); print("""""" %lf %lf %lf\n"""""" % (np[0], np[1], np[2])); raise ValidationError(""ERROR: Symmetry operation %d did not map atom %d to another atom:\n"" % (g, i + 1)). return atom_map. # TODO outfile; # ignored =, +, 0, += assignment operators; # no pubchem; # TODO rename save_string_for_psi4; # TODO add no_com no_reorint in save string for psi4. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:96264,Validat,ValidationError,96264,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"lse):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); freagent.close(); return E. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta5] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:7466,Validat,ValidationError,7466,psi4manual/4.0b5/_modules/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html,3,['Validat'],['ValidationError']
Security,"lse, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:6547,Validat,ValidationError,6547,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,8,['Validat'],['ValidationError']
Security,"lse:; PsiMod.dfmp2(); returnvalue += dfun.c_alpha() * PsiMod.get_variable('DF-MP2 CORRELATION ENERGY'). PsiMod.set_variable('DFT TOTAL ENERGY', returnvalue); PsiMod.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(); return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE']). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). if (PsiMod.get_option('SCF', 'SCF_TYPE') != 'DF'):; raise ValidationError('SCF_TYPE must be DF for DFT gradient (for now).'). returnvalue = run_scf_gradient(name, **kwargs). optstash.restore(); return returnvalue. [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if (name.lower() == 'zapt'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'ZAPTN'); PsiMod.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; PsiMod.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif (name.lower() == 'mp'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'DETCI'); PsiMod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:24729,Validat,ValidationError,24729,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"lta2 and do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:75733,Validat,ValidationError,75733,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"ltiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). qmol = core.Molecule.from_dict(molrec); geom = np.array(molrec[""geom""]).reshape((-1, 3)); qmol._initial_cartesian = core.Matrix.from_array(geom). if return_dict:; return qmol, molrec; else:; return qmol. @classmethod; def _molecule_from_schema(cls, molschema: Dict, return_dict: bool = False, nonphysical: bool = False, verbose: int = 1) -> Union[core.Molecule, Tuple[core.Molecule, Dict]]:; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~psi4.core.Molecule.from_arrays`. Parameters; ----------; molschema; Dictionary form of Molecule following known schema.; return_dict; Additionally return Molecule dictionary intermediate.; nonphysical; Do allow masses outside an element's natural range to pass validation?; verbose; Amount of printing. Returns; -------; mol : :py:class:`psi4.core.Molecule`; molrec : dict; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_schema(molschema, nonphysical=nonphysical, verbose=verbose). qmol = core.Molecule.from_dict(molrec); geom = np.array(molrec[""geom""]).reshape((-1, 3)); qmol._initial_cartesian = core.Matrix.from_array(geom). if return_dict:; return qmol, molrec; else:; return qmol. [docs]; def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the core.Molecule class. """"""; cls.__setattr__ = molecule_set_attr; cls.__getattr__ = molecule_get_attr. cls.to_arrays = qcdb.Molecule.to_arrays; cls.to_dict = qcdb.Molecule.to_dict; cls.BFS = qcdb.Molecule.BFS; cls.B787 = qcdb.Molecule.B787; cls.scramble = qcdb.Molecule.scramble; cls.from_arrays = _molecule_from_arrays; cls.from_string = _molecule_from_string; cls.to_string = qcdb.Molecule.to_string;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html:5222,validat,validation,5222,psi4manual/1.8.x/_modules/psi4/driver/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/molutil.html,3,['validat'],['validation']
Security,"lue(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); self.set_has_zmatrix(zmatrix). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:20717,Validat,ValidationError,20717,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"lueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. # Build and set from numpy routines; value = psi4.Matrix(*valueHI.shape); value_view = np.asarray(value); value_view[:] = np_value; return value. else:; raise ValidationError(""scf_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). #def corl_xtpl_helgaker_2(functionname, valueSCF, zLO, valueLO, zHI, valueHI, verbose=True):; [docs]def corl_xtpl_helgaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~driver_cbs.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; if type(valueLO) != type(valueHI):; raise ValidationError(""corl_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). if isinstance(valueLO, float):; value = (valueHI * zHI ** 3 - valueLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (valueHI - valueLO) / (zHI ** (-3) - zLO ** (-3)). # final = valueSCF + value; final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = """"""\n\n ==> Helgaker 2-point correlated extrapolation for method: %s <==\n\n"""""" % (functionname.upper()); # cbsscheme += """""" HI-zeta (%1s) SCF Energy: % 16.12f\n"""""" % (str(zHI), valueSCF); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); # cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n"""""" % beta; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; #cbsscheme += """""" LO-zeta (%s) Correlation Energy: % 16.12f\n"""""" % (str(zLO), valueLO); #cbsscheme += """""" HI-zeta (%s) Correlation Energy: % 16.12f\n"""""" % (str(zHI), ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:10174,Validat,ValidationError,10174,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"lumes\n""); free_atom_volumes(wfn) . oe.compute(). [docs]def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to be set.; A string is taken as a unit-containing value (e.g., 30 mb), which is; case-insensitive.; execute; When False, interpret *inputval* without setting in Psi4 core.; quiet; When True, do not print to the output file. Returns; -------; int; Number of bytes of memory set. Raises; ------; ValidationError; When <500MiB or disallowed type or misformatted. Examples; --------. >>> # [1] Passing absolute number of bytes; >>> psi4.set_memory(600000000); >>> psi4.get_memory(); Out[1]: 600000000L. >>> # [2] Passing memory value as string with units; >>> psi4.set_memory('30 GB'); >>> psi4.get_memory(); Out[2]: 30000000000L",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:3450,Validat,ValidationError,3450,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security,"ly; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in ; :envvar:`PATH`. """"""; # Validate arguments; if self is None:; self = PsiMod.get_active_molecule(). dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:7539,Validat,ValidationError,7539,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"l| ``'off'`` |dr|. Indicates whether, for *name* values built atop of scf calculations,; the scf step is skipped. Suitable when special steps are taken to get; the scf to converge in an explicit preceeding scf step. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into requested basis; >>> energy('sapt0-ct',cast_up=True). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp4'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['energy'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. if (PsiMod.get_global_option('REFERENCE').lower() == 'rks') or (PsiMod.get_global_option('REFERENCE').lower() == 'uks'):; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:20285,Validat,ValidationError,20285,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"m Canopy; print(""""""filedict, htmlcode = mpl.threads(%s,\n color='%s',\n title='%s',\n labels=%s,\n mae=%s,\n mape=%s\n xlimit=%s\n labeled=%s\n saveas=%s\n mousetext=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n mousediv=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, labels, mae, mape, str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, title=title, labels=labels, mae=mae, mape=mape,; xlimit=xlimit, labeled=labeled, view=view,; mousetext=mousetext, mouselink=mouselink,; mouseimag=mouseimag, mousetitle=mousetitle, mousediv=mousediv,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict, htmlcode. [docs]class WrappedDatabase(object):; """"""Wrapper class for raw Psi4 database modules that does some validation; of contents, creates member data and accessors for database structures,; defines error computation, and handles database subsets. Not to be used; directly-- see qcdb.Database for handling single or multiple; qdcb.WrappedDatabase objects and defining nice statistics, plotting, and; table functionalities. >>> asdf = qcdb.WrappedDatabase('Nbc10'); """""". def __init__(self, dbname, pythonpath=None):; """"""Instantiate class with case insensitive name *dbname*. Module; search path can be prepended with *pythonpath*. """"""; #: internal name of database; #:; #: >>> print asdf.dbse; #: 'NBC1'; self.dbse = None. #: description line; #:; #: >>> print asdf.tagl; #: 'interaction energies of dissociation curves for non-bonded systems'; self.tagl = None. #: OrderedDict of reactions/members; #:; #: >>> print asdf.hrxn.keys(); #: ['BzBz_S-3.2', 'BzBz_S-3.3', ... 'BzBz_PD36-2.8', 'BzBz_PD36-3.0']; self.hrxn = None. #: dict of reagents/geometries; #:; #: >>> print asdf.hrgt.keys(); #: ['NBC1-BzBz_PD32-0.8-monoA-CP', '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:20297,validat,validation,20297,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,2,"['access', 'validat']","['accessors', 'validation']"
Security,"m Psi4 LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = qcdb.options.reconcile_options(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = qcdb.options.prepare_options_for_cfour(userkw). # Handle text to be passed untouched to cfour; litcmd = core.get_global_option('LITERAL_CFOUR'). # Assemble ZMAT pieces; zmat = memcmd + molcmd + optcmd + mdccmd + psicmd + bascmd + litcmd. if len(re.findall(r'^\*(ACES2|CFOUR|CRAPS)\(', zmat, re.MULTILINE)) != 1:; core.print_out('\n Faulty ZMAT constructed:\n%s' % (zmat)); raise ValidationError(""""""; Multiple *CFOUR(...) blocks in input. This usually arises; because molecule or options are specified both the psi4 way through; molecule {...} and set ... and the cfour way through cfour {...}.""""""). return zmat. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; psi4.driver.procrouting.interface_cfour. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:17489,Validat,ValidationError,17489,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,1,['Validat'],['ValidationError']
Security,"m Psi4 LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = qcdb.options.reconcile_options(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = qcdb.options.prepare_options_for_cfour(userkw). # Handle text to be passed untouched to cfour; litcmd = core.get_global_option('LITERAL_CFOUR'). # Assemble ZMAT pieces; zmat = memcmd + molcmd + optcmd + mdccmd + psicmd + bascmd + litcmd. if len(re.findall(r'^\*(ACES2|CFOUR|CRAPS)\(', zmat, re.MULTILINE)) != 1:; core.print_out('\n Faulty ZMAT constructed:\n%s' % (zmat)); raise ValidationError(""""""; Multiple *CFOUR(...) blocks in input. This usually arises; because molecule or options are specified both the psi4 way through; molecule {...} and set ... and the cfour way through cfour {...}.""""""). return zmat. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.procrouting.interface_cfour. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/interface_cfour.html:17446,Validat,ValidationError,17446,psi4manual/1.9.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/interface_cfour.html,1,['Validat'],['ValidationError']
Security,"m __future__ import absolute_import; import shutil; import os; import subprocess; import re. # Relative hack for now; import sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); import p4util; from p4util.exceptions import *; from molutil import *. from .functional import *; from .roa import *; from . import proc_util. # never import driver, wrappers, or aliases into this file. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. [docs]def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:2447,validat,validation,2447,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['validat'],['validation']
Security,"m from same arguments as that class's; object-less constructor. *rxn* may be actual Reaction.name; or Reaction.indx. """"""; if (self.dbse == dbse):; if rxn in self.hrxn:; rxnname = rxn # rxn is proper reaction name; else:; try:; if (rxn + 1 > 0) and (rxn == self.hrxn.items()[rxn - 1][1].indx):; rxnname = self.hrxn.items()[rxn - 1][1].name # rxn is reaction index (maybe dangerous?); except (TypeError, IndexError):; raise ValidationError(; """"""Inconsistent to add ReactionDatum for %s to database %s with reactions %s."""""" %; (dbse + '-' + str(rxn), self.dbse, self.hrxn.keys())); label = '-'.join([method, mode, basis]); if overwrite or (label not in self.hrxn[rxnname].data):; self.hrxn[rxnname].data[label] = ReactionDatum.library_modelchem(dbse=dbse, rxn=rxnname,; method=method, mode=mode, basis=basis,; value=value, units=units,; comment=comment, citation=citation); else:; raise ValidationError(""""""ReactionDatum %s already present in Database."""""" % (label)); else:; raise ValidationError(""""""Inconsistent to add ReactionDatum for %s to database %s."""""" %; (dbse + '-' + str(rxn), self.dbse)). [docs] def add_Subset(self, name, func):; """"""Define a new subset labeled *name* by providing a function; *func* that filters *self.hrxn*. """"""; sname = name.lower().split('\n'); label = sname.pop(0); tagl = sname[0].strip() if sname else None; try:; filtered = func(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in filtered]; except TypeError as e:; raise ValidationError(""""""Function %s did not return list: %s."""""" % (func.__name__, str(e))); if len(lsslist) == 0:; print(""""""WrappedDatabase %s: Subset %s NOT formed: empty"""""" % (self.dbse, label)); return. self.sset[label] = OrderedDict(); for rxn in lsslist:; self.sset[label][rxn] = self.hrxn[rxn]; self.oss[label] = Subset(name=label,; hrxn=self.sset[label].keys(),; tagl=tagl); print(""""""WrappedDatabase %s: Subset %s formed: %d"""""" % (self.dbse, label, len(self.sset[label].keys()))). [docs] def compute_errors(self, modelchem, b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:30645,Validat,ValidationError,30645,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"m gradients for H2O. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. stability3; Test LDA stability analysis against QChem. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. scf-level-shift-rks; SCF level shift on an RKS computation. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. cc36; CC2(RHF)/cc-pVDZ energy of H2O. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. fnocc3; Test FNO-QCISD(T) computation. frac-sym; Fractional occupation with symmetry. tdscf-7; TD-HF test variable access. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dft1-alt; DFT Functional Test. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). scf-upcast-custom-basis; test scf castup with custom basis sets. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, compute",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:22137,access,access,22137,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['access'],['access']
Security,"m output; files. Extends the dictionary object to (1) store key as all-caps; version of itself and (2) validate value for duplicate values for the; same key by testing which has more decimal places and whether value; the same within a plausing rounding error. Allows consistency checks; when parsing output files without loss of precision. """""". def __init__(self, *args, **kwargs):; self.update(*args, **kwargs). def __setitem__(self, key, value):; try:; key = key.upper(); except AttributeError:; raise AttributeError('Keys stored as upper-case strings: %s unsuitable' % (key)); value = Decimal(value); if key in self.keys() and not 'CURRENT' in key:; # Validate choosing more detailed value for variable; existing_exp = self[key].as_tuple().exponent # 0.1111 --> -4; candidate_exp = value.as_tuple().exponent; if existing_exp > candidate_exp: # candidate has more digits; places = Decimal(10) ** (existing_exp + 1) # exp+1 permits slack in rounding; best_value = value; else: # existing has more digits; places = Decimal(10) ** (candidate_exp + 1); best_value = self[key]; # Validate values are the same; places = max(places, Decimal('1E-11')) # for computed psivars; #print('FLOOR: ', self[key].quantize(places, rounding=ROUND_FLOOR) - value.quantize(places, rounding=ROUND_FLOOR)); #print('CEIL: ', self[key].quantize(places, rounding=ROUND_CEILING) - value.quantize(places, rounding=ROUND_CEILING)); if (self[key].quantize(places, rounding=ROUND_CEILING).compare(value.quantize(places, rounding=ROUND_CEILING)) != 0) and \; (self[key].quantize(places, rounding=ROUND_FLOOR).compare(value.quantize(places, rounding=ROUND_FLOOR)) != 0):; raise ParsingValidationError(; """"""Output file yielded both %s and %s as values for quantity %s."""""" %; (self[key].to_eng_string(), value.to_eng_string(), key)); #print 'Resetting variable %s to %s' % (key, best_value.to_eng_string()); else:; best_value = value; #print 'Setting variable %s to %s' % (key, best_value.to_eng_string()); super(PreservingDict, self",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:2306,Validat,Validate,2306,psi4manual/1.0.0/_modules/qcdb/pdict.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html,1,['Validat'],['Validate']
Security,"m().to_tuple(); ret[prefix + ""Dim2""] = self.coldim().to_tuple(); if isinstance(self, core.Vector):; ret[prefix + ""Dim""] = [self.dim(x) for x in range(self.nirrep())]. if filename is None:; return ret. np.savez(filename, **ret). def _np_read(; self: Union[core.Matrix, core.Vector],; filename: str,; prefix: str = """",; ) -> Union[core.Matrix, core.Vector]:; """"""Reads the data from a NumPy compressed or uncompressed file using :func:`numpy.load`. Parameters; ----------; self; Pointer to which class to be constructed.; filename; File name to read.; prefix; Name under which array was saved for NumPy.; """""". if isinstance(filename, np.lib.npyio.NpzFile):; data = filename; elif isinstance(filename, str):; if not filename.endswith('.npz'):; filename = filename + '.npz'. data = np.load(filename); else:; raise Exception(""Filename not understood: %s"" % filename). ret_data = []. if ((prefix + ""Irreps"") not in data.keys()) or ((prefix + ""Name"") not in data.keys()):; raise ValidationError(""File %s does not appear to be a numpyz save"" % filename). for h in range(data[prefix + ""Irreps""]):; ret_data.append(data[prefix + ""IrrepData"" + str(h)]). arr_type = self.__mro__[0]; if arr_type == core.Matrix:; dim1 = core.Dimension.from_list(data[prefix + ""Dim1""]); dim2 = core.Dimension.from_list(data[prefix + ""Dim2""]); ret = self(str(data[prefix + ""Name""]), dim1, dim2); elif arr_type == core.Vector:; dim1 = core.Dimension.from_list(data[prefix + ""Dim""]); ret = self(str(data[prefix + ""Name""]), dim1). for h in range(data[prefix + ""Irreps""]):; ret.nph[h][:] = ret_data[h]. return ret. def _to_serial(self: Union[core.Matrix, core.Vector]) -> Dict[str, Any]:; """"""; Converts an object with a ``.nph`` accessor to a serialized dictionary. Parameters; ----------; self; Matrix or Vector instance. Returns; -------; ~typing.Dict[str, ~typing.Any]; Serialized dictionary with keys:. - shape; - data : List[str]; - type : {'matrix', 'vector'}. """"""; json_data = {}; json_data[""shape""] = []; json_data[""data""] = []. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html:11176,Validat,ValidationError,11176,psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,2,['Validat'],['ValidationError']
Security,"m. Bohr = psi4.GeometryUnits.Bohr. names = {‘Angstrom’: psi4.GeometryUnits.Angstrom, ‘Bohr’: psi4.Geometr... values = {0: psi4.GeometryUnits.Angstrom, 1: psi4.GeometryUnits.Bohr}. ———————————————————————-. Methods inherited from Boost.Python.enum:. __repr__(...). x.__repr__() <==> repr(x). __str__(...). x.__str__() <==> str(x). ———————————————————————-. Data descriptors inherited from Boost.Python.enum:. name. ———————————————————————-. Methods inherited from __builtin__.int:. __abs__(...). x.__abs__() <==> abs(x). __add__(...). x.__add__(y) <==> x+y. __and__(...). x.__and__(y) <==> x&y. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __coerce__(...). x.__coerce__(y) <==> coerce(x, y). __div__(...). x.__div__(y) <==> x/y. __divmod__(...). x.__divmod__(y) <==> divmod(x, y). __float__(...). x.__float__() <==> float(x). __floordiv__(...). x.__floordiv__(y) <==> x//y. __format__(...). __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getnewargs__(...). __hash__(...). x.__hash__() <==> hash(x). __hex__(...). x.__hex__() <==> hex(x). __index__(...). x[y:z] <==> x[y.__index__():z.__index__()]. __int__(...). x.__int__() <==> int(x). __invert__(...). x.__invert__() <==> ~x. __long__(...). x.__long__() <==> long(x). __lshift__(...). x.__lshift__(y) <==> x<<y. __mod__(...). x.__mod__(y) <==> x%y. __mul__(...). x.__mul__(y) <==> x*y. __neg__(...). x.__neg__() <==> -x. __nonzero__(...). x.__nonzero__() <==> x != 0. __oct__(...). x.__oct__() <==> oct(x). __or__(...). x.__or__(y) <==> x|y. __pos__(...). x.__pos__() <==> +x. __pow__(...). x.__pow__(y[, z]) <==> pow(x, y[, z]). __radd__(...). x.__radd__(y) <==> y+x. __rand__(...). x.__rand__(y) <==> y&x. __rdiv__(...). x.__rdiv__(y) <==> y/x. __rdivmod__(...). x.__rdivmod__(y) <==> divmod(y, x). __rfloordiv__(...). x.__rfloordiv__(y) <==> y//x. __rlshift__(...). x.__rlshift__(y) <==> y<<x. __rmod__(...). x.__rmod__(y) <==> y%x. __rmul__(...). x.__rmul__(y) <==> y*x. __ror__(...). x.__ror__(y) <==> y|x. __rpow__(...). y.__rpo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:153297,hash,hash,153297,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['hash'],['hash']
Security,"m1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); view = _get_raw_views(ret)[0]; view[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError (""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def _to_array(matrix, copy=True, dense=False):; """"""; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters; ----------; matrix : :py:class:`~psi4.core.Matrix` or :py:class:`~psi4.core.Vector`; Pointers to which Psi4 core class should be used in the construction.; copy : bool; Copy the data if True, return a view otherwise; dense : bool; Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns; -------; array : np.array or list of of np.array; Returns either a list of np.array's or the base array depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:6102,Validat,ValidationError,6102,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"m` symbol, possibly conveying ghosting, isotope, mass, tagging information.; tooclose; Interatom distance (native `geom` units) nearer than which atoms not allowed.; nonphysical; Do allow masses outside an element's natural range to pass validation?; speclabel; If `True`, interpret `elbl` as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., `@13C_mine` or; `He4@4.01`. If `False`, interpret `elbl` as only the user/tagging; extension to nucleus label, e.g. `_mine` or `4` in the previous examples.; missing_enabled_return; {'minimal', 'none', 'error'}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out; When `True`, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use `False` to get a json-able version. Returns; -------; molrec : dict; Molecule dictionary spec follows. Its principles are. (1) contents are fully validated and defaulted - no error; checking necessary,. (2) contents may be mildly redundant - atomic numbers and; element symbols present,. (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,. (4) some fields are optional (e.g., fix_symmetry) but largely; self-describing so units or fix_com must be present. (5) apart from some mild optional fields, _all_ fields will; be present (corollary of ""fully validated and defaulted"") - no; need to check for every key. in some cases like efp, keys will; appear in blocks, so pre-handshake there will be a few hint keys; and post-handshake they will be joined by full qm-like molrec. (6) molrec should be idempotent through this function (equiv to; schema validator) but are not idempotent throughout its life. if; fields permit, frame may be changed. Future? if fields permit,; mol may be symmetrized. Coordinates and angles may change units; or range if program returns them in only one form. name : str, optional; Label ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:5448,validat,validated,5448,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['validat'],['validated']
Security,"maller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Fitted 2-point parameter. Overrides the default :math:`\alpha = 1.63`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [1]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63`. References; ----------. .. [1] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DT]Z', scf_scheme='scf_xtpl_helgaker_2'). """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 1.63. beta_division = 1 / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); beta_mult = math.exp(-1 * alpha * zHI). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:4689,Validat,ValidationError,4689,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,4,['Validat'],['ValidationError']
Security,"mbersonly=False):; """"""Prints a detailed PSI3-style summary of the basis (per-atom); * @param out The file stream to use for printing. Defaults to outfile. """"""; text = ''; if not numbersonly:; text += self.print_summary(out=None); text += """""" ==> AO Basis Functions <==\n""""""; text += '\n'; text += """""" [ %s ]\n"""""" % (self.name); text += """""" spherical\n"""""" if self.has_puream() else """""" cartesian\n""""""; text += """""" ****\n"""""". for uA in range(self.molecule.nunique()):; A = self.molecule.unique(uA); if not numbersonly:; text += """""" %2s %3d\n"""""" % (self.molecule.symbol(A), A + 1); first_shell = self.center_to_shell[A]; n_shell = self.center_to_nshell[A]. for Q in range(n_shell):; text += self.shells[Q + first_shell].pyprint(outfile=None); text += """""" ****\n""""""; text += """"""\n"""""". if out is None:; return text; else:; with open(out, mode='w') as handle:; handle.write(text). [docs] def export_for_libmints(self, role):; """"""From complete BasisSet object, returns array where; triplets of elements are each unique atom label, the hash; of the string shells entry in gbs format and the; shells entry in gbs format for that label. This packaging is; intended for return to libmints BasisSet::pyconstruct for; instantiation of a libmints BasisSet clone of *self*. """"""; basstrings = []; tally = []; for A in range(self.molecule.natom()):; if self.molecule.label(A) not in tally:; label = self.molecule.label(A); first_shell = self.center_to_shell[A]; n_shell = self.center_to_nshell[A]. basstrings.append(label); basstrings.append(self.molecule.atoms[A].shell(key=role)); text = """""" %s 0\n"""""" % (label); for Q in range(n_shell):; text += self.shells[Q + first_shell].pyprint(outfile=None); text += """""" ****\n""""""; basstrings.append(text). return basstrings. [docs] def print_detail_gamess(self, out=None, numbersonly=False):; """"""Prints a detailed PSI3-style summary of the basis (per-atom); * @param out The file stream to use for printing. Defaults to outfile. """"""; text = ''; if not numbersonly:; text += ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:34855,hash,hash,34855,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['hash'],['hash']
Security,"me + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" %; (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.PYinput_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.PYinput_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. def save_string_xyz(self, save_ghosts=True, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:12019,Validat,ValidationError,12019,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"me + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)); except IndexError:; raise ValidationError(""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. [docs] def save_string_xyz(self, save_ghosts=True",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:9321,Validat,ValidationError,9321,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"me == 'c4-mp3':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'MP3'. elif lowername == 'c4-mp4(sdq)':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'SDQ-MP4'. elif lowername == 'c4-mp4':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'MP4'. elif lowername == 'c4-cc2':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CC2'. elif lowername == 'c4-ccsd':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CCSD'; options['CFOUR']['CFOUR_CC_PROGRAM']['value'] = 'ECC'. elif lowername == 'c4-cc3':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CC3'. elif lowername == 'c4-ccsd(t)':; # Can't use (T) b/c bug in xsymcor lops it off; #options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CCSD(T)'; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CCSD[T]'; options['CFOUR']['CFOUR_CC_PROGRAM']['value'] = 'ECC'. elif lowername == 'c4-ccsdt':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CCSDT'; options['CFOUR']['CFOUR_CC_PROGRAM']['value'] = 'ECC'. else:; raise ValidationError(""""""Requested Cfour computational methods %d is not available."""""" % (lowername)). # Set clobbering; if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options. [docs]def cfour_list():; """"""Return an array of Cfour methods with energies. Appended; to procedures['energy']. """"""; val = []; val.append('cfour'); val.append('c4-scf'); val.append('c4-mp2'); val.append('c4-mp3'); val.append('c4-mp4(sdq)'); val.append('c4-mp4'); val.append('c4-cc2'); val.append('c4-ccsd'); val.append('c4-cc3'); val.append('c4-ccsd(t)'); val.append('c4-ccsdt'); return val. [docs]def cfour_gradient_list():; """"""Return an array of Cfour methods with ana",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:32303,Validat,ValidationError,32303,psi4manual/1.0.0/_modules/qcdb/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html,1,['Validat'],['ValidationError']
Security,"me == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'). if core.get_global_option('SCF_TYPE') not in ['CD', 'DISK_DF']:; raise ValidationError(""""""Invalid scf_type for DFCC.""""""). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). fnocc_wfn = core.fnocc(ref_wfn). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); level = kwargs.get('level', 0). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:120654,Validat,ValidationError,120654,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"me == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'). if core.get_global_option('SCF_TYPE') not in ['CD', 'DISK_DF']:; raise ValidationError(""""""Invalid scf_type for DFCC.""""""). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:154376,Validat,ValidationError,154376,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"me""] = item.get(""scheme"", _get_default_xtpl(len(stage[""basis""][1]), stage[""treatment""])); if len(metadata) > 0:; stage[""wfn_lo""] = item.get(""wfn_lo"", metadata[-1].get(""wfn"")).lower(); stage[""basis_lo""] = _expand_bracketed_basis(item.get(""basis_lo"", item[""basis""]).lower(), molecule); if len(stage[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({0:d}) and low ({1:d}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); metadata.append(stage); return (metadata). def _process_cbs_kwargs(kwargs):; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs : dict; kwargs containing the CBS function specification. Returns; -------; list; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); # either both *_wfn and *_basis have to be specified; if ""{:s}_wfn"".format(sn) in kwargs and ""{:s}_basis"".format(sn) in kwargs:; stage = {""wfn"": kwargs[""{:s}_wfn"".format(sn)], ""basis"": kwargs[""{:s}_basis"".format(sn)]}; # or we're at a scf stage which can be implied with a provided scf_basis; elif sn == ""scf"" and ""{:s}_basis"".fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:31747,validat,validation,31747,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['validat'],['validation']
Security,"me); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:100767,Validat,ValidationError,100767,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"me); self.dataSDF = unzipped.read(); unzipped.close(); try:; os.remove(file_name); except:; pass; print(""\tDone!""); break; # We didn't find a download location yet.; if attempt == 0:; # If this is the first try, take a ticket; ticket = extract_xml_keyval(xml, 'PCT-Waiting_reqid'); #print(""ticket = "" + ticket); statusrequest = """"""<PCT-Data>; <PCT-Data_input>; <PCT-InputData>; <PCT-InputData_request>; <PCT-Request>; <PCT-Request_reqid>%d</PCT-Request_reqid>; <PCT-Request_type value=""status""/>; </PCT-Request>; </PCT-InputData_request>; </PCT-InputData>; </PCT-Data_input>; </PCT-Data>; """""" % int(ticket); if ticket:; # Wait 10 seconds...; print(""\tPubChem result not available yet, will try again in 10 seconds...""); time.sleep(10); # ...and ask for an update on the progress; server_response = urlopen(url, statusrequest).read(); xml = ET.fromstring(server_response); #print(server_response); else:; # We can't find a ticket number, or a download location. Bail.; raise ValidationError(""""""PubChem: download error""""""); return self.dataSDF. [docs] def name(self):; """"""Function to return the IUPAC name of the PubChem object.""""""; return self.iupac. [docs] def getCartesian(self):; """"""Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. """"""; try:; sdfText = self.getSDF(); except Exception as e:; raise e. # Find; # NA NB CONSTANT; # 14 13 0 0 0 0 0 0 0999 V2000; m = re.search(r'^\s*(\d+)\s+(?:\d+\s+){8}V2000$', sdfText, re.MULTILINE); self.natom = 0; if (m):; self.natom = int(m.group(1)). if self.natom == 0:; raise ValidationError(""PubChem: Cannot find the number of atoms. 3D data doesn't appear\n"" +; ""to be available for %s.\n"" % self.iupac). lines = re.split('\n', sdfText). # 3.7320 -0.2500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0; NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; atom_re = re.compile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*(\w+)(?:\s+\d+){12}'). molecule_string = ""Pubchem",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:5323,Validat,ValidationError,5323,psi4manual/1.0.0/_modules/pubchem.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html,1,['Validat'],['ValidationError']
Security,"me* and derivative level *dertype*; into options for orca. While deliberately requested pieces,; generally orca__orca_deriv_level and orca__orca_calc_level,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, can be countermanded by keywords in input file; ('clobber' set to False). Occasionally, we want these pieces to actually; overcome keywords in input file ('superclobber' set to True).; """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; options['ORCA']['ORCA_RUNTYP']['value'] = 'ENERGY'; elif dertype == 1:; options['ORCA']['ORCA_RUNTYP']['value'] = 'ENGRAD'; else:; raise ValidationError(""Requested Orca dertype {} is not available.""; .format(dertype)). if lowername == 'orca':; pass; elif lowername == 'orca-b3lyp':; options['ORCA']['ORCA_FUNCTIONAL']['value'] = 'B3LYP_G'; elif lowername == 'orca-mp2':; options['ORCA']['ORCA_CALC_LEVEL']['value'] = 'MP2'; elif lowername == 'orca-ccsd':; options['ORCA']['ORCA_CALC_LEVEL']['value'] = 'CCSD'; elif lowername == 'orca-ccsd(t)':; options['ORCA']['ORCA_CALC_LEVEL']['value'] = 'CCSD(T)'; else:; raise ValidationError(""Requested Orca computational methods {} is not ""; ""available."" .format(lowername)). # Set clobbering; if 'ORCA_RUNTYP' in options['ORCA']:; options['ORCA']['ORCA_RUNTYP']['clobber'] = True; options['ORCA']['ORCA_RUNTYP']['superclobber'] = True; if 'ORCA_FUNCTIONAL' in options['ORCA']:; options['ORCA']['ORCA_FUNCTIONAL']['clobber'] = True; options['ORCA']['ORCA_FUNCTIONAL']['superclobber'] = True. return text, options. [docs]def orca_list():; """"""Return an array of Orca methods with energies. Appended; to procedures['energy']. """"""; val = []; val.append('orca'); val.append('orca-b3lyp'); return val. [docs]def orca_gradient_list():; """"""Return an array of Orca methods with analytical gradients.; Appended to procedures['gradient']. """"""; val = []; val.append('oc-b3lyp'); return val. [docs]def harvest_molecule_from_outfi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:2622,Validat,ValidationError,2622,psi4manual/1.0.0/_modules/qcdb/orca.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html,1,['Validat'],['ValidationError']
Security,"me.upper())); psi4.print_out(' -------------------------\n'); psi4.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); psi4.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); psi4.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)). optstash.restore(); return scf_wfn. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name.upper()). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). wfn = run_scf_gradient(name, **kwargs). optstash.restore(); return wfn. [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if psi4.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; psi4.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; psi4.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; psi4.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; psi4.set_local_opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:72888,Validat,ValidationError,72888,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"me.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Karton 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_Karton_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_helgaker_3(functionname: str, zLO: int, valueLO: Extrapolatable, zMD: int, valueMD: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 3-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 3-point; extrapolation.; zMD; Zeta number of the medium basis set in 3-point extrapolation.; Must be `zLO + 1`.; valueMD; Energy, gradient, or Hessian value at the medium basis set in 3-point; extrapolation.; zHI; Zeta number of the larger basis set in 3-point extrapolation.; Must be `zLO + 2`.; valueHI; Energy, gradient, or Hessian value at the larger",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:13237,Validat,ValidationError,13237,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,3,['Validat'],['ValidationError']
Security,"me.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Karton 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_Karton_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_helgaker_3(functionname: str, zLO: int, valueLO: Extrapolatable, zMD: int, valueMD: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 3-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 3-point; extrapolation.; zMD; Zeta number of the medium basis set in 3-point extrapolation.; Must be `zLO + 1`.; valueMD; Energy, gradient, or Hessian value at the medium basis set in 3-point; extrapolation.; zHI; Zeta number of the larger basis set in 3-point extrapolation.; Must be `zLO + 2`.; valueHI; Energy, gradient, or Hessian value at the larger basis se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:13171,Validat,ValidationError,13171,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Validat'],['ValidationError']
Security,"me.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Karton 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_Karton_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_helgaker_3(functionname: str, zLO: int, valueLO: Extrapolatable, zMD: int, valueMD: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 3-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 3-point; extrapolation.; zMD; Zeta number of the medium basis set in 3-point extrapolation.; Must be `zLO + 1`.; valueMD; Energy, gradient, or Hessian value at the medium basis set in 3-point; extrapolation.; zHI; Zeta number of the larger basis set in 3-point extrapolation.; Must be `zLO + 2`.; valueHI; Energy, gradient, or Hessian value at the larger b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:13227,Validat,ValidationError,13227,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Validat'],['ValidationError']
Security,"me__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec banners. try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: (*float*) Total electronic energy in Hartrees. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further pro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:29329,Validat,ValidationError,29329,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"me_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zMD].upper(),; zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; valueLO = np.array(valueLO); valueMD = np.array(valueMD); valueHI = np.array(valueHI). nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. # Build and set from numpy routines; value = core.Matrix(*valueHI.shape); value_view = np.asarray(value); value_view[:] = np_value; return value. else:; raise ValidationError(""scf_xtpl_helgaker_3: datatype is not recognized '%s'."" % type(valueLO)). #def corl_xtpl_helgaker_2(functionname, valueSCF, zLO, valueLO, zHI, valueHI, verbose=True):; [docs]def corl_xtpl_helgaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`.; Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson, Chem. Phys. Lett. 286 (1998) 243-252. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; if type(valueLO) != type(valueHI):; raise ValidationError(""corl_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). if isinstance(valueLO, float):; value = (valueHI * zHI ** 3 - valueLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (valueHI - valueLO) / (zHI ** (-3) - zLO ** (-3)). # final = valueSCF + value; final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = """"""\n\n ==> Helgaker 2-point co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:10003,Validat,ValidationError,10003,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"me_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zMD].upper(),; zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; valueLO = np.array(valueLO); valueMD = np.array(valueMD); valueHI = np.array(valueHI). nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. # Build and set from numpy routines; value = core.Matrix(*valueHI.shape); value_view = np.asarray(value); value_view[:] = np_value; return value. else:; raise ValidationError(""scf_xtpl_helgaker_3: datatype is not recognized '%s'."" % type(valueLO)). #def corl_xtpl_helgaker_2(functionname, valueSCF, zLO, valueLO, zHI, valueHI, verbose=True):; [docs]def corl_xtpl_helgaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname : str; Name of the CBS component.; zLO : int; Lower zeta level.; valueLO : float; Lower value used for extrapolation.; zHI : int; Higher zeta level. Should be equal to zLO + 1.; valueHI : float; Higher value used for extrapolation.; alpha : float, optional; Overrides the default :math:`\alpha = 3.0`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [5]_:; :math:`E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}`. References; ----------. .. [5] Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilso",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:19355,Validat,ValidationError,19355,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"me_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zMD].upper(),; zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; valueLO = np.array(valueLO); valueMD = np.array(valueMD); valueHI = np.array(valueHI). nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. # Build and set from numpy routines; value = core.Matrix(*valueHI.shape); value_view = np.asarray(value); value_view[:] = np_value; return value. else:; raise ValidationError(""scf_xtpl_helgaker_3: datatype is not recognized '%s'."" % type(valueLO)). #def corl_xtpl_helgaker_2(functionname, valueSCF, zLO, valueLO, zHI, valueHI, verbose=True):; [docs]def corl_xtpl_helgaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`.; Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson, Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}. """"""; if type(valueLO) != type(valueHI):; raise ValidationError(""corl_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 3.0. if isinstance(valueLO, float):; value = (valueHI * zHI ** alpha - valueLO * zLO ** alpha) / (zHI ** alpha - zLO ** alpha); beta = (valueHI - valueLO) / (zHI ** (-alpha) - zLO ** (-alpha)). # final = valueSCF + value; final = v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:16201,Validat,ValidationError,16201,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"me_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zMD].upper(),; zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; psi4.print_out(cbsscheme). return value. elif isinstance(valueLO, (psi4.Matrix, psi4.Vector)):; valueLO = np.array(valueLO); valueMD = np.array(valueMD); valueHI = np.array(valueHI). nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. # Build and set from numpy routines; value = psi4.Matrix(*valueHI.shape); value_view = np.asarray(value); value_view[:] = np_value; return value. else:; raise ValidationError(""scf_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). #def corl_xtpl_helgaker_2(functionname, valueSCF, zLO, valueLO, zHI, valueHI, verbose=True):; [docs]def corl_xtpl_helgaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~driver_cbs.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; if type(valueLO) != type(valueHI):; raise ValidationError(""corl_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). if isinstance(valueLO, float):; value = (valueHI * zHI ** 3 - valueLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (valueHI - valueLO) / (zHI ** (-3) - zLO ** (-3)). # final = valueSCF + value; final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = """"""\n\n ==> Helgaker 2-point correlated extrapolation for method: %s <==\n\n"""""" % (functionname.upper()); # cbs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:9659,Validat,ValidationError,9659,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"mediates_gradient; ntasks; when driver is g/h; all individual gradients.   1_((1, 2), (1, 2));   (nat, 3); when driver is g/h; total gradient for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat, 3); when driver is g/h; total gradient for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_hessian; ntasks; when driver is h; all individual Hessians.   1_((1, 2), (1, 2));   (nat*3, nat*3); when driver is h; total Hessian for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat*3, nat*3); when driver is h; total Hessian for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. validator set_bsse_type  »  bsse_type[source]¶. validator set_embedding_charges  »  embedding_charges[source]¶. validator set_max_nbody  »  max_nbody[source]¶. validator set_molecule  »  molecule[source]¶. validator set_nfragments  »  nfragments[source]¶. validator set_return_total_data  »  return_total_data[source]¶. table of contents. Basis Set Superposition Corrections; nbody(); API; BsseEnum; BsseEnum.cp; BsseEnum.nocp; BsseEnum.vmfc. ManyBodyComputer; ManyBodyComputer.basis; ManyBodyComputer.bsse_type; ManyBodyComputer.driver; ManyBodyComputer.embedding_charges; ManyBodyComputer.keywords; ManyBodyComputer.max_nbody; ManyBodyComputer.method; ManyBodyComputer.molecule; ManyBodyComputer.nbodies_per_mc_level; ManyBodyComputer.nfragments; ManyBodyComputer.quiet; ManyBodyComputer.return_total_data; ManyBodyComputer.task_list; ManyBodyComputer.build_tasks(); ManyBodyComputer.compute(); ManyBodyComputer.get_psi_results(); ManyBodyComputer.get_results(); ManyBodyComputer.plan(); ManyBodyComputer.prepare_results(); ManyBodyComputer.set_bsse_type; ManyBodyComputer.set_embedding_charges; ManyBodyComputer.set_max_nbody; ManyBodyComputer.set_molecule; ManyBodyComputer.set_nfragments; ManyBodyComputer.set_return_total_data. «; hide menu. menu; sidebar; »; . Navigation. Index. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/nbody.html:35214,validat,validator,35214,psi4manual/master/nbody.html,https://psicode.org,https://psicode.org/psi4manual/master/nbody.html,3,['validat'],['validator']
Security,"mension.from_list(data[prefix + ""Dim1""]); dim2 = core.Dimension.from_list(data[prefix + ""Dim2""]); ret = self(str(data[prefix + ""Name""]), dim1, dim2); elif arr_type == core.Vector:; dim1 = core.Dimension.from_list(data[prefix + ""Dim""]); ret = self(str(data[prefix + ""Name""]), dim1). for h in range(data[prefix + ""Irreps""]):; ret.nph[h][:] = ret_data[h]. return ret. def _to_serial(self: Union[core.Matrix, core.Vector]) -> Dict[str, Any]:; """"""; Converts an object with a ``.nph`` accessor to a serialized dictionary. Parameters; ----------; self; Matrix or Vector instance. Returns; -------; ~typing.Dict[str, ~typing.Any]; Serialized dictionary with keys:. - shape; - data : List[str]; - type : {'matrix', 'vector'}. """"""; json_data = {}; json_data[""shape""] = []; json_data[""data""] = []. for view in self.nph:; json_data[""shape""].append(view.shape); json_data[""data""].append(view.tostring()). if len(json_data[""shape""][0]) == 1:; json_data[""type""] = ""vector""; elif len(json_data[""shape""][0]) == 2:; json_data[""type""] = ""matrix""; else:; raise ValidationError(""_to_json is only used for vector and matrix objects.""). return json_data. def _from_serial(self, json_data: Dict[str, Any]) -> Union[core.Matrix, core.Vector]:; """"""; Converts serialized data to the correct Psi4 data type. Parameters; ----------; self; Pointer to which class to be constructed.; json_data; Serialization of class. See :meth:`to_serial` for data layout. """""". if json_data[""type""] == ""vector"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); ret = self(""Vector from JSON"", dim1); elif json_data[""type""] == ""matrix"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); dim2 = core.Dimension.from_list([x[1] for x in json_data[""shape""]]); ret = self(""Matrix from JSON"", dim1, dim2); else:; raise ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.frombuffer(json_data[""data""][n], dtype=np.doubl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:12466,Validat,ValidationError,12466,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,4,['Validat'],['ValidationError']
Security,"ment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:4432,Validat,ValidationError,4432,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"ment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1). # Now go through the rest of the lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; for line in glines:. # handle fragment markers; if frag.match(line):; ifrag += 1; self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); tempfrag = []. # handle atom markers; elif atom.match(line):; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomLabel = entries[0]. # handle ghost atoms; ghostAtom = False; if ghost.match(atomLabel):; # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; atomLabel = ghost.match(atomLabel).group(2) if not ghost.match(atomLabel).group(1) \; else ghost.match(atomLabel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:16662,Validat,ValidationError,16662,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,2,['Validat'],['ValidationError']
Security,"ments for extrapolation functions by; extracting zetas and values (which one determined by *datakey*) out; of *needdict* and returning a dictionary whose keys are contructed; from _lmh_labels. """"""; largs = {}; largs['functionname'] = needdict['HI']['f_wfn']; Nxtpl = len(needdict); zlabels = _lmh_labels[Nxtpl] # e.g., ['LO', 'HI']. for zeta in range(Nxtpl):; zlab = zlabels[zeta] # e.g., LO; largs['z' + zlab] = needdict[zlab]['f_zeta']; largs['value' + zlab] = needdict[zlab][datakey]. return largs. ## Aliases ##; cbs = complete_basis_set. def _cbs_wrapper_methods(**kwargs):; cbs_method_kwargs = ['scf_wfn', 'corl_wfn', 'delta_wfn']; cbs_method_kwargs += ['delta%d_wfn' % x for x in range(2, 6)]. cbs_methods = []; for method in cbs_method_kwargs:; if method in kwargs:; cbs_methods.append(kwargs[method]); return cbs_methods. def _parse_cbs_gufunc_string(method_name):; method_name_list = re.split( """"""\+(?![^\[\]]*\]|[^\(\)]*\))"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(); user_d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:56428,Validat,ValidationError,56428,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"ments for extrapolation functions by; extracting zetas and values (which one determined by *datakey*) out; of *needdict* and returning a dictionary whose keys are contructed; from _lmh_labels. """"""; largs = {}; largs['functionname'] = needdict['HI']['f_wfn']; Nxtpl = len(needdict); zlabels = _lmh_labels[Nxtpl] # e.g., ['LO', 'HI']. for zeta in range(Nxtpl):; zlab = zlabels[zeta] # e.g., LO; largs['z' + zlab] = needdict[zlab]['f_zeta']; largs['value' + zlab] = needdict[zlab][datakey]. return largs. ## Aliases ##; complete_basis_set = cbs. def _cbs_wrapper_methods(**kwargs):; cbs_method_kwargs = ['scf_wfn', 'corl_wfn', 'delta_wfn']; cbs_method_kwargs += ['delta%d_wfn' % x for x in range(2, 6)]. cbs_methods = []; for method in cbs_method_kwargs:; if method in kwargs:; cbs_methods.append(kwargs[method]); return cbs_methods. def _parse_cbs_gufunc_string(method_name):; method_name_list = re.split( """"""\+(?![^\[\]]*\]|[^\(\)]*\))"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:56838,Validat,ValidationError,56838,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"ments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:21125,Validat,ValidationError,21125,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,2,['Validat'],['ValidationError']
Security,"merA,wfn_monomerB). molecule.reset_point_group(user_pg); molecule.update_geometry(). PsiMod.set_global_option('DF_INTS_IO', df_ints_io). optstash.restore(); return e_sapt. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; PsiMod.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (PsiMod.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'dimer', 'monomerA'); PsiMod.IO.set_default_namespace('monomerA'); PsiMod.set_local_option('SCF',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:58303,Validat,ValidationError,58303,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"meters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 6.3`. Returns; -------; float or ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [3]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3`. References; ----------. .. [3] Karton, Martin, Theor. Chem. Acc. 115 (2006) 330-333,; DOI: 10.1007/s00214-005-0028-6. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_karton_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 6.30. # prior to April 2022, this wrong expression was used; # beta_division = 1 / (math.exp(-1 * alpha) * (math.exp(math.sqrt(zHI)) - math.exp(math.sqrt(zLO)))); beta_division = 1 / (math.exp(-1 * alpha * math.sqrt(zHI)) - math.exp(-1 * alpha * math.sqrt(zLO))); beta_mult = math.exp(-1 * alpha * math.sqrt(zHI)). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Karton 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:11118,Validat,ValidationError,11118,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Validat'],['ValidationError']
Security,"mething special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). return psi4.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf(name, **kwargs); returnvalue = psi4.get_variable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; psi4.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); psi4.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('MP2 CORRELATION ENERGY'). psi4.set_v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:38176,Validat,ValidationError,38176,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"method and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype is not None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; stage['scheme'] = kwargs.pop('scf_scheme'); stage['stage'] = ""scf""; stage['treatment'] = ""scf""; else:; # _validate_cbs_inputs will produce scf stage automatically; stage = {}; stage['wfn'] = method_list[0]; stage['basis']",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:40920,Validat,ValidationError,40920,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"mily object. add_rifit(fit)[source]¶; Function to add basis fit as associated fitting basis; member rifit to a BasisFamily object. name()[source]¶; Function to return the ornate name of the orbital basis,; e.g., 6-311++G** for 6-311ppgss. corresponding_dualfit(name)[source]¶; Function to return an appropriate DUAL helper basis for; the orbital basis name in coded or ornate form. None; is returned if no fitting basis is defined or if the; orbital basis is not found. corresponding_jfit(name)[source]¶; Function to return an appropriate J fitting basis for; the orbital basis name in coded or ornate form. None; is returned if no fitting basis is defined or if the; orbital basis is not found. corresponding_jkfit(name)[source]¶; Function to return an appropriate JK fitting basis for; the orbital basis name in coded or ornate form. None; is returned if no fitting basis is defined or if the; orbital basis is not found. corresponding_orbital(name)[source]¶; Function to validate if the orbital basis name in coded or; ornate form is in Psi4’s standard installed bases list. None; is returned if the orbital basis is not found. corresponding_rifit(name)[source]¶; Function to return an appropriate RI fitting basis for; the orbital basis name in coded or ornate form. None; is returned if no fitting basis is defined or if the; orbital basis is not found. load_basis_families()[source]¶; Function to load into the array basisfamily_list; BasisFamily objects for all Psi4’s standard installed bases. print_basis_families()[source]¶; Function to print to the output file a formatted summary; of all the BasisFamily objects in basisfamily_list, by; default all Psi4’s standard installed bases. sanitize_basisname(name)[source]¶; Function to return name in coded form, stripped of; characters that confuse filenames, characters into lowercase,; + into p, * into s, and (, ), & ,; into _. array_to_matrix¶; classmethod(function) -> method; Convert a function to be a class method.; A class method recei",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:144108,validat,validate,144108,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['validat'],['validate']
Security,"min + 0.3, 1.0, stats(np.array(mcdats[item])), fontsize=7, family='monospace', verticalalignment='center'); # ax_again.plot([0, 0], [0.9, 1.1], color='#cccc00', lw=2); # ax_again.set_frame_on(False); # ax_again.set_yticks([]); # ax_again.set_xticks([-12.0, -8.0, -4.0, -2.0, -1.0, 0.0, 1.0, 2.0, 4.0, 8.0, 12.0]); # ax_again.tick_params(axis='both', which='major', labelbottom='off', bottom='off'); # ax_again.set_xticks([-12.0, -8.0, -4.0, -2.0, -1.0, 0.0, 1.0, 2.0, 4.0, 8.0, 12.0]); # ax_again.tick_params(axis='both', which='major', labelbottom='on', bottom='off'); #; # plt.savefig('scratch/' + pltfile + '_trimd' + '.png', transparent=True, format='PNG'); # plt.savefig('scratch/' + pltfile + '_trimd' + '.pdf', transparent=True, format='PDF'); # plt.savefig('scratch/' + pltfile + '_trimd' + '.eps', transparent=True, format='EPS'). [docs]def valerr(data, color=None, title='', xtitle='', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". """"""; import hashlib; from itertools import cycle; import matplotlib.pyplot as plt. fig, ax = plt.subplots(figsize=(4, 6)); ax1 = fig.add_subplot(211); plt.axhline(0.0, axes=ax1, color='black'); ax1.set_ylabel('Reaction Energy'); plt.title(title). ax2 = plt.subplot(212, sharex=ax1); plt.axhline(0.0, axes=ax2, color='#cccc00'); ax2.set_ylabel('Energy Error'); ax2.set_xlabel(xtitle). xmin = 500.0; xmax = -500.0; vmin = 1.0; vmax = -1.0; emin = 1.0; emax = -1.0; linecycler = cycle(['-', '--', '-.', ':']); # plot reaction errors and threads; for trace, tracedata in data.iteritems():; vaxis = []; vmcdata = []; verror = []; for rxn in tracedata:; clr = segment_color(color, rxn['color'] if 'color' in rxn else None); xmin = min(xmin, rxn['axis']); xmax = max(xmax, rxn['axis']). ax1.plot(rxn['axis'], rxn['mcdata'], '^', color=clr, markersize=6.0, mew=0, zorder=10); vmcdata.append(rxn['mcdata']); vaxis.append(rxn['axis']); vmin = min(0, vmin, rxn['mcdata']); vmax = max(0, vmax, rxn['mcdata']). if rxn['bmdata'] is not None:; ax1.p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:8966,hash,hashlib,8966,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['hash'],['hashlib']
Security,"mization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, True). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:55647,Validat,ValidationError,55647,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"mize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(name, **kwargs); Function to compute various properties. property(name, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name, **kwargs); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(reference, ref_wfn); Builds the correct wavefunction from the provided information. set_memory(inputval[, execute]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dictionar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:199821,validat,validate,199821,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['validat'],['validate']
Security,"mode, basis, value, units='kcal/mol', citation=None, comment=None,; overwrite=False):; """"""Add a new quantum chemical value to *rxn* by creating a; qcdb.ReactionDatum from same arguments as that class's; object-less constructor. *rxn* may be actual Reaction.name; or Reaction.indx. """"""; if (self.dbse == dbse):; if rxn in self.hrxn:; rxnname = rxn # rxn is proper reaction name; else:; try:; if (rxn + 1 > 0) and (rxn == self.hrxn.items()[rxn - 1][1].indx):; rxnname = self.hrxn.items()[rxn - 1][1].name # rxn is reaction index (maybe dangerous?); except (TypeError, IndexError):; raise ValidationError(; """"""Inconsistent to add ReactionDatum for %s to database %s with reactions %s."""""" %; (dbse + '-' + str(rxn), self.dbse, self.hrxn.keys())); label = '-'.join([method, mode, basis]); if overwrite or (label not in self.hrxn[rxnname].data):; self.hrxn[rxnname].data[label] = ReactionDatum.library_modelchem(dbse=dbse, rxn=rxnname,; method=method, mode=mode, basis=basis,; value=value, units=units,; comment=comment, citation=citation); else:; raise ValidationError(""""""ReactionDatum %s already present in Database."""""" % (label)); else:; raise ValidationError(""""""Inconsistent to add ReactionDatum for %s to database %s."""""" %; (dbse + '-' + str(rxn), self.dbse)). [docs] def add_Subset(self, name, func):; """"""Define a new subset labeled *name* by providing a function; *func* that filters *self.hrxn*. """"""; sname = name.lower().split('\n'); label = sname.pop(0); tagl = sname[0].strip() if sname else None; try:; filtered = func(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in filtered]; except TypeError as e:; raise ValidationError(""""""Function %s did not return list: %s."""""" % (func.__name__, str(e))); if len(lsslist) == 0:; print(""""""WrappedDatabase %s: Subset %s NOT formed: empty"""""" % (self.dbse, label)); return. self.sset[label] = OrderedDict(); for rxn in lsslist:; self.sset[label][rxn] = self.hrxn[rxn]; self.oss[label] = Subset(name=label,; hrxn=self.sset[label].keys(),",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:30552,Validat,ValidationError,30552,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"mol: psi::Molecule) → None¶; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns; Returns either a list of np.array’s or the base array depending on options. Return type; numpy.ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix) → psi4.core.Matrix¶; Creates a new matrix that is the transpose of this matrix. transpose_this(self: psi4.core.Matrix) → None¶; Transpose the matrix in-place. static triplet(A, B, C, transA, transB, transC)¶; Multiply three matrices together. Deprecated since version 1.4: Use psi4.core.triplet() instead. vector_dot(self: psi4.core.Matrix, rhs: psi4.core.Matrix) → float¶; Returns the vector dot product of this with rhs. zero(self: psi4.core.Matrix) → None¶; Zero all elements of the matrix. zero_diagonal(self: psi4.core.Matrix) → None¶; Zero the diagonal of the matrix. zero_lowe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html:15462,access,accessor,15462,psi4manual/1.4.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html,3,['access'],['accessor']
Security,"molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print 'Performing finite difference calculations'. # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed ...' % (ndisp),; energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:23335,Validat,ValidationError,23335,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:25804,Validat,ValidationError,25804,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"mong states of their own symmetry. For example, to target the second excited-state, which is also the lowest energy state; of its irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much more strongly than; with the molecular system. Changing the number of roots sought, the symmetry; subspace or the symmetry apportionment of roots under which the computation is run,; or the excited state method are all likely to scramble root numberings. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/notes_c.html:2686,access,accessible,2686,psi4manual/1.6.x/notes_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html,1,['access'],['accessible']
Security,"most users will ever; need to access directly to perform frequency calculations. Behind; the scenes, frequency() is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. psi4.frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/freq-1.html:1490,access,accessed,1490,psi4manual/1.3.2/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/freq-1.html,2,['access'],['accessed']
Security,"most users will ever; need to access directly to perform frequency calculations. Behind; the scenes, frequency() is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. psi4.frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/freq-1.html:1488,access,accessed,1488,psi4manual/1.1.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/freq-1.html,4,['access'],['accessed']
Security,"move it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in ; :envvar:`PATH`. """"""; # Validate arguments; if self is None:; self = PsiMod.get_active_molecule(). dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][fu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:6907,Validat,Validate,6907,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,1,['Validat'],['Validate']
Security,"mple, setting; REFERENCE will appropriately set CFOUR_REFERENCE. For a; list of applicable keywords, see source of; muster_psi4options.; Consult Functionality for information on what Cfour; functionality is accessible through PSI4. PSI4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a PSI4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/psi4/share/psi4/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into PSI4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the PSI4 instance (as opposed to solely in files); is the only advantage thus far incurred by the P4C4 interface. We’ll call; this mode of basic utility the “sandwich” mode.; Molecule specification in PSI4 allows Cartesians, Z-matrices, mixed; Cartesian/Z-matrix, negation of variables, delayed specification of; variables, specification of fragments, etc., all in a whitespace-tolerant; format. See Molecule and Geometry Specification for details and; cfour/mints5 for examples. When a PSI4-style molecule is; supplied, its geometry is written to ZMAT in Cartesian form and the; CFOUR_COORDINATES=CARTESIAN, CFOUR_UNITS=ANGSTROM,; CFOUR_CHARGE, and CFOUR_MULTIPLICITY keywords are set; appropriately in the *CFOUR(...) directive. Warning; There exist molecules (e.g., allene) where the; inertial frame is no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cfour.html:3689,access,accessible,3689,psi4manual/master/cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/cfour.html,9,['access'],['accessible']
Security,"mport build_superfunctional_from_dictionary. def scf_set_reference_local(name, is_dft=False):; """"""; Figures out the correct SCF reference to set locally; """""". optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['SCF', 'REFERENCE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Alter reference name if needed; user_ref = core.get_option('SCF', 'REFERENCE'). sup = build_superfunctional_from_dictionary(functionals[name], 1, 1, True)[0]; if sup.needs_xc() or is_dft:; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationnError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop,; oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.basisset()); if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html:2398,Validat,Validations,2398,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,1,['Validat'],['Validations']
Security,"mpute(). optstash.restore(); return scf_wfn. [docs]def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; optstash = p4util.OptionsState(; ['WFN'],; ['DERTYPE'],; ['ONEPDM'],; ['PROPERTY'],; ['CCLAMBDA', 'R_CONVERGENCE'],; ['CCEOM', 'R_CONVERGENCE'],; ['CCEOM', 'E_CONVERGENCE']). oneel_properties = ['dipole', 'quadrupole']; twoel_properties = []; response_properties = ['polarizability', 'rotation', 'roa', 'roa_tensor']; excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs['properties']. for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); psi4.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); psi4.set_globa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:59827,Validat,ValidationError,59827,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"mputed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAG",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:29659,Validat,ValidationError,29659,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:4528,access,accessing,4528,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['access'],['accessing']
Security,"must be at least 1'.format(start)). return enabled. def _validate_soscf():; """"""Sanity-checks SOSCF control options. Raises; ------; ValidationError; If any of |scf__soscf|, |scf__soscf_start_convergence|,; |scf__soscf_min_iter|, |scf__soscf_max_iter| don't play well together. Returns; -------; bool; Whether SOSCF is enabled during scf. """"""; enabled = core.get_option('SCF', 'SOSCF'); if enabled:; start = core.get_option('SCF', 'SOSCF_START_CONVERGENCE'); if start < 0.0:; raise ValidationError('SCF SOSCF_START_CONVERGENCE ({}) must be positive'.format(start)). miniter = core.get_option('SCF', 'SOSCF_MIN_ITER'); if miniter < 1:; raise ValidationError('SCF SOSCF_MIN_ITER ({}) must be at least 1'.format(miniter)). maxiter = core.get_option('SCF', 'SOSCF_MAX_ITER'); if maxiter < miniter:; raise ValidationError(; 'SCF SOSCF_MAX_ITER ({}) must be at least SOSCF_MIN_ITER ({})'.format(maxiter, miniter)). conv = core.get_option('SCF', 'SOSCF_CONV'); if conv < 1.e-10:; raise ValidationError('SCF SOSCF_CONV ({}) must be achievable'.format(conv)). return enabled. def field_fn(xyz):; """"""Callback function for PylibEFP to compute electric field from electrons; in ab initio part for libefp polarization calculation. Parameters; ----------; xyz : list; (3 * npt, ) flat array of points at which to compute electric field. Returns; -------; list; (3 * npt, ) flat array of electric field at points in `xyz`. Notes; -----; Function signature defined by libefp, so function uses number of; basis functions and integrals factory `mints_psi4_yo` and total density; matrix `efp_Dt_psi4_yo` from global namespace. """"""; points = np.array(xyz).reshape(-1, 3); npt = len(points). # Cartesian basis one-electron EFP perturbation; nbf = mints_psi4_yo.basisset().nbf(); field_ints = np.zeros((3, nbf, nbf)). # Electric field at points; field = np.zeros((npt, 3)). for ipt in range(npt):; # get electric field integrals from Psi4; p4_field_ints = mints_psi4_yo.electric_field(origin=points[ipt]). field[ipt] = [np.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:26231,Validat,ValidationError,26231,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security,"n 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; Module with database functionality. """""". __all__ = [; ""database"",; ""db"",; ""DB_RGT"",; ""DB_RXN"",; ]. import collections; import math; import os; import re; import sys. from psi4 import core; from psi4.driver import constants; from psi4.driver import p4util; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/wrapper_database.html:1620,access,access,1620,psi4manual/1.7.x/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/wrapper_database.html,1,['access'],['access']
Security,"n = None. #: dict of reagents/geometries; #:; #: >>> print asdf.hrgt.keys(); #: ['NBC1-BzBz_PD32-0.8-monoA-CP', 'NBC1-BzBz_PD34-0.6-dimer', ... 'NBC1-BzBz_PD34-1.7-dimer']; self.hrgt = None. #: dict of defined reaction subsets.; #: Note that self.sset['default'] contains all the nonredundant information.; #:; #: >>> print asdf.sset.keys(); #: ['meme', 'mxddpp', '5min', ... 'small']; self.sset = None. # Removing hrxn, hrgt etc. do not reduce the size of the object.; # These attributes are stored for ease of access for adding qc info, etc. #: object of defined reaction subsets.; self.oss = None. # load database; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../databases'); database = psiutil.import_ignorecase(dbname); if not database:; print('\nPython module for database %s failed to load\n\n' % (dbname)); print('\nSearch path that was tried:\n'); print("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(dbname)). # gross validation of database; for item in ['dbse', 'GEOS', 'HRXN', 'ACTV', 'RXNM']:; try:; getattr(database, item); except AttributeError:; raise ValidationError(""""""Database %s severely deformed with %s missing."""""" % (database.__name__, item)); for item in ['TAGL', 'BIND']:; try:; getattr(database, item); except AttributeError:; print(""""""Warning: Database %s possibly deformed with %s missing.\n"""""" % (database.__name__, item)). # form database name; self.dbse = database.dbse; try:; self.tagl = database.TAGL['dbse']; except KeyError:; print(""""""Warning: TAGL missing for database %s"""""" % (self.dbse)). # form array of database contents to process through; pieces = []; for item in dir(database):; if item in ['qcdb', 'rxn', 'dbse', 'TAGL']:; pass; elif item.startswith('__'):; pass; else:; pieces.append(item). # form qcdb.Reagent objects from all defined geometries, GEOS; oHRGT = {}; for rgt, mol in database.GEOS.iteritems():; mol.update_geometr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:22173,Validat,ValidationError,22173,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"n Bohr; >>> print H2OH2O.z(4); -1.43347254509. Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; File to. dictify_database_docstrings()[source]¶. drop_duplicates(seq)[source]¶; Function that given an array or array of arrays seq, returns an; array without any duplicate entries. There is no guarantee of which; duplicate entry is dropped. useful()[source]¶. Module with non-generic exceptions classes. exception FeatureNotImplemented(msg)[source]¶; Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. exception IncompleteAtomError(msg)[source]¶; Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. exception QcdbException[source]¶; Error class for QCDB. exception ValidationError(msg)[source]¶; Error called for problems with syntax input file. Prints; error message msg to standard output stream. class Molecule(psi4molstr=None)[source]¶; Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. BFS()[source]¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. auto_fragments()[source]¶; Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. format_molecule_for_molpro()[source]¶. format_molecule_for_nwchem()[source]¶. format_molecule_for_psi4()[source]¶; Returns string of molecule definition block. format_molecule_for_qchem()[source]¶. gr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:63755,Validat,ValidationError,63755,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['Validat'],['ValidationError']
Security,"n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class to. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label=""""):; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html:5158,Validat,ValidationError,5158,psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,3,['Validat'],['ValidationError']
Security,"n Integral Algorithm Overview¶; The following table summarizes which implementation is used; for each type of one electron integral in PSI4. Algorithms used for One Electron Integrals¶. Integral; Class; Implementation; Comment. Three-Center Overlap; ThreeCenterOverlapInt; Libint2; using libint2::Operator::delta for 4-center integrals. Angular Momentum; AngularMomentumInt; M-D. Dipole; DipoleInt; Libint2; no derivatives supported. Electric Field; ElectricFieldInt; Libint2; using first derivative of libint2::Operator::nuclear. Coulomb Potential; ElectrostaticInt; Libint2; evaluated for a single origin and unity charge. Kinetic; KineticInt; Libint2. Multipole Potential; MultipolePotentialInt; M-D; arbitrary order derivative of 1/R supported. Multipole Moments; MultipoleInt; M-D; arbitrary order multipoles supported, including nuclear gradients. Nabla Operator; NablaInt; Libint2; using first derivative of libint2::Operator::overlap. Overlap; OverlapInt; Libint2. Nuclear Coulomb Potential; PotentialInt; Libint2; assumes nuclear centers/charges as the potential. PCM Potential; PCMPotentialInt; Libint2; parallelized over charge points. Quadrupole; QuadrupoleInt; Libint2. Traceless Quadrupole; TracelessQuadrupoleInt; Libint2. Relativistic Potential; RelPotentialInt; Libint2. table of contents. Integrals in PSI4; Introduction; The older style; The new syntax; Sieving; Buffer address; Density Screening; Shell blocking; Permutational symmetry; Using bra-ket symmetry; Instantiating integral objects. One Electron Integrals in PSI4; Calling compute_shell(int P, int Q); Accessing integrals; Derivative Integrals; Changes to External Potential Engines; New Operators Available; Shell Pairs; One Electron Integral Algorithm Overview. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Integrals in PSI4. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_integrals.html:19080,Access,Accessing,19080,psi4manual/master/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_integrals.html,1,['Access'],['Accessing']
Security,"n Ne and Ar atoms. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. matrix2; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. cdremp-2; Cholesky decomposed REMP/cc-pVDZ energies for the CH3 radical. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. opt16; SCF 6-31G(d) optimization of TS for HCN to HNC Performs finite difference hessian calculation. Then optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the plane of symemtry, This test confirms that only the reference geometry, with the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. extern4; External potential calculation involving a TIP3P water and a QM water. Gradient on the external charges is compared to gradient on the QM atoms to validate the gradient on the charges. tdscf-7; TD-HF test variable access. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). mom-h2o-3; MOM excitation from LUMO HOMO+3. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. olcc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:16572,Validat,ValidationError,16572,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['Validat'],['ValidationError']
Security,"n NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; 1>>> mat.np[:] = 1. this operation is identical to the above. Warning; The following will lead to reference errors: view =; psi4.Matrix(3, 3).np. Here, the Python garbage collection deletes the Matrix; object, the view then points to deleted data resulting in the view effectively; reading random data. As a general rule, never assign the .nph or .np; accessors. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; 1; 2; 3; 4; 5; 6; 7; 8>>> dim = psi4.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.Matrix(""New Matrix"", dim, dim). # Create a list of Psi4 arrays; >>> list_of_arrays = irreped_mat.to_array(). # Or, use the .nph irreped accessor; >>> irreped_mat.nph[0][:] = 1. Where .nph is the irreped accessor form. If .np or np.array are; called on irreped Matrices or Vectors an error will be thrown; however, the; irreped form is always valid for non-irreped matrices. Array to Matrix¶; A general function that converts PSI4 data objects to NumPy arrays. psi4.driver.p4util.numpy_helper.array_to_matrix(self, arr, name='New Matrix', dim1=None, dim2=None)[source]¶; Converts a numpy array or li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/numpy-1.html:2267,access,accessors,2267,psi4manual/1.1.0/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/numpy-1.html,2,['access'],['accessors']
Security,"n ['gradient', 'hessian']:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:3081,Validat,ValidationError,3081,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"n ['gradient', 'hessian']:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:3049,Validat,ValidationError,3049,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"n energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. # CSXError ceased to be used by v1.4. Class removed by v1.7; # class CSXError(PsiException):. [docs]class MissingMethodError(ValidationError):; """"""Error called when requested level or theory or derivative level are not; available. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]class ManagedMethodError(PsiException):; """"""Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters; ----------; circs; List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. Attributes; ----------; message; Human readable string describing the exception.; stats; Dictionary of conditions for which method request was made.; Keys are:. - driver : {""energy"", ""gradient"", ""hessian"", ""properties""}; - derivative_int : {0, 1, 2, ""prop""}, integer representation of driver; - method : str, model/method/level-of-theory; - link : str, link address to table in docs; - method_type : (str, str), raw value and str repr of governing variable and algorithm; - re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html:9896,Validat,ValidationError,9896,psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,1,['Validat'],['ValidationError']
Security,"n full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html:5410,Validat,ValidationError,5410,psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,3,['Validat'],['ValidationError']
Security,"n kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' %",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:34572,Validat,ValidationError,34572,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"n kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:35289,Validat,ValidationError,35289,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"n of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in ; :envvar:`PATH`. """"""; # Validate arguments; if self is None:; self = PsiMod.get_active_molecule(). dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all par",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:7427,Validat,ValidationError,7427,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"n self.shell_first_basis_function[i]. [docs] def function_to_shell(self, i):; """"""Given a function number what shell does it correspond to.""""""; return self.function_to_shell[i]. [docs] def function_to_center(self, i):; """"""Given a function what is its atomic center; * @param i Function number; * @return The atomic center for the i'th function. """"""; return self.function_center[i]. [docs] def ao_to_shell(self, i):; """"""Given a Cartesian function (AO) number what shell does it correspond to.""""""; return self.ao_to_shell[i]. [docs] def shell(self, si, center=None):; """"""Return the si'th Gaussian shell on center; * @param i Shell number; * @return A shared pointer to the GaussianShell object for the i'th shell. """"""; if center is not None:; si += self.center_to_shell[center]; if si < 0 or si > self.nshell():; text = """"""BasisSet::shell(si = %d), requested a shell out-of-bound.\n Max shell size: %d\n Name: %s\n"""""" % \; (si, self.nshell(), self.name()); raise ValidationError(""BasisSet::shell: requested shell is out-of-bounds:\n%s"" % (text)); return self.shells[si]. [docs] def nshell_on_center(self, i):; """"""Return the number of shells on a given center.""""""; return self.center_to_nshell[i]. [docs] def shell_on_center(self, center, shell):; """"""Return the overall shell number""""""; return self.center_to_shell[center] + shell. # <<< Methods for Printing >>>. [docs] def print_by_level(self, out=None, level=2):; """"""Print basis set information according to the level of detail in print_level; @param out The file stream to use for printing. Defaults to outfile.; @param print_level: defaults to 2; * < 1: Nothing ; * 1: Brief summary ; * 2: Summary and contraction details ; * > 2: Full details. """"""; if level < 1:; return; elif level == 1:; text = self.pyprint(out=None); elif level == 2:; text = self.print_summary(out=None); elif level > 2:; text = self.print_detail(out=None). if out is None:; print(text); else:; with open(out, mode='w') as handle:; handle.write(text). [docs] def pyprint(self, o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:30317,Validat,ValidationError,30317,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['Validat'],['ValidationError']
Security,"n task list. Parameters:; client (qcportal.FractalClient | None) – . get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. client (qcportal.FractalClient | None) – . Returns:. ret – Gradient or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. Return type:; float | Matrix | Tuple[float | Matrix, Wavefunction]. get_results(client=None)[source]¶; Return results as FiniteDifference-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None) – . Return type:; AtomicResult. plan()[source]¶. validator set_driver  »  driver[source]¶. validator set_molecule  »  molecule[source]¶. table of contents. Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes; Molden Interface Keywords; NORMAL_MODES_WRITE; WRITER_FILE_LABEL. psi4.driver.qcdb.vib Module; Functions. API; FiniteDifferenceComputer; FiniteDifferenceComputer.driver; FiniteDifferenceComputer.findifrec; FiniteDifferenceComputer.metameta; FiniteDifferenceComputer.method; FiniteDifferenceComputer.molecule; FiniteDifferenceComputer.task_list; FiniteDifferenceComputer.computer; FiniteDifferenceComputer.build_tasks(); FiniteDifferenceComputer.compute(); FiniteDifferenceComputer.get_psi_results(); FiniteDifferenceComputer.get_results(); FiniteDifferenceComputer.plan(); FiniteDifferenceComputer.set_driver; FiniteDifferenceComputer.set_molecule. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Psithon Functions: Invoking a Calcul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/freq.html:10724,validat,validator,10724,psi4manual/1.8.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/freq.html,1,['validat'],['validator']
Security,"n task list. Parameters:; client (qcportal.FractalClient | None) – . get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. client (qcportal.FractalClient | None) – . Returns:. ret – Gradient or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. Return type:; float | Matrix | Tuple[float | Matrix, Wavefunction]. get_results(client=None)[source]¶; Return results as FiniteDifference-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None) – . Return type:; AtomicResult. plan()[source]¶. validator set_driver  »  driver[source]¶. validator set_molecule  »  molecule[source]¶. table of contents. Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes; Molden Interface Keywords; NORMAL_MODES_WRITE; WRITER_FILE_LABEL. psi4.driver.qcdb.vib Module; Functions. API; FiniteDifferenceComputer; FiniteDifferenceComputer.driver; FiniteDifferenceComputer.findifrec; FiniteDifferenceComputer.metameta; FiniteDifferenceComputer.method; FiniteDifferenceComputer.molecule; FiniteDifferenceComputer.task_list; FiniteDifferenceComputer.computer; FiniteDifferenceComputer.build_tasks(); FiniteDifferenceComputer.compute(); FiniteDifferenceComputer.get_psi_results(); FiniteDifferenceComputer.get_results(); FiniteDifferenceComputer.plan(); FiniteDifferenceComputer.set_driver; FiniteDifferenceComputer.set_molecule. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon Functions: Invoking a Calcul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/freq.html:10724,validat,validator,10724,psi4manual/1.9.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/freq.html,1,['validat'],['validator']
Security,"n the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to compute managers.""); priority: str = Field(1, description=""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}""); owner_group: Optional[str] = Field(None, description=""group in the chown sense.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs]; @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs]; @validator(""method""); def set_method(cls, method):; return method.lower(). [docs]; @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs]; def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": self.protocols,; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs]; def compute(self, client: Optional[""qcportal.client.FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. from qcelemental.models import Molecule. # Build the molecule; mol = Molecule(**self.molecule.to_schema(dtype=2)). meta, ids = client.add_singlepoints(; molecules=mol,; program=""psi4"",; driver=self.driver,; method=self.method,; basis=self.basis,; keywords=self.keywords,; protocols=self.protocols,; tag=self.tag,; priority=self.priority,; owner",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/task_base.html:3918,validat,validator,3918,psi4manual/1.9.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/task_base.html,2,['validat'],['validator']
Security,"n the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to compute managers.""); priority: str = Field(1, description=""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}""); owner_group: Optional[str] = Field(None, description=""group in the chown sense.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs]; @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs]; @validator(""method""); def set_method(cls, method):; return method.lower(). [docs]; @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs]; def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": self.protocols,; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs]; def compute(self, client: Optional[""qcportal.client.FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. try:; # QCFractal v0.15.8; from qcportal.models import KeywordSet, Molecule; qca_next_branch = False; except ImportError:; # QCFractal `next`; from qcelemental.models import Molecule; qca_next_branch = True. # Build the molecule; mol = Molecule(**self.molecule.to_schema(dtype=2)). if not qca_next_branch:; # QCFractal v0.15.8. # Build the keyw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:3943,validat,validator,3943,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html,1,['validat'],['validator']
Security,"n title='%s',\n labels=%s,\n mae=%s,\n mape=%s\n xlimit=%s\n labeled=%s\n saveas=%s\n mousetext=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n mousediv=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, ixmid, mae, mape, str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, title=title, labels=ixmid, mae=mae, mape=mape,; xlimit=xlimit, labeled=labeled, view=view,; mousetext=mousetext, mouselink=mouselink,; mouseimag=mouseimag, mousetitle=mousetitle, mousediv=mousediv,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict, htmlcode. [docs] def plot_liliowa(self, modelchem, benchmark='default',; failoninc=True, xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". Note that not possible to access sset of component databases. That is, for Database SSIBBI, SSI-only arylaryl is accessible b/c not defined in BBI, but SSI-only neutral is not accessible.; """"""; # compute errors; mc = modelchem; errors = {}; for ss in self.sset.keys():; errors[ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False). # repackage; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, grap",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:81080,access,access,81080,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['access'],['access']
Security,"n ». Database¶; Code author: Lori A. Burns; Section author: Lori A. Burns. database(name, db_name[, func, mode, cp, rlxd, symm, zpe, benchmark, tabulate, subset])[source]¶; Function to access the molecule objects and reference energies of; popular chemical databases. Aliases :db(). Returns:(float) Mean absolute deviation of the database in kcal/mol. Psi variables:. db_name DATABASE MEAN SIGNED DEVIATION; db_name DATABASE MEAN ABSOLUTE DEVIATION; db_name DATABASE ROOT-MEAN-SQUARE DEVIATION; Python dictionaries of results accessible as DB_RGT and DB_RXN. Note; It is very easy to make a database from a collection of xyz files; using the script psi4/lib/scripts/ixyz2database.pl.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4 ; distribution, add the path to the directory containing the database ; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in ; psi4/lib/databases or PYTHONPATH. Consult that ; directory for available databases and literature citations. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/db-1.html:1089,access,access,1089,psi4manual/4.0b3/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/db-1.html,4,['access'],['access']
Security,"n' % \; (dashcoeff[dashlvleff][func]['s6'],; dashcoeff[dashlvleff][func]['sr6'],; dashcoeff[dashlvleff][func]['s8'],; 1.0,; dashcoeff[dashlvleff][func]['alpha6'],; 3); elif dashlvleff.lower() == 'd3bj':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; dashcoeff[dashlvleff][func]['a1'],; dashcoeff[dashlvleff][func]['s8'],; dashcoeff[dashlvleff][func]['a2'],; 0.0, 4); else:; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())); return returnstring. # Return parameter list for Dispersion.build function; # d2p4: name=-D2 s6=s6 p1=None p2=None p3=None (damping parameter fixed in Dispersion class); # d2gr: name=-D2GR s6=s6 p1=alpha6 p2=None p3=None; # d3zero: name=-D3ZERO s6=s6 p1=sr6 p2=s8 p3=alpha6; # d3bj: name=-D3BJ s6=s6 p1=a1 p2=s8 p3=a2; elif mode.lower() == 'psi4':; if dashlvleff == 'd2p4':; return '-D2', \; dashcoeff[dashlvleff][func]['s6'], \; 0.0, 0.0, 0.0; elif dashlvleff == 'd2gr':; return '-D2GR', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['alpha6'], \; 0.0, 0.0; elif dashlvleff == 'd3zero':; return '-D3ZERO', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['sr6'], \; dashcoeff[dashlvleff][func]['alpha6']; elif dashlvleff == 'd3bj':; return '-D3BJ', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['a1'], \; dashcoeff[dashlvleff][func]['a2']; else:; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). else:; raise ValidationError(""""""-D return format %s is not available. Choose 'psi4' or 'dftd3'.""""""). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta3] » ; Module code ». © Copyright 2012, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/dashparam.html:11413,Validat,ValidationError,11413,psi4manual/4.0b3/_modules/dashparam.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/dashparam.html,2,['Validat'],['ValidationError']
Security,"n' % \; (dashcoeff[dashlvleff][func]['s6'],; dashcoeff[dashlvleff][func]['sr6'],; dashcoeff[dashlvleff][func]['s8'],; 1.0,; dashcoeff[dashlvleff][func]['alpha6'],; 3); elif dashlvleff.lower() == 'd3bj':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; dashcoeff[dashlvleff][func]['a1'],; dashcoeff[dashlvleff][func]['s8'],; dashcoeff[dashlvleff][func]['a2'],; 0.0, 4); else:; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())); return returnstring. # Return parameter list for Dispersion.build function; # d2p4: name=-D2 s6=s6 p1=None p2=None p3=None (damping parameter fixed in Dispersion class); # d2gr: name=-D2GR s6=s6 p1=alpha6 p2=None p3=None; # d3zero: name=-D3ZERO s6=s6 p1=sr6 p2=s8 p3=alpha6; # d3bj: name=-D3BJ s6=s6 p1=a1 p2=s8 p3=a2; elif mode.lower() == 'psi4':; if dashlvleff == 'd2p4':; return '-D2', \; dashcoeff[dashlvleff][func]['s6'], \; 0.0, 0.0, 0.0; elif dashlvleff == 'd2gr':; return '-D2GR', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['alpha6'], \; 0.0, 0.0; elif dashlvleff == 'd3zero':; return '-D3ZERO', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['sr6'], \; dashcoeff[dashlvleff][func]['alpha6']; elif dashlvleff == 'd3bj':; return '-D3BJ', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['a1'], \; dashcoeff[dashlvleff][func]['a2']; else:; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). else:; raise ValidationError(""""""-D return format %s is not available. Choose 'psi4' or 'dftd3'.""""""). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta4] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/dashparam.html:11413,Validat,ValidationError,11413,psi4manual/4.0b4/_modules/dashparam.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/dashparam.html,2,['Validat'],['ValidationError']
Security,"n' % \; (dashcoeff[dashlvleff][func]['s6'],; dashcoeff[dashlvleff][func]['sr6'],; dashcoeff[dashlvleff][func]['s8'],; 1.0,; dashcoeff[dashlvleff][func]['alpha6'],; 3); elif dashlvleff.lower() == 'd3bj':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; dashcoeff[dashlvleff][func]['a1'],; dashcoeff[dashlvleff][func]['s8'],; dashcoeff[dashlvleff][func]['a2'],; 0.0, 4); else:; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())); return returnstring. # Return parameter list for Dispersion.build function; # d2p4: name=-D2 s6=s6 p1=None p2=None p3=None (damping parameter fixed in Dispersion class); # d2gr: name=-D2GR s6=s6 p1=alpha6 p2=None p3=None; # d3zero: name=-D3ZERO s6=s6 p1=sr6 p2=s8 p3=alpha6; # d3bj: name=-D3BJ s6=s6 p1=a1 p2=s8 p3=a2; elif mode.lower() == 'psi4':; if dashlvleff == 'd2p4':; return '-D2', \; dashcoeff[dashlvleff][func]['s6'], \; 0.0, 0.0, 0.0; elif dashlvleff == 'd2gr':; return '-D2GR', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['alpha6'], \; 0.0, 0.0; elif dashlvleff == 'd3zero':; return '-D3ZERO', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['sr6'], \; dashcoeff[dashlvleff][func]['alpha6']; elif dashlvleff == 'd3bj':; return '-D3BJ', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['a1'], \; dashcoeff[dashlvleff][func]['a2']; else:; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). else:; raise ValidationError(""""""-D return format %s is not available. Choose 'psi4' or 'dftd3'.""""""). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta5] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/dashparam.html:12233,Validat,ValidationError,12233,psi4manual/4.0b5/_modules/dashparam.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/dashparam.html,2,['Validat'],['ValidationError']
Security,"n('SCF', ""MOM_START"") != 0 and len(core.get_option('SCF', ""MOM_OCC"")) > 0); if enabled:; start = core.get_option('SCF', ""MOM_START""); if enabled < 0:; raise ValidationError('SCF MOM_START ({}) must be at least 1'.format(start)). return enabled. def _validate_soscf():; """"""Sanity-checks SOSCF control options. Raises; ------; ValidationError; If any of |scf__soscf|, |scf__soscf_start_convergence|,; |scf__soscf_min_iter|, |scf__soscf_max_iter| don't play well together. Returns; -------; bool; Whether SOSCF is enabled during scf. """"""; enabled = core.get_option('SCF', 'SOSCF'); if enabled:; start = core.get_option('SCF', 'SOSCF_START_CONVERGENCE'); if start < 0.0:; raise ValidationError('SCF SOSCF_START_CONVERGENCE ({}) must be positive'.format(start)). miniter = core.get_option('SCF', 'SOSCF_MIN_ITER'); if miniter < 1:; raise ValidationError('SCF SOSCF_MIN_ITER ({}) must be at least 1'.format(miniter)). maxiter = core.get_option('SCF', 'SOSCF_MAX_ITER'); if maxiter < miniter:; raise ValidationError(; 'SCF SOSCF_MAX_ITER ({}) must be at least SOSCF_MIN_ITER ({})'.format(maxiter, miniter)). conv = core.get_option('SCF', 'SOSCF_CONV'); if conv < 1.e-10:; raise ValidationError('SCF SOSCF_CONV ({}) must be achievable'.format(conv)). return enabled. def field_fn(xyz):; """"""Callback function for PylibEFP to compute electric field from electrons; in ab initio part for libefp polarization calculation. Parameters; ----------; xyz : list; (3 * npt, ) flat array of points at which to compute electric field. Returns; -------; list; (3 * npt, ) flat array of electric field at points in `xyz`. Notes; -----; Function signature defined by libefp, so function uses number of; basis functions and integrals factory `mints_psi4_yo` and total density; matrix `efp_Dt_psi4_yo` from global namespace. """"""; points = np.array(xyz).reshape(-1, 3); npt = len(points). # Cartesian basis one-electron EFP perturbation; nbf = mints_psi4_yo.basisset().nbf(); field_ints = np.zeros((3, nbf, nbf)). # Electric fi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:26053,Validat,ValidationError,26053,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security,"n(2); self.symop[2].c2_y(); self.symop[3].c2_x(). elif self.PYbits == PointGroups['D2h']:; self.symop[1].rotation(2); self.symop[2].c2_y(); self.symop[3].c2_x(); self.symop[4].i(); self.symop[5].sigma_xy(); self.symop[6].sigma_xz(); self.symop[7].sigma_yz(). else:; return -1. # now find the inverse of each symop; for gi in range(self.PYnirrep):; for gj in range(self.PYnirrep):; so = self.symop[gi].operate(self.symop[gj]). # is so a unit matrix?; if abs(1.0 - so[0][0]) < 1.0e-8 and \; abs(1.0 - so[1][1]) < 1.0e-8 and \; abs(1.0 - so[2][2]) < 1.0e-8:; break. if gj == self.PYnirrep:; # ExEnv::err0() << indent; # << ""make_table: uh oh, can't find inverse of "" << gi << endl;; # abort();; raise ValidationError(""make_table: uh oh, can't find inverse""). self.inv[gi] = gj. # Check the bits of the operator make sure they make what; # we were given.; sym_bits = 0; for i in range(self.PYnirrep):; sym_bits |= self.symop[i].bit(). if sym_bits != self.PYbits:; raise ValidationError(""make_table: Symmetry operators did not match the point group given.""). return 0. # <<< Methods for Printing >>>. def __str__(self, out=None):; """"""This prints the irrep to the given file, or stdout if none is; given. """"""; text = ''; if not self.PYnirrep:; return. text += ' point group %s\n\n' % (self.symb); for i in range(self.PYnirrep):; text += self.PYgamma[i].__str__(out=None). text += '\n symmetry operation matrices:\n\n'; for i in range(self.PYnirrep):; text += self.symop[i].__str__(out=None). text += '\n inverse symmetry operation matrices:\n\n'; for i in range(self.PYnirrep):; text += self.symop[self.inverse(i)].__str__(out=None). if out is None:; return text; else:; with open(out, mode='w') as handle:; handle.write(text). [docs]class PointGroup(object):; """"""The PointGroup class is really a place holder for a CharacterTable.; It contains a string representation of the Schoenflies symbol of a; point group, a frame of reference for the symmetry operation; transformation matrices, and a point of orig",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:37045,Validat,ValidationError,37045,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security,"n(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return metadata. def _process_cbs_kwargs(kwargs: Dict) -> CBSMetadata:; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs; kwargs containing the CBS function specification. Returns; -------; cbs_metadata; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}_basis"" in kwargs:; # either both *_wfn and *_basis have to be specified; stage = {""wfn"": kwargs[f""{sn}_wfn""], ""basis"": kwargs[f""{sn}_basis""]}; elif sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis"": kwargs[f""{sn}_basis""]}; else:; # otherwise go to the next possible stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwarg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:20210,validat,validate,20210,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,10,"['Validat', 'validat']","['ValidationError', 'validate']"
Security,"n). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cclambda(ccwfn); core.ccdensity(ccwfn). # Need ccresponse only for response-type props; if n_response > 0:; core.set_global_option('DERTYPE', 'RESPONSE'); core.cclambda(ccwfn); for prop in response:; core.set_global_option('PROPERTY', prop); core.ccresponse(ccwfn). # Excited-state transition properties; if n_excited > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""""""Unknown excited-state CC wave function.""""""); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); # Tight convergence unnecessary for transition properties; core.set_local_option('CCLAMBDA', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). if n_one > 0:; # call oe prop for GS density; oe = core.OEProp(ccwfn); oe.set_title(""CC""); for oe_name in one:; oe.add(oe_name.upper()); oe.compute(); # call oe prop for each ES density; if name.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.get_variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.get_variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.get_variable(""CC DIPOLE Z"")); if 'quadrupole' in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:79940,Validat,ValidationError,79940,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"n). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cclambda(ccwfn); core.ccdensity(ccwfn). # Need ccresponse only for response-type props; if n_response > 0:; core.set_global_option('DERTYPE', 'RESPONSE'); core.cclambda(ccwfn); for prop in response:; core.set_global_option('PROPERTY', prop); core.ccresponse(ccwfn). # Excited-state transition properties; if n_excited > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""""""Unknown excited-state CC wave function.""""""); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); # Tight convergence unnecessary for transition properties; core.set_local_option('CCLAMBDA', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). if n_one > 0:; # call oe prop for GS density; oe = core.OEProp(ccwfn); oe.set_title(""CC""); for oe_name in one:; oe.add(oe_name.upper()); oe.compute(); # call oe prop for each ES density; if name.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:79038,Validat,ValidationError,79038,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"n). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cclambda(ccwfn); core.ccdensity(ccwfn). # Need ccresponse only for response-type props; if n_response > 0:; core.set_global_option('DERTYPE', 'RESPONSE'); core.cclambda(ccwfn); for prop in response:; core.set_global_option('PROPERTY', prop); core.ccresponse(ccwfn). # Excited-state transition properties; if n_excited > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""""""Unknown excited-state CC wave function.""""""); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); # Tight convergence unnecessary for transition properties; core.set_local_option('CCLAMBDA', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). if n_one > 0:; # call oe prop for GS density; oe = core.OEProp(ccwfn); oe.set_title(name.upper()); for oe_name in one:; oe.add(oe_name.upper()); oe.compute(); # call oe prop for each ES density; if name.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; # retire components at v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y""));",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:99791,Validat,ValidationError,99791,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"n). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cclambda(ccwfn); core.ccdensity(ccwfn). # Need ccresponse only for response-type props; if n_response > 0:; core.set_global_option('DERTYPE', 'RESPONSE'); core.cclambda(ccwfn); for prop in response:; core.set_global_option('PROPERTY', prop); core.ccresponse(ccwfn). # Excited-state transition properties; if n_excited > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""""""Unknown excited-state CC wave function.""""""); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); # Tight convergence unnecessary for transition properties; core.set_local_option('CCLAMBDA','R_CONVERGENCE',1e-4); core.set_local_option('CCEOM','R_CONVERGENCE',1e-4); core.set_local_option('CCEOM','E_CONVERGENCE',1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX'],; ['SCF_TYPE']). core.set_global_option('ONEPDM', 'TRUE'); core.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:74671,Validat,ValidationError,74671,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"n). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; psi4.set_global_option('WFN', 'EOM_CCSD'); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cceom(ccwfn); elif name == 'eom-cc2':; psi4.set_global_option('WFN', 'EOM_CC2'); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cceom(ccwfn); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cclambda(ccwfn); psi4.ccdensity(ccwfn). # Need ccresponse only for response-type props; if n_response > 0:; psi4.set_global_option('DERTYPE', 'RESPONSE'); psi4.cclambda(ccwfn); for prop in response:; psi4.set_global_option('PROPERTY', prop); psi4.ccresponse(ccwfn). # Excited-state transition properties; if n_excited > 0:; if name == 'eom-ccsd':; psi4.set_global_option('WFN', 'EOM_CCSD'); elif name == 'eom-cc2':; psi4.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""""""Unknown excited-state CC wave function.""""""); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); # Tight convergence unnecessary for transition properties; psi4.set_local_option('CCLAMBDA','R_CONVERGENCE',1e-4); psi4.set_local_option('CCEOM','R_CONVERGENCE',1e-4); psi4.set_local_option('CCEOM','E_CONVERGENCE',1e-5); psi4.cceom(ccwfn); psi4.cclambda(ccwfn); psi4.ccdensity(ccwfn). psi4.set_global_option('WFN', 'SCF'); psi4.revoke_global_option_changed('WFN'); psi4.set_global_option('DERTYPE', 'NONE'); psi4.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. [docs]def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX'],; ['SCF_TYPE']). psi4.set_global_option('ONEPDM', 'TRUE'); psi4.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:62013,Validat,ValidationError,62013,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"n.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ValidationError(""adcc can only deal with a single irrep.""); kwargs[""n_states""] = n_roots[0]. if core.get_option(""ADC"", ""NUM_GUESSES"") > 0:; kwargs[""n_guesses""] = core.get_option(""ADC"", ""NUM_GUESSES""); if core.get_option(""ADC"", ""MAX_NUM_VECS"") > 0:; kwargs[""max_subspace""] = core.get_option(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif kind not in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBIT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:114776,Validat,ValidationError,114776,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['Validat'],['ValidationError']
Security,"n.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ValidationError(""adcc can only deal with a single irrep.""); kwargs[""n_states""] = n_roots[0]. if core.get_option(""ADC"", ""NUM_GUESSES"") > 0:; kwargs[""n_guesses""] = core.get_option(""ADC"", ""NUM_GUESSES""); if core.get_option(""ADC"", ""MAX_NUM_VECS"") > 0:; kwargs[""max_subspace""] = core.get_option(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif not kind in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif not kind in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and not ""cvs"" in name:; raise ValidationError(""The NUM_CORE_ORBIT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:112491,Validat,ValidationError,112491,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"n; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for FCHK files."""""". import re; from typing import Union. import numpy as np; from psi4.driver.p4util.testing import compare_strings, compare_arrays, compare_values, compare_integers; from psi4 import core; from .exceptions import ValidationError. __all__ = [; ""compare_fchkfiles"",; ""compare_moldenfiles"",; ]. def _consume_fchk_section(input_list, index):; """"""compare a float or integer matrix section"""""". n = int(input_list[index].split()[-1]); kind = input_list[index].split()[-3]. if ""R"" in kind:; dtype = np.float64; format_counter = 5; elif ""I"" in kind:; dtype = np.float64; format_counter = 6; else:; raise ValidationError('Unknow field type in FCHK reader\n'). extra = 0 if n <= format_counter else n % format_counter; lines = 1 if n <= format_counter else int(n / format_counter); offset = lines + 1 if extra > 0 else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. def _fchkfile_to_string(fname: str) -> str:; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fchk.html:1367,Validat,ValidationError,1367,psi4manual/1.7.x/_modules/psi4/driver/p4util/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fchk.html,2,['Validat'],['ValidationError']
Security,"n; efp = core.get_active_efp(); if efp.nfragments() > 0:; core.set_legacy_molecule(scf_molecule); core.set_global_option('QMEFP', True) # apt to go haywire if set locally to efp; core.efp_set_options(); efp.set_qm_atoms(); efp.print_out(). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); scf_wfn = scf_wavefunction_factory(core.get_option('SCF', 'REFERENCE'), base_wfn); core.set_legacy_wavefunction(scf_wfn). fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(scf_molecule.name())))[1]; read_filename = os.path.join(core.get_environment(""PSI_SCRATCH""), fname + "".180.npz""). if (core.get_option('SCF', 'GUESS') == 'READ') and os.path.isfile(read_filename):; data = np.load(read_filename); Ca_occ = core.Matrix.np_read(data, ""Ca_occ""); Cb_occ = core.Matrix.np_read(data, ""Cb_occ""); symmetry = str(data[""symmetry""]); basis_name = str(data[""BasisSet""]). if symmetry != scf_molecule.schoenflies_symbol():; raise ValidationError(""Cannot compute projection of different symmetries.""). if basis_name == scf_wfn.basisset().name():; core.print_out("" Reading orbitals from file 180, no projection.\n\n""); scf_wfn.guess_Ca(Ca_occ); scf_wfn.guess_Cb(Cb_occ); else:; core.print_out("" Reading orbitals from file 180, projecting to new basis.\n\n""). puream = int(data[""BasisSet PUREAM""]). if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). old_basis = core.BasisSet.build(scf_molecule, ""ORBITAL"", basis_name, puream=puream); core.print_out("" Computing basis projection from %s to %s\n\n"" % (basis_name, base_wfn.basisset().name())). nalphapi = core.Dimension.from_list(data[""nalphapi""]); nbetapi = core.Dimension.from_list(data[""nbetapi""]); pCa = scf_wfn.basis_projection(Ca_occ, nalphapi, old_basis, base_wfn.basisset()); pCb = scf_wfn.basis_projection(Cb_occ, nbetapi, old_basis, base_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Strip off headers to only get R, RO, U, CU; old_ref = s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:35252,Validat,ValidationError,35252,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"n='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'); cbs_alpha = {; 'scf': kwargs.get('cbs_scf_alpha', kwargs.get('scf_alpha', None)),; 'corl': kwargs.get('cbs_corl_alpha', kwargs.get('corl_alpha', None)),; 'delta': kwargs.get('cbs_delta_alpha', kwargs.get('delta_alpha', None)),; 'delta2': kwargs.get('cbs_delta2_alpha', kwargs.get('delta2_alpha', None)),; }. # Establish function to call (only energy makes sense for cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. # Establish method for reference energy; if do_corl and cbs_corl_wfn.startswith('c4-'):; default_scf = 'c4-hf'; else:; default_scf = 'hf'; cbs_scf_wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:38324,Validat,ValidationError,38324,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"nError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference freq run in one job or files farmed out; freq_mode = kwargs.pop('mode', 'continuous').lower(); if freq_mode == 'continuous':; pass; elif freq_mode == 'sow':; if dertype == 2:; raise ValidationError(""""""Frequency execution mode 'sow' not valid for analytic Hessian calculation.""""""); elif freq_mode == 'reap':; freq_linkage = kwargs.get('linkage', None); if freq_linkage is None:; raise ValidationError(""""""Frequency execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; if dertype == 2:; core.print_out(""""""hessian() switching to finite difference by gradients for partial Hessian calculation.\n""""""); dertype = 1. # Does an analytic procedure exist for the requested method?; if dertype == 2:; core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:66326,Validat,ValidationError,66326,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"nError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference freq run in one job or files farmed out; freq_mode = kwargs.pop('mode', 'continuous').lower(); if freq_mode == 'continuous':; pass; elif freq_mode == 'sow':; if dertype == 2:; raise ValidationError(""""""Frequency execution mode 'sow' not valid for analytic Hessian calculation.""""""); elif freq_mode == 'reap':; freq_linkage = kwargs.get('linkage', None); if freq_linkage is None:; raise ValidationError(""""""Frequency execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0. # Does an analytic procedure exist for the requested method?; if dertype == 2:; psi4.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:64489,Validat,ValidationError,64489,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,nInt class in psi4.core. U. U psi4.core.Localizer attribute. UHF class in psi4.core. UHF_NOONS (SCF). UKSFunctions class in psi4.core. UNCP-CORRECTED 2-BODY INTERACTION ENERGY. unify() psi4.core.FISAPT method. unify_part2() psi4.core.FISAPT method. unit() psi4.core.SymmetryOperation method. units. ; molecule. units() psi4.core.Molecule method. Unnormalized psi4.core.PrimitiveType attribute. up psi4.driver.p4util.InPsight attribute. UPDATE (DETCI). update() psi4.core.SOMCSCF method. update_density() psi4.core.TwoBodyAOInt method. update_geometry() psi4.core.Molecule method. psi4.driver.p4util.InPsight method. update_orbitals() psi4.core.IntegralTransform method. UpgradeHelper. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. v2rdm_casscf. ; plugin. V_potential() psi4.core.HF method. Va() psi4.core.HF method. VAL_EX_LEVEL (DETCI). valid_methods psi4.core.OEProp attribute. validate_diis() psi4.core.HF method. validate_options() psi4.core.Options method. ValidationError. value psi4.core.DerivCalcType attribute. psi4.core.DiagonalizeOrder attribute. psi4.core.FragmentType attribute. psi4.core.GaussianType attribute. psi4.core.GeometryUnits attribute. psi4.core.PrimitiveType attribute. psi4.core.PsiReturnType attribute. psi4.core.SaveType attribute. value() psi4.core.SuperFunctional method. values() psi4.core.SuperFunctional method. variable() in module psi4.core. psi4.core.Wavefunction method. variables() in module psi4.core. psi4.core.Wavefunction method. Vb() psi4.core.HF method. VBase class in psi4.core. vdot() psi4.core.CIVector method. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector class in psi4.core. Vector3 class in psi4.core. vector_axpy() psi4.driver.p4util.SolverEngine method. vector_copy() psi4.driver.p4util.SolverEngine method. vector_dot() psi4.core.Matrix method. psi4.core.Vector method. psi4.driver.p4util.SolverEngine static method. vector_multiply() psi4.core.CIVector method. vector_scale() psi4.driver.p4util.SolverEngine metho,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/genindex.html:125510,Validat,ValidationError,125510,psi4manual/1.8.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/genindex.html,1,['Validat'],['ValidationError']
Security,"n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. psi4.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). psi4.print_out(""\n""); p4util.banner(""CP Computation: Results.""); psi4.print_out(""\n""). p4util.banner(""Hartree"", 2); psi4.print_out(""\n""). psi4.print_out(str(cp_table)). psi4.print_out(""\n""); p4util.banner(""kcal*mol^-1"", 2); psi4.print_out(""\n""). cp_table.scale(). psi4.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:23267,access,access,23267,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['access'],['access']
Security,"n__ = '1.1rc1'; __version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> cat metadata.out.py | head -8; __version__ = '1.1rc2.dev1'; __version_branch_name = 'master'; __version_cmake = '1.0.0.999'; __version_is_clean = 'True'; __version_last_release = '1.0'; __version_long = '1.1rc2.dev1+4e0596e'; __version_prerelease = 'False'; __version_release = 'False'. >>> git log --oneline; 4e0596e Records tag for v1.1rc1; 6100822 v1.1rc1; cbee32b Fixes pcmsolver/scf for py3. Moves source for libefp upstream. ACT to inform remote of bump. Temporarily disengage “Include administrators” on protected master branch. 1; 2>>> git push origin master; >>> git push origin v1.1rc1. Now https://github.com/psi4/psi4/releases says v1.1rc1 & 6100822. How to create and remove an annotated Git tag on a remote¶; PSI4 versioning only works with annotated tags, not lightweight; tags as are created with the GitHub interface. Create annotated tag:; 1; 2>>> git tag -a v1.1a1 <git hash if not current> -m ""v1.1a1""; >>> git push origin v1.1a1. Delete tag:; 1; 2>>> git tag -d v1.1a1; >>> git push origin :refs/tags/v1.1a1. Pull tags:; 1>>> git fetch <remote> 'refs/tags/*:refs/tags/*'. What Psi4 version is running¶. Psithon / from the executable:; 1; 2>>> psi4 --version; 1.1rc2.dev17. PsiAPI / from the library:; 1; 2>>> python -c ""import psi4; print(psi4.__version__)""; 1.1rc2.dev17. Output file header gives info like the print_header() below. Function print_header() returns a summary of citation, version, and; git information about PSI4. Function version_formatter() can; return version and git information in any desired format string.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34>>> import psi4; >>> psi4.print_header(). -----------------------------------------------------------------------; Psi4: An Open-Source Ab Initio Electronic Structure Package; Psi4 1.1rc2.dev17. Git: Rev {condadoc} c852257",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/manage_git-1.html:4816,hash,hash,4816,psi4manual/1.1.0/manage_git-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/manage_git-1.html,6,['hash'],['hash']
Security,"n_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'DIE_IF_NOT_CONVERGED', 'FALSE'); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). return dfocc_wfn. def run_occ(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation. """"""; # Stash these options so we can reload them at computation end.; optstash = p4util.OptionsState(; ['OCC', 'SPIN_SCALE_TYPE'],; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE']). if name == 'mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'); elif name == 'scs-mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'SCS'); elif name == 'scs(n)-mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:66127,Validat,ValidationError,66127,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"n_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'DIE_IF_NOT_CONVERGED', 'FALSE'); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). return dfocc_wfn. def run_occ(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation. """"""; optstash = p4util.OptionsState(; ['OCC', 'SCS_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'SOS_TYPE'],; ['OCC', 'DO_SOS'],; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE']). if name == 'mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); core.set_local_option('OCC', 'DO_SCS', 'FALSE'); core.set_local_option('OCC', 'DO_SOS', 'FALSE'); elif name == 'omp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'DO_SCS', 'FALSE'); core.set_local_option('OCC', 'DO_SOS', 'FALSE'); elif name == 'scs-omp2':; core.set_local_option('OCC', 'WFN_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:51081,Validat,ValidationError,51081,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"n_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); psi4.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); psi4.set_local_option('DFOCC', 'QCHF', 'TRUE'); psi4.set_local_option('DFOCC', 'E_CONVERGENCE', 8). psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); psi4.set_local_option('SCF', 'DIE_IF_NOT_CONVERGED', 'FALSE'); psi4.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = psi4.dfocc(ref_wfn). return dfocc_wfn. [docs]def run_occ(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation. """"""; optstash = p4util.OptionsState(; ['OCC', 'SCS_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'SOS_TYPE'],; ['OCC', 'DO_SOS'],; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE']). if name == 'mp2':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); psi4.set_local_option('OCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('OCC', 'DO_SOS', 'FALSE'); elif name == 'omp2':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'); psi4.set_local_option('OCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('OCC', 'DO_SOS', 'FALSE'); elif name == 'scs-omp2':; psi4.set_local_option('OCC',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:41428,Validat,ValidationError,41428,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"n_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:82792,access,accessed,82792,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['access'],['accessed']
Security,"nally projected coordinates, while OFF (=1) retains the rotational degrees of freedom. At a stationary point on the potential energy surface, both options will give equivalent harmonic force fields, but OFF should be used at non-stationary points. Type: string; Possible Values: ON, OFF; Default: ON. CFOUR_FD_STEPSIZE (CFOUR); CFOUR — Specifies the step length in mass-weighted coordinates (in ) used in generating the force constant matrix by finite difference of Cartesian gradients. Type: integer; Default: 5. CFOUR_FD_USEGROUP (CFOUR); CFOUR — In finite difference calculations using the FINDIF option, this keyword specifies the point group to be used in generating the symmetry-adapted vibrational coordinates. FULL (= 0) specifies the full molecular point group, COMP (= 1) specifies the Abelian subgroup used in the electronic structure calculation. Type: string; Possible Values: FULL, COMP; Default: FULL. CFOUR_FILE_RECSIZ (CFOUR); CFOUR — This specifies the physical length (in integer words) of the records used in the word-addressable direct access files used by CFOUR. This value should always be chosen as a multiple of 512 bytes, as your local system manager certainly understands. Type: integer; Default: 2048. CFOUR_FILE_STRIPE (CFOUR); CFOUR — This option allows the splitting of files. Input is required in the form N1/N2/N3/N4/N5, where N1, N2, N3, N4, and N5 specify the number of files in which MOINTS, GAMLAM, MOABCD, DERINT, and DERGAM are splitted, respectively. Type: string; Default: 0/0/0/0/0. CFOUR_FINITE_PERTURBATION (CFOUR); CFOUR — Specifies the field strength for a perturbation (defined within a %perturbation section). The value must be given as an integer, and the field strength used by the program will be then the value of the keyword . Type: integer; Default: 0. CFOUR_FOCK (CFOUR); CFOUR — This option is used to control the algorithm used for construction of the Fock matrix in SCF calculations. PK (=0) uses the PK-supermatrix approach while AO (=1) con",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:43630,access,access,43630,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['access'],['access']
Security,"nals, build_superfunctional_from_dictionary. def scf_set_reference_local(name, is_dft=False):; """"""; Figures out the correct SCF reference to set locally; """""". optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['SCF', 'REFERENCE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Alter reference name if needed; user_ref = core.get_option('SCF', 'REFERENCE'). sup = build_superfunctional_from_dictionary(functionals[name], 1, 1, True)[0]; if sup.needs_xc() or is_dft:; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationnError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop,; oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.basisset()); if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html:2267,Validat,Validations,2267,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html,1,['Validat'],['Validations']
Security,"name)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:7461,Validat,ValidationError,7461,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,8,['Validat'],['ValidationError']
Security,"name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # If RHF get MP2 NO's; # Why doesnt this work for conv?; if (('DF' in core.get_global_option('SCF_TYPE')) and (user_ref == 'RHF') and; (core.get_option('DETCI', 'MCSCF_TYPE') in ['DF', 'AO']) and; (core.get_option(""DETCI"", ""MCSCF_GUESS"") == ""MP2"")):; core.set_global_option('ONEPDM', True); core.set_global_option('OPDM_RELAX', False); ref_wfn = run_dfmp2_gradient(name, **kwargs); else:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; if (core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV'):; mints = core.MintsHelper(ref_wfn.basisset()); mints.set_print(1); mints.integrals(). ref_optstash.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:164257,Validat,ValidationError,164257,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['Validat'],['ValidationError']
Security,"name); psi4.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (psi4.get_variable('CURRENT ENERGY'), wfn); else:; return psi4.get_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. :returns: :ref:`Matrix<sec:psimod_Matrix>` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:ref:`Matrix<sec:psimod_Matrix>`, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, psi4.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Gradient: Cannot specify bsse_type for gradient yet.""). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Figure out lowername, dertype, and func; # If we have analytical gradients we want to pass to our wrappers, otherwise we want to run; # finite-diference energy or cbs energies; # TODO MP5/cc-pv[DT]Z behavior unkown due to ""levels""; user_dertype = kwargs.pop('dertype', None); if gradient_type == 'custom_function':; if user_dertype is None:; dertype = 0; psi4.print_out(""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""); else:; psi4.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:32402,Validat,ValidationError,32402,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"name, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme using exponential form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname : string; Name of the CBS component.; zLO : int; Lower zeta level.; valueLO : float; Lower value used for extrapolation.; zHI : int; Higher zeta level. Should be equal to zLO + 1.; valueHI : float; Higher value used for extrapolation.; alpha : float, optional; Overrides the default :math:`\alpha = 1.63`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [1]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63`. References; ----------. .. [1] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; ""scf_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)"" % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 1.63. beta_division = 1 / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); beta_mult = math.exp(-1 * alpha * zHI). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':';",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:8050,Validat,ValidationError,8050,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; beta = valueHI.clone(); beta.name = 'Helgaker SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Helgaker SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). def scf_xtpl_truhlar_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme using power form for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`.; Truhlar, Chem. Phys. Lett. 294 (1998) 45-48, DOI: 10.1016/S0009-2614(98)00866-5. .. math:: E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4. """""". if type(valueLO) != type(valueHI):; raise ValidationError(""scf_xtpl_truhlar_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI ** (-1 * alpha) - zLO ** (-1 * alpha)); beta_mult = zHI ** (-1 * alpha). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:8566,Validat,ValidationError,8566,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(1)"", ""cepa_no_singles"": False,},. ""cepa(3)"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(3)"", ""cepa_no_singles"": False,},; ""fno-cepa(3)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(3)"", ""cepa_no_singles"": False,},. ""acpf"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},; ""fno-acpf"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},. ""aqcc"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},; ""fno-aqcc"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},. ""cisd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; ""fno-cisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. some of these pre-trapped by select_* functions but others escape, incl. cepa variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_cepa`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:177476,Validat,ValidationError,177476,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"nce = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Cou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:11377,Validat,ValidationError,11377,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,3,['Validat'],['ValidationError']
Security,"nce = psi4.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Cou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:11257,Validat,ValidationError,11257,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"nce(arr, (list, tuple)):; if (dim1 is not None) or (dim2 is not None):; raise ValidationError(""Array_to_Matrix: If passed input is list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == psi4.Matrix:; sdim1 = psi4.Dimension(irreps); sdim2 = psi4.Dimension(irreps); ; for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == psi4.Vector:; sdim1 = psi4.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for interface, vals in zip(ret.array_interfaces(), arr):; if 0 in interface.__array_interface__[""shape""]:; continue; else:; view = np.asarray(interface); view[:] = vals. return ret . # No irreps implied by list; else:; if arr_type == psi4.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError (""Array_to_Matrix: If dim1 is supplied must supply dim2 also""); ; dim1 = psi4.Dimension.from_list(dim1) ; dim2 = psi4.Dimension.from_list(dim2) . if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""); ; ret = self(name, dim1, dim2); ; start1 = 0; start2 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1 ; start2 += d2. return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. elif arr_type == psi4.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError (""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""); ; dim1 = psi4.Dimension.from_list(dim1) ; ret = self(name, dim1). sta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:4621,Validat,ValidationError,4621,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"nce(dims, (tuple, list, np.ndarray)):; irreps = len(dims); elif isinstance(dims, core.Dimension):; irreps = dims.n(); else:; raise ValidationError(""Dimension from list: Type '%s' not understood"" % type(dims)). ret = core.Dimension(irreps, name); for i in range(irreps):; ret[i] = dims[i]; return ret. def _dimension_to_tuple(dim):; """"""; Converts a core.Dimension object to a tuple.; """""". if isinstance(dim, (tuple, list)):; return tuple(dim). irreps = dim.n(); ret = []; for i in range(irreps):; ret.append(dim[i]); return tuple(ret). def _dimension_iter(dim):; """"""; Provides an iterator class for the Dimension object. Allows:; dim = psi4.core.Dimension(...); list(dim); """""". for i in range(dim.n()):; yield dim[i]. # Dimension attributes; core.Dimension.from_list = _dimension_from_list; core.Dimension.to_tuple = _dimension_to_tuple; core.Dimension.__iter__ = _dimension_iter. # General functions for NumPy array manipulation; def block_diagonal_array(*args):; """"""; Convert square NumPy array to a single block diagonal array.; Mimic of SciPy's block_diag.; """""". # Validate the input matrices.; dim = 0; for matrix in args:; try:; shape = matrix.shape; dim += shape[0]; except (AttributeError, TypeError):; raise ValidationError(""Cannot construct block diagonal from non-arrays.""); if len(shape) != 2:; raise ValidationError(""Cannot construct block diagonal from non-2D arrays.""); if shape[0] != shape[1]:; raise ValidationError(""Cannot construct block diagonal from non-square arrays.""). # If this is too slow, try a sparse matrix?; block_diag = np.zeros((dim, dim)); start = 0; for matrix in args:; next_block = slice(start, start + matrix.shape[0]); block_diag[next_block, next_block] = matrix; start += matrix.shape[0]. return block_diag. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.6;  · . PSI4. Module code; psi4.driver.p4util.numpy_helper. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/numpy_helper.html:15084,Validat,Validate,15084,psi4manual/1.6.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/numpy_helper.html,4,['Validat'],"['Validate', 'ValidationError']"
Security,"nclude deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise Validat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:13241,Validat,ValidationError,13241,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,8,['Validat'],['ValidationError']
Security,"nclude deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise Validatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:13355,Validat,ValidationError,13355,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,3,['Validat'],['ValidationError']
Security,"nction Couterpoise Total Energy'] = vmfc_energy_body_dict[metadata['max_nbody']]; nbody_dict['Valiron-Mayer Function Couterpoise Interaction Energy'] = vmfc_interaction_energy. for n in nbody_range[1:]:; var_key = 'VMFC-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]. # Returns; results = {}; results['nbody'] = nbody_dict; for b in ['cp', 'nocp', 'vmfc']:; if monomer_energies != 0.0:; results['%s_energy_body_dict' % b] = eval('%s_energy_body_dict' % b); results['%s_energy_body_dict' % b] = {str(i) + b: j for i, j in results['%s_energy_body_dict' % b].items()}; else:; results['%s_energy_body_dict' % b] = {}. # Figure out and build return types; return_method = metadata['bsse_type_list'][0]. if return_method == 'cp':; results['ptype_body_dict'] = cp_ptype_body_dict; results['energy_body_dict'] = cp_energy_body_dict; elif return_method == 'nocp':; results['ptype_body_dict'] = nocp_ptype_body_dict; results['energy_body_dict'] = nocp_energy_body_dict; elif return_method == 'vmfc':; results['ptype_body_dict'] = vmfc_ptype_body_dict; results['energy_body_dict'] = vmfc_energy_body_dict; else:; raise ValidationError(; ""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). if metadata['return_total_data']:; results['ret_energy'] = results['energy_body_dict'][metadata['max_nbody']]; else:; results['ret_energy'] = results['energy_body_dict'][metadata['max_nbody']]; results['ret_energy'] -= results['energy_body_dict'][1]. if metadata['ptype'] != 'energy':; if metadata['return_total_data']:; np_final_ptype = results['ptype_body_dict'][metadata['max_nbody']].copy(); else:; np_final_ptype = results['ptype_body_dict'][metadata['max_nbody']].copy(); np_final_ptype -= results['ptype_body_dict'][1]. results['ret_ptype'] = core.Matrix.from_array(np_final_ptype); else:; results['ret_ptype'] = results['ret_energy']. if monomer_energies == 0.0:; del results['energy_body_dict']. re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:29659,Validat,ValidationError,29659,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['Validat'],['ValidationError']
Security,"nction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(client=client); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver.name} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.Matrix.from_array(ret); wfn.set_gradient(ret); elif self.driver == 'hessian':; ret = core.Matrix.from_array(ret); grad = core.Matrix.from_array(nbody_model.properties.return_gradient); wfn.set_hessian(ret); wfn.set_gradient(grad). if return_wfn:; return (ret, wfn); else:; return ret. # TODO questions to check:; # * can work with supersystem and embedding_charges?; # * can levels work with same method, different basis?. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; psi4.driver.driver_nbody. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:93018,Validat,ValidationError,93018,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"nction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(client=client); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver.name} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.Matrix.from_array(ret); wfn.set_gradient(ret); elif self.driver == 'hessian':; ret = core.Matrix.from_array(ret); grad = core.Matrix.from_array(nbody_model.properties.return_gradient); wfn.set_hessian(ret); wfn.set_gradient(grad). if return_wfn:; return (ret, wfn); else:; return ret. # TODO questions to check:; # * can work with supersystem and embedding_charges?; # * can levels work with same method, different basis?. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.driver_nbody. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_nbody.html:92898,Validat,ValidationError,92898,psi4manual/1.9.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"nction encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if core.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). return core.adc(ref_wfn). def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; core.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name in ['mp', 'mp2', 'mp3', 'mp4']:; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'MPN', 'TRUE'); if name == 'mp2':; level = 2; elif name == 'mp3':; level = 3; elif name == 'mp4':; level = 4; else:; level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name == 'ccsd':; # untested; core.set_local_opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:89873,Validat,ValidationError,89873,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"nction. set(self: psi4.core.Vector, arg0: int, arg1: float) -> None. docstring. set(self: psi4.core.Vector, arg0: int, arg1: int, arg2: float) -> None. docstring. to_array(matrix, copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data)¶; Converts an object with a .nph accessor to a serialized dictionary. array_interface(self: psi4.core.Vector) → list. dim(self: psi4.core.Vector, arg0: int) → int; docstring. classmethod from_array(arr, name='New Matrix', dim1=None, dim2=None); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters:; arr (array or list of arrays) – Numpy array or list of arrays to use as the data for a new core.Matrix; name (str) – Name to give the new core.Matrix; dim1 (list, tuple, or core.Dimension (optional)) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 – Same as dim1 only if using a Psi4.Dimension object. Returns:matrix – Returns the given Psi4 object. Return type:Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; 1; 2>>> data = np.random.rand(20); >>> vect",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html:4020,access,accessor,4020,psi4manual/1.1.0/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html,1,['access'],['accessor']
Security,"ncyrepr; # fmcs['Method'][methods[mtd].latex][mc] = fancyrepr; # fmcs['Options'][mod][mc] = fancyrepr; # fmcs['Basis Treatment'][bases[bas].latex][mc] = fancyrepr; # return fmcs. [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; return {db: odb.integer_reactions() for db, odb in self.dbdict.items()}. [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""For each component database, loads qcdb.ReactionDatums from; standard location for *project* :module dbse_project and function; load_project. Module search path can be prepended with *pythonpath*. """"""; for db, odb in self.dbdict.items():; odb.load_qcdata_byproject(project, pythonpath=pythonpath); self._intersect_modelchems(). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""For each component database, loads qcdb.ReactionDatums from; HDF5 file at path/dbse_project.h5 . If path not given, looks in; qcdb/data. This file is written by reap-DB and so has been largely; validated. """"""; for db, odb in self.dbdict.items():; odb.load_qcdata_hdf5_trusted(project, path=path); self._intersect_modelchems(). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; for db, odb in self.dbdict.items():; odb.load_qcdata_hrxn_byproject(project, path=path); self._intersect_modelchems(). [docs] def available_projects(self, path=None):; """"""""""""; import glob. if path is None:; path = os.path.dirname(__file__) + '/../data'. projects = []; for pjfn in glob.glob(path + '/*_hrxn_*.pickle'):; pj = pjfn[:-7].split('_')[-1]; projects.append(pj). complete_projects = []; for pj in set(projects):; if all([os.path.isfile(path + '/' + db + '_hrxn_' + pj + '.pickle') for db in self.dbdict.keys()]):; complete_projects.append(pj). return complete_projects. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""For each component database, loads subsets from all functions; in module *modname*. Default *modname* usues standard ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:51650,validat,validated,51650,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['validat'],['validated']
Security,"nd care needs to be taken when using these; views. Views can be created in two ways:; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; 1>>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; 1; 2; 3; 4; 5; 6; 7; 8>>> dim = psi4.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.Matrix(""New Matrix"", dim, dim). # Create a list of Psi4 arrays; >>> list_of_arrays = irreped_mat.to_array(). # Or, use the .nph irreped accessor; >>> irreped_mat.nph[0][:] = 1. Where .nph is the irreped accessor form. If .np or np.array are; called on irreped Matrices or Vectors an error will be thrown; however, the; irreped form is always valid for non-irreped matrices. Array to Matrix¶; A general function that converts PSI4 data objects to NumPy arrays. psi4.driver.p4util.numpy_helper.array_to_matrix(self, arr, name='New Matrix', dim1=None, dim2=None)[source]¶; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters:; arr (array or list of arrays) – Numpy array or list of arrays to use as the data for a new core.Matrix; name (str) – Name to give the new core.Matrix; dim1 (list, tuple, or core.Dimension (optional)) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 – Same as dim1 only if using a psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/numpy-1.html:2467,access,accessor,2467,psi4manual/1.2.1/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/numpy-1.html,4,['access'],['accessor']
Security,"nd not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # no analytic derivatives for scf_type cd; if psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError('No analytic derivatives for SCF_TYPE CD.'). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:33842,Validat,ValidationError,33842,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"nd validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*. Parameters; ----------; mb_computer; Class of task computers to instantiate and add to self.task_list. Usually :class:`~psi4.driver.AtomicComputer` but may be other when wrappers are layered.; mc_level_idx; Position in field self.nbodies_per_mc_level used to obtain ``nbodies``, the list of n-body; levels (e.g., `[1]` or `[1, 2]` or `[""supersys",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:35635,validat,validator,35635,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,3,['validat'],['validator']
Security,"nd('-grad'); try:; #print('command', command); dashout = subprocess.Popen(command, stdout=subprocess.PIPE, env=lenv); except OSError as e:; raise ValidationError('Program gcp not found in path. %s' % e); out, err = dashout.communicate(). # Parse output; success = False; for line in out.splitlines():; line = line.decode('utf-8'); if re.match(' Egcp:', line):; sline = line.split(); dashd = float(sline[1]); if re.match(' normal termination of gCP', line):; success = True. if not success:; os.chdir(current_directory); raise Dftd3Error(""""""Unsuccessful gCP run.""""""). # Parse grad output; if dertype != 0:; derivfile = './gcp_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program gcp gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Prepare results for Psi4; if isP4regime and dertype != 0:; core.set_variable('GCP CORRECTION ENERGY', dashd); psi_dashdderiv = core.Matrix(self.natom(), 3); psi_dashdderiv.set(dashdderiv). # Print program output to file if verbose; if not verbose and isP4regime:; verbose = True if core.get_option('SCF', 'PRINT') >= 3 else False; if verbose:. text = '\n ==> GCP Output <==\n'; text += out.decode('utf-8'); if dertype != 0:; with open(derivfile, 'r') as handle:; text += handle.read().replace('D', 'E'); text += '\n'; if isP4regime:; core.print_out(text); else:; print(text). # # Clean up files and remove scratch directory; # os.unlink(paramfile1); # os.unlink(paramfile2); # os.unlink(geomfile); # if dertype != 0:; # os.unlink(derivfile); # if defmoved is True:; # os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); # try:; # shutil.rmtree(dftd3_tmpdir); # except OSError as e:; # ValidationError('Un",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html:9185,Validat,ValidationError,9185,psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,1,['Validat'],['ValidationError']
Security,"nd('-grad'); try:; #print('command', command); dashout = subprocess.Popen(command, stdout=subprocess.PIPE, env=lenv); except OSError as e:; raise ValidationError('Program gcp not found in path. %s' % e); out, err = dashout.communicate(). # Parse output; success = False; for line in out.splitlines():; line = line.decode('utf-8'); if re.match(' Egcp:', line):; sline = line.split(); dashd = float(sline[1]); if re.match(' normal termination of gCP', line):; success = True. if not success:; os.chdir(current_directory); raise Dftd3Error(""""""Unsuccessful gCP run.""""""). # Parse grad output; if dertype != 0:; derivfile = './gcp_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program gcp gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Prepare results for Psi4; if isP4regime and dertype != 0:; core.set_variable('GCP CORRECTION ENERGY', dashd); psi_dashdderiv = core.Matrix.from_list(dashdderiv). # Print program output to file if verbose; if not verbose and isP4regime:; verbose = True if core.get_option('SCF', 'PRINT') >= 3 else False; if verbose:. text = '\n ==> GCP Output <==\n'; text += out.decode('utf-8'); if dertype != 0:; with open(derivfile, 'r') as handle:; text += handle.read().replace('D', 'E'); text += '\n'; if isP4regime:; core.print_out(text); else:; print(text). # # Clean up files and remove scratch directory; # os.unlink(paramfile1); # os.unlink(paramfile2); # os.unlink(geomfile); # if dertype != 0:; # os.unlink(derivfile); # if defmoved is True:; # os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); # try:; # shutil.rmtree(dftd3_tmpdir); # except OSError as e:; # ValidationError('Unable to remove dftd3 tempor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_gcp.html:9210,Validat,ValidationError,9210,psi4manual/1.2.1/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_gcp.html,1,['Validat'],['ValidationError']
Security,"ndent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructionsM += """"""# (1) Run all of the OPT-%s-*.in input files on any variety of computer architecture.\n"""""" % (str(opt_iter)); instructionsM += """"""# The output file names must be as given below.\n#\n""""""; for rgt in range(ndisp):; pre = 'OPT-' + str(opt_iter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# OPT-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the gradient step in its output file.\n#\n""""""; if opt_iter == 1:; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:27316,access,accessed,27316,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['access'],['accessed']
Security,"ndent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructionsM += """"""# (1) Run all of the OPT-%s-*.in input files on any variety of computer architecture.\n"""""" % (str(opt_iter)); instructionsM += """"""# The output file names must be as given below.\n#\n""""""; for rgt in range(ndisp):; pre = 'OPT-' + str(opt_iter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# OPT-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the gradient step in its output file.\n#\n""""""; if opt_iter == 1:; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:36750,access,accessed,36750,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['access'],['accessed']
Security,"ne %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Molecule::create_molecule_from_string: Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Molecule::create_molecule_from_string: Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom +",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:21345,Validat,ValidationError,21345,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"ne Electron Integral Algorithm Overview¶; The following table summarizes which implementation is used; for each type of one electron integral in PSI4. Algorithms used for One Electron Integrals¶. Integral; Class; Implementation; Comment. Three-Center Overlap; ThreeCenterOverlapInt; Libint2; using libint2::Operator::delta for 4-center integrals. Angular Momentum; AngularMomentumInt; M-D. Dipole; DipoleInt; Libint2; no derivatives supported. Electric Field; ElectricFieldInt; Libint2; using first derivative of libint2::Operator::nuclear. Coulomb Potential; ElectrostaticInt; Libint2; evaluated for a single origin and unity charge. Kinetic; KineticInt; Libint2. Multipole Potential; MultipolePotentialInt; M-D; arbitrary order derivative of 1/R supported. Multipole Moments; MultipoleInt; M-D; arbitrary order multipoles supported, including nuclear gradients. Nabla Operator; NablaInt; Libint2; using first derivative of libint2::Operator::overlap. Overlap; OverlapInt; Libint2. Nuclear Coulomb Potential; PotentialInt; Libint2; assumes nuclear centers/charges as the potential. PCM Potential; PCMPotentialInt; Libint2; parallelized over charge points. Quadrupole; QuadrupoleInt; Libint2. Traceless Quadrupole; TracelessQuadrupoleInt; Libint2. Relativistic Potential; RelPotentialInt; Libint2. table of contents. Integrals in PSI4; Introduction; The older style; The new syntax; Sieving; Buffer address; Density Screening; Shell blocking; Permutational symmetry; Using bra-ket symmetry; Instantiating integral objects. One Electron Integrals in PSI4; Calling compute_shell(int P, int Q); Accessing integrals; Derivative Integrals; Changes to External Potential Engines; New Operators Available; Shell Pairs; One Electron Integral Algorithm Overview. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Integrals in PSI4. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/prog_integrals.html:19028,Access,Accessing,19028,psi4manual/1.7.x/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/prog_integrals.html,1,['Access'],['Accessing']
Security,"ne in geometry specification: %s' % (line)). # catch last default fragment cgmp; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1). # Now go through the rest of the lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; zmatrix = False; for line in glines:. # handle fragment markers; if frag.match(line):; ifrag += 1; self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); tempfrag = []. # handle atom markers; else:; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomm = atom.match(line.split()[0].strip().upper()); atomLabel = atomm.group('label'); atomSym = atomm.group('symbol'). # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; ghostAtom = False if (atomm.group('gh1') is None and atomm.group('gh2') is None) else True. # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Molecule::create_molecule_from_string: Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; atomMass = el2mass[atomSym] if atomm.group('mass') is None else float(atomm.group('mass')); charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:18389,Validat,ValidationError,18389,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"ne order Cn and Sn of principal axis.; Cn_z = matrix_3d_rotation_Cn(geom, z_axis, False, tol); if verbose > 2:; print("""""" Highest rotation axis (Cn_z) : %d"""""" % (Cn_z)). Sn_z = matrix_3d_rotation_Cn(geom, z_axis, True, tol); if verbose > 2:; print("""""" Rotation axis (Sn_z) : %d"""""" % (Sn_z)). # Check for sigma_h (xy plane).; op_sigma_h = False; for at in range(self.natom()):; if abs(geom[at][2]) < tol:; continue # atom is in xy plane; else:; test_atom = [geom[at][0], geom[at][1], -1 * geom[at][2]]; if not atom_present_in_geom(geom, test_atom, tol):; break; else:; op_sigma_h = True; if verbose > 2:; print("""""" sigma_h : %s"""""" % ('yes' if op_sigma_h else 'no')). # Rotate one off-axis atom to the yz plane and check for sigma_v's.; for at in range(self.natom()):; dist_from_z = math.sqrt(geom[at][0] * geom[at][0] + geom[at][1] * geom[at][1]); if abs(dist_from_z) > tol:; pivot_atom_i = at; break. if pivot_atom_i == self.natom(): # needs to be in else clause?; raise ValidationError(""Molecule::set_full_point_group: Not a linear molecule but could not find off-axis atom.""). # Rotate around z-axis to put pivot atom in the yz plane; xy_point = normalize([geom[pivot_atom_i][0], geom[pivot_atom_i][1], 0]); ddot = dot(y_axis, xy_point); if abs(ddot - 1) < 1.0e-10:; phi = 0.0; elif abs(ddot + 1) < 1.0e-10:; phi = math.pi; else:; phi = math.acos(ddot). is_D = False; if abs(phi) > 1.0e-14:; test_mat = matrix_3d_rotation(geom, z_axis, phi, False); if verbose > 2:; print("""""" Rotating by %8.3e to get atom %d in yz-plane ..."""""" % (phi, pivot_atom_i + 1)); geom = [row[:] for row in test_mat]. # Check for sigma_v (yz plane).; op_sigma_v = False; for at in range(self.natom()):; if abs(geom[at][0]) < tol:; continue # atom is in yz plane; else:; test_atom = [-1 * geom[at][0], geom[at][1], geom[at][2]]; if not atom_present_in_geom(geom, test_atom, tol):; break; else:; #if at == self.natom():; op_sigma_v = True; if verbose > 2:; print("""""" sigma_v : %s"""""" % ('yes' if op_sigma_v else 'no')). print(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:67224,Validat,ValidationError,67224,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"ne, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specific",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:20352,Validat,ValidationError,20352,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"ne, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:20532,Validat,ValidationError,20532,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function.; # Establish function to call; if not('xx_func' in kwargs):; if ('func' in kwargs):; kwargs['xx_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['xx_func'] = energy; func = kwargs['xx_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper xx is unhappy to be calling function \'%s\'.' % (func.__name__)). If specific interoperabilities are known, code them in. For example, if xx shouldn’t call db, add the last two lines above to the xx function. If db shouldn’t call xx, add the following two lines below to the db function.; if (func is xx):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'.' % (func.__name__)). Create a multipart test case that runs some intercalls between your function and others (akin to pywrap_all). In trials, permute the order of calls a few times to expose any calls that don’t clean up after themselves and need further attention. When all is validated, add your findings to the great Permitted nesting of Psithon functions table in the documentation. Previous topic; Plugins: Adding New Functionality to PSI4; Next topic; Documentation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/bestpractices_py-1.html:6013,Validat,ValidationError,6013,psi4manual/4.0b3/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/bestpractices_py-1.html,6,"['Validat', 'expose', 'validat']","['ValidationError', 'expose', 'validated']"
Security,"near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function.; # Establish function to call; if not('xx_func' in kwargs):; if ('func' in kwargs):; kwargs['xx_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['xx_func'] = energy; func = kwargs['xx_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper xx is unhappy to be calling function \'%s\'.' % (func.__name__)). If specific interoperabilities are known, code them in. For example, if xx shouldn’t call db, add the last two lines above to the xx function. If db shouldn’t call xx, add the following two lines below to the db function.; if (func is xx):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'.' % (func.__name__)). Create a multipart test case that runs some intercalls between your function and others (akin to pywrap_all). In trials, permute the order of calls a few times to expose any calls that don’t clean up after themselves and need further attention. When all is validated, add your findings to the great Permitted nesting of Psithon functions table in the documentation. Previous topic; Plugins: Adding New Functionality to PSI4; Next topic; Documentation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/bestpractices_py-1.html:6013,Validat,ValidationError,6013,psi4manual/4.0b4/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/bestpractices_py-1.html,6,"['Validat', 'expose', 'validat']","['ValidationError', 'expose', 'validated']"
Security,"near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function.; # Establish function to call; if not('xx_func' in kwargs):; if ('func' in kwargs):; kwargs['xx_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['xx_func'] = energy; func = kwargs['xx_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper xx is unhappy to be calling function \'%s\'.' % (func.__name__)). If specific interoperabilities are known, code them in. For example, if xx shouldn’t call db, add the last two lines above to the xx function. If db shouldn’t call xx, add the following two lines below to the db function.; if (func is xx):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'.' % (func.__name__)). Create a multipart test case that runs some intercalls between your function and others (akin to pywrap_all). In trials, permute the order of calls a few times to expose any calls that don’t clean up after themselves and need further attention. When all is validated, add your findings to the great Permitted nesting of Psithon functions table in the documentation. Previous topic; Plugins: Adding New Functionality to PSI4; Next topic; Documentation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/bestpractices_py-1.html:6005,Validat,ValidationError,6005,psi4manual/4.0b5/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/bestpractices_py-1.html,6,"['Validat', 'expose', 'validat']","['ValidationError', 'expose', 'validated']"
Security,"nergies with nice labels.   N-BODY (1, 2)@(1, 2) TOTAL ENERGY;   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   N-BODY (3)@(2, 3) TOTAL ENERGY;   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_energy; ntasks; always; all individual energies.   1_((1, 2), (1, 2));   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_gradient; ntasks; when driver is g/h; all individual gradients.   1_((1, 2), (1, 2));   (nat, 3); when driver is g/h; total gradient for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat, 3); when driver is g/h; total gradient for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_hessian; ntasks; when driver is h; all individual Hessians.   1_((1, 2), (1, 2));   (nat*3, nat*3); when driver is h; total Hessian for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat*3, nat*3); when driver is h; total Hessian for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. validator set_bsse_type  »  bsse_type[source]¶. validator set_embedding_charges  »  embedding_charges[source]¶. validator set_max_nbody  »  max_nbody[source]¶. validator set_molecule  »  molecule[source]¶. validator set_nfragments  »  nfragments[source]¶. validator set_return_total_data  »  return_total_data[source]¶. table of contents. Basis Set Superposition Corrections; API. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Basis Set Superposition Corrections. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/nbody.html:32242,validat,validator,32242,psi4manual/1.7.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/nbody.html,6,['validat'],['validator']
Security,"nergy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.0`. Returns; -------; float or numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [5]_:; :math:`E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}`. References; ----------. .. [5] Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson,; Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] CISD extrapolation; >>> energy('cbs', corl_wfn='cisd', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2'). """"""; if type(valueLO) != type(valueHI):; raise ValidationError(; f""corl_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.0. if isinstance(valueLO, float):; value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = f""""""\n\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n\n""""""; cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += f"""""" Beta (coefficient) Value: {beta: 16.12f}\n\n""""""; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; # Note that in energy-only days, this used to print SCF and Correlation, not Total, Energy. name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:18946,Validat,ValidationError,18946,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Validat'],['ValidationError']
Security,"next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle option_molecule_name in; molecule optional_molecule_name {...}. The molecular geometry can be got and set and manipulated as a; Matrix object. Below shows how to access; coordinates in an input file in Python.; molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms as Python array. geom2psi = psi4.Matrix(4, 3) # initialize psi4.Matrix; geom2psi.set(geom2py) # load Python array into psi4.Matrix; geom2psi.scale(1.0/psi_bohr2angstroms) # scale into bohr; geom2psi.print_out() # print alternate coord array to output file. formaldehyde.set_geometry(geom2psi) # load alternate c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithonmol.html:17243,access,access,17243,psi4manual/master/psithonmol.html,https://psicode.org,https://psicode.org/psi4manual/master/psithonmol.html,9,['access'],['access']
Security,"ng files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; from typing import Dict, List, Union. import numpy as np; from qcelemental.models import AtomicInput; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver_findif; from psi4.driver.p4util.exceptions import ValidationError. _engine_can_do = collections.OrderedDict([('libdisp', ['d1', 'd2', 'chg', 'das2009', 'das2010']),; ('dftd3', ['d2', 'd3zero', 'd3bj', 'd3mzero', 'd3mbj']),; ('nl', ['nl']),; ('mp2d', ['dmp2']),; (""dftd4"", [""d4bjeeqatm""]),; ]) # yapf: disable. _capable_engines_for_disp = collections.defaultdict(list); for eng, disps in _engine_can_do.items():; for disp in disps:; _capable_engines_for_disp[disp].append(eng). [docs]class EmpiricalDispersion(object):; """"""Lightweight unification of empirical dispersion calculation modes. Attributes; ----------; dashlevel : str; {'d1', 'd2', 'd3zero', 'd3bj', 'd3mzero', 'd3mbj', 'chg', 'das2009', 'das2010', 'nl', 'dmp2', ""d4bjeeqatm""}; Name of dispersion correction to be applied. Resolved; from `name_hint` and/or `level_hint` into a key of; `empirical_dispersion_resources.dashcoeff`.; dashparams : dict; Complete set of parameter values defining the flexible parts; of :py:attr:`dashlevel`. Number and parameter names vary by; :py:attr:`dashle",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html:1450,Validat,ValidationError,1450,psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,2,['Validat'],['ValidationError']
Security,"ng files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; from typing import Dict, List, Union. import numpy as np; from qcelemental.models import AtomicInput; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver_findif; from psi4.driver.p4util.exceptions import ValidationError. _engine_can_do = collections.OrderedDict([('libdisp', ['d1', 'd2', 'chg', 'das2009', 'das2010']),; ('dftd3', ['d2', 'd3zero', 'd3bj', 'd3mzero', 'd3mbj']),; ('nl', ['nl']),; ('mp2d', ['dmp2']),; ]) # yapf: disable. _capable_engines_for_disp = collections.defaultdict(list); for eng, disps in _engine_can_do.items():; for disp in disps:; _capable_engines_for_disp[disp].append(eng). [docs]class EmpiricalDispersion(object):; """"""Lightweight unification of empirical dispersion calculation modes. Attributes; ----------; dashlevel : str; {'d1', 'd2', 'd3zero', 'd3bj', 'd3mzero', 'd3mbj', 'chg', 'das2009', 'das2010', 'nl', 'dmp2'}; Name of dispersion correction to be applied. Resolved; from `name_hint` and/or `level_hint` into a key of; `empirical_dispersion_resources.dashcoeff`.; dashparams : dict; Complete set of parameter values defining the flexible parts; of :py:attr:`dashlevel`. Number and parameter names vary by; :py:attr:`dashlevel`. Resolved into a complete set (keys o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html:1450,Validat,ValidationError,1450,psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['Validat'],['ValidationError']
Security,"ng input file sets up a DF-CCSD(T); computation using CD integrals; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; cc_type cd; basis aug-cc-pvdz; freeze_core true; }; energy('ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. 1e-9). Gn theory¶; The FNOCC module contains all the components that comprise the Gn family; of composite methods. Currently, only the G2 method is supported; [Curtiss:1991:7221]. The G2 procedure may be called through the; energy() wrapper:; energy('gaussian-2'). Supported methods¶; The various methods supported by the FNOCC module in PSI4 are; summarized in Table FNOCC Methods; and detailed (except FNO) in Table FNOCC Capabilities. Note that these methods are implemented; for closed-shell reference only. Without set qc_module fnocc,; these methods may default to implementations in other modules. Theoretical methods accessible through FNOCC¶. name; calls method; plain; FNO. mp3; third-order MP perturbation theory; E; E. mp4(sdq); fourth-order MP perturbation theory, less triples; E; E. mp4; full fourth-order MP perturbation theory; E; E. cisd; configuration interaction singles and doubles; E; E. qcisd; quadratic configuration interaction singles doubles; E; E. qcisd(t); QCISD with perturbative triples; E; E. lccd; linear coupled cluster doubles; E; E. cepa(0), lccsd; coupled electron pair approximation, variant 0; E; E. cepa(1); coupled electron pair approximation, variant 1; E; E. cepa(3); coupled electron pair approximation, variant 3; E; E. acpf; averaged coupled-pair functional; E; E. aqcc; averaged quadratic coupled-cluster; E; E. ccsd; coupled cluster singles and doubles; E; E. ccsd(t); coupled cluster singles and doubles with perturbative triples; E; E. Detailed capabilities of the FNOCC module. “✓” runs analytically. Single underline “✓̲” is default module when QC_MODULE unspecified. Double u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/fnocc.html:12945,access,accessible,12945,psi4manual/master/fnocc.html,https://psicode.org,https://psicode.org/psi4manual/master/fnocc.html,4,['access'],['accessible']
Security,"ng""; }; },; ""required"": [; ""driver"",; ""method""; ]; }; }; }. Fields:. basis (str); bsse_type (List[psi4.driver.driver_nbody.BsseEnum]); driver (qcelemental.models.common_models.DriverEnum); embedding_charges (Dict[int, List[float]]); keywords (Dict[str, Any]); max_nbody (int); method (str); molecule (Any); nbodies_per_mc_level (List[List[int | Literal['supersystem']]]); nfragments (int); quiet (bool); return_total_data (bool | None); task_list (Dict[str, psi4.driver.task_base.AtomicComputer | psi4.driver.driver_cbs.CompositeComputer | psi4.driver.driver_findif.FiniteDifferenceComputer]). Validators:. set_bsse_type » bsse_type; set_embedding_charges » embedding_charges; set_max_nbody » max_nbody; set_molecule » molecule; set_nfragments » nfragments; set_return_total_data » return_total_data. field basis: str = '(auto)'¶. field bsse_type: List[BsseEnum] = [BsseEnum.cp]¶; Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned. Validated by:. set_bsse_type. field driver: DriverEnum [Required]¶; The computation driver; i.e., energy, gradient, hessian. field embedding_charges: Dict[int, List[float]] = {}¶; Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment. Validated by:. set_embedding_charges. field keywords: Dict[str, Any] = {}¶; The computation keywords/options. field max_nbody: int = -1¶; Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments. Validated by:. set_max_nbody. field method: str = '(auto)'¶. field molecule: Any [Required]¶; The target molecule, if not the last molecule defined. Validated by:. set_molecule. field nbodies_per_mc_level: List[List[Union[int, Literal['supersystem']]]] = []¶; Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/nbody.html:15376,Validat,Validated,15376,psi4manual/master/nbody.html,https://psicode.org,https://psicode.org/psi4manual/master/nbody.html,3,['Validat'],['Validated']
Security,"nkage=None, keys=None):; """"""Evaluate the output file status of jobs in *zmats* which should; exist at *dir* + '/' + prefix + '-' + job + '.out'. Returns string with; formatted summary of job status and boolean of whether all complete.; Return boolean *isOk* signals whether all *zmats* have completed and,; if *validate_func* present, are validated. """"""; isOk = True; msgError = ''; instructions = '\n'; instructions += p4util.banner(prefix + ' Status: ' + datetime.datetime.now().strftime(""%Y-%m-%d %H:%M""), strNotOutfile=True); instructions += '\n'; for job in sorted(zmats):; outfile = dir + '/' + prefix + '-' + job + '.out'; fjafile = dir + '/' + prefix + '-' + job + '.fja'; formatArgs = [prefix + '-' + job, '', '', '', '']; if os.path.isfile(outfile):; with open(outfile, 'r') as handle:; for line in handle:; if line.find('Buy a developer a beer!') > -1:; formatArgs[3] = 'Completed'; if reap_job_validate is not None:; isOkJob, msg, temp = reap_job_validate(dir, prefix, job, linkage, keys); if isOkJob:; formatArgs[4] = '& Validated'; else:; isOk = False; msgError += msg; formatArgs[4] = 'INVALID'; break; else:; isOk = False; formatArgs[2] = 'Running'; elif os.path.isfile(fjafile):; formatArgs[3] = 'Completed'; else:; isOk = False; formatArgs[1] = 'Waiting'; instructions += """""" {0:<27} {1:^10} {2:^10} {3:^10} {4:^10}\n"""""".format(*formatArgs); instructions += '\n' + msgError + '\n\n'. return isOk, instructions. [docs]def reap_job_validate(dir, prefix, item, linkage, keys):; """"""For a given output file whose path is constructed with; *dir* + '/' + *prefix* + '-' + *item* + '.out', tests that the file; exists and has *prefix* RESULTS lines for each piece of information; requested in list *keys* and that those lines correspond to the; appropriate *linkage* and *item*. Returns *keys* along with their; scanned values in dict *reapings*, along with error and success; messages in *instructions* and a boolean *isOk* indicating whether; all *keys* reaped sucessfully. """"""; isOk = Tr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:28846,Validat,Validated,28846,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,1,['Validat'],['Validated']
Security,"nly Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters; ----------; expected : file; Reference Molden file against which `computed` is compared.; computed : file; Input Molden file to compare against `expected`.; atol_exponent : int or float; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label : str; Label for passed and error messages. """"""; def moldenfile_to_string(fname):; with open(fname, 'r') as fn:; molden_string = fn.read(); return molden_string. ref = moldenfile_to_string(expected).splitlines(); calc = moldenfile_to_string(computed).splitlines(); if len(ref) != len(calc):; raise ValidationError(f""These two molden files have different lengths...\n""). high_accuracy = atol_exponent; index = 0; max_len = len(calc); tests = []; section = 0. geom_re = re.compile(r'^\s*(\w*)\s+(\d+)\s+(\d+)\s+(-?\d+.\d+)\s+(-?\d+.\d+)\s+(-?\d+.\d+)\s*$'); basis_header_re = re.compile(r'^\s*([s,p,d,f,g])\s*(\d*)\s*(\d*.\d*)\s*$'); s1_re = re.compile(r'^\s*(\d+.?\d*)\s+(\d+.?\d*)$'); s2_re = re.compile(r'^\s*(\d+)\s+(-?\d+.\d+[e,E][\+,-]\d+)\s*$'); sym_re = re.compile(r'^\s*Sym\s*=\s*(\w*)\s*$'); energy_re = re.compile(r'^\s*Ene\s*=\s*(-?\d*.?\d*[e,E]?\+?-?\d*)\s*$'); spin_re = re.compile(r'^\s*Spin\s*=\s*(\w*)\s*$'); occ_re = re.compile(r'^\s*Occup\s*=\s*(-?\d*.\d*[e,E]?-?\+?\d*)\s*$'). for i in range(max_len):; line = calc[i]. if geom_re.match(line):; c1, c2, c3, c4, c5, c6 = geom_re.match(line).groups(); r1, r2, r3, r4, r5, r6 = geom_re.match(line).groups(); test = compare_strings(r1, c1) and compare_integers(r2, c2) and compare_integers(r3, c3) and compare_values(r4, c4, high_accuracy) and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fchk.html:6375,Validat,ValidationError,6375,psi4manual/1.6.x/_modules/psi4/driver/p4util/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fchk.html,1,['Validat'],['ValidationError']
Security,"nly a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exported via Boost Python) documented thereat; are accessible through the handle option_molecule_name in; molecule optional_molecule_name {...}. The molecular geometry can be got and set and manipulated as a; psi4.Matrix object. Below shows how to access; coordinates in an input file in Python.; molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms as Python array. geom2psi = psi4.Matrix(4, 3) # initialize psi4.Matrix; geom2psi.set(geom2py) # l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:15938,access,accessible,15938,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,2,['access'],['accessible']
Security,"nocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). core.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level.upper()). if name in ['fno-lccd', 'fno-lccsd', 'fno-cepa(0)', 'fno-cepa(1)', 'fno-cepa(3)',; 'fno-acpf', 'fno-aqcc', 'fno-cisd']:; core.set_local_option('FNOCC', 'NAT_ORBS', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). reference = core.get_option('SCF', 'REFERENCE'); if core.get_global_option('CC_TYPE') != ""CONV"":; raise ValidationError(""""""CEPA methods from FNOCC module require 'cc_type conv'.""""""). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:161783,Validat,ValidationError,161783,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"nocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). core.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level.upper()). if name in ['fno-lccd', 'fno-lccsd', 'fno-cepa(0)', 'fno-cepa(1)', 'fno-cepa(3)',; 'fno-acpf', 'fno-aqcc', 'fno-cisd']:; core.set_local_option('FNOCC', 'NAT_ORBS', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). reference = core.get_option('SCF', 'REFERENCE'); if core.get_global_option('CC_TYPE') != ""CONV"":; raise ValidationError(""""""CEPA methods from FNOCC module require 'cc_type conv'.""""""). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:170394,Validat,ValidationError,170394,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Molecule::create_molecule_from_string: Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Molecule::create_molecule_from_string: Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); self.set_has_zmatrix(zmatrix). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:22186,Validat,ValidationError,22186,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. reap_job_validate(dir, prefix, item, linkage, keys)[source]¶; For a given output file whose path is constructed with; dir + ‘/’ + prefix + ‘-‘ + item + ‘.out’, tests that the file; exists and has prefix RESULTS lines for each piece of information; requested in list keys and that those lines correspond to the; appropriate linkage and item. Returns keys along with their; scanned values in dict reapings, along with error and success; messages in instructions and a boolean isOk indicating whether; all keys reaped sucessfully. run_cfour_module(xmod)[source]¶. sown_jobs_status(dir, prefix, zmats, validate_func=None, linkage=None, keys=None)[source]¶; Evaluate the output file status of jobs in zmats which should; exist at dir + ‘/’ + prefix + ‘-‘ + job + ‘.out’. Returns string with; formatted summary of job status and boolean of whether all complete.; Return boolean isOk signals whether all zmats have completed and,; if validate_func present, are validated. vpt2(name, **kwargs)[source]¶; Perform vibrational second-order perturbation computation through; Cfour to get anharmonic frequencies. This version uses c4 for the disp; and pt2 but gets gradients from p4. Parameters:c4full (boolean) – 'on' || 'off' ; Indicates whether when name indicates a Cfour method and mode; indicates a sow/reap approach, sown files are direct ZMAT files; and FJOBARC files are expected to reap, so that Cfour only, not; Cfour-through-Psi4, is needed for distributed jobs. Caution; Some features are not yet implemented. Buy a developer a coffee. Presently uses all gradients. Could mix in analytic 2nd-derivs.; Collect resutls.; Manage scratch / subdir better.; Untangle CCSD(T) vs CCSD[T] and FJOBARC issue; Allow CFOUR_BASIS; Consider forcing some tighter convcrit, c4 and p4; sow/reap; mixed ang/bohr signals; error by converting to ang in psi?; Expand CURRENT DIPOLE XYZ beyond SCF; Remember additional FJOBARC recor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:147208,validat,validated,147208,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['validat'],['validated']
Security,"not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference freq run in one job or files farmed out; freq_mode = kwargs.pop('mode', 'continuous').lower(); if freq_mode == 'continuous':; pass; elif freq_mode == 'sow':; if dertype == 2:; raise ValidationError(""""""Frequency execution mode 'sow' not valid for analytic Hessian calculation.""""""); elif freq_mode == 'reap':; freq_linkage = kwargs.get('linkage', None); if freq_linkage is None:; raise ValidationError(""""""Frequency execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; if dertype == 2:; core.print_out(""""""hessian() switching to finite difference by gradients for partial Hessian calculation.\n""""""); dertype = 1. # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; G0 = gradient(lowername, molecule=molecule, **kwargs); translations_projection_sound, ro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:69125,Validat,ValidationError,69125,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"not of form [(at1, at2, bondorder), ...]: {}"".format(connectivity); ). if units.capitalize() in [""Angstrom"", ""Bohr""]:; molinit[""units""] = units.capitalize(); else:; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. def validate_and_fill_frame(extern, fix_com=None, fix_orientation=None, fix_symmetry=None):. if fix_com is True:; com = True; elif fix_com is False:; if extern:; raise ValidationError(""Invalid fix_com ({}) with extern ({})"".format(fix_com, extern)); else:; com = False; elif fix_com is None:; com = extern; else:; raise ValidationError(""Invalid fix_com: {}"".format(fix_com)). if fix_orientation is True:; orient = True; elif fix_orientation is False:; if extern:; raise ValidationError(""Invalid fix_orientation ({}) with extern ({})"".format(fix_orientation, extern)); else:; orient = False; elif fix_orientation is None:; orient = extern; else:; raise ValidationError(""Invalid fix_orientation: {}"".format(fix_orientation)). symm = None; if extern:; if fix_symmetry is None:; symm = ""c1""; elif fix_symmetry.lower() == ""c1"":; symm = ""c1""; else:; raise ValidationError(""Invalid (non-C1) fix_symmetry ({}) with extern ({})"".format(fix_symmetry, extern)); else:; if fix_symmetry is not None:; symm = fix_symmetry.lower(). molinit = {}; molinit[""fix_com""] = com; molinit[""fix_orientation""] = orient; if symm:; molinit[""fix_symmetry""] = symm. return molinit. def validate_and_fill_efp(fragment_files=None, hint_types=None, geom_hints=None):. if (; fragment_files is None; or hint_types is None; or ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:15274,Validat,ValidationError,15274,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions used by several Python functions."""""". __all__ = [; ""all_casings"",; ""drop_duplicates"",; ""expand_psivars"",; ""format_molecule_for_input"",; ""format_options_for_input"",; ""get_psifile"",; ""getattr_ignorecase"",; ""hold_options_state"",; ""import_ignorecase"",; ""kwargs_lower"",; ""mat2arr"",; ""prepare_options_for_modules"",; ""prepare_options_for_set_options"",; ""provenance_stamp"",; ""plump_qcvar"",; ""state_to_atomicinput"",; ]. import os; import ast; import sys; import math; import pickle; import inspect; import warnings; from contextlib import contextmanager; import collections; from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Union; from types import ModuleType. import numpy as np; from qcelemental.models import AtomicInput. from psi4 import core; from psi4.metadata import __version__; from .exceptions import ValidationError; from . import p4regex. [docs]def kwargs_lower(kwargs: Dict[str, Any]) -> Dict[str, Any]:; """"""Function to rebuild and return *kwargs* dictionary sanitized. Should be; called by every function that could be called directly by the user. Parameters; ----------; kwargs; Input kwargs for any user-facing function. Returns; -------; lowered : Dict[str, Any]; Sanitized kwargs with all keys made lowercase. Also turns boolean-like; values into actual booleans. Also turns values lowercase if sensible. """"""; caseless_kwargs = {}; for key, value in kwargs.items():; lkey = key.lower(); if lkey in ['subset', 'banner', 'restart_file', 'write_orbitals']: # only kw for which case matters; lvalue = value; else:; try:; lvalue = value.lower(); except (AttributeError, KeyError):; lvalue = value. if lkey in ['irrep', 'check_bsse', 'linkage', 'bsse_type']:; caseless_kwargs[lkey] = lvalue. elif 'dertype' in lkey:; if p4regex.der0th.match(str(lvalue)):; caseless_kwargs[lkey] = 0; elif p4regex.der1st",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html:1978,Validat,ValidationError,1978,psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,1,['Validat'],['ValidationError']
Security,"np. from psi4.driver import psifiles as psif; from psi4.driver.p4util.testing import compare_integers, compare_values, compare_recursive; from psi4.driver.procrouting.proc_util import check_iwl_file_from_scf_type. from psi4 import core; from .exceptions import ValidationError, TestComparisonError. [docs]def fcidump(wfn: core.Wavefunction, fname: str = 'INTDUMP', oe_ints: Optional[List] = None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989),; https://doi.org/10.1016/0010-4655(89)90033-7 .; Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. Parameters; ----------; wfn; Set of molecule, basis, orbitals from which to generate FCIDUMP file.; fname; Name of the integrals file, defaults to INTDUMP.; oe_ints; List of additional one-electron integrals to save to file. So far only; EIGENVALUES is a valid option. Raises; ------; ValidationError; When SCF wavefunction is not RHF. Examples; --------. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html:2347,Validat,ValidationError,2347,psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,1,['Validat'],['ValidationError']
Security,"np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if nam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:130859,Validat,ValidationError,130859,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,6,['Validat'],['ValidationError']
Security,"ns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or string; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availabilit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:70134,access,accesses,70134,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['access'],['accesses']
Security,"ns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file (``'continuous'``) or are to be farmed out in an; embarrassingly parallel fashion (``'sow'``/``'reap'``)/ For the latter,; run an initial job with ``'sow'`` and follow instructions in its output file.; For maximum flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:81791,access,accesses,81791,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['access'],['accesses']
Security,"ns; Section author: Lori A. Burns. psi4.driver.wrapper_database.database(name, db_name[, func, mode, cp, rlxd, symm, zpe, benchmark, tabulate, subset])[source]¶; Function to access the molecule objects and reference energies of; popular chemical databases. Aliases; db(). Returns; (float) Mean absolute deviation of the database in kcal/mol. PSI variables. db_name DATABASE MEAN SIGNED DEVIATION; db_name DATABASE MEAN ABSOLUTE DEVIATION; db_name DATABASE ROOT-MEAN-SQUARE DEVIATION; Python dictionaries of results accessible as DB_RGT and DB_RXN. Note; It is very easy to make a database from a collection of xyz files; using the script psi4/psi4/share/psi4/scripts/ixyz2database.py.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters. name (str) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). db_name (str) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/share/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – \(\Rightarrow\) energy \(\Leftarrow\) || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keywo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:1134,access,access,1134,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,5,['access'],['access']
Security,"nsity at this point only for density-based props; if (n_one > 0 or n_two > 0):; if (name.lower() == 'eom-ccsd'):; psi4.set_global_option('WFN', 'EOM_CCSD'); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cceom(); elif (name.lower() == 'eom-cc2'):; psi4.set_global_option('WFN', 'EOM_CC2'); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cceom(); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cclambda(); psi4.ccdensity(). # Need ccresponse only for response-type props; if (n_response > 0):; psi4.set_global_option('DERTYPE', 'RESPONSE'); psi4.cclambda(); for prop in response:; psi4.set_global_option('PROPERTY', prop); psi4.ccresponse(). # Excited-state transition properties; if (n_excited > 0):; if (name.lower() == 'eom-ccsd'):; psi4.set_global_option('WFN', 'EOM_CCSD'); elif (name.lower() == 'eom-cc2'):; psi4.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""Unknown excited-state CC wave function.""); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cceom(); psi4.cclambda(); psi4.ccdensity(). psi4.set_global_option('WFN', 'SCF'); psi4.revoke_global_option_changed('WFN'); psi4.set_global_option('DERTYPE', 'NONE'); psi4.revoke_global_option_changed('DERTYPE'). [docs]def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). psi4.set_global_option('ONEPDM', 'TRUE'); psi4.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; #psi4.set_local_option('SCF', 'SCF_TYPE', 'DF') # insufficient b/c SCF option read in DFMP2; psi4.set_global_option('SCF_TYPE', 'DF'). if not psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 properties need DF-SCF reference,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:31689,Validat,ValidationError,31689,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"nstance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). elif xyzC.match(text[2 + i]):. fileAtom = int(float(xyzC.match(text[2 + i]).group(1))); fileX = float(xyzC.match(text[2 + i]).group(2)); fileY = float(xyzC.match(text[2 + i]).group(3)); fileZ = float(xyzC.match(text[2 + i]).group(4)). # Check that the atomic number is valid; if not fileAtom in z2el:; raise ValidationError('Illegal atom symbol in geometry specification: %d' % (fileAtom)). # Add it to the molecule.; instance.add_atom(fileAtom, fileX, fileY, fileZ, z2el[fileAtom], z2mass[fileAtom], fileAtom). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. @classmethod; [docs] def init_with_mol2(cls, xyzfilename,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:5213,Validat,ValidationError,5213,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"nstance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). elif xyzC.match(text[2 + i]):. fileAtom = int(float(xyzC.match(text[2 + i]).group(1))); fileX = float(xyzC.match(text[2 + i]).group(2)); fileY = float(xyzC.match(text[2 + i]).group(3)); fileZ = float(xyzC.match(text[2 + i]).group(4)). # Check that the atomic number is valid; if not fileAtom in z2el:; raise ValidationError('Illegal atom symbol in geometry specification: %d' % (fileAtom)). # Add it to the molecule.; instance.add_atom(fileAtom, fileX, fileY, fileZ, z2el[fileAtom], z2mass[fileAtom], fileAtom). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d.\n%s:%s"" %; (i + 3, xyzfilename, text[i + 2])); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3,; text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.PYinput_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.PYinput_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. @classmethod; def ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:7878,Validat,ValidationError,7878,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"nt group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays()¶; Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Angstrom', return_type='json')¶; Serializes instance into JSON or YAML according to schema dtype. to_string(dtype, units='Angstrom', atom_format=None, ghost_format=None, width=17, prec=12)¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg2. units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:31773,hash,hash,31773,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,3,['hash'],['hash']
Security,"ntGroups['C1']; # the number of irreps in this pg; self.PYnirrep = 0; # an array of irreps; self.PYgamma = 0; # the matrices describing sym ops; self.symop = 0; # index of the inverse symop; self.inv = 0; # the Schoenflies symbol for the pg; self.symb = 0; # Bitwise representation of the symmetry operations; self.PYbits = 0. # Divert to constructor functions; if len(args) == 0:; pass; elif len(args) == 1 and \; isinstance(args[0], basestring):; self.constructor_schoenflies(*args); elif len(args) == 1 and \; isinstance(args[0], int):; self.constructor_bits(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_schoenflies(self, cpg):; """"""This constructor takes the Schoenflies symbol of a point group; as input. """"""; self.symb = cpg; # Check the symbol coming in; self.PYbits = PointGroup.full_name_to_bits(cpg); if self.PYbits is None:; raise ValidationError('CharacterTable: Invalid point group name: %s\n' % (cpg)); self.common_init(). [docs] def constructor_bits(self, bits):; """"""This constructor takes the bitswise representation of a point; group as input. """"""; self.PYbits = bits; self.symb = PointGroup.bits_to_basic_name(bits); self.common_init(). [docs] def common_init(self):; """"""First parse the point group symbol, this will give us the; order of the point group(g), the type of point group (pg), the; order of the principle rotation axis (nt), and the number of; irreps (nirrep). """"""; if len(self.symb) == 0:; raise ValidationError('CharacterTable::CharacterTable: null point group'); if self.make_table() < 0:; raise ValidationError('CharacterTable::CharacterTable: could not make table'). # CharacterTable(const CharacterTable&);; #CharacterTable::CharacterTable(const CharacterTable& ct); # : nt(0), pg(PointGroups::C1), nirrep_(0), gamma_(0), symop(0), _inv(0), symb(0),; # bits_(0); #{; # *this = ct;; #}; #; #; # CharacterTable& operator=(const Character",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:21577,Validat,ValidationError,21577,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security,"nt_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose); if return_dict:; return core.Molecule.from_dict(molrec), molrec; else:; return core.Molecule.from_dict(molrec). @classmethod; def _molecule_from_schema(cls, molschema: Dict, return_dict: bool = False, nonphysical: bool = False, verbose: int = 1) -> Union[core.Molecule, Tuple[core.Molecule, Dict]]:; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~psi4.core.Molecule.from_arrays`. Parameters; ----------; molschema; Dictionary form of Molecule following known schema.; return_dict; Additionally return Molecule dictionary intermediate.; nonphysical; Do allow masses outside an element's natural range to pass validation?; verbose; Amount of printing. Returns; -------; mol : :py:class:`psi4.core.Molecule`; molrec : dict; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_schema(molschema, nonphysical=nonphysical, verbose=verbose). qmol = core.Molecule.from_dict(molrec); geom = np.array(molrec[""geom""]).reshape((-1, 3)); qmol._initial_cartesian = core.Matrix.from_array(geom). if return_dict:; return qmol, molrec; else:; return qmol. [docs]def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the core.Molecule class. """"""; cls.__setattr__ = molecule_set_attr; cls.__getattr__ = molecule_get_attr. cls.to_arrays = qcdb.Molecule.to_arrays; cls.to_dict = qcdb.Molecule.to_dict; cls.BFS = qcdb.Molecule.BFS; cls.B787 = qcdb.Molecule.B787; cls.scramble = qcdb.Molecule.scramble; cls.from_arrays = _molecule_from_arrays; cls.from_string = _molecule_from_string; cls.to_string = qcdb.Molecule.to_string; c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html:5124,validat,validation,5124,psi4manual/1.4.0/_modules/psi4/driver/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/molutil.html,4,['validat'],['validation']
Security,"nt_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] I'm leaving MRCC CC2 in as a route, but my c.2014 MRCC consistently yields:; # ""Approximate CC methods are not implemented for excitation level 2!""; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and whi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:33244,access,access,33244,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['access'],['access']
Security,"nt_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce (someday) if name is function; if hasattr(name, '__call__'):; raise ValidationError(""Frequency: Cannot use custom function""). lowername = name.lower(). if ""/"" in lowername:; return driver_cbs._cbs_gufunc(frequency, name, ptype='frequency', **kwargs). if kwargs.get('bsse_type', None) is not None:; raise ValdiationError(""Frequency: Does not currently support 'bsse_type' arguements""). return_wfn = kwargs.pop('return_wfn', False). # are we in sow/reap mode?; freq_mode = kwargs.get('mode', 'continuous').lower(); if freq_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(lowername, return_wfn=True, molecule=molecule, **kwargs). # S/R: Quit after getting new displacements; if freq_mode == 'sow':; return 0.0. # Project final frequencies?; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(wfn.gradient()); project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); vibonly = qcdb.vib.filter_nonvib(vibinfo); wfn.set_frequencies(core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data))); wfn.frequency_analysis = vibinfo. for po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:88914,Validat,ValidationError,88914,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). -o <filename>, --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: when the input filename is “input.dat”,; then the output filename defaults to “output.dat”. Otherwise, the; output filename defaults to the the input filename with any; any “.in” or “.dat” extension replaced by “.out”. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -s <name>, --scratch <name>¶; This overrides the value of PSI_SCRATCH and provides; a path to the location of scratch files. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -V, --version¶; Print version information.; 1; 2>>> psi4 --version; 0.4.262. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; Configuring PSI4 through PSIPATH is preferred; to modifying this environment variable. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that PSI4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc fi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/external-1.html:18044,access,access,18044,psi4manual/1.2.1/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/external-1.html,4,['access'],['access']
Security,"nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). -o <filename>, --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: when the input filename is “input.dat”,; then the output filename defaults to “output.dat”. Otherwise, the; output filename defaults to the the input filename with any; any ”.in” or ”.dat” extension replaced by ”.out”. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -s <name>, --scratch <name>¶; This overrides the value of PSI_SCRATCH and provides; a path to the location of scratch files. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -V, --version¶; Print version information.; 1; 2>>> psi4 --version; 0.4.262. Environment Variables¶; These environment variables will influence PSI4‘s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; Configuring PSI4 through PSIPATH is preferred; to modifying this environment variable. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that PSI4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc fi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:17933,access,access,17933,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,2,['access'],['access']
Security,"ntinue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError (""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); view = _get_raw_views(ret)[0]; view[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError (""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def _to_array(matrix, copy=True, dense=False):; """"""; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters; ----------; matrix : :py:class:`~psi4.core.Matrix` or :py:class:`~psi4.core.Vector`; Pointers to which Psi4 core class should be used in the construction.; copy : bool; Copy the data if True, return a view otherwise; dense : bool; Converts irreped Psi4 objects to diagonally blocked dense ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:5656,Validat,ValidationError,5656,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"ntly used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs] @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs] @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs] @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs] @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs] @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs] @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs] def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*. Parameters; ----------; mb_computer; Class of task computers to instantiate and add to self.task_list. Usually :class:`~psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:35329,validat,validator,35329,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,1,['validat'],['validator']
Security,"nto a blank file. Exclamation points denote comments.; As the first line of the file, add the basis set name in brackets.; As the second line of the file, add the word spherical or cartesian to indicate; whether the basis set will run in (5D/7F) or (6D/10F).; The combination of [basis name], PUREAM value, and element basis set specifications; forms a section, like the one shown below.; Multiple basis sets can be specified in the same file by adding additional sections to the file.; Specify the location of the new basis set file in a PSI4 input file with the command; basis file path/to/basis.file, where the path can be either relative or absolute.; [ sto-3g ]; cartesian; ****; H 0; S 3 1.00; 3.42525091 0.15432897; 0.62391373 0.53532814; 0.16885540 0.44463454; ****; O 0; S 3 1.00; 130.7093200 0.15432897; 23.8088610 0.53532814; 6.4436083 0.44463454; SP 3 1.00; 5.0331513 -0.09996723 0.15591627; 1.1695961 0.39951283 0.60768372; 0.3803890 0.70011547 0.39195739; ****. Request the new basis set in an input file in the usual manner.; set basis new_basis_name. (3) Include new basis set in input file.; Construct for a basis set a section like the one above that includes; [basis name], PUREAM; value, and element basis set specifications. Hash signs denote comments.; Copy the section into a PSI4 input file and surround it with the command basis {...},; as shown below.; Multiple basis sets can be specified by adding additional sections within the surrounding brackets.; basis {; # basis set section like in snippet above goes here; # additional basis set sections follow; }. Previous topic; Customization: Adding Simple Extensions; Next topic; Defining a Method Alias; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Customization: Adding Simple Extensions ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/quickaddbasis-1.html:2647,Hash,Hash,2647,psi4manual/4.0b3/quickaddbasis-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/quickaddbasis-1.html,2,['Hash'],['Hash']
Security,"nto a blank file. Exclamation points denote comments.; As the first line of the file, add the basis set name in brackets.; As the second line of the file, add the word spherical or cartesian to indicate; whether the basis set will run in (5D/7F) or (6D/10F).; The combination of [basis name], PUREAM value, and element basis set specifications; forms a section, like the one shown below.; Multiple basis sets can be specified in the same file by adding additional sections to the file.; Specify the location of the new basis set file in a PSI4 input file with the command; basis file path/to/basis.file, where the path can be either relative or absolute.; [ sto-3g ]; cartesian; ****; H 0; S 3 1.00; 3.42525091 0.15432897; 0.62391373 0.53532814; 0.16885540 0.44463454; ****; O 0; S 3 1.00; 130.7093200 0.15432897; 23.8088610 0.53532814; 6.4436083 0.44463454; SP 3 1.00; 5.0331513 -0.09996723 0.15591627; 1.1695961 0.39951283 0.60768372; 0.3803890 0.70011547 0.39195739; ****. Request the new basis set in an input file in the usual manner.; set basis new_basis_name. (3) Include new basis set in input file.; Construct for a basis set a section like the one above that includes; [basis name], PUREAM; value, and element basis set specifications. Hash signs denote comments.; Copy the section into a PSI4 input file and surround it with the command basis {...},; as shown below.; Multiple basis sets can be specified by adding additional sections within the surrounding brackets.; basis {; # basis set section like in snippet above goes here; # additional basis set sections follow; }. Previous topic; Customization: Adding Simple Extensions; Next topic; Defining a Method Alias; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/quickaddbasis-1.html:2647,Hash,Hash,2647,psi4manual/4.0b4/quickaddbasis-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickaddbasis-1.html,2,['Hash'],['Hash']
Security,"nto a blank file. Exclamation points denote comments.; As the first line of the file, add the basis set name in brackets.; As the second line of the file, add the word spherical or cartesian to indicate; whether the basis set will run in (5D/7F) or (6D/10F).; The combination of [basis name], PUREAM value, and element basis set specifications; forms a section, like the one shown below.; Multiple basis sets can be specified in the same file by adding additional sections to the file.; Specify the location of the new basis set file in a PSI4 input file with the command; basis file path/to/basis.file, where the path can be either relative or absolute.; [ sto-3g ]; cartesian; ****; H 0; S 3 1.00; 3.42525091 0.15432897; 0.62391373 0.53532814; 0.16885540 0.44463454; ****; O 0; S 3 1.00; 130.7093200 0.15432897; 23.8088610 0.53532814; 6.4436083 0.44463454; SP 3 1.00; 5.0331513 -0.09996723 0.15591627; 1.1695961 0.39951283 0.60768372; 0.3803890 0.70011547 0.39195739; ****. Request the new basis set in an input file in the usual manner.; set basis new_basis_name. (3) Include new basis set in input file.; Construct for a basis set a section like the one above that includes; [basis name], PUREAM; value, and element basis set specifications. Hash signs denote comments.; Copy the section into a PSI4 input file and surround it with the command basis {...},; as shown below.; Multiple basis sets can be specified by adding additional sections within the surrounding brackets.; basis {; # basis set section like in snippet above goes here; # additional basis set sections follow; }. Previous topic; Customization: Adding Simple Extensions; Next topic; Defining a Method Alias; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Customization: Adding Simple Extensions ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/quickaddbasis-1.html:2647,Hash,Hash,2647,psi4manual/4.0b5/quickaddbasis-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/quickaddbasis-1.html,2,['Hash'],['Hash']
Security,"ntract HCl single-point energy Testing the in line -decontract option for basis sets. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. soscf2; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dft1-alt; DFT Functional Test. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dcft-grad3; Restricted DF-DCFT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradients. scf5; Test of all different algorithms and reference types for SCF, on singlet and tri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html:3941,Access,Accesses,3941,psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,4,['Access'],['Accesses']
Security,"ntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Molecule::create_molecule_from_string: Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:20102,Validat,ValidationError,20102,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"nts (1, 2).; ...; N-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-Body: Computing complex (1/1) with fragments (1, 2) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2): -257.41867403127321); ...; ==> N-Body: Counterpoise Corrected (CP) energies <==. n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]; 1 -257.418648109779 0.000000000000 0.000000000000; 2 -257.418674031273 -0.016265984132 -0.016265984132. And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; 1; 2; 3; 4; 5; 6; 7CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:22389,access,accessed,22389,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,6,['access'],['accessed']
Security,"nts (1, 2).; ...; N-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-Body: Computing complex (1/1) with fragments (1, 2) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2): -257.41867403127321); ...; ==> N-Body: Counterpoise Corrected (CP) energies <==. n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]; 1 -257.418648109779 0.000000000000 0.000000000000; 2 -257.418674031273 -0.016265984132 -0.016265984132. And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/tutorial.html:22227,access,accessed,22227,psi4manual/master/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/master/tutorial.html,9,['access'],['accessed']
Security,"nts vector3 class to Justin M. Turney and; incremental improvements by other psi4 developers. """"""; from __future__ import absolute_import; from __future__ import print_function; import math; import copy; from .exceptions import *. ZERO = 1.0E-14. [docs]def norm(v):; """"""Compute the magnitude of vector *v*.""""""; return math.sqrt(sum(v[i] * v[i] for i in range(len(v)))). [docs]def add(v, u):; """"""Compute sum of vectors *v* and *u*.""""""; return [u[i] + v[i] for i in range(len(v))]. [docs]def sub(v, u):; """"""Compute difference of vectors *v* - *u*.""""""; return [v[i] - u[i] for i in range(len(v))]. [docs]def dot(v, u):; """"""Compute dot product of vectors *v* and *u*.""""""; return sum(u[i] * v[i] for i in range(len(v))). [docs]def scale(v, d):; """"""Compute by-element scale by *d* of vector *v*.""""""; return [d * v[i] for i in range(len(v))]. [docs]def naivemult(v, u):; """"""Compute by-element multiplication of vectors *v* and *u*.""""""; if len(u) != len(v):; raise ValidationError('naivemult() only defined for vectors of same length \n'); return [u[i] * v[i] for i in range(len(v))]. [docs]def normalize(v):; """"""Compute normalized vector *v*.""""""; vmag = norm(v); return [v[i] / vmag for i in range(len(v))]. [docs]def distance(v, u):; """"""Compute the distance between points defined by vectors *v* and *u*.""""""; return norm(sub(v, u)). [docs]def cross(v, u):; """"""Compute cross product of length 3 vectors *v* and *u*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('cross() only defined for vectors of length 3\n'); return [v[1] * u[2] - v[2] * u[1],; v[2] * u[0] - v[0] * u[2],; v[0] * u[1] - v[1] * u[0]]. [docs]def rotate(v, theta, axis):; """"""Rotate length 3 vector *v* about *axis* by *theta* radians.""""""; if len(v) != 3 or len(axis) != 3:; raise ValidationError('rotate() only defined for vectors of length 3\n'). unitaxis = normalize(copy.deepcopy(axis)); # split into parallel and perpendicular components along axis; parallel = scale(axis, dot(v, axis) / dot(axis, axis)); perpendicular = s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html:2008,Validat,ValidationError,2008,psi4manual/1.0.0/_modules/qcdb/vecutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html,1,['Validat'],['ValidationError']
Security,"nts.set_print(1); mints.integrals(). def check_non_symmetric_jk_density(name):; """"""; Ensure non-symmetric density matrices are supported for the selected JK routine.; """"""; scf_type = core.get_global_option('SCF_TYPE'); supp_jk_type = ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT', 'OUT_OF_CORE']; supp_string = ', '.join(supp_jk_type[:-1]) + ', or ' + supp_jk_type[-1] + '.'. if scf_type not in supp_jk_type:; raise ValidationError(""Method %s: Requires support for non-symmetric density matrices.\n""; "" Please set SCF_TYPE to %s"" % (name, supp_string)). def check_disk_df(name, optstash):. optstash.add_option(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE') or core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out(f"""""" For method '{name}', SCF Algorithm Type (re)set to DISK_DF.\n""""""); else:; if core.get_global_option('SCF_TYPE') == ""MEM_DF"":; raise ValidationError(; f"" Method '{name}' requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation.""; ). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d info",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:4522,Validat,ValidationError,4522,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,3,['Validat'],['ValidationError']
Security,"ntsbasisset — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.libmintsbasisset; from __future__ import absolute_import; from __future__ import print_function; from __future__ import division; import os; import re; import sys; import string; import hashlib; import itertools; from collections import defaultdict; try:; from collections import OrderedDict; except ImportError:; from .oldpymodules import OrderedDict; from .exceptions import *; from .psiutil import search_file; from .molecule import Molecule; from .periodictable import *; from .libmintsgshell import GaussianShell; from .libmintsbasissetparser import Gaussian94BasisSetParser; from .basislist import corresponding_basis; if sys.version_info >= (3,0):; basestring = str. [docs]class BasisSet(object):; """"""Basis set container class; Reads the basis set from a checkpoint file object. Also reads the molecule; from the checkpoint file storing the information in an internal Molecule class; which can be accessed using molecule(). """""". # <<< Globals >>>. # Has static information been initialized?; initialized_shared = False; # Global arrays of x, y, z exponents (Need libmint for max ang mom); LIBINT_MAX_AM = 6 # TODO; exp_ao = [[] for l in range(LIBINT_MAX_AM)]. def __init__(self, *args):. # <<< Basic BasisSet Information >>>. # The name of this basis set (e.g. ""BASIS"", ""RI BASIS""); self.name = None; # Array of gaussian shells; self.shells = None; # Molecule object.; self.molecule = None; # Shell information; self.atom_basis_shell = None. # <<< Scalars >>>. # Number of atomic orbitals (Cartesian); self.PYnao = None; # Number of basis functions (either cartesian or spherical); self.PYnbf = None; # The number of unique primitives; self.n_uprimitive = None; # The number of shells; self.n_shells = None; # The number of primitives; self.PYnprimitive = None; # The maximum angular momentum; self.PYmax_am = None; # The maximum number of primitives ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:1060,access,accessed,1060,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['access'],['accessed']
Security,"nue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1 . return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def to_array(matrix, copy=True, dense=False):; """"""; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view.; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. ret = []; for h in matrix.array_interfaces():; if 0 in h.__array_interface__[""shape""]:; ret.append(np.empty(shape = h.__array_interface__[""shape""])); else:; ret.append(np.array(h, copy=copy)). # Return the list of arrays; if dense is False:; return ret; ; # Build the dense matrix; if isinstance(matrix, psi4.Vector):; ret_type = '1D'; elif isinstance(matrix, psi4.Matrix):; ret_type = '2D'; else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % type(matrix)). dim1 = []; dim2 = []; for h in ret:; # Ignore zero dim irreps; if 0 in h.shape:; dim1.append(0); dim2.append(0); else:; dim1.append(h.shape[0]); if ret_type == '2D':; dim2.append(h.shape[1]). ndim1 = np.sum(dim1); ndim2 = np.sum(dim2); if ret_type == '1D':; dense_ret = np.zeros(shape=(ndim1)); start = 0; for d1, arr in zip(dim1, ret):; if d1 == 0: continue; dense_ret[start: start + d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, ret):; if d1 == 0: continue. dense_ret[start1: start1 + d1, start2: start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; if 0 in matrix.__array_interface__[""shape""]:; return np.empty(shape = matrix.__array_interface__[""shape""]); else:; return np.array(matrix, copy=copy). def _build_view(matrix):; """"""; Builds a view of the vector or matrix; """"""; views = to_array(matrix, copy=False, dense=F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:6719,Validat,ValidationError,6719,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"number in thermodynamic computations. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. tdscf-7; TD-HF test variable access. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. remp-energy2; integral conventional unrestricted REMP/cc-pVDZ energies for the H2O+ molecule. results were independently verified against the initial wavels implementation. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cepa-module; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:28071,access,access,28071,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['access'],['access']
Security,"nything that looks like a string in quotes; and to remove leading dollar signs from python variables. interactive¶. run()[source]¶. pubchem¶. class PubChemObj(cid, mf, iupac)[source]¶. getCartesian()[source]¶; Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. getMoleculeString()[source]¶; Function to obtain a molecule string through; getCartesian() or fail. getSDF()[source]¶; Function to return the SDF (structure-data file) of the PubChem object. getXYZFile()[source]¶; Function to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. name()[source]¶; Function to return the IUPAC name of the PubChem object. getPubChemResults(name)[source]¶; Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. psiexceptions¶; Module with non-generic exceptions classes. exception PsiException[source]¶; Error class for Psi. exception ValidationError(msg)[source]¶; Error called for problems with the input file. Prints; error message msg to standard output stream and output file. frac¶. frac_nuke(mol, **kwargs)[source]¶. frac_traverse(mol, **kwargs)[source]¶. ip_fitting(mol, omega_l, omega_r, **kwargs)[source]¶. molutil¶; Module with utility functions that act on molecule objects. BFS(self)[source]¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. activate(mol)[source]¶; Function to set molecule object mol as the current active molecule. dynamic_variable_bind(cls)[source]¶; Function to dynamically add extra members to; the psi4.Molecule class. extract_cluster_indexing(mol, cluster_size=0)[source]¶; Function to returns a LIST of all subclusters of the molecule mol of; real size cluster_size. If cluster_size = 0, returns all possible; combinations of c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:3788,Validat,ValidationError,3788,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['Validat'],['ValidationError']
Security,"o disk; if psi4.get_option('SCF', 'SCF_TYPE') == 'DF' or psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; mints = psi4.MintsHelper(); mints.integrals(). psi4.transqt2(); psi4.ccsort(); psi4.ccenergy(). if (lowername == 'ccsd(at)' or lowername == 'a-ccsd(t)'):; 	psi4.cchbar(); 	psi4.cclambda(). optstash.restore(). [docs]def run_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). psi4.set_global_option('DERTYPE', 'FIRST'). run_ccenergy(name, **kwargs); if (name.lower() == 'ccsd'):; psi4.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); psi4.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif (name.lower() == 'ccsd(t)'):; psi4.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); psi4.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). user_ref = psi4.get_option('CCENERGY', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'UHF'):; raise ValidationError('Reference %s for CCSD(T) gradients is not available.' % user_ref). psi4.cchbar(); psi4.cclambda(); psi4.ccdensity(); psi4.deriv(). optstash.restore(). [docs]def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'DELETE_TEI'],; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if (name.lower() == 'bccd'):; psi4.set_local_option('TRANSQT2', 'WFN', 'BCCD'); psi4.set_local_option('CCSORT', 'WFN', 'BCCD'); psi4.set_local_option('CCENERGY', 'WFN', 'BCCD'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') == 'DF' or psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; mints = psi4.MintsHelper(); mints.integr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:26231,Validat,ValidationError,26231,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"o evaluate (e.g., B3LYP, MP2, …). Validated by:. set_method. field molecule: Any [Required]¶; The molecule to use in the computation. field owner_group: Optional[str] = None¶; group in the chown sense. field priority: str = 1¶; The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}. field protocols: Union[AtomicResultProtocols, Dict[str, Any], None] = {'stdout': True}¶; Output modifications. field result: Any [Optional]¶; AtomicResult return. field result_id: Optional[str] = None¶; The optional ID for the computation. field tag: str = '*'¶; The tags to pass along to compute managers. compute(client=None)[source]¶; Run quantum chemistry. Parameters:; client (qcportal.client.FractalClient | None) – . get_results(client=None)[source]¶; Return results as Atomic-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None) – . Return type:; AtomicResult. plan()[source]¶; Form QCSchema input from member data.; :rtype: AtomicInput. Return type:; AtomicInput. validator set_basis  »  psi4.driver.AtomicComputer.basis[source]¶. validator set_keywords  »  psi4.driver.AtomicComputer.keywords[source]¶. validator set_method  »  psi4.driver.AtomicComputer.method[source]¶. table of contents. AtomicComputer; AtomicComputer; AtomicComputer.basis; AtomicComputer.computed; AtomicComputer.driver; AtomicComputer.keywords; AtomicComputer.method; AtomicComputer.molecule; AtomicComputer.owner_group; AtomicComputer.priority; AtomicComputer.protocols; AtomicComputer.result; AtomicComputer.result_id; AtomicComputer.tag; AtomicComputer.compute(); AtomicComputer.get_results(); AtomicComputer.plan(); AtomicComputer.set_basis; AtomicComputer.set_keywords; AtomicComputer.set_method. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; AtomicComputer. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.AtomicComputer.html:6589,validat,validator,6589,psi4manual/1.9.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.AtomicComputer.html,3,['validat'],['validator']
Security,"o optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. optstash = OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:31435,Validat,ValidationError,31435,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"o the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psicode downloads; page for the latest guides. Warning; As of v1.2rc1, new (conda build 3; updated compilers); conda packages are available for Linux but not Mac).; Psi4conda installers are not ready for either platform. PSI4 is available as a pre-compiled binary for Mac and Linux (and; Windows, through the Ubuntu shell) and native Windows architectures; through Anaconda (formerly Continuum Analytics, the company that produces; Anaconda Python (a; full-fledged scientific python environment with package manager conda) and, more particularly, Miniconda (a lightweight Python; distribution with same package manager conda). Some nice features for us:. cross-platform; no root, administrator, or sudo access required; built with high-performance math libraries; lightweight software stack (<100 MB w/o PSI4; ~1 GB including PSI4, numpy, and MKL); updated nightly so new features accessible; standardizes python distribution so no need to find/install libpython packages; add-ons (plugins, extra features requiring Fortran compiler, etc.) can be made available as conda packages; develop PSI4 through plugins without a pre-existing development environment, see Creating a New Plugin Using a Conda Pre-compiled Binary. The PSI4 binary repository is at Anaconda (formerly Binstar).; For commands to get a default installation, go to How to install a Psi4 binary with the Psi4conda installer, command-line; or the psicode downloads page .; Users proficient with conda may prefer to consult What do the conda packages psi4 & psi4-dev and the installer psi4conda contain.; For more flexibility and a detailed explanation, go to; Detailed Installation of Miniconda and Detailed Installation of . How to install a Psi4 binary with the Psi4conda installer, download site¶; Download one of the nine installers (Linux/Mac/Windows; Py38/39/310).; bash it. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/conda.html:1142,access,access,1142,psi4manual/master/conda.html,https://psicode.org,https://psicode.org/psi4manual/master/conda.html,6,['access'],"['access', 'accessible']"
Security,"o_shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * qcel.constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_completion,; run_mirror=do_mirror,; verbose=verbose). compare_integers(; True, np.allclose(solution.shift, perturbation.shift, atol=6), 'shifts equiv', verbose=verbose - 1); if not do_resort:; compare_integers(; True,; np.allclose(solution.rotation.T, perturbation.rotation),; 'rotations transpose',; verbose=verbose - 1); if solution.mirror:; compare_integers(True, do_mirror, 'mirror allowed', verbose=verbose - 1). def set_fragment_pattern(self, frl, frt, frc, frm):; """"""Set fragment member data through public method analogous to psi4.core.Molecule"""""". if not (len(frl) == len(frt) == len(frc) == len(frm)):; raise ValidationError(""""""Molecule::set_fragment_pattern: fragment arguments not of same length.""""""). self.fragments = frl; self.fragment_types = frt; self.fragment_charges = frc; self.fragment_multiplicities = frm. # Attach methods to qcdb.Molecule class; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol = _parker_xyz2mol_yo. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; psi4.driver.qcdb.molecule. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:67275,Validat,ValidationError,67275,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"oaded from Psi4 LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = qcdb.options.reconcile_options(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = qcdb.options.prepare_options_for_cfour(userkw). # Handle text to be passed untouched to cfour; litcmd = core.get_global_option('LITERAL_CFOUR'). # Assemble ZMAT pieces; zmat = memcmd + molcmd + optcmd + mdccmd + psicmd + bascmd + litcmd. if len(re.findall(r'^\*(ACES2|CFOUR|CRAPS)\(', zmat, re.MULTILINE)) != 1:; core.print_out('\n Faulty ZMAT constructed:\n%s' % (zmat)); raise ValidationError(""""""; Multiple *CFOUR(...) blocks in input. This usually arises; because molecule or options are specified both the psi4 way through; molecule {...} and set ... and the cfour way through cfour {...}.""""""). return zmat. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.procrouting.interface_cfour. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html:17031,Validat,ValidationError,17031,psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,1,['Validat'],['ValidationError']
Security,"oaded from Psi4 LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = qcdb.options.reconcile_options(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = qcdb.options.prepare_options_for_cfour(userkw). # Handle text to be passed untouched to cfour; litcmd = core.get_global_option('LITERAL_CFOUR'). # Assemble ZMAT pieces; zmat = memcmd + molcmd + optcmd + mdccmd + psicmd + bascmd + litcmd. if len(re.findall(r'^\*(ACES2|CFOUR|CRAPS)\(', zmat, re.MULTILINE)) != 1:; core.print_out('\n Faulty ZMAT constructed:\n%s' % (zmat)); raise ValidationError(""""""; Multiple *CFOUR(...) blocks in input. This usually arises; because molecule or options are specified both the psi4 way through; molecule {...} and set ... and the cfour way through cfour {...}.""""""). return zmat. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.5;  · . PSI4. Module code; psi4.driver.procrouting.interface_cfour. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/interface_cfour.html:17172,Validat,ValidationError,17172,psi4manual/1.5.0/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/interface_cfour.html,1,['Validat'],['ValidationError']
Security,"oat(f) for f in fr]; except (ValueError, TypeError):; raise ValidationError(""""""Un float-able elements in geom_hints[{}]: {}"""""".format(ifr, fr)). htype = hint_types[ifr]; if len(hint) == hlen[htype]:; hints.append(hint); else:; raise ValidationError(""""""EFP hint type {} not {} elements: {}"""""".format(htype, hlen[htype], hint)). return {""fragment_files"": files, ""hint_types"": types, ""geom_hints"": hints}. def validate_and_fill_geometry(geom=None, tooclose=0.1, copy=True):; """"""Check `geom` for overlapping atoms. Return flattened"""""". npgeom = np.array(geom, copy=copy, dtype=float).reshape((-1, 3)). # Upper triangular; metric = tooclose ** 2; tooclose_inds = []; for x in range(npgeom.shape[0]):; diffs = npgeom[x] - npgeom[x + 1 :]; dists = np.einsum(""ij,ij->i"", diffs, diffs). # Record issues; if np.any(dists < metric):; indices = np.where(dists < metric)[0]; tooclose_inds.extend([(x, y, dist) for y, dist in zip(indices + x + 1, dists[indices] ** 0.5)]). if tooclose_inds:; raise ValidationError(; """"""Following atoms are too close: {}"""""".format([(i, j, dist) for i, j, dist in tooclose_inds]); ). return {""geom"": npgeom.reshape((-1))}. def validate_and_fill_nuclei(; nat,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; # processing details; speclabel=True,; nonphysical=False,; mtol=1.0e-3,; verbose=1,; ):; """"""Check the nuclear identity arrays for consistency and fill in knowable values."""""". if elea is None:; elea = np.asarray([None] * nat); else:; # -1 equivalent to None; elea = np.asarray(elea); if -1 in elea:; elea = np.array([(None if at == -1 else at) for at in elea]) # Rebuild to change dtype if needed. if elez is None:; elez = np.asarray([None] * nat); else:; elez = np.asarray(elez). if elem is None:; elem = np.asarray([None] * nat); else:; elem = np.asarray(elem). if mass is None:; mass = np.asarray([None] * nat); else:; mass = np.asarray(mass). if real is None:; real = np.asarray([None] * nat); else:; real = np.asarray(real). if elbl is None:; elbl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:18098,Validat,ValidationError,18098,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"ob; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union, TYPE_CHECKING. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import DriverEnum, AtomicResult; from qcelemental import constants. from psi4 import core; from psi4.driver import p4util, pp, qcdb, nppp10; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil siz",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:4913,Validat,ValidationError,4913,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,1,['Validat'],['ValidationError']
Security,"obal_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n""); if banner:; core.print_out("" "" + banner.center(58)); if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58)); ref_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(ref_wfn). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(ref_wfn, ""_disp_functor""):; disp_energy = ref_wfn._disp_functor.compute_energy(ref_wfn.molecule()); ref_wfn.set_variable(""-D Energy"", disp_energy); ref_wfn.compute_energy(). # broken clean-up; if do_broken:; raise ValidationError(""Broken Symmetry computations are temporarily disabled.""); scf_molecule.set_multiplicity(1); core.set_local_option('SCF', 'GUESS', 'READ'); core.print_out('\n'); p4util.banner(' Computing broken symmetry solution from high-spin triplet guess '); core.print_out('\n'). # cast clean-up; if cast:. # Move files to proper namespace; core.IO.change_file_namespace(180, guesspace, namespace); core.IO.set_default_namespace(namespace). optstash2.restore(). # Print the banner for the standard operation; core.print_out('\n'); p4util.banner(bannername.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n""); core.print_out("" "" + banner.center(58)). scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(scf_wfn). # The wfn from_file routine adds the npy suf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:45251,Validat,ValidationError,45251,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"obal_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""Unknown excited-state CC wave function.""); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cceom(); psi4.cclambda(); psi4.ccdensity(). psi4.set_global_option('WFN', 'SCF'); psi4.revoke_global_option_changed('WFN'); psi4.set_global_option('DERTYPE', 'NONE'); psi4.revoke_global_option_changed('DERTYPE'). [docs]def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). psi4.set_global_option('ONEPDM', 'TRUE'); psi4.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; #psi4.set_local_option('SCF', 'SCF_TYPE', 'DF') # insufficient b/c SCF option read in DFMP2; psi4.set_global_option('SCF_TYPE', 'DF'). if not psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 properties need DF-SCF reference, for now.'). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(psi4.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:32635,Validat,ValidationError,32635,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"obj, **kwargs)[source]¶. compute(client=None)[source]¶. Parameters:; client (qcportal.FractalClient | None). get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. molecule; dummy basis, def2-svp; e/g/h member data; QCVariables; module if simple. client (qcportal.FractalClient | None). Returns:. ret – Energy, gradient, or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. Return type:; float | Matrix | Tuple[float | Matrix, Wavefunction]. get_results(client=None)[source]¶; Return results as Composite-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None). Return type:; AtomicResult. plan()[source]¶. validator set_molecule  »  molecule[source]¶. table of contents. Complete Basis Set; Output; Extrapolation Schemes; xtpl_highest_1(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(); scf_xtpl_helgaker_3(); corl_xtpl_helgaker_2(); _get_default_xtpl(); register_xtpl_function(). Aliases; sherrill_gold_standard(); allen_focal_point(); register_composite_function(). API; CompositeComputer; CompositeComputer.basis; CompositeComputer.cbsrec; CompositeComputer.compute_list; CompositeComputer.driver; CompositeComputer.keywords; CompositeComputer.metadata; CompositeComputer.metameta; CompositeComputer.method; CompositeComputer.molecule; CompositeComputer.results_list; CompositeComputer.task_list; CompositeComputer.trove; CompositeComputer.verbose; CompositeComputer.build_tasks(); CompositeComputer.compute(); CompositeComputer.get_psi_results(); CompositeComputer.get_results(); CompositeComputer.plan(); CompositeComputer.set_molecule. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .  ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cbs.html:40666,validat,validator,40666,psi4manual/master/cbs.html,https://psicode.org,https://psicode.org/psi4manual/master/cbs.html,1,['validat'],['validator']
Security,"ocedure `ip_fitting` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). # How many electrons are there?; N = 0; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). # Work in the ot namespace for this procedure; core.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""); E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Burn-in', **kwargs); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). if not wfn.functional().is_x_lrc():; raise ValidationError(""""""Not sensible to optimize omega for non-long-range-correction functional.""""""). # Determine HOMO, to determine mult1; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. Na1 = Na; Nb1 = Nb; if HOMO > 0:; Na1 -= 1; else:; Nb1 -= 1. charge1 = charge0 + 1; mult1 = Na1 - Nb1 + 1. omegas = []; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_r). # Neutral; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); E0r, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Right Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:17075,Validat,ValidationError,17075,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,4,['Validat'],['ValidationError']
Security,"ocs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Molecule::set_units: argument must be 'Angstrom' or 'Bohr'.""""""). [docs] def has_zmatrix(self):; """"""Gets the presence of any zmatrix entry. >>> print H2OH2O.has_zmatrix(); False. """"""; return self.zmat. [docs] def set_has_zmatrix(self, tf):; """"""Sets the presence of any zmatrix entry. >>> H2OH2O.set_has_zmatrix(True). """"""; self.zmat = tf. # <<< Simple Methods for Coordinates >>>. [docs] def Z(self, atom):; """"""Nuclear charge of atom (0-indexed). >>> print H2OH2O.Z(4); 1. """"""; return self.atoms[atom].Z(). [docs] def x(self, atom):; """"""x position of atom (0-indexed) in Bohr. >>> print H2OH2O.x(4); 3.17549201425. """"""; return self.input_units_to_au * self.atoms[atom].compute()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au *",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:7028,Validat,ValidationError,7028,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"od.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:62507,Validat,ValidationError,62507,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,"odule with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; from __future__ import absolute_import; import re; import os; import math; import warnings; import pickle; import copy; import collections; from psi4.driver import constants; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`share/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:2234,access,accessible,2234,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,1,['access'],['accessible']
Security,"oeff[dashlvl][func]['s6'], dashcoeff[dashlvl][func]['a1'], dashcoeff[dashlvl][func]['s8'],; dashcoeff[dashlvl][func]['a2'], 0.0, 4)); pfile.close(). # Write dftd3_geometry file that supplies geometry to dispersion calc; geomfile = './dftd3_geometry.xyz'; gfile = open(geomfile, 'w'); gfile.write(self.save_string_xyz()); gfile.close(). # Call dftd3 program; try:; dashout = subprocess.Popen(['dftd3', geomfile, '-grad'], stdout=subprocess.PIPE); except OSError:; raise ValidationError('Program dftd3 not found in path.'); out, err = dashout.communicate(); if verbosity >= 3:; print out. # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; raise ValidationError('Program dftd3 did not complete successfully.'). # Parse grad output; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for at in dfile.readlines():; dashdderiv.append([float(x.replace('D', 'E')) for x in at.split()]); dfile.close(); if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Clean up files and remove scratch directory; # os.unlink(paramfile); # os.unlink(geomfile); # os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); # try:; # shutil.rmtree(dftd3_tmpdir); # except OSError as e:; # ValidationError('Unable to remove dftd3 temporary directory %s' % e, file=sys.stderr); os.chdir(current_directory). # return -D & d(-D)/dx; return dashd, dashdderiv. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta5] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:30236,Validat,ValidationError,30236,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,2,['Validat'],['ValidationError']
Security,"of LUMO.; frac_diis : Optional[bool]; Do use DIIS for non-1.0-occupied points?; neutral_guess : Optional[bool]; Do use neutral orbitals as guess for the anion?; hf_guess: Optional[bool]; Do use UHF guess before UKS?; continuous_guess : Optional[bool]; Do carry along guess rather than reguessing at each occupation?; filename : Optional[str]; Result filename, if not name of molecule. Returns; -------; ~typing.Dict[float, float]; Dictionary associating SCF energies with occupations. """"""; optstash = p4util.OptionsState(; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'REFERENCE'],; [""SCF"", ""FRAC_START""],; [""SCF"", ""FRAC_RENORMALIZE""],; #[""SCF"", ""FRAC_LOAD""],; [""SCF"", ""FRAC_OCC""],; [""SCF"", ""FRAC_VAL""],; [""SCF"", ""FRAC_DIIS""]); kwargs = p4util.kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one, and neutral; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). if molecule.molecular_charge() != 0:; raise ValidationError(""""""frac_traverse requires neutral molecule to start.""""""); if molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" Requested procedure `frac_traverse` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). chargep = charge0 + 1; chargem = charge0 - 1. multp = kwargs.get('cation_mult', mult0 + 1); multm = kwargs.get('anion_mult', mult0 + 1). # By default, we start the frac procedure on the 25th iteration; # when not reading a previous guess; frac_start = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; HOMO_occs = kwargs.get('HOMO_occs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]); LUMO_occs = kwargs.get('LUMO_occs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; Z = 0; for A in range(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:3288,Validat,ValidationError,3288,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,4,['Validat'],['ValidationError']
Security,"of SAD basis sets; if (core.get_option(""SCF"", ""GUESS"") in [""SAD"", ""SADNO"", ""HUCKEL""]):; sad_basis_list = core.BasisSet.build(wfn.molecule(), ""ORBITAL"",; core.get_global_option(""BASIS""),; puream=wfn.basisset().has_puream(),; return_atomlist=True); wfn.set_sad_basissets(sad_basis_list). if (""DF"" in core.get_option(""SCF"", ""SAD_SCF_TYPE"")):; # We need to force this to spherical regardless of any user or other demands.; optstash = p4util.OptionsState(['PUREAM']); core.set_global_option('PUREAM', True); sad_fitting_list = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SAD"",; core.get_option(""SCF"", ""DF_BASIS_SAD""),; puream=True,; return_atomlist=True); wfn.set_sad_fitting_basissets(sad_fitting_list); optstash.restore(). if hasattr(core, ""EXTERN"") and 'external_potentials' in kwargs:; core.print_out(""\n Warning! Both an external potential EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:42429,Validat,ValidationError,42429,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions used by several Python functions."""""". __all__ = [; ""all_casings"",; ""drop_duplicates"",; ""expand_psivars"",; ""format_molecule_for_input"",; ""format_options_for_input"",; ""get_psifile"",; ""getattr_ignorecase"",; ""hold_options_state"",; ""import_ignorecase"",; ""kwargs_lower"",; ""mat2arr"",; ""prepare_options_for_modules"",; ""prepare_options_for_set_options"",; ""provenance_stamp"",; ""state_to_atomicinput"",; ]. import collections; import os; import warnings; from contextlib import contextmanager; from types import ModuleType; from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Union. import numpy as np; from qcelemental.models import AtomicInput. from psi4 import core; from psi4.metadata import __version__. from . import p4regex; from .exceptions import ValidationError. [docs]; def kwargs_lower(kwargs: Dict[str, Any]) -> Dict[str, Any]:; """"""Function to rebuild and return *kwargs* dictionary sanitized. Should be; called by every function that could be called directly by the user. Parameters; ----------; kwargs; Input kwargs for any user-facing function. Returns; -------; lowered : Dict[str, Any]; Sanitized kwargs with all keys made lowercase. Also turns boolean-like; values into actual booleans. Also turns values lowercase if sensible. """"""; caseless_kwargs = {}; for key, value in kwargs.items():; lkey = key.lower(); if lkey in ['subset', 'banner', 'restart_file', 'write_orbitals']: # only kw for which case matters; lvalue = value; else:; try:; lvalue = value.lower(); except (AttributeError, KeyError):; lvalue = value. if lkey in ['irrep', 'check_bsse', 'linkage', 'bsse_type']:; caseless_kwargs[lkey] = lvalue. elif 'dertype' in lkey:; if p4regex.der0th.match(str(lvalue)):; caseless_kwargs[lkey] = 0; elif p4regex.der1st.match(str(lvalue",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/procutil.html:1919,Validat,ValidationError,1919,psi4manual/1.9.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/procutil.html,2,['Validat'],['ValidationError']
Security,"of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; func : function; Function to be called (energy, gradient, frequency or cbs).; total_method_name : str; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; tuple or float; Float, or if ``return_wfn`` is specified, a tuple of ``(value, wavefunction)``.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); core.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for unsupported calls; if ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:64009,Sanitiz,Sanitize,64009,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Sanitiz'],['Sanitize']
Security,"of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; func : function; Function to be called (energy, gradient, frequency or cbs).; total_method_name : str; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; tuple or float; Float, or if ``return_wfn`` is specified, a tuple of ``(value, wavefunction)``.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); if core.get_option(""SCF"", ""DF_INTS_IO"") != ""SAVE"":; core.clean(); optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for unsupported calls; if ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:65566,Sanitiz,Sanitize,65566,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Sanitiz'],['Sanitize']
Security,"of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for FCHK files."""""". import re; import numpy as np; from psi4.driver.p4util.testing import compare_strings, compare_arrays, compare_values, compare_integers; from psi4 import core; from .exceptions import ValidationError. __all__ = ['fchkfile_to_string','compare_fchkfiles', ""compare_moldenfiles""]. def _consume_fchk_section(input_list, index):; """"""compare a float or integer matrix section"""""". n = int(input_list[index].split()[-1]); kind = input_list[index].split()[-3]. if ""R"" in kind:; dtype = np.float64; format_counter = 5; elif ""I"" in kind:; dtype = np.float64; format_counter = 6; else:; raise ValidationError('Unknow field type in FCHK reader\n'). extra = 0 if n <= format_counter else n % format_counter; lines = 1 if n <= format_counter else int(n / format_counter); offset = lines + 1 if extra > 0 else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. [docs]def fchkfile_to_string(fname):; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read(); return fchk_string. [docs]def compare_fchkfiles(expected, computed, atol_exponent, label):; """"""Comparison function for output data in FCHK (formatted checkpoint) file format.; Compares many fields including number of electrons, highest angular momentum, basis; set exponents, densities, final gradient. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fchk.html:1738,Validat,ValidationError,1738,psi4manual/1.6.x/_modules/psi4/driver/p4util/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fchk.html,1,['Validat'],['ValidationError']
Security,"oftware package; #; # Copyright (c) 2007-2017 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". ## Force Python 3 print syntax, if this is python 2.X; #if sys.hexversion < 0x03000000:; from __future__ import print_function; from __future__ import absolute_import. import re; import os; import sys; import uuid; from psi4.driver import pubchem; from psi4.driver.p4util.exceptions import *; from psi4.driver.p4util.util import set_memory; from psi4 import core. # globally available regex strings; pubchemre = re.compile(r'^(\s*pubchem\s*:\s*(.*)\n)$', re.MULTILINE | re.IGNORECASE). # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/inputparser.html:1215,access,access,1215,psi4manual/1.1.0/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/inputparser.html,1,['access'],['access']
Security,"oftware package; #; # Copyright (c) 2007-2018 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". ## Force Python 3 print syntax, if this is python 2.X; #if sys.hexversion < 0x03000000:; from __future__ import print_function; from __future__ import absolute_import; import re; import os; import sys; import uuid. from psi4 import core; from psi4.driver.qcdb.molparse import pubchem; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # globally available regex strings; pubchemre = re.compile(r'^(\s*pubchem\s*:\s*(.*)\n)$', re.MULTILINE | re.IGNORECASE). # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/inputparser.html:1217,access,access,1217,psi4manual/1.2.1/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/inputparser.html,1,['access'],['access']
Security,"oftware package; #; # Copyright (c) 2007-2019 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". import re; import os; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/inputparser.html:1217,access,access,1217,psi4manual/1.3.2/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/inputparser.html,1,['access'],['access']
Security,"oftware package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:1240,access,access,1240,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,2,['access'],['access']
Security,"oftware package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/inputparser.html:1240,access,access,1240,psi4manual/1.7.x/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/inputparser.html,1,['access'],['access']
Security,"oftware package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/inputparser.html:1240,access,access,1240,psi4manual/1.6.x/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/inputparser.html,1,['access'],['access']
Security,"oftware package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:1242,access,access,1242,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,1,['access'],['access']
Security,"oftware package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import uuid. from psi4 import core; from psi4.driver.p4util.exceptions import *; from psi4.driver.p4util.util import set_memory. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/inputparser.html:1242,access,access,1242,psi4manual/1.9.x/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/inputparser.html,1,['access'],['access']
Security,"oftware package; #; # Copyright (c) 2007-2024 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import uuid. from psi4 import core; from psi4.driver.p4util.exceptions import *; from psi4.driver.p4util.util import set_memory. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/inputparser.html:1249,access,access,1249,psi4manual/master/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/inputparser.html,1,['access'],['access']
Security,"ol = True, alpha: float = None):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component.; zLO; Lower zeta level.; valueLO; Lower value used for extrapolation.; zMD; Intermediate zeta level. Should be equal to zLO + 1.; valueMD; Intermediate value used for extrapolation.; zHI; Higher zeta level. Should be equal to zLO + 2.; valueHI; Higher value used for extrapolation.; alpha; Not used. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [4]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0`. References; ----------. .. [4] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(""scf_xtpl_helgaker_3: Inputs must be of the same datatype! (%s, %s, %s)"" %; (type(valueLO), type(valueMD), type(valueHI))). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:17677,Validat,ValidationError,17677,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"olecule, ""_initial_cartesian"", None) is not None:; c1_molecule._initial_cartesian = scf_molecule._initial_cartesian.clone(); c1_molecule.set_geometry(c1_molecule._initial_cartesian); c1_molecule.reset_point_group(""c1""); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); else:; raise ValidationError(""Set no_com/no_reorient/symmetry c1 by hand for PE on non-Cartesian molecules.""). scf_molecule = c1_molecule; core.print_out("""""" PE does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); core.print_out("""""" PE geometry must align with POTFILE keyword: """"""; """"""resetting coordinates with fixed origin and orientation.\n""""""). # SCF Banner data; banner = kwargs.pop('banner', None); bannername = name. # Did we pass in a DFT functional?; dft_func = kwargs.pop('dft_functional', None); if dft_func is not None:; if name.lower() != ""scf"":; raise ValidationError(""dft_functional was supplied to SCF, but method name was not SCF ('%s')"" % name); name = dft_func; bannername = name; if isinstance(name, dict):; bannername = name.get(""name"", ""custom functional""). # Setup the timer; if do_timer:; core.tstart(). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('SCF', 'SOSCF'):; proc_util.check_non_symmetric_jk_density(""Second-order SCF""). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if core.has_option_changed('SCF', 'BASIS_GUESS'):; cast = core.get_option('SCF', 'BASIS_GUESS'); if p4util.yes.match(str(cast)):; cast = True; elif p4util.no.match(str(cast)):; cast = False. if cast:. # A user can set ""BASIS_GUESS"" to True and we default to 3-21G; if cast is True:; guessbasis = corresponding_basis(core.get_global_option('BASIS'), 'GUESS')[0]; if guessbasis is None:; guessbasis = '3-21G' # guess of last resort; else:; guessbasis = cast; core.set_global_option('BASIS', guessbasis). castdf = 'DF' in core.get_global_option('SCF_TYPE'). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:38932,Validat,ValidationError,38932,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"olecule, current keyword settings, and cfour {...} block. """"""; # Handle memory; mem = int(0.000001 * core.get_memory()); if mem == 524:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; core.set_local_option('CFOUR', 'TRANSLATE_PSI4', False); else:; molecule.update_geometry(); #print(molecule.create_psi4_string_from_molecule()); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.tagline = molecule.name(); molcmd, molkw = qcdbmolecule.format_molecule_for_cfour(). if core.get_global_option('BASIS') == '':; bascmd, baskw = '', {}; else:; user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1') # need basis printed for *every* atom; qbs = core.BasisSet.build(molecule, ""BASIS"", core.get_global_option('BASIS')); if qbs.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(qbs.genbas()); core.print_out(' GENBAS loaded from Psi4 LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html:15372,Validat,ValidationError,15372,psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,3,['Validat'],['ValidationError']
Security,"olecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] <example description>; >>> <example python command>. >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> frequencies('scf', dertype=1, irrep=4). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Compute the hessian; hessian(name, **kwargs). if not (('mode' in kwargs) and (kwargs['mode'].lower() == 'sow')):; # call thermo module; psi4.thermo(). #TODO add return current energy once satisfied that's set to energy at eq, not a findif; return psi4.get_variable('CURRENT ENERGY'). ## Aliases ##; frequencies = frequency; freq = frequency. [docs]def molden(filename):; """"""Function to write wavefunction information in molden; format to *filename*. """"""; m = psi4.MoldenWriter(psi4.wavefunction()); m.write(filename). [docs]def parse_cotton_irreps(irrep):; r""""""Function to return validated Cotton ordering index from string or integer; irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2v': {; 'a1': 1,; 'a2': 2,; 'b1': 3,; 'b2': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2h': {; 'ag': 1,; 'bg': 2,; 'au': 3,; 'bu': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; },; 'd2h': {; 'ag': 1,; 'b1g': 2,; 'b2g': 3,; 'b3g': 4,; 'au': 5,; 'b1u': 6,; 'b2u': 7,; 'b3u': 8,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; '5': 5,; '6': 6,; '7': 7,; '8': 8; }; }. point_group = psi4.get_active_molecule().schoenflies_symbol().lower(); irreducible_representation = str(irrep).lower(). try:; return cotton[point_group][irreducible_representation]; except KeyError:; raise ValidationError(""Irrep \'%s\' not valid for point group \'%s\'."" % (str(irrep), p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:73973,validat,validated,73973,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['validat'],['validated']
Security,"olled by the keyword CHOLESKY_TOLERANCE.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. PSI4 also features the capability to use “composite” Fock matrix build; algorithms - arbitrary combinations of specialized algorithms that construct; either the Coulomb or the Exchange matrix separately. In general, since; separate Coulomb and Exchange matrix build algorithms exploit properties specific to; their respective matrix, composite algorithms display lower; scaling factors than their combined Fock build counterparts. However, composite algorithms also; introduce redundant ERI computations into the calculation. Therefore, composite Fock build; algorithms tend to perform better for larger systems, but worse for smaller systems. Arbitrary; composite algorithms can be accessed by setting SCF_TYPE to J_alg+K_alg,; where J_alg and K_alg are the names of the separate Coulomb; and Exchange construction algorithms to use, respectively. Alternatively, if one is using; DFT with non-hybrid functionals, a composite Coulomb construction algorithm can be; specified solo by setting SCF_TYPE to J_alg, without the need to set; an associated K_alg.; Specialized algorithms available to construct the Coulomb term within a composite framework; are as follows:. DFDIRJAn integral-direct algorithm constructing the Coulomb term based on [Weigend:2002:4285]; The DFDIRJ algorithm combines the benefits of integral-direct SCF approaches; with that of density-fitting. Specifically, DFJ utilizes no I/O and displays; strong performance with large system size through a combination of; effective parallelization and utilization of density-fitting to minimize; ERI computational cost. See the Integral-Direct Density-Fitted Coulomb Construction section for more information. Specialized algorithms available to construct the Exchange term within a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:28456,access,accessed,28456,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,2,['access'],['accessed']
Security,"olled by the keyword CHOLESKY_TOLERANCE.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. PSI4 also features the capability to use “composite” Fock matrix build; algorithms - arbitrary combinations of specialized algorithms that construct; either the Coulomb or the Exchange matrix separately. In general, since; separate Coulomb and Exchange matrix build algorithms exploit properties specific to; their respective matrix, composite algorithms display lower; scaling factors than their combined Fock build counterparts. However, composite algorithms also; introduce redundant ERI computations into the calculation. Therefore, composite Fock build; algorithms tend to perform better for larger systems, but worse for smaller systems. Arbitrary; composite algorithms can be accessed by setting SCF_TYPE to J_alg+K_alg,; where J_alg and K_alg are the names of the separate Coulomb; and Exchange construction algorithms to use, respectively.; Specialized algorithms available to construct the Coulomb term within a composite framework; are as follows:. DFDIRJAn integral-direct algorithm constructing the Coulomb term based on [Weigend:2002:4285]; The DFDIRJ algorithm combines the benefits of integral-direct SCF approaches; with that of density-fitting. Specifically, DFJ utilizes no I/O and displays; strong performance with large system size through a combination of; effective parallelization and utilization of density-fitting to minimize; ERI computational cost. See the Integral-Direct Density-Fitted Coulomb Construction section for more information. Specialized algorithms available to construct the Exchange term within a composite framework; are as follows:. COSXAn algorithm based on the semi-numerical “chain of spheres exchange” (COSX); approach described in [Neese:2009:98]. The coulomb term is computed with a; direct dens",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:28209,access,accessed,28209,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,1,['access'],['accessed']
Security,"ologies to the coders. compare_matrices(expected, computed, digits, label)[source]¶; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. compare_values(expected, computed, digits, label)[source]¶; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits.; Performs a system exit on failure. Used in input files in the test suite. query_yes_no(question, default=True)[source]¶; Ask a yes/no question via raw_input() and return their answer.; question is a string that is presented to the user.; default is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user).; The return value is one of True or False. File for accessory procedures in the chem module.; Credit for the libmints vector3 class to Justin M. Turney and; incremental improvements by other psi4 developers. add(v, u)[source]¶; Compute sum of vectors v and u. cross(v, u)[source]¶; Compute cross product of length 3 vectors v and u. determinant(mat)[source]¶; Given 3x3 matrix mat, compute the determinat. diagonalize3x3symmat(A)[source]¶; Given an real symmetric 3x3 matrix A, compute the eigenvalues. distance(v, u)[source]¶; Compute the distance between points defined by vectors v and u. dot(v, u)[source]¶; Compute dot product of vectors v and u. mscale(matrix, d)[source]¶; Return matrix scaled by scalar d. mult(matrix1, matrix2)[source]¶; Matrix multiplication. norm(v)[source]¶; Compute the magnitude of vector v. normalize(v)[source]¶; Compute normalized vector v. perp_unit(u, v)[source]¶; Compute unit vector perpendicular to length 3 vectors u and v. rotate(v, theta, axis)[source]¶; Rotate length 3 vector v about axis by theta radians. scale(v, d)[sour",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:64437,access,accessory,64437,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,4,['access'],['accessory']
Security,"ologies to the coders. compare_matrices(expected, computed, digits, label)[source]¶; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. compare_values(expected, computed, digits, label)[source]¶; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits.; Performs a system exit on failure. Used in input files in the test suite. query_yes_no(question, default=True)[source]¶; Ask a yes/no question via raw_input() and return their answer.; question is a string that is presented to the user.; default is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user).; The return value is one of True or False. File for accessory procedures in the chem module.; Credit for the libmints vector3 class to Justin M. Turney and; incremental improvements by other psi4 developers. add(v, u)[source]¶; Compute sum of vectors v and u. cross(v, u)[source]¶; Compute cross product of length 3 vectors v and u. determinant(mat)[source]¶; Given 3x3 matrix mat, compute the determinat. diagonalize3x3symmat(M)[source]¶; Given an real symmetric 3x3 matrix M, compute the eigenvalues. distance(v, u)[source]¶; Compute the distance between points defined by vectors v and u. dot(v, u)[source]¶; Compute dot product of vectors v and u. mscale(matrix, d)[source]¶; Return matrix scaled by scalar d. mult(matrix1, matrix2)[source]¶; Matrix multiplication. norm(v)[source]¶; Compute the magnitude of vector v. normalize(v)[source]¶; Compute normalized vector v. perp_unit(u, v)[source]¶; Compute unit vector perpendicular to length 3 vectors u and v. rotate(v, theta, axis)[source]¶; Rotate length 3 vector v about axis by theta radians. scale(v, d)[sour",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:67696,access,accessory,67696,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['access'],['accessory']
Security,"om basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `conda install -c conda-forge pyddx` or `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ); scf_wfn.ddx_state = None. # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c conda-forge cppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:55872,Validat,ValidationError,55872,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"om basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ); scf_wfn.ddx_state = None. # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:55716,Validat,ValidationError,55716,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"om basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx_state = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:55332,Validat,ValidationError,55332,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"om basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:47633,Validat,ValidationError,47633,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"om other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". from psi4 import core, extras. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:1319,Validat,ValidationError,1319,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,3,['Validat'],['ValidationError']
Security,"om output file and subsidiary files; outPsivar, outMol, outGrad = harvest_output(c4out). if 'GRD' in largs:; grdMol, grdGrad = harvest_GRD(largs['GRD']); else:; grdMol, grdGrad = None, None. if 'FCMFINAL' in largs:; fcmHess = harvest_FCM(largs['FCMFINAL']); else:; fcmHess = None. if 'DIPOL' in largs:; dipolDip = harvest_DIPOL(largs['DIPOL']); else:; dipolDip = None. # Reconcile the coordinate information: several cases; # Case p4Mol GRD Check consistency Apply orientation? ReturnMol (1-19-2014); # sp with mol thru cfour {} None None outMol N.C. outMol; # opt with mol thru cfour {} None grdMol outMol && grdMol N.C. grdMol; # sp with mol thru molecule {} p4Mol None p4Mol && outMol p4Mol <-- outMol p4Mol (same as input arg); # opt with mol thru molecule {} p4Mol grdMol p4Mol && outMol && grdMol p4Mol <-- grdMol p4Mol (same as input arg). if outMol:; if grdMol:; if abs(outMol.nuclear_repulsion_energy() - grdMol.nuclear_repulsion_energy()) > 1.0e-3:; raise ValidationError(""""""Cfour outfile (NRE: %f) inconsistent with Cfour GRD (NRE: %f)."""""" % \; (outMol.nuclear_repulsion_energy(), grdMol.nuclear_repulsion_energy())); if p4Mol:; if abs(outMol.nuclear_repulsion_energy() - p4Mol.nuclear_repulsion_energy()) > 1.0e-3:; raise ValidationError(""""""Cfour outfile (NRE: %f) inconsistent with Psi4 input (NRE: %f)."""""" % \; (outMol.nuclear_repulsion_energy(), p4Mol.nuclear_repulsion_energy())); else:; raise ValidationError(""""""No coordinate information extracted from Cfour output.""""""). # print ' <<< [1] P4-MOL >>>'; # if p4Mol:; # p4Mol.print_out_in_bohr(); # print ' <<< [2] C4-OUT-MOL >>>'; # if outMol:; # outMol.print_out_in_bohr(); # print ' <<< [3] C4-GRD-MOL >>>'; # if grdMol:; # grdMol.print_out_in_bohr(). # Set up array reorientation object; if p4Mol and grdMol:; p4c4 = OrientMols(p4Mol, grdMol); oriCoord = p4c4.transform_coordinates2(grdMol); oriGrad = p4c4.transform_gradient(grdGrad); oriDip = None if dipolDip is None else p4c4.transform_vector(dipolDip); elif p4Mol and outMol:;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:21682,Validat,ValidationError,21682,psi4manual/1.0.0/_modules/qcdb/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html,1,['Validat'],['ValidationError']
Security,"om(True). nfrag = sapt_dimer.nfragments(). if nfrag == 3:; # Midbond case; if sapt_basis == 'monomer':; raise ValidationError(""SAPT basis cannot both be monomer centered and have midbond functions.""). midbond = sapt_dimer.extract_subsets(3); ztotal = 0; for n in range(midbond.natom()):; ztotal += midbond.Z(n). if ztotal > 0:; raise ValidationError(""SAPT third monomer must be a midbond function (all ghosts).""). ghosts = ([2, 3], [1, 3]); elif nfrag == 2:; # Classical dimer case; ghosts = (2, 1); else:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). if sapt_basis == 'dimer':; monomerA = sapt_dimer.extract_subsets(1, ghosts[0]); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, ghosts[1]); monomerB.set_name('monomerB'); elif sapt_basis == 'monomer':; monomerA = sapt_dimer.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2); monomerB.set_name('monomerB'); else:; raise ValidationError(""SAPT basis %s not recognized"" % sapt_basis). return (sapt_dimer, monomerA, monomerB). def sapt_empirical_dispersion(name, dimer_wfn, **kwargs):; sapt_dimer = dimer_wfn.molecule(); sapt_dimer, monomerA, monomerB = prepare_sapt_molecule(sapt_dimer, ""dimer""); disp_name = name.split(""-"")[1]. # Get the names right between SAPT0 and FISAPT0; saptd_name = name.split('-')[0].upper(); if saptd_name == ""SAPT0"":; sapt0_name = ""SAPT0""; else:; sapt0_name = ""SAPT"". save_pair = (saptd_name == ""FISAPT0""). from .proc import build_disp_functor; _, _disp_functor = build_disp_functor('hf-' + disp_name, restricted=True, save_pairwise_disp=save_pair, **kwargs). ## Dimer dispersion; dimer_disp_energy = _disp_functor.compute_energy(dimer_wfn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:8199,Validat,ValidationError,8199,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,3,['Validat'],['ValidationError']
Security,"om=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" %; (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzN = re.compile(r'(?:\s*)([A-Z](?:[a-z])?)(?:\s+)' +; NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s*)', re.IGNORECASE); xyzC = re.compile(r'(?:\s*)(\d+\.?\d*)(?:\s+)' +; NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s*)', re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:5806,Validat,ValidationError,5806,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"om_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if dashlvl is not None:; dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())); else:; raise ValidationError(""""""Must specify a dashlvl""""""). if func is not None:; dftd3_params = dash_server(func, dashlvl); else:; dftd3_params = {}. if dashparam is not None:; dftd3_params.update(dashparam). # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Find out if running from Psi4 for scratch details and such; # try:; # import psi4; # except ImportError as err:; # isP4regime = False; # else:; # isP4regime = True",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html:3829,Validat,ValidationError,3829,psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"omain='qm', missing_enabled_return='error', np_out=True, speclabel=True, tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, copy=True, verbose=1)[source]¶; Compose a Molecule dict from unvalidated arrays and variables, returning dict.; See fields of Return molrec below. Required parameters (for QM XYZ); are geom and one of elem, elez, elbl (speclabel=True). Parameters. geom (Union[List[List[float]], numpy.ndarray]) – (nat, 3) or (3 * nat, ) ndarray or list o’lists of Cartesian coordinates.; fragment_separators (Union[List[int], numpy.ndarray]) – (nfr - 1, ) list of atom indices at which to split geom into fragments.; elbl (Union[List[str], numpy.ndarray]) – (nat, ) Label extending elem symbol, possibly conveying ghosting, isotope, mass, tagging information.; tooclose (float) – Interatom distance (native geom units) nearer than which atoms not allowed.; nonphysical (bool) – Do allow masses outside an element’s natural range to pass validation?; speclabel (bool) – If True, interpret elbl as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., @13C_mine or; He4@4.01. If False, interpret elbl as only the user/tagging; extension to nucleus label, e.g. _mine or 4 in the previous examples.; missing_enabled_return (str) – {‘minimal’, ‘none’, ‘error’}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out (bool) – When True, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use False to get a json-able version. Returns. molrec (dict) – Molecule dictionary spec follows. Its principles are; (1) contents are fully validated and defaulted - no error; checking necessary,; (2) contents may be mildly redundant - atomic numbers and; element symbols present,; (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,; (4) some fields are optional (e.g., fix_symmetry)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external_apis-1.html:6194,validat,validation,6194,psi4manual/1.4.0/external_apis-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external_apis-1.html,5,['validat'],['validation']
Security,"ome info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(""""""Stability analysis root following is only available for UHF""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (core.get_option('SCF', 'REFERENCE') in ['RHF', 'RKS']) and \; ((scf_molecule.natom() > 1) or core.get_option('SCF', 'SAD_FRAC_OCC')):; core.set_local_option('SCF', 'GUESS', 'SAD'); elif core.get_option('SCF', 'REFERENCE') in ['ROHF', 'ROKS', 'UHF', 'UKS']:; core.set_local_option('SCF', 'GUESS', 'GWH'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') == '':; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:32857,Validat,ValidationError,32857,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"ome info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(""""""Stability analysis root following is only available for UHF""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') == '':; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n"");; if banner:; core.print_out("" "" + banner.center(58));; if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58));; ref_wfn = scf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:33401,Validat,ValidationError,33401,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"ome info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(""""""Stability analysis root following is only available for UHF""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n"");; if banner:; core.print_out("" "" + banner.center(58));; if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58));; r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:41763,Validat,ValidationError,41763,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"ometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 array. >>> print H2OH2O.geome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:32693,access,accessing,32693,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,3,['access'],['accessing']
Security,"ommand tested that psi4 is in your path, and it’s finding; all the libraries it needs. Now you need only specify a scratch directory; (see Scratch Files and Elementary Restart) by replacing the placeholder in the following:; >>> echo ""export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files"" >> ~/.bashrc; # log out, log back in so variable takes effect. All done!. Note; Above commands use bash for installation and set up your environment for bash at runtime. To use csh at runtime, follow the on-screen directions at the end of the installation or consult step 7 below. Detailed Installation of Miniconda¶. Sanity check. If you already have Miniconda or Anaconda, skip to step 5. The whole installation takes ~5 min; reading this page takes far longer.; Get bzip2. You’ll need this slightly exotic command so run which to test for availability, and install from yum, source, etc. if unavailable. You’ll also need an internet connection for downloading; computers behind a firewall or with restricted login domains are eligible. So long as you can ssh into the computer to an account with write permissions and can connect to the internet from the computer, all is well. # check; >>> which bzip2; /usr/bin/bzip2; >>> curl -O ""http://psicode.org/psi4manual/master/introduction.html""; >>> ls -1; introduction.html. Get Miniconda installer script. Either issue the command below or download from http://conda.pydata.org/miniconda.html by clicking on the appropriate link for your OS. If you already have or would prefer to use Anaconda rather than Miniconda, that’s fine. Locate or install Anaconda, check that conda is in your path, and skip to step 4. >>> curl -O ""http://repo.continuum.io/miniconda/Miniconda-latest-Linux-x86_64.sh""; # check; >>> ls -1; Miniconda-latest-Linux-x86_64.sh. Install Miniconda. Execute the script and answer its questions, particularly your choice of installation location. You may need to replace the filename below with the correct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/conda-1.html:11498,firewall,firewall,11498,psi4manual/1.1.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/conda-1.html,8,['firewall'],['firewall']
Security,"omputations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description=""AtomicResult return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs] @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs] @validator(""method""); def set_method(cls, method):; return method.lower(). [docs] @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs] def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": {; ""stdout"": True,; },; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs] def compute(self, client: Optional[""FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True; from qcportal.models import KeywordSet, Molecule. # Build the keywords; keyword_id = client.add_keywords([KeywordSet(values=self.keywords)])[0]. # Build the molecule; mol = Molecule(**self.mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/task_base.html:2995,validat,validator,2995,psi4manual/1.6.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/task_base.html,1,['validat'],['validator']
Security,"omputed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAG",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:29658,Validat,ValidationError,29658,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"on = citation; # digital object identifier for publication (maybe this should be doi of datum, not of pub?); self.doi = doi; # addl comments; self.comment = comment. @classmethod; [docs] def library_modelchem(cls, dbse, rxn, method, mode, basis, value, units='kcal/mol', citation=None, doi=None,; comment=None):; """"""Constructor when method and basis are strings corresponding to; qcdb.Method and qcdb.BasisSet already defined in methods and bases. """"""; # computational method; try:; tmp_method = methods[method.upper()]; except KeyError as e:; raise ValidationError(""""""Invalid ReactionDatum method %s: %s"""""" % (method, e)); # computational basis set; try:; tmp_basis = bases[basis.lower()]; except KeyError as e:; raise ValidationError(""""""Invalid ReactionDatum basis %s: %s"""""" % (basis, e)); # publication; if citation is None:; tmp_pub = citation; else:; try:; tmp_pub = pubs[citation.lower()]; except KeyError as e:; raise ValidationError(""""""Invalid ReactionDatum publication %s: %s"""""" % (citation, e)); return cls(dbse, rxn, tmp_method, mode, tmp_basis, value, units, citation=tmp_pub, doi=doi, comment=comment). def __str__(self):; text = ''; text += """""" ==> ReactionDatum <==\n\n""""""; text += """""" Database reaction: %s\n"""""" % (self.dbrxn); text += """""" Method: %s\n"""""" % (self.method.fullname); text += """""" Mode: %s\n"""""" % (self.mode); text += """""" Basis: %s\n"""""" % (self.basis.fullname); text += """""" Value: %f [%s]\n"""""" % (self.value, self.units); text += """""" Citation: %s %s\n"""""" % (self.citation.name, self.citation.doi); text += """""" DOI: %s\n"""""" % (self.doi); text += """""" Comment: %s\n"""""" % (self.comment); text += """"""\n""""""; return text. [docs]class Subset(object):; """"""Affiliated qcdb.Reaction-s. """""". def __init__(self, name, hrxn, tagl=None, axis=None):; # identifier; self.name = name; # array of reactions names; self.hrxn = hrxn; # description line; self.tagl = tagl; # mathematical relationships of reactions; self.axis = OrderedDict(). def __str__(self):; text = ''; text += """""" ==> %s S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:11153,Validat,ValidationError,11153,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"on ». Database¶; Code author: Lori A. Burns; Section author: Lori A. Burns. database(name, db_name[, func, mode, cp, rlxd, symm, zpe, benchmark, tabulate, subset])[source]¶; Function to access the molecule objects and reference energies of; popular chemical databases. Aliases :db(). Returns:(float) Mean absolute deviation of the database in kcal/mol. Psi variables:. db_name DATABASE MEAN SIGNED DEVIATION; db_name DATABASE MEAN ABSOLUTE DEVIATION; db_name DATABASE ROOT-MEAN-SQUARE DEVIATION; Python dictionaries of results accessible as DB_RGT and DB_RXN. Note; It is very easy to make a database from a collection of xyz files; using the script psi4/lib/scripts/ixyz2database.pl.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/lib/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/db-1.html:1089,access,access,1089,psi4manual/4.0b5/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/db-1.html,2,['access'],['access']
Security,"on('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:117008,Validat,ValidationError,117008,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"on('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). return optstash. [docs]def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES',; 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES',; 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI',; 'NO_OCCUPATIONS']. if not len(prop_list):; raise ValidationnError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop,; oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)); . [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'CD', 'PK', 'DIRECT']:; mints = psi4.MintsHelper(wfn.basisset()); mints.set_print(1); mints.integrals(). [docs]def check_non_symmetric_jk_density(name):; """"""; Ensure non-symmetric density matrices are supported for the selected JK routine.; """"""; scf_type = psi4.get_option('SCF', 'SCF_TYPE'); supp_jk_type = ['DF', 'CD', 'PK', 'DIRECT', 'OUT_OF_CORE']; supp_string = ', '.join(supp_jk_type[:-1]) + ', or ' + supp_jk_type[-1] + '.'. if scf_type not in supp_jk_type:; raise ValidationError(""Method %s: Requires support for non-symmetric density matrices.\n""; "" Please set SCF_TYPE to %s"" % (name, supp_string)) . Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html:4004,Validat,ValidationError,4004,psi4manual/1.0.0/_modules/procedures/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html,1,['Validat'],['ValidationError']
Security,"on(1); molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' FNOCC does not make use of molecular symmetry, further calculations in C1 point group.\n'). # hack to ensure puream (or not) throughout; psi4.set_global_option('PUREAM', psi4.MintsHelper().basisset().has_puream()). # triples?; if (lowername == 'df-ccsd'):; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); if (lowername == 'df-ccsd(t)'):; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); if (lowername == 'fno-df-ccsd'):; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); psi4.set_local_option('FNOCC', 'NAT_ORBS', True); if (lowername == 'fno-df-ccsd(t)'):; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); psi4.set_local_option('FNOCC', 'NAT_ORBS', True). # set scf-type to df unless the user wants something else; if psi4.has_option_changed('SCF','SCF_TYPE') == False:; psi4.set_global_option('SCF_TYPE', 'DF'). scf_type = psi4.get_option('SCF','SCF_TYPE'); if ( scf_type != 'CD' and scf_type != 'DF' ):; raise ValidationError(""Invalid scf_type for DFCC.""). # save DF or CD ints generated by SCF for use in CC; psi4.set_local_option('SCF','DF_INTS_IO', 'SAVE'). # the default auxiliary basis; if psi4.get_option('FNOCC','DF_BASIS_CC') == '':; basis = psi4.get_global_option('BASIS'); dfbasis = p4util.corresponding_rifit(basis); psi4.set_local_option('FNOCC','DF_BASIS_CC',dfbasis). # make sure this module knows what df basis was used in the scf; if ( psi4.get_option('SCF','SCF_TYPE') == ""DF"" ):; df_basis_scf = psi4.get_option('SCF','DF_BASIS_SCF'); if df_basis_scf == '':; basis = psi4.get_global_option('BASIS'); df_basis_scf = p4util.corresponding_jkfit(basis). psi4.set_global_option('DF_BASIS_SCF',df_basis_scf). scf_helper(name,**kwargs). psi4.fnocc(). molecule.reset_point_group(user_pg); molecule.update_geometry(). # restore options; optstash.restore(). return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:65422,Validat,ValidationError,65422,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"on); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. import sys; from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]; def array_to_matrix(; self: Union[core.Matrix, core.Vector],; arr: Union[np.ndarray, List[np.ndarray]],; name: str = ""New Matrix"",; dim1: Optional[Union[List, Tuple, core.Dimension]] = None,; dim2: Optional[core.Dimension] = None,; ) -> Union[core.Matrix, core.Vector]:; """"""; Converts a `NumPy array; <https://numpy.org/doc/stable/reference/arrays.ndarray.html>`_ or list of; NumPy arrays into a |PSIfour| :class:`~psi4.core.Matrix` or; :class:`~psi4.core.Vector` (irrepped if list). Parameters; ----------; self; Matrix or Vector class.; arr; NumPy array or list of arrays to use as the data for a new; :class:`~psi4.core.Matrix` or :class:`~psi4.core.Vector`.; name; Name to give the new :class:`~psi4.core.Matrix`.; dim1; If a single dense NumPy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:2266,Validat,ValidationError,2266,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"on); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. import sys; from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(; self: Union[core.Matrix, core.Vector],; arr: Union[np.ndarray, List[np.ndarray]],; name: str = ""New Matrix"",; dim1: Optional[Union[List, Tuple, core.Dimension]] = None,; dim2: Optional[core.Dimension] = None,; ) -> Union[core.Matrix, core.Vector]:; """"""; Converts a `NumPy array; <https://numpy.org/doc/stable/reference/arrays.ndarray.html>`_ or list of; NumPy arrays into a |PSIfour| :class:`~psi4.core.Matrix` or; :class:`~psi4.core.Vector` (irrepped if list). Parameters; ----------; self; Matrix or Vector class.; arr; NumPy array or list of arrays to use as the data for a new; :class:`~psi4.core.Matrix` or :class:`~psi4.core.Vector`.; name; Name to give the new :class:`~psi4.core.Matrix`.; dim1; If a single dense NumPy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:2264,Validat,ValidationError,2264,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"on, performed by applying a finite electric field and numerical differentiation. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in CH2. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. adc1; ADC/6-31G** on H2O. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. dft2; DFT Functional Test. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cisd-sp; 6-31G** H2O Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a tes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:30687,Access,Accesses,30687,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,4,['Access'],['Accesses']
Security,"on-CBS function; gradient_type = 'custom_function'. elif kwargs.get('bsse_type', None) is not None:; gradient_type = 'nbody_gufunc'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Call appropriate wrappers; if gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(hessian, name.lower(), ptype='hessian', **kwargs); # Check if this is a CBS extrapolation; elif gradient_type == ""cbs_gufunc"":; return driver_cbs._cbs_gufunc(hessian, name.lower(), **kwargs, ptype=""hessian""); elif gradient_type == ""cbs_wrapper"":; return driver_cbs.cbs(hessian, ""cbs"", **kwargs, ptype=""hessian""); elif gradient_type != ""conventional"":; raise ValidationError(""Hessian: Does not yet support custom functions.""); else:; lowername = name.lower(). _filter_renamed_methods(""frequency"", lowername); ; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.get('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 ir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:76210,Validat,ValidationError,76210,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"on. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. print_global_options(self: psi4.core.Options) → None¶; print the global, cross-module options. print_module_options(self: psi4.core.Options) → None¶; print global and local options prepared for current module. read_globals(self: psi4.core.Options) → bool¶; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str) → None¶; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool) → None¶; set bool option. set_current_module(self: psi4.core.Options, arg0: str) → None¶; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float) → None¶; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int) → None¶; set int option. set_read_globals(self: psi4.core.Options, arg0: bool) → None¶; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. table of contents. Options; Options; Options.add_array(); Options.add_bool(); Options.add_int(); Options.add_str(); Options.add_str_i(); Options.get_bool(); Options.get_current_module(); Options.get_double(); Options.get_int(); Options.get_int_vector(); Options.get_str(); Options.print_global_options(); Options.print_module_options(); Options.read_globals(); Options.set_array(); Options.set_bool(); Options.set_current_module(); Options.set_double(); Options.set_int(); Options.set_read_globals(); Options.set_str(); Options.set_str_i(); Options.validate_options(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Options. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Options.html:3450,validat,validate,3450,psi4manual/1.8.x/api/psi4.core.Options.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Options.html,1,['validat'],['validate']
Security,"on. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. print_global_options(self: psi4.core.Options) → None¶; print the global, cross-module options. print_module_options(self: psi4.core.Options) → None¶; print global and local options prepared for current module. read_globals(self: psi4.core.Options) → bool¶; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str) → None¶; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool) → None¶; set bool option. set_current_module(self: psi4.core.Options, arg0: str) → None¶; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float) → None¶; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int) → None¶; set int option. set_read_globals(self: psi4.core.Options, arg0: bool) → None¶; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. table of contents. Options; Options; Options.add_array(); Options.add_bool(); Options.add_int(); Options.add_str(); Options.add_str_i(); Options.get_bool(); Options.get_current_module(); Options.get_double(); Options.get_int(); Options.get_int_vector(); Options.get_str(); Options.print_global_options(); Options.print_module_options(); Options.read_globals(); Options.set_array(); Options.set_bool(); Options.set_current_module(); Options.set_double(); Options.set_int(); Options.set_read_globals(); Options.set_str(); Options.set_str_i(); Options.validate_options(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; Options. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Options.html:3450,validat,validate,3450,psi4manual/1.9.x/api/psi4.core.Options.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Options.html,1,['validat'],['validate']
Security,"on; """""". if core.has_option_changed(""SCF"", ""DFT_DISPERSION_PARAMETERS""):; modified_disp_params = core.get_option(""SCF"", ""DFT_DISPERSION_PARAMETERS""); else:; modified_disp_params = None. # Figure out functional; if functional is None:; superfunc, disp_type = dft_functional.build_superfunctional(core.get_option(""SCF"", ""DFT_FUNCTIONAL"")); elif isinstance(functional, core.SuperFunctional):; superfunc = functional; disp_type = False; elif isinstance(functional, (str, unicode)):; superfunc, disp_type = dft_functional.build_superfunctional(functional); else:; raise ValidationError(""Functional %s is not understood"" % str(functional)). # Build the wavefunction; core.prepare_options_for_module(""SCF""); if reference in [""RHF"", ""RKS""]:; wfn = core.RHF(ref_wfn, superfunc); elif reference == ""ROHF"":; wfn = core.ROHF(ref_wfn, superfunc); elif reference in [""UHF"", ""UKS""]:; wfn = core.UHF(ref_wfn, superfunc); elif reference == ""CUHF"":; wfn = core.CUHF(ref_wfn, superfunc); else:; raise ValidationError(""SCF: Unknown reference (%s) when building the Wavefunction."" % reference). if disp_type:; wfn._disp_functor = empirical_dispersion.EmpericalDispersion(disp_type[0], disp_type[1],; tuple_params = modified_disp_params); wfn._disp_functor.print_out(). # Set the multitude of SAD basis sets; if (core.get_option(""SCF"", ""SCF_TYPE"") == ""DF"") or \; (core.get_option(""SCF"", ""DF_SCF_GUESS"") and (core.get_option(""SCF"", ""SCF_TYPE"") == ""DIRECT"")):; aux_basis = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); wfn.set_basisset(""DF_BASIS_SCF"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; decon_basis = core.BasisSet.build(wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); wfn.set_basisset(""BASIS_RELATIVISTIC"", decon_basis). if (core.get_optio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:27009,Validat,ValidationError,27009,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"on; freq. freq¶. psi4.driver.freq(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples. >>> # [1] Frequency",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.freq-1.html:1069,access,accesses,1069,psi4manual/1.4.0/api/psi4.driver.freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.freq-1.html,5,['access'],['accesses']
Security,"on=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * qcel.constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_completion,; run_mirror=do_mirror,; verbose=verbose). compare_integers(; True, np.allclose(solution.shift, perturbation.shift, atol=6), 'shifts equiv', verbose=verbose - 1); if not do_resort:; compare_integers(; True,; np.allclose(solution.rotation.T, perturbation.rotation),; 'rotations transpose',; verbose=verbose - 1); if solution.mirror:; compare_integers(True, do_mirror, 'mirror allowed', verbose=verbose - 1). def set_fragment_pattern(self, frl, frt, frc, frm):; """"""Set fragment member data through public method analogous to psi4.core.Molecule"""""". if not (len(frl) == len(frt) == len(frc) == len(frm)):; raise ValidationError(""""""Molecule::set_fragment_pattern: fragment arguments not of same length.""""""). self.fragments = frl; self.fragment_types = frt; self.fragment_charges = frc; self.fragment_multiplicities = frm. # Attach methods to qcdb.Molecule class; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol = _parker_xyz2mol_yo; from .interface_gcp import run_gcp as _gcp_qcdb_yo; Molecule.run_gcp = _gcp_qcdb_yo. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.3.2;  · . PSI4. Module code. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:60980,Validat,ValidationError,60980,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"onError; If any of |scf__frac_start| don't play well together. Returns; -------; bool; Whether FRAC is enabled during scf. """"""; enabled = (core.get_option('SCF', 'FRAC_START') != 0); if enabled:; if enabled < 0:; raise ValidationError('SCF FRAC_START ({}) must be at least 1'.format(enabled)). return enabled. def _validate_MOM():; """"""Sanity-checks MOM control options. Raises; ------; ValidationError; If any of |scf__mom_start|, |scf__mom_occ| don't play well together. Returns; -------; bool; Whether excited-state MOM (not just the plain stabilizing MOM) is enabled during scf. """"""; enabled = (core.get_option('SCF', ""MOM_START"") != 0 and len(core.get_option('SCF', ""MOM_OCC"")) > 0); if enabled:; start = core.get_option('SCF', ""MOM_START""); if enabled < 0:; raise ValidationError('SCF MOM_START ({}) must be at least 1'.format(start)). return enabled. def _validate_soscf():; """"""Sanity-checks SOSCF control options. Raises; ------; ValidationError; If any of |scf__soscf|, |scf__soscf_start_convergence|,; |scf__soscf_min_iter|, |scf__soscf_max_iter| don't play well together. Returns; -------; bool; Whether SOSCF is enabled during scf. """"""; enabled = core.get_option('SCF', 'SOSCF'); if enabled:; start = core.get_option('SCF', 'SOSCF_START_CONVERGENCE'); if start < 0.0:; raise ValidationError('SCF SOSCF_START_CONVERGENCE ({}) must be positive'.format(start)). miniter = core.get_option('SCF', 'SOSCF_MIN_ITER'); if miniter < 1:; raise ValidationError('SCF SOSCF_MIN_ITER ({}) must be at least 1'.format(miniter)). maxiter = core.get_option('SCF', 'SOSCF_MAX_ITER'); if maxiter < miniter:; raise ValidationError(; 'SCF SOSCF_MAX_ITER ({}) must be at least SOSCF_MIN_ITER ({})'.format(maxiter, miniter)). conv = core.get_option('SCF', 'SOSCF_CONV'); if conv < 1.e-10:; raise ValidationError('SCF SOSCF_CONV ({}) must be achievable'.format(conv)). return enabled. def field_fn(xyz):; """"""Callback function for PylibEFP to compute electric field from electrons; in ab initio part for libefp polar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:25385,Validat,ValidationError,25385,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security,"on_changed; enabled = (core.get_option('SCF', 'DAMPING_PERCENTAGE') > 0.0); if enabled:; parameter = core.get_option('SCF', ""DAMPING_PERCENTAGE""); if parameter < 0.0 or parameter > 100.0:; raise ValidationError('SCF DAMPING_PERCENTAGE ({}) must be between 0 and 100'.format(parameter)). stop = core.get_option('SCF', 'DAMPING_CONVERGENCE'); if stop < 0.0:; raise ValidationError('SCF DAMPING_CONVERGENCE ({}) must be > 0'.format(stop)). return enabled. def _validate_diis():; """"""Sanity-checks DIIS control options. Raises; ------; ValidationError; If any of |scf__diis|, |scf__diis_start|,; |scf__diis_min_vecs|, |scf__diis_max_vecs| don't play well together. Returns; -------; bool; Whether DIIS is enabled during scf. """"""; enabled = bool(core.get_option('SCF', 'DIIS')); if enabled:; start = core.get_option('SCF', 'DIIS_START'); if start < 1:; raise ValidationError('SCF DIIS_START ({}) must be at least 1'.format(start)). minvecs = core.get_option('SCF', 'DIIS_MIN_VECS'); if minvecs < 1:; raise ValidationError('SCF DIIS_MIN_VECS ({}) must be at least 1'.format(minvecs)). maxvecs = core.get_option('SCF', 'DIIS_MAX_VECS'); if maxvecs < minvecs:; raise ValidationError(; 'SCF DIIS_MAX_VECS ({}) must be at least DIIS_MIN_VECS ({})'.format(maxvecs, minvecs)). return enabled. def _validate_frac():; """"""Sanity-checks FRAC control options. Raises; ------; ValidationError; If any of |scf__frac_start| don't play well together. Returns; -------; bool; Whether FRAC is enabled during scf. """"""; enabled = (core.get_option('SCF', 'FRAC_START') != 0); if enabled:; if enabled < 0:; raise ValidationError('SCF FRAC_START ({}) must be at least 1'.format(enabled)). return enabled. def _validate_MOM():; """"""Sanity-checks MOM control options. Raises; ------; ValidationError; If any of |scf__mom_start|, |scf__mom_occ| don't play well together. Returns; -------; bool; Whether excited-state MOM (not just the plain stabilizing MOM) is enabled during scf. """"""; enabled = (core.get_option('SCF', ""MOM_START"") !",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:24082,Validat,ValidationError,24082,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security,"onal alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, core.Molecule):; # called on a python export of a psi4.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if dashlvl is not None:; dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())); else:; raise ValidationError(""""""Must specify a dashlvl""""""). if func is not None:; dftd3_params = dash_server(func, dashlvl); else:; dftd3_params = {}. if dashparam is not None:; dftd3_params.update(dashparam). # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html:3416,Validat,ValidationError,3416,psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"onally projected coordinates, while OFF (=1) retains the rotational degrees of freedom. At a stationary point on the potential energy surface, both options will give equivalent harmonic force fields, but OFF should be used at non-stationary points. Type: string; Possible Values: ON, OFF; Default: ON. CFOUR_FD_STEPSIZE¶. Specifies the step length in mass-weighted coordinates (in \(10^{-4} amu^{1/2} bohr\) ) used in generating the force constant matrix by finite difference of Cartesian gradients. Type: integer; Default: 5. CFOUR_FD_USEGROUP¶. In finite difference calculations using the FINDIF option, this keyword specifies the point group to be used in generating the symmetry-adapted vibrational coordinates. FULL (= 0) specifies the full molecular point group, COMP (= 1) specifies the Abelian subgroup used in the electronic structure calculation. Type: string; Possible Values: FULL, COMP; Default: FULL. CFOUR_FILE_RECSIZ¶. This specifies the physical length (in integer words) of the records used in the word-addressable direct access files used by CFOUR. This value should always be chosen as a multiple of 512 bytes, as your local system manager certainly understands. Type: integer; Default: 2048. CFOUR_FILE_STRIPE¶. This option allows the splitting of files. Input is required in the form N1/N2/N3/N4/N5, where N1, N2, N3, N4, and N5 specify the number of files in which MOINTS, GAMLAM, MOABCD, DERINT, and DERGAM are split, respectively. Type: string; Default: 0/0/0/0/0. CFOUR_FINITE_PERTURBATION¶. Specifies the field strength for a perturbation (defined within a %perturbation section). The value must be given as an integer, and the field strength used by the program will be then the value of the keyword \(\times 10^{-6}\). Type: integer; Default: 0. CFOUR_FOCK¶. This option is used to control the algorithm used for construction of the Fock matrix in SCF calculations. PK (=0) uses the PK-supermatrix approach while AO (=1) constructs the matrix directly from the basis funct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html:26164,access,access,26164,psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,15,['access'],['access']
Security,"onary specifying available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. """"""; from __future__ import print_function; from __future__ import absolute_import; import os; import re; import sys; import json; import shutil. import numpy as np. from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver.procrouting import *; from psi4.driver.p4util.exceptions import *; # never import wrappers or aliases into this file. def _find_derivative_type(ptype, method_name, user_dertype):; r""""""; Figures out the derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". if ptype not in ['gradient', 'hessian']:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:2090,Validat,ValidationError,2090,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"onary, or throw error.; np_out; When `True`, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use `False` to get a json-able version. Returns; -------; molrec : dict; Molecule dictionary spec follows. Its principles are. (1) contents are fully validated and defaulted - no error; checking necessary,. (2) contents may be mildly redundant - atomic numbers and; element symbols present,. (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,. (4) some fields are optional (e.g., fix_symmetry) but largely; self-describing so units or fix_com must be present. (5) apart from some mild optional fields, _all_ fields will; be present (corollary of ""fully validated and defaulted"") - no; need to check for every key. in some cases like efp, keys will; appear in blocks, so pre-handshake there will be a few hint keys; and post-handshake they will be joined by full qm-like molrec. (6) molrec should be idempotent through this function (equiv to; schema validator) but are not idempotent throughout its life. if; fields permit, frame may be changed. Future? if fields permit,; mol may be symmetrized. Coordinates and angles may change units; or range if program returns them in only one form. name : str, optional; Label for molecule; should be valid Python identifier.; units : {'Angstrom', 'Bohr'}; Units for `geom`.; input_units_to_au : float, optional; If `units='Angstrom'`, overrides consumer's value for [A]-->[a0] conversion.; fix_com : bool; Whether translation of `geom` is allowed or disallowed.; fix_orientation : bool; Whether rotation of `geom` is allowed or disallowed.; fix_symmetry : str, optional; Maximal point group symmetry which `geom` should be treated. Lowercase.; geom : ndarray of float; (3 * nat, ) Cartesian coordinates in `units`.; elea : ndarray of int; (nat, ) Mass number for atoms, if known isotope, else -1.; elez : ndarray of int; (nat, ) Number of protons, nuclear charge for atoms.; elem : ndarray of str; (n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:6197,validat,validator,6197,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['validat'],['validator']
Security,"one, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False)¶; Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type; psi4.core.Molecule. static from_dict(arg0: dict) → psi4.core.Molecule¶; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1)¶; Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters. molschema (Dict) – Dictionary form of Molecule following known schema.; return_dict (bool) – Additionally return Molecule dictionary intermediate.; nonphysical (bool) – Do allow masses outside an element’s natural range to pass validation?; verbose (int) – Amount of printing. Return type; Union[Molecule, Tuple[Molecule, Dict]]. Returns. mol (psi4.core.Molecule); molrec (dict) – Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=True, enable_efp=True, missing_enabled_return_qm='none', missing_enabled_return_efp='none', verbose=1)¶. fsymbol(self: psi4.core.Molecule, atom: int) → str¶; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self: psi4.core.Molecule) → psi4.core.Matrix¶; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self: psi4.core.Molecule) → int¶; Gets n in Cnv, etc.; If there is no n (e.g. Td",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Molecule.html:21137,validat,validation,21137,psi4manual/1.6.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Molecule.html,1,['validat'],['validation']
Security,"onn.sort(key=lambda tup: tup[0]); molinit[""connectivity""] = conn; except ValueError:; raise ValidationError(; ""Connectivity entry is not of form [(at1, at2, bondorder), ...]: {}"".format(connectivity); ). if units.capitalize() in [""Angstrom"", ""Bohr""]:; molinit[""units""] = units.capitalize(); else:; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. def validate_and_fill_frame(extern, fix_com=None, fix_orientation=None, fix_symmetry=None):. if fix_com is True:; com = True; elif fix_com is False:; if extern:; raise ValidationError(""Invalid fix_com ({}) with extern ({})"".format(fix_com, extern)); else:; com = False; elif fix_com is None:; com = extern; else:; raise ValidationError(""Invalid fix_com: {}"".format(fix_com)). if fix_orientation is True:; orient = True; elif fix_orientation is False:; if extern:; raise ValidationError(""Invalid fix_orientation ({}) with extern ({})"".format(fix_orientation, extern)); else:; orient = False; elif fix_orientation is None:; orient = extern; else:; raise ValidationError(""Invalid fix_orientation: {}"".format(fix_orientation)). symm = None; if extern:; if fix_symmetry is None:; symm = ""c1""; elif fix_symmetry.lower() == ""c1"":; symm = ""c1""; else:; raise ValidationError(""Invalid (non-C1) fix_symmetry ({}) with extern ({})"".format(fix_symmetry, extern)); else:; if fix_symmetry is not None:; symm = fix_symmetry.lower(). molinit = {}; molinit[""fix_com""] = com; molinit[""fix_orientation""] = orient; if symm:; molinit[""fix_symmetry""] = symm. return molinit. def va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:15122,Validat,ValidationError,15122,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"onse = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs.pop('properties'); properties = drop_duplicates(properties). for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""The \""properties\"" keyword is required with the property() function.""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if (n_invalid > 0):; print(""The following properties are not currently supported: %s"" % invalid). if (n_excited > 0 and (name.lower() != 'eom-ccsd' and name.lower() != 'eom-cc2')):; raise ValidationError(""Excited state CC properties require EOM-CC2 or EOM-CCSD.""). if ((name.lower() == 'eom-ccsd' or name.lower() == 'eom-cc2') and n_response > 0):; raise ValidationError(""Cannot (yet) compute response properties for excited states.""). if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""Computing both density- and response-based properties.""). if (name.lower() == 'ccsd'):; PsiMod.set_global_option('WFN', 'CCSD'); run_ccenergy('ccsd', **kwargs); PsiMod.set_global_option('WFN', 'CCSD'); elif (name.lower() == 'cc2'):; PsiMod.set_global_option('WFN', 'CC2'); run_ccenergy('cc2', **kwargs); PsiMod.set_global_option('WFN', 'CC2'); elif (name.lower() == 'eom-ccsd'):; PsiMod.set_global_option('WFN', 'EOM_CCSD'); run_ccenergy('eom-ccsd', **kwargs); PsiMod.set_global_option('WFN', 'EOM_CCSD'); elif (name.lower() == 'eom-cc2'):; PsiMod.set_global_option('WFN', 'EOM_CC2'); run_ccenergy('eom-cc2', **kwargs); PsiMod.set_global_option('WFN', 'EOM_CC2'). # Need cchbar for everything; PsiMod.cchbar(). # Need ccdensity at this point only for density-based props; if (n_one > 0 or n_two > 0):; if (name.lower() == 'eom-ccsd'):; PsiMod.set_global_option('WFN', 'EOM_CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:17641,Validat,ValidationError,17641,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,2,['Validat'],['ValidationError']
Security,"ontraction of 1.0.; * @return A new empty BasisSet object. """"""; # In the new implementation, we simply call the default constructor; return BasisSet(). [docs] def atomic_basis_set(self, center):; """"""Return a BasisSet object containing all shells at center i (0-index); * Used for Atomic HF computations for SAD Guesses; * @param center Atomic center to provide a basis object for.; * @returns A new basis set object for the atomic center. """"""; return BasisSet(self, center). @staticmethod; [docs] def build(molecule, shells):; """"""Builder factory method; * @param molecule the molecule to build the BasisSet around; * @param shells array of *atom-numbered* GaussianShells to build the BasisSet from; * @return BasisSet corresponding to this molecule and set of shells. """"""; raise FeatureNotImplemented('BasisSet::build'). @staticmethod; [docs] def pyconstruct_combined(mol, keys, targets, fitroles, others):. # make sure the lengths are all the same; if len(keys) != len(targets) or len(keys) != len(fitroles):; raise ValidationError(""""""Lengths of keys, targets, and fitroles must be equal""""""). # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, basestring):; mol = Molecule(mol); returnBasisSet = False; elif isinstance(mol, Molecule):; returnBasisSet = True; else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # load in the basis sets; sets = []; name = """"; for at in range(len(keys)):; bas = BasisSet.pyconstruct(mol, keys[at], targets[at], fitroles[at], others[at]); name += targets[at] + "" + ""; sets.append(bas). name = name[:-3].strip(); # work our way through the sets merging them; combined_atom_basis_shell = OrderedDict(); for at in range(len(sets)):; atom_basis_shell = sets[at].atom_basis_shell. for label, basis_map in atom_basis_shell.items():; if label not in combined_atom_basis_shell:; combined_atom_basis_shell[label] = OrderedDict(); combined_atom_basis_shell[label][name] = []; for basis, shells in basis_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:15158,Validat,ValidationError,15158,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['Validat'],['ValidationError']
Security,"onvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant funct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/opt-1.html:1995,access,accesses,1995,psi4manual/1.3.2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/opt-1.html,2,['access'],['accesses']
Security,"onvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/opt-1.html:1995,access,accesses,1995,psi4manual/1.2.1/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/opt-1.html,2,['access'],['accesses']
Security,"onvert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union, TYPE_CHECKING; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }; CBSMetadata = List[Dict[str, Any]]. # remove in 1.8; # these get input files to the point where they raise an UpgradeHelper; def xtpl_highest_1():; pass. def scf_xtpl_helgaker_2():; pass. def scf_xtpl_truhlar_2():; pass. def scf_xtpl_karton_2():; pass. def scf_x",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:5546,Validat,ValidationError,5546,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"ope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import os; import re; import math; import pickle; import collections. from psi4.driver import constants; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`share/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedde",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:1631,access,access,1631,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,1,['access'],['access']
Security,"open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzN = re.compile(r'(?:\s*)([A-Z](?:[a-z])?)(?:\s+)' +; NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s*)', re.IGNORECASE); xyzC = re.compile(r'(?:\s*)(\d+\.?\d*)(?:\s+)' +; NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s*)', re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). elif xyzC.match(text[2 + i]):. fileAtom = i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:3949,Validat,ValidationError,3949,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER']",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:51214,Validat,ValidationError,51214,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"option('SCF', 'E_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 8). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.wavefunction().energy(). optstash.restore(); return PsiMod.get_variable('CURRENT ENERGY'). else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a numbe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:34237,Validat,ValidationError,34237,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"optional; Additional comment for molecule.; provenance : dict of str; Accumulated history of molecule, with fields ""creator"", ""version"", ""routine"".; connectivity : list of tuples of int, optional; (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples. EFP extension (this + units is minimal). fragment_files : list of str; (nfr, ) lowercased names of efp meat fragment files.; hint_types : {'xyzabc', 'points'}; (nfr, ) type of fragment orientation hint.; geom_hints : list of lists of float; (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment. QMVZ extension (geom_unsettled replaces geom). geom_unsettled : list of lists of str; (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables : list of pairs; (nvar, 2) pairs of variables (str) and values (float). May be incomplete. Raises; ------; qcelemental.ValidationError; For most anything wrong. """"""; # << domain sorting >>; available_domains = [""qm"", ""efp"", ""qmvz""]; if domain not in available_domains:; raise ValidationError(; ""Topology domain {} not available for processing. Choose among {}"".format(domain, available_domains); ). if domain == ""qm"" and (geom is None or np.asarray(geom).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom = []; else:; raise ValidationError(""""""For domain 'qm', `geom` must be provided.""""""); if domain == ""efp"" and (geom_hints is None or np.asarray(geom_hints, dtype=object).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom_hints = []; fragment_files = []; hint_types = []; else:; raise ValidationError(""""""For domain 'efp', `geom_hints` must be provided.""""""). molinit = {}; extern = False. processed = validate_and_fill_units(; name=name,; units=units,; input_units_to_au=input_units_to_au,; comment=comment,; provenance=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:8829,Validat,ValidationError,8829,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"or CCSD(T) gradients is not available.' % user_ref). psi4.cchbar(ccwfn); psi4.cclambda(ccwfn); psi4.ccdensity(ccwfn). derivobj = psi4.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad). optstash.restore(); return ccwfn. [docs]def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'DELETE_TEI'],; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; psi4.set_local_option('TRANSQT2', 'WFN', 'BCCD'); psi4.set_local_option('CCSORT', 'WFN', 'BCCD'); psi4.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); psi4.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; psi4.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); psi4.set_local_option('CCSORT', 'WFN', 'BCCD_T'); psi4.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); psi4.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); psi4.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (psi4.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). psi4.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); psi4.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; while True:; if (psi4.get_global_option(""RUN_CCTRANSORT"")):; psi4.cctransort(ref_wfn); else:; psi4.transqt2(ref_wfn); psi4.ccsort(). ref_wfn = psi4.ccenergy(ref_wfn); psi4.print_out('Brueckner convergence check: %s\n' % bool(psi4.get_variable('BRUECKNER CONVERGED'))); if (psi4.get_variable('BRUECKNER CONVERGED') == True):; break. if bcc_iter_cnt >= psi4.get_option('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:56437,Validat,ValidationError,56437,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"or DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:50511,Validat,ValidationError,50511,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"or h, v in enumerate(self.nph):; ret[prefix + ""IrrepData"" + str(h)] = v. if isinstance(self, core.Matrix):; ret[prefix + ""Dim1""] = self.rowdim().to_tuple(); ret[prefix + ""Dim2""] = self.coldim().to_tuple(); if isinstance(self, core.Vector):; ret[prefix + ""Dim""] = [self.dim(x) for x in range(self.nirrep())]. if filename is None:; return ret. np.savez(filename, **ret). def _np_read(self, filename, prefix=""""):. if isinstance(filename, np.lib.npyio.NpzFile):; data = filename; elif (sys.version_info[0] == 2) and isinstance(filename, (str, unicode)):; if not filename.endswith('.npz'):; filename = filename + '.npz'; data = np.load(filename); elif (sys.version_info[0] > 2) and isinstance(filename, str):; if not filename.endswith('.npz'):; filename = filename + '.npz'. data = np.load(filename); else:; raise Exception(""Filename not understood: %s"" % filename). ret_data = []. if ((prefix + ""Irreps"") not in data.keys()) or ((prefix + ""Name"") not in data.keys()):; raise ValidationError(""File %s does not appear to be a numpyz save"" % filename). for h in range(data[prefix + ""Irreps""]):; ret_data.append(data[prefix + ""IrrepData"" + str(h)]). arr_type = self.__mro__[0]; if arr_type == core.Matrix:; dim1 = core.Dimension.from_list(data[prefix + ""Dim1""]); dim2 = core.Dimension.from_list(data[prefix + ""Dim2""]); ret = self(str(data[prefix + ""Name""]), dim1, dim2); elif arr_type == core.Vector:; dim1 = core.Dimension.from_list(data[prefix + ""Dim""]); ret = self(str(data[prefix + ""Name""]), dim1). for h in range(data[prefix + ""Irreps""]):; ret.nph[h][:] = ret_data[h]. return ret. def _to_serial(data):; """"""; Converts an object with a .nph accessor to a serialized dictionary; """""". json_data = {}; json_data[""shape""] = []; json_data[""data""] = []. for view in data.nph:; json_data[""shape""].append(view.shape); json_data[""data""].append(view.tostring()). if len(json_data[""shape""][0]) == 1:; json_data[""type""] = ""vector""; elif len(json_data[""shape""][0]) == 2:; json_data[""type""] = ""matrix""; else:; raise Va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:10443,Validat,ValidationError,10443,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"or qcdb.Molecule""""""); mol.update_geometry(). # Apply requested basis set(s) to the molecule; # - basstrings only a temp object so using fitrole as dict key instead of psi4 keyword; # - error checking not needed since C-side already checked for NULL ptr; mol.clear_basis_all_atoms(); # TODO now need to clear shells, too; basstrings = defaultdict(dict); if orb is None or orb == '':; raise ValidationError(""""""Orbital basis argument must not be empty.""""""); elif callable(orb):; basstrings['BASIS'] = orb(mol, 'BASIS'); elif isinstance(orb, basestring):; mol.set_basis_all_atoms(orb, role='BASIS'); else:; raise ValidationError(""""""Orbital basis argument must be function that applies basis sets to Molecule or a string of the basis to be applied to all atoms.""""""). if aux is None or aux == '':; pass; elif callable(aux):; basstrings[fitrole] = aux(mol, fitrole); elif isinstance(aux, basestring):; mol.set_basis_all_atoms(aux, role=fitrole); else:; raise ValidationError(""""""Auxiliary basis argument must be function that applies basis sets to Molecule or a string of the basis to be applied to all atoms.""""""). # Not like we're ever using a non-G94 format; parser = Gaussian94BasisSetParser(). # Molecule and parser prepped, call the constructor; bs, msg = BasisSet.construct(parser, mol, fitrole, None if fitrole == 'BASIS' else fitrole, basstrings[fitrole]). text = """""" => Loading Basis Set <=\n\n""""""; text += """""" Role: %s\n"""""" % (fitrole); text += """""" Keyword: %s\n"""""" % (key); text += """""" Name: %s\n"""""" % (target); text += msg. if returnBasisSet:; #print text; return bs; else:; bsdict = {}; bsdict['message'] = text; bsdict['name'] = bs.name; bsdict['puream'] = int(bs.has_puream()); bsdict['shell_map'] = bs.export_for_libmints(fitrole); return bsdict. @classmethod; [docs] def construct(cls, parser, mol, role, deffit=None, basstrings=None):; """"""Returns a new BasisSet object configured from the *mol*; Molecule object for *role* (generally a Psi4 keyword: BASIS,; DF_BASIS_SCF, etc.). Fails utter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:20132,Validat,ValidationError,20132,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['Validat'],['ValidationError']
Security,"or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. fsapt-ext-abc2; FSAPT with external charge on dimer. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. scf-response3; UHF Dipole Polarizability Test. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. cc36; CC2(RHF)/cc-pVDZ energy of H2O. opt11; Transition-state optimizations of HOOH to both torsional transition states. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. sapt11; sapt example with orbital freezing with alkali metal and dMP2. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. cc52; CCSD Response for H2O2. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. dforemp-grad1; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O molecule. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc56; EOM-CCSD/6-31g excited state transition dat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:12320,Access,Accesses,12320,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['Access'],['Accesses']
Security,"or('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:63654,Validat,ValidationError,63654,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,"or(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn.sort(key=lambda tup: tup[0]); molinit[""connectivity""] = conn; except ValueError:; raise ValidationError(; ""Connectivity entry is not of form [(at1, at2, bondorder), ...]: {}"".format(connectivity); ). if units.capitalize() in [""Angstrom"", ""Bohr""]:; molinit[""units""] = units.capitalize(); else:; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:13945,Validat,ValidationError,13945,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"or(msg); Error called when requested level or theory or derivative level are not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for PSI4. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. TestComparisonError(msg); Error called when a compare_values() or other comparison function fails. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Input specification has problems. Class Inheritance Diagram¶. psi4.driver.p4util Package¶; Miscellaneous tools for driver and users. Functions¶. OptionsStateCM(osd); Return a context manager that will collect the state (value and changed :rtype: Iterator[None]. all_casings(input_string); Return a generator of all lettercase permutations of input_string. array_to_matrix(self, arr[, name, dim1, dim2]); Converts a NumPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). banner(text[, type, width, strNotOutfile]); Format text into a banner style and print or return it. basis_helper(block[, name, key, set_option]); Helper to specify a custom basis set in PsiAPI mode. block_diagonal_array(*args); Convert square NumPy array to a single block diagonal array. cg_solver(rhs_vec, hx_function, preconditioner); Solves the \(Ax = b\) linear equations via Conjugate Gradient. compare_fchkfiles(expected, computed, ...); Comparison function for output data in FCHK (formatted check",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:22332,Validat,ValidationError,22332,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,1,['Validat'],['ValidationError']
Security,"or(msg); Error called when requested level or theory or derivative level are not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for PSI4. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. TestComparisonError(msg); Error called when a compare_values() or other comparison function fails. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Input specification has problems. Class Inheritance Diagram¶. psi4.driver.p4util Package¶; Miscellaneous tools for driver and users. Functions¶. OptionsStateCM(osd); Return a context manager that will collect the state (value and changed status) of a list of keywords osd that can initialize OptionsState on entry to the with-statement and restore the collected state when exiting the with-statement. all_casings(input_string); Return a generator of all lettercase permutations of input_string. array_to_matrix(self, arr[, name, dim1, dim2]); Converts a NumPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). banner(text[, type, width, strNotOutfile]); Format text into a banner style and print or return it. basis_helper(block[, name, key, set_option]); Helper to specify a custom basis set in PsiAPI mode. block_diagonal_array(*args); Convert square NumPy array to a single block diagonal array. cg_solver(rhs_vec, hx_function, preconditioner); Solves the \(Ax = b\) linear",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:22437,Validat,ValidationError,22437,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,3,['Validat'],['ValidationError']
Security,"or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import numpy as np; import psi4; from exceptions import *. def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; try:; arr.shape; except:; raise ValidationError(""Expected numpy array, found object of type '%s'"", type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). @classmethod; def _dimension_from_list(self, dims, name=""New Dimension""):; """"""; Builds a psi4.Dimension object from a python list or tuple. If a dimension; object is passed a copy will be returned.; """""". if isinstance(dims, (tuple, list)):; irreps = len(dims); elif isinstance(dims, psi4.Dimension):; irreps = dims.n(); else:; raise ValidationError(""Dimension from list: Type '%s' not understood"" % type(dims)). ret = psi4.Dimension(irreps, name); for i in range(irreps):; ret[i] = dims[i]; return ret. def _dimension_to_tuple(dim):; """"""; Converts a psi4.Dimension object to a tuple.; """""". if isinstance(dim, (tuple, list)):; return tuple(dim); ; irreps = dim.n(); ret = []; for i in range(irreps):; ret.append(dim[i]); return tuple(ret). @classmethod; def array_to_matrix(self, arr, name=""New Matrix"", dim1=None, dim2=None):; """"""; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list).; ; Parameters; ----------; a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:1608,Validat,ValidationError,1608,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"orce spherical or cartesian (e.g., loading old guess); self.force_puream_or_cartesian = False if forced_puream is None else True; # Is the forced value to use puream? (Otherwise force Cartesian).; self.forced_is_puream = False if forced_puream is None else forced_puream; # string filename; self.filename = None. [docs] def load_file(self, filename, basisname=None):; """"""Load and return the file to be used by parse. Return only; portion of *filename* pertaining to *basisname* if specified (for; multi-basisset files) otherwise entire file as list of strings. """"""; # string filename; self.filename = filename. given_basisname = False if basisname is None else True; found_basisname = False; basis_separator = re.compile(r'^\s*\[\s*(.*?)\s*\]\s*$'). # Loads an entire file.; try:; infile = open(filename, 'r'); except IOError:; raise BasisSetFileNotFound(""""""BasisSetParser::parse: Unable to open basis set file: %s"""""" % (filename)); if os.stat(filename).st_size == 0:; raise ValidationError(""""""BasisSetParser::parse: given filename '%s' is blank."""""" % (filename)); contents = infile.readlines(). lines = []; for text in contents:; text = text.strip(); # If no basisname was given always save the line.; if given_basisname is False:; lines.append(text). if found_basisname:; # If we find another [*] we're done.; if basis_separator.match(text):; what = basis_separator.match(text).group(1); break; lines.append(text); continue. # If the user gave a basisname AND text matches the basisname we want to trigger to retain; if given_basisname and basis_separator.match(text):; if basisname == basis_separator.match(text).group(1):; found_basisname = True. return lines. [docs] def parse(self, symbol, dataset):; """"""Given a string, parse for the basis set needed for atom.; * @param symbol atom symbol to look for in dataset; * @param dataset data set to look through; dataset can be list of lines or a single string which will be converted to list of lines. """"""; if isinstance(dataset, basestring):; lines",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:1728,Validat,ValidationError,1728,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,1,['Validat'],['ValidationError']
Security,"order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:24291,validat,validation,24291,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,4,"['Validat', 'validat']","['ValidationError', 'validation']"
Security,"order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # no analytic derivatives for scf_type cd; if psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError('No analytic derivatives for SCF_TYPE CD.'). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linka",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:32643,validat,validation,32643,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,"['Validat', 'validat']","['ValidationError', 'validation']"
Security,"ords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to compute managers.""); priority: str = Field(1, description=""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}""); owner_group: Optional[str] = Field(None, description=""group in the chown sense.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs]; @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs]; @validator(""method""); def set_method(cls, method):; return method.lower(). [docs]; @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs]; def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": self.protocols,; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs]; def compute(self, client: Optional[""qcportal.client.FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. from qcelemental.models import Molecule. # Build the molecule; mol = Molecule(**self.molecule.to_schema(dtype=2)). meta, ids = client.add_singlepoints(; molecules=mol,; program=""psi4"",; driver=self.driver,; method=self.method,; basis=self.basis,; keywords=sel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/task_base.html:3835,validat,validator,3835,psi4manual/1.9.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/task_base.html,2,['validat'],['validator']
Security,"ords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to compute managers.""); priority: str = Field(1, description=""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}""); owner_group: Optional[str] = Field(None, description=""group in the chown sense.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs]; @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs]; @validator(""method""); def set_method(cls, method):; return method.lower(). [docs]; @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs]; def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": self.protocols,; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs]; def compute(self, client: Optional[""qcportal.client.FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. try:; # QCFractal v0.15.8; from qcportal.models import KeywordSet, Molecule; qca_next_branch = False; except ImportError:; # QCFractal `next`; from qcelemental.models import Molecule; qca_next_branch = True. # Build the molecule; mol = Molecule(**self.molecul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:3860,validat,validator,3860,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html,1,['validat'],['validator']
Security,"ore(). [docs]def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; molecule = PsiMod.get_active_molecule(); if 'molecule' in kwargs:; molecule = kwargs.pop('molecule'). if not molecule:; raise ValueNotSet('no molecule found'). PsiMod.scf(). return PsiMod.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). returnvalue = run_scf(name, **kwargs). for ssuper in superfunctional_list():; if ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; PsiMod.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); PsiMod.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); PsiMod.dfmp2(); returnvalue += dfun.c_alpha() * PsiMod.get_variable('SCS-DF-MP2 CORRELATION ENERGY'). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:22747,Validat,ValidationError,22747,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"ore.Options, arg0: str, arg1: str, arg2: str) → None¶; add string option. get_bool(self: psi4.core.Options, arg0: str) → bool¶; get boolean option. get_current_module(self: psi4.core.Options) → str¶; gets current module. get_double(self: psi4.core.Options, arg0: str) → float¶; get double option. get_int(self: psi4.core.Options, arg0: str) → int¶; get integer option. get_int_vector(self: psi4.core.Options, arg0: str) → List[int]¶; get int vector option. get_str(*args, **kwargs)¶; Overloaded function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. print_global_options(self: psi4.core.Options) → None¶; print the global, cross-module options. print_module_options(self: psi4.core.Options) → None¶; print global and local options prepared for current module. read_globals(self: psi4.core.Options) → bool¶; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str) → None¶; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool) → None¶; set bool option. set_current_module(self: psi4.core.Options, arg0: str) → None¶; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float) → None¶; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int) → None¶; set int option. set_read_globals(self: psi4.core.Options, arg0: bool) → None¶; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; Options. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Options.html:3448,validat,validate,3448,psi4manual/1.7.x/api/psi4.core.Options.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Options.html,1,['validat'],['validate']
Security,"ore.SymmetryOperation method, [1], [2]. units. ; molecule. units() psi4.core.Molecule method, [1], [2]. Unnormalized psi4.core.PrimitiveType attribute, [1], [2]. Unrestricted psi4.core.IntegralTransform.TransformationType attribute, [1]. UPDATE (DETCI). update() psi4.core.DFSOMCSCF method, [1]. psi4.core.DiskSOMCSCF method, [1]. psi4.core.SOMCSCF method, [1], [2]. update_geometry() psi4.core.Molecule method, [1], [2]. update_orbitals() psi4.core.IntegralTransform method, [1], [2]. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. V_potential() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. Va() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. VAL_EX_LEVEL (DETCI). valid_methods psi4.core.OEProp attribute, [1], [2]. validate_options() psi4.core.Options method, [1], [2]. ValidationError. value() psi4.core.SuperFunctional method, [1], [2]. values() psi4.core.SuperFunctional method, [1], [2]. variable() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. variables() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. Vb() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. VBase class in psi4.core, [1]. vdot() psi4.core.CIVector method, [1], [2]. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector class ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:146747,Validat,ValidationError,146747,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['Validat'],['ValidationError']
Security,"ore.SymmetryOperation method, [1], [2]. units. ; molecule. units() psi4.core.Molecule method, [1], [2]. Unnormalized psi4.core.PrimitiveType attribute, [1], [2]. Unrestricted psi4.core.IntegralTransform.TransformationType attribute, [1]. UPDATE (DETCI). update() psi4.core.DFSOMCSCF method, [1]. psi4.core.DiskSOMCSCF method, [1]. psi4.core.SOMCSCF method, [1], [2]. update_geometry() psi4.core.Molecule method, [1], [2]. update_orbitals() psi4.core.IntegralTransform method, [1], [2]. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. V_potential() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. Va() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. VAL_EX_LEVEL (DETCI). valid_methods psi4.core.OEProp attribute, [1], [2]. validate_options() psi4.core.Options method, [1], [2]. ValidationError. value() psi4.core.SuperFunctional method, [1], [2]. values() psi4.core.SuperFunctional method, [1], [2]. variables() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. Vb() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. VBase class in psi4.core, [1]. vdot() psi4.core.CIVector method, [1], [2]. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector class in psi4.core, [1]. Vector3 class in psi4.core, [1]. vector_dot() psi4.core.Matrix method, [1], [2]. vector_multiply() psi4.core.CIVector method, [1], [2]. VectorMatrix class in psi4.core, [1]. version() in module psi4.core, [1]. vibanal_wfn() in module psi4.driver. vibrational analysis. ; function call. output. vir() psi4.core.MOSpace method",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:125470,Validat,ValidationError,125470,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['Validat'],['ValidationError']
Security,"ore.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c conda-forge adcc'.""). min_version = ""0.15.16""; if parse_version(adcc.__version__) < parse_version(min_version):; raise ModuleNotFoundError(""adcc version {} is required at least. ""; ""Version {}""; "" was found."".format(min_version,; adcc.__version__)). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:117695,Validat,ValidationError,117695,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"ore.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if p4util.yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Cou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:11067,Validat,ValidationError,11067,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,7,['Validat'],['ValidationError']
Security,"ore.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_helgaker_3(functionname, zLO, valueLO, zMD, valueMD, zHI, valueHI, verbose=True):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`.; Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}; """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(""scf_xtpl_helgaker_3: Inputs must be of the same datatype! (%s, %s, %s)""; % (type(valueLO), type(valueMD), type(valueHI))). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zMD].upper()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:8104,Validat,ValidationError,8104,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"ores the gradient into the reference wavefunction.; PsiMod.fd_freq_0(energies, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequencies(name, **kwargs). [docs]def molden(filename):; m = PsiMod.MoldenWriter(PsiMod.reference_wavefunction()); m.write(filename). [docs]def parse_cotton_irreps(irrep):; r""""""Function to return validated Cotton ordering index from string or integer; irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2v': {; 'a1': 1,; 'a2': 2,; 'b1': 3,; 'b2': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2h': {; 'ag': 1,; 'bg': 2,; 'au': 3,; 'bu': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; },; 'd2h': {; 'ag': 1,; 'b1g': 2,; 'b2g': 3,; 'b3g': 4,; 'au': 5,; 'b1u': 6,; 'b2u': 7,; 'b3u': 8,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; '5': 5,; '6': 6,; '7': 7,; '8': 8; }; }. point_group = PsiMod.get_active_molecule().schoenflies_symbol().lower(); irreducible_representation = str(irrep).lower(). try:; return cotton[point_group][irreducible_representation]; except KeyError:; raise ValidationError(""Irrep \'%s\' not valid for point group \'%s\'."" % (str(irrep),",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:48839,validat,validated,48839,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['validat'],['validated']
Security,"orm and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor from basis set strings, 'cc-pv[q5]z' from [cc-pvqz, cc-pv5z]; [docs]def reconstitute_bracketed_basis(needarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:75683,Validat,ValidationError,75683,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,4,['Validat'],['ValidationError']
Security,"ormally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:12035,Validat,ValidationError,12035,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,11,['Validat'],['ValidationError']
Security,"ory (only path to develop PSI4); Tarball from GitHub Repository. Find-the-code Quiz¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid. I just want to run the code. I may tweak the Python, but I’m not; developing anything to contribute back to the code base. Provided I still get good, threaded BLAS/LAPACK, OpenMP parallelism,; and optimization for a variety of processor architectures, I’m willing to forgo; architecture tuning wizardry to avoid compiling it myself. I’m on Linux or Mac or Windows with Ubuntu Bash Shell. I’m familiar with conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself to eke out best performance on my; computer. I accept responsibility for navigating compiler, threading,; and BLAS/LAPACK compatibility. I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; I don’t want to deal with this newfangled git, just give me a; tarball of the source code — Goto Tarball-from-GitHub. I want to run and develop in PSI4. In keeping with the open-source philosophy, I don’t mind my code being; as public as Psi4 itself during the development process. —; Goto Fork-from-GitHub; I want to develop using PSI4 infrastructure and libraries, not; on them; I think a plugin might do. I’ve got a PSI4 compilation. Use it, then consult plugins; I’d rather not compile PSI4 or I don’t have compilers —; Goto Binary-Package then consult; plugins through conda. I really like parentheses and/or DBOC, so I want Psi3. —; Psi3 is available from sourceforge, but you’re on your own. Binary Installer¶. Get Initially; Just go to http://www.psicode.org/downloads.html, select “Installer”,; “Stable Release”, and your choice of architecture and Python version,; and follow the instructions there. Build; Not a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_obtaining-1.html:1597,access,access,1597,psi4manual/1.4.0/build_obtaining-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_obtaining-1.html,6,['access'],['access']
Security,"ory: .gcppar; ###The short version reads in: basis-keywo. # Write dftd3_geometry file that supplies geometry to dispersion calc; numAtoms = self.natom(); geom = self.save_string_xyz(); reals = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; numAtoms -= 1; else:; reals.append(line). geomtext = str(numAtoms) + '\n\n'; for line in reals:; geomtext += line.strip() + '\n'; geomfile = './gcp_geometry.xyz'; with open(geomfile, 'w') as handle:; handle.write(geomtext); # TODO somehow the variations on save_string_xyz and; # whether natom and chgmult does or doesn't get written; # have gotten all tangled. I fear this doesn't work; # the same btwn libmints and qcdb or for ghosts. # Call gcp program; command = ['gcp', geomfile]; command.extend(['-level', func]); if derint != 0:; command.append('-grad'); try:; #print('command', command); dashout = subprocess.Popen(command, stdout=subprocess.PIPE, env=lenv); except OSError as e:; raise ValidationError('Program gcp not found in path. %s' % e); out, err = dashout.communicate(). # Parse output; success = False; for line in out.splitlines():; line = line.decode('utf-8'); if re.match(' Egcp:', line):; sline = line.split(); dashd = float(sline[1]); if re.match(' normal termination of gCP', line):; success = True. if not success:; os.chdir(current_directory); raise Dftd3Error(""""""Unsuccessful gCP run.""""""). # Parse grad output; if derint != 0:; derivfile = './gcp_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program gcp gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Prepare results for Psi4; if isP4regime and derint != 0:; core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html:7986,Validat,ValidationError,7986,psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,1,['Validat'],['ValidationError']
Security,"ould work, you should strive to make that interoperability a reality. Some steps:. If any interoperability is possible, define an argument xx_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function.; # Establish function to call; if not('xx_func' in kwargs):; if ('func' in kwargs):; kwargs['xx_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['xx_func'] = energy; func = kwargs['xx_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper xx is unhappy to be calling function \'%s\'.' % (func.__name__)). If specific interoperabilities are known, code them in. For example, if xx shouldn’t call db, add the last two lines above to the xx function. If db shouldn’t call xx, add the following two lines below to the db function.; if (func is xx):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'.' % (func.__name__)). Create a multipart test case that runs some intercalls between your function and others (akin to pywrap_all). In trials, permute the order of calls a few times to expose any calls that don’t clean up after themselves and need further attention. When all is validated, add your findings to the great Permitted nesting of Psithon functions table in the documentation. Previous topic; Plugins: Adding New Functionality to PSI4; Next topic; Documentation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. nex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/bestpractices_py-1.html:5660,Validat,ValidationError,5660,psi4manual/4.0b2/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/bestpractices_py-1.html,2,['Validat'],['ValidationError']
Security,"ould work, you should strive to make that interoperability a reality. Some steps:. If any interoperability is possible, define an argument xx_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function.; # Establish function to call; if not('xx_func' in kwargs):; if ('func' in kwargs):; kwargs['xx_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['xx_func'] = energy; func = kwargs['xx_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper xx is unhappy to be calling function \'%s\'.' % (func.__name__)). If specific interoperabilities are known, code them in. For example, if xx shouldn’t call db, add the last two lines above to the xx function. If db shouldn’t call xx, add the following two lines below to the db function.; if (func is xx):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'.' % (func.__name__)). Create a multipart test case that runs some intercalls between your function and others (akin to pywrap_all). In trials, permute the order of calls a few times to expose any calls that don’t clean up after themselves and need further attention. When all is validated, add your findings to the great Permitted nesting of Psithon functions table in the documentation. Previous topic; Plugins: Adding New Functionality to PSI4; Next topic; Documentation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/bestpractices_py-1.html:5675,Validat,ValidationError,5675,psi4manual/4.0b4/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/bestpractices_py-1.html,6,['Validat'],['ValidationError']
Security,"ould work, you should strive to make that interoperability a reality. Some steps:. If any interoperability is possible, define an argument xx_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function.; # Establish function to call; if not('xx_func' in kwargs):; if ('func' in kwargs):; kwargs['xx_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['xx_func'] = energy; func = kwargs['xx_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper xx is unhappy to be calling function \'%s\'.' % (func.__name__)). If specific interoperabilities are known, code them in. For example, if xx shouldn’t call db, add the last two lines above to the xx function. If db shouldn’t call xx, add the following two lines below to the db function.; if (func is xx):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'.' % (func.__name__)). Create a multipart test case that runs some intercalls between your function and others (akin to pywrap_all). In trials, permute the order of calls a few times to expose any calls that don’t clean up after themselves and need further attention. When all is validated, add your findings to the great Permitted nesting of Psithon functions table in the documentation. Previous topic; Plugins: Adding New Functionality to Psi4; Next topic; Documentation. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/bestpractices_py-1.html:5591,Validat,ValidationError,5591,psi4manual/1.0.0/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/bestpractices_py-1.html,2,['Validat'],['ValidationError']
Security,"oup (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:5122,Validat,ValidationError,5122,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"oup.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(). if psi4.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('FISAPT requires requires \""reference rhf\"".'). if ref_wfn is None:; ref_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); fisapt_wfn = psi4.fisapt(ref_wfn). optstash.restore(); return fisapt_wfn. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = psi4.get_variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to psi4.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = psi4.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:92028,Validat,ValidationError,92028,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"oupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); metadata = _process_cbs_kwargs(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling; function '%s' instead of 'energy', 'gradient' or 'hessian'."""""" % ptype). optstash = p4util.OptionsState(['BASIS'], ['WFN'], ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); natom = molecule.natom(). if metadata[0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (metadata[0][""wfn""])). if len(metadata) > 1:; for delta in metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested higher %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn""])); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; """"""Requested lesser %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn_lo""])). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""core.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup: %s ' % label)\n""""""; cbsbanners += """"""core.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = [; 'd_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian', 'd_a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:46829,Validat,ValidationError,46829,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"oupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); metadata = _process_cbs_kwargs(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling; function '%s' instead of 'energy', 'gradient' or 'hessian'."""""" % ptype). optstash = p4util.OptionsState(['BASIS'], ['WFN'], ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); natom = molecule.natom(). if metadata[0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (metadata[0][""wfn""])). if len(metadata) > 1:; for delta in metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested higher %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn""])); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; """"""Requested lesser %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn_lo""])). # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Setup{':' + label if label else ''} "", strNotOutfile=True) + ""\n""; core.print_out(instructions). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = [; 'd_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian', 'd_alpha'; ]; f_fields = ['f_wfn', 'f_basis', 'f_zeta',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:48436,Validat,ValidationError,48436,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"owercase by here. """"""; import os; import shutil; import subprocess. import numpy as np. from psi4 import extras; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import *; from psi4.driver.molutil import *; # never import driver, wrappers, or aliases into this file. from .roa import *; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:2338,validat,validation,2338,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['validat'],['validation']
Security,"p the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; psi4.print_out('\nMRCC scratch files have been kept.\n'); psi4.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; psi4.print_out('\n'); p4util.banner('Full results from MRCC'); psi4.print_out('\n'); psi4.print_out(iface_contents). return e. [docs]def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> energy('df-ccsd(t)'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # stash user options; optstash = p4util.OptionsState(; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','DFCC'],; ['FNOCC','NAT_ORBS'],; ['FNOCC','RUN_CEPA'],; ['SCF','DF_BASIS_SCF'],; ['SCF','DF_INTS_IO'],; ['SCF','SCF_TYPE']). psi4.set_local_option('FNOCC', 'DFCC', True); psi4.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""Error: %s requires \""reference rhf\""."" % lowername). # override symmetry:; molecule = psi4.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(1); molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' FNOCC does not make use of molecular symmetry, further calculations in C1 point group.\n'). # hack to ensure puream (or not) throughout; psi4.set_global_option('PUREAM', psi4.MintsHelper().basisset().has_puream()). # triples?; if (lowername == 'df-ccsd'):; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); if (lowername == 'df-ccsd(t)'):; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); if (lowername == 'fno-df-ccsd'):; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); psi4.set_local_option('FNOCC', 'NAT_ORBS', True); if (lowername == 'fno-df-ccsd(t)'):; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); psi4.set_local_option('FNOCC', 'NAT_ORBS', True). # set scf-t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:64174,Validat,ValidationError,64174,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"p(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)); except IndexError:; raise ValidationError(""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. [docs] def save_string_xyz(self, save_ghosts=True, save_natom=False):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.75856100000",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:9663,Validat,ValidationError,9663,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"p). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequencies(name, **kwargs). [docs]def molden(filename):; """"""Function to write wavefunction information in molden; format to *filename*. """"""; m = PsiMod.MoldenWriter(PsiMod.reference_wavefunction()); m.write(filename). [docs]def parse_cotton_irreps(irrep):; r""""""Function to return validated Cotton ordering index from string or integer; irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2v': {; 'a1': 1,; 'a2': 2,; 'b1': 3,; 'b2': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2h': {; 'ag': 1,; 'bg': 2,; 'au': 3,; 'bu': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; },; 'd2h': {; 'ag': 1,; 'b1g': 2,; 'b2g': 3,; 'b3g': 4,; 'au': 5,; 'b1u': 6,; 'b2u': 7,; 'b3u': 8,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; '5': 5,; '6': 6,; '7': 7,; '8': 8; }; }. point_group = PsiMod.get_active_molecule().schoenflies_symbol().lower(); irreducible_representation = str(irrep).lower(). try:; return cotton[point_group][irreducible_representation]; except KeyError:; raise ValidationError(""Irrep \'%s\' not valid for point group \'%s\'."" % (str(irrep),",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:52062,validat,validated,52062,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['validat'],['validated']
Security,"p.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. # Build and set from numpy routines; value = core.Matrix(*valueHI.shape); value_view = np.asarray(value); value_view[:] = np_value; return value. else:; raise ValidationError(""scf_xtpl_helgaker_3: datatype is not recognized '%s'."" % type(valueLO)). #def corl_xtpl_helgaker_2(functionname, valueSCF, zLO, valueLO, zHI, valueHI, verbose=True):; [docs]def corl_xtpl_helgaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`.; Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson, Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}. """"""; if type(valueLO) != type(valueHI):; raise ValidationError(""corl_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 3.0. if isinstance(valueLO, float):; value = (valueHI * zHI ** alpha - valueLO * zLO ** alpha) / (zHI ** alpha - zLO ** alpha); beta = (valueHI - valueLO) / (zHI ** (-alpha) - zLO ** (-alpha)). # final = valueSCF + value; final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = """"""\n\n ==> Helgaker 2-point correlated extrapolation for method: %s <==\n\n"""""" % (functionname.upper()); # cbsscheme += """""" HI-zeta (%1s) SCF Energy: % 16.12f\n"""""" % (str(zHI), valueSCF); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; #cbsscheme += """""" LO-zeta (%s) Correlation Energy: % 16.12f\n"""""" % (str(zLO), valueLO); #cbsscheme += """""" HI-zeta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:16849,Validat,ValidationError,16849,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"p/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.driver.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype is not None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; stage['scheme'] = kwargs.pop('scf_scheme'); stage['stage'] = ""scf""; stage['treatment'] = ""scf""; else:; # _validate_cbs_inputs will produce scf stage automatically; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'corl_scheme' in kwargs:; stage['scheme'] = kwargs.pop('corl_scheme'); stage['stage'] = ""corl""; stage['treat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:41272,Validat,ValidationError,41272,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,4,['Validat'],['ValidationError']
Security,"p_type` that quacked; # like a list rather than the more common dict handled above. if; # ever again sighted, make an issue so this code can accommodate. _disp_functor.print_out(); return superfunc, _disp_functor. else:; return superfunc, None. [docs]def scf_wavefunction_factory(name, ref_wfn, reference, **kwargs):; """"""Builds the correct (R/U/RO/CU HF/KS) wavefunction from the; provided information, sets relevant auxiliary basis sets on it,; and prepares any empirical dispersion. """"""; # Figure out functional and dispersion; superfunc, _disp_functor = build_disp_functor(name, restricted=(reference in [""RKS"", ""RHF""]), **kwargs). # Build the wavefunction; core.prepare_options_for_module(""SCF""); if reference in [""RHF"", ""RKS""]:; wfn = core.RHF(ref_wfn, superfunc); elif reference == ""ROHF"":; wfn = core.ROHF(ref_wfn, superfunc); elif reference in [""UHF"", ""UKS""]:; wfn = core.UHF(ref_wfn, superfunc); elif reference == ""CUHF"":; wfn = core.CUHF(ref_wfn, superfunc); else:; raise ValidationError(""SCF: Unknown reference (%s) when building the Wavefunction."" % reference). if _disp_functor and _disp_functor.engine != 'nl':; wfn._disp_functor = _disp_functor. # Set the DF basis sets; df_needed = core.get_global_option(""SCF_TYPE"") in [""DF"", ""MEM_DF"", ""DISK_DF"", ""COSX"", ""LINK""]; df_needed |= (core.get_global_option(""SCF_TYPE"") == ""DIRECT"" and core.get_option(""SCF"", ""DF_SCF_GUESS"")); if df_needed:; aux_basis = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); wfn.set_basisset(""DF_BASIS_SCF"", aux_basis); else:; wfn.set_basisset(""DF_BASIS_SCF"", core.BasisSet.zero_ao_basis_set()). # Set the relativistic basis sets; if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; decon_basis = core.BasisSet.build(wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:40342,Validat,ValidationError,40342,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"p_type` that quacked; # like a list rather than the more common dict handled above. if; # ever again sighted, make an issue so this code can accommodate. _disp_functor.print_out(); return superfunc, _disp_functor. else:; return superfunc, None. [docs]def scf_wavefunction_factory(name, ref_wfn, reference, **kwargs):; """"""Builds the correct (R/U/RO/CU HF/KS) wavefunction from the; provided information, sets relevant auxiliary basis sets on it,; and prepares any empirical dispersion. """"""; # Figure out functional and dispersion; superfunc, _disp_functor = build_disp_functor(name, restricted=(reference in [""RKS"", ""RHF""]), **kwargs). # Build the wavefunction; core.prepare_options_for_module(""SCF""); if reference in [""RHF"", ""RKS""]:; wfn = core.RHF(ref_wfn, superfunc); elif reference == ""ROHF"":; wfn = core.ROHF(ref_wfn, superfunc); elif reference in [""UHF"", ""UKS""]:; wfn = core.UHF(ref_wfn, superfunc); elif reference == ""CUHF"":; wfn = core.CUHF(ref_wfn, superfunc); else:; raise ValidationError(""SCF: Unknown reference (%s) when building the Wavefunction."" % reference). if _disp_functor and _disp_functor.engine != 'nl':; wfn._disp_functor = _disp_functor. # Set the DF basis sets; df_needed = core.get_global_option(""SCF_TYPE"") in [""DF"", ""MEM_DF"", ""DISK_DF"", ""COSX""]; df_needed |= (core.get_global_option(""SCF_TYPE"") == ""DIRECT"" and core.get_option(""SCF"", ""DF_SCF_GUESS"")); if df_needed:; aux_basis = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); wfn.set_basisset(""DF_BASIS_SCF"", aux_basis); else:; wfn.set_basisset(""DF_BASIS_SCF"", core.BasisSet.zero_ao_basis_set()). # Set the relativistic basis sets; if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; decon_basis = core.BasisSet.build(wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:33736,Validat,ValidationError,33736,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"p_type` that quacked; # like a list rather than the more common dict handled above. if; # ever again sighted, make an issue so this code can accommodate. _disp_functor.print_out(); return superfunc, _disp_functor. else:; return superfunc, None. [docs]def scf_wavefunction_factory(name, ref_wfn, reference, **kwargs):; """"""Builds the correct (R/U/RO/CU HF/KS) wavefunction from the; provided information, sets relevant auxiliary basis sets on it,; and prepares any empirical dispersion. """"""; # Figure out functional and dispersion; superfunc, _disp_functor = build_disp_functor(name, restricted=(reference in [""RKS"", ""RHF""]), **kwargs). # Build the wavefunction; core.prepare_options_for_module(""SCF""); if reference in [""RHF"", ""RKS""]:; wfn = core.RHF(ref_wfn, superfunc); elif reference == ""ROHF"":; wfn = core.ROHF(ref_wfn, superfunc); elif reference in [""UHF"", ""UKS""]:; wfn = core.UHF(ref_wfn, superfunc); elif reference == ""CUHF"":; wfn = core.CUHF(ref_wfn, superfunc); else:; raise ValidationError(""SCF: Unknown reference (%s) when building the Wavefunction."" % reference). if _disp_functor and _disp_functor.engine != 'nl':; wfn._disp_functor = _disp_functor. # Set the DF basis sets; if ((""DF"" in core.get_global_option(""SCF_TYPE"")) or; (core.get_option(""SCF"", ""DF_SCF_GUESS"") and (core.get_global_option(""SCF_TYPE"") == ""DIRECT""))):; aux_basis = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); wfn.set_basisset(""DF_BASIS_SCF"", aux_basis); else:; wfn.set_basisset(""DF_BASIS_SCF"", core.BasisSet.zero_ao_basis_set()). # Set the relativistic basis sets; if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; decon_basis = core.BasisSet.build(wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); wfn.set_basisset(""BASIS_RELATIVISTIC"", decon_basis). # Set th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:32890,Validat,ValidationError,32890,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"pace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(""""""Stability analysis root following is only available for UHF""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (core.get_option('SCF', 'REFERENCE') in ['RHF', 'RKS']) and \; ((scf_molecule.natom() > 1) or core.get_option('SCF', 'SAD_FRAC_OCC')):; core.set_local_option('SCF', 'GUESS', 'SAD'); elif core.get_option('SCF', 'REFERENCE') in ['ROHF', 'ROKS', 'UHF', 'UKS']:; core.set_local_option('SCF', 'GUESS', 'GWH'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') == '':; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:32735,Validat,ValidationError,32735,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"pace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(""""""Stability analysis root following is only available for UHF""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') == '':; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n"");; if banner:; co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:33279,Validat,ValidationError,33279,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"pace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(""""""Stability analysis root following is only available for UHF""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n"");; if",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:41641,Validat,ValidationError,41641,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_list = inputfile.split(""\n""); set_re = re.compile(r'^(\s*?)set\s+(?:([-,\w]+)\s+)?(\w+)[\s=]+\[.*', re.IGNORECASE); newinput = """"; while len(input_list):; line = input_list[0]; if set_re.match(line):; # We've found the start of a set matrix [ .... line - hand it off for more checks; newinput += parse_multiline_array(input_list); else:; # Nothing to do - just add the line to the string; newinput += ""%s\n"" % (input_list.pop(0)); return newinput. [docs]def process_input(raw_input, print_level=1):; """"""Function to preprocess *raw input*, the text of the input file, then; parse it, validate it for format, and convert it into legitimate Python.; *raw_input* is printed to the output file unless *print_level* =0. Does; a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user's .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed *raw_input*. """"""; # Check if the infile is actually an outfile (yeah we did); psi4_id = re.compile(r'Psi4: An Open-Source Ab Initio Electronic Structure Package'); if re.search(psi4_id, raw_input):; input_lines = raw_input.split(""\n""); input_re = re.compile(r'^\s*?\=\=> Input File <\=\='); input_start = -1; for line_count in range(len(input_lines)):; line = input_lines[line_count]; if re.match(input_re, line):; input_start = line_count + 3; break. stop_re = re.compile(r'^-{74}'); input_stop = -1; f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/inputparser.html:19966,validat,validate,19966,psi4manual/1.1.0/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/inputparser.html,6,['validat'],['validate']
Security,"passed on to Optking.; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Cfour c4-scf Gradient Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. ... Irrep: 1 Size: 4 x 3. 1 2 3. 1 0.0000000 -0.0122978 0.0000000; 2 -0.0051192 0.0040993 -0.0088667; 3 -0.0051192 0.0040993 0.0088667; 4 0.0102384 0.0040993 0.0000000. CFOUR scratch file GRD has been read; 4 0.0000000000; 7.0000000000 -0.0880964705 0.0000000000 0.0000000000; 1.0000000000 0.4080144050 -0.9178691296 -1.5897959670; 1.0000000000 0.4080144050 -0.9178691296 1.5897959670; 1.0000000000 0.4080144050 1.8357382590 0.0000000001; 7.0000000000 -0.0122978407 0.0000000000 0.0000000000; 1.0000000000 0.0040992802 -0.0051191833 -0.0088666856; 1.0000000000 0.0040992802 -0.0051191833 0.0088666856; 1.0000000000 0.0040992802 0.0102383666 0.0000000000. The gradient can also be accessed from the input file as a; Matrix object through the wfn as; psi4.core.Wavefunction.gradient(). Previously, cfour communicated through; psi4.core.legacy_gradient which was accessed through psi4.core.get_gradient(); Cfour Files; The contents of all files associated with Cfour are accessible from the; input file through the Python dictionary P4C4_INFO. That is,; P4C4_INFO['zmat'] returns a string of the input file sent to Cfour.; Accessible arguments are zmat, output, and any that have been; produced of grd. For example, to print to the screen if CC convergence; is reached, the following could be placed in the PSI4 input file.; energy('c4-ccsd'); print 'miracle?', 'miracle' in P4C4_INFO['output']. Scratch Files; By default, a separate subdirectory for each Cfour call is created within; the job’s scratch directory. To explicitly specify the location of the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the default) energy('cfour'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cfour.html:22435,access,accessed,22435,psi4manual/master/cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/cfour.html,4,['access'],['accessed']
Security,"pattern,; geom=ms['geometry'],; elea=None,; elez=None,; elem=ms['symbols'],; mass=ms.get('masses', None),; real=ms.get('real', None),; elbl=None,; throw_reorder=True). molrec = molparse.from_arrays(geom=dcontig['geom'],; elea=None,; elez=None,; elem=dcontig['elem'],; mass=dcontig['mass'],; real=dcontig['real'],; elbl=None,; name=ms.get('name', None),; units='Bohr',; input_units_to_au=None,; fix_com=ms.get('fix_com', None),; fix_orientation=ms.get('fix_orientation', None),; fix_symmetry=None,; fragment_separators=dcontig['fragment_separators'],; fragment_charges=ms.get('fragment_charges', None),; fragment_multiplicities=ms.get('fragment_multiplicities', None),; molecular_charge=ms.get('molecular_charge', None),; molecular_multiplicity=ms.get('molecular_multiplicity', None),; domain='qm',; #missing_enabled_return=missing_enabled_return,; #tooclose=tooclose,; #zero_ghost_fragments=zero_ghost_fragments,; #nonphysical=nonphysical,; #mtol=mtol,; verbose=verbose). else:; raise ValidationError(""""""Schema not recognized""""""). if return_dict:; return Molecule.from_dict(molrec), molrec; else:; return Molecule.from_dict(molrec). def _raw_to_schema(self, dtype, units='Angstrom', return_type='json'):; """"""Serializes instance into JSON or YAML according to schema `dtype`."""""". molrec = self.to_dict(np_out=True); jymol = molparse.to_schema(molrec,; dtype=dtype,; units=units,; return_type=return_type); return jymol. @staticmethod; def _raw_to_dict(self, force_c1=False, force_units=False, np_out=True):; """"""Serializes instance into Molecule dictionary."""""". self.update_geometry(); molrec = {}. if self.name() not in ['', 'default']:; molrec['name'] = self.name(). if force_units == 'Bohr':; molrec['units'] = 'Bohr'; elif force_units == 'Angstrom':; molrec['units'] = 'Angstrom'; else:; units = self.units(); molrec['units'] = units; if units == 'Angstrom' and abs(self.input_units_to_au() * psi_bohr2angstroms - 1.) > 1.e-6:; molrec['input_units_to_au'] = self.input_units_to_au(). molrec['fix_com",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:46360,Validat,ValidationError,46360,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"pdate qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, psi4.Molecule):; # called on a python export of a psi4.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all par",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:3341,Validat,ValidationError,3341,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"pe(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:32353,access,access,32353,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['access'],['access']
Security,"pe, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def scf_wavefunction_factory(name, ref_wfn, reference, **kwargs):; """"""Builds the correct (R/U/RO/CU HF/KS) wavefunction from the; provided information, sets relevant auxiliary basis sets on it,; and prepares any empirical dispersion. """"""; if core.has_option_changed(""SCF"", ""DFT_DISPERSION_PARAMETERS""):; modified_disp_params = core.get_option(""SCF"", ""DFT_DISPERSION_PARAMETERS""); else:; modified_disp_params = None. # Figure out functional; superfunc, disp_type = dft.build_superfunctional(name, (reference in [""RKS"", ""RHF""])). # Build the wavefunction; core.prepare_options_for_module(""SCF""); if reference in [""RHF"", ""RKS""]:; wfn = core.RHF(ref_wfn, superfunc); elif reference == ""ROHF"":; wfn = core.ROHF(ref_wfn, superfunc); elif reference in [""UHF"", ""UKS""]:; wfn = core.UHF(ref_wfn, superfunc); elif reference == ""CUHF"":; wfn = core.CUHF(ref_wfn, superfunc); else:; raise ValidationError(""SCF: Unknown reference (%s) when building the Wavefunction."" % reference). if disp_type:; if isinstance(name, dict):; # user dft_functional={} spec - type for lookup, dict val for param defs,; # name & citation discarded so only param matches to existing defs will print labels; wfn._disp_functor = empirical_dispersion.EmpiricalDispersion(; name_hint='',; level_hint=disp_type[""type""],; param_tweaks=disp_type[""params""],; engine=kwargs.get('engine', None)); else:; # dft/*functionals.py spec - name & type for lookup, option val for param tweaks; wfn._disp_functor = empirical_dispersion.EmpiricalDispersion(; name_hint=superfunc.name(),; level_hint=disp_type[""type""],; param_tweaks=modified_disp_params,; engine=kwargs.get('engine', None)). # [Aug 2018] there once was a breed of `disp_type` that quacked; # like a list rather than the more common dict handled above. if; # ever again sighted, make an issue so this code can accommodate. wfn._disp_functor.print_out(); if disp_type[""type""] == 'nl':; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:26836,Validat,ValidationError,26836,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"pe; str. numeric¶; Whether data is numeric. Pass True to disable validating data as float/Decimal/np.ndarray. Type; bool. class qcelemental.models.types.Array[source]¶. qcelemental.molutil.B787(cgeom, rgeom, cuniq, runiq, do_plot=False, verbose=1, atoms_map=False, run_resorting=False, mols_align=False, run_to_completion=False, algorithm='hungarian_uno', uno_cutoff=0.001, run_mirror=False)[source]¶; Use Kabsch algorithm to find best alignment of geometry cgeom onto; rgeom while sampling atom mappings restricted by runiq and cuniq. Parameters. rgeom (ndarray) – (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom (ndarray) – (nat, 3) array of concern/changeable geometry. Assumed [a0] for RMSD; purposes. Must have same nat, units, and atom content as rgeom.; runiq (ndarray) – (nat,) array of str indicating which rows (atoms) in rgeom are shuffleable; without changing the molecule. Generally hashes of element symbol and; mass are used, but could be as simple as [‘C’, ‘H’, ‘H’, ‘D’, ‘H’] for; monodeuterated methane.; cuniq (ndarray) – (nat,) array of str indicating which rows (atoms) in cgeom are shuffleable.; See runiq for more details. Strings and count in cuniq must match; runiq. That is, sorted(cuniq) == sorted(runiq).; do_plot (bool) – Pops up a mpl plot showing before, after, and ref geometries.; verbose (int) – Quantity of printing. 0 to silence.; atoms_map (bool) – Whether atom1 of rgeom already corresponds to atom1 of cgeom and so on.; If True, no resorting will be run, parameters runiq and cuniq; may be passed as None, and much time will be saved.; run_resorting (bool) – Run the resorting machinery even if unnecessary because atoms_map=True.; mols_align (Union[bool, float]) – Whether ref_mol and concern_mol have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If True, procedure is truncated when RMSD condition met, saving time.; If float, convcrit at which search for mini",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external_apis-1.html:2834,hash,hashes,2834,psi4manual/1.4.0/external_apis-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external_apis-1.html,5,['hash'],['hashes']
Security,"pe[0],; do_shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * qcel.constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_completion,; run_mirror=do_mirror,; verbose=verbose). compare_integers(; True, np.allclose(solution.shift, perturbation.shift, atol=6), 'shifts equiv', verbose=verbose - 1); if not do_resort:; compare_integers(; True,; np.allclose(solution.rotation.T, perturbation.rotation),; 'rotations transpose',; verbose=verbose - 1); if solution.mirror:; compare_integers(True, do_mirror, 'mirror allowed', verbose=verbose - 1). def set_fragment_pattern(self, frl, frt, frc, frm):; """"""Set fragment member data through public method analogous to psi4.core.Molecule"""""". if not (len(frl) == len(frt) == len(frc) == len(frm)):; raise ValidationError(""""""Molecule::set_fragment_pattern: fragment arguments not of same length.""""""). self.fragments = frl; self.fragment_types = frt; self.fragment_charges = frc; self.fragment_multiplicities = frm. # Attach methods to qcdb.Molecule class; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol = _parker_xyz2mol_yo. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.qcdb.molecule. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html:64306,Validat,ValidationError,64306,psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"pe[0],; do_shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * qcel.constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_completion,; run_mirror=do_mirror,; verbose=verbose). compare_integers(; True, np.allclose(solution.shift, perturbation.shift, atol=6), 'shifts equiv', verbose=verbose - 1); if not do_resort:; compare_integers(; True,; np.allclose(solution.rotation.T, perturbation.rotation),; 'rotations transpose',; verbose=verbose - 1); if solution.mirror:; compare_integers(True, do_mirror, 'mirror allowed', verbose=verbose - 1). def set_fragment_pattern(self, frl, frt, frc, frm):; """"""Set fragment member data through public method analogous to psi4.core.Molecule"""""". if not (len(frl) == len(frt) == len(frc) == len(frm)):; raise ValidationError(""""""Molecule::set_fragment_pattern: fragment arguments not of same length.""""""). self.fragments = frl; self.fragment_types = frt; self.fragment_charges = frc; self.fragment_multiplicities = frm. # Attach methods to qcdb.Molecule class; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol = _parker_xyz2mol_yo. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.5;  · . PSI4. Module code; psi4.driver.qcdb.molecule. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/qcdb/molecule.html:67154,Validat,ValidationError,67154,psi4manual/1.5.0/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"pedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]; def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:3767,sanitiz,sanitized,3767,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,3,['sanitiz'],['sanitized']
Security,"pen(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program gcp gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Prepare results for Psi4; if isP4regime and dertype != 0:; core.set_variable('GCP CORRECTION ENERGY', dashd); psi_dashdderiv = core.Matrix.from_list(dashdderiv). # Print program output to file if verbose; if not verbose and isP4regime:; verbose = True if core.get_option('SCF', 'PRINT') >= 3 else False; if verbose:. text = '\n ==> GCP Output <==\n'; text += out.decode('utf-8'); if dertype != 0:; with open(derivfile, 'r') as handle:; text += handle.read().replace('D', 'E'); text += '\n'; if isP4regime:; core.print_out(text); else:; print(text). # # Clean up files and remove scratch directory; # os.unlink(paramfile1); # os.unlink(paramfile2); # os.unlink(geomfile); # if dertype != 0:; # os.unlink(derivfile); # if defmoved is True:; # os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); # try:; # shutil.rmtree(dftd3_tmpdir); # except OSError as e:; # ValidationError('Unable to remove dftd3 temporary directory %s' % e); os.chdir(current_directory). # return -D & d(-D)/dx; if dertype == -1:; return dashd, dashdderiv; elif dertype == 0:; return dashd; elif dertype == 1:; return psi_dashdderiv. try:; # Attach method to libmints psi4.Molecule class; core.Molecule.run_gcp = run_gcp; except (NameError, AttributeError):; # But don't worry if that doesn't work b/c; # it'll get attached to qcdb.Molecule class; pass. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.2.1;  · . PSI4. Module code. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_gcp.html:10191,Validat,ValidationError,10191,psi4manual/1.2.1/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_gcp.html,1,['Validat'],['ValidationError']
Security,"pen(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" %; (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzN = re.compile(r'(?:\s*)([A-Z](?:[a-z])?)(?:\s+)' +; NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s*)', re.IGNORECASE); xyzC = re.compile(r'(?:\s*)(\d+\.?\d*)(?:\s+)' +; NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s*)', re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). elif xyzC.match(text[2 + i]):. fileAtom = i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:6614,Validat,ValidationError,6614,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"pes for SCF). """""". if post_scf:; name = ""scf"". optstash = p4util.OptionsState(; ['PUREAM'],; ['BASIS'],; ['QMEFP'],; ['DF_BASIS_SCF'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF_TYPE'], # Hack: scope gets changed internally with the Andy trick; ). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ). # Grab a few kwargs; use_c1 = kwargs.get('use_c1', False); scf_molecule = kwargs.get('molecule', core.get_active_molecule()); read_orbitals = core.get_option('SCF', 'GUESS') is ""READ""; do_timer = kwargs.pop(""do_timer"", True); ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is not None:; raise ValidationError(""Cannot seed an SCF calculation with a reference wavefunction ('ref_wfn' kwarg).""). # SCF Banner data; banner = kwargs.pop('banner', None). # Did we pass in a DFT functional?; dft_func = kwargs.pop('dft_functional', None); if dft_func is not None:; if name.lower() != ""scf"":; raise ValidationError(""dft_functional was supplied to SCF, but method name was not SCF ('%s')"" % name); name = dft_func. # Setup the timer; if do_timer:; core.tstart(). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('SCF', 'SOSCF'):; proc_util.check_non_symmetric_jk_density(""Second-order SCF""). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if core.has_option_changed('SCF', 'BASIS_GUESS'):; cast = core.get_option('SCF', 'BASIS_GUESS'); if p4util.yes.match(str(cast)):; cast = True; elif p4util.no.match(str(cast)):; cast = False. if cast:. # A user can set ""BASIS_GUESS"" to True and we default to 3-21G; if cast is True:; guessbasis = '3-21G'; else:; guessbasis = cast; core.set_global_option('BASIS', guessbasis). castdf = 'DF' in core.get_global_option('SCF_TYPE'). if core.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = core.get_option('SCF', 'DF_BASIS_GUESS'); if p4util.yes.match(str(castdf)):; castdf = True; elif p4util.no.match(str(castdf)):; c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:30240,Validat,ValidationError,30240,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"pl_helgaker_2; else:; raise ValidationError(""Wrong number of basis sets supplied to corl_xtpl: %d"" % nbasis); else:; raise ValidationError(""Stage treatment must be 'corl' or 'scf', not '%s'"" % xtpl_type). def _validate_cbs_inputs(cbs_metadata, molecule):; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata : list; List of dicts containing CBS stage keywords.; molecule : qcdb.molecule or psi4.core.Molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for item in cbs_metadata:; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(""Stage {:d} doesn't have defined level of theory!"".format(cbs_metadata.index(item))); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(""Stage {:d} doesn't have defined basis sets!"".format(cbs_metadata.index(item))); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ""scf"", ""c4-scf""]:; scf = {}; if stage[""wfn""].startswith(""c4""):; scf[""wfn""] = ""c4-hf""; else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xtpl(len(scf[""basis""][1]), scf[""treatment""]); scf[""alpha""] = None; scf[""options""] = False; metadata.append(scf); # 2c) keep processing current stage; stage[""treatment""] = item.get(""treatment"", ""scf"" if len(metadata) == 0 else ""corl""); stage[""stage""] = item.get(""stage"", False); if not stage[""stage""]:; if len(metadata) == 0:; stage[""stage""] = ""scf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:29639,Validat,ValidationError,29639,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"pl_type == ""corl"":; if nbasis == 2:; return corl_xtpl_helgaker_2; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata, molecule):; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata : list; List of dicts containing CBS stage keywords.; molecule : qcdb.molecule or psi4.core.Molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ""scf"", ""c4-scf""]:; scf = {}; if stage[""wfn""].startswith(""c4""):; scf[""wfn""] = ""c4-hf""; else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xtpl(len(scf[""basis""][1]), scf[""treatment""]); scf[""alpha""] = None; scf[""options""] = False; scf[""options_lo""] = False; metadata.append(scf); # 2c) keep processing current stage; stage[""treatment""] = item.get(""treatment"", ""scf"" if len(metadata) == 0 else ""corl""); stage[""stage""] = item.get(""stage"", False); if not stage[""stage""]:; if len(met",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:29990,Validat,ValidationError,29990,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,4,['Validat'],['ValidationError']
Security,"pl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata; List of dicts containing CBS stage keywords.; molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". # TODO: split options into mixable (qc_module=ccenergy/"""") or non-mixable (freeze_core=true/false). metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ""scf"", ""c4-scf""]:; scf = {}; if stage[""wfn""].startswith(""c4""):; scf[""wfn""] = ""c4-hf""; else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:17672,validat,validation,17672,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,3,['validat'],['validation']
Security,"pl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata; List of dicts containing CBS stage keywords.; molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ""scf"", ""c4-scf""]:; scf = {}; if stage[""wfn""].startswith(""c4""):; scf[""wfn""] = ""c4-hf""; else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xtpl(len(scf[""basis""][1]), scf[""treatment""]); scf[""alpha""] = None; scf[""options""] = False; scf[""option",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:17598,validat,validation,17598,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,2,['validat'],['validation']
Security,"place parentheses and commas). For example, basis 6-31++G** is stored in psi4/psi4/share/psi4/basis/6-31ppgss.gbs,; and cc-pV(D+d)Z is stored in psi4/psi4/share/psi4/basis/cc-pv_dpd_z.gbs.; Only one basis set may be specified per file.; Copy the new basis set file into psi4/psi4/share/psi4/basis.; Request the new basis set in an input file in the usual manner.; set basis new_basis_name. (2) Use new basis set file in arbitrary location.; Prepare a basis set file exactly as above. Append the directory; containing the basis set file to the environment variable; PSIPATH. If the directory is the current working directory,; PSI4 will find it automatically, and the directory does not need; to be added to PSIPATH.; Request the new basis set in an input file in the usual manner.; set basis new_basis_name. (3) Include new basis set in input file.; Construct for a basis set a section like the one below that includes; [basis name], PUREAM value, and element basis set; specifications. Hash signs denote comments. This format is exactly like; the stand-alone basis file except for the addition of the basis name in; brackets.; [ sto-3g ]; cartesian; ****; H 0; S 3 1.00; 3.42525091 0.15432897; 0.62391373 0.53532814; 0.16885540 0.44463454; ****; O 0; S 3 1.00; 130.7093200 0.15432897; 23.8088610 0.53532814; 6.4436083 0.44463454; SP 3 1.00; 5.0331513 -0.09996723 0.15591627; 1.1695961 0.39951283 0.60768372; 0.3803890 0.70011547 0.39195739; ****. Copy the section into a PSI4 input file and surround it with the; command basis {...}, as shown below. Multiple basis sets can be; specified by adding additional sections within the surrounding brackets.; Use assign statements to actually request the basis set. This; basis {...} section replaces the usual set basis XXX line.; In a more complex input, if the user needs to call the user-defined; basis by name, this can be achieved using the syntax basis mybas {...},; and then the basis can be recalled later as set basis mybas.; To use a custom basi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/basissets.html:8767,Hash,Hash,8767,psi4manual/master/basissets.html,https://psicode.org,https://psicode.org/psi4manual/master/basissets.html,9,['Hash'],['Hash']
Security,"ple; conversion from these objects to a NumPy array:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10>>> import psi4; >>> import numpy as np. # Build the Psi4 data objects; >>> mat = psi4.Matrix(3, 3); >>> vec = psi4.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; 1; 2>>> new_mat = psi4.Matrix.from_array(mat); >>> new_vec = psi4.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; 1>>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; 1; 2; 3; 4; 5; 6; 7; 8>>> dim = psi4.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.Matrix(""New Matrix"", dim, dim). # Create a list of Psi4 arrays; >>> list_of_arrays = irreped_mat.to_array(). # Or, use the .nph irreped accessor; >>> irreped_mat.nph[0][:] = 1. Where .nph is the irreped accessor form. If .np or np.array are; called on irreped Matrices or Vectors an error will be thrown; however, the; irreped form is always",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/numpy-1.html:1625,Access,Access,1625,psi4manual/1.2.1/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/numpy-1.html,4,['Access'],['Access']
Security,"ple; conversion from these objects to a NumPy array:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10>>> import psi4; >>> import numpy as np. # Build the Psi4 data objects; >>> mat = psi4.Matrix(3, 3); >>> vec = psi4.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; 1; 2>>> new_mat = psi4.Matrix.from_array(mat); >>> new_vec = psi4.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; 1>>> mat.np[:] = 1. this operation is identical to the above. Warning; The following will lead to reference errors: view =; psi4.Matrix(3, 3).np. Here, the Python garbage collection deletes the Matrix; object, the view then points to deleted data resulting in the view effectively; reading random data. As a general rule, never assign the .nph or .np; accessors. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; 1; 2; 3; 4; 5; 6; 7; 8>>> dim = psi4.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.Matrix(""New Matrix"", dim, dim). # Create",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/numpy-1.html:1665,Access,Access,1665,psi4manual/1.1.0/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/numpy-1.html,2,['Access'],['Access']
Security,"plied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import os; import re; import shutil; import subprocess; import sys; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental.util import parse_version, which. from psi4 import core, extras. from .. import p4util; from .. import psifiles as psif; from .. import qcdb; from ..constants import constants; from ..p4util.exceptions import (; ManagedMethodError,; PastureRequiredError,; UpgradeHelper,; ValidationError,; docs_table_link,; ). #from psi4.driver.molutil import *; from ..qcdb.basislist import corresponding_basis; from . import dft, empirical_dispersion, mcscf, proc_util, response, solvent; from .proc_data import method_algorithm_type; from .roa import run_roa. # never import driver, wrappers, or aliases into this file. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http://psicode.org/psi4manual/master/proc_py.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # mani",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:1768,Validat,ValidationError,1768,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"plied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys; from typing import List, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(self, arr: Union[np.ndarray, List[np.ndarray]], name: str = ""New Matrix"", dim1: Union[List, Tuple, core.Dimension] = None, dim2: core.Dimension = None) -> Union[core.Matrix, core.Vector]:; """"""; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters; ----------; arr; Numpy array or list of arrays to use as the data for a new core.Matrix; name; Name to give the new core.Matrix; dim1; If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2; Same as dim1 only if using a psi4.core.Dimension object. Returns; -------; Matrix",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:1756,Validat,ValidationError,1756,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,3,['Validat'],['ValidationError']
Security,"point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:34394,validat,validation,34394,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,2,['validat'],"['validation', 'validator']"
Security,"point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs] @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs] @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs] @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs] @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs] @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs] @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:34602,validat,validation,34602,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,2,['validat'],"['validation', 'validator']"
Security,"point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:34679,validat,validation,34679,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,6,['validat'],"['validation', 'validator']"
Security,"ponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""cg_solver"",; ""davidson_solver"",; ""DIIS"",; ""hamiltonian_solver"",; ""SolverEngine"",; ]. import time; from abc import ABC, abstractmethod; from typing import Any, Callable, Dict, List, Optional, Type. import numpy as np. from psi4 import core. from .exceptions import ValidationError. """"""; Generalized iterative solvers for Psi4. """""". [docs]; def cg_solver(; rhs_vec: List[core.Matrix],; hx_function: Callable,; preconditioner: Callable,; guess: Optional[List[core.Matrix]] = None,; printer: Optional[Callable] = None,; printlvl: int = 1,; maxiter: int = 20,; rcond: float = 1.e-6) -> List[core.Matrix]:; """"""; Solves the :math:`Ax = b` linear equations via Conjugate Gradient. The `A` matrix must be a hermitian, positive definite matrix. Parameters; ----------; rhs_vec; The RHS vector in the Ax=b equation.; hx_function; Takes in a list of :py:class:`~psi4.core.Matrix` objects and a mask of active indices. Returns the Hessian-vector product.; preconditioner; Takes in a list of :py:class:`~psi4.core.Matrix` objects and a mask of active indices. Returns the preconditioned value.; guess; Starting vectors. If None, use a preconditioner (rhs) guess; printer; Takes in a list of current x and residual vectors and provides a print function. This function can also; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:1393,Validat,ValidationError,1393,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,3,['Validat'],['ValidationError']
Security,"ponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""cg_solver"",; ""davidson_solver"",; ""DIIS"",; ""hamiltonian_solver"",; ""SolverEngine"",; ]. import time; from abc import ABC, abstractmethod; from typing import Any, Callable, Dict, List, Optional, Type. import numpy as np. from psi4 import core. from .exceptions import ValidationError. """"""; Generalized iterative solvers for Psi4. """""". [docs]def cg_solver(; rhs_vec: List[core.Matrix],; hx_function: Callable,; preconditioner: Callable,; guess: Optional[List[core.Matrix]] = None,; printer: Optional[Callable] = None,; printlvl: int = 1,; maxiter: int = 20,; rcond: float = 1.e-6) -> List[core.Matrix]:; """"""; Solves the :math:`Ax = b` linear equations via Conjugate Gradient. The `A` matrix must be a hermitian, positive definite matrix. Parameters; ----------; rhs_vec; The RHS vector in the Ax=b equation.; hx_function; Takes in a list of :py:class:`~psi4.core.Matrix` objects and a mask of active indices. Returns the Hessian-vector product.; preconditioner; Takes in a list of :py:class:`~psi4.core.Matrix` objects and a mask of active indices. Returns the preconditioned value.; guess; Starting vectors. If None, use a preconditioner (rhs) guess; printer; Takes in a list of current x and residual vectors and provides a print function. This function can also; re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:1391,Validat,ValidationError,1391,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,1,['Validat'],['ValidationError']
Security,"ponding to `compute_list`.; task_list: List[AtomicComputer] = []. # One-to-One list of QCSchema corresponding to `task_list`.; results_list: List[Any] = []. [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; data = p4util.kwargs_lower(data); data[""metadata""] = _process_cbs_kwargs(data); BaseComputer.__init__(self, **data). self.metameta = {; 'kwargs': data,; 'ptype': self.driver,; 'verbose': self.verbose,; 'label': None,; 'molecule': self.molecule,; }; # logger.debug(""METAMETA\n"" + pp.pformat(self.metameta)). if data['metadata']:; if data['metadata'][0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in driver_cbs.py to proceed."""""" %; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested lesser {delta[""treament""]} method '{delta[""wfn_lo""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ). self.cbsrec, self.compute_list, self.trove = _build_cbs_compute(self.metameta, self.metadata). for job in self.compute_list:; keywords = copy.deepcopy(self.metameta['kwargs']['keywords']); if job[""f_options""] is not False:; stage_keywords = dict(job[""f_options""].items()); keywords = {**keywords, **stage_keywords}; task = AtomicComputer(; **{; ""molecule"": self.molecule,; ""driver"": self.driver,; ""method"": job[""f_wfn""],; ""basis"": job[""f_basis""],; ""keywords"": keywords or {},; }); self.task_list.append(task). # logger.debug(""TASK\n"" + pp.pformat(task.dict())). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled funct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:54512,Validat,ValidationError,54512,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"portal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }; CBSMetadata = List[Dict[str, Any]]. # remove in 1.8; # these get input files to the point where they raise an UpgradeHelper; def xtpl_highest_1():; pass. def scf_xtpl_helgaker_2():; pass. def scf_xtpl_truhlar_2():; pass. def scf_xtpl_karton_2():; pass. def scf_xtpl_helgaker_3():; pass. def corl_xtpl_helgaker_2():; pass. def _expand_bracketed_basis(basisstring: str, molecule: Union[""qcdb.Molecule"", core.Molecule] = None) -> Tuple[List[str], List[int]]:; """"""Function to transform and validate basis series specification for cbs(). Parameters; ----------; basisstring; A string containing the basis sets to be expanded.; A basis set with no paired square brackets is passed through; with zeta level 0 (e.g., ``'6-31+G(d,p)'`` is returned as; ``([""6-31+G(d,p)""], [0])``). A basis set with square brackets is checked; for sensible sequence and returned as separate basis sets; (e.g., ``'cc-pV[Q5]Z'` is returned as ``([""cc-pVQZ"", ""cc-pV5Z""], [4, 5])``).; Allows out-of-order zeta specification (e.g., ``[qtd]``) and numeral for; number (e.g., ``[23]``). Does not allow skipped zetas (e.g., ``[dq]``), zetas; outside the [2,8] range, non-Dunning, non-Ahlrichs, or non-Jensen sets,; or non-findable .gbs sets.; molecule; This function checks that the basis is valid by trying to build; the qcdb.BasisSet object for *molecule* or for H2 if None. Returns; -------; tuple; Tuple in the ``([basis set names], [basis set zetas])`` format. """"""; BSET = []; ZSET = []; legit_compo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:6704,validat,validate,6704,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,4,['validat'],['validate']
Security,"ported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if n_response > 0:; if (""ref_wfn"" in kwargs and not kwargs[""ref_wfn""].same_a_b_orbs()) or core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""Non-RHF CC response properties are not implemented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); if core.get_option('CCDENSITY', 'OPDM_RELAX') or n_two > 0:; # WARNING!!! A one-particle property computed _with_ a two-particle property will differ; # from a one-particle property computed by itself. There are no two-particle properties at; # present, so we can kick the issue further down the road.; core.set_global_option('OPDM_ONLY', 'FALSE'); else:; core.set_global_option('OPDM_ONLY', 'TRUE'); core.cclambda(ccwfn); core.ccdensity(ccwfn). # Need ccresponse only for response-type p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:99788,Validat,ValidationError,99788,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['Validat'],['ValidationError']
Security,"pped, and otherwise badgered into coincidence, then the same; manipulations are applied to the gradient in GRD, the result of which; is printed below and passed on to Optking.; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Cfour c4-scf Gradient Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. ... Irrep: 1 Size: 4 x 3. 1 2 3. 1 0.0000000 -0.0122978 0.0000000; 2 -0.0051192 0.0040993 -0.0088667; 3 -0.0051192 0.0040993 0.0088667; 4 0.0102384 0.0040993 0.0000000. CFOUR scratch file GRD has been read; 4 0.0000000000; 7.0000000000 -0.0880964705 0.0000000000 0.0000000000; 1.0000000000 0.4080144050 -0.9178691296 -1.5897959670; 1.0000000000 0.4080144050 -0.9178691296 1.5897959670; 1.0000000000 0.4080144050 1.8357382590 0.0000000001; 7.0000000000 -0.0122978407 0.0000000000 0.0000000000; 1.0000000000 0.0040992802 -0.0051191833 -0.0088666856; 1.0000000000 0.0040992802 -0.0051191833 0.0088666856; 1.0000000000 0.0040992802 0.0102383666 0.0000000000. The gradient can also be accessed from the input file as a; Matrix object through the wfn as; psi4.core.Wavefunction.gradient(). Previously, cfour communicated through; psi4.core.legacy_gradient which was accessed through psi4.core.get_gradient(); Cfour Files; The contents of all files associated with Cfour are accessible from the; input file through the Python dictionary P4C4_INFO. That is,; P4C4_INFO['zmat'] returns a string of the input file sent to Cfour.; Accessible arguments are zmat, output, and any that have been; produced of grd. For example, to print to the screen if CC convergence; is reached, the following could be placed in the PSI4 input file.; energy('c4-ccsd'); print 'miracle?', 'miracle' in P4C4_INFO['output']. Scratch Files; By default, a separate subdirectory for each Cfour call is created within; the job’s scratch directory. To explicitly specify the location of the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cfour.html:22255,access,accessed,22255,psi4manual/master/cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/cfour.html,4,['access'],['accessed']
Security,"pr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.valerr(dbdatdict, color=color, title=title, xtitle=axis,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def load_saptdata_frombfdb(self, sset='default',; pythonpath='/Users/loriab/linux/bfdb/sapt_punt', failoninc=True): # pythonpath=None; """"""This is a stopgap function that loads sapt component data from; sapt_punt in bfdb repo. """"""; saptpackage = OrderedDict(); for db, odb in self.dbdict.items():; modname = 'sapt_' + odb.dbse; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). try:; saptdata = getattr(datamodule, 'DATA'); except AttributeError:; raise ValidationError(""SAPT punt module does not contain DATA"" + str(modname)); saptmc = saptdata['SAPT MODELCHEM']. dbix = self.dbdict.keys().index(db); for rxn, orxn in odb.hrxn.iteritems():; lss = self.sset[sset][dbix]; if lss is not None:; if rxn in odb.sset[lss]:; dbrxn = orxn.dbrxn; try:; elst = saptdata['SAPT ELST ENERGY'][dbrxn]; exch = saptdata['SAPT EXCH ENERGY'][dbrxn]; ind = saptdata['SAPT IND ENERGY'][dbrxn]; disp = saptdata['SAPT DISP ENERGY'][dbrxn]; except (KeyError, AttributeError):; print(""""""Warning: DATA['SAPT * ENERGY'] missing for reaction %s"""""" % (dbrxn)); if failoninc:; break; else:; if not all([elst, ind, disp]): # exch sometimes physically zero; print(""""""Warning: DATA['SAPT * ENERGY'] missing piece for reaction %s: %s"""""" % (dbrxn, [elst, exch, ind, disp])); if failoninc:; break; saptpackage[dbrxn] = {'mc': saptmc,; 'elst': elst,; 'exch':",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:65284,Validat,ValidationError,65284,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"pre') + ""{0:d}"".format(_zeta_sym2val[b] - 1)); # assemble nZaPa basis sets; elif zapa_basis.match(basisname.group('post')):; bzapa = b.replace(""d"", ""2"").replace(""t"", ""3"").replace(""q"", ""4""); BSET.append(basisname.group('pre') + bzapa + basisname.group('post')); else:; BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(; """"""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z*'. or 'def2-[sdtq]zvp*' or '*pcs[s]eg-[1234]' or '[1234567]ZaPa' """""" %; (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n""""""; elif isinstance(molecule, core.Molecule):; molecule = qcdb.Molecule(molecule.to_dict()). for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound:; e = sys.exc_info()[1]; raise ValidationError(f""""""Basis set '{basis}' not available for molecule.""""""). return (BSET, ZSET). def _contract_bracketed_basis(basisarray: List):; """"""Function to reform a bracketed basis set string from a sequential series; of basis sets. Essentially the inverse of _expand_bracketed_basis(). Used to; print a nicely formatted basis set string in the results table. Parameters; ----------; basisarray; Basis set names, differing by zeta level, e.g. ``[""cc-pvqz"", ""cc-pv5z""]``. Returns; -------; string; A nicely formatted basis set string, e.g. ``""cc-pv[q5]z""`` for the above example. """""". if len(basisarray) == 1:; return basisarray[0]. else:; zetaindx = [i for i in range(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]. pre = basisarray[1][:zetaindx]; post = basisarray[1][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post; return basisstring. [docs]def xtpl_highest_1(functionname: str, zHI: int, valueHI: float, verbose: bool = True, **kwar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:5365,Validat,ValidationError,5365,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"pre') + ""{0:d}"".format(_zeta_sym2val[b] - 1)); # assemble nZaPa basis sets; elif zapa_basis.match(basisname.group('post')):; bzapa = b.replace(""d"", ""2"").replace(""t"", ""3"").replace(""q"", ""4""); BSET.append(basisname.group('pre') + bzapa + basisname.group('post')); else:; BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(; """"""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z*'. or 'def2-[sdtq]zvp*' or '*pcs[s]eg-[1234]' or '[1234567]ZaPa' """""" %; (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n""""""; elif isinstance(molecule, core.Molecule):; molecule = qcdb.Molecule(molecule.to_dict()). for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound:; e = sys.exc_info()[1]; raise ValidationError(f""""""Basis set '{basis}' not available for molecule.""""""). return (BSET, ZSET). def _contract_bracketed_basis(basisarray: List[str]) -> str:; """"""Function to re-form a bracketed basis set string from a sequential series; of basis sets. Essentially the inverse of _expand_bracketed_basis(). Used to; print a nicely formatted basis set string in the results table. Parameters; ----------; basisarray; Basis set names, differing by zeta level, e.g. ``[""cc-pvqz"", ""cc-pv5z""]``. Returns; -------; str; A nicely formatted basis set string, e.g. ``""cc-pv[q5]z""`` for the above example. """""". if len(basisarray) == 1:; return basisarray[0]. else:; zetaindx = [i for i in range(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]; pre = basisarray[1][:zetaindx]; post = basisarray[1][zetaindx + 1:]. return """".join([pre, ""["", *ZSET, ""]"", post]). def return_energy_components():; """"""Define some quantum chemical knowledge, namely what methods are subsumed in othe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:10051,Validat,ValidationError,10051,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,5,['Validat'],['ValidationError']
Security,"print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; # retire components by v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); core.set_variable(""CURRENT DIPOLE X"", core.variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.variable(name.upper() + "" DIPOLE Z"")); core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP I",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:167563,Validat,ValidationError,167563,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:3379,Validat,ValidationError,3379,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"prop); oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval, execute=True):; """"""Function to reset the total memory allocation. Takes memory value; *inputval* as type int, float, or str; int and float are taken literally; as bytes to be set, string taken as a unit-containing value (e.g., 30 mb); which is case-insensitive. Set *execute* to False to interpret *inputval*; without setting in Psi4 core. :returns: *memory_amount* (float) Number of bytes of memory set. :raises: ValidationError when <500MiB or disallowed type or misformatted. :examples:. >>> # [1] Passing absolute number of bytes; >>> psi4.set_memory(600000000); >>> psi4.get_memory(); Out[1]: 600000000L. >>> # [2] Passing memory value as string with units; >>> psi4.set_memory('30 GB'); >>> psi4.get_memory(); Out[2]: 30000000000L. >>> # Good examples; >>> psi4.set_memory(800000000) # 800000000; >>> psi4.set_memory(2004088624.9)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html:2861,Validat,ValidationError,2861,psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,2,['Validat'],['ValidationError']
Security,"prop); oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS',['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and; ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval, execute=True):; """"""Function to reset the total memory allocation. Takes memory value; *inputval* as type int, float, or str; int and float are taken literally; as bytes to be set, string taken as a unit-containing value (e.g., 30 mb); which is case-insensitive. Set *execute* to False to interpret *inputval*; without setting in Psi4 core. :returns: *memory_amount* (float) Number of bytes of memory set. :raises: ValidationError when <500MiB or disallowed type or misformatted. :examples:. >>> # [1] Passing absolute number of bytes; >>> psi4.set_memory(600000000); >>> psi4.get_memory(); Out[1]: 600000000L. >>> # [2] Passing memory value as string with units; >>> psi4.set_memory('30 GB'); >>> psi4.get_memory(); Out[2]: 30000000000L. :good examples:. 800000000 # 800000000; 2004088624.9 # 2004088624; 1.0e9 # 1000000000; '600 mb' # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html:2859,Validat,ValidationError,2859,psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security,"prov_keys:; if not isinstance(dicary[""creator""], str):; raise ValidationError(; """"""Provenance key 'creator' should be string of creating program's name: {}"""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn.sort(key=lambda tup: tup[0]); molinit[""connectivity""] = conn; except ValueError:; raise ValidationError(; ""Connectivity entry is not of form [(at1, at2, bondorder), ...]: {}"".format(connectivity); ). if units.capitalize() in [""Angstrom"", ""Bohr""]:; molinit[""units""] = units.capitalize(); else:; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:13659,Validat,ValidationError,13659,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"psi4.core.Matrix) → float; docstring. symmetrize_gradient(self: psi4.core.Matrix, arg0: psi::Molecule) → None; docstring. symmetry(self: psi4.core.Matrix) → int; docstring. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float; docstring. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. triplet(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: bool, arg3: bool, arg4: bool) → psi4.core.Matrix; docstring. vector_dot(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → float; docstring. zero(self: psi4.core.Matrix) → None; docstring. zero_diagonal(self: psi4.core.Matrix) → None; docstring. zero_lower(self: psi4.core.Matrix) → None; docstring. zero_upper(self: psi4.core.Matrix) → None; docstring. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:16034,access,accessor,16034,psi4manual/1.1.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html,1,['access'],['accessor']
Security,"psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; add string option. get_bool(self: psi4.core.Options, arg0: str) → bool¶; get boolean option. get_current_module(self: psi4.core.Options) → str¶; gets current module. get_double(self: psi4.core.Options, arg0: str) → float¶; get double option. get_int(self: psi4.core.Options, arg0: str) → int¶; get integer option. get_int_vector(self: psi4.core.Options, arg0: str) → List[int]¶; get int vector option. get_str(*args, **kwargs)¶; Overloaded function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. print_global_options(self: psi4.core.Options) → None¶; print the global, cross-module options. print_module_options(self: psi4.core.Options) → None¶; print global and local options prepared for current module. read_globals(self: psi4.core.Options) → bool¶; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str) → None¶; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool) → None¶; set bool option. set_current_module(self: psi4.core.Options, arg0: str) → None¶; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float) → None¶; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int) → None¶; set int option. set_read_globals(self: psi4.core.Options, arg0: bool) → None¶; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; Options. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.options.html:3466,validat,validate,3466,psi4manual/1.4.0/api/psi4.core.options.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.options.html,1,['validat'],['validate']
Security,"psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; add string option. get_bool(self: psi4.core.Options, arg0: str) → bool¶; get boolean option. get_current_module(self: psi4.core.Options) → str¶; gets current module. get_double(self: psi4.core.Options, arg0: str) → float¶; get double option. get_int(self: psi4.core.Options, arg0: str) → int¶; get integer option. get_int_vector(self: psi4.core.Options, arg0: str) → List[int]¶; get int vector option. get_str(*args, **kwargs)¶; Overloaded function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. print_global_options(self: psi4.core.Options) → None¶; print the global, cross-module options. print_module_options(self: psi4.core.Options) → None¶; print global and local options prepared for current module. read_globals(self: psi4.core.Options) → bool¶; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str) → None¶; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool) → None¶; set bool option. set_current_module(self: psi4.core.Options, arg0: str) → None¶; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float) → None¶; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int) → None¶; set int option. set_read_globals(self: psi4.core.Options, arg0: bool) → None¶; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; Options. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.options.html:3466,validat,validate,3466,psi4manual/1.5.0/api/psi4.core.options.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.options.html,1,['validat'],['validate']
Security,"psi4.driver.frequency(name, **kwargs)[source]¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.frequency.html:1101,access,accesses,1101,psi4manual/1.7.x/api/psi4.driver.frequency.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.frequency.html,4,['access'],['accesses']
Security,"psi4.get_option(""OCC"", ""MP2_TYPE"") == ""CONV""):; return run_mp2(name, **kwargs); else:; return run_dfmp2(name, **kwargs). [docs]def run_mp2_select_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2 gradient call; and directing toward the OCC (conv MP2) or the DFMP2 modules. """"""; if (psi4.get_option(""DFMP2"", ""MP2_TYPE"") == ""CONV"") or (psi4.get_option(""OCC"", ""MP2_TYPE"") == ""CONV""):; return run_mp2_gradient(name, **kwargs); else:; return run_dfmp2_gradient(name, **kwargs). [docs]def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; #psi4.set_local_option('SCF', 'SCF_TYPE', 'DF') # insufficient b/c SCF option read in DFMP2; psi4.set_global_option('SCF_TYPE', 'DF'). if not psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 gradients need DF-SCF reference, for now.'). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(psi4.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:21431,Validat,ValidationError,21431,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). if (core.get_option('SCF', 'REFERENCE') != 'RHF') and (name.upper() != ""SAPT0""):; raise ValidationError('Only SAPT0 supports a reference different from \""reference rhf\"".'). do_delta_mp2 = True if name.endswith('dmp2') else False; do_empirical_disp = True if '-d' in name.lower() else False. if do_empirical_disp:; ## Make sure we are turning SAPT0 dispersion off; core.set_local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). # raise Exception(""""). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=dimer_wfn, **kwargs); mp2_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:133209,Validat,ValidationError,133209,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"pt OSError as e:; raise ValidationError('Program dftd3 not found in path. %s' % e); out, err = dashout.communicate(). # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; line = line.decode('utf-8'); if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; os.chdir(current_directory); raise Dftd3Error(""""""Unsuccessful run. Possibly -D variant not available in dftd3 version.""""""). # Parse grad output; if dertype != 0:; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != mol.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), mol.natom())). # Prepare results for Psi4; if isP4regime and dertype != 0:; core.set_variable('DISPERSION CORRECTION ENERGY', dashd); psi_dashdderiv = core.Matrix.from_list(dashdderiv). # Print program output to file if verbose; if not verbose and isP4regime:; verbose = True if core.get_option('SCF', 'PRINT') >= 3 else False; if verbose:. text = '\n ==> DFTD3 Output <==\n'; text += out.decode('utf-8'); if dertype != 0:; with open(derivfile, 'r') as handle:; text += handle.read().replace('D', 'E'); text += '\n'; if isP4regime:; core.print_out(text); else:; print(text). # Clean up files and remove scratch directory; os.unlink(paramfile1); os.unlink(paramfile2); os.unlink(geomfile); if dertype != 0:; os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); try:; shutil.rmtree(dftd3_tmpdir); except OSError as e:; ValidationError('Unable to remove dftd3 temporary directory %",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html:9463,Validat,ValidationError,9463,psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"ption of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.frombuffer(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs) -> core.Matrix:; """"""Chains dot products together from a series of Psi4 Matrix classes. Uses :func:`~psi4.core.doublet`. Parameters; ----------; args; Arbitrary number of :class:`~psi4.core.Matrix` arguments to be; multiplied.; trans; Optional iterable of booleans of length number of `args` to designate; transposes, if any. """"""; trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[n + 1]). return ret. def _irrep_access(self, *args, **kwargs):; """"""; Warns user when iterating/accessing an irrepped object.; """"""; raise ValidationError(""Attempted to access by index/iteration a Psi4 data object that supports multiple""; "" irreps. Please use .np or .nph explicitly.""). # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_serial = _to_serial; core.Matrix.from_serial = classmethod(_from_serial); core.Matrix.chain_dot = _chain_dot; core.Matrix.__iter__ = _irrep_access; core.Matrix.__getitem__ = _irrep_access. # Vector attributes; core.Vector.from_array = classmethod(array_to_matrix); core.Vector.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html:14299,access,accessing,14299,psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,2,['access'],['accessing']
Security,"ption('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); elif name == 'mp4(sdq)':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', False); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); elif name == 'fno-mp4(sdq)':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', False); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); elif name == 'mp3':; core.set_local_option('FNOCC', 'RUN_MP3', True); elif name == 'mp4':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name == 'mp3':; emp3 = core.get_variable(""MP3 TOTAL ENERGY""); cemp3 = core.get_variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"",",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:124599,Validat,ValidationError,124599,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"ption('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); elif name == 'mp4(sdq)':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', False); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); elif name == 'fno-mp4(sdq)':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', False); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); elif name == 'mp3':; core.set_local_option('FNOCC', 'RUN_MP3', True); elif name == 'mp4':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name == 'mp3':; emp3 = core.variable(""MP3 TOTAL ENERGY""); cemp3 = core.variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:123672,Validat,ValidationError,123672,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"ption('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); elif name == 'mp4(sdq)':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', False); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); elif name == 'fno-mp4(sdq)':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', False); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); elif name == 'mp3':; core.set_local_option('FNOCC', 'RUN_MP3', True); elif name == 'mp4':; core.set_local_option('FNOCC', 'RUN_MP4', True); core.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_option('SCF', 'SCF_TYPE'), ref_wfn); else:; scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name == 'mp3':; emp3 = core.get_variable(""MP3 TOTAL ENERGY""); cemp3 = core.get_variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:119103,Validat,ValidationError,119103,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"ption('FNOCC', 'RUN_MP4', True); psi4.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); psi4.set_local_option('FNOCC', 'NAT_ORBS', True); elif name == 'mp4(sdq)':; psi4.set_local_option('FNOCC', 'RUN_MP4', True); psi4.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', False); psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); elif name == 'fno-mp4(sdq)':; psi4.set_local_option('FNOCC', 'RUN_MP4', True); psi4.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', False); psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); psi4.set_local_option('FNOCC', 'NAT_ORBS', True); elif name == 'mp3':; psi4.set_local_option('FNOCC', 'RUN_MP3', True); elif name == 'mp4':; psi4.set_local_option('FNOCC', 'RUN_MP4', True); psi4.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True). # throw an exception for open-shells; if psi4.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). fnocc_wfn = psi4.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name == 'mp3':; emp3 = psi4.get_variable(""MP3 TOTAL ENERGY""); cemp3 = psi4.get_variable(""MP3 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp3); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'fno-mp3':; emp3 = psi4.get_variable(""MP3 TOTAL ENERGY""); cemp3 = psi4.get_variable(""MP3 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp3); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'mp4(sdq)':; emp4sd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:103093,Validat,ValidationError,103093,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"ption_changed('WFN'); user_wfn = PsiMod.get_global_option('WFN'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:63296,Validat,ValidationError,63296,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"put file; elif (opt_mode.lower() == 'sow'):; PsiMod.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec banners. try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:28757,Validat,ValidationError,28757,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"putation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_local_option('SCF', 'SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! FISAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' FISAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('FISAPT requires requires \""reference rhf\"".'). if ref_wfn is None:; ref_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). sapt_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SAPT"",; core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS""),; ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SAPT"", sapt_basis). minao = core.BasisSet.build(ref_wfn.molecule(), ""BASIS"",; core.get_global_option(""MINAO_BASIS"")); ref_wfn.set_basisset(""MINAO"", minao). fisapt_wfn = core.fisapt(ref_wfn). optstash.restore(); return fisapt_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:107374,Validat,ValidationError,107374,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"putation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', psi4.get_active_molecule()); else:; psi4.print_out('Warning! FISAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; psi4.print_out(' FISAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(). if psi4.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('FISAPT requires requires \""reference rhf\"".'). if ref_wfn is None:; ref_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); fisapt_wfn = psi4.fisapt(ref_wfn). optstash.restore(); return fisapt_wfn. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = psi4.get_variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to psi4.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not dele",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:91258,Validat,ValidationError,91258,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"putations\n'). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_local_option('SCF', 'SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e; sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True). # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = sapt_dimer.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = sapt_dimer.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, 1); monomerB.set_name('monomerB'); sapt_dimer.update_geometry(); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = sapt_dimer.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = core.get_option('SCF', 'SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'); core.set_global_option('DF_INTS_IO', 'SAVE'); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.set_global_option('DF_INTS_IO', 'LOAD'). if (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:101053,Validat,ValidationError,101053,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"pute difference of vectors *v* - *u*.""""""; return [v[i] - u[i] for i in range(len(v))]. [docs]def dot(v, u):; """"""Compute dot product of vectors *v* and *u*.""""""; return sum(u[i] * v[i] for i in range(len(v))). [docs]def scale(v, d):; """"""Compute by-element scale by *d* of vector *v*.""""""; return [d * v[i] for i in range(len(v))]. [docs]def naivemult(v, u):; """"""Compute by-element multiplication of vectors *v* and *u*.""""""; if len(u) != len(v):; raise ValidationError('naivemult() only defined for vectors of same length \n'); return [u[i] * v[i] for i in range(len(v))]. [docs]def normalize(v):; """"""Compute normalized vector *v*.""""""; vmag = norm(v); return [v[i] / vmag for i in range(len(v))]. [docs]def distance(v, u):; """"""Compute the distance between points defined by vectors *v* and *u*.""""""; return norm(sub(v, u)). [docs]def cross(v, u):; """"""Compute cross product of length 3 vectors *v* and *u*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('cross() only defined for vectors of length 3\n'); return [v[1] * u[2] - v[2] * u[1],; v[2] * u[0] - v[0] * u[2],; v[0] * u[1] - v[1] * u[0]]. [docs]def rotate(v, theta, axis):; """"""Rotate length 3 vector *v* about *axis* by *theta* radians.""""""; if len(v) != 3 or len(axis) != 3:; raise ValidationError('rotate() only defined for vectors of length 3\n'). unitaxis = normalize(copy.deepcopy(axis)); # split into parallel and perpendicular components along axis; parallel = scale(axis, dot(v, axis) / dot(axis, axis)); perpendicular = sub(v, parallel); # form unit vector perpendicular to parallel and perpendicular; third_axis = perp_unit(axis, perpendicular); third_axis = scale(third_axis, norm(perpendicular)). result = add(parallel, add(scale(perpendicular, math.cos(theta)), scale(third_axis, math.sin(theta)))); for item in range(len(result)):; if math.fabs(result[item]) < ZERO:; result[item] = 0.0; return result. [docs]def perp_unit(u, v):; """"""Compute unit vector perpendicular to length 3 vectors *u* and *v*.""""""; if len(u) != 3 or le",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html:2502,Validat,ValidationError,2502,psi4manual/1.0.0/_modules/qcdb/vecutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html,1,['Validat'],['ValidationError']
Security,"q]; if theta < 0.0:; t = -1.0 / (math.sqrt(1.0 + theta * theta) - theta); else:; t = 1.0 / (math.sqrt(1.0 + theta * theta) + theta). c = 1.0 / math.sqrt(1.0 + t * t); s = t * c; z = t * A[p][q]. # Apply Jacobi transformation; A[p][q] = 0.0; w[p] -= z; w[q] += z. for r in range(p):; t = A[r][p]; A[r][p] = c * t - s * A[r][q]; A[r][q] = s * t + c * A[r][q]. for r in range(p + 1, q):; t = A[p][r]; A[p][r] = c * t - s * A[r][q]; A[r][q] = s * t + c * A[r][q]. for r in range(q + 1, 3):; t = A[p][r]; A[p][r] = c * t - s * A[q][r]; A[q][r] = s * t + c * A[q][r]. # Update eigenvectors; for r in range(3):; t = Q[r][p]; Q[r][p] = c * t - s * Q[r][q]; Q[r][q] = s * t + c * Q[r][q]. return None. [docs]def zero(m, n):; """""" Create zero matrix""""""; new_matrix = [[0 for row in range(n)] for col in range(m)]; return new_matrix. [docs]def show(matrix):; """""" Print out matrix""""""; for col in matrix:; print col. [docs]def mscale(matrix, d):; """"""Return *matrix* scaled by scalar *d*""""""; for i in range(len(matrix)):; for j in range(len(matrix[0])):; matrix[i][j] *= d; return matrix. [docs]def mult(matrix1, matrix2):; """""" Matrix multiplication""""""; if len(matrix1[0]) != len(matrix2):; # Check matrix dimensions; raise ValidationError('Matrices must be m*n and n*p to multiply!'). else:; # Multiply if correct dimensions; new_matrix = zero(len(matrix1), len(matrix2[0])); for i in range(len(matrix1)):; for j in range(len(matrix2[0])):; for k in range(len(matrix2)):; new_matrix[i][j] += matrix1[i][k] * matrix2[k][j]; return new_matrix. [docs]def transpose(matrix):; """"""Return matrix transpose""""""; if len(matrix[0]) != len(matrix):; # Check matrix dimensions; raise ValidationError('Matrices must be square.'). tmat = [list(i) for i in zip(*matrix)]; return tmat. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta5] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html:7679,Validat,ValidationError,7679,psi4manual/4.0b5/_modules/qcdb/vecutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html,2,['Validat'],['ValidationError']
Security,"r *project*; :module dbse_project and function load_project. Module search path; can be prepended with *pythonpath*. """"""; mod = self.dbse + '_' + project; func = 'load_' + project; self.load_qcdata(modname=mod, funcname=func, pythonpath=pythonpath). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; """"""""""""; if path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise ValidationError(; ""Reactions pickle file for loading database data from file %s does not exist"" % (pklfile)). with open(pklfile, 'rb') as handle:; hrxns = pickle.load(handle); # no error checking for speed; for rxn, data in hrxns.iteritems():; self.hrxn[rxn].data.update(data). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; hdf5file = os.path.abspath(path) + os.sep + self.dbse + '_' + project + '.h5'; if not os.path.isfile(hdf5file):; raise ValidationError(""HDF5 file for loading database data from file %s does not exist"" % (hdf5file)); try:; import pandas as pd; except ImportError:; raise ValidationError(""Pandas data managment module must be available for import""). try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; intrxn = False; else:; intrxn = True. with pd.get_store(hdf5file) as handle:; for mc in handle['pdie'].keys():; lmc = mc.split('-') # TODO could be done better; method = lmc[0]; bsse = '_'.join(lmc[1:-1]); basis = lmc[-1]. df = handle['pdie'][mc]; for dbrxn in df.index[df.notnull()].values:; [dbse, rxn] = dbrxn.split('-', 1); if intrxn:; rxn = int(rxn); self.hrxn[rxn].data[mc] = ReactionDatum.library_modelchem(dbse=dbse, rxn=rxn,; method=method, mode=bsse, basis=basis,; value=df[dbrxn]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:39718,validat,validated,39718,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['validat'],['validated']
Security,"r case. One Electron Integral Algorithm Overview¶; The following table summarizes which implementation is used; for each type of one electron integral in PSI4. Algorithms used for One Electron Integrals¶. Integral; Class; Implementation; Comment. Three-Center Overlap; ThreeCenterOverlapInt; Libint2; using libint2::Operator::delta for 4-center integrals. Angular Momentum; AngularMomentumInt; M-D. Dipole; DipoleInt; Libint2; no derivatives supported. Electric Field; ElectricFieldInt; Libint2; using first derivative of libint2::Operator::nuclear. Coulomb Potential; ElectrostaticInt; Libint2; evaluated for a single origin and unity charge. Kinetic; KineticInt; Libint2. Multipole Potential; MultipolePotentialInt; M-D; arbitrary order derivative of 1/R supported. Multipole Moments; MultipoleInt; M-D; arbitrary order multipoles supported, including nuclear gradients. Nabla Operator; NablaInt; Libint2; using first derivative of libint2::Operator::overlap. Overlap; OverlapInt; Libint2. Nuclear Coulomb Potential; PotentialInt; Libint2; assumes nuclear centers/charges as the potential. PCM Potential; PCMPotentialInt; Libint2; parallelized over charge points. Quadrupole; QuadrupoleInt; Libint2. Traceless Quadrupole; TracelessQuadrupoleInt; Libint2. Relativistic Potential; RelPotentialInt; Libint2. table of contents. Integrals in PSI4; Introduction; The older style; The new syntax; Sieving; Buffer address; Density Screening; Shell blocking; Permutational symmetry; Using bra-ket symmetry; Instantiating integral objects. One Electron Integrals in PSI4; Calling compute_shell(int P, int Q); Accessing integrals; Derivative Integrals; Changes to External Potential Engines; New Operators Available; Shell Pairs; One Electron Integral Algorithm Overview. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Integrals in PSI4. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_integrals.html:19028,Access,Accessing,19028,psi4manual/1.6.x/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html,1,['Access'],['Accessing']
Security,"r more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys. import numpy as np. from psi4 import core; from .exceptions import *. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(self, arr, name=""New Matrix"", dim1=None, dim2=None):; """"""; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters; ----------; arr : array or list of arrays; Numpy array or list of arrays to use as the data for a new core.Matrix; name : str; Name to give the new core.Matrix; dim1 : list, tuple, or core.Dimension (optional); If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 :; Same as dim1 only if using a psi4.core.Dimension object. Returns; -------; matrix : :py:class:`~psi4.core.Matrix` or :py:class:`~psi4.core.Vector`; Returns the given Psi4 object. Notes; -----; This is a generalized function to convert a NumPy array to a Psi4 object. Examples; --------. >>> data = np.random.ran",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html:1837,Validat,ValidationError,1837,psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"r parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""AtomicComputer"",; ""BaseComputer"",; ""EnergyGradientHessianWfnReturn"",; ]. import abc; import copy; import logging; from typing import Any, Dict, Optional, Tuple, Union, TYPE_CHECKING. from pydantic import Field, validator; import qcelemental as qcel; from qcelemental.models import DriverEnum, AtomicInput, AtomicResult; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs] @abc.abstractmethod; def compute(self):; pass. [docs] @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_base.html:1323,validat,validator,1323,psi4manual/1.7.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_base.html,1,['validat'],['validator']
Security,"r psi4.core.Matrix, optional; When `dertype` is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When `psi4` the python module is importable at `import qcdb`; time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o'lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar ""DISPERSION CORRECTION ENERGY"" is set; * `verbose` triggered when PRINT keywork of SCF module >=3. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, (Molecule, core.Molecule)):; # 1st: called on a qcdb.Molecule; # 2nd: called on a python export of a psi4.Molecule (py-side through Psi4's driver); pass; elif isinstance(mol, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); mol = Molecule(mol); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # Validate arguments; if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError(""""""Requested derivative level 'dertype' %s not valid for run_dftd3."""""" % (dertype)); else:; raise ValidationError(""""""Requested derivative level 'dertype' %s not valid for run_dftd3."""""" % (dertype)). if dashlvl is not None:; dashlvl = dashlvl.lower(); dashlvl = get_dispersion_aliases()[dashlvl] if dashlvl in get_dispersion_aliases() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())); else:; raise ValidationError(""""""Must specify a dashlvl""""""). if func is not None:; dftd3_params = dash_server(func, dashlvl); else:; dftd3_params = {}. if dashparam is not None:; dftd3_params.update(da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html:4655,Validat,ValidationError,4655,psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"r simply; constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irreped Psi4 objects to diagonally blocked dense arrays if `True`. Returns a list of arrays otherwise. Returns; -------; numpy.ndarray; Returns either a list of np.array's or the base array depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. matrix_views = _get_raw_views(matrix, copy=copy). # Return the list of arrays; if dense is False:; return matrix_views. # Build the dense matrix; if isinstance(matrix, core.Vector):; ret_type = '1D'; elif isinstance(matrix, core.Matrix):; ret_type = '2D'; else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % type(matrix)). dim1 = []; dim2 = []; for h in matrix_views:; # Ignore zero dim irreps; if 0 in h.shape:; dim1.append(0); dim2.append(0); else:; dim1.append(h.shape[0]); if ret_type == '2D':; dim2.append(h.shape[1]). ndim1 = np.sum(dim1); ndim2 = np.sum(dim2); if ret_type == '1D':; dense_ret = np.zeros(shape=(ndim1)); start = 0; for d1, arr in zip(dim1, matrix_views):; if d1 == 0: continue; dense_ret[start:start + d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, matrix_views):; if (d1 == 0) or (d2 == 0): continue. dense_ret[start1:start1 + d1, start2:start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; return _get_raw_views(matrix, copy=copy)[0]. @property; def _np_shape(self):; """"""; Shape of the Psi4 data object.; """"""; view_data = _get_raw_views(self); if self.nirrep() > 1:; return tuple(view_data[x].shape for x in range(self.ni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:6707,Validat,ValidationError,6707,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,3,['Validat'],['ValidationError']
Security,"r with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Molecule::atom_at_position: Argument vector not of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vstr', vstr, 'all_variables', self.all_variables, (vstr.upper() in self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. # def __setattr__(self, name, value):; # """"""Function to overload setting attributes to allow geometry; # variable assigment as if member data.; #; # """"""; # try:; # if name.upper() in self.__dict__['all_variables']:; # self.set_variable(name, value); # else:; # self.__dict__[name] = value; # except KeyError:; # self.__dict__[name] = value; #; # def __getattr__(self, name):; # """"""Function to overload accessing attribute co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:35848,Validat,ValidationError,35848,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"r ”.dat” suffix) plus ”.out”. -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to PSI4 for available templates. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -d, --debug¶; Flush the outfile at every fprintf. Default: true iff --with-debug. -V, --version¶; Print version information. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for executables. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins (see Plugins: Adding New Functionality to PSI4) or databases.; Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shell commands. First line for C shell; second for bash.; setenv PYTHONPATH /home/user/psiadditions:$PYTHONPATH; PYTHONPATH=/home/user/psiadditions:$PYTHONPATH; export PYTHONPATH. Place ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/external-1.html:10181,access,access,10181,psi4manual/4.0b4/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/external-1.html,4,['access'],['access']
Security,r('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'def,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:33408,Validat,ValidationError,33408,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,r('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)). # Establish method for fifth delta correction energy; if 'delta5_wfn' in kwargs:; do_delta5 = 1; cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); if not (cbs_delta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)). if 'delta5_wfn_lesser' in kwargs:; cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); else:; cbs_delta5_wfn_lesser = 'mp2'; if not (cbs_delta5_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA5 method lesser \'%s\',MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:73014,Validat,ValidationError,73014,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,r('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)). # Establish method for fifth delta correction energy; if 'delta5_wfn' in kwargs:; do_delta5 = 1; cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); if not (cbs_delta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)). if 'delta5_wfn_lesser' in kwargs:; cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); else:; cbs_delta5_wfn_lesser = 'mp2'; if not (cbs_delta5_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_s,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:73667,Validat,ValidationError,73667,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"r() + 1; now_aval = self.aval.variable_to_string(6); text += ""\t%s %5d %s %5d %s\n"" % (self.symbol(), now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(6); text += ""\t%s %5d %s %5d %s %5d %s\n"" % \; (self.symbol(), now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compute()); # Check for NaN, and don't update if we find one; # what is this? proper py traslation?; if val == val:; self.dval.rset(val * 180.0 / math.pi). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'ZMatrixCoord'. [docs] def clone(self):; """"""Returns new, independent ZMatrixEntry object.""""""; return copy.d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html:11951,Validat,ValidationError,11951,psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,2,['Validat'],['ValidationError']
Security,"r(), 0, root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). _clean_detci(); optstash.restore(); return ciwfn. def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); core.set_local_option('CCEOM', 'WFN', 'EOM_CCSD'); ref_wfn = run_ccenergy('ccsd', **kwargs). elif name == 'eom-cc2':; user_ref = core.get_option('CCENERGY', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'UHF'):; raise ValidationError('Reference %s for EOM-CC2 is not available.' % user_ref); core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CC2'); core.set_local_option('CCEOM', 'WFN', 'EOM_CC2'); ref_wfn = run_ccenergy('cc2', **kwargs). elif name == 'eom-cc3':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC3'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC3'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC3'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CC3'); core.set_local_option('CCEOM', 'WFN', 'EOM_CC3'); ref_wfn = run_ccenergy('cc3', **kwargs). core.cchbar(ref_wfn); core.cceom(ref_wfn). optstash.restore(); return ref_wfn; # TODO ask if all these cc modules not actually changing wfn. def run_eom_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. """"""; optstash =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:114393,Validat,ValidationError,114393,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"r(), 0, root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). _clean_detci(); optstash.restore(); return ciwfn. def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); core.set_local_option('CCEOM', 'WFN', 'EOM_CCSD'); ref_wfn = run_ccenergy('ccsd', **kwargs); elif name == 'eom-cc2':. user_ref = core.get_option('CCENERGY', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'UHF'):; raise ValidationError('Reference %s for EOM-CC2 is not available.' % user_ref). core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CC2'); core.set_local_option('CCEOM', 'WFN', 'EOM_CC2'); ref_wfn = run_ccenergy('cc2', **kwargs); elif name == 'eom-cc3':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC3'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC3'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC3'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CC3'); core.set_local_option('CCEOM', 'WFN', 'EOM_CC3'); ref_wfn = run_ccenergy('cc3', **kwargs). core.cchbar(ref_wfn); core.cceom(ref_wfn). optstash.restore(); return ref_wfn; # TODO ask if all these cc modules not actually changing wfn. def run_eom_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. """"""; optstash =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:107517,Validat,ValidationError,107517,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"r(core, ""EXTERN""):; wfn.set_external_potential(core.EXTERN). return wfn. [docs]def scf_helper(name, post_scf=True, **kwargs):; """"""Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). """""". if post_scf:; name = ""scf"". optstash = p4util.OptionsState(; ['PUREAM'],; ['BASIS'],; ['QMEFP'],; ['DF_BASIS_SCF'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF_TYPE'], # Hack: scope gets changed internally with the Andy trick; ). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ). # Grab a few kwargs; use_c1 = kwargs.get('use_c1', False); scf_molecule = kwargs.get('molecule', core.get_active_molecule()); read_orbitals = core.get_option('SCF', 'GUESS') is ""READ""; do_timer = kwargs.pop(""do_timer"", True); ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is not None:; raise ValidationError(""Cannot seed an SCF calculation with a reference wavefunction ('ref_wfn' kwarg).""). # SCF Banner data; banner = kwargs.pop('banner', None). # Did we pass in a DFT functional?; dft_func = kwargs.pop('dft_functional', None); if dft_func is not None:; if name.lower() != ""scf"":; raise ValidationError(""dft_functional was supplied to SCF, but method name was not SCF ('%s')"" % name); name = dft_func. # Setup the timer; if do_timer:; core.tstart(). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('SCF', 'SOSCF'):; proc_util.check_non_symmetric_jk_density(""Second-order SCF""). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if core.has_option_changed('SCF', 'BASIS_GUESS'):; cast = core.get_option('SCF', 'BASIS_GUESS'); if p4util.yes.match(str(cast)):; cast = True; elif p4util.no.match(str(cast)):; cast = False. if cast:. # A user can set ""BASIS_GUESS"" to True and we default to 3-21G; if cast is True:; guessbasis = '3-2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:29942,Validat,ValidationError,29942,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"r(s, l, t)[source]¶. yes = <_sre.SRE_Pattern object at 0x190fef80>¶. class Keyword(name, typ, arg=None, req=False, callback=None)[source]¶; Placehoder for keyword objects. get()[source]¶. is_required()[source]¶. is_set()[source]¶. is_type(typ)[source]¶. sanity_check(path)[source]¶. set(val)[source]¶. set_status(set)[source]¶. setkw(arg)[source]¶. typecheck()[source]¶. xvalidate(templ, path=None)[source]¶. class Section(name, tag=None, req=False, callback=None)[source]¶; Section class; Placehoder for section objects. add_kw(name, typ, arg=None, req=False, set=False, callback=None)[source]¶. add_kwkw(kw, set=False)[source]¶. add_sect(sect, set=False)[source]¶. check_key(key)[source]¶. equalize(templ)[source]¶. fetch_kw(name)[source]¶. fetch_sect(name)[source]¶. find_sect(path)[source]¶. get(k)[source]¶. get_keys()[source]¶. get_keyword(path)[source]¶. get_sects()[source]¶. getkw(path)[source]¶. is_required()[source]¶. is_set(key=None)[source]¶. run_callbacks(templ)[source]¶. sanitize(templ)[source]¶. sanity_check(path=None)[source]¶. set(k, val)[source]¶. set_status(set)[source]¶. setkw(name, arg)[source]¶. status()[source]¶. xvalidate(templ, path=None)[source]¶. check_ignored(list, sect)[source]¶. check_opt(sect, key)[source]¶. check_required(list, sect)[source]¶. parse_error(s, t, d, err)[source]¶. test(strng)[source]¶. wrappers¶; Module with functions that call the four main driver; functions: driver.energy, driver.optimize,; driver.response, and driver.frequency. auto_fragments(name, **kwargs)[source]¶; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT; usage: auto_fragments(‘’). call_function_in_1st_argument(funcarg, **largs)[source]¶; Function to make primary function call to energy(), opt(), etc.; with options dictionary largs.; Useful when funcarg to call is stored in variable. convert(p, symbol)[source]¶. reconstitute_bracketed_basis(needarray)[source]¶; Function to reform a bracketed basis set strin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:16582,sanitiz,sanitize,16582,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['sanitiz'],['sanitize']
Security,"r,wfn_monomerA,wfn_monomerB). molecule.reset_point_group(user_pg); molecule.update_geometry(). PsiMod.set_global_option('DF_INTS_IO', df_ints_io). optstash.restore(); return e_sapt. [docs]def run_infsapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a INF-SAPT0 calculation of any level. """"""; optstash = OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; PsiMod.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (PsiMod.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); if (sapt_basis == 'dimer'):; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); wfn_dimer = PsiMod.wavefunction(); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:54897,Validat,ValidationError,54897,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"r. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)); return; else:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""""""Python module loading problem for database data """""" + str(modname)); try:; getattr(datamodule, funcname)(self); except AttributeError:; if not failoninc:; print(""""""%s %s data unavailable for database %s.\n"""""" % (modname, funcname, self.dbse)); return; else:; raise ValidationError(""Python module missing function %s for loading data "" % (str(funcname))). print(""""""WrappedDatabase %s: %s %s results loaded"""""" % (self.dbse, modname, funcname)). [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""Loads qcdb.ReactionDatums from standard location for *project*; :module dbse_project and function load_project. Module search path; can be prepended with *pythonpath*. """"""; mod = self.dbse + '_' + project; func = 'load_' + project; self.load_qcdata(modname=mod, funcname=func, pythonpath=pythonpath). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; """"""""""""; if path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise ValidationError(; ""Reactions pickle file for loading database data from file %s does not exist"" % (pklfile)). with open(pklfile, 'rb') as handle:; hrxns = pickle.load(handle); # no error checking for speed; for rxn, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:38395,Validat,ValidationError,38395,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"r_df_basis_mp2 = psi4.get_option('DF_BASIS_MP2'); #user_df_basis_cc = psi4.get_option('DF_BASIS_CC'); #user_df_basis_sapt = psi4.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = psi4.get_option('DF_BASIS_ELST'); b_user_wfn = psi4.has_global_option_changed('WFN'); user_wfn = psi4.get_global_option('WFN'). user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:70756,Validat,ValidationError,70756,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"ract_fragments(reals, ghosts=ghosts). [docs] def extract_fragments(self, reals, ghosts=[]):; """"""Makes a copy of the molecule, returning a new molecule with; only certain fragment atoms present as either ghost or real atoms; *reals*: The list or int of fragments (1-indexed) that should be present in the molecule as real atoms.; *ghosts*: The list or int of fragments (1-indexed) that should be present in the molecule as ghosts.; (method name in libmints is extract_subsets. This is different; in qcdb because the psi4 input parser tries to process lines with; that term, giving rise to Boost:Python type conlicts.) See usage; at :py:func:`~qcdb.molecule.extract_fragments`. """"""; lreals = []; try:; for idx in reals:; lreals.append(idx - 1); except TypeError:; lreals = [reals - 1]; lghosts = []; try:; for idx in ghosts:; lghosts.append(idx - 1); except TypeError:; lghosts = [ghosts - 1]; if len(lreals) + len(lghosts) > self.nfragments():; raise ValidationError('Molecule::extract_fragments: sum of real- and ghost-atom subsets is greater than the number of subsets'). subset = self.clone(); subset.deactivate_all_fragments(); for fr in lreals:; subset.set_active_fragment(fr + 1) # the active fragment code subtracts 1; for fr in lghosts:; subset.set_ghost_fragment(fr + 1) # the ghost fragment code subtracts 1. subset.update_geometry(); return subset. # <<< Methods for Construction >>>. [docs] def create_molecule_from_string(self, text):; """"""Given a string *text* of psi4-style geometry specification; (including newlines to separate lines), builds a new molecule.; Called from constructor. """"""; comment = re.compile(r'^\s*#'); blank = re.compile(r'^\s*$'); bohr = re.compile(r'^\s*units?[\s=]+(bohr|au|a.u.)\s*$', re.IGNORECASE); ang = re.compile(r'^\s*units?[\s=]+(ang|angstrom)\s*$', re.IGNORECASE); orient = re.compile(r'^\s*(no_reorient|noreorient)\s*$', re.IGNORECASE); com = re.compile(r'^\s*(no_com|nocom)\s*$', re.IGNORECASE); symmetry = re.compile(r'^\s*symmetry[\s=]+(\w+)\s*$', re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:14174,Validat,ValidationError,14174,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"ractalClient | None) – . get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. client (qcportal.FractalClient | None) – . Returns:. ret – Gradient or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. Return type:; float | Matrix | Tuple[float | Matrix, Wavefunction]. get_results(client=None)[source]¶; Return results as FiniteDifference-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None) – . Return type:; AtomicResult. plan()[source]¶. validator set_driver  »  driver[source]¶. validator set_molecule  »  molecule[source]¶. table of contents. Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes; Molden Interface Keywords; NORMAL_MODES_WRITE; WRITER_FILE_LABEL. psi4.driver.qcdb.vib Module; Functions. API; FiniteDifferenceComputer; FiniteDifferenceComputer.driver; FiniteDifferenceComputer.findifrec; FiniteDifferenceComputer.metameta; FiniteDifferenceComputer.method; FiniteDifferenceComputer.molecule; FiniteDifferenceComputer.task_list; FiniteDifferenceComputer.computer; FiniteDifferenceComputer.build_tasks(); FiniteDifferenceComputer.compute(); FiniteDifferenceComputer.get_psi_results(); FiniteDifferenceComputer.get_results(); FiniteDifferenceComputer.plan(); FiniteDifferenceComputer.set_driver; FiniteDifferenceComputer.set_molecule. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Psithon Functions: Invoking a Calculation; Harmonic Vibrational Analysis and Vis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/freq.html:10766,validat,validator,10766,psi4manual/1.8.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/freq.html,1,['validat'],['validator']
Security,"ractalClient | None) – . get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. client (qcportal.FractalClient | None) – . Returns:. ret – Gradient or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. Return type:; float | Matrix | Tuple[float | Matrix, Wavefunction]. get_results(client=None)[source]¶; Return results as FiniteDifference-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None) – . Return type:; AtomicResult. plan()[source]¶. validator set_driver  »  driver[source]¶. validator set_molecule  »  molecule[source]¶. table of contents. Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes; Molden Interface Keywords; NORMAL_MODES_WRITE; WRITER_FILE_LABEL. psi4.driver.qcdb.vib Module; Functions. API; FiniteDifferenceComputer; FiniteDifferenceComputer.driver; FiniteDifferenceComputer.findifrec; FiniteDifferenceComputer.metameta; FiniteDifferenceComputer.method; FiniteDifferenceComputer.molecule; FiniteDifferenceComputer.task_list; FiniteDifferenceComputer.computer; FiniteDifferenceComputer.build_tasks(); FiniteDifferenceComputer.compute(); FiniteDifferenceComputer.get_psi_results(); FiniteDifferenceComputer.get_results(); FiniteDifferenceComputer.plan(); FiniteDifferenceComputer.set_driver; FiniteDifferenceComputer.set_molecule. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon Functions: Invoking a Calculation; Harmonic Vibrational Analysis and Vis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/freq.html:10766,validat,validator,10766,psi4manual/1.9.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/freq.html,1,['validat'],['validator']
Security,"radient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). # are we in sow/reap mode?; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:59914,Validat,ValidationError,59914,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"radient'; dfile = open(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Prepare results for Psi4; if isP4regime and dertype != 0:; core.set_variable('DISPERSION CORRECTION ENERGY', dashd); psi_dashdderiv = core.Matrix(self.natom(), 3); psi_dashdderiv.set(dashdderiv). # Print program output to file if verbose; if not verbose and isP4regime:; verbose = True if core.get_option('SCF', 'PRINT') >= 3 else False; if verbose:. text = '\n ==> DFTD3 Output <==\n'; text += out.decode('utf-8'); if dertype != 0:; with open(derivfile, 'r') as handle:; text += handle.read().replace('D', 'E'); text += '\n'; if isP4regime:; core.print_out(text); else:; print(text). # Clean up files and remove scratch directory; os.unlink(paramfile1); os.unlink(paramfile2); os.unlink(geomfile); if dertype != 0:; os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); try:; shutil.rmtree(dftd3_tmpdir); except OSError as e:; ValidationError('Unable to remove dftd3 temporary directory %s' % e); os.chdir(current_directory). # return -D & d(-D)/dx; if dertype == -1:; return dashd, dashdderiv; elif dertype == 0:; return dashd; elif dertype == 1:; return psi_dashdderiv. try:; # Attach method to libmints psi4.Molecule class; core.Molecule.run_dftd3 = run_dftd3; except (NameError, AttributeError):; # But don't worry if that doesn't work b/c; # it'll get attached to qcdb.Molecule class; pass. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. Module code. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html:8787,Validat,ValidationError,8787,psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"radient, or Hessian value at the medium basis set in 3-point; extrapolation.; zHI; Zeta number of the larger basis set in 3-point extrapolation.; Must be `zLO + 2`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 3-point; extrapolation.; verbose; Controls volume of printing.; alpha; Not used. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [4]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0`. References; ----------. .. [4] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(; f""scf_xtpl_helgaker_3: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueMD)}, {type(valueHI)})""; ). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upper(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:15010,Validat,ValidationError,15010,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,4,['Validat'],['ValidationError']
Security,"raise ValidationError('CUHF reference for DFT is not available.'). returnvalue = run_scf(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'). return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). if (PsiMod.get_global_option('SCF_TYPE') != 'DF'):; raise ValidationError('SCF_TYPE must be DF for DFT gradient (for now).'). run_scf_gradient(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); PsiMod.revoke_global_option_changed('REFERENCE'). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; if (name.lower() == 'zapt'):; PsiMod.set_global_option('WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_option('MPN_ORDER_SAVE', 1); elif (name.lower() == 'mp'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_globa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:18150,Validat,ValidationError,18150,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)); #; # if 'delta5_wfn_lesser' in kwargs:; # cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); # else:; # cbs_delta5_wfn_lesser = cbs_delta4_wfn; # if not (cbs_delta5_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and not do_delta4 and not do_delta5:; # pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; # pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; # pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = _expand_bracketed_basis(kwargs['corl_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""CORL basis sets through keyword '%s' are required."""""" % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:35618,Validat,ValidationError,35618,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"ral Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import absolute_import. # Gn theory. import re; import os; import math; import warnings; import driver; import psi4; import p4util; import p4const; #from driver import *; # never import aliases into this file. [docs]def run_gaussian_2(name, **kwargs):. # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""""""g2 computations require ""reference rhf"".""""""). # stash user options:; optstash = p4util.OptionsState(; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','COMPUTE_MP4_TRIPLES'],; ['FREEZE_CORE'],; ['MP2_TYPE'],; ['SCF','SCF_TYPE']). # override default scf_type; psi4.set_local_option('SCF','SCF_TYPE','OUT_OF_CORE'). # optimize geometry at scf level; psi4.clean(); psi4.set_global_option('BASIS',""6-31G(D)""); driver.optimize('scf'); psi4.clean(). # scf frequencies for zpe; scf_e, ref = driver.frequency('scf', return_wfn=True). # thermodynamic properties; du = psi4.get_variable('INTERNAL ENERGY CORRECTION'); dh = psi4.get_variable('ENTHALPY CORRECTION'); dg = psi4.get_variable('GIBBS FREE ENERGY CORRECTION'). freqs = ref.frequencies(); nfreq = freqs.dim(0); freqsum = 0.0; for i in range(0, nfreq):; freqsum += freqs.get(i); zpe = freqsum / p4const.psi_hartree2wavenumbers * 0.8929 * 0.5; psi4.clean(). # optimize geometry at mp2 (no frozen core) level; # note: freeze_core isn't an option in M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:1490,Validat,ValidationError,1490,psi4manual/1.0.0/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html,1,['Validat'],['ValidationError']
Security,"ral Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility function for dumping the Hamiltonian to file in FCIDUMP format.""""""; from __future__ import division. from datetime import datetime. import numpy as np. from psi4.driver import constants; from psi4.driver.p4util.util import compare_values, success; from psi4.driver.procrouting.proc_util import check_iwl_file_from_scf_type. from .exceptions import *. [docs]def fcidump(wfn, fname='INTDUMP', oe_ints=None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989); Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. :returns: None. :raises: ValidationError when SCF wavefunction is not RHF. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files; :param fname: name of the integrals file, defaults to INTDUMP; :param oe_ints: list of additional one-electron integrals to save to file.; So far only EIGENVALUES is a valid option. :examples:. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html:1793,Validat,ValidationError,1793,psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,1,['Validat'],['ValidationError']
Security,"rammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; molecule = PsiMod.get_active_molecule(); if 'molecule' in kwargs:; molecule = kwargs.pop('molecule'). if not molecule:; raise ValueNotSet('no molecule found'). PsiMod.scf(). return PsiMod.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). returnvalue = run_scf(name, **kwargs). for ssuper in superfunctional_list():; if ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; PsiMod.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); PsiMod.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); PsiMod.dfmp2(); returnvalue += dfun.c_alpha() * PsiMod.get_variable('SCS-DF-MP2 CORRELATION ENERGY'). else:; PsiMod.dfmp2(); returnvalue += dfun.c_alpha() * PsiMod.get_variable('DF-MP2 CORRELATION ENERGY'). PsiMod.set_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:22842,Validat,ValidationError,22842,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"ransort(ref_wfn); else:; psi4.transqt2(ref_wfn); psi4.ccsort(). ccwfn = psi4.ccenergy(ref_wfn). if name == 'ccsd(at)':; psi4.cchbar(ref_wfn); psi4.cclambda(ref_wfn). optstash.restore(); return ccwfn. [docs]def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). psi4.set_global_option('DERTYPE', 'FIRST'). if psi4.get_global_option('FREEZE_CORE') == 'TRUE':; raise ValidationError('Frozen core is not available for the CC gradients.'). ccwfn = run_ccenergy(name, **kwargs). if name == 'ccsd':; psi4.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); psi4.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; psi4.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); psi4.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). user_ref = psi4.get_option('CCENERGY', 'REFERENCE'); if user_ref != 'UHF':; raise ValidationError('Reference %s for CCSD(T) gradients is not available.' % user_ref). psi4.cchbar(ccwfn); psi4.cclambda(ccwfn); psi4.ccdensity(ccwfn). derivobj = psi4.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad). optstash.restore(); return ccwfn. [docs]def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'DELETE_TEI'],; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; psi4.set_local_option('TRANSQT2', 'WFN', 'BCCD'); psi4.set_local_option('CCSORT', 'WFN', 'BCCD'); psi4.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); psi4.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; psi4.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); psi4.set_local_option('CCSORT', 'WFN', 'BCCD_T'); psi4.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); psi4.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); psi4.set_local_op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:55386,Validat,ValidationError,55386,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"rather than split btwn R & C,; which may be invalid if not 1-to-1. Weighting is not recommended. Returns; -------; float, ndarray, ndarray; First item is RMSD [A] between `rgeom` and the optimally aligned; geometry computed.; Second item is (3, 3) rotation matrix to optimal alignment.; Third item is (3,) translation vector [a0] to optimal alignment. Sources; -------; Kabsch: Acta Cryst. (1978). A34, 827-828 http://journals.iucr.org/a/issues/1978/05/00/a15629/a15629.pdf; C++ affine code: https://github.com/oleg-alexandrov/projects/blob/master/eigen/Kabsch.cpp; weighted RMSD: http://www.amber.utah.edu/AMBER-workshop/London-2015/tutorial1/; protein wRMSD code: https://pharmacy.umich.edu/sites/default/files/global_wrmsd_v8.3.py.txt; quaternion: https://cnx.org/contents/HV-RsdwL@23/Molecular-Distance-Measures. Author: dsirianni. """"""; if weight is None:; w = np.ones((rgeom.shape[0])); elif isinstance(weight, (list, np.ndarray)):; w = np.asarray(weight); else:; raise ValidationError(f""""""Unrecognized argument type {type(weight)} for kwarg 'weight'.""""""). R = rgeom; C = cgeom; N = rgeom.shape[0]; if np.allclose(R, C):; # can hit a mixed non-identity translation/rotation, so head off; return 0.0, np.identity(3), np.zeros(3). Rcentroid = R.sum(axis=0) / N; Ccentroid = C.sum(axis=0) / N; R = np.subtract(R, Rcentroid); C = np.subtract(C, Ccentroid). R *= np.sqrt(w[:, None]); C *= np.sqrt(w[:, None]). RR = kabsch_quaternion(C.T, R.T) # U; TT = Ccentroid - RR.dot(Rcentroid). C = C.dot(RR); rmsd = np.linalg.norm(R - C) * constants.bohr2angstroms / np.sqrt(np.sum(w)). return rmsd, RR, TT. def kabsch_quaternion(P, Q):; """"""Computes the optimal rotation matrix U which mapping a set of points P; onto the set of points Q according to the minimization of || Q - U * P ||,; using the unit quaternion formulation of the Kabsch algorithm. Arguments:; <np.ndarray> P := MxN array. M=dimension of space, N=number of points.; <np.ndarray> Q := MxN array. M=dimension of space, N=number of points. Retu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html:16572,Validat,ValidationError,16572,psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,3,['Validat'],['ValidationError']
Security,"ray(x))); core.Vector.to_array = _to_array; core.Vector.shape = _np_shape; core.Vector.np = _np_view; core.Vector.nph = _nph_view; core.Vector.__array_interface__ = _array_conversion; core.Vector.np_write = _np_write; core.Vector.np_read = classmethod(_np_read); core.Vector.to_serial = _to_serial; core.Vector.from_serial = classmethod(_from_serial); core.Vector.__iter__ = _irrep_access; core.Vector.__getitem__ = _irrep_access. ### CIVector properties. @property; def _civec_view(self):; """"""; Returns a view of the CIVector's buffer; """"""; return np.asarray(self). core.CIVector.np = _civec_view. ### Dimension properties. @classmethod; def _dimension_from_list(self, dims, name=""New Dimension""):; """"""; Builds a core.Dimension object from a python list or tuple. If a dimension; object is passed a copy will be returned.; """""". if isinstance(dims, (tuple, list, np.ndarray)):; irreps = len(dims); elif isinstance(dims, core.Dimension):; irreps = dims.n(); else:; raise ValidationError(""Dimension from list: Type '%s' not understood"" % type(dims)). ret = core.Dimension(irreps, name); for i in range(irreps):; ret[i] = dims[i]; return ret. def _dimension_to_tuple(dim):; """"""; Converts a core.Dimension object to a tuple.; """""". if isinstance(dim, (tuple, list)):; return tuple(dim). irreps = dim.n(); ret = []; for i in range(irreps):; ret.append(dim[i]); return tuple(ret). def _dimension_iter(dim):; """"""; Provides an iterator class for the Dimension object. Allows:; dim = psi4.core.Dimension(...); list(dim); """""". for i in range(dim.n()):; yield dim[i]. # Dimension attributes; core.Dimension.from_list = _dimension_from_list; core.Dimension.to_tuple = _dimension_to_tuple; core.Dimension.__iter__ = _dimension_iter. # General functions for NumPy array manipulation; def block_diagonal_array(*args):; """"""; Convert square NumPy array to a single block diagonal array.; Mimic of SciPy's block_diag.; """""". # Validate the input matrices.; dim = 0; for matrix in args:; try:; shape = matrix.shape; dim +",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html:14077,Validat,ValidationError,14077,psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,4,['Validat'],['ValidationError']
Security,"rays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type :rtype: Union[Matrix, Vector]. get(*args, **kwargs); Overloaded function. get_block(self, slice); Get a vector block. init(self, arg0); Reallocate the data of the Vector. load(self, psio, file); Load the vector from disk. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename, prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). print_out(self); Prints the vector to the output file. save(self, psio, file); Save the vector to disk. scale(self, sc); Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set_block(self, slice, block); Set a vector block. to_array([copy, dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. vector_dot(self, other); Take the dot product of two vectors. zero(self); Zeros the vector. Attributes Documentation. name¶; The name of the Vector. Used in printing. np¶; View with single irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. add(*args, **kwargs)¶; Overloaded function. add(self: psi4.core.Vector, m: int, val: float) -> None. Add to a single element value located at m. add(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Add to a single element value located at m in irrep h. array_interface(self: psi4.core.Vector) → list¶. axpby(self: psi4.core.Vector, a: float, b: float, other: psi4.core.Vector) → None¶; Adds to this vector scaled by b another vector scaled by a; self <- a * other + b * self. axpy(self: psi4.core.Vector, a: float, other: psi4.core.Vector) → None¶; Adds to this vector (unscaled) another vector scaled by a; self <- a * other + self. clone(self: psi4.core.Vector) → psi4.core.Vector¶; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html:1914,access,accessor,1914,psi4manual/1.9.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html,1,['access'],['accessor']
Security,"rce/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2007-2024, The Psi4 Project.; Last updated on ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_tour.html:2636,access,accessible,2636,psi4manual/master/prog_tour.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_tour.html,1,['access'],['accessible']
Security,"rce/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 A",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_tour-1.html:2627,access,accessible,2627,psi4manual/1.4.0/prog_tour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_tour-1.html,2,['access'],['accessible']
Security,"rce/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 Nov",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/prog_tour-1.html:2627,access,accessible,2627,psi4manual/1.5.0/prog_tour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/prog_tour-1.html,2,['access'],['accessible']
Security,"rce/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_tour.html:2627,access,accessible,2627,psi4manual/1.6.x/prog_tour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_tour.html,1,['access'],['accessible']
Security,"rce/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/prog_tour.html:2627,access,accessible,2627,psi4manual/1.7.x/prog_tour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/prog_tour.html,1,['access'],['accessible']
Security,"rce/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/prog_tour.html:2629,access,accessible,2629,psi4manual/1.8.x/prog_tour.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/prog_tour.html,1,['access'],['accessible']
Security,"rce/glossary_psivariables.rst. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursda",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/prog_tour.html:2629,access,accessible,2629,psi4manual/1.9.x/prog_tour.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/prog_tour.html,1,['access'],['accessible']
Security,"rce]¶; Detects fragments in unfragmented molecule using BFS algorithm.; Currently only used for the WebMO implementation of SAPT. Parameters:. molecule (molecule, optional) – The target molecule, if not the last molecule defined.; seed_atoms (Optional[List[List[int]]]) – List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]. Return type:; Molecule. Returns:. Molecule – fragmented molecule in; Cartesian, fixed-geom (no variable values), no dummy-atom format. Examples; >>> # [1] prepare unfragmented (and non-adjacent-atom) HHFF into (HF)_2 molecule ready for SAPT; >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. psi4.driver.inputparser.process_input(raw_input, print_level=1)[source]¶; Function to preprocess raw input, the text of the input file, then; parse it, validate it for format, and convert it into legitimate Python.; Does a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user’s .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed raw_input. Parameters:. raw_input (str) – Input in a mixture of Python and PSIthon syntax.; print_level (int) – raw_input is printed to the output file unless print_level =0. Return type:; str. psi4.driver.frac.ip_fitting(name, omega_l=0.05, omega_r=2.5, omega_convergence=0.001, maxiter=20, **kwargs)[source]¶; Optimize DFT omega parameter for molecular system. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l (float) – Minimum omega to be considered during fitting.; omega_r (f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/external_apis.html:2426,validat,validate,2426,psi4manual/1.7.x/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/external_apis.html,2,['validat'],['validate']
Security,"rced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). >>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). # are we in sow/reap mode?; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are feezing cartesian, do not orien",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:57157,Validat,ValidationError,57157,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_gradient; ntasks; when driver is g/h; all individual gradients.   1_((1, 2), (1, 2));   (nat, 3); when driver is g/h; total gradient for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat, 3); when driver is g/h; total gradient for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_hessian; ntasks; when driver is h; all individual Hessians.   1_((1, 2), (1, 2));   (nat*3, nat*3); when driver is h; total Hessian for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat*3, nat*3); when driver is h; total Hessian for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. validator set_bsse_type  »  bsse_type[source]¶. validator set_embedding_charges  »  embedding_charges[source]¶. validator set_max_nbody  »  max_nbody[source]¶. validator set_molecule  »  molecule[source]¶. validator set_nfragments  »  nfragments[source]¶. validator set_return_total_data  »  return_total_data[source]¶. table of contents. Basis Set Superposition Corrections; nbody(); API; BsseEnum; BsseEnum.cp; BsseEnum.nocp; BsseEnum.vmfc. ManyBodyComputer; ManyBodyComputer.basis; ManyBodyComputer.bsse_type; ManyBodyComputer.driver; ManyBodyComputer.embedding_charges; ManyBodyComputer.keywords; ManyBodyComputer.max_nbody; ManyBodyComputer.method; ManyBodyComputer.molecule; ManyBodyComputer.nbodies_per_mc_level; ManyBodyComputer.nfragments; ManyBodyComputer.quiet; ManyBodyComputer.return_total_data; ManyBodyComputer.task_list; ManyBodyComputer.build_tasks(); ManyBodyComputer.compute(); ManyBodyComputer.get_psi_results(); ManyBodyComputer.get_results(); ManyBodyComputer.plan(); ManyBodyComputer.prepare_results(); ManyBodyComputer.set_bsse_type; ManyBodyComputer.set_embedding_charges; ManyBodyComputer.set_max_nbody; ManyBodyComputer.set_molecule; ManyBodyComputer.set_nfragments; ManyBodyComputer.set_return_total_da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/nbody.html:35164,validat,validator,35164,psi4manual/master/nbody.html,https://psicode.org,https://psicode.org/psi4manual/master/nbody.html,3,['validat'],['validator']
Security,"rder': 5, 'fullname': 'CCSDTQP-1a' },; 'sdtqph-1a' : { 'method': 5, 'order': 6, 'fullname': 'CCSDTQPH-1a' },; 'sdt-1b' : { 'method': 6, 'order': 3, 'fullname': 'CCSDT-1b' },; 'sdtq-1b' : { 'method': 6, 'order': 4, 'fullname': 'CCSDTQ-1b' },; 'sdtqp-1b' : { 'method': 6, 'order': 5, 'fullname': 'CCSDTQP-1b' },; 'sdtqph-1b' : { 'method': 6, 'order': 6, 'fullname': 'CCSDTQPH-1b' },; '2' : { 'method': 7, 'order': 2, 'fullname': 'CC2' },; '3' : { 'method': 7, 'order': 3, 'fullname': 'CC3' },; '4' : { 'method': 7, 'order': 4, 'fullname': 'CC4' },; '5' : { 'method': 7, 'order': 5, 'fullname': 'CC5' },; '6' : { 'method': 7, 'order': 6, 'fullname': 'CC6' },; 'sdt-3' : { 'method': 8, 'order': 3, 'fullname': 'CCSDT-3' },; 'sdtq-3' : { 'method': 8, 'order': 4, 'fullname': 'CCSDTQ-3' },; 'sdtqp-3' : { 'method': 8, 'order': 5, 'fullname': 'CCSDTQP-3' },; 'sdtqph-3' : { 'method': 8, 'order': 6, 'fullname': 'CCSDTQPH-3' }; }. # looks for 'sdt(q)' in dictionary; if ccfullname in methods:; return 'mrcc', methods[ccfullname]; else:; raise ValidationError('MRCC method \'%s\' invalid.' % (name)). elif re.match(r'^[a-z]+\d+$', name):; decompose = re.compile(r'^([a-z]+)(\d+)$').match(name); namestump = decompose.group(1); namelevel = int(decompose.group(2)). if namestump in ['mp', 'zapt', 'ci']:; # Let mp2, mp3, mp4 pass through to select functions; if namestump == 'mp' and namelevel in [2, 3, 4]:; return name, None; # Otherwise return method and order; else:; return namestump, namelevel; else:; return name, None; else:; return name, None. [docs]def parse_cotton_irreps(irrep, point_group):; r""""""Function to return validated Cotton ordering index for molecular; *point_group* from string or integer irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:6829,Validat,ValidationError,6829,psi4manual/1.0.0/_modules/driver_util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html,1,['Validat'],['ValidationError']
Security,"re Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; Module with database functionality. """""". __all__ = [; ""database"",; ""db"",; ""DB_RGT"",; ""DB_RXN"",; ]. import collections; import math; import os; import re; import sys. from psi4 import core. from . import p4util; from .constants import constants; from .driver import *. # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]; def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/wrapper_database.html:1602,access,access,1602,psi4manual/1.9.x/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/wrapper_database.html,2,['access'],['access']
Security,"re of the Cartesian->pure; transformation (if required by the basis set). The mechanism for handling this; was to provide a public facing compute_shell(int P, int Q) method for the; caller; this then looked up the appropriate GaussianShell objects that were; passed into the corresponding (private) compute_pair(GaussianShell &s1,; GaussianShell &s2) function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the compute_shell(int P, int Q) simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private compute_pair() routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals¶; Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called buffer_, which was accessed through the integral; object’s buffer() method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator’s batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to buffer(); that returns a single buffer must be replaced with a call to buffer() to; get a list of pointers; we recommend that be assigned the type const auto; &. For simple integrals, such as overlap or kinetic, only the buffer; corresponding to the zeroth element of this array contains integrals. Derivative Integrals¶; The old one electron integral code used translational invariance relations to; minimze the number of integrals to be computed, leaving the caller with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_integrals.html:12899,Access,Accessing,12899,psi4manual/master/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_integrals.html,10,"['Access', 'access']","['Accessing', 'accessed']"
Security,"re relative. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. mints3; Test individual integral objects for correctness. dft-custom; DFT custom functional test. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. soscf-large; Second-order SCF convergnece: Benzene. opt16; SCF 6-31G(d) optimization of TS for HCN to HNC Performs finite difference hessian calculation. Then optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the plane of symemtry, This test confirms that only the reference geometry, with the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). casscf-fzc-sp; CASSCF/6-31G** energy point. scf-coverage; Lithium test for coverage. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. cisd-sp; 6-31G** H2O Test CISD Energy Point. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dct4; DCT calculation fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:24044,Validat,ValidationError,24044,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['Validat'],['ValidationError']
Security,"re(); return dct_wfn. def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(corl_type):; if corl_type == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif corl_type == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_global_option('SCF_TYPE') != 'CD':; core.set_local_option('DFOCC', 'READ_SCF_3INDEX', 'FALSE'); else:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC""""""). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); corl_type = core.get_global_option('MP2_TYPE'); elif name in ['mp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE'); elif name in ['mp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); corl_type = core.get_global_option('CC_TYPE'). elif name == 'ccd':; core.set_local_option('DFO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:54749,Validat,ValidationError,54749,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"re.HF.print_energies = scf_print_energies. def _converged(e_delta, d_rms, e_conv=None, d_conv=None):; if e_conv is None:; e_conv = core.get_option(""SCF"", ""E_CONVERGENCE""); if d_conv is None:; d_conv = core.get_option(""SCF"", ""D_CONVERGENCE""). return (abs(e_delta) < e_conv and d_rms < d_conv). def _validate_damping():; """"""Sanity-checks DAMPING control options. Raises; ------; ValidationError; If any of |scf__damping_percentage|, |scf__damping_convergence|; don't play well together. Returns; -------; bool; Whether DAMPING is enabled during scf. """"""; # Q: I changed the enabled criterion get_option <-- has_option_changed; enabled = (core.get_option('SCF', 'DAMPING_PERCENTAGE') > 0.0); if enabled:; parameter = core.get_option('SCF', ""DAMPING_PERCENTAGE""); if parameter < 0.0 or parameter > 100.0:; raise ValidationError('SCF DAMPING_PERCENTAGE ({}) must be between 0 and 100'.format(parameter)). stop = core.get_option('SCF', 'DAMPING_CONVERGENCE'); if stop < 0.0:; raise ValidationError('SCF DAMPING_CONVERGENCE ({}) must be > 0'.format(stop)). return enabled. def _validate_diis():; """"""Sanity-checks DIIS control options. Raises; ------; ValidationError; If any of |scf__diis|, |scf__diis_start|,; |scf__diis_min_vecs|, |scf__diis_max_vecs| don't play well together. Returns; -------; bool; Whether DIIS is enabled during scf. """"""; enabled = bool(core.get_option('SCF', 'DIIS')); if enabled:; start = core.get_option('SCF', 'DIIS_START'); if start < 1:; raise ValidationError('SCF DIIS_START ({}) must be at least 1'.format(start)). minvecs = core.get_option('SCF', 'DIIS_MIN_VECS'); if minvecs < 1:; raise ValidationError('SCF DIIS_MIN_VECS ({}) must be at least 1'.format(minvecs)). maxvecs = core.get_option('SCF', 'DIIS_MAX_VECS'); if maxvecs < minvecs:; raise ValidationError(; 'SCF DIIS_MAX_VECS ({}) must be at least DIIS_MIN_VECS ({})'.format(maxvecs, minvecs)). return enabled. def _validate_frac():; """"""Sanity-checks FRAC control options. Raises; ------; ValidationError; If any of |sc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:23445,Validat,ValidationError,23445,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security,re.Localizer attribute). UHF (class in psi4.core). UHF_NOONS (SCF). UKSFunctions (class in psi4.core). UNCP-CORRECTED 2-BODY INTERACTION ENERGY. unify() (psi4.core.FISAPT method). unify_part2() (psi4.core.FISAPT method). unit() (psi4.core.SymmetryOperation method). units. ; molecule. units() (psi4.core.Molecule method). Unnormalized (psi4.core.PrimitiveType attribute). up (psi4.driver.p4util.InPsight attribute). UPDATE (DETCI). update() (psi4.core.SOMCSCF method). update_density() (psi4.core.TwoBodyAOInt method). update_geometry() (psi4.core.Molecule method). (psi4.driver.p4util.InPsight method). update_orbitals() (psi4.core.IntegralTransform method). UpgradeHelper. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. v2rdm_casscf. ; plugin. V_potential() (psi4.core.HF method). Va() (psi4.core.HF method). VAL_EX_LEVEL (DETCI). valid_methods (psi4.core.OEProp attribute). validate_diis() (psi4.core.HF method). validate_options() (psi4.core.Options method). ValidationError. value (psi4.core.DerivCalcType attribute). (psi4.core.DiagonalizeOrder attribute). (psi4.core.FragmentType attribute). (psi4.core.GaussianType attribute). (psi4.core.GeometryUnits attribute). (psi4.core.PrimitiveType attribute). (psi4.core.PsiReturnType attribute). (psi4.core.SaveType attribute). value() (psi4.core.SuperFunctional method). values() (psi4.core.SuperFunctional method). variable() (in module psi4.core). (psi4.core.Wavefunction method). variables() (in module psi4.core). (psi4.core.Wavefunction method). Vb() (psi4.core.HF method). VBase (class in psi4.core). vdot() (psi4.core.CIVector method). VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector (class in psi4.core). Vector3 (class in psi4.core). vector_axpy() (psi4.driver.p4util.SolverEngine method). vector_copy() (psi4.driver.p4util.SolverEngine method). vector_dot() (psi4.core.Matrix method). (psi4.core.Vector method). (psi4.driver.p4util.SolverEngine static method). vector_multiply() (psi4.core.CIVector method). ve,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/genindex.html:129206,Validat,ValidationError,129206,psi4manual/1.9.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/genindex.html,1,['Validat'],['ValidationError']
Security,"re.Matrix(3, 3); >>> vec = psi4.core.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; >>> new_mat = psi4.core.Matrix.from_array(mat); >>> new_vec = psi4.core.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; >>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; >>> dim = psi4.core.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.core.Matrix(""New Matrix"", dim, dim). # Create a list of Psi4 arrays; >>> list_of_arrays = irreped_mat.to_array(). # Or, use the .nph irreped accessor; >>> irreped_mat.nph[0][:] = 1. Where .nph is the irreped accessor form. If .np or np.array are; called on irreped Matrices or Vectors an error will be thrown; however, the; irreped form is always valid for non-irreped matrices. Array to Matrix¶; A general function that converts PSI4 data objects to NumPy arrays. psi4.driver.p4util.numpy_helper.array_to_matrix(self, arr, name='New Matri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/numpy.html:1822,access,access,1822,psi4manual/master/numpy.html,https://psicode.org,https://psicode.org/psi4manual/master/numpy.html,9,['access'],['access']
Security,"re.Matrix; dim1 : list, tuple, or core.Dimension (optional); If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 :; Same as dim1 only if using a psi4.core.Dimension object. Returns; -------; matrix : :py:class:`~psi4.core.Matrix` or :py:class:`~psi4.core.Vector`; Returns the given Psi4 object. Notes; -----; This is a generalized function to convert a NumPy array to a Psi4 object. Examples; --------. >>> data = np.random.rand(20); >>> vector = array_to_matrix(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4); """""". # What type is it? MRO can help.; arr_type = self.__mro__[0]. # Irreped case; if isinstance(arr, (list, tuple)):; if (dim1 is not None) or (dim2 is not None):; raise ValidationError(""Array_to_Matrix: If passed input is list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == core.Matrix:; sdim1 = core.Dimension(irreps); sdim2 = core.Dimension(irreps). for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() !",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html:3234,Validat,ValidationError,3234,psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,2,['Validat'],['ValidationError']
Security,"re.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_legacy_frequencies(cls):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.legacy_frequencies` (accessing c-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.legacy_frequencies(). def _core_wavefunction_set_frequencies(cls, val):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_frequencies` (accessing c-side member data) instead of `psi4.core.Wavefunction.frequency_analysis` (py-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_legacy_frequencies(val). core.Wavefunction.frequencies = _core_wavefunction_frequencies; core.Wavefunction.legacy_frequencies = _core_wavefunction_legacy_frequencies; core.Wavefunction.set_frequencies = _core_wavefunction_set_frequencies. def _core_wavefunction_X(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.X` instead of `psi4.core.Wavefunction.lagrangian` is deprecated, and in 1.5 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.lagrangian(). core.Wavefunctio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:35900,access,accessing,35900,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,2,['access'],['accessing']
Security,"re.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If we force c1 copy the active molecule; if use_c1:; scf_molecule.update_geometry(); if scf_molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" A requested method does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); scf_molecule = scf_molecule.clone(); scf_molecule.reset_point_group('c1'); scf_molecule.fix_orientation(True); scf_molecule.fix_com(True); scf_molecule.update_geometry(). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (core.get_option('SCF', 'REFERENCE') in ['RHF', 'RKS']) and \; ((scf_molecule.natom() > 1) or core.get_option('SCF', 'SAD_FRAC_OCC')):; core.set_local_op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:31624,Validat,ValidationError,31624,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"re.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(""""""Stability analysis root following is only available for UHF""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (core.get_option('SCF', 'REFERENCE') in ['RHF', 'RKS']) and \; ((scf_molecule.natom() > 1) or core.get_option('SCF', 'SAD_FRAC_OCC')):; core.set_local_option('SCF', 'GUESS', 'SAD'); elif core.get_option('SCF', 'REFERENCE') in ['ROHF', 'ROKS', 'UHF', 'UKS']:; core.set_local_option('SCF', 'GUESS', 'GWH'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:32518,Validat,ValidationError,32518,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"re.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(""""""Stability analysis root following is only available for UHF""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') == '':; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or brok",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:33062,Validat,ValidationError,33062,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"re.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(""""""Stability analysis root following is only available for UHF""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:41424,Validat,ValidationError,41424,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"re.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:43403,Validat,ValidationError,43403,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"re>.*cc-.*|def2-|.*pcs+eg-|.*)\[(?P<zeta>[dtq2345678,s1]*)\](?P<post>.*z.*|)$', re.IGNORECASE); pc_basis = re.compile(r'.*pcs+eg-$', re.IGNORECASE); def2_basis = re.compile(r'def2-', re.IGNORECASE); zapa_basis = re.compile(r'.*zapa.*',re.IGNORECASE). if legit_compound_basis.match(basisstring):; basisname = legit_compound_basis.match(basisstring); # handle def2-svp* basis sets as double-zeta; if def2_basis.match(basisname.group('pre')):; bn_gz = basisname.group('zeta').replace(""s"", ""d""); # handle pc-n basis set polarisation -> zeta conversion; elif pc_basis.match(basisname.group('pre')):; bn_gz = basisname.group('zeta').replace(""4"", ""5"").replace(""3"", ""4"").replace(""2"", ""3"").replace(""1"", ""2""); else:; bn_gz = basisname.group('zeta'); # filter out commas and be forgiving of e.g., t5q or 3q; zetas = [z for z in zeta_values if (z in bn_gz or str(zeta_values.index(z) + 2) in bn_gz)]; for b in zetas:; if ZSET and (int(ZSET[len(ZSET) - 1]) - zeta_values.index(b)) != 1:; raise ValidationError(""""""Basis set '%s' has skipped zeta level '%s'."""""" %; (basisstring, zeta_val2sym[zeta_sym2val[b] - 1])); # reassemble def2-svp* properly instead of def2-dzvp*; if def2_basis.match(basisname.group('pre')) and b == ""d"":; BSET.append(basisname.group('pre') + ""s"" + basisname.group('post')[1:]); # reassemble pc-n basis sets properly; elif pc_basis.match(basisname.group('pre')):; BSET.append(basisname.group('pre') + ""{0:d}"".format(zeta_sym2val[b] - 1)); # assemble nZaPa basis sets; elif zapa_basis.match(basisname.group('post')):; bzapa = b.replace(""d"",""2"").replace(""t"",""3"").replace(""q"",""4""); BSET.append(basisname.group('pre') + bzapa + basisname.group('post')); else:; BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(; """"""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z*'. or 'def2-[sdtq]zvp*' or '*pcs[s]eg-[1234]' o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:3720,Validat,ValidationError,3720,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"re_csx(); Function to validate energies in CSX files against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. compare_wavefunctions(expected, computed[, …]); Function to compare two wavefunctions. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energies_from_fcidump(intdump). energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, …); Find list of approximate (within max_distance) matches to string seq1 among options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:310188,sanitiz,sanitized,310188,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['sanitiz'],['sanitized']
Security,"recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:5538,access,accessed,5538,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,2,['access'],['accessed']
Security,"recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import psi4; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; psi4.plugin_load(sofile).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/plugins-1.html:5538,access,accessed,5538,psi4manual/4.0b5/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/plugins-1.html,2,['access'],['accessed']
Security,"rected Interaction Energy'] = nocp_interaction_energy. for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = nocp_energy_body_dict[n] - nocp_energy_body_dict[1]. # Compute vmfc energy and ptype; if 'vmfc' in metadata['bsse_type_list']:; _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)""); vmfc_interaction_energy = vmfc_energy_body_dict[metadata['max_nbody']] - vmfc_energy_body_dict[1]; nbody_dict['Valiron-Mayer Function Couterpoise Total Energy'] = vmfc_energy_body_dict[metadata['max_nbody']]; nbody_dict['Valiron-Mayer Function Couterpoise Interaction Energy'] = vmfc_interaction_energy. for n in nbody_range[1:]:; var_key = 'VMFC-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]. # Returns; results = {}; results['nbody'] = nbody_dict. # Figure out and build return types; return_method = metadata['bsse_type_list'][0]. if return_method == 'cp':; results['ptype_body_dict'] = cp_ptype_body_dict; results['energy_body_dict'] = cp_energy_body_dict; elif return_method == 'nocp':; results['ptype_body_dict'] = nocp_ptype_body_dict; results['energy_body_dict'] = nocp_energy_body_dict; elif return_method == 'vmfc':; results['ptype_body_dict'] = vmfc_ptype_body_dict; results['energy_body_dict'] = vmfc_energy_body_dict; else:; raise ValidationError(""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). if metadata['return_total_data']:; results['ret_energy'] = results['energy_body_dict'][metadata['max_nbody']]; else:; results['ret_energy'] = results['energy_body_dict'][metadata['max_nbody']]; results['ret_energy'] -= results['energy_body_dict'][1]. return results. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.2.1;  · . PSI4. Module code. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html:24353,Validat,ValidationError,24353,psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"rection to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the moleucle. :type ptype: string; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data.; """""". ### ==> Parse some kwargs <==; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); ptype = kwargs.pop('ptype', None); return_total_data = kwargs.pop('return_total_data', False); molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); core.clean_variables(). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % ptype). # Figure out BSSE types; do_cp = False; do_nocp = False; do_vmfc = False; return_method = False. # Must be passed bsse_type; bsse_type_list = kwargs.pop('bsse_type'); if bsse_type_list is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(bsse_type_list, list):; bsse_type_list = [bsse_type_list]. for num, btype in enumerate(bsse_type_list):; if btype.lower() == 'cp':; do_cp = True; if (num == 0): return_method = 'cp'; elif btype.lower() == 'nocp':; do_nocp = True; if (num == 0): return_method = 'nocp'; elif btype.lower() == 'vmfc':; do_vmfc = True; if (num == 0): return_method = 'vmfc'; else:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). max_nbody = kwargs.get('max_nbody', -1); max_frag = molecule.nfragments(); if max_nbody == -1:; max_nbody = molecule.nfragments(); else:; max_nbody = min(max_nbody, max_frag). # What levels do we ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html:5847,Validat,ValidationError,5847,psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"rection to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the moleucle. :type ptype: string; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data.; """""". ### ==> Parse some kwargs <==; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); ptype = kwargs.pop('ptype', None); return_total_data = kwargs.pop('return_total_data', False); molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); psi4.clean_variables(). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % ptype). # Figure out BSSE types; do_cp = False; do_nocp = False; do_vmfc = False; return_method = False. # Must be passed bsse_type; bsse_type_list = kwargs.pop('bsse_type'); if bsse_type_list is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(bsse_type_list, list):; bsse_type_list = [bsse_type_list]. for num, btype in enumerate(bsse_type_list):; if btype.lower() == 'cp':; do_cp = True; if (num == 0): return_method = 'cp'; elif btype.lower() == 'nocp':; do_nocp = True; if (num == 0): return_method = 'nocp'; elif btype.lower() == 'vmfc':; do_vmfc = True; if (num == 0): return_method = 'vmfc'; else:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). max_nbody = kwargs.get('max_nbody', -1); max_frag = molecule.nfragments(); if max_nbody == -1:; max_nbody = molecule.nfragments(); else:; max_nbody = min(max_nbody, max_frag). # What levels do we ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:5714,Validat,ValidationError,5714,psi4manual/1.0.0/_modules/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"ree software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for use in input files."""""". __all__ = [; ""copy_file_to_scratch"",; ""copy_file_from_scratch"",; ""cubeprop"",; ""get_memory"",; ""libint2_configuration"",; ""libint2_print_out"",; ""oeprop"",; ""set_memory"",; ]. import os; import re; from typing import Dict, List, Union. from psi4 import core. from .exceptions import ValidationError; from .prop_util import *. [docs]; def oeprop(wfn: core.Wavefunction, *args: List[str], **kwargs):; """"""Evaluate one-electron properties. :returns: None. :param wfn: set of molecule, basis, orbitals from which to compute properties. :param args:. Arbitrary-number of properties to be computed from *wfn*.; See :ref:`Available One-Electron Properties <table:oe_features>`. :type title: str; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop.upper()). # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_ou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/util.html:1444,Validat,ValidationError,1444,psi4manual/1.9.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/util.html,2,['Validat'],['ValidationError']
Security,"reet, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #; from __future__ import absolute_import; from __future__ import print_function; from decimal import Decimal, ROUND_FLOOR, ROUND_CEILING; from .exceptions import *. [docs]class PreservingDict(dict):; """"""Class to store quantum chemical quantities extracted from output; files. Extends the dictionary object to (1) store key as all-caps; version of itself and (2) validate value for duplicate values for the; same key by testing which has more decimal places and whether value; the same within a plausing rounding error. Allows consistency checks; when parsing output files without loss of precision. """""". def __init__(self, *args, **kwargs):; self.update(*args, **kwargs). def __setitem__(self, key, value):; try:; key = key.upper(); except AttributeError:; raise AttributeError('Keys stored as upper-case strings: %s unsuitable' % (key)); value = Decimal(value); if key in self.keys() and not 'CURRENT' in key:; # Validate choosing more detailed value for variable; existing_exp = self[key].as_tuple().exponent # 0.1111 --> -4; candidate_exp = value.as_tuple().exponent; if existing_exp > candidate_exp: # candidate has more digits; places = Decimal(10) ** (existing_exp + 1) # exp+1 permits slack in rounding; best_value = value; else: # existing has more digits; places = Decimal(10) ** (candidate_exp + 1); best_value = self[key]; # Validate values are the same; places = max(places, Decimal('1E-11')) # for computed psivars; #print('FLOOR: ', self[key].quantize(places, rounding=ROUND_FLOOR) - value.quantize(places, rounding=ROUND_FLOOR)); #print('CEIL: ', self[key].quantize(places, rounding=ROUND_CEILING) - value.quantize(places, rounding=ROUND_CEILING)); if (self[key].quantize(places, rounding=ROUND_CEILING).compare(value.quantize(places, rounding=ROUND_CEILING)) != 0) and \; (self[key].quantize(places, rounding=ROUND_FLOOR).compare(value.quantize(places, rounding=ROUND_FLOOR)) != 0):; raise ParsingValidationError(; """"""O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:1884,Validat,Validate,1884,psi4manual/1.0.0/_modules/qcdb/pdict.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html,1,['Validat'],['Validate']
Security,"ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). returnvalue = run_scf(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'). return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). if (PsiMod.get_global_option('SCF_TYPE') != 'DF'):; raise ValidationError('SCF_TYPE must be DF for DFT gradient (for now).'). run_scf_gradient(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); PsiMod.revoke_global_option_changed('REFERENCE'). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; if (name.lower() == 'zapt'):; PsiMod.set_global_option('WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:18055,Validat,ValidationError,18055,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:11784,Validat,ValidationError,11784,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,3,['Validat'],['ValidationError']
Security,"reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:11664,Validat,ValidationError,11664,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH`. """"""; # Validate arguments; if self is None:; self = psi4.get_active_molecule(). dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][fun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:7744,Validat,Validate,7744,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,1,['Validat'],['Validate']
Security,rence; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #if(kwargs.has_key('mode')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise Valid,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:32420,Validat,ValidationError,32420,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"rens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % line. [docs]def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_list = inputfile.split(""\n""); set_re = re.compile(r'^(\s*?)set\s+(?:([-,\w]+)\s+)?(\w+)[\s=]+\[.*', re.IGNORECASE); newinput = """"; while len(input_list):; line = input_list[0]; if set_re.match(line):; # We've found the start of a set matrix [ .... line - hand it off for more checks; newinput += parse_multiline_array(input_list); else:; # Nothing to do - just add the line to the string; newinput += ""%s\n"" % input_list.pop(0); return newinput. [docs]def process_input(raw_input, print_level=1):; """"""Function to preprocess *raw input*, the text of the input file, then; parse it, validate it for format, and convert it into legitimate Python.; *raw_input* is printed to the output file unless *print_level* =0. Does; a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user's .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed *raw_input*. """"""; # Check if the infile is actually an outfile (yeah we did); psi4_id = re.compile(r'PSI4: An Open-Source Ab Initio Electronic Structure Package'); if (re.search(psi4_id, raw_input)):; input_lines = raw_input.split(""\n""); input_re = re.compile(r'^\s*?\=\=> Input File <\=\='); input_start = -1; for line_count in range(len(input_lines)):; line = input_lines[line_count]; if re.match(input_re, line):; input_start = line_count + 3; break. stop_re = re.compile(r'^-{74}'); input_stop = -1;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/input.html:16524,validat,validate,16524,psi4manual/4.0b3/_modules/input.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/input.html,3,['validat'],['validate']
Security,"rent helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/prog_tour.html:2650,access,accessibility,2650,psi4manual/1.7.x/prog_tour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/prog_tour.html,1,['access'],['accessibility']
Security,"rent keyword settings, and cfour {...} block. """"""; # Handle memory; mem = int(0.000001 * core.get_memory()); if mem == 524:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; core.set_local_option('CFOUR', 'TRANSLATE_PSI4', False); else:; molecule.update_geometry(); #print(molecule.create_psi4_string_from_molecule()); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.tagline = molecule.name(); molcmd, molkw = qcdbmolecule.format_molecule_for_cfour(). if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; bascmd, baskw = '', {}; else:; user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1') # need basis printed for *every* atom; qbs = core.BasisSet.build(molecule, ""BASIS"", core.get_global_option('BASIS')); if qbs.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(qbs.genbas()); core.print_out(' GENBAS loaded from Psi4 LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:15826,Validat,ValidationError,15826,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,4,['Validat'],['ValidationError']
Security,"reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalquantity.print_out(). return wfn. def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). def cfour_hessian_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_hessian_list(). def cfo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:13571,Validat,ValidationError,13571,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,4,['Validat'],['ValidationError']
Security,"requests among ‘png’, ‘pdf’, and ‘eps’ formats. relpath; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary.; Prepares flat diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames.; asdf.plot_flat(‘CCSD-CP-atqzadz’, failoninc=False). plot_iowa(modelchem, benchmark='default', sset='default', failoninc=True, verbose=False, title='', xtitle='', xlimit=2.0, view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Computes individual errors for single modelchem versus; benchmark over subset sset. Coloring green-to-purple with; maximum intensity at xlimit. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. plot_liliowa(modelchem, benchmark='default', failoninc=True, xlimit=2.0, view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Note that not possible to access sset of component databases. That is, for Database SSIBBI, SSI-only arylaryl is accessible b/c not defined in BBI, but SSI-only neutral is not accessible. plot_modelchems(modelchem, benchmark='default', mbenchmark=None, sset='default', msset=None, failoninc=True, verbose=False, color='sapt', xlimit=4.0, labeled=True, view=True, mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Computes individual errors and summary statistics over all component; databases for each model chemistry in array modelchem versus benchmark; over subset sset. mbenchmark and msset are array options (same; length as modelchem) that override benchmark and sset, respectively,; for non-uniform specification. Thread color can be ‘rgb’ for old; coloring, a color name or ‘sapt’ for spectrum coloring.; saveas conveys directory (‘/’) and/or filename for saving the; resulting plot. File exten",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:38063,access,access,38063,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['access'],['access']
Security,"restore(). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file (``'continuous'``) or are to be farmed out in an; embarrassingly parallel fashion (``'sow'``/``'reap'``)/ For the latter,; run an initial job with ``'sow'`` and follow instructions in its output file.; For maximum flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:81560,access,accessed,81560,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['access'],['accessed']
Security,"return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, & ``,``; into ``_``. """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases. """"""; from .basislistdunning import load_basfam_dunning; from .basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases. """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_basis(name, role='BASIS'):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found. """"""; role = role.upper(); basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; if role == 'ORNATE':; return fam.ornate; elif role == 'BASIS' or role == 'ORBITAL':; return fam.orbital; elif role == 'JFIT':; return fam.jfit; elif role == 'JKFIT':; return fam.jkfit; elif role == 'RIFIT':; return fam.rifit; elif role == 'DUALFIT':; return fam.dualfit; return None. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislist.html:5586,validat,validate,5586,psi4manual/1.0.0/_modules/qcdb/basislist.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislist.html,1,['validat'],['validate']
Security,"return float(val). if key.upper().startswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; reshaper = (-1, ); elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); elif key.upper().endswith(""QUADRUPOLES""):; reshaper = (-1, 3, 3); elif key.upper().endswith(""OCTUPOLES""):; reshaper = (-1, 3, 3, 3); elif key.upper().endswith(""DIPOLE"") or ""DIPOLE -"" in key.upper():; reshaper = (3, ); elif ""QUADRUPOLE POLARIZABILITY TENSOR"" in key.upper():; reshaper = (3, 3, 3); elif any((key.upper().endswith(p) or f""{p} -"" in key.upper()) for p in _multipole_order):; p = [p for p in _multipole_order if (key.upper().endswith(p) or f""{p} -"" in key.upper())]; reshaper = tuple([3] * _multipole_order.index(p[0])); elif key.upper() in [""MULLIKEN_CHARGES"", ""LOWDIN_CHARGES"", ""MULLIKEN CHARGES"", ""LOWDIN CHARGES"", ""SCF TOTAL ENERGIES""]:; reshaper = (-1, ); elif ""GRADIENT"" in key.upper():; reshaper = (-1, 3); elif ""HESSIAN"" in key.upper():; ndof = int(math.sqrt(len(tgt))); reshaper = (ndof, ndof); else:; raise ValidationError(f'Uncertain how to reshape array: {key}'). return tgt.reshape(reshaper). _multipole_order = [""dummy"", ""dummy"", ""QUADRUPOLE"", ""OCTUPOLE"", ""HEXADECAPOLE""]; for order in range(5, 10):; _multipole_order.append(f""{int(2**order)}-POLE""). def _qcvar_reshape_set(key: str, val: np.ndarray) -> np.ndarray:; """"""Reverse :py:func:`_qcvar_reshape_get` for internal; :py:class:`psi4.core.Matrix` storage. """"""; reshaper = None; if key.upper().startswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; return val; elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); return val.reshape(reshaper); elif key.upper().endswith(""QUADRUPOLES""):; val = val.reshape(-1, 3, 3); val = np.array([_multipole_compressor(val[iat], 2) for iat in range(len(val))]); return val; elif key.upper().endswith(""OCTUPOLES""):; val = val.reshape(-1, 3, 3, 3); val = np.array([_multipole_compressor(val[iat], 3) for iat in range(len(val))]); return val; elif key.upper().endswith(""DIPOLE"") or ""DIPOLE -"" in key.upper():; r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:29631,Validat,ValidationError,29631,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"return_wfn, func, mode, dertype, irrep])[source]¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples:. >>> # [1] Frequency cal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/freq-1.html:1689,access,accesses,1689,psi4manual/1.3.2/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/freq-1.html,2,['access'],['accesses']
Security,"return_wfn, func, mode, dertype, irrep])[source]¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/freq-1.html:1687,access,accesses,1687,psi4manual/1.1.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/freq-1.html,4,['access'],['accesses']
Security,"reviously.; 1; 2; 3; 4; 5; 6; 7; 8; 9# Bypass the scf call if a reference wavefunction is given. ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run.; 1; 2; 3; 4# include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; 1; 2# include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; 1; 2# never include; return returnvalue. Managed Methods¶; When functionality overlaps between modules, a pattern is needed to (1); access each route through the code without contrivances like ccsd2,; _ccsd, sdci and (2) apportion defaulting among the modules, taking; into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).; Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/proc_py-1.html:3818,access,access,3818,psi4manual/1.1.0/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/proc_py-1.html,6,['access'],['access']
Security,"rforms a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:18664,Validat,ValidationError,18664,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"rg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.strip().split(None, 10); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if label == 'electronic energy' and s[8:10] == ['electronic', 'energy']:; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); if label == 'electronic gradient' and s[8:10] == ['electronic', 'gradient']:; E = ast.literal_eval(s[-1]); psi4.print_out('%s RESULT: electronic gradient = %r\n' % (quantity, E)); freagent.close(); return E. [docs]def prepare_options_for_modules(changedOnly=False, commandsInsteadDict=False):; """"""Function to return a string of commands to replicate the; current state of user-modified options. Used to capture C++; options information for distributed (sow/reap) input files. .. caution:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:9094,Validat,ValidationError,9094,psi4manual/1.0.0/_modules/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html,1,['Validat'],['ValidationError']
Security,"rg0: str, arg1: bool) → None; add bool option. add_int(self: psi4.core.Options, arg0: str, arg1: int) → None; add int option. add_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None; add string option. add_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None; add string option. get_bool(self: psi4.core.Options, arg0: str) → bool; get boolean option. get_current_module(self: psi4.core.Options) → str; gets current module. get_double(self: psi4.core.Options, arg0: str) → float; get double option. get_int(self: psi4.core.Options, arg0: str) → int; get integer option. get_int_vector(self: psi4.core.Options, arg0: str) → List[int]; get int vector option. get_str(*args, **kwargs); Overloaded function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. read_globals(self: psi4.core.Options) → bool; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str) → None; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool) → None; set bool option. set_current_module(self: psi4.core.Options, arg0: str) → None; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float) → None; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int) → None; set int option. set_read_globals(self: psi4.core.Options, arg0: bool) → None; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None; set string option. validate_options(self: psi4.core.Options) → None; validate options for arg0 module. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.options.html:4944,validat,validate,4944,psi4manual/1.2.1/api/psi4.core.options.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.options.html,1,['validat'],['validate']
Security,"rges""] # sometimes safe update is too picky about overwriting v_a_f_fragments values; del molinit[""fragment_multiplicities""]; update_with_error(molinit, processed). extern = domain == ""efp"". processed = validate_and_fill_frame(; extern=extern, fix_com=fix_com, fix_orientation=fix_orientation, fix_symmetry=fix_symmetry; ); update_with_error(molinit, processed). if verbose >= 2:; print(""RETURN FROM qcel.molparse.from_arrays(domain={})"".format(domain.upper())); pprint.pprint(molinit). if not np_out:; molinit = unnp(molinit). return molinit. def validate_and_fill_units(; name=None,; units=""Angstrom"",; input_units_to_au=None,; comment=None,; provenance=None,; connectivity=None,; always_return_iutau=False,; ):; molinit = {}. if name is not None:; molinit[""name""] = name. if comment is not None:; molinit[""comment""] = comment. def validate_provenance(dicary):; expected_prov_keys = [""creator"", ""routine"", ""version""]; try:; prov_keys = sorted(dicary.keys()); except AttributeError:; raise ValidationError(""Provenance entry is not dictionary: {}"".format(dicary)). if prov_keys == expected_prov_keys:; if not isinstance(dicary[""creator""], str):; raise ValidationError(; """"""Provenance key 'creator' should be string of creating program's name: {}"""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:12572,Validat,ValidationError,12572,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"rgs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },; ""conv-omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },. ""mp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""TRUE"", },. ""mp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", },. ""oremp2"": {""wfn_type"": ""OREMP"", ""orb_opt"": ""TRUE"", },. ""lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC gradient""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:78676,Validat,ValidationError,78676,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"rgs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e; sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True). # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(). if (core.get_option('SCF', 'REFERENCE') != 'RHF') and (name.upper() != ""SAPT0""):; raise ValidationError('Only SAPT0 supports a reference different from \""reference rhf\"".'). nfrag = sapt_dimer.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). do_delta_mp2 = True if name.endswith('dmp2') else False. sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if sapt_basis == 'dimer':; monomerA = sapt_dimer.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif sapt_basis == 'monomer':; monomerA = sapt_dimer.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2); monomerB.set_name('monomerB'). ri = core.get_option('SCF', 'SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). dimer_wfn = scf_helper('RHF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:94384,Validat,ValidationError,94384,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"rgs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; # cbs_delta3_wfn_lesser = kwargs.get('delta3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:32564,Validat,ValidationError,32564,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"rgs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')); #; # # Establish list of valid basis sets for fifth delta correction energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_3; elif (len(BSTR) == 2) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot be handled."""""" % (len(BSTR))); elif do_corl:; cbs_scf_scheme = xtpl_highest_1; BSTR = [BSTC[-1]]; ZETR = [ZETC[-1]]; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; if do_corl:; if len(BSTC) == 2:; cbs_corl_scheme = corl_xtpl_helgaker_2; elif len(BSTC) > 2:; raise ValidationError(""""""Cannot extrapolate correlation with %d basis sets. Use highest 2."""""" % (len(BSTC))); else:; cbs_corl_scheme = xtpl_highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; if do_delta:; if len(BSTD) == 2:; cbs_delta_scheme = corl_xtpl_helgaker_2; else:; cbs_delta_scheme = xtpl_highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:46961,Validat,ValidationError,46961,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"rgs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')); #; # # Establish list of valid basis sets for fifth delta correction energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_3; elif (len(BSTR) == 2) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot be handled."""""" % (len(BSTR))); elif do_corl:; cbs_scf_scheme = xtpl_highest_1; BSTR = [BSTC[-1]]; ZETR = [ZETC[-1]]; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; if do_corl:; if len(BSTC) == 2:; cbs_corl_scheme = corl_xtpl_helgaker_2; else:; cbs_corl_scheme = xtpl_highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; if do_delta:; if len(BSTD) == 2:; cbs_delta_scheme = corl_xtpl_helgaker_2; else:; cbs_delta_scheme = xtpl_highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; if do_delta2:; if len(BSTD2) == 2:; cbs_delta2_scheme = corl_xtpl_hel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:38460,Validat,ValidationError,38460,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"rgy = energy(""hf""). compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, ""Nuclear repulsion energy"") #TEST; compare_values(refenergy, thisenergy, 9, ""Reference energy"") #TEST; compare_values(refenergy, get_variable('scf total energy'), 9, ""Reference energy"") #TEST. Of those small modifications, first, note the special comment at the top (starting with the #! comment marker). This should be descriptive since it is inlined into the manual (unless !nosample in the comment) as a sample input.; The reference values are assigned to variables for later use. The compare_values function (along with several relatives in psi4/psi4/driver/p4util/testing.py for comparing strings, matrices, etc.) checks that the computed values match these reference values to suitable precision. This function prints an error message and signals that the test failed to the make system, if the values don’t match. Any lines of the input associated with the validation process should be flagged with #TEST at the end of each line, so that they can be removed when copying from the tests to the samples directory.; Finally, add the directory name to the list of tests in psi4/tests/CMakeLists.txt.; In preparing the test case, turn energy, density, amplitude, and; geometry convergence criteria to very tight levels, and use these; results for reference energies, reference geometries, reference cube; files, etc.. Then, either remove or relax the convergence settings,; if these are not a vital part of the test. In choosing the number of; digits for compare_values() and other compare_* functions,; select a number looser than the convergence set in the test or the; default convergence for the calculation type (energy, gradient, etc.). Adding PsiAPI Test Cases¶; Sometimes you want to add tests that check several variations of a; template job or that test error handling or that are PsiAPI rather than; PSIthon focused. In these cases, you’ll want to add to the second test; suite that lives at psi4/tests/pyt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/add_tests-1.html:2577,validat,validation,2577,psi4manual/1.4.0/add_tests-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/add_tests-1.html,4,['validat'],['validation']
Security,"rgy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE; Default: FALSE. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. INTEGRAL_PACKAGE¶. Integral package to use. If compiled with ERD or Simint support, change this option to use them; LibInt is used otherwise. Type: string; Possible Values: ERD, LIBINT, SIMINT; Default: LIBINT. LITERAL_CFOUR¶. Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through cfour {...} block. Type: string; Default: No Default. MOLDEN_WITH_VIRTUAL¶. Write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs (false). Type: boolean; Default: true. MP2_TYPE¶. Algorithm to use for MP2 computation. See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: DF. MP_TYPE¶. Algorithm to use for MPn ( \(n>2\) ) computation (e.g., MP3 or MP2.5 or MP4(SDQ)). See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: CONV. NUM_FROZEN_DOCC¶. The number of core orbitals to freeze in later correlated computations. This trumps FREEZE_CORE. Type: integer; Default: 0. NUM_FROZEN_UOCC¶. The number of virtual orbitals to freeze in later correlated computations. Type: integer; Default: 0. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. PRINT¶. The amount of information to pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__globals-1.html:3675,Access,Access,3675,psi4manual/1.1.0/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__globals-1.html,4,['Access'],['Access']
Security,"rgy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:169075,Validat,ValidationError,169075,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"rgy':; finalquantity = finalenergy; elif ptype == 'gradient':; finalquantity = finalgradient; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif ptype == 'hessian':; finalquantity = finalhessian; wfn.set_hessian(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT HESSIAN'); finalquantity.print_out(). if return_wfn:; return (finalquantity, wfn); else:; return finalquantity. _lmh_labels = {1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']}. def _expand_scheme_orders(scheme, basisname, basiszeta, wfnname, natom):; """"""Check that the length of *basiszeta* array matches the implied degree of; extrapolation in *scheme* name. Return a dictionary of same length as; basiszeta, with *basisname* and *basiszeta* distributed therein. """"""; Nxtpl = len(basiszeta). if int(scheme.__name__.split('_')[-1]) != Nxtpl:; raise ValidationError(""""""Call to '%s' not valid with '%s' basis sets."""""" % (scheme.__name__, len(basiszeta))). f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_energy', 'f_gradient', 'f_hessian']; NEED = {}; for idx in range(Nxtpl):; NEED[_lmh_labels[Nxtpl][idx]] = dict(zip(f_fields, [wfnname, basisname[idx], basiszeta[idx],; 0.0,; core.Matrix(natom, 3),; core.Matrix(3 * natom, 3 * natom)])); return NEED. def _contract_scheme_orders(needdict, datakey='f_energy'):; """"""Prepared named arguments for extrapolation functions by; extracting zetas and values (which one determined by *datakey*) out; of *needdict* and returning a dictionary whose keys are contructed; from _lmh_labels. """"""; largs = {}; largs['functionname'] = needdict['HI']['f_wfn']; Nxtpl = len(needdict); zlabels = _lmh_labels[Nxtpl] # e.g., ['LO', 'HI']. for zeta in range(Nxtpl):; zlab = zlabels[zeta] # e.g., LO; largs['z' + zlab] = needdict[zlab]['f_zeta']; largs['value' + zlab] = needdict[zlab][datakey]. return largs. ## Aliases ##; complete_basis_se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:55367,Validat,ValidationError,55367,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"rgy':; finalquantity = finalenergy; elif ptype == 'gradient':; finalquantity = finalgradient; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; psi4.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif ptype == 'hessian':; finalquantity = finalhessian; wfn.set_hessian(finalquantity); if finalquantity.rows(0) < 20:; psi4.print_out('CURRENT HESSIAN'); finalquantity.print_out(). if return_wfn:; return (finalquantity, wfn); else:; return finalquantity. _lmh_labels = {1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']}. def _expand_scheme_orders(scheme, basisname, basiszeta, wfnname, natom):; """"""Check that the length of *basiszeta* array matches the implied degree of; extrapolation in *scheme* name. Return a dictionary of same length as; basiszeta, with *basisname* and *basiszeta* distributed therein. """"""; Nxtpl = len(basiszeta). if int(scheme.__name__.split('_')[-1]) != Nxtpl:; raise ValidationError(""""""Call to '%s' not valid with '%s' basis sets."""""" % (scheme.__name__, len(basiszeta))). f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_energy', 'f_gradient', 'f_hessian']; NEED = {}; for idx in range(Nxtpl):; NEED[_lmh_labels[Nxtpl][idx]] = dict(zip(f_fields, [wfnname, basisname[idx], basiszeta[idx],; 0.0,; psi4.Matrix(natom, 3),; psi4.Matrix(3 * natom, 3 * natom)])); return NEED. def _contract_scheme_orders(needdict, datakey='f_energy'):; """"""Prepared named arguments for extrapolation functions by; extracting zetas and values (which one determined by *datakey*) out; of *needdict* and returning a dictionary whose keys are contructed; from _lmh_labels. """"""; largs = {}; largs['functionname'] = needdict['HI']['f_wfn']; Nxtpl = len(needdict); zlabels = _lmh_labels[Nxtpl] # e.g., ['LO', 'HI']. for zeta in range(Nxtpl):; zlab = zlabels[zeta] # e.g., LO; largs['z' + zlab] = needdict[zlab]['f_zeta']; largs['value' + zlab] = needdict[zlab][datakey]. return largs. ## Aliases ##; cbs = complete_ba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:54957,Validat,ValidationError,54957,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"rgy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:79562,validat,validate,79562,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,2,['validat'],['validate']
Security,"riable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array QCVariable *key* from global memory if present."""""". if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls: core.Wavefunction, key: str) -> None:;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:29179,Validat,ValidationError,29179,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"riable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line.split()[0].strip()):; glines.append(line); else:; raise ValidationError('Molecule::create_molecule_from_string: Unidentifiable line in geometry specification: %s' % (line)). # catch last default fragment cgmp; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1). # Now go through the rest of the lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; zmatrix = False; for line in glines:. # handle fragment markers; if frag.match(line):; ifrag += 1; self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); tempfrag = []. # handle atom markers; else:; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomm = atom.match(line.split()[0].strip().upper()); atomLabel = atomm.group('label'); atomSym = atomm.group('symbol'). # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; ghostAtom = False if (atomm.group('gh1') is None and atomm.group('gh2') is None) else True. # Check that the atom symbol is valid; if not atomSym in el2z:; ra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:17340,Validat,ValidationError,17340,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"rial(self, json_data):; """"""; Converts serialized data to the correct Psi4 data type; """""". if json_data[""type""] == ""vector"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); ret = self(""Vector from JSON"", dim1); elif json_data[""type""] == ""matrix"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); dim2 = core.Dimension.from_list([x[1] for x in json_data[""shape""]]); ret = self(""Matrix from JSON"", dim1, dim2); else:; raise ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.frombuffer(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs):; """"""; Chains dot products together from a series of Psi4 Matrix classes. By default there is no transposes, an optional vector of booleans can be passed in.; """""". trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[n + 1]). return ret. def _irrep_access(self, *args, **kwargs):; """"""; Warns user when iterating/accessing an irreped object.; """"""; raise ValidationError(""Attempted to access by index/iteration a Psi4 data object that supports multiple""; "" irreps. Please use .np or .nph explicitly.""). # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_seria",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:11848,Validat,ValidationError,11848,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,3,['Validat'],['ValidationError']
Security,"rial(self, json_data):; """"""; Converts serialized data to the correct Psi4 data type; """""". if json_data[""type""] == ""vector"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); ret = self(""Vector from JSON"", dim1); elif json_data[""type""] == ""matrix"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); dim2 = core.Dimension.from_list([x[1] for x in json_data[""shape""]]); ret = self(""Matrix from JSON"", dim1, dim2); else:; raise ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.frombuffer(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs):; """"""; Chains dot products together from a series of Psi4 Matrix classes. By default there is no transposes, an optional vector of booleans can be passed in.; """""". trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[n + 1]). return ret. def _irrep_access(self, *args, **kwargs):; """"""; Warns user when iterating/accessing an irreped object.; """"""; raise ValidationError(""Attempted to access by index/iteration a Psi4 data object that supports multiple""; ""irreps. Please use .np or .nph explicitly.""). # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_serial",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html:11779,Validat,ValidationError,11779,psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"rial(self, json_data):; """"""; Converts serialized data to the correct Psi4 data type; """""". if json_data[""type""] == ""vector"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); ret = self(""Vector from JSON"", dim1); elif json_data[""type""] == ""matrix"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); dim2 = core.Dimension.from_list([x[1] for x in json_data[""shape""]]); ret = self(""Matrix from JSON"", dim1, dim2); else:; raise ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.fromstring(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs):; """"""; Chains dot products together from a series of Psi4 Matrix classes. By default there is no transposes, an optional vector of booleans can be passed in.; """""". trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.Matrix.doublet(ret, mat, False, trans[n + 1]). return ret. # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_serial = _to_serial; core.Matrix.from_serial = classmethod(_from_serial); core.Matrix.chain_dot = _chain_dot. # Vector attributes; core.Vector.from_array = classmethod(array_to_matrix); core.Vector.from_list = classmethod(lambda self, x: array_to_matrix(self, n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html:11961,Validat,ValidationError,11961,psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"ring of commands to replicate the current state of user-modified options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. get_memory(); Return the total memory allocation in bytes. get_psifile(fileno[, pidspace]); Form full path and filename for psi scratch file. getattr_ignorecase(module, attr); Extract attribute attr from module if attr is available in any possible lettercase permutation. hamiltonian_solver(engine, guess, *, nroot); Finds the smallest eigenvalues and associated right and left hand eigenvectors of a large real Hamiltonian eigenvalue problem emulated through an engine. hold_options_state(); Return a context manager that will collect the current state of Process:environment.options on entry to the with-statement and clear and restore the collected keywords state when exiting the with-statement. import_ignorecase(module); Import loader for module in any possible lettercase permutation. kwargs_lower(kwargs); Function to rebuild and return kwargs dictionary sanitized. levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. libint2_configuration(); Returns information on integral classes, derivatives, and AM from currently linked Libint2. libint2_print_out(). mat2arr(mat); Convert Matrix to List. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. pcm_helper(block); Helper to specify the multiline PCMSolver syntax for PCM. plump_qcvar(key, val); Prepare serialized QCVariables for QCSchema AtomicResult.extras[""qcvars""] by converting flat arrays into numpy, shaped ones and floating strings. prefactor_ecd(); Prefactor for converting microscopic observable to decadic molar extinction coefficient in electronic circular dichroism. prefactor_opa(); Prefactor for converting microscopic observable to decadic molar extinction coefficient in one-photon absorption. prepare_options_for_modu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:26144,sanitiz,sanitized,26144,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,1,['sanitiz'],['sanitized']
Security,"ring of commands to replicate the current state of user-modified options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. get_memory(); Return the total memory allocation in bytes. get_psifile(fileno[, pidspace]); Form full path and filename for psi scratch file. getattr_ignorecase(module, attr); Extract attribute attr from module if attr is available in any possible lettercase permutation. hamiltonian_solver(engine, guess, *, nroot); Finds the smallest eigenvalues and associated right and left hand eigenvectors of a large real Hamiltonian eigenvalue problem emulated through an engine. hold_options_state(); Return a context manager that will collect the current state of Process:environment.options on entry to the with-statement and clear and restore the collected keywords state when exiting the with-statement. import_ignorecase(module); Import loader for module in any possible lettercase permutation. kwargs_lower(kwargs); Function to rebuild and return kwargs dictionary sanitized. levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. libint2_configuration(); Returns information on integral classes, derivatives, and AM from currently linked Libint2. libint2_print_out(). rtype:; None. mat2arr(mat); Convert Matrix to List. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. pcm_helper(block); Helper to specify the multiline PCMSolver syntax for PCM. plump_qcvar(key, val); Prepare serialized QCVariables for QCSchema AtomicResult.extras[""qcvars""] by converting flat arrays into numpy, shaped ones and floating strings. prefactor_ecd(); Prefactor for converting microscopic observable to decadic molar extinction coefficient in electronic circular dichroism. prefactor_opa(); Prefactor for converting microscopic observable to decadic molar extinction coefficient in one-photon absorption. prepare_op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:26263,sanitiz,sanitized,26263,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,1,['sanitiz'],['sanitized']
Security,"ring of commands to replicate the current state of user-modified options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. get_memory(); Return the total memory allocation in bytes. get_psifile(fileno[, pidspace]); Form full path and filename for psi scratch file. getattr_ignorecase(module, attr); Extract attribute attr from module if attr is available in any possible lettercase permutation. hamiltonian_solver(engine, guess, *, nroot); Finds the smallest eigenvalues and associated right and left hand eigenvectors of a large real Hamiltonian eigenvalue problem emulated through an engine. hold_options_state(); Return a context manager that will collect the current state of Process:environment.options on entry to the with-statement and clear and restore the collected keywords state when exiting the with-statement. import_ignorecase(module); Import loader for module in any possible lettercase permutation. kwargs_lower(kwargs); Function to rebuild and return kwargs dictionary sanitized. levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mat2arr(mat); Convert Matrix to List. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. pcm_helper(block); Helper to specify the multiline PCMSolver syntax for PCM. plump_qcvar(val, shape_clue[, ret]); Prepare serialized QCVariable for set_variable() by converting flat arrays into shaped ones and floating strings. prefactor_ecd(); Prefactor for converting microscopic observable to decadic molar extinction coefficient in electronic circular dichroism. prefactor_opa(); Prefactor for converting microscopic observable to decadic molar extinction coefficient in one-photon absorption. prepare_options_for_modules([changedOnly, ...]); Capture current state of psi4.core.Options information. prepare_options_for_set_options(); Collect current state of psi4.core.Optio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:26163,sanitiz,sanitized,26163,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['sanitiz'],['sanitized']
Security,"rings=None):; """"""Returns a new BasisSet object configured from the *mol*; Molecule object for *role* (generally a Psi4 keyword: BASIS,; DF_BASIS_SCF, etc.). Fails utterly if a basis has not been set for; *role* for every atom in *mol*, unless *deffit* is set (JFIT,; JKFIT, or RIFIT), whereupon empty atoms are assigned to *role*; from the :py:class:`~BasisFamily`. This function is significantly; re-worked from its libmints analog. """"""; # Update geometry in molecule, if there is a problem an exception is thrown.; mol.update_geometry(). # Paths to search for gbs files: here + PSIPATH + library; psidatadir = os.environ.get('PSIDATADIR', None); psidatadir = __file__ + '/../../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/basis'; basisPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath. # Validate deffit for role; univdef = {'JFIT': 'def2-qzvpp-jfit',; 'JKFIT': 'def2-qzvpp-jkfit',; 'RIFIT': 'def2-qzvpp-ri',; 'F12': 'def2-qzvpp-f12'}. if deffit is not None:; if deffit not in univdef.keys():; raise ValidationError(""""""BasisSet::construct: deffit argument invalid: %s"""""" % (deffit)). # Map of GaussianShells; atom_basis_shell = OrderedDict(); names = {}; summary = []. for at in range(mol.natom()):; symbol = mol.atom_entry(at).symbol() # O, He; label = mol.atom_entry(at).label() # O3, C_Drot, He; basdict = mol.atom_entry(at).basissets() # {'BASIS': 'sto-3g', 'DF_BASIS_MP2': 'cc-pvtz-ri'}. if label not in atom_basis_shell:; atom_basis_shell[label] = OrderedDict(). # Establish search parameters for what/where basis entries suitable for atom; seek = {}; try:; requested_basname = basdict[role]; except KeyError:; if role == 'BASIS' or deffit is None:; raise BasisSetNotDefined(""""""BasisSet::construct: No basis set specified for %s and %s."""""" %; (symbol, role)); else:; # No auxiliary basis set for atom, so try darnedest to find one.; # This involves query",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:21940,Validat,Validate,21940,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['Validat'],['Validate']
Security,"rint the global, cross-module options. print_module_options(self: psi4.core.Options) → None¶; print global and local options prepared for current module. read_globals(self: psi4.core.Options) → bool¶; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str) → None¶; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool) → None¶; set bool option. set_current_module(self: psi4.core.Options, arg0: str) → None¶; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float) → None¶; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int) → None¶; set int option. set_read_globals(self: psi4.core.Options, arg0: bool) → None¶; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. add_array(self: psi4.core.Options, arg0: str) → None; add array option. add_bool(self: psi4.core.Options, arg0: str, arg1: bool) → None; add bool option. add_int(self: psi4.core.Options, arg0: str, arg1: int) → None; add int option. add_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None; add string option. add_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None; add string option. get_bool(self: psi4.core.Options, arg0: str) → bool; get boolean option. get_current_module(self: psi4.core.Options) → str; gets current module. get_double(self: psi4.core.Options, arg0: str) → float; get double option. get_int(self: psi4.core.Options, arg0: str) → int; get integer option. get_int_vector(self: psi4.core.Options, arg0: str) → List[int]; get int vector option. get_str(*args, **kwargs); Overloaded function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.core.Options, arg0: str) -> str. get s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.options.html:3459,validat,validate,3459,psi4manual/1.3.2/api/psi4.core.options.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.options.html,1,['validat'],['validate']
Security,"rint the global, cross-module options. print_module_options(self: psi4.core.Options) → None¶; print global and local options prepared for current module. read_globals(self: psi4.core.Options) → bool¶; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str) → None¶; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool) → None¶; set bool option. set_current_module(self: psi4.core.Options, arg0: str) → None¶; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float) → None¶; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int) → None¶; set int option. set_read_globals(self: psi4.core.Options, arg0: bool) → None¶; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. class psi4.core.OrbitalSpace¶; Bases: pybind11_builtins.pybind11_object; Contains information about the orbitals. C(self: psi4.core.OrbitalSpace) → psi4.core.Matrix¶; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace) → psi::BasisSet¶; The AO basis set used to create C. build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float) → psi4.core.OrbitalSpace¶; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. build_ri_space(molecule: psi::Molecule, obs_key: str, aux_key: str, lindep_tol: float) → psi4.core.OrbitalSpace¶; Given two basis sets, it merges the b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:187388,validat,validate,187388,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['validat'],['validate']
Security,"rint"": 2}). """"""; optionre = re.compile(r'\A(?P<module>\w+__)?(?P<option>\w+)\Z', re.IGNORECASE); rejected = {}. for k, v, in options_dict.items():. mobj = optionre.match(k.strip()); module = mobj.group('module').upper()[:-2] if mobj.group('module') else None; option = mobj.group('option').upper(). if module:; if ((module, option, v) not in [('SCF', 'GUESS', 'READ')]) and ((module, option) not in [('PCM', 'INPUT')]):; # TODO guess/read exception is for distributed driver. should be handled differently.; try:; core.set_local_option(module, option, v); except RuntimeError as err:; rejected[k] = (v, err); if verbose > 1:; print('Setting: core.set_local_option', module, option, v). if (module, option) == (""PCM"", ""INPUT""):; pcm_helper(v). else:; try:; core.set_global_option(option, v); except RuntimeError as err:; rejected[k] = (v, err); if verbose > 1:; print('Setting: core.set_global_option', option, v). if rejected:; raise ValidationError(f'Error setting options: {rejected}'); # TODO could subclass ValidationError and append rejected so that run_json could handle remanants. [docs]def set_module_options(module: str, options_dict: Dict[str, Any]) -> None:; """"""; Sets Psi4 module options from a module specification and input dictionary. .. deprecated:: 1.5; Use :py:func:`psi4.driver.p4util.set_options` instead. """"""; warnings.warn(; ""Using `psi4.set_module_options(<module>, {<key>: <val>})` instead of `psi4.set_options({<module>__<key>: <val>})` is deprecated, and as soon as 1.5 it will stop working\n"",; category=FutureWarning,; stacklevel=2). for k, v, in options_dict.items():; core.set_local_option(module.upper(), k.upper(), v). ## OEProp helpers. [docs]def pcm_helper(block: str):; """"""Helper to specify the multiline PCMSolver syntax for PCM.; Prefer to use :py:func:`set_options` with key ``""PCM__INPUT""``. Parameters; ----------; block; Text that goes in a PSIthon ``pcm = {...}`` block. """"""; import pcmsolver. with NamedTemporaryFile(mode=""w+t"", delete=True) as fl:; fl.writ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:17667,Validat,ValidationError,17667,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"rite(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or string; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:69903,access,accessed,69903,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['access'],['accessed']
Security,"rite(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file (``'continuous'``) or are to be farmed out in an; embarrassingly parallel fashion (``'sow'``/``'reap'``)/ For the latter,; run an initial job with ``'sow'`` and follow instructions in its output file.; For maximum flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:85154,access,accessed,85154,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['access'],['accessed']
Security,"rite_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:22964,Validat,ValidationError,22964,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,2,['Validat'],['ValidationError']
Security,"riter_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:66785,Validat,ValidationError,66785,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"rix) → float¶; docstring. symmetrize_gradient(self: psi4.core.Matrix, arg0: psi::Molecule) → None¶; docstring. symmetry(self: psi4.core.Matrix) → int¶; docstring. to_array(matrix, copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data)¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; docstring. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. triplet(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: bool, arg3: bool, arg4: bool) → psi4.core.Matrix¶; docstring. vector_dot(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → float¶; docstring. zero(self: psi4.core.Matrix) → None¶; docstring. zero_diagonal(self: psi4.core.Matrix) → None¶; docstring. zero_lower(self: psi4.core.Matrix) → None¶; docstring. zero_upper(self: psi4.core.Matrix) → None¶; docstring. absmax(self: psi4.core.Matrix) → float; docstring. accumulate_product(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None; docstring. add(self: psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:9318,access,accessor,9318,psi4manual/1.1.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html,1,['access'],['accessor']
Security,"rix) → float¶; docstring. symmetrize_gradient(self: psi4.core.Matrix, arg0: psi::Molecule) → None¶; docstring. symmetry(self: psi4.core.Matrix) → int¶; docstring. to_array(matrix, copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data)¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; docstring. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. triplet(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: bool, arg3: bool, arg4: bool) → psi4.core.Matrix¶; docstring. vector_dot(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → float¶; docstring. zero(self: psi4.core.Matrix) → None¶; docstring. zero_diagonal(self: psi4.core.Matrix) → None¶; docstring. zero_lower(self: psi4.core.Matrix) → None¶; docstring. zero_upper(self: psi4.core.Matrix) → None¶; docstring. class psi4.core.MatrixFactory¶; Bases: object; docstring. create_matrix(*args, **kwargs)¶; Overloaded function. create_matrix(self: psi4.core.MatrixFactory) -> psi4.core.Matri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:69776,access,accessor,69776,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['access'],['accessor']
Security,"rix, Wavefunction) – Hessian and wavefunction when return_wfn specified. Examples. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). It’s handy to collect the wavefunction after a frequency; calculation through e, wfn = psi4.frequency(...,; return_wfn=True) as the frequencies can be accessed through; psi4.core.Wavefunction.frequencies(), the Hessian through; psi4.core.Wavefunction.hessian(), and much other computation; info through psi4.core.Wavefunction.frequency_analysis; (note no parentheses). Examples of using this data; structure can be found fd-freq-gradient and; psi4/tests/pytests/test_vibanalysis.py. Formatted printing of vibrational; results is available through psi4.driver.qcdb.vib.print_vibs(). Results accessible through psi4.core.Wavefunction.frequency_analysis¶. key; description (lbl & comment); units; data (real/imaginary modes). omega; frequency; cm^-1; ndarray(ndof) complex (real/imag). q; normal mode, normalized mass-weighted; a0 u^1/2; ndarray(ndof, ndof) float. w; normal mode, un-mass-weighted; a0; ndarray(ndof, ndof) float. x; normal mode, normalized un-mass-weighted; a0; ndarray(ndof, ndof) float. degeneracy; degree of degeneracy. ndarray(ndof) int. TRV; translation/rotation/vibration. ndarray(ndof) str ‘TR’ or ‘V’ or ‘-’ for partial. gamma; irreducible representation. ndarray(ndof) str irrep or None if unclassifiable. mu; reduced mass; u; ndarray(ndof) float (+/+). k; force constant; mDyne/A; ndarray(ndof) float (+/-). DQ0; RMS deviation v=0; a0 u^1/2; ndarray(ndof) float (+/0). Qtp0; Turning point v=0; a0 u^1/2; ndarray(ndof) float (+/0). Xtp0; Turning point v=0; a0; ndarray(ndof) float (+/0). theta_vib; char temp; K; ndarray(ndof) float (+/0). Visualization of Normal Modes¶; PSI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/freq-1.html:4887,access,accessible,4887,psi4manual/1.4.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/freq-1.html,5,['access'],['accessible']
Security,"rix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array QCVariable *key* from global memory if present."""""". if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array QCVariable *key* from *cls* if present."""""". if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from global memory."""""". dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variable",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:29657,Validat,ValidationError,29657,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"rix:; # moldict['zmat'] = self.zmat; # TODO zmat, geometry_variables. nat = self.natom(); geom = np.array(self.geometry()) # [a0]; if molrec['units'] == 'Angstrom':; geom *= constants.bohr2angstroms #self.input_units_to_au(); molrec['geom'] = geom.reshape((-1)). molrec['elea'] = np.array([self.mass_number(at) for at in range(nat)]); molrec['elez'] = np.array([qcel.periodictable.to_Z(self.symbol(at)) for at in range(nat)]); molrec['elem'] = np.array([self.symbol(at).capitalize() for at in range(nat)]); molrec['mass'] = np.array([self.mass(at) for at in range(nat)]); molrec['real'] = np.array([bool(self.Z(at)) for at in range(nat)]); molrec['elbl'] = np.array([self.label(at)[len(self.symbol(at)):].lower() for at in range(nat)]). fragments = [x[:] for x in self.get_fragments()]; fragment_charges = [float(f) for f in self.get_fragment_charges()]; fragment_multiplicities = [m for m in self.get_fragment_multiplicities()]. # do trimming not performed in Molecule class b/c fragment_* member data never directly exposed; for ifr, fr in reversed(list(enumerate(self.get_fragment_types()))):; if fr == 'Ghost':; fragment_charges[ifr] = 0.; fragment_multiplicities[ifr] = 1; elif fr == 'Absent':; del fragment_charges[ifr]; del fragment_multiplicities[ifr]; # readjust atom indices for subsequent fragments; renum = fragments[ifr][0]; for iffr, ffr in enumerate(fragments):; if iffr <= ifr:; continue; lenfr = ffr[1] - ffr[0]; fragments[iffr] = [renum, renum + lenfr]; renum += lenfr; del fragments[ifr]. molrec['fragment_separators'] = [int(f[0]) for f in fragments[1:]] # np.int --> int; molrec['fragment_charges'] = fragment_charges; molrec['fragment_multiplicities'] = fragment_multiplicities. molrec['molecular_charge'] = float(self.molecular_charge()); molrec['molecular_multiplicity'] = self.multiplicity(). # * mass number (elea) untouched by qcdb.Molecule/psi4.core.Molecule and; # likely to be array of -1s, so let from_arrays fill in the values and; # (1) don't complain about the diffe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html:51092,expose,exposed,51092,psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html,2,['expose'],['exposed']
Security,"rk = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Data",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:14686,Validat,ValidationError,14686,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,2,['Validat'],['ValidationError']
Security,"rk = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Data",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:14566,Validat,ValidationError,14566,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"rmat_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROHF; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""ROHF"":; raise UpgradeHelper(f""energy('zapt{level}')"", f""energy('mp{level}')"", 1.7,; "" Replace method ZAPT with method MP for RHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). core.set_local_option('DETCI', 'WFN', 'ZAPTN'); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""mp"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'MPN', 'TRUE'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:131939,Validat,ValidationError,131939,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"rn ret . # No irreps implied by list; else:; if arr_type == psi4.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError (""Array_to_Matrix: If dim1 is supplied must supply dim2 also""); ; dim1 = psi4.Dimension.from_list(dim1) ; dim2 = psi4.Dimension.from_list(dim2) . if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""); ; ret = self(name, dim1, dim2); ; start1 = 0; start2 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1 ; start2 += d2. return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. elif arr_type == psi4.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError (""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""); ; dim1 = psi4.Dimension.from_list(dim1) ; ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1 . return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def to_array(matrix, copy=True, dense=False):; """"""; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view.; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. ret = []; for h in matrix.array_interfaces():; if 0 in h.__array_interface__[""shape""]:; ret.append(np.empty(shape = h.__array_interface__[""shape""])); els",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:5473,Validat,ValidationError,5473,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"rn_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference freq run in one job or files farmed out; freq_mode = kwargs.pop('mode', 'continuous').lower(); if freq_mode == 'continuous':; pass; elif freq_mode == 'sow':; if dertype == 2:; raise ValidationError(""""""Frequency execution mode 'sow' not valid for analytic Hessian calculation.""""""); elif freq_mode == 'reap':; freq_linkage = kwargs.get('linkage', None); if freq_linkage is None:; raise ValidationError(""""""Frequency execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; if dertype == 2:; core.print_out(""""""hessian() switching to finite difference by gradients for partial Hessian calculation.\n""""""); dertype = 1. # At stationary point?; if 'ref_gradient' in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:68923,Validat,ValidationError,68923,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"rn_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file (``'continuous'``) or are to be farmed out in an; embarrassingly parallel fashion (``'sow'``/``'reap'``)/ For the latter,; run an initial job with ``'sow'`` and follow instructions in its output file.; For maximum flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:79594,access,accessed,79594,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['access'],['accessed']
Security,"rns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in ; :envvar:`PATH`. """"""; # Validate arguments; if self is None:; self = PsiMod.get_active_molecule(). dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:7701,Validat,ValidationError,7701,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"rocedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print 'Performing finite difference calculations'. # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed ...' % (ndisp),; energies",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:22942,Validat,ValidationError,22942,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"rocedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end="""");",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:25411,Validat,ValidationError,25411,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"rocedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 8). # Does dertype indicate ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:32922,Validat,ValidationError,32922,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"rocess.PIPE, env=lenv); except OSError as e:; raise ValidationError('Program dftd3 not found in path. %s' % e); out, err = dashout.communicate(). # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; os.chdir(current_directory); raise Dftd3Error(""""""Unsuccessful run. Possibly -D variant not available in dftd3 version.""""""). # Parse grad output; if dertype != 0:; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Prepare results for Psi4; if isP4regime and dertype != 0:; psi4.set_variable('DISPERSION CORRECTION ENERGY', dashd); psi_dashdderiv = psi4.Matrix(self.natom(), 3); psi_dashdderiv.set(dashdderiv). # Print program output to file if verbose; if isP4regime:; verbose = True if psi4.get_option('SCF', 'PRINT') >= 3 else False; if verbose:. text = '\n ==> DFTD3 Output <==\n'; text += out; if dertype != 0:; with open(derivfile, 'r') as handle:; text += handle.read().replace('D', 'E'); text += '\n'; if isP4regime:; psi4.print_out(text); else:; print(text). # Clean up files and remove scratch directory; os.unlink(paramfile1); os.unlink(paramfile2); os.unlink(geomfile); if dertype != 0:; os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); try:; shutil.rmtree(dftd3_tmpdir); except OSError as e:; ValidationError('Unable to remove dftd3 temporary directory %s' %",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:8165,Validat,ValidationError,8165,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"rom a computation."",; ""default"": ""none"",; ""allOf"": [; {; ""$ref"": ""#/definitions/WavefunctionProtocolEnum""; }; ]; },; ""stdout"": {; ""title"": ""Stdout"",; ""description"": ""Primary output file to keep from the computation"",; ""default"": true,; ""type"": ""boolean""; },; ""error_correction"": {; ""title"": ""Error Correction"",; ""description"": ""Policies for error correction"",; ""allOf"": [; {; ""$ref"": ""#/definitions/ErrorCorrectionProtocol""; }; ]; },; ""native_files"": {; ""description"": ""Policies for keeping processed files from the computation"",; ""default"": ""none"",; ""allOf"": [; {; ""$ref"": ""#/definitions/NativeFilesProtocolEnum""; }; ]; }; },; ""additionalProperties"": false; }; }; }. Fields:. basis (str); computed (bool); driver (qcelemental.models.common_models.DriverEnum); keywords (Dict[str, Any]); method (str); molecule (Any); owner_group (str | None); priority (str); protocols (qcelemental.models.results.AtomicResultProtocols | Dict[str, Any] | None); result (Any); result_id (str | None); tag (str). Validators:. set_basis » basis; set_keywords » keywords; set_method » method. field basis: str [Required]¶; The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, …). Validated by:. set_basis. field computed: bool = False¶; Whether quantum chemistry has been run on this task. field driver: DriverEnum [Required]¶; The resulting type of computation: energy, gradient, hessian, properties.Note for finite difference that this should be the target driver, not the means driver. field keywords: Dict[str, Any] [Optional]¶; The keywords to use in the computation. Validated by:. set_keywords. field method: str [Required]¶; The quantum chemistry method to evaluate (e.g., B3LYP, MP2, …). Validated by:. set_method. field molecule: Any [Required]¶; The molecule to use in the computation. field owner_group: Optional[str] = None¶; group in the chown sense. field priority: str = 1¶; The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}. field protocols: Union[Atom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:4887,Validat,Validators,4887,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,3,['Validat'],['Validators']
Security,"rom psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, ValidationError; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:2599,validat,validation,2599,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['validat'],['validation']
Security,ror('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:72360,Validat,ValidationError,72360,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"roup(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). elif xyzC.match(text[2 + i]):. fileAtom = int(float(xyzC.match(text[2 + i]).group(1))); fileX = float(xyzC.match(text[2 + i]).group(2)); fileY = float(xyzC.match(text[2 + i]).group(3)); fileZ = float(xyzC.match(text[2 + i]).group(4)). # Check that the atomic number is valid; if not fileAtom in z2el:; raise ValidationError('Illegal atom symbol in geometry specification: %d' % (fileAtom)). # Add it to the molecule.; instance.add_atom(fileAtom, fileX, fileY, fileZ, z2el[fileAtom], z2mass[fileAtom], fileAtom). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. @classmethod; [docs] def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:5547,Validat,ValidationError,5547,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"rovenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn.sort(key=lambda tup: tup[0]); molinit[""connectivity""] = conn; except ValueError:; raise ValidationError(; ""Connectivity entry is not of form [(at1, at2, bondorder), ...]: {}"".format(connectivity); ). if units.capitalize() in [""Angstrom"", ""Bohr""]:; molinit[""units""] = units.capitalize(); else:; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. def validate_and_fill_frame(extern, fix_com=None, fix_orientation=None, fix_symmetry=None):. if fix_com is True:; com = True; elif fix_com is False:; if extern:; raise ValidationError(""Invalid fix_com ({}) with extern ({})"".format(fix_com, extern)); else:; com = False; elif fix_com is None:; com = extern; else:; raise ValidationError(""Invalid fix_com: {}"".format(fix_com)). if fix_orientation is True:; orient = True; elif fix_orientation is False:; if extern:; raise Valida",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:14416,Validat,ValidationError,14416,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"rray QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; cls.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array QCVariable *key* from global memory if present."""""". if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls: core.Wavefunction, key: str) -> None:; """"""Removes sca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:31417,Validat,ValidationError,31417,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"rray is not None else None. # make the wavefunction; wfn = core.Wavefunction(molecule, basisset, wfn_matrix, wfn_vector, wfn_dimension, wfn_int, wfn_string,; wfn_boolean, wfn_float). # some of the wavefunction's variables can be changed directly; for k, v in wfn_floatvar.items():; wfn.set_variable(k, v); for k, v in wfn_matrixarr.items():; wfn.set_variable(k, v). return wfn. core.Wavefunction.from_file = _core_wavefunction_from_file. def _core_wavefunction_to_file(wfn: core.Wavefunction, filename: str = None) -> Dict:; """"""Converts a Wavefunction object to a base class. Parameters; ----------; wfn; A Wavefunction or inherited class; filename; An optional filename to write the data to. Returns; -------; dict; A dictionary and NumPy representation of the Wavefunction. """""". # collect the wavefunction's variables in a dictionary indexed by varaible type; # some of the data types have to be made numpy-friendly first; if wfn.basisset().name().startswith(""anonymous""):; raise ValidationError(""Cannot serialize wavefunction with custom basissets.""). wfn_data = {; 'molecule': wfn.molecule().to_dict(),; 'matrix': {; 'Ca': wfn.Ca().to_array() if wfn.Ca() else None,; 'Cb': wfn.Cb().to_array() if wfn.Cb() else None,; 'Da': wfn.Da().to_array() if wfn.Da() else None,; 'Db': wfn.Db().to_array() if wfn.Db() else None,; 'Fa': wfn.Fa().to_array() if wfn.Fa() else None,; 'Fb': wfn.Fb().to_array() if wfn.Fb() else None,; 'H': wfn.H().to_array() if wfn.H() else None,; 'S': wfn.S().to_array() if wfn.S() else None,; 'X': wfn.lagrangian().to_array() if wfn.lagrangian() else None,; 'aotoso': wfn.aotoso().to_array() if wfn.aotoso() else None,; 'gradient': wfn.gradient().to_array() if wfn.gradient() else None,; 'hessian': wfn.hessian().to_array() if wfn.hessian() else None; },; 'vector': {; 'epsilon_a': wfn.epsilon_a().to_array() if wfn.epsilon_a() else None,; 'epsilon_b': wfn.epsilon_b().to_array() if wfn.epsilon_b() else None,; 'frequencies': wfn.frequencies().to_array() if wfn.frequencies() els",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:7542,Validat,ValidationError,7542,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,3,['Validat'],['ValidationError']
Security,"rray to a Psi4 object. Examples; --------. >>> data = np.random.rand(20,1); >>> vector = psi4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4); """""". # What type is it? MRO can help.; arr_type = self.__mro__[0]. # Irrepped case; if isinstance(arr, (list, tuple)):; if (dim1 is not None) or (dim2 is not None):; raise ValidationError(""Array_to_Matrix: If passed input is list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == core.Matrix:; sdim1 = core.Dimension(irreps); sdim2 = core.Dimension(irreps). for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irrepped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:4494,Validat,ValidationError,4494,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,4,['Validat'],['ValidationError']
Security,"rror if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant funct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html:1369,access,accesses,1369,psi4manual/1.3.2/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html,4,['access'],['accesses']
Security,"rror if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html:1369,access,accesses,1369,psi4manual/1.2.1/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html,4,['access'],['accesses']
Security,"rror:; intrxn = False; else:; intrxn = True. with pd.get_store(hdf5file) as handle:; for mc in handle['pdie'].keys():; lmc = mc.split('-') # TODO could be done better; method = lmc[0]; bsse = '_'.join(lmc[1:-1]); basis = lmc[-1]. df = handle['pdie'][mc]; for dbrxn in df.index[df.notnull()].values:; [dbse, rxn] = dbrxn.split('-', 1); if intrxn:; rxn = int(rxn); self.hrxn[rxn].data[mc] = ReactionDatum.library_modelchem(dbse=dbse, rxn=rxn,; method=method, mode=bsse, basis=basis,; value=df[dbrxn]). [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; return False; else:; return True. @staticmethod; [docs] def load_pickled(dbname, path=None):; """""". """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; picklefile = psiutil.findfile_ignorecase(dbname,; pre=os.path.abspath(path) + os.sep, post='_WDb.pickle'); if not picklefile:; raise ValidationError(""Pickle file for loading database data from file %s does not exist"" % (; os.path.abspath(path) + os.sep + dbname + '.pickle')); # with open('/var/www/html/bfdb_devel/bfdb/scratch/ASDFlogfile.txt', 'a') as handle:; # handle.write('<!-- PICKLE %s\n' % (picklefile)); with open(picklefile, 'rb') as handle:; instance = pickle.load(handle); return instance. [docs] def available_modelchems(self, union=True):; """"""Returns all the labels of model chemistries that have been; loaded. Either all modelchems that have data for any reaction if; *union* is True or all modelchems that have data for all reactions; if *union* is False. """"""; mcs = [set(v.data) for v in self.hrxn.itervalues()]; if union:; return sorted(set.union(*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # retu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:41169,Validat,ValidationError,41169,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"rs to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_tour.html:2659,access,accessibility,2659,psi4manual/master/prog_tour.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_tour.html,1,['access'],['accessibility']
Security,"rt wrapper directives from options (where ppl know to find them) to kwargs (suitable for non-globals transmitting); kwargs['findif_verbose'] = core.get_option(""FINDIF"", ""PRINT""); kwargs['findif_stencil_size'] = core.get_option(""FINDIF"", ""POINTS""); kwargs['findif_step_size'] = core.get_option(""FINDIF"", ""DISP_SIZE""). # Select certain irreps; irrep = kwargs.pop('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; kwargs['findif_irrep'] = irrep. ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name); _filter_renamed_methods(""hessian"", lowername). # * Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # * Prevent methods that do not have associated derivatives; if lowername in energy_only_methods:; raise ValidationError(f""`hessian('{name}')` does not have an associated Hessian.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""hessian"", lowername, molecule, **kwargs); logger.debug('HESSIAN PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 2nd derivative. _filter_renamed_methods(""frequency"", lowername); core.clean_variables(). optstash = p4util.Op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:71625,Validat,ValidationError,71625,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"rted""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:87326,Validat,ValidationError,87326,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"rted""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerica",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:83911,Validat,ValidationError,83911,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"rties""; ],; ""type"": ""string""; }; }; }. Fields:. basis (str); computed (bool); driver (qcelemental.models.common_models.DriverEnum); keywords (Dict[str, Any]); method (str); molecule (Any); result (Any); result_id (Optional[str]). Validators:. set_basis » basis; set_keywords » keywords; set_method » method. field basis: str [Required]¶; The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, …). Validated by:. set_basis. field computed: bool = False¶; Whether quantum chemistry has been run on this task. field driver: DriverEnum [Required]¶; The resulting type of computation: energy, gradient, hessian, properties.Note for finite difference that this should be the target driver, not the means driver. field keywords: Dict[str, Any] [Optional]¶; The keywords to use in the computation. Validated by:. set_keywords. field method: str [Required]¶; The quantum chemistry method to evaluate (e.g., B3LYP, MP2, …). Validated by:. set_method. field molecule: Any [Required]¶; The molecule to use in the computation. field result: Any [Optional]¶; AtomicResult return. field result_id: Optional[str] = None¶; The optional ID for the computation. compute(client=None)[source]¶; Run quantum chemistry. Parameters:; client (Optional[qcportal.client.FractalClient]) – . get_results(client=None)[source]¶; Return results as Atomic-flavored QCSchema. Return type:; AtomicResult. Parameters:; client (Optional[FractalClient]) – . plan()[source]¶; Form QCSchema input from member data. Return type:; AtomicInput. validator set_basis  »  psi4.driver.AtomicComputer.basis[source]¶. validator set_keywords  »  psi4.driver.AtomicComputer.keywords[source]¶. validator set_method  »  psi4.driver.AtomicComputer.method[source]¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; AtomicComputer. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.AtomicComputer.html:3290,validat,validator,3290,psi4manual/1.7.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.AtomicComputer.html,3,['validat'],['validator']
Security,"rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(10); text += "" %d %s %d %s %d %s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compute()); # Check for NaN, and don't update if we find one; # what is this? proper py traslation?; if val == val:; self.dval.rset(val * 180.0 / math.pi). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'ZMatrixCoord'. [docs] def clone(self):; """"""Returns new, independent ZMatrixEntry object.""""""; return copy.deepcopy(self). [docs] def compute(self):; """"""Compute the Cartesian coordinates in Bohr of current atom's entry."""""". if self.computed:; return self.coordinates. # place first atom at the origi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:17399,Validat,ValidationError,17399,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['Validat'],['ValidationError']
Security,"rtype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print 'Performing finite difference calculations'. # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is prett",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:22849,Validat,ValidationError,22849,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"rtype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:25318,Validat,ValidationError,25318,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"rtype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:32829,Validat,ValidationError,32829,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"rtype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH` or :envvar:`PSIPATH`.; *self* may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, core.Molecule):; # called on a python export of a psi4.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if dashlvl is not None:; dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())); else:; raise ValidationError(""""""Must specify a dashlvl""""""). if func is not None:; dftd3_params = dash_server(func, dashlvl); else:; dftd3_params = {}. if dashparam is not None:; dftd3_params.update(dashpar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html:3016,Validat,ValidationError,3016,psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"rumps); # 6 from set {...} 5 from set {...} 5 (local trumps); #; # energy(name) [cfour][cfour_calc_level]; # c4-scf SCF by default; # c4-scf CCSD from set {...}. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; if lowername == 'cfour':; pass # permit clean operation of sandwich mode; else:; options['CFOUR']['CFOUR_DERIV_LEVEL']['value'] = 'ZERO'; elif dertype == 1:; options['CFOUR']['CFOUR_DERIV_LEVEL']['value'] = 'FIRST'; elif dertype == 2:; options['CFOUR']['CFOUR_DERIV_LEVEL']['value'] = 'SECOND'; else:; raise ValidationError(""""""Requested Cfour dertype %d is not available."""""" % (dertype)). if lowername == 'cfour':; pass; elif lowername == 'c4-scf':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'SCF'. elif lowername == 'c4-mp2':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'MP2'. elif lowername == 'c4-mp3':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'MP3'. elif lowername == 'c4-mp4(sdq)':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'SDQ-MP4'. elif lowername == 'c4-mp4':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'MP4'. elif lowername == 'c4-cc2':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CC2'. elif lowername == 'c4-ccsd':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CCSD'; options['CFOUR']['CFOUR_CC_PROGRAM']['value'] = 'ECC'. elif lowername == 'c4-cc3':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CC3'. elif lowername ==",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:31041,Validat,ValidationError,31041,psi4manual/1.0.0/_modules/qcdb/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html,1,['Validat'],['ValidationError']
Security,"run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). """""". if post_scf:; name = ""scf"". optstash = p4util.OptionsState(; ['PUREAM'],; ['BASIS'],; ['QMEFP'],; ['INTS_TOLERANCE'],; ['DF_BASIS_SCF'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'ORBITALS_WRITE'],; ['SCF_TYPE'], # Hack: scope gets changed internally with the Andy trick; ). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ). # Make sure we grab the correctly scoped integral threshold for SCF; core.set_global_option('INTS_TOLERANCE', core.get_option('SCF', 'INTS_TOLERANCE')). # Grab a few kwargs; use_c1 = kwargs.get('use_c1', False); scf_molecule = kwargs.get('molecule', core.get_active_molecule()); read_orbitals = core.get_option('SCF', 'GUESS') == ""READ""; do_timer = kwargs.pop(""do_timer"", True); ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is not None:; raise ValidationError(""Cannot seed an SCF calculation with a reference wavefunction ('ref_wfn' kwarg).""). # decide if we keep the checkpoint file; _chkfile = kwargs.get('write_orbitals', True); write_checkpoint_file = False; if isinstance(_chkfile, str):; write_checkpoint_file = True; filename = kwargs.get('write_orbitals'); core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif _chkfile is True:; write_checkpoint_file = True. # PCM needs to be run w/o symmetry; if core.get_option(""SCF"", ""PCM""):; c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.update_geometry(). scf_molecule = c1_molecule; core.print_out("""""" PCM does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""). # PE needs to use exactly input orientation to correspond to potfile; if core.get_option(""SCF"", ""PE""):; c1_molecule = scf_molecule.clone(); if getattr(scf_molecule, ""_initial_cartesian"", None) is not None:; c1_molecule._initial_cartesian = scf_molecule._initial_carte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:37098,Validat,ValidationError,37098,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"rxn; actives = ''; actives += """"""psi4.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""psi4.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""psi4.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\npsi4.set_memory(%s)\n\n"""""" % (user_memory); for chgdopt in psi4.get_global_option_list():; if psi4.has_global_option_changed(chgdopt):; chgdoptval = psi4.get_global_option(chgdopt); #chgdoptval = psi4.get_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""psi4.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""psi4.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'; commands += """"""psi4.set_global_option('BASIS', '%s')\n"""""" % (user_basis); if not((user_df_basis_scf == """") or (user_df_basis_scf == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_SCF', '%s')\n"""""" % (user_df_basis_scf); if not((user_df_basis_mp2 == """") or (user_df_basis_mp2 == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_MP2', '%s')\n"""""" % (user_df_basis_mp2); if not((user_df_basis_sapt == """") or (user_df_basis_sapt == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_SAPT', '%s')\n"""""" % (user_df_basis_sapt); if not((user_df_basis_elst == """") or (user_df_basis_elst == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = psi4.get_active_molecule()\n""""""; commands += """"""molecule.upd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:41765,Validat,ValidationError,41765,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"ry: .gcppar; ###The short version reads in: basis-keywo. # Write dftd3_geometry file that supplies geometry to dispersion calc; numAtoms = self.natom(); geom = self.save_string_xyz(); reals = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; numAtoms -= 1; else:; reals.append(line). geomtext = str(numAtoms) + '\n\n'; for line in reals:; geomtext += line.strip() + '\n'; geomfile = './gcp_geometry.xyz'; with open(geomfile, 'w') as handle:; handle.write(geomtext); # TODO somehow the variations on save_string_xyz and; # whether natom and chgmult does or doesn't get written; # have gotten all tangled. I fear this doesn't work; # the same btwn libmints and qcdb or for ghosts. # Call gcp program; command = ['gcp', geomfile]; command.extend(['-level', func]); if dertype != 0:; command.append('-grad'); try:; #print('command', command); dashout = subprocess.Popen(command, stdout=subprocess.PIPE, env=lenv); except OSError as e:; raise ValidationError('Program gcp not found in path. %s' % e); out, err = dashout.communicate(). # Parse output; success = False; for line in out.splitlines():; line = line.decode('utf-8'); if re.match(' Egcp:', line):; sline = line.split(); dashd = float(sline[1]); if re.match(' normal termination of gCP', line):; success = True. if not success:; os.chdir(current_directory); raise Dftd3Error(""""""Unsuccessful gCP run.""""""). # Parse grad output; if dertype != 0:; derivfile = './gcp_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program gcp gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Prepare results for Psi4; if isP4regime and dertype != 0:; co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html:8357,Validat,ValidationError,8357,psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,2,['Validat'],['ValidationError']
Security,"s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:74560,validat,validate,74560,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,4,['validat'],['validate']
Security,"s * A[r][q]; A[r][q] = s * t + c * A[r][q]. for r in range(p + 1, q):; t = A[p][r]; A[p][r] = c * t - s * A[r][q]; A[r][q] = s * t + c * A[r][q]. for r in range(q + 1, 3):; t = A[p][r]; A[p][r] = c * t - s * A[q][r]; A[q][r] = s * t + c * A[q][r]. # Update eigenvectors; for r in range(3):; t = Q[r][p]; Q[r][p] = c * t - s * Q[r][q]; Q[r][q] = s * t + c * Q[r][q]. return None. [docs]def zero(m, n):; """""" Create zero matrix""""""; new_matrix = [[0 for row in range(n)] for col in range(m)]; return new_matrix. [docs]def identity(m):; """"""Create identity matrix""""""; new_matrix = zero(m, m); for i in range(m):; new_matrix[i][i] = 1.0; return new_matrix. [docs]def show(matrix):; """""" Print out matrix""""""; for col in matrix:; print(col). [docs]def mscale(matrix, d):; """"""Return *matrix* scaled by scalar *d*""""""; for i in range(len(matrix)):; for j in range(len(matrix[0])):; matrix[i][j] *= d; return matrix. [docs]def mult(matrix1, matrix2):; """""" Matrix multiplication""""""; if len(matrix1[0]) != len(matrix2):; # Check matrix dimensions; raise ValidationError('Matrices must be m*n and n*p to multiply!'). else:; # Multiply if correct dimensions; try:; new_matrix = zero(len(matrix1), len(matrix2[0])); for i in range(len(matrix1)):; for j in range(len(matrix2[0])):; for k in range(len(matrix2)):; new_matrix[i][j] += matrix1[i][k] * matrix2[k][j]; except TypeError:; new_matrix = zero(len(matrix1), 1); for i in range(len(matrix1)):; for k in range(len(matrix2)):; new_matrix[i][0] += matrix1[i][k] * matrix2[k]; return new_matrix. [docs]def transpose(matrix):; """"""Return matrix transpose""""""; if len(matrix[0]) != len(matrix):; # Check matrix dimensions; raise ValidationError('Matrices must be square.'). tmat = [list(i) for i in zip(*matrix)]; return tmat. [docs]def matadd(matrix1, matrix2, fac1=1.0, fac2=1.0):; """"""Matrix addition""""""; if (len(matrix1[0]) != len(matrix2[0])) or (len(matrix1) != len(matrix2)):; raise ValidationError('Matrices must be same dimension to add.'); new_matrix = zero(len(ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html:8150,Validat,ValidationError,8150,psi4manual/1.0.0/_modules/qcdb/vecutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html,1,['Validat'],['ValidationError']
Security,"s = psi4.PsiReturnType.Success. names = {‘Balk’: psi4.PsiReturnType.Balk, ‘EndLoop’: psi4.PsiReturnTyp... values = {0: psi4.PsiReturnType.Success, 1: psi4.PsiReturnType.Failure... ———————————————————————-. Methods inherited from Boost.Python.enum:. __repr__(...). x.__repr__() <==> repr(x). __str__(...). x.__str__() <==> str(x). ———————————————————————-. Data descriptors inherited from Boost.Python.enum:. name. ———————————————————————-. Methods inherited from __builtin__.int:. __abs__(...). x.__abs__() <==> abs(x). __add__(...). x.__add__(y) <==> x+y. __and__(...). x.__and__(y) <==> x&y. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __coerce__(...). x.__coerce__(y) <==> coerce(x, y). __div__(...). x.__div__(y) <==> x/y. __divmod__(...). x.__divmod__(y) <==> divmod(x, y). __float__(...). x.__float__() <==> float(x). __floordiv__(...). x.__floordiv__(y) <==> x//y. __format__(...). __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getnewargs__(...). __hash__(...). x.__hash__() <==> hash(x). __hex__(...). x.__hex__() <==> hex(x). __index__(...). x[y:z] <==> x[y.__index__():z.__index__()]. __int__(...). x.__int__() <==> int(x). __invert__(...). x.__invert__() <==> ~x. __long__(...). x.__long__() <==> long(x). __lshift__(...). x.__lshift__(y) <==> x<<y. __mod__(...). x.__mod__(y) <==> x%y. __mul__(...). x.__mul__(y) <==> x*y. __neg__(...). x.__neg__() <==> -x. __nonzero__(...). x.__nonzero__() <==> x != 0. __oct__(...). x.__oct__() <==> oct(x). __or__(...). x.__or__(y) <==> x|y. __pos__(...). x.__pos__() <==> +x. __pow__(...). x.__pow__(y[, z]) <==> pow(x, y[, z]). __radd__(...). x.__radd__(y) <==> y+x. __rand__(...). x.__rand__(y) <==> y&x. __rdiv__(...). x.__rdiv__(y) <==> y/x. __rdivmod__(...). x.__rdivmod__(y) <==> divmod(y, x). __rfloordiv__(...). x.__rfloordiv__(y) <==> y//x. __rlshift__(...). x.__rlshift__(y) <==> y<<x. __rmod__(...). x.__rmod__(y) <==> y%x. __rmul__(...). x.__rmul__(y) <==> y*x. __ror__(...). x.__ror__(y) <==> y|x. __rpow__(...). y.__rpo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:276773,hash,hash,276773,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,8,['hash'],['hash']
Security,"s = resolved['dashparams']; self.description = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['description']; self.ordered_params = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['default'].keys(); self.dashlevel_citation = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['citation']; self.dashparams_citation = resolved['dashparams_citation']. capable_engines_for_disp = _capable_engines_for_disp(); if engine is None:; self.engine = capable_engines_for_disp[self.dashlevel][0]; else:; if self.dashlevel in _engine_can_do[engine]:; self.engine = engine; else:; raise ValidationError(f""This little engine ({engine}) can't ({self.dashlevel})""). if self.engine == 'libdisp':; self.disp = core.Dispersion.build(self.dashlevel, **resolved['dashparams']). if gcp_engine is None:; self.gcp_engine = capable_engines_for_disp[""3c""][0]; else:; if ""3c"" in _engine_can_do[gcp_engine]:; self.gcp_engine = gcp_engine; else:; raise ValidationError(f""This little engine ({engine}) can't (3c)""). [docs] def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:7870,Validat,ValidationError,7870,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['Validat'],['ValidationError']
Security,"s = resolved['dashparams']; self.description = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['description']; self.ordered_params = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['default'].keys(); self.dashlevel_citation = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['citation']; self.dashparams_citation = resolved['dashparams_citation']. capable_engines_for_disp = _capable_engines_for_disp(); if engine is None:; self.engine = capable_engines_for_disp[self.dashlevel][0]; else:; if self.dashlevel in _engine_can_do[engine]:; self.engine = engine; else:; raise ValidationError(f""This little engine ({engine}) can't ({self.dashlevel})""). if self.engine == 'libdisp':; self.disp = core.Dispersion.build(self.dashlevel, **resolved['dashparams']). if gcp_engine is None:; self.gcp_engine = capable_engines_for_disp[""3c""][0]; else:; if ""3c"" in _engine_can_do[gcp_engine]:; self.gcp_engine = gcp_engine; else:; raise ValidationError(f""This little engine ({engine}) can't (3c)""). [docs]; def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs]; def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:8379,Validat,ValidationError,8379,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,3,['Validat'],['ValidationError']
Security,"s == PointGroups['CsX']:; return ""Cs(X)""; elif bits == PointGroups['D2']:; return ""D2""; elif bits == PointGroups['C2vX']:; return ""C2v(X)""; elif bits == PointGroups['C2vY']:; return ""C2v(Y)""; elif bits == PointGroups['C2vZ']:; return ""C2v(Z)""; elif bits == PointGroups['C2hX']:; return ""C2h(X)""; elif bits == PointGroups['C2hY']:; return ""C2h(Y)""; elif bits == PointGroups['C2hZ']:; return ""C2h(Z)""; elif bits == PointGroups['D2h']:; return ""D2h""; else:; raise ValidationError(""Unrecognized point group bits: %d\n"" % (bits)). @staticmethod; [docs] def bits_to_basic_name(bits):; """"""From bit representation of point group, returns string of simple; (non-directional) Schoenflies symbol. """"""; if bits == PointGroups['C1']:; return ""c1""; elif bits == PointGroups['Ci']:; return ""ci""; elif bits in [PointGroups['C2X'], PointGroups['C2Y'], PointGroups['C2Z']]:; return ""c2""; elif bits in [PointGroups['CsZ'], PointGroups['CsY'], PointGroups['CsX']]:; return ""cs""; elif bits == PointGroups['D2']:; return ""d2""; elif bits in [PointGroups['C2vX'], PointGroups['C2vY'], PointGroups['C2vZ']]:; return ""c2v""; elif bits in [PointGroups['C2hX'], PointGroups['C2hY'], PointGroups['C2hZ']]:; return ""c2h""; elif bits == PointGroups['D2h']:; return ""d2h""; else:; raise ValidationError('Unrecognized point group bits: %d\n' % (bits)). @staticmethod; [docs] def full_name_to_bits(pg): # altered signature from (pg, bits):; """""". """"""; pgc = pg.capitalize(). if pgc == 'C1':; bits = PointGroups['C1']; elif pgc == 'Ci':; bits = PointGroups['Ci']; elif pgc == 'C2(x)' or pgc == 'C2x' or pgc == 'C2_x':; bits = PointGroups['C2X']; elif pgc == 'C2(y)' or pgc == 'C2y' or pgc == 'C2_y':; bits = PointGroups['C2Y']; elif pgc == 'C2(z)' or pgc == 'C2z' or pgc == 'C2_z':; bits = PointGroups['C2Z']; elif pgc == 'Cs(x)' or pgc == 'Csx' or pgc == 'Cs_x':; bits = PointGroups['CsX']; elif pgc == 'Cs(y)' or pgc == 'Csy' or pgc == 'Cs_y':; bits = PointGroups['CsY']; elif pgc == 'Cs(z)' or pgc == 'Csz' or pgc == 'Cs_z':; bits = Poin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:44711,Validat,ValidationError,44711,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security,"s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n""); if banner:; core.print_out("" "" + banner.center(58)); if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58)); ref_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:43817,Validat,ValidationError,43817,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"s FCHK files. Parameters; ----------; expected; Path to reference FCHK file against which `computed` is compared.; computed; Path to input FCHK file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; fchk_ref = _fchkfile_to_string(expected).splitlines(); fchk_calc = _fchkfile_to_string(computed).splitlines(). high_accuracy = atol_exponent; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(fchk_ref[index], line, f""FCK text line {index+1}.""); index += 1;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fchk.html:4079,Validat,ValidationError,4079,psi4manual/1.7.x/_modules/psi4/driver/p4util/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fchk.html,4,['Validat'],['ValidationError']
Security,"s Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:168582,Validat,ValidationError,168582,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"s a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; try:; adcc.set_n_threads(core.get_num_threads()); except AttributeError:; # Before adcc 0.13.3:; adcc.thread_pool.reinit(core.get_num_threads(), core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; ""{}"".format(str(ex))); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level >",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:114569,Validat,ValidationError,114569,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"s a possible search for a lower SCF solution. There are three possible options for this keyword. OFF (=0) does nothing, while ON (=1) performs a stability analysis and returns the number of negative eigenvalues in the orbital rotation Hessian. A third option, FOLLOW (=2) performs the stability analysis and then proceeds to rotate the SCF orbitals in the direction of a particular negative eigenvalue of the orbital rotation Hessian (see the explanation of keyword CFOUR_ROT_EVEC), after which the SCF is rerun. Type: string; Possible Values: OFF, ON, FOLLOW; Default: OFF. CFOUR_INCORE (CFOUR); CFOUR — This keyword can be used to significantly reduce disk i/o, and should be implemented very soon. The following options are available: OFF (= 0), no special algorithms are used (the default case); ALL (=1) all quantities except the \(\langle ab\vert\vert cd\rangle\) molecular integral lists are held in core; PARTIAL (= 2), the T2 and T1 vectors are held in core throughout the calculation; (=4) all quantities except the \(\langle ab\vert\vert cd\rangle\) and \(\langle ab\vert\vert ci\rangle\) integrals are held in core; (=5) \(\langle ij\vert\vert kl\rangle\) and \(\langle ij\vert\vert ka\rangle\) and two-index quantities are held in core; (=6) all direct access files (MOINTS, GAMLAM, etc.) are held in core. At present, these options have been implemented only in the energy code xvcc and the excitation energy code xvee. (Default: 0). Type: string; Possible Values: OFF, ALL, PARTIAL; Default: OFF. CFOUR_INPUT_MRCC (CFOUR); CFOUR — Specifies whether an input for mrcc is written (ON, =0) or not (OFF, =1) if CFOUR_CC_PROGRAM =EXTERNAL has been specified. Type: boolean; Default: true. CFOUR_INTEGRALS (CFOUR); CFOUR — This keyword defines what type of integral input will be written by xjoda. VMOL (=1) has to be used with the programs of CFOUR. Using ARGOS (=0), input for Pitzer’s ARGOS integral program will be written. (Default: VMOL). Type: string; Possible Values: VMOL, ARGOS; De",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:52130,access,access,52130,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['access'],['access']
Security,"s and condense the components into a minimum number of calculations. compare_arrays(expected, computed, digits, label); Function to compare two numpy arrays. compare_csx(); Function to validate energies in CSX files against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, ...); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, ...); Function to compare two vectors. copy_file_from_scratch(filename, prefix, ...); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, ...); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. extract_cluster_indexing(mol[, cluster_size]); Function to returns a LIST of all subclusters of the molecule mol of real size cluster_size. extract_clusters(mol[, ghost, cluster_size]); Function to return all subclusters of the molecule mol of real size cluster_size and all other atoms ghosted if ghost equals true, all other atoms discarded if ghost is false. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. filter_comments(string); Remove from string any ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:196989,sanitiz,sanitized,196989,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['sanitiz'],['sanitized']
Security,"s corresponding to `compute_list`.; task_list: List[AtomicComputer] = []. # One-to-One list of QCSchema corresponding to `task_list`.; results_list: List[Any] = []. @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; data = p4util.kwargs_lower(data); data[""metadata""] = _process_cbs_kwargs(data); BaseComputer.__init__(self, **data). self.metameta = {; 'kwargs': data,; 'ptype': self.driver,; 'verbose': self.verbose,; 'label': None,; 'molecule': self.molecule,; }; # logger.debug(""METAMETA\n"" + pp.pformat(self.metameta)). if data['metadata']:; if data['metadata'][0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in driver_cbs.py to proceed."""""" %; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested lesser {delta[""treament""]} method '{delta[""wfn_lo""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ). self.cbsrec, self.compute_list, self.trove = _build_cbs_compute(self.metameta, self.metadata). for job in self.compute_list:; keywords = copy.deepcopy(self.metameta['kwargs']['keywords']); if job[""f_options""] is not False:; stage_keywords = dict(job[""f_options""].items()); keywords = {**keywords, **stage_keywords}; task = AtomicComputer(; **{; ""molecule"": self.molecule,; ""driver"": self.driver,; ""method"": job[""f_wfn""],; ""basis"": job[""f_basis""],; ""keywords"": keywords or {},; }); self.task_list.append(task). # logger.debug(""TASK\n"" + pp.pformat(task.dict())). def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. def plan(self):; # uncalled function; return [t.p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:54122,Validat,ValidationError,54122,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"s for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". __all__ = [; ""ConvergenceError"",; ""MissingMethodError"",; ""ManagedMethodError"",; ""OptimizationConvergenceError"",; ""ParsingError"",; ""PastureRequiredError"",; ""PsiException"",; ""SCFConvergenceError"",; ""TDSCFConvergenceError"",; ""TestComparisonError"",; ""UpgradeHelper"",; ""ValidationError"",; ""docs_table_link"",; ""sanitize_method"",; ]. from typing import Any, Dict, List, Optional. from psi4 import core, extras. [docs]; class PsiException(Exception):; """"""Error class for |PSIfour|. Flags success as False (triggering coffee).""""""; extras._success_flag_ = False. [docs]; class ValidationError(PsiException):; """"""Input specification has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]; class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and outpu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/exceptions.html:1440,Validat,ValidationError,1440,psi4manual/1.9.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/exceptions.html,2,['Validat'],['ValidationError']
Security,"s for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". __all__ = [; ""ConvergenceError"",; ""MissingMethodError"",; ""ManagedMethodError"",; ""OptimizationConvergenceError"",; ""ParsingError"",; ""PastureRequiredError"",; ""PsiException"",; ""SCFConvergenceError"",; ""TDSCFConvergenceError"",; ""TestComparisonError"",; ""UpgradeHelper"",; ""ValidationError"",; ""docs_table_link"",; ""sanitize_method"",; ]. from typing import Any, Dict, List, Optional; from psi4 import core, extras. [docs]; class PsiException(Exception):; """"""Error class for |PSIfour|. Flags success as False (triggering coffee).""""""; extras._success_flag_ = False; pass. [docs]; class ValidationError(PsiException):; """"""Input specification has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]; class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:1440,Validat,ValidationError,1440,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,1,['Validat'],['ValidationError']
Security,"s for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". __all__ = [; ""ConvergenceError"",; ""MissingMethodError"",; ""ManagedMethodError"",; ""OptimizationConvergenceError"",; ""ParsingError"",; ""PastureRequiredError"",; ""PsiException"",; ""SCFConvergenceError"",; ""TDSCFConvergenceError"",; ""TestComparisonError"",; ""UpgradeHelper"",; ""ValidationError"",; ""docs_table_link"",; ""sanitize_method"",; ]. from typing import Any, Dict, List, Optional; from psi4 import core, extras. [docs]class PsiException(Exception):; """"""Error class for |PSIfour|. Flags success as False (triggering coffee).""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Input specification has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and outpu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html:1438,Validat,ValidationError,1438,psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,1,['Validat'],['ValidationError']
Security,"s list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == core.Matrix:; sdim1 = core.Dimension(irreps); sdim2 = core.Dimension(irreps). for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html:4250,Validat,ValidationError,4250,psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,5,['Validat'],['ValidationError']
Security,"s supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata; List of dicts containing CBS stage keywords.; molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". # TODO: split options into mixable (qc_module=ccenergy/"""") or non-mixable (freeze_core=true/false). metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ""scf"", ""c4-scf""]:; scf = {}; if stage[""wfn""].startswith(""c4""):; scf[""wfn""] = ""c4-hf""; else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xtpl(len(scf[""basis""][1]), scf[""treatment""]); scf[""alpha""] = None; scf[""options""] = False; scf[""options_lo""] = False; metadata.append(scf); # 2c) keep processing current stage; stage[""treatment""] = item.get(""treatment"", ""scf"" if len(metadata) == 0 else ""corl""); stage[""stage""] = item.get(""stage"", False); if not stage[""stage""]:; if len(met",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:17927,Validat,ValidationError,17927,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,6,['Validat'],['ValidationError']
Security,"s to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = os.environ.get('PSIDATADIR', None); #nolongerpredictable psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; driver_loc = os.path.dirname(os.path.abspath(__file__)); dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath + \; ':' + driver_loc # so the databases can ""import qcdb"". sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:9961,Validat,ValidationError,9961,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"s » embedding_charges; set_max_nbody » max_nbody; set_molecule » molecule; set_nfragments » nfragments; set_return_total_data » return_total_data. field basis: str = '(auto)'¶. field bsse_type: List[BsseEnum] = [<BsseEnum.cp: 'cp'>]¶; Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned. Validated by:. set_bsse_type. field driver: DriverEnum [Required]¶; The computation driver; i.e., energy, gradient, hessian. field embedding_charges: Dict[int, List[float]] = {}¶; Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment. Validated by:. set_embedding_charges. field keywords: Dict[str, Any] = {}¶; The computation keywords/options. field max_nbody: int = -1¶; Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments. Validated by:. set_max_nbody. field method: str = '(auto)'¶. field molecule: Any [Required]¶; The target molecule, if not the last molecule defined. Validated by:. set_molecule. field nbodies_per_mc_level: List[List[Union[int, Literal['supersystem']]]] = []¶; Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry ‘supersystem’ means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any ‘supersystem’ element is at the end. field nfragments: int = -1¶; Number of distinct fragments c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/nbody.html:13234,Validat,Validated,13234,psi4manual/1.7.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/nbody.html,1,['Validat'],['Validated']
Security,"s(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union, TYPE_CHECKING; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:5064,validat,validator,5064,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,2,['validat'],['validator']
Security,"s(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(); adc_wfn = run_adcc(name, do_timer=False, **kwargs); state = adc_wfn.adcc_state; hf = state.reference_state; mp = state.ground_state. # Formats and indention; ind = "" ""; def format_vector(label, data):; assert data.ndim == 1; return f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Møller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:118170,Validat,ValidationError,118170,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['Validat'],['ValidationError']
Security,"s) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:18869,Validat,ValidationError,18869,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,2,['Validat'],['ValidationError']
Security,"s); dertype = 2. optstash = OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['hessian']:; dertype = 2; elif lowername in procedures['gradient']:; dertype = 1; func = gradient; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; freq_dertype = kwargs['dertype']. if der0th.match(str(freq_dertype)):; dertype = 0; func = energy; elif der1st.match(str(freq_dertype)):; dertype = 1; func = gradient; elif der2nd.match(str(freq_dertype)):; dertype = 2; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function frequency.' % (freq_dertype)). # 3. if the user provides a custom function THAT takes precedence; if ('freq_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['freq_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['freq_func']. # Summary validation; if (dertype == 2) and (lowername in procedures['hessian']):; pass; elif (dertype == 1) and (func is gradient) and (lowername in procedures['gradient']):; pass; elif (dertype == 1) and not(func is gradient):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:60450,Validat,ValidationError,60450,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"s, energies. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. A format description is found https://www3.cmbi.umcn.nl/molden/molden_format.html. Parameters; ----------; expected; Path to reference Molden file against which `computed` is compared.; computed; Path to input Molden file to compare against `expected`.; atol_exponent; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label; Label for passed and error messages. """"""; def moldenfile_to_string(fname):; with open(fname, 'r') as fn:; molden_string = fn.read(); return molden_string. ref = moldenfile_to_string(expected).splitlines(); calc = moldenfile_to_string(computed).splitlines(); if len(ref) != len(calc):; raise ValidationError(f""These two molden files have different lengths...\n""). high_accuracy = atol_exponent; index = 0; max_len = len(calc); tests = []; section = 0. geom_re = re.compile(r'^\s*(\w*)\s+(\d+)\s+(\d+)\s+(-?\d+.\d+)\s+(-?\d+.\d+)\s+(-?\d+.\d+)\s*$'); basis_header_re = re.compile(r'^\s*([s,p,d,f,g])\s*(\d*)\s*(\d*.\d*)\s*$'); s1_re = re.compile(r'^\s*(\d+.?\d*)\s+(\d+.?\d*)$'); s2_re = re.compile(r'^\s*(\d+)\s+(-?\d+.\d+[e,E][\+,-]\d+)\s*$'); sym_re = re.compile(r'^\s*Sym\s*=\s*(\w*)\s*$'); energy_re = re.compile(r'^\s*Ene\s*=\s*(-?\d*.?\d*[e,E]?\+?-?\d*)\s*$'); spin_re = re.compile(r'^\s*Spin\s*=\s*(\w*)\s*$'); occ_re = re.compile(r'^\s*Occup\s*=\s*(-?\d*.\d*[e,E]?-?\+?\d*)\s*$'). for i in range(max_len):; line = calc[i]. if geom_re.match(line):; c1, c2, c3, c4, c5, c6 = geom_re.match(line).groups(); r1, r2, r3, r4, r5, r6 = geom_re.match(line).groups(); test = compare_strings(r1, c1) and compare_integers(r2, c2) and compare_integers(r3, c3) and compare_values(r4, c4, high_accuracy) and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fchk.html:6438,Validat,ValidationError,6438,psi4manual/1.7.x/_modules/psi4/driver/p4util/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fchk.html,4,['Validat'],['ValidationError']
Security,"s, ri_basis, etc.; * @param name Value from input file. """"""; self.PYbasissets[role] = name. [docs] def basisset(self, role='BASIS'):; """"""Returns the basis name for the provided type.; * @param type Keyword from input file.; * @returns the value from input. """"""; try:; return self.PYbasissets[role]; except ValueError:; raise ValidationError('CoordEntry::basisset: Basisset not set for %s and type of %s' % \; (self.PYlabel, role)). [docs] def basissets(self):; """"""Returns basisset to atom map""""""; return self.PYbasissets. [docs] def set_shell(self, bshash, key='BASIS'):; """"""Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. """"""; self.PYshells[key] = bshash. [docs] def shell(self, key='BASIS'):; """"""Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. """"""; try:; return self.PYshells[key]; except (ValueError, KeyError):; raise ValidationError('CoordEntry::shells: Shells not set for %s and type of %s' % \; (self.PYlabel, key)). [docs] def shells(self):; """"""Returns shells sets to atom map""""""; return self.PYshells. [docs] def everything(self):; print('\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n Basissets = %s\n\n Shells = %s\n\n' %; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z, basis=None, shells=None):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label, basis, shells); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:10874,Validat,ValidationError,10874,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['Validat'],['ValidationError']
Security,"s.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; from typing import Dict, List, Tuple, Union. import numpy as np; from qcelemental.models import AtomicInput; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver_findif; from psi4.driver.p4util.exceptions import ValidationError. _engine_can_do = collections.OrderedDict([; # engine order establishes default for each disp; (""libdisp"", [""d1"", ""d2"", ""chg"", ""das2009"", ""das2010"",]),; (""s-dftd3"", [ ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ""d3zeroatm"", ""d3bjatm"", ""d3mzeroatm"", ""d3mbjatm"", ]),; (""dftd3"", [ ""d2"", ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ]),; (""nl"", [ ""nl"", ]),; (""mp2d"", [ ""dmp2"", ]),; (""dftd4"", [ ""d4bjeeqatm"", ]),; (""mctc-gcp"", [ ""3c"", ]),; (""gcp"", [ ""3c"", ]),; ]) # yapf: disable. def _capable_engines_for_disp()-> Dict[str, List[str]]:; """"""Invert _engine_can_do dictionary and check program detection. Returns a dictionary with keys all dispersion levels and values a list of all; capable engines, where the engine in the first element is available, if any are. """"""; from qcengine.testing import _programs as _programs_qcng. programs_disp = {k: v for k, v in _programs_qcng.items() if k in _engine_can_do}; programs_disp[""libdisp""] = True; programs_disp[""nl""] = True. capable = collec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:1457,Validat,ValidationError,1457,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['Validat'],['ValidationError']
Security,"s.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; from typing import Dict, List, Tuple, Union. import numpy as np; from qcelemental.models import AtomicInput; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver_findif; from psi4.driver.p4util.exceptions import ValidationError. _engine_can_do = collections.OrderedDict([; # engine order establishes default for each disp; (""libdisp"", [""d1"", ""d2"", ""chg"", ""das2009"", ""das2010"",]),; (""s-dftd3"", [ ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ""d3zeroatm"", ""d3bjatm"", ""d3mzeroatm"", ""d3mbjatm"", ]),; (""dftd3"", [ ""d2"", ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ]),; (""nl"", [ ""nl"", ]),; (""mp2d"", [ ""dmp2"", ]),; (""dftd4"", [ ""d4bjeeqatm"", ]),; (""mctc-gcp"", [ ""3c"", ]),; (""gcp"", [ ""3c"", ]),; ]) # yapf: disable. def _capable_engines_for_disp()-> Dict[str, List[str]]:; """"""Invert _engine_can_do dictionary and check program detection. Returns a dictionary with keys all dispersion levels and values a list of all; capable engines, where the engine in the first element is available, if any are. """"""; try:; from qcengine.testing import _programs as _programs_qcng; except ModuleNotFoundError:; # _programs_qcng is up-to-date with current harnesses but it requires pytest present, so let's provide a workaround; from qc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:1459,Validat,ValidationError,1459,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['Validat'],['ValidationError']
Security,"s.; data : float or decimal.Decimal or numpy.ndarray; Value for `label`.; comment : str; Additional notes.; doi : str; Literature citation or definition DOI link.; glossary : str; Extended description or definition.; numeric : bool; Whether `data` is numeric. Pass `True` to disable validating `data` as float/Decimal/np.ndarray. """""". numeric: bool; label: str; units: str; data: Any; comment: str = """"; doi: Optional[str] = None; glossary: str = """". class Config:; extra = ""forbid""; allow_mutation = False; json_encoders = {np.ndarray: lambda v: v.flatten().tolist(), complex: lambda v: (v.real, v.imag)}. def __init__(self, label, units, data, *, comment=None, doi=None, glossary=None, numeric=True):; kwargs = {""label"": label, ""units"": units, ""data"": data, ""numeric"": numeric}; if comment is not None:; kwargs[""comment""] = comment; if doi is not None:; kwargs[""doi""] = doi; if glossary is not None:; kwargs[""glossary""] = glossary. super().__init__(**kwargs). @validator(""data""); def must_be_numerical(cls, v, values, **kwargs):; try:; 1.0 * v; except TypeError:; try:; Decimal(""1.0"") * v; except TypeError:; if values[""numeric""]:; raise ValueError(f""Datum data should be float, Decimal, or np.ndarray, not {type(v)}.""); else:; values[""numeric""] = True; else:; values[""numeric""] = True. return v. def __str__(self, label=""""):; width = 40; text = [""-"" * width, ""{:^{width}}"".format(""Datum "" + self.label, width=width)]; if label:; text.append(""{:^{width}}"".format(label, width=width)); text.append(""-"" * width); text.append(""Data: {}"".format(self.data)); text.append(""Units: [{}]"".format(self.units)); text.append(""doi: {}"".format(self.doi)); text.append(""Comment: {}"".format(self.comment)); text.append(""Glossary: {}"".format(self.glossary)); text.append(""-"" * width); return ""\n"".join(text). def dict(self, *args, **kwargs):; return super().dict(*args, **{**kwargs, **{""exclude_unset"": True}}). def to_units(self, units=None):; from .physical_constants import constants. to_unit = self.units if unit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/datum.html:1573,validat,validator,1573,psi4manual/1.4.0/_modules/qcelemental/datum.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/datum.html,3,['validat'],['validator']
Security,"s.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); if core.get_option(""SCF"", ""DF_INTS_IO"") != ""SAVE"":; core.clean(); optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for unsupported calls; if ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype != None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; stage['scheme'] = kwargs.pop('scf_scheme'); stage['stage'] = ""scf""; stage['treatment'] = ""scf""; else:; # _validate_cbs_inputs will produce scf stage automatically; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'corl_scheme' in kwargs:; stage['scheme'] =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:66504,Validat,ValidationError,66504,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,s; compare_fcidumps; compare_fcidumps; ConvergenceError; copy_file_from_scratch; copy_file_from_scratch; copy_file_to_scratch; copy_file_to_scratch; create_plugin; create_plugin; CSXError; cubeprop; cubeprop; Dftd3Error; dynamic_variable_bind; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energies_from_fcidump; energy; energy; fchk; fchk; fchkfile_to_string; fchkfile_to_string; fcidump; fcidump; fcidump_from_file; fcidump_from_file; find_approximate_string_matches; find_approximate_string_matches; free_atom_volumes; free_atom_volumes; freq; freq; frequencies; frequencies; frequency; frequency; gdma; gdma; geometry; geometry; get_memory; get_memory; gradient; gradient; hessian; hessian; ipi_broker; ipi_broker; join_path; join_path; levenshtein; levenshtein; ManagedMethodError; mdi_run; mdi_run; message_box; message_box; MissingMethodError; molden; molden; molecule_get_attr; molecule_get_attr; molecule_set_attr; molecule_set_attr; oeprop; oeprop; opt; opt; OptimizationConvergenceError; optimize; optimize; optimize_geometric; optimize_geometric; ParsingError; PastureRequiredError; pcm_helper; pcm_helper; print_stderr; print_stderr; print_stdout; print_stdout; process_input; process_input; prop; prop; properties; properties; PsiException; PsiImportError; compare_vibinfos; compare_vibinfos; filter_nonvib; filter_nonvib; filter_omega_to_real; filter_omega_to_real; harmonic_analysis; harmonic_analysis; hessian_symmetrize; hessian_symmetrize; print_molden_vibs; print_molden_vibs; print_vibs; print_vibs; thermo; thermo; QMMM; sanitize_name; sanitize_name; scf_helper; scf_helper; scf_wavefunction_factory; scf_wavefunction_factory; SCFConvergenceError; set_memory; set_memory; set_module_options; set_module_options; set_options; set_options; Table; tdscf; tdscf; TDSCFConvergenceError; temp_circular_import_blocker; temp_circular_import_blocker; TestComparisonError; UpgradeHelper; ValidationError; vibanal_wfn; vibanal_wfn; write_eigenvalues; write_eigenvalues.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:553483,Validat,ValidationError,553483,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['Validat'],['ValidationError']
Security,s; psi4.driver.freq; psi4.driver.frequencies; psi4.driver.frequency; psi4.driver.gdma; psi4.driver.geometry; psi4.driver.get_memory; psi4.driver.getFromDict; psi4.driver.gradient; psi4.driver.hessian; psi4.driver.join_path; psi4.driver.levenshtein; psi4.driver.ManagedMethodError; psi4.driver.molden; psi4.driver.molecule_get_attr; psi4.driver.molecule_set_attr; psi4.driver.oeprop; psi4.driver.opt; psi4.driver.optimize; psi4.driver.ParsingError; psi4.driver.PastureRequiredError; psi4.driver.pcm_helper; psi4.driver.print_stderr; psi4.driver.print_stdout; psi4.driver.process_input; psi4.driver.process_pubchem_command; psi4.driver.prop; psi4.driver.property; psi4.driver.PsiException; psi4.driver.PsiImportError; psi4.driver.QMMM; psi4.driver.sanitize_name; psi4.driver.scf_helper; psi4.driver.scf_wavefunction_factory; psi4.driver.set_memory; psi4.driver.set_module_options; psi4.driver.set_options; psi4.driver.success; psi4.driver.Table; psi4.driver.TestComparisonError; psi4.driver.ValidationError; psi4.driver.xml2dict. Appendices; Appendices. /autodir_options_c; ; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <n,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:340001,Validat,ValidationError,340001,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['Validat'],['ValidationError']
Security,s; psi4.driver.freq; psi4.driver.frequencies; psi4.driver.frequency; psi4.driver.gdma; psi4.driver.geometry; psi4.driver.get_memory; psi4.driver.getFromDict; psi4.driver.gradient; psi4.driver.hessian; psi4.driver.join_path; psi4.driver.levenshtein; psi4.driver.ManagedMethodError; psi4.driver.molden; psi4.driver.molecule_get_attr; psi4.driver.molecule_set_attr; psi4.driver.oeprop; psi4.driver.opt; psi4.driver.optimize; psi4.driver.ParsingError; psi4.driver.PastureRequiredError; psi4.driver.pcm_helper; psi4.driver.print_stderr; psi4.driver.print_stdout; psi4.driver.process_input; psi4.driver.process_pubchem_command; psi4.driver.prop; psi4.driver.property; psi4.driver.PsiException; psi4.driver.PsiImportError; psi4.driver.QMMM; psi4.driver.sanitize_name; psi4.driver.scf_helper; psi4.driver.scf_wavefunction_factory; psi4.driver.set_memory; psi4.driver.set_module_options; psi4.driver.set_options; psi4.driver.success; psi4.driver.Table; psi4.driver.TestComparisonError; psi4.driver.ValidationError; psi4.driver.xml2dict. Appendices; Appendices. autodir_options_c; ; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:298577,Validat,ValidationError,298577,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['Validat'],['ValidationError']
Security,"s['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % psi4.psi_top_srcdir()); database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = psi4.get_global_option('BASIS'); user_df_basis_scf = psi4.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = psi4.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = psi4.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = psi4.get_global_option('DF_BASIS_ELST'). user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). b_user_reference = psi4.has_global_option_changed('REFERENCE'); user_reference = psi4.get_global_option('REFERENCE'); user_memory = psi4.get_memory(). user_molecule = psi4.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.mat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:31005,Validat,ValidationError,31005,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"s[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:19255,Validat,ValidationError,19255,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"s]def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2']). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = PsiMod.IOManager.shared_object(); psio = PsiMod.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(PsiMod.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). run_scf('RHF', **kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). PsiMod.dfmp2grad(); e_dfmp2 = PsiMod.get_variable('DF-MP2 ENERGY'); e_scs_dfmp2 = PsiMod.get_variable('SCS-DF-MP2 ENERGY'). optstash.restore(). if (name.upper() == 'SCS-DFMP2') or (name.upper() == 'SCS-DF-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2'):; return e_dfmp2. [docs]def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:11497,Validat,ValidationError,11497,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"s_computed()[source]¶; Whether the current atom’s coordinates are up-to-date. is_equivalent_to(other)[source]¶; Whether this atom has the same mass and ghost status as atom other.; Also compares basis set assignment down to nbf(), has_puream() level; with code borrowed from Robert M. Parrish’s SAD guess in Psi4. is_ghosted()[source]¶; Whether the current atom is ghosted or not. label()[source]¶; The atom label. mass()[source]¶; The atomic mass of the current atom. static r(a1, a2)[source]¶; Computes the distance between two sets of coordinates. set_basisset(name, role='BASIS')[source]¶; Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. set_ghosted(gh)[source]¶; Flag the atom as either ghost or real. set_shell(bshash, key='BASIS')[source]¶; Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. shell(key='BASIS')[source]¶; Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. shells()[source]¶; Returns shells sets to atom map. symbol()[source]¶; The atomic symbol. class CoordValue(fixed=False, computed=False)[source]¶; An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. everything()[source]¶. fixed()[source]¶; Get whether the coordinate value is fixed or not. invalidate()[source]¶; Flag the current value as outdated. set_fixed(fixed)[source]¶; Set whether the coordinate value is fixed or not. class NumberValue(value, fixed=False)[source]¶; Specialization of CoordValue that is simply a number to be stored. clone()[source]¶; Returns new, independent NumberValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. rset(val)[source]¶; Resets value of coordinat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:116044,hash,hash,116044,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['hash'],['hash']
Security,"s_method_kwargs = ['scf_wfn', 'corl_wfn', 'delta_wfn']; cbs_method_kwargs += ['delta%d_wfn' % x for x in range(2, 6)]. cbs_methods = []; for method in cbs_method_kwargs:; if method in kwargs:; cbs_methods.append(kwargs[method]); return cbs_methods. def _parse_cbs_gufunc_string(method_name):; method_name_list = re.split( """"""\+(?![^\[\]]*\]|[^\(\)]*\))"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy cal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:57410,Validat,ValidationError,57410,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"scalar_variable(key); elif core.has_array_variable(key):; return core.array_variable(key); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls, key):; if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return cls.array_variable(key); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key, val):; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(val)); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). def _core_wavefunction_set_variable(cls, key, val):; if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(val)); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). def _core_del_variable(key):; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:19277,Validat,ValidationError,19277,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"scf"" if len(metadata) == 0 else ""corl""); stage[""stage""] = item.get(""stage"", False); if not stage[""stage""]:; if len(metadata) == 0:; stage[""stage""] = ""scf""; elif len(metadata) == 1:; stage[""stage""] = ""corl""; else:; stage[""stage""] = ""delta{0:d}"".format(len(metadata) - 1); stage[""scheme""] = item.get(""scheme"", _get_default_xtpl(len(stage[""basis""][1]), stage[""treatment""])); if len(metadata) > 0:; stage[""wfn_lo""] = item.get(""wfn_lo"", metadata[-1].get(""wfn"")).lower(); stage[""basis_lo""] = _expand_bracketed_basis(item.get(""basis_lo"", item[""basis""]).lower(), molecule); if len(stage[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({0:d}) and low ({1:d}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); metadata.append(stage); return (metadata). def _process_cbs_kwargs(kwargs):; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs : dict; kwargs containing the CBS function specification. Returns; -------; list; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); # either both *_wfn and *_basis have to be spec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:31542,validat,validation,31542,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['validat'],['validation']
Security,"se ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]. # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:4059,Validat,ValidationError,4059,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"se ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]. # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Setup unique scratch directory and move in; current_directory = os.getcwd(); psioh = PsiMod.IOManager.sh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:8145,Validat,ValidationError,8145,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"se ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]. # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Setup unique scratch directory and move in; current_directory = os.getcwd(); psioh = psi4.IOManager.shar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:8980,Validat,ValidationError,8980,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"se ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.frombuffer(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs):; """"""; Chains dot products together from a series of Psi4 Matrix classes. By default there is no transposes, an optional vector of booleans can be passed in.; """""". trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[n + 1]). return ret. def _irrep_access(self, *args, **kwargs):; """"""; Warns user when iterating/accessing an irreped object.; """"""; raise ValidationError(""Attempted to access by index/iteration a Psi4 data object that supports multiple""; ""irreps. Please use .np or .nph explicitly.""). # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_serial = _to_serial; core.Matrix.from_serial = classmethod(_from_serial); core.Matrix.chain_dot = _chain_dot; core.Matrix.__iter__ = _irrep_access; core.Matrix.__getitem__ = _irrep_access. # Vector attributes; core.Vector.from_array = classmethod(array_to_matrix); core.Vector.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Vector.to_array = _to_array; core.Vector.shape = _np_shape; core.Vector.np = _np_view; core.Vector.nph = _nph",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html:12183,Validat,ValidationError,12183,psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,2,"['Validat', 'access']","['ValidationError', 'access']"
Security,"se. CFOUR_HFSTABILITY¶. Control analysis of the stability of RHF, ROHF and UHF wavefunctions, as well as a possible search for a lower SCF solution. There are three possible options for this keyword. OFF (=0) does nothing, while ON (=1) performs a stability analysis and returns the number of negative eigenvalues in the orbital rotation Hessian. A third option, FOLLOW (=2) performs the stability analysis and then proceeds to rotate the SCF orbitals in the direction of a particular negative eigenvalue of the orbital rotation Hessian (see the explanation of keyword CFOUR_ROT_EVEC , after which the SCF is rerun. Type: string; Possible Values: OFF, ON, FOLLOW; Default: OFF. CFOUR_INCORE¶. This keyword can be used to significantly reduce disk i/o, and should be implemented very soon. The following options are available: OFF (= 0), no special algorithms are used (the default case); ALL (=1) all quantities except the molecular integral lists are held in core; PARTIAL (= 2), the T2 and T1 vectors are held in core throughout the calculation; (=4) all quantities except the and integrals are held in core; (=5) and and two-index quantities are held in core; (=6) all direct access files (MOINTS, GAMLAM, etc.) are held in core. At present, these options have been implemented only in the energy code xvcc and the excitation energy code xvee. (Default: 0). Type: string; Possible Values: OFF, ALL, PARTIAL; Default: OFF. CFOUR_INPUT_MRCC¶. Specifies whether an input for mrcc is written (ON, =0) or not (OFF, =1) if CFOUR_CC_PROGRAM =EXTERNAL has been specified. Type: boolean; Default: true. CFOUR_INTEGRALS¶. This keyword defines what type of integral input will be written by xjoda. VMOL (=1) has to be used with the programs of CFOUR. Using ARGOS (=0), input for Pitzer’s ARGOS integral program will be written. (Default: VMOL). Type: string; Possible Values: VMOL, ARGOS; Default: VMOL. CFOUR_JODA_PRINT¶. Controls amount of debug printing performed by xjoda. The higher the number, the more ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:34051,access,access,34051,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['access'],['access']
Security,"se:; raise ValidationError(""""""SCF basis sets through keyword '%s' are required. Or perhaps you forgot the '%s'."""""" % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = _expand_bracketed_basis(kwargs['delta_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA basis sets through keyword '%s' are required."""""" % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')); #; # # Establish list of valid basis sets for fifth delta correction energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_3; elif (len(BSTR) == 2) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) ==",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:37336,Validat,ValidationError,37336,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"se; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. # Establish method for reference energy; if do_corl and cbs_corl_wfn.startswith('c4-'):; default_scf = 'c4-hf'; else:; default_scf = 'hf'; cbs_scf_wfn = kwargs.pop('scf_wfn', default_scf).lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # ... resume correlation logic; if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:39630,Validat,ValidationError,39630,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"sed from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for FCHK files."""""". import numpy as np; from psi4.driver.p4util.testing import compare_strings, compare_arrays, compare_values, compare_integers; from psi4 import core; from .exceptions import ValidationError. __all__ = ['fchkfile_to_string','compare_fchkfiles']. def _consume_fchk_section(input_list, index):; """"""compare a float or integer matrix section"""""". n = int(input_list[index].split()[-1]); kind = input_list[index].split()[-3]. if ""R"" in kind:; dtype = np.float64; format_counter = 5; elif ""I"" in kind:; dtype = np.float64; format_counter = 6; else:; raise ValidationError('Unknow field type in FCHK reader\n'). extra = 0 if n <= format_counter else n % format_counter; lines = 1 if n <= format_counter else int(n / format_counter); offset = lines + 1 if extra > 0 else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. [docs]def fchkfile_to_string(fname):; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read(); return fchk",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:1330,Validat,ValidationError,1330,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,2,['Validat'],['ValidationError']
Security,"sed upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); els",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:32280,Validat,ValidationError,32280,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"seek['entry']:. # Seek entry in lines, else skip to next entry; shells, msg = parser.parse(entry, lines); if shells is None:; continue. # Found!; atom_basis_shell[label][bas] = shells; mol.set_basis_by_number(at, bas, role=role); summary.append(""""""entry %-10s %s %s"""""" % (entry, msg, index)); break. # Break from outer loop if inner loop breaks; else:; continue; break. else:; # Ne'er found :-(; text2 = """""" Shell Entries: %s\n"""""" % (seek['entry']); text2 += """""" Basis Sets: %s\n"""""" % (seek['basis']); text2 += """""" File Path: %s\n"""""" % (', '.join(map(str, seek['path'].split(':')))); text2 += """""" Input Blocks: %s\n"""""" % (', '.join(seek['strings'])); raise BasisSetNotFound('BasisSet::construct: Unable to find a basis set for atom %d for role %s among:\n%s' % \; (at + 1, role, text2)). # Construct the grand BasisSet for mol; basisset = BasisSet(role, mol, atom_basis_shell). # Construct all the one-atom BasisSet-s for mol's CoordEntry-s; for at in range(mol.natom()):; oneatombasis = BasisSet(basisset, at); oneatombasishash = hashlib.sha1(oneatombasis.print_detail(numbersonly=True).encode('utf-8')).hexdigest(); mol.set_shell_by_number(at, oneatombasishash, role=role); mol.update_geometry() # re-evaluate symmetry taking basissets into account. #TODO fix name; basisset.name = ' + '.join(names). # Summary printing; tmp = defaultdict(list); for at, v in enumerate(summary):; tmp[v].append(at + 1); tmp2 = OrderedDict(); maxsats = 0; for item in sorted(tmp.values()):; for msg, ats in tmp.items():; if item == ats:; G = (list(x) for _, x in itertools.groupby(ats, lambda x, c=itertools.count(): next(c) - x)); sats = "", "".join(""-"".join(map(str, (g[0], g[-1])[:len(g)])) for g in G); maxsats = max(maxsats, len(sats)); tmp2[sats] = msg; #text = """""" ==> Loading Basis Set <==\n\n""""""; #text += """""" Role: %s\n"""""" % (role); #text += """""" Basis Set: %s\n"""""" % (basisset.name); text = ''; for ats, msg in tmp2.items():; text += """""" atoms %s %s\n"""""" % (ats.ljust(maxsats), msg). #print text; return basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:25869,hash,hashlib,25869,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['hash'],['hashlib']
Security,"self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(6); text += "" %5d %11s %5d %11s %5d %11s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compute()); # Check for NaN, and don't update if we find one; # what is this? proper py traslation?; if val == val:; self.dval.rset(val * 180.0 / math.pi). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'ZMatrixCoord'. [docs] def clone(self):; """"""Returns new, independent ZMatrixEntry object.""""""; return copy.deepcopy(self). [docs] def compute(self):; """"""Compute the Cartesian coordinates in Bohr of current atom's entry."""""". if self.computed:; return self.coordinates. # place first atom at the origi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:12890,Validat,ValidationError,12890,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,1,['Validat'],['ValidationError']
Security,"sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', psi4.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = psi4.new_wavefunction(mcscf_molecule, psi4.get_global_option('BASIS')). return psi4.mcscf(new_wfn). [docs]def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']) # yes, this really must be global, not local to SCF. # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if psi4.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). dfmp2_wfn = psi4.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). optstash.restore(); return dfmp2_wfn. [docs]def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; psi4.set_local_option('TRANSQT2', 'WFN', 'CCSD'); psi4.set_local_option('CCSORT', 'WFN', 'CCSD'); psi4.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); psi4.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; psi4.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); psi4.set_local_option('CCSORT', 'WFN'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:51287,Validat,ValidationError,51287,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"ser's OMP_NUM_THREADS and CFOUR_OMP_NUM_THREADS; omp_num_threads_found = 'OMP_NUM_THREADS' in os.environ; if omp_num_threads_found == True:; omp_num_threads_user = os.environ['OMP_NUM_THREADS']; if psi4.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = str(psi4.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen([cfour_executable], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); p4out.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; if psi4.outfile_name() == 'stdout':; sys.stdout.write(data); else:; p4out.write(data); p4out.flush(); c4out += data; internal_p4c4_info['output'] = c4out. # Restore user's OMP_NUM_THREADS; if omp_num_threads_found == True:; if psi4.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. c4files = {}; p4out.write('\n'); for item in ['GRD', 'FCMFINAL', 'DIPOL']:; try:; with open(psioh.get_default_path() + cfour_tmpdir + '/' + item, 'r') as handle:; c4files[item] = handle.read(); p4out.write(' CFOUR scratch file %s has been read\n' % (item)); p4out.write('%s\n' % c4files[item]); internal_p4c4_info[item.lower()] = c4files[item]; except IOError:; pass; p4out.write('\n'). molecule = psi4.get_active_molecule(); if molecule.name() == 'blank_molecule_psi4_yo':; qcdbmolecule = None; else:; molecule.update_geometry(); qcdbmolecule = qcd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:8532,Validat,ValidationError,8532,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html,1,['Validat'],['ValidationError']
Security,"set(), 1: {((1,), (1, 2)),; 2: {((1,), (1, 2)), ((2,), (1, 2))},; ((2,), (1, 2)), 2: {((1, 2), (1, 2))}; ((1, 2), (1, 2))} }; }. Subdicts below are always returned. Any may be empty if not requested through *bsse_type*. * ``'all'`` |w---w| full list of computations required; * ``'cp'`` |w---w| list of computations required for CP procedure; * ``'nocp'`` |w---w| list of computations required for non-CP procedure; * ``'vmfc_compute'`` |w---w| list of computations required for VMFC procedure; * ``'vmfc_levels'`` |w---w| list of levels required for VMFC procedure. """"""; # What levels do we need?; fragment_range = range(1, nfragments + 1). # Need nbodies and all lower-body in full basis; cp_compute_list = {x: set() for x in nbodies}; nocp_compute_list = {x: set() for x in nbodies}; vmfc_compute_list = {x: set() for x in nbodies}; vmfc_level_list = {x: set() for x in nbodies} # Need to sum something slightly different. # Verify proper passing of bsse_type. already validated in Computer; bsse_type_remainder = set(bsse_type) - {e.value for e in BsseEnum}; if bsse_type_remainder:; raise ValidationError(""""""Unrecognized BSSE type(s): {bsse_type_remainder}""""""). # Build up compute sets; if 'cp' in bsse_type:; # Everything is in full n-mer basis; basis_tuple = tuple(fragment_range). for nb in nbodies:; if nb > 1:; for sublevel in range(1, nb + 1):; for x in itertools.combinations(fragment_range, sublevel):; # below was `nbodies`, which would never hit. present is closest to pre-DDD. purpose unclear to me.; # if self.max_nbody == 1: break; cp_compute_list[nb].add((x, basis_tuple)). if 'nocp' in bsse_type or return_total_data:; # Everything in monomer basis; for nb in nbodies:; for sublevel in range(1, nb + 1):; for x in itertools.combinations(fragment_range, sublevel):; nocp_compute_list[nb].add((x, x)). if 'vmfc' in bsse_type:; # Like a CP for all combinations of pairs or greater; for nb in nbodies:; for cp_combos in itertools.combinations(fragment_range, nb):; basis_tuple = tuple",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:17761,validat,validated,17761,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,5,['validat'],['validated']
Security,"set_local_option('SCF', 'SCF_TYPE', 'DF'). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf_gradient(name, **kwargs). optstash.restore(). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). user_ref = PsiMod.get_option('DETCI', 'REFERENCE'); if (user_ref != 'RHF') or (user_ref != 'ROHF'):; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if (name.lower() == 'zapt'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'ZAPTN'); PsiMod.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; PsiMod.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif (name.lower() == 'detci-mp') or (name.lower() == 'mp'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'DETCI'); PsiMod.set_local_option('DETCI', 'WFN', 'DETCI'); PsiMod.set_local_option('DETCI', 'MPN', 'TRUE'). level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; PsiMod.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif (name.lower() == '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:38415,Validat,ValidationError,38415,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; z = qcel.periodictable.to_Z(fileAtom). # Add it to the molecule.; instance.add_atom(z, fileX, fileY, fileZ, fileAtom, qcel.periodictable.to_mass(fileAtom), z). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(; ""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.PYinput_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.PYinput_units_to_au = 1.0 / constants.bohr2angstroms. instance.update_geometry(); return instance. def save_string_xyz(self, save_ghosts=True, save_natom=False):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html:8981,Validat,ValidationError,8981,psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html,2,['Validat'],['ValidationError']
Security,"set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; z = qcel.periodictable.to_Z(fileAtom). # Add it to the molecule.; instance.add_atom(z, fileX, fileY, fileZ, fileAtom, qcel.periodictable.to_mass(fileAtom), z). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(; ""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.PYinput_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.PYinput_units_to_au = 1.0 / qcel.constants.bohr2angstroms. instance.update_geometry(); return instance. def save_string_xyz(self, save_ghosts=True, save_natom=False):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.0407120000",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:8796,Validat,ValidationError,8796,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,6,['Validat'],['ValidationError']
Security,"shape[0],; do_shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * qcel.constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_completion,; run_mirror=do_mirror,; verbose=verbose). compare_integers(; True, np.allclose(solution.shift, perturbation.shift, atol=6), 'shifts equiv', verbose=verbose - 1); if not do_resort:; compare_integers(; True,; np.allclose(solution.rotation.T, perturbation.rotation),; 'rotations transpose',; verbose=verbose - 1); if solution.mirror:; compare_integers(True, do_mirror, 'mirror allowed', verbose=verbose - 1). def set_fragment_pattern(self, frl, frt, frc, frm):; """"""Set fragment member data through public method analogous to psi4.core.Molecule"""""". if not (len(frl) == len(frt) == len(frc) == len(frm)):; raise ValidationError(""""""Molecule::set_fragment_pattern: fragment arguments not of same length.""""""). self.fragments = frl; self.fragment_types = frt; self.fragment_charges = frc; self.fragment_multiplicities = frm. # Attach methods to qcdb.Molecule class; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol = _parker_xyz2mol_yo. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.6;  · . PSI4. Module code; psi4.driver.qcdb.molecule. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:67138,Validat,ValidationError,67138,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,shell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:32789,Validat,ValidationError,32789,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_completion,; run_mirror=do_mirror,; verbose=verbose). compare_integers(; True, np.allclose(solution.shift, perturbation.shift, atol=6), 'shifts equiv', verbose=verbose - 1); if not do_resort:; compare_integers(; True,; np.allclose(solution.rotation.T, perturbation.rotation),; 'rotations transpose',; verbose=verbose - 1); if solution.mirror:; compare_integers(True, do_mirror, 'mirror allowed', verbose=verbose - 1). def set_fragment_pattern(self, frl, frt, frc, frm):; """"""Set fragment member data through public method analogous to psi4.core.Molecule"""""". if not (len(frl) == len(frt) == len(frc) == len(frm)):; raise ValidationError(""""""Molecule::set_fragment_pattern: fragment arguments not of same length.""""""). self.fragments = frl; self.fragment_types = frt; self.fragment_charges = frc; self.fragment_multiplicities = frm. # Attach methods to qcdb.Molecule class; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol = _parker_xyz2mol_yo. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.qcdb.molecule. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/qcdb/molecule.html:67221,Validat,ValidationError,67221,psi4manual/master/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"si4 global options from an input dictionary. success(label); Function to print a ‘label...PASSED’ line to screen. xml2dict([filename]); Read XML filename into nested OrderedDict-s. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, maxit); Error called for problems with converging and iterative method. Dftd3Error(msg). EmpericalDispersion(alias, dtype, **kwargs). ManagedMethodError(circs). ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶; digraph inheritancee3b8ec5824 {; rankdir=LR;; size=""8.0, 12.0"";; ""CSXError"" [fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",tooltip=""Error called when CSX generation fails.""];; ""PsiException"" -> ""CSXError"" [arrowsize=0.5,style=""setlinewidth(0.5)""];; ""ConvergenceError"" [fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",tooltip=""Error called for problems with converging and iterative method. Prints""];; ""PsiException"" -> ""ConvergenceError"" [arrowsize=0.5,style=""setlinewidth(0.5)""];; ""Dftd3Error"" [fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)""];; ""PsiException"" -> ""Dftd3Error"" [arrowsize=0.5,style=""setlinewidth(0.5)""];; ""EmpericalDispersion"" [fontname=""Vera Sans, DejaVu S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:201718,Validat,ValidationError,201718,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['Validat'],['ValidationError']
Security,si4.core.DFSOMCSCF method. psi4.core.DiskSOMCSCF method. psi4.core.SOMCSCF method. update_density() psi4.core.ERI method. psi4.core.TwoBodyAOInt method. psi4.core.TwoElectronInt method. update_forward_refs() psi4.driver.AtomicComputer class method. update_geometry() psi4.core.Molecule method. update_orbitals() psi4.core.IntegralTransform method. UpgradeHelper. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. v2rdm_casscf. ; plugin. V_potential() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. Va() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. VAL_EX_LEVEL (DETCI). valid_methods psi4.core.OEProp attribute. validate() psi4.driver.AtomicComputer class method. validate_diis() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. validate_options() psi4.core.Options method. ValidationError. class in qcelemental. value psi4.core.DerivCalcType attribute. psi4.core.DiagonalizeOrder attribute. psi4.core.FragmentType attribute. psi4.core.GaussianType attribute. psi4.core.GeometryUnits attribute. psi4.core.PrimitiveType attribute. psi4.core.PsiReturnType attribute. psi4.core.SaveType attribute. value() psi4.core.SuperFunctional method. values() psi4.core.SuperFunctional method. variable() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. variables() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. Vb() psi4.core.CUHF method. psi4.core.HF method. ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:153486,Validat,ValidationError,153486,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['Validat'],['ValidationError']
Security,"si4.driver.procrouting.sapt import fisapt_proc. def scf_set_reference_local(name, is_dft=False):; """"""; Figures out the correct SCF reference to set locally; """""". optstash = p4util.OptionsState(['SCF_TYPE'], ['SCF', 'REFERENCE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Alter reference name if needed; user_ref = core.get_option('SCF', 'REFERENCE'). sup = build_superfunctional_from_dictionary(functionals[name], 1, 1, True)[0]; if sup.needs_xc() or is_dft:; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop, oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.basisset()); if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(wfn.molecule(),; ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:2412,Validat,Validations,2412,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,3,['Validat'],['Validations']
Security,"si4.get_memory(); Out[1]: 600000000L. >>> # [2] Passing memory value as string with units; >>> psi4.set_memory('30 GB'); >>> psi4.get_memory(); Out[2]: 30000000000L. :good examples:. 800000000 # 800000000; 2004088624.9 # 2004088624; 1.0e9 # 1000000000; '600 mb' # 600000000; '600.0 MiB' # 629145600; '.6 Gb' # 600000000; ' 100000000kB ' # 100000000000; '2 eb' # 2000000000000000000. :bad examples:. {} # odd type; '' # no info; ""8 dimms"" # unacceptable units; ""1e5 gb"" # string w/ exponent; ""5e5"" # string w/o units; 2000 # mem too small; -5e5 # negative (and too small). """"""; # Handle memory given in bytes directly (int or float); if isinstance(inputval, (int, float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(""""""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more."""""".format(; memory_amount / 1024 ** 2, memory_amount / 1000 ** 2)). if execute:; core.set_memory_bytes(memory_amount); return memory_amount. [docs]def get_memory():; """"""Function to retur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html:4609,Validat,ValidationError,4609,psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security,"siMod.set_variable('MP2C MONOMER A MP2 ENERGY', e_monomerA_mp2); PsiMod.set_variable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = PsiMod.sapt(). optstash.restore(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; PsiMod.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (PsiMod.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; #molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; #molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); if (sapt_basis == 'dimer'):; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:46789,Validat,ValidationError,46789,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"sible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # distribute benchmark; if mbenchmark is None:; lbenchmark = [benchmark] * len(modelchem) # normal bm modelchem name; else:; if isinstance(mbenchmark, basestring) or len(mbenchmark) != len(modelchem):; raise ValidationError(; """"""mbenchmark must be array of length distributable among modelchem"""""" % (str(mbenchmark))); else:; lbenchmark = mbenchmark # array of bm for each modelchem; # distribute sset; if msset is None:; lsset = [sset] * len(modelchem) # normal ss name like 'MX'; else:; if isinstance(msset, basestring) or len(msset) != len(modelchem):; raise ValidationError(""""""msset must be array of length distributable among modelchem"""""" % (str(msset))); else:; lsset = msset # array of ss for each modelchem; # compute errors; index = []; errors = {}; indiv = {}; for mc, bm, ss in zip(modelchem, lbenchmark, lsset):; ix = '%s_%s_%s' % (ss, mc, bm); index.append(ix); errors[ix], indiv[ix] = self.compute_statistics(mc, benchmark=bm, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); for rxn in odb.hrxn:; data = []; for ix in index:; if indiv[ix][db] is not None:; if rxn in odb.sset[self.sset[lsset[index.index(ix)]][dbix]]:; try:; data.append(indiv[ix][db][rxn][0]); except KeyError as e:; if failoninc:; raise e; else:; data.append(None); else:; data.append(None); else:; data.append(None); if not data",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:78179,Validat,ValidationError,78179,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,2,['Validat'],['ValidationError']
Security,"signs basis *name* to atom number *number* (1-indexed, includes dummies).""""""; raise FeatureNotImplemented('Molecule::set_basis_by_number') # FINAL. [docs] def set_basis_by_label(self, label, name, type=""BASIS""):; """""" **NYI** Assigns basis *name* to all atoms with *label*.""""""; raise FeatureNotImplemented('Molecule::set_basis_by_label') # FINAL. [docs] def nfrozen_core(self, depth=""SMALL""):; """"""Number of frozen core for molecule given freezing state. >>> print H2OH2O.nfrozen_core(); 2. """"""; if depth == False:; return 0. elif depth == True or depth.upper() == 'TRUE' or depth.upper() == 'SMALL':; nfzc = 0; for A in range(self.natom()):; if self.Z(A) > 2 and self.Z(A) <= 10:; nfzc += 1; elif self.Z(A) > 10:; nfzc += 2; return nfzc. elif depth.upper() == 'FALSE':; return 0. elif depth.upper() == 'LARGE':; nfzc = 0; for A in range(self.natom()):; if self.Z(A) > 2 and self.Z(A) <= 10:; nfzc += 1; elif self.Z(A) > 10:; nfzc += 5; return nfzc. else:; raise ValidationError(""Frozen core '%s' is not supported, options are {true, false, small, large}."" % (depth)). # <<< Involved Methods for Frame >>>. [docs] def translate(self, r):; """"""Translates molecule by r. >>> H2OH2O.translate([1.0, 1.0, 0.0]). """"""; temp = [None, None, None]; for at in range(self.nallatom()):; temp = scale(self.full_atoms[at].compute(), self.input_units_to_au); temp = add(temp, r); temp = scale(temp, 1.0 / self.input_units_to_au); self.full_atoms[at].set_coordinates(temp[0], temp[1], temp[2]). [docs] def center_of_mass(self):; """"""Computes center of mass of molecule (does not translate molecule). >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_m = 0.0. for at in range(self.natom()):; m = self.mass(at); ret = add(ret, scale(self.xyz(at), m)); total_m += m. ret = scale(ret, 1.0 / total_m); return ret. [docs] def move_to_com(self):; """"""Moves molecule to center of mass. """"""; com = scale(self.center_of_mass(), -1.0); self.translate(com). [docs] de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:46724,Validat,ValidationError,46724,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,2,['Validat'],['ValidationError']
Security,"sion_info[0] > 2) and isinstance(filename, str):; if not filename.endswith('.npz'):; filename = filename + '.npz'. data = np.load(filename); else:; raise Exception(""Filename not understood: %s"" % filename). ret_data = []. if ((prefix + ""Irreps"") not in data.keys()) or ((prefix + ""Name"") not in data.keys()):; raise ValidationError(""File %s does not appear to be a numpyz save"" % filename). for h in range(data[prefix + ""Irreps""]):; ret_data.append(data[prefix + ""IrrepData"" + str(h)]). arr_type = self.__mro__[0]; if arr_type == core.Matrix:; dim1 = core.Dimension.from_list(data[prefix + ""Dim1""]); dim2 = core.Dimension.from_list(data[prefix + ""Dim2""]); ret = self(str(data[prefix + ""Name""]), dim1, dim2); elif arr_type == core.Vector:; dim1 = core.Dimension.from_list(data[prefix + ""Dim""]); ret = self(str(data[prefix + ""Name""]), dim1). for h in range(data[prefix + ""Irreps""]):; ret.nph[h][:] = ret_data[h]. return ret. def _to_serial(data):; """"""; Converts an object with a .nph accessor to a serialized dictionary; """""". json_data = {}; json_data[""shape""] = []; json_data[""data""] = []. for view in data.nph:; json_data[""shape""].append(view.shape); json_data[""data""].append(view.tostring()). if len(json_data[""shape""][0]) == 1:; json_data[""type""] = ""vector""; elif len(json_data[""shape""][0]) == 2:; json_data[""type""] = ""matrix""; else:; raise ValidationError(""_to_json is only used for vector and matrix objects.""). return json_data. def _from_serial(self, json_data):; """"""; Converts serialized data to the correct Psi4 data type; """""". if json_data[""type""] == ""vector"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); ret = self(""Vector from JSON"", dim1); elif json_data[""type""] == ""matrix"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); dim2 = core.Dimension.from_list([x[1] for x in json_data[""shape""]]); ret = self(""Matrix from JSON"", dim1, dim2); else:; raise ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""]))",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:11109,access,accessor,11109,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,2,['access'],['accessor']
Security,"sis %s\n' % (psi4.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(psi4.MintsHelper().basisset().has_puream()). # Handle psi4 keywords implying cfour keyword values; if psi4.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = qcdb.options.reconcile_options(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = qcdb.options.prepare_options_for_cfour(userkw). # Handle text to be passed untouched to cfour; litcmd = psi4.get_global_option('LITERAL_CFOUR'). # Assemble ZMAT pieces; zmat = memcmd + molcmd + optcmd + mdccmd + psicmd + bascmd + litcmd. if len(re.findall(r'^\*(ACES2|CFOUR|CRAPS)\(', zmat, re.MULTILINE)) != 1:; psi4.print_out('\n Faulty ZMAT constructed:\n%s' % (zmat)); raise ValidationError(""""""; Multiple *CFOUR(...) blocks in input. This usually arises; because molecule or options are specified both the psi4 way through; molecule {...} and set ... and the cfour way through cfour {...}.""""""). return zmat. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:16514,Validat,ValidationError,16514,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html,1,['Validat'],['ValidationError']
Security,"sis set specification: assign lines present but shells have no [basname] label.""; """"); raise TestComparisonError(message); else:; # case with specs separated by [basname] markers; for idx in range(0, len(basblock), 2):; basstrings[_basname(basblock[idx])] = basblock[idx + 1]. return basstrings. anon.__name__ = 'basisspec_psi4_yo__' + cleanbas; qcdb.libmintsbasisset.basishorde[name.upper()] = anon; if set_option:; core.set_global_option(key, name). core.OEProp.valid_methods = [; 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES',; 'MBIS_CHARGES','MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS'; ]. ## Option helpers. def _core_set_global_option_python(key, EXTERN):; """"""; This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul.; """"""; if (key != ""EXTERN""):; raise ValidationError(""Options: set_global_option_python does not recognize keyword %s"" % key). if EXTERN is None:; core.EXTERN = None; core.set_global_option(""EXTERN"", False); elif isinstance(EXTERN, core.ExternalPotential):; # Well this is probably the worst hack I have done, thats saying something; core.EXTERN = EXTERN; core.set_global_option(""EXTERN"", True); else:; raise ValidationError(""Options: set_global_option_python can either be a NULL or External Potential object""). core.set_global_option_python = _core_set_global_option_python. ## QCvar helps. _qcvar_transitions = {; # old: (replacement, release after next); ""SCSN-MP2 CORRELATION ENERGY"": (""SCS(N)-MP2 CORRELATION ENERGY"", 1.5),; ""SCSN-MP2 TOTAL ENERGY"": (""SCS(N)-MP2 TOTAL ENERGY"", 1.5),; ""MAYER_INDICES"": (""MAYER INDICES"", 1.5),; ""WIBERG_LOWDIN_INDICES"": (""WIBERG LOWDIN INDICES"", 1.5),; ""LOWDIN_CHARGES"": (""LOWDIN CHARGES"", 1.5),; ""MULLIKEN_CHARGES"": (""MULLIKEN CHARGES"", 1.5),; ""(AT) CORRECTION ENERGY"": (""A-(T) CORRECTION ENERGY"", 1.5),; ""CCSD(AT) TOTAL ENER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:22694,Validat,ValidationError,22694,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['Validat'],['ValidationError']
Security,"sis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The Psithon function psi4.driver.p4util.Table has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below:; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2). rows = []; table = []. set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]). import pandas as pd; df = pd.DataFrame(table, columns = [""E(S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psithoninput.html:11547,access,access,11547,psi4manual/1.7.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psithoninput.html,3,['access'],['access']
Security,"sis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we fir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:11547,access,access,11547,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,7,['access'],['access']
Security,"small; result = [1.0, 0.0, 0.0]; return result; else:; # choose a vector perpendicular to d; # choose it in one of the planes xy, xz, yz; # choose the plane to be that which contains the two largest components of d; absd = [math.fabs(d[0]), math.fabs(d[1]), math.fabs(d[2])]; if (absd[1] - absd[0]) > 1.0e-12:; #if absd[0] < absd[1]:; axis0 = 1; if (absd[2] - absd[0]) > 1.0e-12:; #if absd[0] < absd[2]:; axis1 = 2; else:; axis1 = 0; else:; axis0 = 0; if (absd[2] - absd[1]) > 1.0e-12:; #if absd[1] < absd[2]:; axis1 = 2; else:; axis1 = 1; result = [0.0, 0.0, 0.0]; # do the pi/2 rotation in the plane; result[axis0] = d[axis1]; result[axis1] = -1.0 * d[axis0]; result = normalize(result); return result. else:; # normalize the cross product and return the result; result = scale(result, 1.0 / math.sqrt(resultdotresult)); return result. [docs]def determinant(mat):; """"""Given 3x3 matrix *mat*, compute the determinat. """"""; if len(mat) != 3 or len(mat[0]) != 3 or len(mat[1]) != 3 or len(mat[2]) != 3:; raise ValidationError('determinant() only defined for arrays of dimension 3x3\n'). det = mat[0][0] * mat[1][1] * mat[2][2] - mat[0][2] * mat[1][1] * mat[2][0] + \; mat[0][1] * mat[1][2] * mat[2][0] - mat[0][1] * mat[1][0] * mat[2][2] + \; mat[0][2] * mat[1][0] * mat[2][1] - mat[0][0] * mat[1][2] * mat[2][1]; return det. [docs]def diagonalize3x3symmat(A):; """"""Given an real symmetric 3x3 matrix A, compute the eigenvalues. """"""; if len(A) != 3 or len(A[0]) != 3 or len(A[1]) != 3 or len(A[2]) != 3:; raise ValidationError('diagonalize3x3symmat() only defined for arrays of dimension 3x3\n'). B = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] # I is the identity matrix; p = A[0][1] * A[0][1] + A[0][2] * A[0][2] + A[1][2] * A[1][2]; if p == 0:; # A is diagonal; eig1 = A[0][0]; eig2 = A[1][1]; eig3 = A[2][2]; else:; q = (A[0][0] + A[1][1] + A[2][2]) / 3.0; p = (A[0][0] - q) ** 2 + (A[1][1] - q) ** 2 + (A[2][2] - q) ** 2 + 2.0 * p; p = math.sqrt(p / 6.0); for i in range(3):; for j in range(3):; B[i][j] = (A[",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/vecutil.html:3967,Validat,ValidationError,3967,psi4manual/4.0b3/_modules/qcdb/vecutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/vecutil.html,2,['Validat'],['ValidationError']
Security,"small; result = [1.0, 0.0, 0.0]; return result; else:; # choose a vector perpendicular to d; # choose it in one of the planes xy, xz, yz; # choose the plane to be that which contains the two largest components of d; absd = [math.fabs(d[0]), math.fabs(d[1]), math.fabs(d[2])]; if (absd[1] - absd[0]) > 1.0e-12:; #if absd[0] < absd[1]:; axis0 = 1; if (absd[2] - absd[0]) > 1.0e-12:; #if absd[0] < absd[2]:; axis1 = 2; else:; axis1 = 0; else:; axis0 = 0; if (absd[2] - absd[1]) > 1.0e-12:; #if absd[1] < absd[2]:; axis1 = 2; else:; axis1 = 1; result = [0.0, 0.0, 0.0]; # do the pi/2 rotation in the plane; result[axis0] = d[axis1]; result[axis1] = -1.0 * d[axis0]; result = normalize(result); return result. else:; # normalize the cross product and return the result; result = scale(result, 1.0 / math.sqrt(resultdotresult)); return result. [docs]def determinant(mat):; """"""Given 3x3 matrix *mat*, compute the determinat. """"""; if len(mat) != 3 or len(mat[0]) != 3 or len(mat[1]) != 3 or len(mat[2]) != 3:; raise ValidationError('determinant() only defined for arrays of dimension 3x3\n'). det = mat[0][0] * mat[1][1] * mat[2][2] - mat[0][2] * mat[1][1] * mat[2][0] + \; mat[0][1] * mat[1][2] * mat[2][0] - mat[0][1] * mat[1][0] * mat[2][2] + \; mat[0][2] * mat[1][0] * mat[2][1] - mat[0][0] * mat[1][2] * mat[2][1]; return det. [docs]def diagonalize3x3symmat(M):; """"""Given an real symmetric 3x3 matrix *M*, compute the eigenvalues. """"""; if len(M) != 3 or len(M[0]) != 3 or len(M[1]) != 3 or len(M[2]) != 3:; raise ValidationError('diagonalize3x3symmat() only defined for arrays of dimension 3x3\n'). A = copy.deepcopy(M) # Symmetric input matrix; Q = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] # Storage buffer for eigenvectors; w = [A[0][0], A[1][1], A[2][2]] # Storage buffer for eigenvalues; # sd, so # Sums of diagonal resp. off-diagonal elements; # s, c, t # sin(phi), cos(phi), tan(phi) and temporary storage; # g, h, z, theta # More temporary storage. # Calculate SQR(tr(A)); sd = 0.0; for i in range(3):; s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html:5115,Validat,ValidationError,5115,psi4manual/1.0.0/_modules/qcdb/vecutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html,2,['Validat'],['ValidationError']
Security,"source]¶; Generate pieces for inclusion into tables. Supply list of; modelchemistries to plot from modelchem, otherwise defaults to; all those available. Can modify subset sset and plotting; range xlimit.; >>> asdf.plot_all_flats(sset='tt-5min', xlimit=4.0). plot_axis(axis, modelchem, benchmark='default', sset='default', failoninc=True, verbose=False, color='sapt', view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶. plot_bars(modelchem, benchmark='default', sset=['default', 'hb', 'mx', 'dd'], failoninc=True, verbose=False, view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Prepares ‘grey bars’ diagram for each model chemistry in array; modelchem versus benchmark over all component databases. A wide bar; is plotted with three smaller bars, corresponding to the ‘mae’; summary statistic of the four subsets in sset.; saveas conveys directory (‘/’) and/or filename for saving the; resulting plot. File extension is not accessible, but graphicsformat; array requests among ‘png’, ‘pdf’, and ‘eps’ formats. relpath; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary.; Prepares bars diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames.; >>> asdf.plot_bars(['MP2-CP-adz', 'MP2-CP-adtz'], sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']). plot_disthist(modelchem, benchmark='default', sset='default', failoninc=True, verbose=False, xtitle='', view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Computes individual errors and summary statistics for single; model chemistry modelchem versus benchmark over; subset sset over all component databases. Computes histogram; of errors and gaussian distribution.; saveas conveys directory (‘/’) and/or filename for saving the; resulting plot. File extension is not accessible, but graphicsformat; array ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:35029,access,accessible,35029,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['access'],['accessible']
Security,"sponding to `compute_list`.; task_list: List[AtomicComputer] = []. # One-to-One list of QCSchema corresponding to `task_list`.; results_list: List[Any] = []. [docs] @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; data = p4util.kwargs_lower(data); data[""metadata""] = _process_cbs_kwargs(data); BaseComputer.__init__(self, **data). self.metameta = {; 'kwargs': data,; 'ptype': self.driver,; 'verbose': self.verbose,; 'label': None,; 'molecule': self.molecule,; }; # logger.debug(""METAMETA\n"" + pp.pformat(self.metameta)). if data['metadata']:; if data['metadata'][0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in driver_cbs.py to proceed."""""" %; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested lesser {delta[""treament""]} method '{delta[""wfn_lo""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ). self.cbsrec, self.compute_list, self.trove = _build_cbs_compute(self.metameta, self.metadata). for job in self.compute_list:; keywords = copy.deepcopy(self.metameta['kwargs']['keywords']); if job[""f_options""] is not False:; stage_keywords = dict(job[""f_options""].items()); keywords = {**keywords, **stage_keywords}; task = AtomicComputer(; **{; ""molecule"": self.molecule,; ""driver"": self.driver,; ""method"": job[""f_wfn""],; ""basis"": job[""f_basis""],; ""keywords"": keywords or {},; }); self.task_list.append(task). # logger.debug(""TASK\n"" + pp.pformat(task.dict())). [docs] def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs] def plan(self):; # uncalled functio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:54334,Validat,ValidationError,54334,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"sponse_properties = ['polarizability', 'rotation', 'roa']; excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs.pop('properties'); properties = p4util.drop_duplicates(properties). for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""The \""properties\"" keyword is required with the property() function.""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if (n_invalid > 0):; print(""The following properties are not currently supported: %s"" % invalid). if (n_excited > 0 and (name.lower() != 'eom-ccsd' and name.lower() != 'eom-cc2')):; raise ValidationError(""Excited state CC properties require EOM-CC2 or EOM-CCSD.""). if ((name.lower() == 'eom-ccsd' or name.lower() == 'eom-cc2') and n_response > 0):; raise ValidationError(""Cannot (yet) compute response properties for excited states.""). if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""Computing both density- and response-based properties.""). if (name.lower() == 'ccsd'):; psi4.set_global_option('WFN', 'CCSD'); run_ccenergy('ccsd', **kwargs); psi4.set_global_option('WFN', 'CCSD'); elif (name.lower() == 'cc2'):; psi4.set_global_option('WFN', 'CC2'); run_ccenergy('cc2', **kwargs); psi4.set_global_option('WFN', 'CC2'); elif (name.lower() == 'eom-ccsd'):; psi4.set_global_option('WFN', 'EOM_CCSD'); run_ccenergy('eom-ccsd', **kwargs); psi4.set_global_option('WFN', 'EOM_CCSD'); elif (name.lower() == 'eom-cc2'):; psi4.set_global_option('WFN', 'EOM_CC2'); run_ccenergy('eom-cc2', **kwargs); psi4.set_global_option('WFN', 'EOM_CC2'). # Need cchbar for everything; psi4.cchbar(). # Need ccdensity at th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:29682,Validat,ValidationError,29682,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"sscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionnam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:85146,Validat,ValidationError,85146,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,"ssing term in \(E^{(30)}_{ind}\) was added, causing; possible discrepancies with prior versions of the code on the order of; 0.01 kcal/mol. See https://github.com/psi4/psi4/issues/1677. Caution; August 2021, the number of frozen core orbitals used in the dMP2 computations; is now standardized. Specifically, we now rigorously enforce that the number of core orbitals; frozen in dimer computations is equal to the sum of frozen orbitals of each monomer. Prior to; this, a discrepency between these values was possible when one of the monomers was (exclusively); a charged alkali metal. Caution; May 2022 c. v1.6, the default for DF_BASIS_ELST; changed from the value of DF_BASIS_SAPT (which itself; defaults to the RI of the orbital basis) to the JKFIT of the orbital; basis. This affects SAPT0 and sSAPT0 computed with the SAPT; module (the default code for energy(""sapt0"") that; can also compute higher-order SAPT). Electostatics, exchange,; and induction terms for SAPT0 and sSAPT0 accessed through; energy(""sapt0"") or energy(""ssapt0"") change; the dispersion; term does not change. The SAPT0 and sSAPT0 terms accessed as; subsidiary calculations of higher-order SAPT do not change; that is,; the SAPT module breaks the consistency of its SAPT0; results. The reasoning and reward behind this change is that the JKFIT; basis better describes the physics (see fitting changes ) and the; default SAPT0 results from the SAPT module are now; consistent with those from the FISAPT module and; the sapt(dft) module. See sapt-compare for an example.; To reproduce former behavior, set DF_BASIS_ELST to the; orbital basis set’s RI auxiliary basis. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sapt.html:2355,access,accessed,2355,psi4manual/master/sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/sapt.html,5,['access'],['accessed']
Security,"st users will ever; need to access directly to perform frequency calculations. Behind; the scenes, frequency() is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. psi4.frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/freq.html:1592,access,accessed,1592,psi4manual/master/freq.html,https://psicode.org,https://psicode.org/psi4manual/master/freq.html,4,['access'],['accessed']
Security,"st"": {; ""title"": ""Task List"",; ""default"": {},; ""type"": ""object"",; ""additionalProperties"": {; ""$ref"": ""#/definitions/BaseComputer""; }; },; ""findifrec"": {; ""title"": ""Findifrec"",; ""default"": {},; ""type"": ""object""; },; ""method"": {; ""title"": ""Method"",; ""type"": ""string""; }; },; ""required"": [; ""driver"",; ""method""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""BaseComputer"": {; ""title"": ""BaseComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {}; }; }; }. Fields:. driver (qcelemental.models.common_models.DriverEnum); findifrec (Dict[str, Any]); metameta (Dict[str, Any]); method (str); molecule (Any); task_list (Dict[str, psi4.driver.task_base.BaseComputer]). Validators:. set_driver » driver; set_molecule » molecule. field driver: DriverEnum [Required]¶. Validated by:. set_driver. field findifrec: Dict[str, Any] = {}¶. field metameta: Dict[str, Any] = {}¶. field method: str [Required]¶. field molecule: Any = None¶. Validated by:. set_molecule. field task_list: Dict[str, BaseComputer] = {}¶. computer¶; alias of AtomicComputer. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶; Run each job in task list. Parameters:; client (Optional[FractalClient]) – . get_psi_results(return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:; return_wfn (bool) – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. Return type:; Union[float, Matrix, Tuple[Union[float, Matrix], Wavefunction]]. Returns:. ret – Gradient or He",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/freq.html:9383,Validat,Validated,9383,psi4manual/1.7.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/freq.html,1,['Validat'],['Validated']
Security,"st"": {; ""title"": ""Task List"",; ""default"": {},; ""type"": ""object"",; ""additionalProperties"": {; ""$ref"": ""#/definitions/BaseComputer""; }; },; ""findifrec"": {; ""title"": ""Findifrec"",; ""default"": {},; ""type"": ""object""; },; ""method"": {; ""title"": ""Method"",; ""type"": ""string""; }; },; ""required"": [; ""driver"",; ""method""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""BaseComputer"": {; ""title"": ""BaseComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {}; }; }; }. Fields:. driver (qcelemental.models.common_models.DriverEnum); findifrec (Dict[str, Any]); metameta (Dict[str, Any]); method (str); molecule (Any); task_list (Dict[str, psi4.driver.task_base.BaseComputer]). Validators:. set_driver » driver; set_molecule » molecule. field driver: DriverEnum [Required]¶. Validated by:. set_driver. field findifrec: Dict[str, Any] = {}¶. field metameta: Dict[str, Any] = {}¶. field method: str [Required]¶. field molecule: Any = None¶. Validated by:. set_molecule. field task_list: Dict[str, BaseComputer] = {}¶. computer¶; alias of AtomicComputer. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶; Run each job in task list. Parameters:; client (qcportal.FractalClient | None) – . get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. client (qcportal.FractalClient | None) – . Returns:. ret – Gradient or Hessian according to se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/freq.html:9385,Validat,Validated,9385,psi4manual/1.8.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/freq.html,2,['Validat'],['Validated']
Security,"st"": {; ""title"": ""Task List"",; ""default"": {},; ""type"": ""object"",; ""additionalProperties"": {; ""$ref"": ""#/definitions/BaseComputer""; }; },; ""findifrec"": {; ""title"": ""Findifrec"",; ""default"": {},; ""type"": ""object""; },; ""method"": {; ""title"": ""Method"",; ""type"": ""string""; }; },; ""required"": [; ""driver"",; ""method""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""BaseComputer"": {; ""title"": ""BaseComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {}; }; }; }. Fields:. driver (qcelemental.models.common_models.DriverEnum); findifrec (Dict[str, Any]); metameta (Dict[str, Any]); method (str); molecule (Any); task_list (Dict[str, psi4.driver.task_base.BaseComputer]). Validators:. set_driver » driver; set_molecule » molecule. field driver: DriverEnum [Required]¶. Validated by:. set_driver. field findifrec: Dict[str, Any] = {}¶. field metameta: Dict[str, Any] = {}¶. field method: str [Required]¶. field molecule: Any = None¶. Validated by:. set_molecule. field task_list: Dict[str, BaseComputer] = {}¶. computer¶; alias of AtomicComputer. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶; Run each job in task list. Parameters:; client (qcportal.FractalClient | None). get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. client (qcportal.FractalClient | None). Returns:. ret – Gradient or Hessian according to self.dri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/freq.html:9392,Validat,Validated,9392,psi4manual/master/freq.html,https://psicode.org,https://psicode.org/psi4manual/master/freq.html,1,['Validat'],['Validated']
Security,"st, basis_list)`` format, where ``method_list``; is the list of the component methods, and ``basis_list`` is the list of; basis sets forming the extrapolation for each specified method.; E.g. ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""`` would return:; ``([""mp2"", ""ccsd(t)""], [""cc-pv[tq]z"", ""cc-pvtz""])``.; """""". method_name_list = re.split(""""""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; A text based wrapper of the CBS function. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; func : function; Function to be called (energy, gradient, frequency or cbs).; total_method_name : str; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; tuple or float; Float, or if ``return_wfn`` is specified, a tuple of ``(value, wavefunction)``.; """""". # Catch kwarg issues ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:62673,Validat,ValidationError,62673,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"stack” (e.g., libint, gdma) should already be updated and; built on conda-forge. Survey them to check version tick PRs have been merged.; Conda-forge overwhelmingly handles the psi4 package itself, with a full architecture and Python; version matrix. What remains are specialty or development builds for the psi4 channel. High AM and multiarch psi4 builds for Linux. Especially at tagged releases, update and reconcile c-f psi4/feedstock recipe with psinet; psi4meta/conda-recipes/psi4-cf recipe. Differences include:. restricted to only even python versions; c-f libint vs. psi4 libint2 packages (latter with high AM); smoke vs. full tests; no git rev-parse lines; load Intel compilers and specify them in compilers and flags CMake arguments. Prepare recipe, make sure psi4-cf is the only target uncommented in kitandkapoodle.py, set; crontab, view in kpd-anom.log.; Files will upload to psi4/label/dev. For releases and postreleases, on the anaconda.org site; (logged in as psi4), add, not replace, main label, so accessible from psi4/label/main. Build Psi4conda set¶; Installers are build using the project constructor to build binary bash or exe scripts, one per; OS per Python version. For example, there’s 16 installers when OSes are linux-64, win-64, osx-64,; osx-arm64 and pythons are 38, 39, 310, 311. In analogy to Miniconda, they’re called Psi4Conda. They; are built through GHA on the https://github.com/psi4/psi4meta repository and get served from vergil; (the cdsgroup webserver). If the previous release hasn’t had a snapshot saved, copy construct.yaml into a version-labeled; file and check it in.; Edit recipe https://github.com/psi4/psi4meta/blob/master/installers/construct.yaml. Edit the top matter for Configuration, mainly the release field. See snapshots in directory for examples.; Edit the packages and channels info if necessary. Probably long-term stable. Edit the GHA control file https://github.com/psi4/psi4meta/blob/master/.github/workflows/Installers.yml; matrix.cfg l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/manage_release.html:14191,access,accessible,14191,psi4manual/master/manage_release.html,https://psicode.org,https://psicode.org/psi4manual/master/manage_release.html,2,['access'],['accessible']
Security,"stance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; PsiMod.print_out(instructions). # write sow/reap instructions",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:36096,Validat,ValidationError,36096,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"start = core.get_option('SCF', 'DIIS_START'); if start < 1:; raise ValidationError('SCF DIIS_START ({}) must be at least 1'.format(start)). minvecs = core.get_option('SCF', 'DIIS_MIN_VECS'); if minvecs < 1:; raise ValidationError('SCF DIIS_MIN_VECS ({}) must be at least 1'.format(minvecs)). maxvecs = core.get_option('SCF', 'DIIS_MAX_VECS'); if maxvecs < minvecs:; raise ValidationError(; 'SCF DIIS_MAX_VECS ({}) must be at least DIIS_MIN_VECS ({})'.format(maxvecs, minvecs)). return enabled. def _validate_frac():; """"""Sanity-checks FRAC control options. Raises; ------; ValidationError; If any of |scf__frac_start| don't play well together. Returns; -------; bool; Whether FRAC is enabled during scf. """"""; enabled = (core.get_option('SCF', 'FRAC_START') != 0); if enabled:; if enabled < 0:; raise ValidationError('SCF FRAC_START ({}) must be at least 1'.format(enabled)). return enabled. def _validate_MOM():; """"""Sanity-checks MOM control options. Raises; ------; ValidationError; If any of |scf__mom_start|, |scf__mom_occ| don't play well together. Returns; -------; bool; Whether excited-state MOM (not just the plain stabilizing MOM) is enabled during scf. """"""; enabled = (core.get_option('SCF', ""MOM_START"") != 0 and len(core.get_option('SCF', ""MOM_OCC"")) > 0); if enabled:; start = core.get_option('SCF', ""MOM_START""); if enabled < 0:; raise ValidationError('SCF MOM_START ({}) must be at least 1'.format(start)). return enabled. def _validate_soscf():; """"""Sanity-checks SOSCF control options. Raises; ------; ValidationError; If any of |scf__soscf|, |scf__soscf_start_convergence|,; |scf__soscf_min_iter|, |scf__soscf_max_iter| don't play well together. Returns; -------; bool; Whether SOSCF is enabled during scf. """"""; enabled = core.get_option('SCF', 'SOSCF'); if enabled:; start = core.get_option('SCF', 'SOSCF_START_CONVERGENCE'); if start < 0.0:; raise ValidationError('SCF SOSCF_START_CONVERGENCE ({}) must be positive'.format(start)). miniter = core.get_option('SCF', 'SOSCF_MIN_ITER')",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:24834,Validat,ValidationError,24834,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security,"stash.restore(). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # call thermo module; PsiMod.thermo(). optstash.restore(); return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequencies(name, **kwargs). [docs]def molden(filename):; """"""Function to write wavefunction information in molden; format to *filename*. """"""; m = PsiMod.MoldenWriter(PsiMod.wavefunction()); m.write(filename). [docs]def parse_cotton_irreps(irrep):; r""""""Function to return validated Cotton ordering index from string or integer; irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2v': {; 'a1': 1,; 'a2': 2,; 'b1': 3,; 'b2': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2h': {; 'ag': 1,; 'bg': 2,; 'au': 3,; 'bu': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; },; 'd2h': {; 'ag': 1,; 'b1g': 2,; 'b2g': 3,; 'b3g': 4,; 'au': 5,; 'b1u': 6,; 'b2u': 7,; 'b3u': 8,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; '5': 5,; '6': 6,; '7': 7,; '8': 8; }; }. point_group = PsiMod.get_active_molecule().schoenflies_symbol().lower(); irreducible_representation = str(irrep).lower(). try:; return cotton[point_group][irreducible_representation]; except KeyError:; raise ValidationError(""Irrep \'%s\' not valid for point group \'%s\'."" % (str(irrep), point_group)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta4] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:68989,Validat,ValidationError,68989,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"stash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO']). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if psi4.has_option_changed('SCF', 'BASIS_GUESS'):; cast = psi4.get_option('SCF', 'BASIS_GUESS'); if yes.match(str(cast)):; cast = True; elif no.match(str(cast)):; cast = False. if psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; castdf = True; else:; castdf = False. if psi4.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = psi4.get_option('SCF', 'DF_BASIS_GUESS'); if yes.match(str(castdf)):; castdf = True; elif no.match(str(castdf)):; castdf = False. # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; molecule = psi4.get_active_molecule(); multp = molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if psi4.get_option('SCF','REFERENCE') != 'UHF' and psi4.get_option('SCF','REFERENCE') != 'UKS':; raise ValidationError('You must specify ""set reference uhf"" to use broken symmetry.'); do_broken = True; else:; do_broken = False. precallback = None; if 'precallback' in kwargs:; precallback = kwargs.pop('precallback'). postcallback = None; if 'postcallback' in kwargs:; postcallback = kwargs.pop('postcallback'). # Hack to ensure cartesian or pure are used throughout; # Note that can't query PUREAM option directly, as it only; # reflects user changes to value, so load basis and; # read effective PUREAM setting off of it; psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')); psi4.set_global_option('PUREAM', psi4.MintsHelper().basisset().has_puream()). # broken set-up; if do_broken:; molecule.set_multiplicity(3); psi4.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); psi4.print_out('\n'). # cast set-up; if (cast):. if yes.match(str(cast)):; guessbasis = '3-21G'; else:; guessbasis = cast. if (castdf):; if yes.match(str(castdf)):; guessbasisdf = p4util.corresponding_jkfit(guess",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:17818,Validat,ValidationError,17818,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"ster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. PsiMod.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). PsiMod.print_out(""\n""); banner(""CP Computation: Results.""); PsiMod.print_out(""\n""). banner(""Hartree"", 2); PsiMod.print_out(""\n""). PsiMod.print_out(str(cp_table)). PsiMod.print_out(""\n""); banner(""kcal*mol^-1"", 2); PsiMod.print_out(""\n""). cp_table.scale(). PsiMod.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:22636,access,access,22636,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['access'],['access']
Security,"ston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions used by several Python functions."""""". __all__ = [; ""all_casings"",; ""drop_duplicates"",; ""expand_psivars"",; ""format_molecule_for_input"",; ""format_options_for_input"",; ""get_psifile"",; ""getattr_ignorecase"",; ""hold_options_state"",; ""import_ignorecase"",; ""kwargs_lower"",; ""mat2arr"",; ""prepare_options_for_modules"",; ""prepare_options_for_set_options"",; ""provenance_stamp"",; ""state_to_atomicinput"",; ]. import os; import ast; import sys; import math; import pickle; import inspect; import warnings; from contextlib import contextmanager; import collections; from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Union; from types import ModuleType. import numpy as np; from qcelemental.models import AtomicInput. from psi4 import core; from psi4.metadata import __version__; from .exceptions import ValidationError; from . import p4regex. [docs]; def kwargs_lower(kwargs: Dict[str, Any]) -> Dict[str, Any]:; """"""Function to rebuild and return *kwargs* dictionary sanitized. Should be; called by every function that could be called directly by the user. Parameters; ----------; kwargs; Input kwargs for any user-facing function. Returns; -------; lowered : Dict[str, Any]; Sanitized kwargs with all keys made lowercase. Also turns boolean-like; values into actual booleans. Also turns values lowercase if sensible. """"""; caseless_kwargs = {}; for key, value in kwargs.items():; lkey = key.lower(); if lkey in ['subset', 'banner', 'restart_file', 'write_orbitals']: # only kw for which case matters; lvalue = value; else:; try:; lvalue = value.lower(); except (AttributeError, KeyError):; lvalue = value. if lkey in ['irrep', 'check_bsse', 'linkage', 'bsse_type']:; caseless_kwargs[lkey] = lvalue. elif 'dertype' in lkey:; if p4regex.der0th.match(str(lvalue)):; caseless_kwargs[lkey] = 0; elif p4regex.der1st.match(str(lvalue)):; caseless_kwargs[lkey] = 1; elif p4regex.der2nd.match(str(lvalue)):; caseless_kw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:2127,sanitiz,sanitized,2127,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,1,['sanitiz'],['sanitized']
Security,"str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upper(),; _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; valueLO = np.array(valueLO); valueMD = np.array(valueMD); valueHI = np.array(valueHI). nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. # Build and set from numpy routines; value = core.Matrix(*valueHI.shape); value_view = np.asarray(value); value_view[:] = np_value; return value. else:; raise ValidationError(""scf_xtpl_helgaker_3: datatype is not recognized '%s'."" % type(valueLO)). #def corl_xtpl_helgaker_2(functionname, valueSCF, zLO, valueLO, zHI, valueHI, verbose=True):; [docs]def corl_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: float, zHI: int, valueHI: float, verbose: bool = True, alpha: float = None):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component.; zLO; Lower zeta level.; valueLO; Lower value used for extrapolation.; zHI; Higher zeta level. Should be equal to zLO + 1.; valueHI; Higher value used for extrapolation.; alpha; Overrides the default :math:`\alpha = 3.0`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [5]_:; :math:`E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}`. References; ----------. .. [5] Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson,; Ch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:19581,Validat,ValidationError,19581,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(PsiMod.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). PsiMod.dfmp2grad(); e_dfmp2 = PsiMod.get_variable('MP2 TOTAL ENERGY'); e_scs_dfmp2 = PsiMod.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-DFMP2') or (name.upper() == 'SCS-DF-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if (name.lower() == 'eom-ccsd'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); PsiMod.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); PsiMod.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); PsiMod.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); PsiMod.set_local_option('CCEOM',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:31770,Validat,ValidationError,31770,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(psi4.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). psi4.dfmp2grad(); e_dfmp2 = psi4.get_variable('MP2 TOTAL ENERGY'); e_scs_dfmp2 = psi4.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; lowername = name.lower(). optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if (lowername == 'ccsd'):; psi4.set_local_option('TRANSQT2', 'WFN', 'CCSD'); psi4.set_local_option('CCSORT', 'WFN', 'CCSD'); psi4.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif (lowername == 'ccsd(t)'):; psi4.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); psi4.set_local_option('CCSORT', 'WFN', 'CCSD_T'); psi4.set_local_option('CCENERGY', 'WFN', 'CCSD_T');",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:22825,Validat,ValidationError,22825,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"str)); cbsscheme += """"""% 16.12f\n\n"""""" % final; core.print_out(cbsscheme). return final. elif isinstance(valueLO, (core.Matrix, core.Vector)):. beta = valueHI.clone(); beta.subtract(valueLO); beta.scale(1 / (zHI ** (-3) - zLO ** (-3))); beta.name = 'Helgaker SCF (%s, %s) beta' % (zLO, zHI). value = valueHI.clone(); value.scale(zHI ** 3). tmp = valueLO.clone(); tmp.scale(zLO ** 3); value.subtract(tmp). value.scale(1 / (zHI ** 3 - zLO ** 3)); value.name = 'Helgaker Corr (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Helgaker 2-point correlated extrapolation for """"""; """"""method: %s <==\n\n"""""" % (functionname.upper())); core.print_out("""""" LO-zeta (%s) Data\n"""""" % (str(zLO))); valueLO.print_out(); core.print_out("""""" HI-zeta (%s) Data\n"""""" % (str(zHI))); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). # value.add(valueSCF); return value. else:; raise ValidationError(""corl_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). def return_energy_components():; VARH = {}; VARH['scf'] = {; 'scf': 'SCF TOTAL ENERGY'}; VARH['hf'] = {; 'hf': 'HF TOTAL ENERGY'}; VARH['mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY',; 'mp4': 'MP4(SDTQ) TOTAL ENERGY'}; VARH['omp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'omp2': 'OMP2 TOTAL ENE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:12962,Validat,ValidationError,12962,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"string_xyz(); commands += 'units angstrom\n}\n"""""", 0)\n'; return eval(commands). [docs]def format_options_for_input():; """"""Function to return a string of commands to replicate the; current state of user-modified options. Used to capture C++; options information for distributed (sow/reap) input files. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Does not cover local (as opposed to global) options. - Does not work with array-type options. """"""; commands = ''; commands += """"""\nPsiMod.set_memory(%s)\n\n"""""" % (PsiMod.get_memory()); for chgdopt in PsiMod.get_global_option_list():; if PsiMod.has_option_changed(chgdopt):; chgdoptval = PsiMod.get_global_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""PsiMod.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""PsiMod.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed.' % (chgdopt)); return commands. [docs]def format_kwargs_for_input(filename, lmode=1, **kwargs):; """"""Function to pickle to file *filename* the options dictionary; *kwargs*. Mode *lmode* =2 pickles appropriate settings for; reap mode. Used to capture Python options information for; distributed (sow/reap) input files. """"""; if lmode == 2:; kwargs['mode'] = 'reap'; kwargs['linkage'] = os.getpid(); filename.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, filename); filename.write('''"""""")\n'''); filename.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); if lmode == 2:; kwargs['mode'] = 'sow'; del kwargs['linkage']. [docs]def drop_duplicates(seq):; """"""Function that given an array *seq*, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. """"""; noDupes = []; [noDupes.append(i) for i in seq if not noDupes.count(i)]; return noDupes. Quick search. Enter ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/procutil.html:2403,Validat,ValidationError,2403,psi4manual/4.0b2/_modules/procutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/procutil.html,1,['Validat'],['ValidationError']
Security,"structions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; pass; # if not running from Canopy, print line to execute from Canopy; else:; # if running from Canopy, call mpl directly; filedict = mpl.ternary(dbdat, title=title, labeled=labeled,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_flat(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, color='sapt', xlimit=4.0, xlines=[0.0, 0.3, 1.0],; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Thread *color* can be; 'rgb' for old coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares flat diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. asdf.plot_flat('CCSD-CP-atqzadz', failoninc=False); """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append({'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'data': [indiv[db][rxn][0]]}); pre, suf, mid = string_contrast(mc); title = self.dbse + '-' + sset + ' ' + pre + '[]' + suf; mae = errors[self.dbse]['mae']; mape = None; # mape = 100 * errors[self.dbse]['mape']",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:68026,access,accessible,68026,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['access'],['accessible']
Security,"subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; psi4.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if (db_mode.lower() == 'sow'):; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single input file (%s-master.in) with a database(mode='reap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of comput",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:38014,access,accessed,38014,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['access'],['accessed']
Security,"svec); # -1 displacement; Em1 = displaced_energy(atom, -1*transvec); # +2 displacement; Ep2 = displaced_energy(atom, 2*transvec); # -2 displacement; Em2 = displaced_energy(atom, -2*transvec); # Evaluate; ecpgrad[atom, xyz] = (Em2 + 8*Ep1 - 8*Em1 - Ep2) / (12*delta); ecpgradmat.symmetrize_gradient(ref_wfn.molecule()); ecpgradmat.print_atom_vector(); grad.add(ecpgradmat); grad.print_atom_vector(); ref_wfn.set_print(old_print). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_scf_hessian(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an SCF hessian calculation. """"""; optstash = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['UHF', 'ROHF', 'CUHF', 'RKS', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if ""_disp_functor"" in dir(ref_wfn):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule()); ref_wfn.set_array(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). optstash.restore(); return ref_wfn. def run_libfock(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a calculation through libfock, namely RCPHF,; RCIS, RTDHF, RTDA, and RTDDFT. """"""; if name == 'cphf':; core.set_global_option('MODULE', 'RCPHF'); if name == 'cis':; core.set_global_option('MODULE', 'RCIS'); if name == 'tdhf':; core.set_global_option('MODULE', 'RTDHF'); if name == 'cpks':; core.set_global_option('MODULE', 'RCPKS'); if name == 'tda':; core.set_global_option('MODULE', 'RTDA'); if name == 'tddft':; core.set_global_option('MODULE', 'RTDDFT'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:64794,Validat,ValidationError,64794,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"svec); # -1 displacement; Em1 = displaced_energy(atom, -1*transvec); # +2 displacement; Ep2 = displaced_energy(atom, 2*transvec); # -2 displacement; Em2 = displaced_energy(atom, -2*transvec); # Evaluate; ecpgrad[atom, xyz] = (Em2 + 8*Ep1 - 8*Em1 - Ep2) / (12*delta); ecpgradmat.symmetrize_gradient(ref_wfn.molecule()); ecpgradmat.print_atom_vector(); grad.add(ecpgradmat); grad.print_atom_vector(); ref_wfn.set_print(old_print). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_scf_hessian(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an SCF hessian calculation. """"""; optstash = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['UHF', 'ROHF', 'CUHF', 'RKS', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule()); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:64683,Validat,ValidationError,64683,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"sxdict = xd.parse(handle). return csxdict. [docs]def getFromDict(dataDict, mapList):; return reduce(lambda d, k: d[k], mapList, dataDict). [docs]def csx2endict():; """"""Grabs the CSX file as a dictionary, encodes translation of PSI variables; to XML blocks, gathers all available energies from CSX file into returned; dictionary. """"""; blockprefix = ['chemicalSemantics', 'molecularCalculation', 'quantumMechanics', 'singleReferenceState',; 'singleDeterminant']; blockmidfix = ['energies', 'energy']; prefix = 'cs:'. pv2xml = {; 'MP2 CORRELATION ENERGY': [['mp2'], 'correlation'],; 'MP2 SAME-SPIN CORRELATION ENERGY': [['mp2'], 'sameSpin correlation'],; 'HF TOTAL ENERGY': [['abinitioScf'], 'electronic'],; 'NUCLEAR REPULSION ENERGY': [['abinitioScf'], 'nuclearRepulsion'],; 'DFT FUNCTIONAL TOTAL ENERGY': [['dft'], 'dftFunctional'],; 'DFT TOTAL ENERGY': [['dft'], 'electronic'],; 'DOUBLE-HYBRID CORRECTION ENERGY': [['dft'], 'doubleHybrid correction'],; 'DISPERSION CORRECTION ENERGY': [['dft'], 'dispersion correction'],; }. csxdict = xml2dict(); enedict = {}; for pv, lpv in pv2xml.items():; address = blockprefix + lpv[0] + blockmidfix; indices = [prefix + bit for bit in address]; try:; qwer = getFromDict(csxdict, indices); except KeyError:; continue; for v in qwer:; vv = v.values(); if vv[0] == prefix + lpv[1]:; enedict[pv] = float(vv[1]). return enedict. [docs]def compare_csx():; """"""Function to validate energies in CSX files against PSIvariables. Only; active if write_csx flag on. """"""; if 'csx4psi' in sys.modules.keys():; if core.get_global_option('WRITE_CSX'):; enedict = csx2endict(); compare_integers(len(enedict) >= 2, True, 'CSX harvested'); for pv, en in enedict.items():; compare_values(core.get_variable(pv), en, 6, 'CSX ' + pv + ' ' + str(round(en, 4))). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.2.1;  · . PSI4. Module code. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html:18728,validat,validate,18728,psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,1,['validat'],['validate']
Security,"t OSError as e:; raise ValidationError('Program dftd3 not found in path. %s' % e); out, err = dashout.communicate(). # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; line = line.decode('utf-8'); if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; os.chdir(current_directory); raise Dftd3Error(""""""Unsuccessful run. Possibly -D variant not available in dftd3 version.""""""). # Parse grad output; if dertype != 0:; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Prepare results for Psi4; if isP4regime and dertype != 0:; core.set_variable('DISPERSION CORRECTION ENERGY', dashd); psi_dashdderiv = core.Matrix(self.natom(), 3); psi_dashdderiv.set(dashdderiv). # Print program output to file if verbose; if not verbose and isP4regime:; verbose = True if core.get_option('SCF', 'PRINT') >= 3 else False; if verbose:. text = '\n ==> DFTD3 Output <==\n'; text += out.decode('utf-8'); if dertype != 0:; with open(derivfile, 'r') as handle:; text += handle.read().replace('D', 'E'); text += '\n'; if isP4regime:; core.print_out(text); else:; print(text). # Clean up files and remove scratch directory; os.unlink(paramfile1); os.unlink(paramfile2); os.unlink(geomfile); if dertype != 0:; os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); try:; shutil.rmtree(dftd3_tmpdir); except OSError as e:; ValidationError('Unable to remove",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html:7792,Validat,ValidationError,7792,psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"t WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; from __future__ import absolute_import; import re; import os; import math; import warnings; import pickle; import copy; import collections; import p4const; from driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`share/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedde",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:1716,access,access,1716,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['access'],['access']
Security,"t helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/prog_tour.html:2652,access,accessibility,2652,psi4manual/1.8.x/prog_tour.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/prog_tour.html,1,['access'],['accessibility']
Security,"t helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/prog_tour.html:2652,access,accessibility,2652,psi4manual/1.9.x/prog_tour.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/prog_tour.html,1,['access'],['accessibility']
Security,"t in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; # cbs_delta3_wfn_lesser = kwargs.get('delta3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # else:; # cbs_delta4_wfn_lesser = cbs_delta3_wfn; # if not (cbs_delta4_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA4 method lesser \'%",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:32914,Validat,ValidationError,32914,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"t in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. scf-upcast-custom-basis; test scf castup with custom basis sets. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. fnocc5; Test FNO-DF-CCSD(T) energy. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cbs-xtpl-energy; Extrapolated water energies. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. dft-reference; MP2 with a PBE0 reference computation. mbis-1; MBIS calculation on H2O. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:39660,Access,Accesses,39660,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['Access'],['Accesses']
Security,"t key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from ast import literal_eval; from enum import Enum; from typing import TYPE_CHECKING, Any, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import logging. import numpy as np; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_nbody_multilevel, p4util; from .constants import constants, pp; from .driver_cbs import CompositeComputer; from .driver_findif import FiniteDifferenceComputer; from .p4util.exceptions import *; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_nbody.html:7399,validat,validator,7399,psi4manual/1.9.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_nbody.html,4,['validat'],['validator']
Security,"t o'lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar ""DISPERSION CORRECTION ENERGY"" is set; * `verbose` triggered when PRINT keywork of SCF module >=3. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, (Molecule, core.Molecule)):; # 1st: called on a qcdb.Molecule; # 2nd: called on a python export of a psi4.Molecule (py-side through Psi4's driver); pass; elif isinstance(mol, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); mol = Molecule(mol); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # Validate arguments; if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError(""""""Requested derivative level 'dertype' %s not valid for run_dftd3."""""" % (dertype)); else:; raise ValidationError(""""""Requested derivative level 'dertype' %s not valid for run_dftd3."""""" % (dertype)). if dashlvl is not None:; dashlvl = dashlvl.lower(); dashlvl = get_dispersion_aliases()[dashlvl] if dashlvl in get_dispersion_aliases() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())); else:; raise ValidationError(""""""Must specify a dashlvl""""""). if func is not None:; dftd3_params = dash_server(func, dashlvl); else:; dftd3_params = {}. if dashparam is not None:; dftd3_params.update(dashparam). # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html:5056,Validat,ValidationError,5056,psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"t of component databases. That is, for Database SSIBBI, SSI-only arylaryl is accessible b/c not defined in BBI, but SSI-only neutral is not accessible. plot_modelchems(modelchem, benchmark='default', mbenchmark=None, sset='default', msset=None, failoninc=True, verbose=False, color='sapt', xlimit=4.0, labeled=True, view=True, mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Computes individual errors and summary statistics over all component; databases for each model chemistry in array modelchem versus benchmark; over subset sset. mbenchmark and msset are array options (same; length as modelchem) that override benchmark and sset, respectively,; for non-uniform specification. Thread color can be ‘rgb’ for old; coloring, a color name or ‘sapt’ for spectrum coloring.; saveas conveys directory (‘/’) and/or filename for saving the; resulting plot. File extension is not accessible, but graphicsformat; array requests among ‘png’, ‘pdf’, and ‘eps’ formats. relpath; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary.; Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of mousetext, mouselink,; or mouseimag is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. plot_ternary(sset='default', labeled=True, pythonpath='/Users/loriab/linux/bfdb/sapt_punt', failoninc=True, view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; This is a stopgap function that loads sapt component data from; sapt_punt in bfdb repo, then formats it to plot a ternary diagram. promote_Subset(name=None)[source]¶; Examine component databases and elevate subset name not necessarily; present for all component databases to a subset for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:39042,access,accessible,39042,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['access'],['accessible']
Security,"t on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; findif_meta_dict = driver_findif.gradient_from_energy_geometries(molecule); ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed ..."""""" % (ndisp), end=''). wfn ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:40343,Validat,ValidationError,40343,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"t on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:38081,Validat,ValidationError,38081,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"t on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:36908,Validat,ValidationError,36908,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"t on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(). # no analytic derivatives for scf_type cd; if psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; psi4.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:35677,Validat,ValidationError,35677,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"t the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Fitted 2-point parameter. Overrides the default :math:`\alpha = 1.63`. Returns; -------; float or ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [1]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63`. References; ----------. .. [1] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DT]Z', scf_scheme='scf_xtpl_helgaker_2'). """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 1.63. beta_division = 1 / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); beta_mult = math.exp(-1 * alpha * zHI). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:4661,Validat,ValidationError,4661,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Validat'],['ValidationError']
Security,"t to change and for the current has_changed status; (presumably reflecting whether the user has changed the value, as long as; no preceeding code has corrupted that definition). The python function; then makes its changes to the option and runs any c-side modules with; those changes. Finally, just before the function returns, the options are; reset to the user’s value and has_changed status (which should now again; reflect only whether the user has changed the value). Warning; PUREAM is an exception in that its value and; has_changed() value only reflect what the user has explicitly set.; This keyword should not be queried to find out the current; PUREAM state for the active basis; use instead,; PsiMod.MintsHelper().basisset().has_puream(). Reading Options in Module¶. Handling Options in Driver¶; This section is about the scopes of options and how best to handle them in; the python driver. There are four groups of commands available.; Options from the c-side Options object are accessible in the Python driver through four sets of commands. get; get_global_option(); get_local_option(); get_option(). set; set_global_option(); set_local_option(). has_changed; has_global_option_changed(); has_local_option_changed(); has_option_changed(). revoke_changed; revoke_global_option_changed(); revoke_local_option_changed(). There’s a pattern here. Setting something, either a value (set) or a; negative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that are used by most, if not all, modules. There are two primary purposes for in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:6381,access,accessible,6381,psi4manual/4.0b3/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html,4,['access'],['accessible']
Security,"t valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, by",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:13123,Validat,ValidationError,13123,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,8,['Validat'],['ValidationError']
Security,"t valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:13237,Validat,ValidationError,13237,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,3,['Validat'],['ValidationError']
Security,"t"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for dir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, dir)):; available_plugins.append(dir). [docs]def create_plugin(name, template):; """"""Generate plugin in directory with sanitized *name* based upon *template*."""""". name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/plugin.html:3582,sanitiz,sanitized,3582,psi4manual/1.2.1/_modules/psi4/driver/plugin.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/plugin.html,2,['sanitiz'],['sanitized']
Security,"t(info); logger.info(info). # TODO: Replace with a generator from a stencil to a set of points.; # Diagonal displacements differ between the totally symmetric irrep, compared to all others.; # Off-diagonal displacements are the same for both.; pts_dict = {; 3: {; ""sym_irr"": ((-1, ), (1, )),; ""asym_irr"": ((-1, ), ),; ""off"": ((1, 1), (-1, -1)); },; 5: {; ""sym_irr"": ((-2, ), (-1, ), (1, ), (2, )),; ""asym_irr"": ((-2, ), (-1, )),; ""off"": ((-1, -2), (-2, -1), (-1, -1), (1, -1), (-1, 1), (1, 1), (2, 1), (1, 2)); }; }. try:; disps = pts_dict[stencil_size]; except KeyError:; raise ValidationError(f""FINDIF: Number of points ({stencil_size}) not among {pts_dict.keys()}!""). # Convention: x_pi means x_per_irrep. The ith element is x for irrep i, with Cotton ordering.; salc_indices_pi = [[] for h in range(n_irrep)]. # Validate that we have an irrep matching the user-specified irrep, if any.; try:; salc_indices_pi[freq_irrep_only]; except (TypeError, IndexError):; if freq_irrep_only != -1:; raise ValidationError(; f""FINDIF: 0-indexed Irrep value ({freq_irrep_only}) not in valid range: <{len(salc_indices_pi)}.""). # Populate salc_indices_pi for all irreps.; # * Python error if iterate through `salc_list`; for i in range(len(salc_list)):; salc_indices_pi[salc_list[i].irrep_index()].append(i). # If the method allows more than one irrep, print how the irreps partition the SALCS.; if print_lvl and method_allowed_irreps != 0x1 and verbose:; info = "" Index of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; tmp = ("" {:d} "" * len(salc_indices_pi[h])).format(*salc_indices_pi[h]); info += "" {:d} : "".format(h + 1) + tmp + ""\n""; info += "" Number of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; info += "" Irrep {:d}: {:d}\n"".format(h + 1, len(salc_indices_pi[h])); core.print_out(info); logger.info(info). # Now that we've printed the SALCs, clear any that are not of user-specified symmetry.; if freq_i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:10145,Validat,ValidationError,10145,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['Validat'],['ValidationError']
Security,"t) → None; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int) → str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float) → None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]; Exports coordinate info into NumPy arrays. Parameters:; dummy (bool, optional) – Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool, optional) – Whether or not to treat ghost atoms as dummies. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]; Serializes instance into dictionary according to schema dtype. to_string(dtype, units='Angstrom', atom_format=None, ghost_format=None, width=17, prec=12)[source]; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int) → int; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule) → str; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None; Reevaluates the geometry with curr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:60813,hash,hash,60813,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,1,['hash'],['hash']
Security,"t)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']) or; core.get_option('CCTRANSORT', 'SEMICANONICAL')):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driver.pasture import addins; addins.ccsort_transqt2(ref_wfn); except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). ccwfn = core.ccenergy(ref_wfn); if core.get_global_option('PE'):; ccwfn.pe_state = ref_wfn.pe_state. if name == 'a-ccsd(t)':; core.cchbar(ref_wfn); lambdawfn = core.cclambda(ref_wfn); for k, v in lambdawfn.variables().items():; ccwfn.set_variable(k, v). optstash.restore(); return ccwfn. def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). core.set_global_option('DERTYPE', 'FIRST'). if core.get_global_option('FREEZE_CORE') not in [""FALSE"", ""0""]:; raise ValidationError('Frozen core is not available for the CC gradients.'). ccwfn = run_ccenergy(name, **kwargs). if name == 'cc2':; core.set_local_option('CCHBAR', 'WFN', 'CC2'); core.set_local_option('CCLAMBDA', 'WFN', 'CC2'); core.set_local_option('CCDENSITY', 'WFN', 'CC2'); if name == 'ccsd':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). core.cchbar(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). derivobj = core.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad); ccwfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(""CURRENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:90416,Validat,ValidationError,90416,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"t, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import os; import re; import math; import pickle; import collections. from psi4.driver import constants; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`share/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:2166,access,accessible,2166,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,1,['access'],['accessible']
Security,"t, List, Optional. import numpy as np. from psi4 import core. from .. import psifiles as psif; from ..procrouting.proc_util import check_iwl_file_from_scf_type; from .exceptions import TestComparisonError, ValidationError; from .testing import compare_integers, compare_recursive, compare_values. [docs]; def fcidump(wfn: core.Wavefunction, fname: str = 'INTDUMP', oe_ints: Optional[List] = None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989),; https://doi.org/10.1016/0010-4655(89)90033-7 .; Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. Parameters; ----------; wfn; Set of molecule, basis, orbitals from which to generate FCIDUMP file.; fname; Name of the integrals file, defaults to INTDUMP.; oe_ints; List of additional one-electron integrals to save to file. So far only; EIGENVALUES is a valid option. Raises; ------; ValidationError; When SCF wavefunction is not RHF. Examples; --------. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/fcidump.html:2314,Validat,ValidationError,2314,psi4manual/1.9.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/fcidump.html,2,['Validat'],['ValidationError']
Security,"t, [rxn['sys']] * Nweft,; npxvals, [rxn['show']] * Nweft, xscreen, yscreen)). # labeling; if not(mousetext or mouselink or mouseimag):; if labeled and len(data) < 200:; try:; toplblposn = next(item for item in xvals if item is not None); botlblposn = next(item for item in reversed(xvals) if item is not None); except StopIteration:; pass; else:; ax.text(toplblposn, -0.75 + 0.6 * random.random(), rxn['sys'],; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', fontsize=8); ax.text(botlblposn, -1 * Nweft - 0.75 + 0.6 * random.random(), rxn['sys'],; verticalalignment='bottom', horizontalalignment='center',; family='Times New Roman', fontsize=8). # plot trimmings; if mae is not None:; ax.plot([-x for x in mae], positions, 's', color='black'); if labeled:; if mape is not None: # equivalent to MAE for a 10 kcal/mol IE; ax.plot([0.025 * x for x in mape], positions, 'o', color='black'); plt.axvline(0, color='#cccc00'). # save and show; pltuid = title + '_' + ('lbld' if labeled else 'bare') + '_' + hashlib.sha1(title + repr(labels) + repr(xlimit)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='thread_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(). if not (mousetext or mouselink or mouseimag):; plt.close(); return files_saved, None; else:; dpi = 80; img_width = fig.get_figwidth() * dpi; img_height = fig.get_figheight() * dpi. htmlcode = """"""<SCRIPT>\n""""""; htmlcode += """"""function mouseshow(db, rxn, val, show) {\n""""""; if mousetext or mouselink:; htmlcode += """""" var cid = document.getElementById(""cid"");\n""""""; if mousetext:; htmlcode += """""" cid.innerHTML = %s;\n"""""" % (mousetext); if mouselink:; htmlcode += """""" cid.href = %s;\n"""""" % (mouselink); if mouseimag:; htmlcode += """""" var cmpd_img = document.getElementById(""cmpd_img"");\n""""""; htmlcode += ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:20586,hash,hashlib,20586,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['hash'],['hashlib']
Security,"t. def gaussianpdf(u, v, x):; """"""*u* is mean, *v* is variance, *x* is value, returns probability""""""; return 1.0 / np.sqrt(2.0 * np.pi * v) * np.exp(-pow(x - u, 2) / 2.0 / v). me = me if me is not None else np.mean(data); stde = stde if stde is not None else np.std(data, ddof=1); evenerr = max(abs(me - 4.0 * stde), abs(me + 4.0 * stde)); xmin = xmin if xmin is not None else -1 * evenerr; xmax = xmax if xmax is not None else evenerr. dx = (xmax - xmin) / 40.; nx = int(round((xmax - xmin) / dx)) + 1; pdfx = []; pdfy = []; for i in xrange(nx):; ix = xmin + i * dx; pdfx.append(ix); pdfy.append(gaussianpdf(me, pow(stde, 2), ix)). fig, ax1 = plt.subplots(figsize=(16, 6)); plt.axvline(0.0, color='#cccc00'); ax1.set_xlim(xmin, xmax); ax1.hist(data, bins=30, range=(xmin, xmax), color='#2d4065', alpha=0.7); ax1.set_xlabel(xtitle); ax1.set_ylabel('Count'). ax2 = ax1.twinx(); ax2.fill(pdfx, pdfy, color='k', alpha=0.2); ax2.set_ylabel('Probability Density'). plt.title(title). # save and show; pltuid = title + '_' + hashlib.sha1(title + str(me) + str(stde) + str(xmin) + str(xmax)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='disthist_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. #def thread(data, labels, color=None, title='', xlimit=4.0, mae=None, mape=None):; # """"""Generates a tiered slat diagram between model chemistries with; # errors (or simply values) in list *data*, which is supplied as part of the; # dictionary for each participating reaction, along with *dbse* and *rxn* keys; # in argument *data*. The plot is labeled with *title* and each tier with; # an element of *labels* and plotted at *xlimit* from the zero-line. If; # *color* is None, slats are black, if 'sapt', colors are taken from *color*; # key in *data* [0, 1]. Summary sta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:12720,hash,hashlib,12720,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['hash'],['hashlib']
Security,"t.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:56632,Validat,ValidationError,56632,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"t.format('total', 'CBS', '', '', '', finalenergy, ''); tables += delimit. return tables. [docs]; class CompositeComputer(BaseComputer):. molecule: Any; basis: str = ""(auto)""; method: str = ""(auto)""; driver: DriverEnum; keywords: Dict[str, Any] = {}; metadata: Any; metameta: Dict[str, Any] = {}. verbose: int = 1. # List of model chemistries with extrapolation scheme applied. Can reconstruct CBS. Keys are d_fields. Formerly GRAND_NEED.; cbsrec: List[Dict[str, Any]] = []. # Maximal list of model chemistries extractable from running `compute_list`. Keys are _f_fields. Formerly JOBS_EXT.; trove: List[Dict[str, Any]] = []. # Minimal (enlightened) list of jobs to run to satisfy full CBS. Keys are _f_fields. Formerly JOBS.; compute_list: List[Dict[str, Any]] = []. # One-to-One list of AtomicComputer-s corresponding to `compute_list`.; task_list: List[AtomicComputer] = []. # One-to-One list of QCSchema corresponding to `task_list`.; results_list: List[Any] = []. [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; data = p4util.kwargs_lower(data); data[""metadata""] = _process_cbs_kwargs(data); BaseComputer.__init__(self, **data). self.metameta = {; 'kwargs': data,; 'ptype': self.driver,; 'verbose': self.verbose,; 'label': None,; 'molecule': self.molecule,; }; # logger.debug(""METAMETA\n"" + pp.pformat(self.metameta)). if data['metadata']:; if data['metadata'][0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in driver_cbs.py to proceed."""""" %; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:53721,validat,validator,53721,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,3,['validat'],['validator']
Security,"t: bool = True,; speclabel: bool = True,; tooclose: float = 0.1,; zero_ghost_fragments=False,; nonphysical: bool = False,; mtol=1.0e-3,; copy=True,; verbose=1,; ):; r""""""Compose a Molecule dict from unvalidated arrays and variables, returning dict. See fields of Return molrec below. Required parameters (for QM XYZ); are `geom` and one of `elem`, `elez`, `elbl` (`speclabel=True`). Parameters; ----------; geom : Union[List[List[float]], numpy.ndarray]; (nat, 3) or (3 * nat, ) ndarray or list o'lists of Cartesian coordinates.; fragment_separators : Union[List[int], numpy.ndarray]; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; elbl : Union[List[str], numpy.ndarray]; (nat, ) Label extending `elem` symbol, possibly conveying ghosting, isotope, mass, tagging information.; tooclose; Interatom distance (native `geom` units) nearer than which atoms not allowed.; nonphysical; Do allow masses outside an element's natural range to pass validation?; speclabel; If `True`, interpret `elbl` as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., `@13C_mine` or; `He4@4.01`. If `False`, interpret `elbl` as only the user/tagging; extension to nucleus label, e.g. `_mine` or `4` in the previous examples.; missing_enabled_return; {'minimal', 'none', 'error'}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out; When `True`, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use `False` to get a json-able version. Returns; -------; molrec : dict; Molecule dictionary spec follows. Its principles are. (1) contents are fully validated and defaulted - no error; checking necessary,. (2) contents may be mildly redundant - atomic numbers and; element symbols present,. (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,. (4) some fields are optional (e.g., fix_symmet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:4702,validat,validation,4702,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['validat'],['validation']
Security,"t; computed[""State dipole moment (in a.u.)""] = data; adc_wfn.set_variable(f""{name} state dipoles"", core.Matrix.from_array(data)). core.print_out(""\nExcited state properties:\n""); n_states = adc_wfn.variable(""number of excited states""); for i in range(int(n_states)):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(computed.items()):; lines += [ind + ind + format_vector(prop, data[i])]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; core.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name in ['mp', 'mp2', 'mp3', 'mp4']:; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'MPN', 'TRUE'); if name == 'mp2':; level = 2; elif name == 'mp3':; level = 3; elif name == 'mp4':; level = 4; else:; level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name == 'ccsd':; # untested; core.set_local_opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:121607,Validat,ValidationError,121607,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"t; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except Name",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:86872,Validat,ValidationError,86872,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,"t; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Compl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:85631,Validat,ValidationError,85631,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"t=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n mousediv=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, ixmid, mae, mape, str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, title=title, labels=ixmid, mae=mae, mape=mape,; xlimit=xlimit, labeled=labeled, view=view,; mousetext=mousetext, mouselink=mouselink,; mouseimag=mouseimag, mousetitle=mousetitle, mousediv=mousediv,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict, htmlcode. [docs] def plot_liliowa(self, modelchem, benchmark='default',; failoninc=True, xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". Note that not possible to access sset of component databases. That is, for Database SSIBBI, SSI-only arylaryl is accessible b/c not defined in BBI, but SSI-only neutral is not accessible.; """"""; # compute errors; mc = modelchem; errors = {}; for ss in self.sset.keys():; errors[ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False). # repackage; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:81167,access,accessible,81167,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,2,['access'],['accessible']
Security,"tXYZFile(self):; """"""Function to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. """"""; try:; temp = self.getCartesian(); except Exception as e:; raise; molstr = ""%d\n%s\n%s"" % (self.natom, self.iupac, temp); return molstr. [docs] def getMoleculeString(self):; """"""Function to obtain a molecule string through; getCartesian() or fail.; """"""; try:; return self.getCartesian(); except Exception as e:; return e.message. [docs]def getPubChemResults(name):; """"""Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. """"""; url = 'http://www.ncbi.nlm.nih.gov/sites/entrez?db=pccompound&term=%s&format=text' % quote(name); print(""\tSearching PubChem database for %s"" % (name)); try:; loc = urlopen(url); except URLError as e:; msg = ""\tPubchemError\n%s\n\treceived when trying to open\n\t%s\n"" % (str(e), url); msg += ""\tCheck your internet connection, and the above URL, and try again.\n""; raise ValidationError(msg); data = loc.read(). ans = []; l = data.find(b""<pre>""); l = data.find(b""\n"", l); i = 1; while(True):; l = data.find(str(""%d. "" % i).encode(sys.getdefaultencoding()), l); if l == -1:; break; tag = b""MF: ""; l = data.find(tag, l) + len(tag); mf = data[l:data.find(b'\n', l)].decode(sys.getdefaultencoding()); tag = b""IUPAC name: ""; l = data.find(tag, l) + len(tag); iupac = data[l:data.find(b'\n', l)].decode(sys.getdefaultencoding()); tag = b""CID:""; l = data.find(tag, l) + len(tag); #if l == 4:; # break; cid = int(data[l:data.find(b""\n"", l)]); l = data.find(b'\t', l) + 1. pubobj = PubChemObj(cid, mf, iupac); ans.append(pubobj); i += 1. print(""\tFound %d results"" % (len(ans))); return ans. if __name__ == ""__main__"":; try:; #obj = getPubChemResults(""1-methoxy-4-[(E)-prop-1-enyl]benzene""); #obj = getPubChemResults(""sodium benzenesulfonate""); obj = getPubChemResults(""4-[bis(4-hydroxyphenyl)methyl]phenol""); except Exception as e:; print(e.message). for r in obj:; print(r); print(r.getMol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:7771,Validat,ValidationError,7771,psi4manual/1.0.0/_modules/pubchem.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html,1,['Validat'],['ValidationError']
Security,"t][i] - rgeom[at][i] for i in range(3)])). if do_plot:; # TODO Missing import; plot_coord(ref=rgeom, cand=ageom, orig=cgeom, comment=""Final RMSD = {:8.4f}"".format(final_rmsd)). # sanity checks; assert compare_values(; _pseudo_nre(cuniq, cgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE uncorrupted"",; atol=1.0e-4,; quiet=(verbose < 2),; ). if mols_align is True:; assert compare_values(; _pseudo_nre(runiq, rgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE matches ref_mol"",; atol=1.0e-4,; quiet=(verbose < 2),; ); assert compare_values(; rgeom, ageom, ""D: concern_mol-->returned_mol geometry matches ref_mol"", atol=1.0e-4, quiet=(verbose < 2); ); assert compare_values(0.0, final_rmsd, ""D: null RMSD"", atol=1.0e-4, quiet=(verbose < 2)). return final_rmsd, hold_solution. def _plausible_atom_orderings(ref, current, rgeom, cgeom, algorithm=""hungarian_uno"", verbose=1, uno_cutoff=1.0e-3):; r"""""". Parameters; ----------; ref : list; Hashes encoding distinguishable non-coord characteristics of reference; molecule. Namely, atomic symbol, mass, basis sets?.; current : list; Hashes encoding distinguishable non-coord characteristics of trial; molecule. Namely, atomic symbol, mass, basis sets?. Returns; -------; iterator of tuples. """"""; if sorted(ref) != sorted(current):; raise ValidationError(; """"""ref and current can't map to each other.\n"""""" + ""R: "" + str(ref) + ""\nC: "" + str(current); ). where = collections.defaultdict(list); for iuq, uq in enumerate(ref):; where[uq].append(iuq). cwhere = collections.defaultdict(list); for iuq, uq in enumerate(current):; cwhere[uq].append(iuq). connect = collections.OrderedDict(); for k in where:; connect[tuple(where[k])] = tuple(cwhere[k]). def filter_permutative(rgp, cgp):; """"""Original atom ordering generator for like subset of atoms (e.g., all carbons).; Relies on permutation. Filtering depends on similarity of structure (see `atol` parameter).; Only suitable for total system size up to about 20 atoms.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html:9816,Hash,Hashes,9816,psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,3,['Hash'],['Hashes']
Security,"t_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.6;  · . PSI4. Module code; qcelemental.molparse.from_arrays. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html:22644,Validat,ValidationError,22644,psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"t_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = sapt_dimer.extract_subsets(2); monomerBm.set_name('monomerBm'). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'); core.set_global_option('DF_INTS_IO', 'SAVE'); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.set_global_option('DF_INTS_IO', 'LOAD'). if (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'); core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF (Dimer Basis)'); core.print_out('\n'); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs). if (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF (Dimer Basis)'); core.print_out('\n'); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:106989,Validat,ValidationError,106989,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,9,['Validat'],['ValidationError']
Security,"t_dertype = kwargs['dertype']. if der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # no analytic derivatives for scf_type cd; if psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError('No analytic derivatives for SCF_TYPE CD.'). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:33122,Validat,ValidationError,33122,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"t_files) == len(hint_types) == len(geom_hints)); ):. raise ValidationError(; """"""Missing or inconsistent length among efp quantities: fragment_files ({}), hint_types ({}), and geom_hints ({})"""""".format(; fragment_files, hint_types, geom_hints; ); ). # NOTE: imposing case on file; try:; files = [f.lower() for f in fragment_files]; except AttributeError:; raise ValidationError(""""""fragment_files not strings: {}"""""".format(fragment_files)). if all(f in [""xyzabc"", ""points"", ""rotmat""] for f in hint_types):; types = hint_types; else:; raise ValidationError(""""""hint_types not among 'xyzabc', 'points', 'rotmat': {}"""""".format(hint_types)). hints = []; hlen = {""xyzabc"": 6, ""points"": 9, ""rotmat"": 12}; for ifr, fr in enumerate(geom_hints):; try:; hint = [float(f) for f in fr]; except (ValueError, TypeError):; raise ValidationError(""""""Un float-able elements in geom_hints[{}]: {}"""""".format(ifr, fr)). htype = hint_types[ifr]; if len(hint) == hlen[htype]:; hints.append(hint); else:; raise ValidationError(""""""EFP hint type {} not {} elements: {}"""""".format(htype, hlen[htype], hint)). return {""fragment_files"": files, ""hint_types"": types, ""geom_hints"": hints}. def validate_and_fill_geometry(geom=None, tooclose=0.1, copy=True):; """"""Check `geom` for overlapping atoms. Return flattened"""""". npgeom = np.array(geom, copy=copy, dtype=float).reshape((-1, 3)). # Upper triangular; metric = tooclose ** 2; tooclose_inds = []; for x in range(npgeom.shape[0]):; diffs = npgeom[x] - npgeom[x + 1 :]; dists = np.einsum(""ij,ij->i"", diffs, diffs). # Record issues; if np.any(dists < metric):; indices = np.where(dists < metric)[0]; tooclose_inds.extend([(x, y, dist) for y, dist in zip(indices + x + 1, dists[indices] ** 0.5)]). if tooclose_inds:; raise ValidationError(; """"""Following atoms are too close: {}"""""".format([(i, j, dist) for i, j, dist in tooclose_inds]); ). return {""geom"": npgeom.reshape((-1))}. def validate_and_fill_nuclei(; nat,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:17347,Validat,ValidationError,17347,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"t_fjobarc(fje,; *qcdb.cfour.backtransform(chgeMol=zmmol, permMol=c4mol), gradient=fjgrd, dipole=fjdip). # Psi4 for gradients; else:; # Prepare Cfour skeleton calc directory; os.chdir(scrdir + c4scrdir) # psi_scratch/cfour; if os.path.exists('scr.' + item):; shutil.rmtree('scr.' + item); os.mkdir('scr.' + item); os.chdir('scr.' + item) # psi_scratch/cfour/scr.000-004; with open('ZMAT', 'w') as handle:; handle.write(zmat); shutil.copy2('../harm/GENBAS', 'GENBAS'). # Run Cfour skeleton calc and extract qcdb.Molecule at needed C4 orientation; with open('partial.out', 'w') as handle:; handle.write(run_cfour_module('xjoda')); handle.write(run_cfour_module('xvmol')); handle.write(run_cfour_module('xvmol2ja')); psi4.print_out(' CFOUR scratch file %s for %s has been read\n' % ('JOBARC (binary)', item)); c4mol = qcdb.cfour.jajo2mol(qcdb.jajo.getrec(['COORD ', 'ATOMCHRG', 'MAP2ZMAT'])). # S/R: Reap results from output file; if isSowReap:; isOk, msg, results = reap_job_validate(outdir, 'VPT2', item, linkage,; ['CURRENT ENERGY', 'CURRENT DIPOLE', 'CURRENT GRADIENT']); if not isOk:; raise ValidationError(msg). fje = results['CURRENT ENERGY']; fjgrd = results['CURRENT GRADIENT']; fjdip = [item / p4const.psi_dipmom_au2debye for item in results['CURRENT DIPOLE']]. # C: Run the job and collect results; else:; psi4.IO.set_default_namespace(item); molecule = geometry(zmmol.create_psi4_string_from_molecule(), 'disp-' + item); molecule.update_geometry(); gradient(lowername, **kwargs). fje = psi4.get_variable('CURRENT ENERGY'); fjgrd = p4util.mat2arr(psi4.get_gradient()); fjdip = [psi4.get_variable('CURRENT DIPOLE X') / p4const.psi_dipmom_au2debye,; psi4.get_variable('CURRENT DIPOLE Y') / p4const.psi_dipmom_au2debye,; psi4.get_variable('CURRENT DIPOLE Z') / p4const.psi_dipmom_au2debye]. # Transform results into C4 orientation (defined by c4mol) & forge FJOBARC file; fjobarc = qcdb.cfour.format_fjobarc(fje,; *qcdb.cfour.backtransform(chgeMol=zmmol, permMol=c4mol, chgeGrad=fjgrd, chgeDip=fjd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:23453,Validat,ValidationError,23453,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,1,['Validat'],['ValidationError']
Security,"t_from_energies(); ---------------------------------; assemble_dipder_from_dipoles(); ------------------------------. * form DD, G, H from lower derivative points. * place as many of DD, G, H as available onto reference entry. * pull qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import p4util, qcdb; from .constants import constants, nppp10, pp; from .p4util.exceptions import ValidationError; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_findif.html:4635,validat,validator,4635,psi4manual/1.9.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_findif.html,4,['validat'],['validator']
Security,"t_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """""". optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # If RHF get MP2 NO's; # Why doesnt this work for conv?; if (('DF' in core.get_global_option('SCF_TYPE')) and (user_ref == 'RHF') and; (core.get_option('DETCI', 'MCSCF_TYPE') in ['DF', 'AO']) and; (core.get_option(""DETCI"", ""MCSCF_GUESS"") == ""MP2"")):; core.set_global_option('ONEPDM', True); core.set_global_option('OPDM_RELAX', False); ref_wfn = run_dfmp2_gradient(name, **kwarg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:129883,Validat,ValidationError,129883,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"t_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # If RHF get MP2 NO's; # Why doesnt this work for conv?; if (('DF' in core.get_global_option('SCF_TYPE')) and (user_ref == 'RHF') and; (core.get_option('DETCI', 'MCSCF_TYPE') in ['DF', 'AO']) and; (core.get_option(""DETCI"", ""MCSCF_GUESS"") == ""MP2"")):; core.set_global_option('ONEPDM', True); core.set_global_option('OPDM_RELAX', False); ref_wfn = run_dfmp2_gradient(name, **kwarg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:128908,Validat,ValidationError,128908,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"t_molecular_change` or `set_multiplicity`. Such alterations are an expert feature. Specifying in the original molecule string is preferred. Nonphysical masses may also trigger the warning.""""""; ); molrec['fragment_charges'] = [None] * len(fragments); molrec['fragment_multiplicities'] = [None] * len(fragments); validated_molrec = qcel.molparse.from_arrays(speclabel=False, nonphysical=True, verbose=0, domain='qm', **molrec); forgive.append('fragment_charges'); forgive.append('fragment_multiplicities'); compare_molrecs(validated_molrec, molrec, 'to_dict', atol=1.e-6, forgive=forgive, verbose=0). # from_arrays overwrites provenance; validated_molrec['provenance'] = copy.deepcopy(molrec['provenance']). if not np_out:; validated_molrec = qcel.util.unnp(validated_molrec). return validated_molrec. @classmethod; def from_dict(cls, molrec, verbose=1):. mol = cls(); mol._internal_from_dict(molrec=molrec, verbose=verbose); return mol. def _internal_from_dict(self, molrec, verbose=1):; """"""Constructs instance from fully validated and defaulted dictionary `molrec`."""""". # Compromises for qcdb.Molecule; # * molecular_charge is int, not float; # * fragment_charges are int, not float. self.lock_frame = False. if 'name' in molrec:; self.set_name(molrec['name']). if 'comment' in molrec:; self.set_comment(molrec['comment']). self.set_provenance(copy.deepcopy(molrec['provenance'])). if 'connectivity' in molrec:; self.set_connectivity(copy.deepcopy(molrec['connectivity'])). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat], Z, label,; molrec['elea'][iat]); for var in molrec['variables']:; self.s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html:50980,validat,validated,50980,psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,7,['validat'],['validated']
Security,"t_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec banners. try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: (*float*) Total electronic energy in Hartrees. .. caution:: Some features ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:29161,Validat,ValidationError,29161,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"t_out('\n'); banner(name.upper()); PsiMod.print_out('\n'); e_sapt = PsiMod.sapt(). molecule.reset_point_group(user_pg); molecule.update_geometry(). optstash.restore(); return e_sapt. [docs]def run_dftsapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFT-SAPT calculation of any level. """"""; optstash = OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; PsiMod.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (PsiMod.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); if (sapt_basis == 'dimer'):; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); wfn_dimer = PsiMod.wavefunction(); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:51501,Validat,ValidationError,51501,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"t_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', psi4.get_active_molecule()); else:; psi4.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(). if psi4.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = sapt_dimer.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = sapt_dimer.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, 1); monomerB.set_name('monomerB'); sapt_dimer.update_geometry(); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = sapt_dimer.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'); psi4.set_global_option('DF_INTS_IO', 'SAVE'); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); psi4.set_global_option('DF_INTS_IO', 'LOAD'). if (ri == 'DF'):; psi4.IO.change_file_namespace(97, 'dimer', 'mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:85485,Validat,ValidationError,85485,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"t_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : dict; A dictionary of vibrational information. See :py:func:`~psi4.driver.qcdb.vib.harmonic_analysis`; """""". if hess is None:; nmwhess = np.asarray(wfn.hessian()); else:; nmwhess = hess. dipder = wfn.variables().get(""CURRENT DIPOLE GRADIENT"", None); if dipder is not None:; dipder = np.asarray(dipder).T. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False), 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(; nmwhess, geom, m, wfn.basisset(), irrep_labels, dipder=dipder, project_trans=project_trans, project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:88341,Validat,ValidationError,88341,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"t_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : dict; A dictionary of vibrational information. See :py:func:`~psi4.driver.qcdb.vib.harmonic_analysis`; """""". if hess is None:; nmwhess = np.asarray(wfn.hessian()); else:; nmwhess = hess. dipder = wfn.variables().get(""CURRENT DIPOLE GRADIENT"", None); if dipder is not None:; dipder = np.asarray(dipder).T. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False), 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess,; geom,; m,; wfn.basisset(),; irrep_labels,; dipder=dipder,; project_trans=project_trans,; project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:81791,Validat,ValidationError,81791,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"t_types : {'xyzabc', 'points'}; (nfr, ) type of fragment orientation hint.; geom_hints : list of lists of float; (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment. QMVZ extension (geom_unsettled replaces geom). geom_unsettled : list of lists of str; (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables : list of pairs; (nvar, 2) pairs of variables (str) and values (float). May be incomplete. Raises; ------; qcelemental.ValidationError; For most anything wrong. """"""; # << domain sorting >>; available_domains = [""qm"", ""efp"", ""qmvz""]; if domain not in available_domains:; raise ValidationError(; ""Topology domain {} not available for processing. Choose among {}"".format(domain, available_domains); ). if domain == ""qm"" and (geom is None or np.asarray(geom).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom = []; else:; raise ValidationError(""""""For domain 'qm', `geom` must be provided.""""""); if domain == ""efp"" and (geom_hints is None or np.asarray(geom_hints, dtype=object).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom_hints = []; fragment_files = []; hint_types = []; else:; raise ValidationError(""""""For domain 'efp', `geom_hints` must be provided.""""""). molinit = {}; extern = False. processed = validate_and_fill_units(; name=name,; units=units,; input_units_to_au=input_units_to_au,; comment=comment,; provenance=provenance,; connectivity=connectivity,; always_return_iutau=False,; ); processed[""provenance""] = provenance_stamp(__name__); update_with_error(molinit, processed). if domain == ""efp"":; processed = validate_and_fill_efp(fragment_files=fragment_files, hint_types=hint_types, geom_hints=geom_hints); update_with_error(molinit, processed); extern = bool(len(molinit[""geom_hints""])). if domain == ""qm"" or (domain =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:9294,Validat,ValidationError,9294,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"t_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from global memory if present. Par",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:38391,Validat,ValidationError,38391,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"ta (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:34977,validat,validator,34977,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,3,['validat'],['validator']
Security,"ta"" + str(h)] = v. if isinstance(self, core.Matrix):; ret[prefix + ""Dim1""] = self.rowdim().to_tuple(); ret[prefix + ""Dim2""] = self.coldim().to_tuple(); if isinstance(self, core.Vector):; ret[prefix + ""Dim""] = [self.dim(x) for x in range(self.nirrep())]. if filename is None:; return ret. np.savez(filename, **ret). def _np_read(self, filename, prefix=""""):; """"""; Reads the data from a NumPy compress file.; """""". if isinstance(filename, np.lib.npyio.NpzFile):; data = filename; elif (sys.version_info[0] == 2) and isinstance(filename, (str, unicode)):; if not filename.endswith('.npz'):; filename = filename + '.npz'; data = np.load(filename); elif (sys.version_info[0] > 2) and isinstance(filename, str):; if not filename.endswith('.npz'):; filename = filename + '.npz'. data = np.load(filename); else:; raise Exception(""Filename not understood: %s"" % filename). ret_data = []. if ((prefix + ""Irreps"") not in data.keys()) or ((prefix + ""Name"") not in data.keys()):; raise ValidationError(""File %s does not appear to be a numpyz save"" % filename). for h in range(data[prefix + ""Irreps""]):; ret_data.append(data[prefix + ""IrrepData"" + str(h)]). arr_type = self.__mro__[0]; if arr_type == core.Matrix:; dim1 = core.Dimension.from_list(data[prefix + ""Dim1""]); dim2 = core.Dimension.from_list(data[prefix + ""Dim2""]); ret = self(str(data[prefix + ""Name""]), dim1, dim2); elif arr_type == core.Vector:; dim1 = core.Dimension.from_list(data[prefix + ""Dim""]); ret = self(str(data[prefix + ""Name""]), dim1). for h in range(data[prefix + ""Irreps""]):; ret.nph[h][:] = ret_data[h]. return ret. def _to_serial(data):; """"""; Converts an object with a .nph accessor to a serialized dictionary; """""". json_data = {}; json_data[""shape""] = []; json_data[""data""] = []. for view in data.nph:; json_data[""shape""].append(view.shape); json_data[""data""].append(view.tostring()). if len(json_data[""shape""][0]) == 1:; json_data[""type""] = ""vector""; elif len(json_data[""shape""][0]) == 2:; json_data[""type""] = ""matrix""; else:; raise Va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html:9821,Validat,ValidationError,9821,psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"ta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = _expand_bracketed_basis(kwargs['corl_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""CORL basis sets through keyword '%s' are required."""""" % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = _expand_bracketed_basis(kwargs['scf_basis'].lower(), molecule=molstr); elif do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError(""""""SCF basis sets through keyword '%s' are required. Or perhaps you forgot the '%s'."""""" % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = _expand_bracketed_basis(kwargs['delta_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA basis sets through keyword '%s' are required."""""" % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:36711,Validat,ValidationError,36711,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"ta[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs) -> core.Matrix:; """"""Chains dot products together from a series of Psi4 Matrix classes.; Uses :func:`~psi4.core.doublet`. Parameters; ----------; args; Arbitrary number of :class:`~psi4.core.Matrix` arguments to be; multiplied.; trans; Optional iterable of booleans of length number of `args` to designate; transposes, if any. """"""; trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[n + 1]). return ret. def _irrep_access(self, *args, **kwargs):; """"""; Warns user when iterating/accessing an irrepped object.; """"""; raise ValidationError(""Attempted to access by index/iteration a Psi4 data object that supports multiple""; "" irreps. Please use .np or .nph explicitly.""). # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_serial = _to_serial; core.Matrix.from_serial = classmethod(_from_serial); core.Matrix.chain_dot = _chain_dot; core.Matrix.__iter__ = _irrep_access; core.Matrix.__getitem__ = _irrep_access. # Vector attributes; core.Vector.from_array = classmethod(array_to_matrix); core.Vector.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Vector.to_array = _to_array; core.Vector.shape = _np_shape; core.Vector.np = _np_view; core.Vector.nph = _np",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:14349,Validat,ValidationError,14349,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,4,"['Validat', 'access']","['ValidationError', 'access']"
Security,"tabase %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; PsiMod.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if (db_mode.lower() == 'sow'):; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single input file (%s-master.in) with a database(mode='reap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:36958,access,accessed,36958,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['access'],['accessed']
Security,"tadata['max_nbody']] - vmfc_energy_body_dict[1]; nbody_dict['Valiron-Mayer Function Couterpoise Total Energy'] = vmfc_energy_body_dict[metadata['max_nbody']]; nbody_dict['Valiron-Mayer Function Couterpoise Interaction Energy'] = vmfc_interaction_energy. for n in nbody_range[1:]:; var_key = 'VMFC-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]. # Returns; results = {}; results['nbody'] = nbody_dict; for b in ['cp', 'nocp', 'vmfc']:; results['%s_energy_body_dict' % b] = eval('%s_energy_body_dict' % b); results['%s_energy_body_dict' % b] = {str(i) + b: j for i, j in results['%s_energy_body_dict' % b].items()}. # Figure out and build return types; return_method = metadata['bsse_type_list'][0]. if return_method == 'cp':; results['ptype_body_dict'] = cp_ptype_body_dict; results['energy_body_dict'] = cp_energy_body_dict; elif return_method == 'nocp':; results['ptype_body_dict'] = nocp_ptype_body_dict; results['energy_body_dict'] = nocp_energy_body_dict; elif return_method == 'vmfc':; results['ptype_body_dict'] = vmfc_ptype_body_dict; results['energy_body_dict'] = vmfc_energy_body_dict; else:; raise ValidationError(; ""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). if metadata['return_total_data']:; results['ret_energy'] = results['energy_body_dict'][metadata['max_nbody']]; else:; results['ret_energy'] = results['energy_body_dict'][metadata['max_nbody']]; results['ret_energy'] -= results['energy_body_dict'][1]. if metadata['ptype'] != 'energy':; if metadata['return_total_data']:; np_final_ptype = results['ptype_body_dict'][metadata['max_nbody']].copy(); else:; np_final_ptype = results['ptype_body_dict'][metadata['max_nbody']].copy(); np_final_ptype -= results['ptype_body_dict'][1]. results['ret_ptype'] = core.Matrix.from_array(np_final_ptype); else:; results['ret_ptype'] = results['ret_energy']. return results. «; hide menu. menu; sidebar; »; . Navigation. In",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:28411,Validat,ValidationError,28411,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"tage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return metadata. def _process_cbs_kwargs(kwargs: Dict) -> CBSMetadata:; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs; kwargs containing the CBS function specification. Returns; -------; cbs_metadata; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}_basis"" in kwargs:; # either both *_wfn and *_basis have to be specified; stage = {""wfn"": kwargs[f""{sn}_wfn""], ""basis"": kwargs[f""{sn}_basis""]}; elif sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis"": kwargs[f""{sn}_basis""]}; else:; # otherwise go to the next possible stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwargs:; stage[""wfn_lo""] = kwargs[f""{sn}_wfn_lesser""]; if f""cbs_{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""cbs_{sn}_alpha""]; elif f""{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""{sn}_alpha""]; cbs_metadata.append(stage); if sn =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:20545,Validat,ValidationError,20545,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,5,['Validat'],['ValidationError']
Security,"tal_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs] @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs] @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs] @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs] @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs] @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs] @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs] def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:35162,validat,validator,35162,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,1,['validat'],['validator']
Security,"tance (native geom units) nearer than which atoms not allowed.; nonphysical (bool) – Do allow masses outside an element’s natural range to pass validation?; speclabel (bool) – If True, interpret elbl as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., @13C_mine or; He4@4.01. If False, interpret elbl as only the user/tagging; extension to nucleus label, e.g. _mine or 4 in the previous examples.; missing_enabled_return (str) – {‘minimal’, ‘none’, ‘error’}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out (bool) – When True, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use False to get a json-able version. Returns. molrec (dict) – Molecule dictionary spec follows. Its principles are; (1) contents are fully validated and defaulted - no error; checking necessary,; (2) contents may be mildly redundant - atomic numbers and; element symbols present,; (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,; (4) some fields are optional (e.g., fix_symmetry) but largely; self-describing so units or fix_com must be present.; (5) apart from some mild optional fields, _all_ fields will; be present (corollary of “fully validated and defaulted”) - no; need to check for every key. in some cases like efp, keys will; appear in blocks, so pre-handshake there will be a few hint keys; and post-handshake they will be joined by full qm-like molrec.; (6) molrec should be idempotent through this function (equiv to; schema validator) but are not idempotent throughout its life. if; fields permit, frame may be changed. Future? if fields permit,; mol may be symmetrized. Coordinates and angles may change units; or range if program returns them in only one form. name (str, optional) – Label for molecule; should be valid Python identifier.; units ({‘Angstrom’, ‘Bohr’}) – Units for geom.;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external_apis-1.html:6935,validat,validated,6935,psi4manual/1.4.0/external_apis-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external_apis-1.html,5,['validat'],['validated']
Security,"tance of PubChemObj for this compound. entry[""PubChemObj""].getMoleculeString() => returns a string compatible; with PSI4's Molecule creation. class PubChemObj(cid, mf, iupac)[source]¶. getCartesian()[source]¶; Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. getMoleculeString()[source]¶; Function to obtain a molecule string through; getCartesian() or fail. getSDF()[source]¶; Function to return the SDF (structure-data file) of the PubChem object. getXYZFile()[source]¶; Function to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. name()[source]¶; Function to return the IUPAC name of the PubChem object. getPubChemResults(name)[source]¶; Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. psiexceptions¶; Module with non-generic exceptions classes. exception PsiException[source]¶; Error class for Psi. exception ValidationError(msg)[source]¶; Error called for problems with the input file. Prints; error message msg to standard output stream and output file. frac¶. frac_nuke(mol, **kwargs)[source]¶. frac_traverse(mol, **kwargs)[source]¶. ip_fitting(mol, omega_l, omega_r, **kwargs)[source]¶. molutil¶; Module with utility functions that act on molecule objects. activate(mol)[source]¶; Function to set molecule object mol as the current active molecule. dynamic_variable_bind(cls)[source]¶; Function to bind PsiMod.Molecule class. extract_cluster_indexing(mol, cluster_size=0)[source]¶; Function to returns a LIST of all subclusters of the molecule mol of; real size cluster_size. If cluster_size = 0, returns all possible; combinations of cluster size. extract_clusters(mol, ghost=True, cluster_size=0)[source]¶; Function to return all subclusters of the molecule mol of; real size cluster_size and all other atoms ghosted if ghost; equals true, all other atoms discarded if ghost is false. If; cluster_size = 0, returns all possible combinat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:1580,Validat,ValidationError,1580,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,2,['Validat'],['ValidationError']
Security,"tart purposes. This is; accomplished by the commands below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously.; To override any of these defaults for selected jobs, simply place the; appropriate commands from the snippets above in the input file itself. During; excecution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed. Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. Alternately, the scratch directory can be set through the environment; variable PSI_SCRATCH (overrides ~/.psi4rc settings).; The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and Boost; Threads for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or other threaded BLAS. Less; than 20% of the threaded code in PSI4 uses OpenMP, the rest is handled by; parallel DGEMM and other library routines. From this point forward, it is; assumed that you have compiled PSI4 with OpenMP and MKL (Note that it is; possible to use g++ or another compiler and yet still link against MKL).; Control of threading in PSI4 can be accomplished at",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/external-1.html:3809,access,accessible,3809,psi4manual/4.0b2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/external-1.html,2,['access'],['accessible']
Security,"tash these since only read, never reset; cast = False; if core.has_option_changed('SCF', 'BASIS_GUESS'):; cast = core.get_option('SCF', 'BASIS_GUESS'); if p4util.yes.match(str(cast)):; cast = True; elif p4util.no.match(str(cast)):; cast = False. if cast:. # A use can set ""BASIS_GUESS"" to True and we default to 3-21G; if cast is True:; guessbasis = '3-21G'; else:; guessbasis = cast; core.set_global_option('BASIS', guessbasis). castdf = core.get_option('SCF', 'SCF_TYPE') == 'DF'. if core.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = core.get_option('SCF', 'DF_BASIS_GUESS'); if p4util.yes.match(str(castdf)):; castdf = True; elif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_local_option('SCF', 'SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, (unicode, str)):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:30715,Validat,ValidationError,30715,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"tch up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_list = inputfile.split(""\n""); set_re = re.compile(r'^(\s*?)set\s+(?:([-,\w]+)\s+)?(\w+)[\s=]+\[.*', re.IGNORECASE); newinput = """"; while len(input_list):; line = input_list[0]; if set_re.match(line):; # We've found the start of a set matrix [ .... line - hand it off for more checks; newinput += parse_multiline_array(input_list); else:; # Nothing to do - just add the line to the string; newinput += ""%s\n"" % (input_list.pop(0)); return newinput. [docs]def process_input(raw_input: str, print_level: int = 1) -> str:; """"""Function to preprocess *raw input*, the text of the input file, then; parse it, validate it for format, and convert it into legitimate Python. Does a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user's .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed *raw_input*. Parameters; ----------; raw_input; Input in a mixture of Python and PSIthon syntax.; print_level; *raw_input* is printed to the output file unless *print_level* =0. """"""; # Check if the infile is actually an outfile (yeah we did); psi4_id = re.compile(r'Psi4: An Open-Source Ab Initio Electronic Structure Package'); if re.search(psi4_id, raw_input):; input_lines = raw_input.split(""\n""); input_re = re.compile(r'^\s*?\=\=> Input File <\=\='); input_start = -1; for line_count in range(len(input_lines)):; line = input_lines[line_count]; if re.match(i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/inputparser.html:18203,validat,validate,18203,psi4manual/1.7.x/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/inputparser.html,1,['validat'],['validate']
Security,"tch(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2angstroms; fileY /= psi_bohr2angstroms; fileZ /= psi_bohr2angstroms. # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Molecule::init_with_xyz: Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out(self):; """"""Print the molecule.; (method name in libmints is print). >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:24775,Validat,ValidationError,24775,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"te']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:36957,Validat,ValidationError,36957,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"te']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); core.print_out(""\n""). # write index of calcs to output file; if db_mode == 'continuous':; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternative",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:15201,Validat,ValidationError,15201,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,2,['Validat'],['ValidationError']
Security,"te']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if db_mode == 'continuous':; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternative",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:15081,Validat,ValidationError,15081,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"te(['PRINT']); core.set_global_option(""PRINT"", 0). # If we force c1 copy the active molecule; scf_molecule.update_geometry(); core.print_out(""""""\n A requested method does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n\n""""""); c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); c1_basis = core.BasisSet.build(c1_molecule, ""ORBITAL"", core.get_global_option('BASIS'), quiet=True); tmp = scf_wfn.c1_deep_copy(c1_basis); c1_jkbasis = core.BasisSet.build(c1_molecule, ""DF_BASIS_SCF"",; core.get_global_option(""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'), quiet=True); tmp.set_basisset(""DF_BASIS_SCF"", c1_jkbasis); c1_optstash.restore(); return tmp. def run_dct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant theory calculation. """""". if (core.get_global_option('FREEZE_CORE') == 'TRUE'):; raise ValidationError('Frozen core is not available for DCT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). if (core.get_global_option(""DCT_TYPE"") == ""DF""):; core.print_out("" Constructing Basis Sets for DCT...\n\n""); aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_DCT"",; core.get_global_option(""DF_BASIS_DCT""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_DCT"", aux_basis). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis); dct_wfn = core.dct(ref_wfn). else:; # Ensure IWL files have been written for non DF-DCT; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); dct_wfn = core.dct(ref_wfn). for k, v in dct_wfn.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:51557,Validat,ValidationError,51557,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"te; . geometry optimization. translate() LibmintsMolecule method. TRANSLATE_PSI4 (CFOUR). transpose() in module qcdb.vecutil. SymmetryOperation method. TRIPLES_ALGORITHM (PSIMRCC). TRIPLES_DIIS (PSIMRCC). TRIPLES_IABC_TYPE (DFOCC). TRIPLES_LOW_MEMORY (FNOCC). TURN_ON_ACTV (MCSCF). TWO-ELECTRONENERGY. type() CartesianEntry method. NumberValue method. VariableValue method. ZMatrixEntry method. U. UHF_NOONS (SCF). UNCP-CORRECTED2-BODYINTERACTIONENERGY. unique() LibmintsMolecule method. unit() SymmetryOperation method. SymRep method. units; . molecule. UNITS (GLOBALS). units() LibmintsMolecule method. up InPsight attribute. UPDATE (DETCI). update() OrderedDict method. PreservingDict method. update_geometry() InPsight method. LibmintsMolecule method. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). useful() in module qcdb.dbproc. V. val() in module qcdb.textables. VAL_EX_LEVEL (DETCI). valerr() in module qcdb.mpl. valid_atom_map() LibmintsMolecule method. ValidationError, [1]. values() OrderedDict method. variable_to_string() NumberValue method. VariableValue method. VariableValue class in qcdb.libmintscoordentry. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). vibrational analysis; . function call. output. viewitems() OrderedDict method. viewkeys() OrderedDict method. viewvalues() OrderedDict method. visualization, [1]. VMDPATH. vpt2() in module procedures.wrappers_cfour. vpt2_instructions() in module procedures.wrappers_cfour. vpt2_reaprun_files() in module procedures.wrappers_cfour. vpt2_sow_files() in module procedures.wrappers_cfour. W. WABEI_LOWDISK (CCHBAR). WebMO. WFN (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCSORT). (CCTRANSORT). (CCTRIPLES). (DETCI). (GLOBALS). (SCF). (TRANSQT2). WFN_SYM (MCSCF). (PSIMRCC). WFN_TYPE (DFOCC). (OCC). which_comp() CharacterTable method. which_irrep() CharacterTable method. width InPsight attribute. WrappedDatabase class in qcdb.dbwrap. wrapper_autofrag module. wrapper_database module",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:135052,Validat,ValidationError,135052,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['Validat'],['ValidationError']
Security,"ted when RMSD condition met, saving time.; If float, convcrit at which search for minimium truncates.; run_to_completion; Run reorderings to completion (past RMSD = 0) even if unnecessary because; `mols_align=True`. Used to test worst-case timings.; algorithm; {'hungarian_uno', 'permutative'}; When `atoms_map=False`, screening algorithm for plausible atom mappings.; `permutative` suitable only for small systems.; uno_cutoff; TODO; run_mirror; Run alternate geometries potentially allowing best match to `rgeom`; from mirror image of `cgeom`. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns; -------; float, tuple; First item is RMSD [A] between `rgeom` and the optimally aligned; geometry computed.; Second item is a AlignmentMill with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from `cgeom` and the optimally aligned geometry. """"""; # validation; if rgeom.shape != cgeom.shape or rgeom.shape[1] != 3:; raise ValidationError(""""""natom doesn't match: {} != {}"""""".format(rgeom.shape, cgeom.shape)); nat = rgeom.shape[0]; if atoms_map and runiq is None and cuniq is None:; runiq = np.array([""""] * nat); cuniq = np.array([""""] * nat); if sorted(runiq) != sorted(cuniq):; raise ValidationError(""""""atom subclasses unequal:\n {}\n {}"""""".format(runiq, cuniq)). if run_mirror:; # use aligner to check if system and its (xz-plane) mirror image are; # superimposible and hence whether its worth doubling the number of Kabsch; # runs below to check for mirror-image matches; mcgeom = np.copy(cgeom); mcgeom[:, 1] *= -1.0; exact = 1.0e-6; mrmsd, msolution = B787(; mcgeom,; cgeom,; cuniq,; cuniq,; do_plot=False,; verbose=0,; atoms_map=False,; mols_align=exact,; run_mirror=False,; uno_cutoff=0.1,; ); superimposable = mrmsd < exact; if verbose >= 1 and superimposable:; print(; ""Not testing for mirror-image matches (despite `run_mirror`) since system and its mirror are superimposable""; ). # initialization; best_rmsd = 100.0 # [A]; ocou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html:3762,Validat,ValidationError,3762,psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,3,['Validat'],['ValidationError']
Security,"ted, and each line in the loop has to be indented; by the same amount. The first line in the loop, dimer.R = R,; sets the Z-matrix variable R of the molecule called dimer; to the R value extracted from the Rvals array. The next line,; ecp[R] = cp('ccsd(t)'), computes the counterpoise-corrected; CCSD(T) energy and places it in the ecp dictionary with R as; the index. Note we didn’t need to specify ghost atoms, and we didn’t need; to call the monomer and dimer computations separately. The built-in; Psithon function cp() does it all for us, automatically.; And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol, which is; defined in Sec. Scratch Files and the ~/.psi4rc File. Notice the loop over to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. Table Of Contents. A PSI4 Tutorial; Basic Input File Structure; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:19278,access,accessed,19278,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,8,['access'],['accessed']
Security,"tegrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. :returns: None. :raises: ValidationError when SCF wavefunction is not RHF. :type wfn: :py:class:`~psi4.core.Wavefunction`. :param wfn: set of molecule, basis, orbitals from which to generate cube files; :param fname: name of the integrals file, defaults to INTDUMP; :param oe_ints: list of additional one-electron integrals to save to file. So far only EIGENVALUES is a valid option. :examples:. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_socc.sum(); irrep_map = _irrep_map(wfn). wfn_irrep = 0; for h, n_socc in enumerate(active_socc):; if n_socc % 2 == 1:; wfn_irrep ^= h. core.print_out('Writing integrals in FCIDUMP format to ' + fname + '\n'); # Generate FCIDUMP header; header = '&FCI\n'; header += 'NORB={:d},\n'.format(nbf); header += 'NELEC={:d},\n'.format(nelectron); header += 'MS2={:d},\n'.format(wfn.nalpha() - wfn.nbeta()); header += 'UHF=.{}.,\n'.format(not wfn.same_a_b_orbs()).upper(); orbsym = ''; for h in range(active_mopi.n()):; for n in range(f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:2713,Validat,ValidationError,2713,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,3,['Validat'],['ValidationError']
Security,"tein distance between two strings. print_stderr(stuff)[source]¶; Function to print stuff to standard error stream. print_stdout(stuff)[source]¶; Function to print stuff to standard output stream. Module with non-generic exceptions classes. exception CSXError(msg)[source]¶; Error called when CSX generation fails. exception Dftd3Error(msg)[source]¶. exception ManagedMethodError(circs)[source]¶. exception ParsingError(msg)[source]¶; Error called for problems parsing a text file. Prints error message; msg to standard output stream and output file. exception PsiException[source]¶; Error class for Psi. exception PsiImportError(msg)[source]¶; Error called for problems import python dependencies. Prints error message; msg to standard output stream and output file. exception TestComparisonError(msg)[source]¶; Error called when a test case fails due to a failed; compare_values() call. Prints error message msg to standard; output stream and output file. exception ValidationError(msg)[source]¶; Error called for problems with the input file. Prints; error message msg to standard output stream and output file. Module to provide mechanism to store and restore option states in driver. class OptionState(option, module=None)[source]¶; Class to store the state of a single option. If module given, the option; value and has_changed value is stored for global, local to module, and used by; module scopes; otherwise (used for BASIS keywords), only global scope is stored.; Class can store, print, and restore option values.; >>> OptionState('SCF_TYPE', 'SCF'). >>> print(OptionState('DF_BASIS_MP2')). restore()[source]¶. class OptionsState(*largs)[source]¶; Class to contain multiple OptionsState() objects.; Used in python driver functions to collect several options before altering; them, then restoring before function return.; >>> optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'REFERENCE']). >>> print(optstash). >>> optstash.restore(). re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:126958,Validat,ValidationError,126958,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['Validat'],['ValidationError']
Security,"tensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Advanced Functional Use and Manipulation¶; New DFT functionals can be created from scratch from within the input; file and accessed using the dft_functional keyword argument in the; energy call:; # DFT Custom Functional. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis sto-3g; dft_spherical_points 302; dft_radial_points 99; reference rks; }. pbe0 = {; ""name"": ""my_PBE0"",; ""x_functionals"": {""GGA_X_PBE"": {""alpha"": 0.75}},; ""x_hf"": {""alpha"": 0.25},; ""c_functionals"": {""GGA_C_PBE"": {}}; }. func_call = energy('SCF', dft_functional=pbe0). # as PBE0 is a pre-defined functional, the call above is equivalent to both below:; func_call = energy('SCF', dft_functional=""PBE0""); func_call = energy('PBE0'). Supported keywords include:. name: string, name of the functional. for custom defined functionals used for printing only.; xc_functionals: dict, definition of a complete (X + C) functional based in LibXC name; x_functionals: dict, definition of exchange functionals using LibXC names; c_functionals: dict, definition of correlation functionals using LibXC names; x_hf: dict, parameters dealing ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dft.html:31032,access,accessed,31032,psi4manual/master/dft.html,https://psicode.org,https://psicode.org/psi4manual/master/dft.html,9,['access'],['accessed']
Security,"ter dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. fci-dipole; 6-31G H2O Test FCI Energy Point. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. rasci-h2o; RASCI/6-31G** H2O Energy Point. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. numpy-array-interface; Numpy interface testing. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. pywrap-align; apply linear fragmentation algorithm to a water cluster. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:19923,validat,validate,19923,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['validat'],['validate']
Security,"ter_omega_to_real(vibonly['omega'].data))); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.get_variable('CURRENT ENERGY'), wfn); else:; return core.get_variable('CURRENT ENERGY'). [docs]def vibanal_wfn(wfn, hess=None, irrep=None, molecule=None, project_trans=True, project_rot=True):. if hess is None:; nmwhess = np.asarray(wfn.hessian()); else:; nmwhess = hess. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False),; 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out('Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess, geom, m, wfn.basisset(), irrep_labels,; project_trans=project_trans, project_rot=project_rot); vibrec.update({k: qca.to_dict() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:90796,Validat,ValidationError,90796,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for use in input files."""""". __all__ = [; ""copy_file_to_scratch"",; ""copy_file_from_scratch"",; ""cubeprop"",; ""get_memory"",; ""libint2_configuration"",; ""libint2_print_out"",; ""oeprop"",; ""set_memory"",; ]. import os; import re; import sys; import warnings; from typing import Dict, List, Union. from psi4 import core; from psi4.driver.procrouting import *; from .exceptions import ValidationError; from .prop_util import *. [docs]; def oeprop(wfn: core.Wavefunction, *args: List[str], **kwargs):; """"""Evaluate one-electron properties. :returns: None. :param wfn: set of molecule, basis, orbitals from which to compute properties. :param args:. Arbitrary-number of properties to be computed from *wfn*.; See :ref:`Available One-Electron Properties <table:oe_features>`. :type title: str; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop). # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html:1512,Validat,ValidationError,1512,psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security,"tes, while OFF (=1) retains the rotational degrees of freedom. At a stationary point on the potential energy surface, both options will give equivalent harmonic force fields, but OFF should be used at non-stationary points. Type: string; Possible Values: ON, OFF; Default: ON. CFOUR_FD_STEPSIZE (CFOUR)¶CFOUR — Specifies the step length in mass-weighted coordinates (in \(10^{-4} amu^{1/2} bohr\) ) used in generating the force constant matrix by finite difference of Cartesian gradients. Type: integer; Default: 5. CFOUR_FD_USEGROUP (CFOUR)¶CFOUR — In finite difference calculations using the FINDIF option, this keyword specifies the point group to be used in generating the symmetry-adapted vibrational coordinates. FULL (= 0) specifies the full molecular point group, COMP (= 1) specifies the Abelian subgroup used in the electronic structure calculation. Type: string; Possible Values: FULL, COMP; Default: FULL. CFOUR_FILE_RECSIZ (CFOUR)¶CFOUR — This specifies the physical length (in integer words) of the records used in the word-addressable direct access files used by CFOUR. This value should always be chosen as a multiple of 512 bytes, as your local system manager certainly understands. Type: integer; Default: 2048. CFOUR_FILE_STRIPE (CFOUR)¶CFOUR — This option allows the splitting of files. Input is required in the form N1/N2/N3/N4/N5, where N1, N2, N3, N4, and N5 specify the number of files in which MOINTS, GAMLAM, MOABCD, DERINT, and DERGAM are split, respectively. Type: string; Default: 0/0/0/0/0. CFOUR_FINITE_PERTURBATION (CFOUR)¶CFOUR — Specifies the field strength for a perturbation (defined within a %perturbation section). The value must be given as an integer, and the field strength used by the program will be then the value of the keyword \(\times 10^{-6}\). Type: integer; Default: 0. CFOUR_FOCK (CFOUR)¶CFOUR — This option is used to control the algorithm used for construction of the Fock matrix in SCF calculations. PK (=0) uses the PK-supermatrix approach while ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:43671,access,access,43671,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,9,['access'],['access']
Security,"th the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:11665,access,access,11665,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['access'],['access']
Security,"the H2O molecule. scf-coverage; Lithium test for coverage. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. cbs-parser; mtd/basis syntax examples. casscf-fzc-sp; CASSCF/6-31G** energy point. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. cbs-xtpl-func; optimization with method defined via cbs. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. fci-h2o-2; 6-31G H2O Test FCI Energy Point. cbs-xtpl-energy; Extrapolated water energies - density-fitted version. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. tdscf-6; td-camb3lyp with DiskDF and method/basis specification. dfccs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:5337,validat,validate,5337,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['validat'],['validate']
Security,"the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description=""AtomicResult return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs] @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs] @validator(""method""); def set_method(cls, method):; return method.lower(). [docs] @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs] def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": {; ""stdout"": True,; },; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs] def compute(self, client: Optional[""FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True; from qcportal.models import KeywordSet, Molecule. # Build the keywords; keyword_id = client.add_keywords([KeywordSet(values=self.keywords)])[0]. # Build the molecule; mol = Molecule(**self.molecule.to_schema(dtype=2)). r = client.add_compute(; ""psi4"", self.method, self.b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/task_base.html:3073,validat,validator,3073,psi4manual/1.6.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/task_base.html,1,['validat'],['validator']
Security,"the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; from __future__ import absolute_import; import re; import os; import math; import warnings; import pickle; import copy; import collections; from psi4.driver import constants; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`share/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedde",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:1699,access,access,1699,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,1,['access'],['access']
Security,"the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs] def build_tasks(self, mb_computer: SubTa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:34676,validat,validator,34676,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,1,['validat'],['validator']
Security,"the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. matrix2; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. casscf-sp; CASSCF/6-31G** energy point. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. oremp-grad1; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-h2o; RASCI/6-31G** H2O Energy Point. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:7165,validat,validate,7165,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['validat'],['validate']
Security,"the; output filename defaults to the the input filename (subtracting; any ”.in” or ”.dat” suffix) plus ”.out”. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -s <name>, --scratch <name>¶; This overrides the value of PSI_SCRATCH and provides; a path to the location of scratch files. --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to Psi4 for available templates. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -V, --version¶; Print version information.; >>> psi4 --version; 0.4.262. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence Psi4‘s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; Configuring Psi4 through PSIPATH is preferred; to modifying this environment variable. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that Psi4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh; >>> setenv PSI_SCRATCH /scra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:15463,access,access,15463,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['access'],['access']
Security,"ther they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. fci-h2o; 6-31G H2O Test FCI Energy Point. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. mbis-5; MBIS calculation on ZnO. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cbs-parser; mtd/basis syntax examples. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. fci-dipole; 6-31G H2O Test FCI Energy Point. scf-response3; UHF Dipole Polarizability Test. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. cc13a; UHF-CCSD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:34288,validat,validate,34288,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['validat'],['validate']
Security,"this appears in the full atom list. everything()[source]¶. is_computed()[source]¶; Whether the current atom’s coordinates are up-to-date. is_equivalent_to(other)[source]¶; Whether this atom has the same mass and ghost status as atom other.; Also compares basis set assignment down to nbf(), has_puream() level; with code borrowed from Robert M. Parrish’s SAD guess in Psi4. is_ghosted()[source]¶; Whether the current atom is ghosted or not. label()[source]¶; The atom label. mass()[source]¶; The atomic mass of the current atom. static r(a1, a2)[source]¶; Computes the distance between two sets of coordinates. set_basisset(name, role='BASIS')[source]¶; Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. set_ghosted(gh)[source]¶; Flag the atom as either ghost or real. set_shell(bshash, key='BASIS')[source]¶; Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. shell(key='BASIS')[source]¶; Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. shells()[source]¶; Returns shells sets to atom map. symbol()[source]¶; The atomic symbol. class CoordValue(fixed=False, computed=False)[source]¶; An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. everything()[source]¶. fixed()[source]¶; Get whether the coordinate value is fixed or not. invalidate()[source]¶; Flag the current value as outdated. set_fixed(fixed)[source]¶; Set whether the coordinate value is fixed or not. class NumberValue(value, fixed=False)[source]¶; Specialization of CoordValue that is simply a number to be stored. clone()[source]¶; Returns new, independent NumberValue object. compute()[source]¶; Computes value of coordinate from member data. everythi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:115969,hash,hash,115969,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['hash'],['hash']
Security,"through conda install libefp -c psi4.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. Previous bullet had details. To build PSI4 from source and use; libefp from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source psi4/psi4/share/psi4/efpfrag. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are searched; for first in the current directory, next in the paths of PSIPATH, and; finally in built-in library. If PSI4 is unable to find the; fragment, an error will be reported. Note; When constructing new fragment files, the name of the name of the; file should be lowercase and have extension .efp. The molecule name; within the file, e.g., $NH3 must correspond to the name of the; fragment file. Molecule Specification¶; EFP fragment geometries are specified alongside the quantum mechanical; (QM) molecule and make use of the -- fragment separation scheme; described here. Each EFP fragment has its own; fragment section that includes the label efp, the name of the file; fragname from which EFP parameters are to be read, and the position; specification for the fragment in one of two ways, XYZABC or POINTS. For; XYZABC, the fragment specification is all",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/libefp-1.html:1919,access,accessible,1919,psi4manual/1.2.1/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/libefp-1.html,4,['access'],['accessible']
Security,"timization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/opt-1.html:1782,access,accesses,1782,psi4manual/1.1.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/opt-1.html,2,['access'],['accesses']
Security,"tion atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). # Establish function to call (only energy makes sense for cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Esta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:30313,Validat,ValidationError,30313,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"tion atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). # Establish function to call (only energy makes sense for cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Esta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:29960,Validat,ValidationError,29960,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"tion called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:85478,Validat,ValidationError,85478,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,4,['Validat'],['ValidationError']
Security,"tion code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function.; # Establish function to call; if not('xx_func' in kwargs):; if ('func' in kwargs):; kwargs['xx_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['xx_func'] = energy; func = kwargs['xx_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper xx is unhappy to be calling function \'%s\'.' % (func.__name__)). If specific interoperabilities are known, code them in. For example, if xx shouldn’t call db, add the last two lines above to the xx function. If db shouldn’t call xx, add the following two lines below to the db function.; if (func is xx):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'.' % (func.__name__)). Create a multipart test case that runs some intercalls between your function and others (akin to pywrap_all). In trials, permute the order of calls a few times to expose any calls that don’t clean up after themselves and need further attention. When all is validated, add your findings to the great Permitted nesting of Psithon functions table in the documentation. Previous topic; Plugins: Adding New Functionality to Psi4; Next topic; Documentation. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Contributions: Intro to Programming in Psi4 ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/bestpractices_py-1.html:5929,Validat,ValidationError,5929,psi4manual/1.0.0/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/bestpractices_py-1.html,6,"['Validat', 'expose', 'validat']","['ValidationError', 'expose', 'validated']"
Security,"tion of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.frombuffer(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs) -> core.Matrix:; """"""Chains dot products together from a series of Psi4 Matrix classes.; Uses :func:`~psi4.core.doublet`. Parameters; ----------; args; Arbitrary number of :class:`~psi4.core.Matrix` arguments to be; multiplied.; trans; Optional iterable of booleans of length number of `args` to designate; transposes, if any. """"""; trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[n + 1]). return ret. def _irrep_access(self, *args, **kwargs):; """"""; Warns user when iterating/accessing an irrepped object.; """"""; raise ValidationError(""Attempted to access by index/iteration a Psi4 data object that supports multiple""; "" irreps. Please use .np or .nph explicitly.""). # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_serial = _to_serial; core.Matrix.from_serial = classmethod(_from_serial); core.Matrix.chain_dot = _chain_dot; core.Matrix.__iter__ = _irrep_access; core.Matrix.__getitem__ = _irrep_access. # Vector attributes; core.Vector.from_array = classmethod(array_to_matrix); core.Vector.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:14307,access,accessing,14307,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,2,['access'],['accessing']
Security,"tion of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH`. """"""; # Validate arguments; if self is None:; self = psi4.get_active_molecule(). dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all par",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:8262,Validat,ValidationError,8262,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"tion of user fields happens through typing and validator functions, so no class __init__ needed. @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs] def build_tasks(self, mb_computer: SubTaskComputers, mc_level_idx: int, **kwargs: Dict[str, Any]) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*. Parameters; ----------; mb_computer; Class of TaskComputers to instantiate and add to self.task_list. Usually AtomicComputer but may be other when wrappers are layered.; mc_level_idx; Position in field self.nbodies_per_mc_level used to obtain ``nbodies``, the list of n-body; levels (e.g., `[1]` or `[1, 2]` or `[""supersystem""]`) to which the modelchem speci",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:35302,validat,validator,35302,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,1,['validat'],['validator']
Security,"tion or atom mapping) and expected final RMSD = 0.; If `True`, procedure is truncated when RMSD condition met, saving time.; If float, convcrit at which search for minimium truncates.; run_to_completion; Run reorderings to completion (past RMSD = 0) even if unnecessary because; `mols_align=True`. Used to test worst-case timings.; algorithm; {'hungarian_uno', 'permutative'}; When `atoms_map=False`, screening algorithm for plausible atom mappings.; `permutative` suitable only for small systems.; uno_cutoff; TODO; run_mirror; Run alternate geometries potentially allowing best match to `rgeom`; from mirror image of `cgeom`. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns; -------; float, tuple; First item is RMSD [A] between `rgeom` and the optimally aligned; geometry computed.; Second item is a AlignmentMill with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from `cgeom` and the optimally aligned geometry. """"""; # validation; if rgeom.shape != cgeom.shape or rgeom.shape[1] != 3:; raise ValidationError(""""""natom doesn't match: {} != {}"""""".format(rgeom.shape, cgeom.shape)); nat = rgeom.shape[0]; if atoms_map and runiq is None and cuniq is None:; runiq = np.array([""""] * nat); cuniq = np.array([""""] * nat); if sorted(runiq) != sorted(cuniq):; raise ValidationError(""""""atom subclasses unequal:\n {}\n {}"""""".format(runiq, cuniq)). if run_mirror:; # use aligner to check if system and its (xz-plane) mirror image are; # superimposible and hence whether its worth doubling the number of Kabsch; # runs below to check for mirror-image matches; mcgeom = np.copy(cgeom); mcgeom[:, 1] *= -1.0; exact = 1.0e-6; mrmsd, msolution = B787(; mcgeom,; cgeom,; cuniq,; cuniq,; do_plot=False,; verbose=0,; atoms_map=False,; mols_align=exact,; run_mirror=False,; uno_cutoff=0.1,; ); superimposable = mrmsd < exact; if verbose >= 1 and superimposable:; print(; ""Not testing for mirror-image matches (despite `run_mirror`) since system and i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html:3689,validat,validation,3689,psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,3,['validat'],['validation']
Security,"tion('CCLAMBDA', 'WFN', 'CCSD_T'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). core.cchbar(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). derivobj = core.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); core.set_local_option('CCSORT', 'WFN', 'BCCD'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); core.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); core.set_local_option('CCSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.get_variable('BRU",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:72815,Validat,ValidationError,72815,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"tion('CCLAMBDA', 'WFN', 'CCSD_T'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). core.cchbar(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). derivobj = core.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); core.set_local_option('CCSORT', 'WFN', 'BCCD'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); core.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); core.set_local_option('CCSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:71921,Validat,ValidationError,71921,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"tion('CCLAMBDA', 'WFN', 'CCSD_T'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). core.cchbar(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). derivobj = core.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); core.set_local_option('CCSORT', 'WFN', 'BCCD'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); core.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); core.set_local_option('CCSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_option('SCF', 'SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.get_variable('BRU",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:68853,Validat,ValidationError,68853,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"tion:: Get rid of active molecule lines- should be handled in energy. """"""; molecule = PsiMod.get_active_molecule(); if 'molecule' in kwargs:; molecule = kwargs.pop('molecule'). if not molecule:; raise ValueNotSet('no molecule found'). PsiMod.scf(). return PsiMod.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL'); b_user_fctl = PsiMod.has_option_changed('DFT_FUNCTIONAL'); user_ref = PsiMod.get_local_option('SCF', 'REFERENCE'); b_user_ref = PsiMod.has_option_changed('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). returnvalue = run_scf(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'). return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF ref",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:17165,Validat,ValidationError,17165,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"tionConvergenceError(""""""geometry optimization"""""", n - 1, wfn). [docs]def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Hessian: Cannot specify bsse_type for hessian yet.""). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. if gradient_type != 'conventional':; raise ValidationError(""Hessian: Does not yet support more advanced input or custom functions.""). lowername = name.lower(). # Check if this is a CBS extrapolation; if ""/"" in lowername:; return driver_cbs._cbs_gufunc('hessian', lowername, **kwargs). return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:67227,Validat,ValidationError,67227,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"tionError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; # cbs_delta3_wfn_lesser = kwargs.get('delta3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # else:; # cbs_delta4_wfn_lesser = cbs_delta3_wfn; # if not (cbs_delta4_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)); #; # # Establish method for fifth delta correction energy; # if 'delta5_wfn' in kwargs:; # do_delta5 = True; # cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); # if not (cbs_delta5_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)); #; # if 'delta5_wfn_lesser' in kwargs:; # cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); # else:; # cbs_delta5_wfn_lesser = cbs_delta4_wfn; # if not (cbs_delta5_wfn_lesser in VARH.keys(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:33546,Validat,ValidationError,33546,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"tion_from_molecules debug info'); print('\nPatm', Patm, 'Catm', Catm, 'Pwhite', Pwhite, \; 'Cwhite', Cwhite, 'sameElem', sameElem, 'allowed', allowed, \; '\nCgeom[Catm]: ', Cgeom[Catm], '\nPgeom[Patm]: ', Pgeom[Patm], \; '\nmapMat', mapMat); print('\nPgeom: '); for item in Pgeom:; print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])); print('\nCgeom: '); for item in Cgeom:; print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])); print(self); raise ValidationError(""""""Atom unreconcilable between QC programs.""""""). self.Cexchflip = exfp; self.Catommap = mapMat; # Note that this is resetting the geom but not the atoms, so c4mol.print_out() is deceptive; c4mol.rotate(exfp); new_geom = []; for at in range(Nat):; new_geom.append(Cgeom[mapMat[at]]); c4mol.set_geometry(new_geom). # One last check that p4mol and c4mol align; Pgeom = p4mol.geometry(); Cgeom = c4mol.geometry(). if not all([all([abs(Cgeom[at][ax] - Pgeom[at][ax]) < COORD_ZERO for ax in range(3)]) for at in range(Nat)]):; raise ValidationError(""""""Geometries unreconcilable between QC programs:\n P4 %s\n C4 %s"""""" % (Pgeom, Cgeom)). [docs] def transform_coordinates(self, coord):; """""". """"""; #print self; print(""Original""); coord.print_out(). coord.translate(scale(self.Cshift, -1.0)); print(""Shift""); coord.print_out(). coord.rotate(self.Crotate); print(""Rotate""); coord.print_out(). coord.rotate(self.Cexchflip); print(""ExchFlip""); coord.print_out(). geom = coord.geometry(); new_geom = []; for at in range(coord.natom()):; new_geom.append(geom[self.Catommap[at]]); coord.set_geometry(new_geom); print(""AtomMap""); coord.print_out(). coord.rotate(transpose(self.Protate)); print(""P4 Rotate""); coord.print_out(). coord.translate(self.Pshift); print(""P4 Shift""); coord.print_out(). [docs] def transform_coordinates2(self, coord):; """""". """"""; geom = coord.geometry(). # print self; # print ""Original""; # for item in geom:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). # ?????; #coord.translate(scale(self.Cs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html:10171,Validat,ValidationError,10171,psi4manual/1.0.0/_modules/qcdb/orient.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html,1,['Validat'],['ValidationError']
Security,"tionary, or throw error.; np_out (bool) – When True, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use False to get a json-able version. Returns. molrec (dict) – Molecule dictionary spec follows. Its principles are; (1) contents are fully validated and defaulted - no error; checking necessary,; (2) contents may be mildly redundant - atomic numbers and; element symbols present,; (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,; (4) some fields are optional (e.g., fix_symmetry) but largely; self-describing so units or fix_com must be present.; (5) apart from some mild optional fields, _all_ fields will; be present (corollary of “fully validated and defaulted”) - no; need to check for every key. in some cases like efp, keys will; appear in blocks, so pre-handshake there will be a few hint keys; and post-handshake they will be joined by full qm-like molrec.; (6) molrec should be idempotent through this function (equiv to; schema validator) but are not idempotent throughout its life. if; fields permit, frame may be changed. Future? if fields permit,; mol may be symmetrized. Coordinates and angles may change units; or range if program returns them in only one form. name (str, optional) – Label for molecule; should be valid Python identifier.; units ({‘Angstrom’, ‘Bohr’}) – Units for geom.; input_units_to_au (float, optional) – If units=’Angstrom’, overrides consumer’s value for [A]–>[a0] conversion.; fix_com (bool) – Whether translation of geom is allowed or disallowed.; fix_orientation (bool) – Whether rotation of geom is allowed or disallowed.; fix_symmetry (str, optional) – Maximal point group symmetry which geom should be treated. Lowercase.; geom (ndarray of float) – (3 * nat, ) Cartesian coordinates in units.; elea (ndarray of int) – (nat, ) Mass number for atoms, if known isotope, else -1.; elez (ndarray of int) – (nat, ) Number of protons, nuclear charge for atoms.; elem (ndarray of str) – (nat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external_apis-1.html:7686,validat,validator,7686,psi4manual/1.4.0/external_apis-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external_apis-1.html,5,['validat'],['validator']
Security,"tions['GTHRESH'].items():; text += """""",%s=%s"""""" % (opt, val['value']); text += '\n\n'. for item in proc:; if len(options[item.upper()]) > 0:; text += """"""{%s%s}\n"""""" % (item, options[item.upper()]['OPTIONS']['value']); else:; text += """"""%s\n"""""" % (item). if text:; text += '\n'. return text. [docs]def muster_modelchem(name, dertype, mol):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)); proc = []. if dertype == 0:; pass; else:; raise ValidationError(""""""Requested Psi4 dertype %d is not available."""""" % (dertype)). if lowername == 'mp2':; pass; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'direct'; options['MP2']['MP2_TYPE']['value'] = 'conv'; text += """"""mp2')\n\n"""""". elif lowername == 'ccsd(t)-f12':; proc.append('rhf'); proc.append('ccsd(t)-f12'); options['CCSD(T)-F12']['OPTIONS']['value'] = ',df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb'. elif lowername == 'ccsd(t)-f12c':; proc.append('rhf'); proc.append('ccsd(t)-f12c'); options['CCSD(T)-F12C']['OPTIONS']['value'] = ',df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb'. elif lowername == 'ccsd(t)-f12-optri':; proc.append('rhf'); proc.append('ccsd(t)-f12'); options['CCSD(T)-F12']['OPTIONS']['value'] = ',df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=jkfitc'. elif lowername == 'ccsd(t)-f12-cabsfit':; proc.append('rhf'); proc.append('ccsd(t)-f12'); options['CCSD(T)-F12']['OPTIONS']['value'] = ',df_basis=jkfitc,df_basis_exch=jkfit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:21047,Validat,ValidationError,21047,psi4manual/1.0.0/_modules/qcdb/molpro2.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html,1,['Validat'],['ValidationError']
Security,"tip=""Error called when the specified value of *option* requires some""];; ""PsiException"" -> ""PastureRequiredError"" [arrowsize=0.5,style=""setlinewidth(0.5)""];; ""PsiException"" [fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",tooltip=""Error class for Psi.""];; ""PsiImportError"" [fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",tooltip=""Error called for problems import python dependencies. Prints error message""];; ""PsiException"" -> ""PsiImportError"" [arrowsize=0.5,style=""setlinewidth(0.5)""];; ""QMMM"" [fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)""];; ""Table"" [fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",tooltip=""Class defining a flexible Table object for storing data.""];; ""TestComparisonError"" [fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",tooltip=""Error called when a test case fails due to a failed""];; ""PsiException"" -> ""TestComparisonError"" [arrowsize=0.5,style=""setlinewidth(0.5)""];; ""ValidationError"" [fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",tooltip=""Error called for problems with the input file. Prints""];; ""PsiException"" -> ""ValidationError"" [arrowsize=0.5,style=""setlinewidth(0.5)""];; }. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. Navigation. Index. modules    .    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:204907,Validat,ValidationError,204907,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,4,['Validat'],['ValidationError']
Security,"tistics of last iteration. See keys above. """"""; message: str; iteration: int; wfn: core.Wavefunction; what: str; stats: Dict[str, Any]. def __init__(self, iteration: int, wfn: core.Wavefunction, what: str, stats: Dict[str, Any]):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. # CSXError ceased to be used by v1.4. Class removed by v1.7; # class CSXError(PsiException):. [docs]; class MissingMethodError(ValidationError):; """"""Error called when requested level or theory or derivative level are not; available. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]; class ManagedMethodError(PsiException):; """"""Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters; ----------; circs; List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. Attributes; ----------; message; Human readable string describing the exception.; stats; Dictionary of conditions for which method request was made.; Keys are:. - driver : {""energy"", ""gradient"", ""hessian""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:9604,Validat,ValidationError,9604,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,3,['Validat'],['ValidationError']
Security,"tkins?; Just trying to kill some bugs sir!; -Starship Troopers""""""). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (occs[k], energies[k], potentials[k], convs[k])). optstash.restore(); return E. [docs]; def frac_nuke(name: Union[str, Callable], **kwargs) -> Dict[float, float]:; """"""Pull all the electrons out, one at a time""""""; optstash = p4util.OptionsState(; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; [""SCF"", ""FRAC_START""],; [""SCF"", ""FRAC_RENORMALIZE""],; # NYI [""SCF"", ""FRAC_LOAD""],; [""SCF"", ""FRAC_OCC""],; [""SCF"", ""FRAC_VAL""],; [""SCF"", ""FRAC_DIIS""]). kwargs = p4util.kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one, and neutral; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). if molecule.molecular_charge() != 0:; raise ValidationError(""""""frac_nuke requires neutral molecule to start.""""""); if molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" Requested procedure `frac_nuke` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). # By default, we start the frac procedure on the 25th iteration; # when not reading a previous guess; frac_start = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; foccs = kwargs.get('foccs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; N = 0; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). charge = charge0; mult = mult0. # By default, nuke all the electrons; Nmin = 0; if 'nmax' in kwargs:; Nmin = N - int(kwargs['nmax'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:9776,Validat,ValidationError,9776,psi4manual/1.8.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html,3,['Validat'],['ValidationError']
Security,"tled : list of lists of str; (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables : list of pairs; (nvar, 2) pairs of variables (str) and values (float). May be incomplete. Raises; ------; qcelemental.ValidationError; For most anything wrong. """"""; # << domain sorting >>; available_domains = [""qm"", ""efp"", ""qmvz""]; if domain not in available_domains:; raise ValidationError(; ""Topology domain {} not available for processing. Choose among {}"".format(domain, available_domains); ). if domain == ""qm"" and (geom is None or np.asarray(geom).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom = []; else:; raise ValidationError(""""""For domain 'qm', `geom` must be provided.""""""); if domain == ""efp"" and (geom_hints is None or np.asarray(geom_hints, dtype=object).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom_hints = []; fragment_files = []; hint_types = []; else:; raise ValidationError(""""""For domain 'efp', `geom_hints` must be provided.""""""). molinit = {}; extern = False. processed = validate_and_fill_units(; name=name,; units=units,; input_units_to_au=input_units_to_au,; comment=comment,; provenance=provenance,; connectivity=connectivity,; always_return_iutau=False,; ); processed[""provenance""] = provenance_stamp(__name__); update_with_error(molinit, processed). if domain == ""efp"":; processed = validate_and_fill_efp(fragment_files=fragment_files, hint_types=hint_types, geom_hints=geom_hints); update_with_error(molinit, processed); extern = bool(len(molinit[""geom_hints""])). if domain == ""qm"" or (domain == ""efp"" and geom is not None) or domain == ""qmvz"":; if domain == ""qmvz"":; processed = validate_and_fill_unsettled_geometry(geom_unsettled=geom_unsettled, variables=variables); update_with_error(molinit, processed); nat = len(molinit[""geom_unsettled""]). else:; processed = validate_and_fill_geometry(geom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:9616,Validat,ValidationError,9616,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; densit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/opt.html:2560,access,accesses,2560,psi4manual/master/opt.html,https://psicode.org,https://psicode.org/psi4manual/master/opt.html,12,['access'],['accesses']
Security,"to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. [docs] def save_string_for_psi4(self):; """"""Returns a string of Molecule formatted for psi4.; Includes fragments and reorienting, if specified. >>> print H2OH2O.save_string_for_psi4(); 6; 0 1; O -1.55100700 -0.11452000 0.00000000; H -1.93425900 0.76250300 0.00000000; H -0.59967700 0.04071200 0.00000000; --; 0 1; @X 0.00000000 0.00000000 0.00000000; O 1.35062500 0.11146900 0.00000000; H 1.68039800 -0.373",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html:3170,Validat,ValidationError,3170,psi4manual/4.0b3/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html,2,['Validat'],['ValidationError']
Security,"to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. [docs] def save_string_xyz(self, save_ghosts=True):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:4053,Validat,ValidationError,4053,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"to the highest atomic number included in any calculations. This option is only used if FREEZE_CORE is set to POLICY. Type: array; Default: No Default. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. INTEGRAL_PACKAGE¶. Integral package to use. If compiled with ERD or Simint support, change this option to use them; LibInt is used otherwise. Type: string; Possible Values: ERD, LIBINT1, SIMINT, LIBINT2; Default: LIBINT2. LITERAL_CFOUR¶. Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through cfour {...} block. Type: string; Default: No Default. MAX_RADIAL_MOMENT¶. Maximum Radial Moment to Calculate. Type: integer; Default: 4. MBIS_D_CONVERGENCE¶. MBIS Convergence Criteria. Type: conv double; Default: 1.0e-8. MBIS_MAXITER¶. Maximum Number of MBIS Iterations. Type: integer; Default: 500. MBIS_PRUNING_SCHEME¶. Pruning scheme for MBIS Grid. Type: string; Default: ROBUST. MBIS_RADIAL_POINTS¶. MBIS Number of Radial Points. Type: integer; Default: 75. MBIS_SPHERICAL_POINTS¶. MBIS Number of Spherical Points. Type: integer; Default: 302. MOLDEN_WITH_VIRTUAL¶. Write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs (false). Type: boolean; Default: true. MP2_TYPE¶. Algorithm to use for MP2 computation. See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: DF. MP_TYPE¶. Algorithm to use for MPn ( \(n>2\) ) computation (e.g., MP3 or MP2.5 or MP4(SDQ)). See Cross-module Redundancies for details. Since v1.4, default for non",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__globals.html:5243,Access,Access,5243,psi4manual/1.7.x/autodir_options_c/module__globals.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__globals.html,3,['Access'],['Access']
Security,"tomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Molecule::atom_at_position: Argument vector not of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vstr', vstr, 'all_variables', self.all_variables, (vstr.upper() in self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:35045,Validat,ValidationError,35045,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 3-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n MD-zeta ({zMD}) Data\n""""""; cbsscheme += nppp(valueMD); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha Data\n""""""; cbsscheme += nppp(alpha); cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(np_value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). ## Build and set from numpy routines; #value = core.Matrix(*valueHI.shape); #value_view = np.asarray(value); #value_view[:] = np_value; #return value. return np_value. else:; raise ValidationError(f""scf_xtpl_helgaker_3: datatype is not recognized '{type(valueLO)}'.""). [docs]; def corl_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'MP2') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.0`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:17484,Validat,ValidationError,17484,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,3,['Validat'],['ValidationError']
Security,"top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 3-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n MD-zeta ({zMD}) Data\n""""""; cbsscheme += nppp(valueMD); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha Data\n""""""; cbsscheme += nppp(alpha); cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(np_value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). ## Build and set from numpy routines; #value = core.Matrix(*valueHI.shape); #value_view = np.asarray(value); #value_view[:] = np_value; #return value. return np_value. else:; raise ValidationError(f""scf_xtpl_helgaker_3: datatype is not recognized '{type(valueLO)}'.""). [docs]def corl_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'MP2') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.0`. Returns; -------; float or numpy.ndarray; Eponymous function applied to input zetas and values; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:17402,Validat,ValidationError,17402,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Validat'],['ValidationError']
Security,"top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 3-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n MD-zeta ({zMD}) Data\n""""""; cbsscheme += nppp(valueMD); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha Data\n""""""; cbsscheme += nppp(alpha); cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(np_value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). ## Build and set from numpy routines; #value = core.Matrix(*valueHI.shape); #value_view = np.asarray(value); #value_view[:] = np_value; #return value. return np_value. else:; raise ValidationError(f""scf_xtpl_helgaker_3: datatype is not recognized '{type(valueLO)}'.""). [docs]def corl_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'MP2') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.0`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:17472,Validat,ValidationError,17472,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Validat'],['ValidationError']
Security,"tor`.; name; Name to give the new :class:`~psi4.core.Matrix`.; dim1; If a single dense NumPy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2; Same as `dim1` only if using a :class:`~psi4.core.Dimension` object. Returns; -------; Matrix or Vector; Returns the given (`self`) Psi4 object. Notes; -----; This is a generalized function to convert a NumPy array to a Psi4 object. Examples; --------. >>> data = np.random.rand(20,1); >>> vector = psi4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4); """""". # What type is it? MRO can help.; arr_type = self.__mro__[0]. # Irrepped case; if isinstance(arr, (list, tuple)):; if (dim1 is not None) or (dim2 is not None):; raise ValidationError(""Array_to_Matrix: If passed input is list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == core.Matrix:; sdim1 = core.Dimension(irreps); sdim2 = core.Dimension(irreps). for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irrepped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:3991,Validat,ValidationError,3991,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,4,['Validat'],['ValidationError']
Security,"tory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; core.get_gradient().print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; core.get_gradient().print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; gobas = core.get_global_option('BASIS') if core.get_global_option('BASIS') else 'sto-3g'; basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = core.get_gradient(); wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalquantity.print_out(). return wfn. def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). def cfour_hessian_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_hessian_list(). def cfour_psivar_list():; """"""Form dictionary of :ref:`PSI Variab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/interface_cfour.html:13327,Validat,ValidationError,13327,psi4manual/1.5.0/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/interface_cfour.html,2,['Validat'],['ValidationError']
Security,"tory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; core.get_gradient().print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; core.get_gradient().print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; gobas = core.get_global_option('BASIS') if core.get_global_option('BASIS') else 'sto-3g'; basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = core.get_gradient(); wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalquantity.print_out(). return wfn. def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). def cfour_psivar_list():; """"""Form dictionary of :ref:`PSI Variables <apdx:cfour_psivar>` set by Cfour methods.""""""; return qcdb.cfour.cfour_psivar_list(). def write_zmat(name, dertype, molecule):; """"""Return",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html:13327,Validat,ValidationError,13327,psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,1,['Validat'],['ValidationError']
Security,"total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_gradient; ntasks; when driver is g/h; all individual gradients.   1_((1, 2), (1, 2));   (nat, 3); when driver is g/h; total gradient for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat, 3); when driver is g/h; total gradient for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_hessian; ntasks; when driver is h; all individual Hessians.   1_((1, 2), (1, 2));   (nat*3, nat*3); when driver is h; total Hessian for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat*3, nat*3); when driver is h; total Hessian for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. validator set_bsse_type  »  bsse_type[source]¶. validator set_embedding_charges  »  embedding_charges[source]¶. validator set_max_nbody  »  max_nbody[source]¶. validator set_molecule  »  molecule[source]¶. validator set_nfragments  »  nfragments[source]¶. validator set_return_total_data  »  return_total_data[source]¶. table of contents. Basis Set Superposition Corrections; nbody(); API; BsseEnum; BsseEnum.cp; BsseEnum.nocp; BsseEnum.vmfc. ManyBodyComputer; ManyBodyComputer.basis; ManyBodyComputer.bsse_type; ManyBodyComputer.driver; ManyBodyComputer.embedding_charges; ManyBodyComputer.keywords; ManyBodyComputer.max_nbody; ManyBodyComputer.method; ManyBodyComputer.molecule; ManyBodyComputer.nbodies_per_mc_level; ManyBodyComputer.nfragments; ManyBodyComputer.quiet; ManyBodyComputer.return_total_data; ManyBodyComputer.task_list; ManyBodyComputer.build_tasks(); ManyBodyComputer.compute(); ManyBodyComputer.get_psi_results(); ManyBodyComputer.get_results(); ManyBodyComputer.plan(); ManyBodyComputer.prepare_results(); ManyBodyComputer.set_bsse_type; ManyBodyComputer.set_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/nbody.html:35006,validat,validator,35006,psi4manual/master/nbody.html,https://psicode.org,https://psicode.org/psi4manual/master/nbody.html,3,['validat'],['validator']
Security,"tpl_highest_1; elif xtpl_type == ""scf"":; if nbasis == 2:; return scf_xtpl_helgaker_2; elif nbasis == 3:; return scf_xtpl_helgaker_3; else:; raise ValidationError(""Wrong number of basis sets supplied to scf_xtpl: %d"" % nbasis); elif xtpl_type == ""corl"":; if nbasis == 2:; return corl_xtpl_helgaker_2; else:; raise ValidationError(""Wrong number of basis sets supplied to corl_xtpl: %d"" % nbasis); else:; raise ValidationError(""Stage treatment must be 'corl' or 'scf', not '%s'"" % xtpl_type). def _validate_cbs_inputs(cbs_metadata, molecule):; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata : list; List of dicts containing CBS stage keywords.; molecule : qcdb.molecule or psi4.core.Molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for item in cbs_metadata:; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(""Stage {:d} doesn't have defined level of theory!"".format(cbs_metadata.index(item))); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(""Stage {:d} doesn't have defined basis sets!"".format(cbs_metadata.index(item))); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ""scf"", ""c4-scf""]:; scf = {}; if stage[""wfn""].startswith(""c4""):; scf[""wfn""] = ""c4-hf""; else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xtpl(len(scf[""basis""][1]), scf[""treatment""]); scf[""alpha""] = N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:29332,validat,validation,29332,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['validat'],['validation']
Security,"tqph-1a' : { 'method' : 5, 'order' : 6, 'fullname' : 'CCSDTQPH-1a' },; 'sdt-1b' : { 'method' : 6, 'order' : 3, 'fullname' : 'CCSDT-1b' },; 'sdtq-1b' : { 'method' : 6, 'order' : 4, 'fullname' : 'CCSDTQ-1b' },; 'sdtqp-1b' : { 'method' : 6, 'order' : 5, 'fullname' : 'CCSDTQP-1b' },; 'sdtqph-1b' : { 'method' : 6, 'order' : 6, 'fullname' : 'CCSDTQPH-1b' },; '2' : { 'method' : 7, 'order' : 2, 'fullname' : 'CC2' },; '3' : { 'method' : 7, 'order' : 3, 'fullname' : 'CC3' },; '4' : { 'method' : 7, 'order' : 4, 'fullname' : 'CC4' },; '5' : { 'method' : 7, 'order' : 5, 'fullname' : 'CC5' },; '6' : { 'method' : 7, 'order' : 6, 'fullname' : 'CC6' },; 'sdt-3' : { 'method' : 8, 'order' : 3, 'fullname' : 'CCSDT-3' },; 'sdtq-3' : { 'method' : 8, 'order' : 4, 'fullname' : 'CCSDTQ-3' },; 'sdtqp-3' : { 'method' : 8, 'order' : 5, 'fullname' : 'CCSDTQP-3' },; 'sdtqph-3' : { 'method' : 8, 'order' : 6, 'fullname' : 'CCSDTQPH-3' }; }. # looks for 'sdt(q)' in dictionary; if ccfullname in methods:; return 'mrcc', methods[ccfullname]; else:; raise ValidationError('MRCC method \'%s\' invalid.' % (namelower)). elif re.match(r'^[a-z]+\d+$', namelower):; decompose = re.compile(r'^([a-z]+)(\d+)$').match(namelower); namestump = decompose.group(1); namelevel = int(decompose.group(2)). if (namestump == 'mp') or (namestump == 'zapt') or (namestump == 'ci'):; # Let 'mp2' and 'mp3' pass through as themselves to occ module; if (namestump == 'mp') and ((namelevel == 2) or (namelevel == 3)):; return namelower, None; # Let 'mp4' be redirected to fnocc module if rhf; elif (namestump == 'mp') and (namelevel == 4):; if PsiMod.get_option('SCF','REFERENCE') == 'RHF':; return 'fnocc-mp', 4; else:; return 'detci-mp', 4; # Otherwise return method and order; else:; return namestump, namelevel; else:; return namelower, None; else:; return namelower, None. [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: (*float*) Total electronic e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:56882,Validat,ValidationError,56882,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"tqph-1a' : { 'method' : 5, 'order' : 6, 'fullname' : 'CCSDTQPH-1a' },; 'sdt-1b' : { 'method' : 6, 'order' : 3, 'fullname' : 'CCSDT-1b' },; 'sdtq-1b' : { 'method' : 6, 'order' : 4, 'fullname' : 'CCSDTQ-1b' },; 'sdtqp-1b' : { 'method' : 6, 'order' : 5, 'fullname' : 'CCSDTQP-1b' },; 'sdtqph-1b' : { 'method' : 6, 'order' : 6, 'fullname' : 'CCSDTQPH-1b' },; '2' : { 'method' : 7, 'order' : 2, 'fullname' : 'CC2' },; '3' : { 'method' : 7, 'order' : 3, 'fullname' : 'CC3' },; '4' : { 'method' : 7, 'order' : 4, 'fullname' : 'CC4' },; '5' : { 'method' : 7, 'order' : 5, 'fullname' : 'CC5' },; '6' : { 'method' : 7, 'order' : 6, 'fullname' : 'CC6' },; 'sdt-3' : { 'method' : 8, 'order' : 3, 'fullname' : 'CCSDT-3' },; 'sdtq-3' : { 'method' : 8, 'order' : 4, 'fullname' : 'CCSDTQ-3' },; 'sdtqp-3' : { 'method' : 8, 'order' : 5, 'fullname' : 'CCSDTQP-3' },; 'sdtqph-3' : { 'method' : 8, 'order' : 6, 'fullname' : 'CCSDTQPH-3' }; }. # looks for 'sdt(q)' in dictionary; if ccfullname in methods:; return 'mrcc', methods[ccfullname]; else:; raise ValidationError('MRCC method \'%s\' invalid.' % (namelower)). elif re.match(r'^[a-z]+\d+$', namelower):; decompose = re.compile(r'^([a-z]+)(\d+)$').match(namelower); namestump = decompose.group(1); namelevel = int(decompose.group(2)). if (namestump == 'mp') or (namestump == 'zapt') or (namestump == 'ci'):; # Let 'mp2' and 'mp3' pass through as themselves to occ module; if (namestump == 'mp') and ((namelevel == 2) or (namelevel == 3)):; return namelower, None; # Let 'mp4' be redirected to fnocc module if rhf; elif (namestump == 'mp') and (namelevel == 4):; if psi4.get_option('SCF', 'REFERENCE') == 'RHF':; return 'fnocc-mp', 4; else:; return 'detci-mp', 4; # Otherwise return method and order; else:; return namestump, namelevel; else:; return namelower, None; else:; return namelower, None. [docs]def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~frequency`. Computes force; constants, deciding analytic, finite difference of gradients, o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:57101,Validat,ValidationError,57101,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"tqph-1a' : { 'method' : 5, 'order' : 6, 'fullname' : 'CCSDTQPH-1a' },; 'sdt-1b' : { 'method' : 6, 'order' : 3, 'fullname' : 'CCSDT-1b' },; 'sdtq-1b' : { 'method' : 6, 'order' : 4, 'fullname' : 'CCSDTQ-1b' },; 'sdtqp-1b' : { 'method' : 6, 'order' : 5, 'fullname' : 'CCSDTQP-1b' },; 'sdtqph-1b' : { 'method' : 6, 'order' : 6, 'fullname' : 'CCSDTQPH-1b' },; '2' : { 'method' : 7, 'order' : 2, 'fullname' : 'CC2' },; '3' : { 'method' : 7, 'order' : 3, 'fullname' : 'CC3' },; '4' : { 'method' : 7, 'order' : 4, 'fullname' : 'CC4' },; '5' : { 'method' : 7, 'order' : 5, 'fullname' : 'CC5' },; '6' : { 'method' : 7, 'order' : 6, 'fullname' : 'CC6' },; 'sdt-3' : { 'method' : 8, 'order' : 3, 'fullname' : 'CCSDT-3' },; 'sdtq-3' : { 'method' : 8, 'order' : 4, 'fullname' : 'CCSDTQ-3' },; 'sdtqp-3' : { 'method' : 8, 'order' : 5, 'fullname' : 'CCSDTQP-3' },; 'sdtqph-3' : { 'method' : 8, 'order' : 6, 'fullname' : 'CCSDTQPH-3' }; }. # looks for 'sdt(q)' in dictionary; if ccfullname in methods:; return 'mrcc', methods[ccfullname]; else:; raise ValidationError('MRCC method \'%s\' invalid.' % (namelower)). elif re.match(r'^[a-z]+\d+$', namelower):; decompose = re.compile(r'^([a-z]+)(\d+)$').match(namelower); namestump = decompose.group(1); namelevel = int(decompose.group(2)). if (namestump == 'mp') or (namestump == 'zapt') or (namestump == 'ci'):; # Let 'mp2' pass through as itself; if (namestump == 'mp') and (namelevel == 2):; return namelower, None; # Otherwise return method and order; else:; return namestump, namelevel; else:; return namelower, None; else:; return namelower, None. [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: (*float*) Total electronic energy in Hartrees. .. note:: Analytic hessians are not available. Frequencies will proceed through; finite differences according to availability of gradients or energies. .. caution:: Some features are not yet implemented. Buy a developer a coffee. -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:41405,Validat,ValidationError,41405,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['Validat'],['ValidationError']
Security,"tr(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; exc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:11879,Validat,ValidationError,11879,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,10,['Validat'],['ValidationError']
Security,"tr(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; exc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:11759,Validat,ValidationError,11759,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"tr(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(PsiMod.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). PsiMod.dfmp2grad(); e_dfmp2 = PsiMod.get_variable('MP2 TOTAL ENERGY'); e_scs_dfmp2 = PsiMod.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-DFMP2') or (name.upper() == 'SCS-DF-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; lowername = name.lower(). optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if (lowername == 'ccsd'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'CCSD'); PsiMod.set_local_option('CCSORT', 'WFN', 'CCSD'); PsiMod.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif (lowername == 'ccsd(t)'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); PsiMod.set_local_option('CCSORT', 'WFN', 'CCSD_T'); PsiMod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:21098,Validat,ValidationError,21098,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"tral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n""""""); E0l, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; E_HOMOl = E_HOMO; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; psi4.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Left Endpoint <==\n""""""); E1l = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IPl = E1l - E0l; kIPl = -E_HOMOl; delta_l = IPl - kIPl. if IPl < kIPl:; message = (""""""\n***IP Fitting Error: Left Omega limit should have kIP < IP""""""); raise ValidationError(message). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl). converged = False; repeat_l = 0; repeat_r = 0; step = 0; while True:. step = step + 1. # Regula Falsi (modified); if repeat_l > 1:; delta_l = delta_l / 2.0; if repeat_r > 1:; delta_r = delta_r / 2.0; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l; psi4.set_global_option('DFT_OMEGA', omega). # Neutral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Omega = %11.3E <==\n"""""" % omega); E0, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/frac.html:15857,Validat,ValidationError,15857,psi4manual/1.0.0/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html,1,['Validat'],['ValidationError']
Security,"trapolation for method: %s <==\n\n"""""" % (functionname.upper())); psi4.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); psi4.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); psi4.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); psi4.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); psi4.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); psi4.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); psi4.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_helgaker_3(functionname, zLO, valueLO, zMD, valueMD, zHI, valueHI, verbose=True):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~driver_cbs.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}; """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(""scf_xtpl_helgaker_3: Inputs must be of the same datatype! (%s, %s, %s)""; % (type(valueLO), type(valueMD), type(valueHI))). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zMD].upper()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:7760,Validat,ValidationError,7760,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"treatment. Contents:; ``'all'``: dict of int: set; Set containing full list of computations required; ``'cp'``: dict of int: set; Set containing list of computations required for CP procedure; ``'nocp'``: dict of int: set; Set containing list of computations required for non-CP procedure; ``'vmfc_compute'``: dict of int: set; Set containing list of computations required for VMFC procedure; ``'vmfc_levels'``: dict of int: set; Set containing list of levels required for VMFC procedure; """"""; # What levels do we need?; nbody_range = range(1, metadata['max_nbody'] + 1); fragment_range = range(1, metadata['max_frag'] + 1). cp_compute_list = {x: set() for x in nbody_range}; nocp_compute_list = {x: set() for x in nbody_range}; vmfc_compute_list = {x: set() for x in nbody_range}; vmfc_level_list = {x: set() for x in nbody_range} # Need to sum something slightly different. # Verify proper passing of bsse_type_list; bsse_type_remainder = set(metadata['bsse_type_list']) - {'cp', 'nocp', 'vmfc'}; if bsse_type_remainder:; raise ValidationError(""""""Unrecognized BSSE type(s): %s; Possible values are 'cp', 'nocp', and 'vmfc'."""""" % ', '.join(str(i) for i in bsse_type_remainder)). # Build up compute sets; if 'cp' in metadata['bsse_type_list']:; # Everything is in dimer basis; basis_tuple = tuple(fragment_range); for nbody in nbody_range:; for x in itertools.combinations(fragment_range, nbody):; if metadata['max_nbody'] == 1: break; cp_compute_list[nbody].add((x, basis_tuple)). if 'nocp' in metadata['bsse_type_list'] or metadata['return_total_data']:; # Everything in monomer basis; for nbody in nbody_range:; for x in itertools.combinations(fragment_range, nbody):; nocp_compute_list[nbody].add((x, x)). if 'vmfc' in metadata['bsse_type_list']:; # Like a CP for all combinations of pairs or greater; for nbody in nbody_range:; for cp_combos in itertools.combinations(fragment_range, nbody):; basis_tuple = tuple(cp_combos); for interior_nbody in nbody_range:; for x in itertools.combinations(cp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:13854,Validat,ValidationError,13854,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['Validat'],['ValidationError']
Security,"treatment. Contents:; ``'all'``: dict of int: set; Set containing full list of computations required; ``'cp'``: dict of int: set; Set containing list of computations required for CP procedure; ``'nocp'``: dict of int: set; Set containing list of computations required for non-CP procedure; ``'vmfc_compute'``: dict of int: set; Set containing list of computations required for VMFC procedure; ``'vmfc_levels'``: dict of int: set; Set containing list of levels required for VMFC procedure; """"""; # What levels do we need?; nbody_range = range(1, metadata['max_nbody'] + 1); fragment_range = range(1, metadata['max_frag'] + 1). cp_compute_list = {x: set() for x in nbody_range}; nocp_compute_list = {x: set() for x in nbody_range}; vmfc_compute_list = {x: set() for x in nbody_range}; vmfc_level_list = {x: set() for x in nbody_range} # Need to sum something slightly different. # Verify proper passing of bsse_type_list; bsse_type_remainder = set(metadata['bsse_type_list']) - {'cp', 'nocp', 'vmfc'}; if bsse_type_remainder:; raise ValidationError(""""""Unrecognized BSSE type(s): %s; Possible values are 'cp', 'nocp', and 'vmfc'."""""" % ', '.join(str(i) for i in bsse_type_remainder)). # Build up compute sets; if 'cp' in metadata['bsse_type_list']:; # Everything is in dimer basis; basis_tuple = tuple(fragment_range); for nbody in nbody_range:; for x in itertools.combinations(fragment_range, nbody):; if metadata['max_nbody'] == 1: break; cp_compute_list[nbody].add((x, basis_tuple)); # Add monomers in monomer basis; for x in fragment_range:; cp_compute_list[1].add(((x, ), (x, ))). if 'nocp' in metadata['bsse_type_list']:; # Everything in monomer basis; for nbody in nbody_range:; for x in itertools.combinations(fragment_range, nbody):; nocp_compute_list[nbody].add((x, x)). if 'vmfc' in metadata['bsse_type_list']:; # Like a CP for all combinations of pairs or greater; for nbody in nbody_range:; for cp_combos in itertools.combinations(fragment_range, nbody):; basis_tuple = tuple(cp_combos); for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:12523,Validat,ValidationError,12523,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"treet, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with a *procedures* dictionary specifying available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. """"""; from __future__ import print_function; from __future__ import absolute_import; import sys; import re; import math; import os; import shutil. import psi4. # Import driver helpers; import driver_util; import driver_cbs; import driver_nbody. from procedures import *; import p4util; from p4util.exceptions import *; # never import wrappers or aliases into this file. def _find_derivative_type(ptype, method_name, user_dertype):; r""""""; Figures out the derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". if ptype not in ['gradient', 'hessian']:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:2031,Validat,ValidationError,2031,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"tribute, [1]. psi4.core.Localizer attribute, [1], [2]. psi4.core.PMLocalizer attribute, [1]. UHF class in psi4.core, [1]. UHF_NOONS (SCF). UNCP-CORRECTED2-BODYINTERACTIONENERGY. unit() psi4.core.SymmetryOperation method, [1], [2]. units. ; molecule. UNITS (GLOBALS). units psi4.core.Molecule attribute, [1], [2]. Unnormalized psi4.core.PrimitiveType attribute, [1], [2]. UPDATE (DETCI). update() psi4.core.DFSOMCSCF method, [1]. psi4.core.DiskSOMCSCF method, [1]. psi4.core.SOMCSCF method, [1], [2]. update_geometry() psi4.core.Molecule method, [1], [2]. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. V() psi4.core.VBase method, [1], [2]. V_potential() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. Va() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. VAL_EX_LEVEL (DETCI). ValidationError. value() psi4.core.SuperFunctional method, [1], [2]. variables() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. Vb() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. VBase class in psi4.core, [1]. vdot() psi4.core.CIVector method, [1], [2]. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector class in psi4.core, [1]. Vector3 class in psi4.core, [1]. vector_dot() psi4.core.Matrix method, [1], [2]. vector_multiply() psi4.core.CIVector method, [1], [2]. VectorMatrix class in psi4.core, [1]. version() in module psi4.core, [1]. vibrational analysis. ; function call. output. View class in psi4.core, [1]. visualization, [1]. VMDPATH. vmfc. ; setting keywords. Vvals() psi4.core.OEProp method, [1], [2]. W. WABEI_LOWDISK (CCHBAR). Wavefu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:101046,Validat,ValidationError,101046,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['Validat'],['ValidationError']
Security,"tributeError:; if not failoninc:; print(""""""%s %s data unavailable for database %s.\n"""""" % (modname, funcname, self.dbse)); return; else:; raise ValidationError(""Python module missing function %s for loading data "" % (str(funcname))). print(""""""WrappedDatabase %s: %s %s results loaded"""""" % (self.dbse, modname, funcname)). [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""Loads qcdb.ReactionDatums from standard location for *project*; :module dbse_project and function load_project. Module search path; can be prepended with *pythonpath*. """"""; mod = self.dbse + '_' + project; func = 'load_' + project; self.load_qcdata(modname=mod, funcname=func, pythonpath=pythonpath). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; """"""""""""; if path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise ValidationError(; ""Reactions pickle file for loading database data from file %s does not exist"" % (pklfile)). with open(pklfile, 'rb') as handle:; hrxns = pickle.load(handle); # no error checking for speed; for rxn, data in hrxns.iteritems():; self.hrxn[rxn].data.update(data). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; hdf5file = os.path.abspath(path) + os.sep + self.dbse + '_' + project + '.h5'; if not os.path.isfile(hdf5file):; raise ValidationError(""HDF5 file for loading database data from file %s does not exist"" % (hdf5file)); try:; import pandas as pd; except ImportError:; raise ValidationError(""Pandas data managment module must be available for import""). try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; intrxn = False; else:; intrxn = True. with pd.ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:39209,Validat,ValidationError,39209,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"tributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.strip().split(None, 10); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if label == 'electronic energy' and s[8:10] == ['electronic', 'energy']:; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); if label == 'electronic gradient' and s[8:10] == ['electronic', 'gradient']:; E = ast.literal_eval(s[-1]); psi4.print_out('%s RESULT: electronic gradient = %r\n' % (quantity, E)); freagent.close(); return E. [docs]def prepare_options_for_modules(changedOnly=False, commandsInsteadDict=Fals",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:8846,Validat,ValidationError,8846,psi4manual/1.0.0/_modules/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html,1,['Validat'],['ValidationError']
Security,"tring is prefixed by ""~"". Notes; -----; Not carefully handling degenerate inertial elements. """"""; it = self.inertia_tensor(zero=zero); Iidx = np.argsort(np.diagonal(it)); if np.array_equal(Iidx, np.asarray([1, 2, 0])):; ar = 'IR'; elif np.array_equal(Iidx, np.asarray([2, 0, 1])):; ar = 'IIR'; elif np.array_equal(Iidx, np.asarray([0, 1, 2])):; ar = 'IIIR'; elif np.array_equal(Iidx, np.asarray([2, 1, 0])):; ar = 'IL'; elif np.array_equal(Iidx, np.asarray([0, 2, 1])):; ar = 'IIL'; elif np.array_equal(Iidx, np.asarray([1, 0, 2])):; ar = 'IIIL'. # if inertial tensor has non-zero off-diagonals, this whole classification is iffy; if np.count_nonzero(it - np.diag(np.diagonal(it))):; ar = '~' + ar. return ar. @staticmethod; def _raw_to_arrays(self):; """"""Exports coordinate info into NumPy arrays. Returns; -------; geom, mass, elem, elez, uniq : ndarray, ndarray, ndarray, ndarray, ndarray; (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost. Usage; -----; geom, mass, elem, elez, uniq = molinstance.to_arrays(). """"""; self.update_geometry(); if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.geometry()); mass = np.asarray([self.mass(at) for at in range(self.natom())]); elem = np.asarray([self.symbol(at) for at in range(self.natom())]); elez = np.asarray([self.Z(at) for at in range(self.natom())]); uniq = np.asarray(; [hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest() for at in range(self.natom())]). return geom, mass, elem, elez, uniq. @staticmethod; def from_string(molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:39077,hash,hash,39077,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['hash'],['hash']
Security,"try optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/opt-1.html:1211,access,accesses,1211,psi4manual/4.0b2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html,2,['access'],['accesses']
Security,"try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:34637,Validat,ValidationError,34637,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"tstash = OptionsState(...) was set up previously; optstash.restore(). Current best practice is to store as much as possible on the wavefunction, not in globals. The; driver should handle interactions with globals. When QCVariables are stored on the wavefunction in; the module, copy to globals with the below:; # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). The function should return the wavefunction, except for rare cases like EFP where no wavefunction available.; For now, CURRENT ENERGY will be set by; energy(), etc. In future, this will be extracted from the wavefunction.; # return highest or most prominent wavefunction (like dimer for SAPT); return fnocc_wfn. Managed Methods¶; There are several conditions when a method and derivative combination should be managed:. when functionality overlaps between modules, a pattern is needed to; access each route through the code;; when functionality doesn’t overlap completely, a pattern is needed to apportion defaulting among; the modules, taking into account reference (RHF/UHF/ROHF), calc type (CONV/DF/CD), and possibly; FREEZE_CORE state (AE/FC).; for higher-level derivatives, when, say, gradient functionality for mtd+ref+type+fcae doesn’t; exactly match energy functionality, a pattern is needed to decide analytic vs. finite difference.; when default type is not available for a method (e.g., CCD governed by CC_TYPE that; defaults to CONV but only DF and CD CCD is available), an informative error message is needed. Managed methods handle these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while most everything higher defaults; to CONV. (Ex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/proc_py.html:4335,access,access,4335,psi4manual/master/proc_py.html,https://psicode.org,https://psicode.org/psi4manual/master/proc_py.html,4,['access'],['access']
Security,"tstash.restore(). if ptype == 'energy':; finalquantity = finalenergy; elif ptype == 'gradient':; finalquantity = finalgradient; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif ptype == 'hessian':; finalquantity = finalhessian; wfn.set_gradient(finalgradient); wfn.set_hessian(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT HESSIAN'); finalquantity.print_out(). if return_wfn:; return (finalquantity, wfn); else:; return finalquantity. ######### COMPUTE / ASSEMBLE; ######### ASSEMBLE / REPORT. def _expand_scheme_orders(scheme, basisname, basiszeta, wfnname, options, natom):; """"""Check that the length of *basiszeta* array matches the implied degree of; extrapolation in *scheme* name. Return a dictionary of same length as; basiszeta, with *basisname* and *basiszeta* distributed therein. """"""; Nxtpl = len(basiszeta). if int(scheme.__name__.split('_')[-1]) != Nxtpl:; raise ValidationError(""""""Call to '%s' not valid with '%s' basis sets."""""" % (scheme.__name__, len(basiszeta))). f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_energy', 'f_gradient', 'f_hessian', 'f_options']; NEED = {}; for idx in range(Nxtpl):; NEED[_lmh_labels[Nxtpl][idx]] = dict(; zip(f_fields, [; wfnname, basisname[idx], basiszeta[idx], 0.0,; core.Matrix(natom, 3),; core.Matrix(3 * natom, 3 * natom), options; ])); return NEED. def _contract_scheme_orders(needdict, datakey='f_energy'):; """"""Prepared named arguments for extrapolation functions by; extracting zetas and values (which one determined by *datakey*) out; of *needdict* and returning a dictionary whose keys are constructed; from _lmh_labels. """"""; largs = {}; largs['functionname'] = needdict['HI']['f_wfn']; Nxtpl = len(needdict); zlabels = _lmh_labels[Nxtpl] # e.g., ['LO', 'HI']. for zeta in range(Nxtpl):; zlab = zlabels[zeta] # e.g., LO; largs['z' + zlab] = needdict[zlab]['f_zeta']; largs['value' + zlab] = needdict[zlab][datakey]. return largs. ## A",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:61106,Validat,ValidationError,61106,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"tswith(self.functional().name()):; # fctl_plus_disp_name = pv.split()[0]; # self.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', dft_energy) # overwritten later for DH; #else:; # self.set_variable(self.functional().name() + ' TOTAL ENERGY', dft_energy) # overwritten later for DH. self.set_variable('SCF ITERATIONS', self.iteration_). # Bind functions to core.HF class; core.HF.initialize = scf_initialize; core.HF.initialize_jk = initialize_jk; core.HF.iterations = scf_iterate; core.HF.compute_energy = scf_compute_energy; core.HF.finalize_energy = scf_finalize_energy; core.HF.print_energies = scf_print_energies. def _converged(e_delta, d_rms, e_conv=None, d_conv=None):; if e_conv is None:; e_conv = core.get_option(""SCF"", ""E_CONVERGENCE""); if d_conv is None:; d_conv = core.get_option(""SCF"", ""D_CONVERGENCE""). return (abs(e_delta) < e_conv and d_rms < d_conv). def _validate_damping():; """"""Sanity-checks DAMPING control options. Raises; ------; ValidationError; If any of |scf__damping_percentage|, |scf__damping_convergence|; don't play well together. Returns; -------; bool; Whether DAMPING is enabled during scf. """"""; # Q: I changed the enabled criterion get_option <-- has_option_changed; enabled = (core.get_option('SCF', 'DAMPING_PERCENTAGE') > 0.0); if enabled:; parameter = core.get_option('SCF', ""DAMPING_PERCENTAGE""); if parameter < 0.0 or parameter > 100.0:; raise ValidationError('SCF DAMPING_PERCENTAGE ({}) must be between 0 and 100'.format(parameter)). stop = core.get_option('SCF', 'DAMPING_CONVERGENCE'); if stop < 0.0:; raise ValidationError('SCF DAMPING_CONVERGENCE ({}) must be > 0'.format(stop)). return enabled. def _validate_diis():; """"""Sanity-checks DIIS control options. Raises; ------; ValidationError; If any of |scf__diis|, |scf__diis_start|,; |scf__diis_min_vecs|, |scf__diis_max_vecs| don't play well together. Returns; -------; bool; Whether DIIS is enabled during scf. """"""; enabled = bool(core.get_option('SCF', 'DIIS')); if enabled:; start = core.get_option",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:22846,Validat,ValidationError,22846,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security,"tting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequencies(name, **kwargs). [docs]def molden(filename):; m = PsiMod.MoldenWriter(PsiMod.reference_wavefunction()); m.write(filename). [docs]def parse_cotton_irreps(irrep):; r""""""Function to return validated Cotton ordering index from string or integer; irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2v': {; 'a1': 1,; 'a2': 2,; 'b1': 3,; 'b2': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2h': {; 'ag': 1,; 'bg': 2,; 'au': 3,; 'bu': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; },; 'd2h': {; 'ag': 1,; 'b1g': 2,; 'b2g': 3,; 'b3g': 4,; 'au': 5,; 'b1u': 6,; 'b2u': 7,; 'b3u': 8,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; '5': 5,; '6': 6,; '7': 7,; '8': 8; }; }. point_group = PsiMod.get_active_molecule().schoenflies_symbol().lower(); irreducible_representation = str(irrep).lower(). try:; return cotton[point_group][irreducible_representation]; except KeyError:; raise ValidationError(""Irrep \'%s\' not valid for point group \'%s\'."" % (str(irrep), point_group)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2] » ; Module code ». © Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:49774,Validat,ValidationError,49774,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"tty dependent on the reference geometry being last (as it is now); print ' %d displacements needed ...' % (ndisp),; energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructionsM += """"""# (1) Run all of the OPT-%s-*.in input files on any variety of computer architecture.\n"""""" % (str(opt_iter)); instructionsM += """"""# The output file names must be as given below.\n#\n""""""; for rgt in range(ndisp):; pre = 'OPT-' + str(opt_iter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# OPT-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the gradient step in its output file.\n#\n""""""; if opt_iter == 1:; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:24838,access,accessed,24838,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['access'],['accessed']
Security,"tum chemistry method to evaluate (e.g., B3LYP, MP2, …). Validated by:. set_method. field molecule: Any [Required]¶; The molecule to use in the computation. field owner_group: Optional[str] = None¶; group in the chown sense. field priority: str = 1¶; The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}. field protocols: Union[AtomicResultProtocols, Dict[str, Any], None] = {'stdout': True}¶; Output modifications. field result: Any [Optional]¶; AtomicResult return. field result_id: Optional[str] = None¶; The optional ID for the computation. field tag: str = '*'¶; The tags to pass along to compute managers. compute(client=None)[source]¶; Run quantum chemistry. Parameters:; client (qcportal.client.FractalClient | None) – . get_results(client=None)[source]¶; Return results as Atomic-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None) – . Return type:; AtomicResult. plan()[source]¶; Form QCSchema input from member data. Return type:; AtomicInput. validator set_basis  »  psi4.driver.AtomicComputer.basis[source]¶. validator set_keywords  »  psi4.driver.AtomicComputer.keywords[source]¶. validator set_method  »  psi4.driver.AtomicComputer.method[source]¶. table of contents. AtomicComputer; AtomicComputer; AtomicComputer.basis; AtomicComputer.computed; AtomicComputer.driver; AtomicComputer.keywords; AtomicComputer.method; AtomicComputer.molecule; AtomicComputer.owner_group; AtomicComputer.priority; AtomicComputer.protocols; AtomicComputer.result; AtomicComputer.result_id; AtomicComputer.tag; AtomicComputer.compute(); AtomicComputer.get_results(); AtomicComputer.plan(); AtomicComputer.set_basis; AtomicComputer.set_keywords; AtomicComputer.set_method. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; AtomicComputer. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:6535,validat,validator,6535,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,3,['validat'],['validator']
Security,"turn scf_wfn. def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; optstash = p4util.OptionsState(; ['WFN'],; ['DERTYPE'],; ['ONEPDM'],; ['PROPERTY'],; ['CCLAMBDA', 'R_CONVERGENCE'],; ['CCEOM', 'R_CONVERGENCE'],; ['CCEOM', 'E_CONVERGENCE']) # yapf:disable. oneel_properties = core.OEProp.valid_methods; twoel_properties = []; response_properties = ['POLARIZABILITY', 'ROTATION', 'ROA', 'ROA_TENSOR']; excited_properties = ['OSCILLATOR_STRENGTH', 'ROTATIONAL_STRENGTH']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs['properties']. for prop in properties:. prop = prop.upper(); if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). # People are used to requesting dipole/quadrupole and getting dipole,quadrupole,mulliken_charges and NO_occupations; if ('DIPOLE' in one) or ('QUADRUPOLE' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:77502,Validat,ValidationError,77502,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,9,['Validat'],['ValidationError']
Security,"turn xtpl_highest_1; elif xtpl_type == ""scf"":; if nbasis == 2:; return scf_xtpl_helgaker_2; elif nbasis == 3:; return scf_xtpl_helgaker_3; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return corl_xtpl_helgaker_2; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata, molecule):; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata : list; List of dicts containing CBS stage keywords.; molecule : qcdb.molecule or psi4.core.Molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ""scf"", ""c4-scf""]:; scf = {}; if stage[""wfn""].startswith(""c4""):; scf[""wfn""] = ""c4-hf""; else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xtpl(len(scf[""basis""][1]), scf[""treatment""]); scf[""alpha""] = None; scf[""options""] = False; scf[""option",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:29835,validat,validation,29835,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['validat'],['validation']
Security,"turn_wfn, func, mode, dertype, irrep])[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/freq.html:1791,access,accesses,1791,psi4manual/master/freq.html,https://psicode.org,https://psicode.org/psi4manual/master/freq.html,4,['access'],['accesses']
Security,"turn_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from typing import Any, Callable, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union, TYPE_CHECKING; from ast import literal_eval; from enum import Enum; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import pprint; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from qcelemental.models import DriverEnum, AtomicResult. from psi4 import core; from psi4.driver import constants, driver_nbody_multilevel, p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.task_base import BaseComputer, AtomicComputer, EnergyGradientHessianWfnReturn; from psi4.driver.driver_cbs import CompositeComputer; from psi4.driver.driver_findif import FiniteDifferenceComputer. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:7409,validat,validator,7409,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,2,['validat'],['validator']
Security,"turned with an image map of; slats to any of text, link, or image, respectively. class ReactionDatum(dbse, rxn, method, mode, basis, value, units='kcal/mol', citation=None, doi=None, comment=None)[source]¶; Piece of quantum chemical information that describes a qcdb.Reaction object. classmethod library_modelchem(dbse, rxn, method, mode, basis, value, units='kcal/mol', citation=None, doi=None, comment=None)[source]¶; Constructor when method and basis are strings corresponding to; qcdb.Method and qcdb.BasisSet already defined in methods and bases. class Reagent(name, mol, tagl=None, comment=None)[source]¶; Chemical entity only slightly dresed up from qcdb.Molecule. class Subset(name, hrxn, tagl=None, axis=None)[source]¶; Affiliated qcdb.Reaction-s. class ThreeDatabases(pythonpath=None)[source]¶. define_supermodelchems()[source]¶. define_supersubsets()[source]¶. class WrappedDatabase(dbname, pythonpath=None)[source]¶; Wrapper class for raw Psi4 database modules that does some validation; of contents, creates member data and accessors for database structures,; defines error computation, and handles database subsets. Not to be used; directly– see qcdb.Database for handling single or multiple; qdcb.WrappedDatabase objects and defining nice statistics, plotting, and; table functionalities.; >>> asdf = qcdb.WrappedDatabase('Nbc10'). add_ReactionDatum(dbse, rxn, method, mode, basis, value, units='kcal/mol', citation=None, comment=None, overwrite=False)[source]¶; Add a new quantum chemical value to rxn by creating a; qcdb.ReactionDatum from same arguments as that class’s; object-less constructor. rxn may be actual Reaction.name; or Reaction.indx. add_Subset(name, func)[source]¶; Define a new subset labeled name by providing a function; func that filters self.hrxn. available_modelchems(union=True)[source]¶; Returns all the labels of model chemistries that have been; loaded. Either all modelchems that have data for any reaction if; union is True or all modelchems that have data",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:45802,validat,validation,45802,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,4,"['access', 'validat']","['accessors', 'validation']"
Security,"turns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:83023,access,accesses,83023,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,7,['access'],['accesses']
Security,"ty += self.fragment_multiplicities[fr] - 1. for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]). # TODO: This is a hack to ensure that set_multiplicity and set_molecular_charge; # work for single-fragment molecules.; if self.nfragments() < 2:; self.PYmolecular_charge = temp_charge; self.PYmultiplicity = temp_multiplicity. [docs] def update_geometry(self):; """"""Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule. >>> H2 = qcdb.Molecule(""H\\nH 1 0.74\\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rather than the symmetry; # the the user might have provided.; frame = self.symmetry_frame(); self.rotate_full(frame); #print ""after rotate:""; #self.print_full(). # Recompute point group of the molecule, so the symmetry info is updated to the new frame; # TODO self.set_point_group(self.find_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:42309,Validat,ValidationError,42309,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,3,['Validat'],['ValidationError']
Security,"ty += self.fragment_multiplicities[fr] - 1. for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]). # TODO: This is a hack to ensure that set_multiplicity and set_molecular_charge; # work for single-fragment molecules.; if self.nfragments() < 2:; self.PYmolecular_charge = temp_charge; self.PYmultiplicity = temp_multiplicity. [docs] def update_geometry(self):; """"""Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule. >>> H2 = qcdb.Molecule(""H\\nH 1 0.74\\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rather than the symmetry; # the the user might have provided.; frame = self.symmetry_frame(); self.rotate_full(frame); #print ""after rotate:""; #self.print_full(). # Recompute point group of the molecule, so the symmetry info is updated to the new frame; self.set_point_group(self.find_point_g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:47849,Validat,ValidationError,47849,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"type = 1; # elif der2nd.match(str(dertype)):; # raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). # if func is None:; # if dashparam is None:; # # defunct case; # raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); # else:; # # case where all param read from dashparam dict (which must have all correct keys); # func = 'custom'; # dashcoeff[dashlvl][func] = {}; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # for key in dashcoeff[dashlvl]['b3lyp'].keys():; # if key in dashparam.keys():; # dashcoeff[dashlvl][func][key] = dashparam[key]; # else:; # raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); # else:; # func = func.lower(); # if func not in dashcoeff[dashlvl].keys():; # raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); # if dashparam is None:; # # (normal) case where all param taken from dashcoeff above; # pass; # else:; # # case where items in dashparam dict can override param taken from dashcoeff above; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # for key in dashcoeff[dashlvl]['b3lyp'].keys():; # if key in dashparam.keys():; # dashcoeff[dashlvl][func][key] = dashparam[key]. # TODO temp until figure out paramfile; allowed_funcs = ['HF/MINIS', 'DFT/MINIS', 'HF/MINIX', 'DFT/MINIX',; 'HF/SV', 'DFT/SV', 'HF/def2-SV(P)', 'DFT/def2-SV(P)', 'HF/def2-SVP',; 'DFT/def2-SVP', 'HF/DZP', 'DFT/DZP', 'HF/def-TZVP', 'DFT/def-TZVP',; 'HF/def2-TZVP', 'DFT/def2-TZVP', 'HF/631Gd', 'DFT/631Gd',; 'HF/def2-TZVP', 'DFT/def2-TZVP', 'HF/cc-pVDZ', 'DFT/cc-pVDZ',; 'HF/aug-cc-pVDZ', 'DFT/aug-cc-pVDZ', 'DFT/SV(P/h,c)', 'DFT/LANL',; 'DFT/pobTZVP', 'TPSS/def2-SVP', 'PW6B95/def2-SVP',; # specials; 'hf3c', 'pbeh3c']; allowed_funcs = [f.lower(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html:4329,Validat,ValidationError,4329,psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,2,['Validat'],['ValidationError']
Security,"type = 2. optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['hessian']:; dertype = 2; elif lowername in procedures['gradient']:; dertype = 1; func = gradient; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; freq_dertype = kwargs['dertype']. if der0th.match(str(freq_dertype)):; dertype = 0; func = energy; elif der1st.match(str(freq_dertype)):; dertype = 1; func = gradient; elif der2nd.match(str(freq_dertype)):; dertype = 2; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function frequency.' % (freq_dertype)). # 3. if the user provides a custom function THAT takes precedence; if ('freq_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['freq_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['freq_func']. # Summary validation; if (dertype == 2) and (lowername in procedures['hessian']):; pass; elif (dertype == 1) and (func is gradient) and (lowername in procedures['gradient']):; pass; elif (dertype == 1) and not(func is gradient):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:59150,Validat,ValidationError,59150,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"t’, ‘pickle’}. Returns; The requested model from a serialized format. Return type; Model. plan()[source]¶; Form QCSchema input from member data. Return type; AtomicInput. classmethod schema(by_alias=True, ref_template='#/definitions/{model}')¶. Return type; DictStrAny. Parameters. by_alias (bool) – ; ref_template (unicode) – . classmethod schema_json(*, by_alias=True, ref_template='#/definitions/{model}', **dumps_kwargs)¶. Return type; unicode. Parameters. by_alias (bool) – ; ref_template (unicode) – ; dumps_kwargs (Any) – . serialize(encoding, *, include=None, exclude=None, exclude_unset=None, exclude_defaults=None, exclude_none=None)¶; Generates a serialized representation of the model. Parameters. encoding (str) – The serialization type, available types are: {‘json’, ‘json-ext’, ‘msgpack-ext’}; include (Optional[Set[str]], optional) – Fields to be included in the serialization.; exclude (Optional[Set[str]], optional) – Fields to be excluded in the serialization.; exclude_unset (Optional[bool], optional) – If True, skips fields that have default values provided.; exclude_defaults (Optional[bool], optional) – If True, skips fields that have set or defaulted values equal to the default.; exclude_none (Optional[bool], optional) – If True, skips fields that have value None. Returns; The serialized model. Return type; Union[bytes, str]. classmethod set_basis(basis)[source]¶. classmethod set_keywords(keywords)[source]¶. classmethod set_method(method)[source]¶. classmethod update_forward_refs(**localns)¶; Try to update ForwardRefs on fields based on this Model, globalns and localns. Return type; None. Parameters; localns (Any) – . classmethod validate(value)¶. Return type; Model. Parameters; value (Any) – . «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; AtomicComputer. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html:6904,validat,validate,6904,psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html,1,['validat'],['validate']
Security,"t” suffix) plus ”.out”. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -s <name>, --scratch <name>¶; This overrides the value of PSI_SCRATCH and provides; a path to the location of scratch files. --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to Psi4 for available templates. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -V, --version¶; Print version information.; >>> psi4 --version; 0.4.262. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence Psi4‘s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; Configuring Psi4 through PSIPATH is preferred; to modifying this environment variable. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that Psi4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh; >>> setenv PSI_SCRATCH /scratch/user. # bash; >>> export PSI_SCRATCH=/scratch/user. You can also include the above",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:15563,access,access,15563,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['access'],['access']
Security,"ublished by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #; from __future__ import absolute_import; from __future__ import print_function; from decimal import Decimal, ROUND_FLOOR, ROUND_CEILING; from .exceptions import *. [docs]class PreservingDict(dict):; """"""Class to store quantum chemical quantities extracted from output; files. Extends the dictionary object to (1) store key as all-caps; version of itself and (2) validate value for duplicate values for the; same key by testing which has more decimal places and whether value; the same within a plausing rounding error. Allows consistency checks; when parsing output files without loss of precision. """""". def __init__(self, *args, **kwargs):; self.update(*args, **kwargs). def __setitem__(self, key, value):; try:; key = key.upper(); except AttributeError:; raise AttributeError('Keys stored as upper-case strings: %s unsuitable' % (key)); value = Decimal(value); if key in self.keys() and not 'CURRENT' in key:; # Validate choosing more detailed value for variable; existing_exp = self[key].as_tuple().exponent # 0.1111 --> -4; candidate_exp = value.as_tuple().exponent; if existing_exp > candidate_exp: # candidate has more digits; places = Decimal(10) ** (existing_exp + 1) # exp+1 permits slack in rounding; best_value = value; else: # existing has more digits; places = Decimal(10) ** (candidate_exp + 1); best_value = self[key]; # Validate values are the same; places = max(places, Decimal('1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:1332,validat,validate,1332,psi4manual/1.0.0/_modules/qcdb/pdict.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html,1,['validat'],['validate']
Security,"uded in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import absolute_import; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error mess",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:1327,Validat,ValidationError,1327,psi4manual/1.0.0/_modules/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html,1,['Validat'],['ValidationError']
Security,"ue. elif (core.get_option('SCF', 'GUESS') == 'READ') and not os.path.isfile(read_filename):; core.print_out(f""\n !!! Unable to find file {read_filename}, defaulting to SAD guess. !!!\n\n""); core.set_local_option('SCF', 'GUESS', 'SAD'); sad_basis_list = core.BasisSet.build(scf_wfn.molecule(), ""ORBITAL"",; core.get_global_option(""BASIS""),; puream=scf_wfn.basisset().has_puream(),; return_atomlist=True); scf_wfn.set_sad_basissets(sad_basis_list). if (""DF"" in core.get_option(""SCF"", ""SAD_SCF_TYPE"")):; sad_fitting_list = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_SAD"",; core.get_option(""SCF"", ""DF_BASIS_SAD""),; puream=scf_wfn.basisset().has_puream(),; return_atomlist=True); scf_wfn.set_sad_fitting_basissets(sad_fitting_list). if cast:; core.print_out(""\n Computing basis projection from %s to %s\n\n"" % (ref_wfn.basisset().name(), base_wfn.basisset().name())); if ref_wfn.basisset().n_ecp_core() != base_wfn.basisset().n_ecp_core():; raise ValidationError(""Projecting from basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:46617,Validat,ValidationError,46617,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,6,['Validat'],['ValidationError']
Security,"ue. elif (core.get_option('SCF', 'GUESS') == 'READ') and not os.path.isfile(read_filename):; core.print_out(f""\n !!! Unable to find file {read_filename}, defaulting to SAD guess. !!!\n\n""); core.set_local_option('SCF', 'GUESS', 'SAD'); sad_basis_list = core.BasisSet.build(scf_wfn.molecule(), ""ORBITAL"",; core.get_global_option(""BASIS""),; puream=scf_wfn.basisset().has_puream(),; return_atomlist=True); scf_wfn.set_sad_basissets(sad_basis_list). if (""DF"" in core.get_option(""SCF"", ""SAD_SCF_TYPE"")):; sad_fitting_list = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_SAD"",; core.get_option(""SCF"", ""DF_BASIS_SAD""),; puream=scf_wfn.basisset().has_puream(),; return_atomlist=True); scf_wfn.set_sad_fitting_basissets(sad_fitting_list). if cast:; core.print_out(""\n Computing basis projection from %s to %s\n\n"" % (ref_wfn.basisset().name(), base_wfn.basisset().name())); if ref_wfn.basisset().n_ecp_core() != base_wfn.basisset().n_ecp_core():; raise ValidationError(""Projecting from basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute dftd3; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:46577,Validat,ValidationError,46577,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"uencies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples. >>> # [1] Frequency",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequencies-1.html:1097,access,accesses,1097,psi4manual/1.4.0/api/psi4.driver.frequencies-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequencies-1.html,5,['access'],['accesses']
Security,"ugh each active conda package off https://anaconda.org/psi4/repo. Find the most recent build set (Linux/Mac, active py versions) that psi4/psi4-rt/psi4-dev is using; _add_ (not replace) the main label. This makes a conda install psi4 -c psi4 get everything psi4 needs. For the moment conda install psi4 -c psi4/label/dev will get the same set, until package psi4-1.4a1.dev1 gets uploaded. May help to check versions and build versions against ltrtver in conda_build_config.yaml.; This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from “main”, not “dev”). Build Psi4conda set (pre-Spring 2021)¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They can be built anywhere (Mac can be built on Linux) and get served from vergil (cdsgroup webserver). Need a conda env with constructor and cookiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/manage_release-1.html:11466,access,accessed,11466,psi4manual/1.5.0/manage_release-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/manage_release-1.html,5,['access'],['accessed']
Security,"uilt from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; libefp can be obtained through conda install libefp.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source psi4/psi4/share/psi4/efpfrag. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are searched; for first in the current directory, next in the paths of PSIPATH, and; finally in built-in library. If PSI4 is unable to find the; fragment, an error will be reported. Note; When constructing new fragment files, the name of the name of the; file should be lowercase and have extension .efp. The molecule name; within the file, e.g., $NH3 must correspond to the name of the; fragment file. Molecule Specification¶; EFP fragment geometries are specified alongside the quantum mechanical; (QM) molecule and make use of the -- fragment separation scheme; described here. Each EFP fragment has its own; fragment section that includes the label efp, the name of the file; fragname from which EFP parameters are to be read, and the position; specification for the fragment in one of two ways, XYZABC or POINTS. For; XYZABC, the fragment specification is all",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libefp-1.html:1783,access,accessible,1783,psi4manual/1.1.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libefp-1.html,2,['access'],['accessible']
Security,"uired]¶. Validated by:. set_driver. field findifrec: Dict[str, Any] = {}¶. field metameta: Dict[str, Any] = {}¶. field method: str [Required]¶. field molecule: Any = None¶. Validated by:. set_molecule. field task_list: Dict[str, BaseComputer] = {}¶. computer¶; alias of AtomicComputer. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶; Run each job in task list. Parameters:; client (Optional[FractalClient]) – . get_psi_results(return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:; return_wfn (bool) – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. Return type:; Union[float, Matrix, Tuple[Union[float, Matrix], Wavefunction]]. Returns:. ret – Gradient or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. get_results(client=None)[source]¶; Return results as FiniteDifference-flavored QCSchema. Return type:; AtomicResult. Parameters:; client (Optional[FractalClient]) – . plan()[source]¶. validator set_driver  »  driver[source]¶. validator set_molecule  »  molecule[source]¶. table of contents. Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes; Molden Interface Keywords; NORMAL_MODES_WRITE; WRITER_FILE_LABEL. psi4.driver.qcdb.vib Module; Functions. API. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/freq.html:10669,validat,validator,10669,psi4manual/1.7.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/freq.html,2,['validat'],['validator']
Security,"ulation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs] @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs] @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs] @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs] @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs] @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs] @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs] def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as nece",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:35039,validat,validator,35039,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,1,['validat'],['validator']
Security,"uld add its own; output.ref. When that doesn’t happen, this command helps.; find tests/ -mindepth 1 -maxdepth 1 -type d '!' -exec test -e ""{}/output.ref"" "";"" -print. How to do GitHub issue management and code review¶. Anyone, core-dev or not, is encouraged to review PRs. It’s actually good practice for interacting with other open-source projects, where you don’t have the advantage of knowing or working with the contributors. Before venturing into projects on GitHub where you don’t know the maintainers, it doesn’t hurt to read https://snarky.ca/setting-expectations-for-open-source-participation/ .; Psi4 is a learning tool for all involved, so partial reviews in areas of confidence and questions and comments on PRs in general are encouraged.; Approving before CI completes is fine, though it can be mildly personally embarrassing when CI catches something you didn’t.; All main branches (master and 1.N.x maintenance) are protected by GitHub, including administrators, so even with write access, no one can accidentally push (master) or rewrite the history (master and maintenance).; PR owners who also have maintainer status can merge their PRs as GitHub enforces three external reviews.; Unless there’s been a lot of discussion on core-dev about merge order, generally the 3rd positive reviewer merges the PR. Also fine to add review and leave merge for later.; Presently only Travis-CI is set up as a required-to-merge service. Incomplete Azure won’t block merging, but we do usually let it complete before merging unless it’s a trivial PR.; We don’t enforce branches to be up to date before merging since that’d be a lot of extra CI time and coordination when merging several PRs in a day. So, if a PR hasn’t been updated in a while, and a reviewer is nervous about PR interference, fine to ask submitter to rebase. For this reason, we try to merge newer contributors first so the rebase falls on more experienced contributors.; Ideally a PR consists of atomic, compilable commits. When th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_git-1.html:9109,access,access,9109,psi4manual/1.4.0/manage_git-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_git-1.html,6,['access'],['access']
Security,"uld add its own; output.ref. When that doesn’t happen, this command helps.; find tests/ -mindepth 1 -maxdepth 1 -type d '!' -exec test -e ""{}/output.ref"" "";"" -print. How to do GitHub issue management and code review¶. Anyone, core-dev or not, is encouraged to review PRs. It’s actually good practice for interacting with other open-source projects, where you don’t have the advantage of knowing or working with the contributors. Before venturing into projects on GitHub where you don’t know the maintainers, it doesn’t hurt to read https://snarky.ca/setting-expectations-for-open-source-participation/ .; Psi4 is a learning tool for all involved, so partial reviews in areas of confidence and questions and comments on PRs in general are encouraged.; Approving before CI completes is fine, though it can be mildly personally embarrassing when CI catches something you didn’t.; All main branches (master and 1.N.x maintenance) are protected by GitHub, including administrators, so even with write access, no one can accidentally push (master) or rewrite the history (master and maintenance).; PR owners who also have maintainer status can merge their PRs as GitHub enforces two external reviews.; Unless there’s been a lot of discussion on core-dev about merge order, generally the 2nd positive reviewer merges the PR. Also fine to add review and leave merge for later.; Presently only Azure is set up as a required-to-merge service. Incomplete GHA Ecosystem or Docs won’t block merging, but we do usually let it complete before merging unless it’s a trivial PR.; We don’t enforce branches to be up to date before merging since that’d be a lot of extra CI time and coordination when merging several PRs in a day. So, if a PR hasn’t been updated in a while, and a reviewer is nervous about PR interference, fine to ask submitter to rebase. Or, there’s an update button on the PR – but if this is used, warn the submitted that their remote and local branches will be out of sync. For this reason, we try ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/manage_git.html:9118,access,access,9118,psi4manual/master/manage_git.html,https://psicode.org,https://psicode.org/psi4manual/master/manage_git.html,3,['access'],['access']
Security,"ule calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']) # yes, this really must be global, not local to SCF. # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:67001,Validat,ValidationError,67001,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"ult: CDGESV. LINEQ_SOLVER (OCC)¶OCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. LINESEARCH_STATIC_MAX (OPTKING)¶OPTKING — If doing a static line search, this fixes the largest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.100. LINESEARCH_STATIC_MIN (OPTKING)¶OPTKING — If doing a static line search, this fixes the shortest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.001. LINESEARCH_STATIC_N (OPTKING)¶OPTKING — If doing a static line search, scan this many points. Type: integer; Default: 8. LINK_INTS_TOLERANCE (SCF)¶SCF — The screening tolerance used for ERI/Density sparsity in the LinK algorithm. Type: conv double; Default: 1.0e-12. LITERAL_CFOUR (GLOBALS)¶GLOBALS — Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through cfour {...} block. Type: string; Default: No Default. LOCAL (CCENERGY)¶CCENERGY — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCEOM)¶CCEOM — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCLAMBDA)¶CCLAMBDA — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCRESPONSE)¶CCRESPONSE — Do simulate local correlation?. Type: boolean; Default: false. LOCAL_CONVERGENCE (DLPNO)¶DLPNO — Convergence criteria for the Foster-Boys orbital localization. Type: conv double; Default: 1.0e-12. LOCAL_CONVERGENCE (FISAPT)¶FISAPT — Relative convergence in orbital localization. Type: conv double; Default: 1.0e-12. LOCAL_CONVERGENCE (SCF)¶SCF — The convergence on the orbital localization procedure. Type: conv double; Default: 1e-12. LOCAL_CPHF_CUTOFF (CCENERGY)¶CCENERGY — Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. LOCAL",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:154126,Access,Access,154126,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,1,['Access'],['Access']
Security,"ults kwarg; * in struct[""intermediates_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""ManyBodyComputer"",; ]. import copy; import itertools; import math; from typing import Any, Callable, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union; from ast import literal_eval; from enum import Enum. from pydantic import Field, validator. import pprint; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from qcelemental.models import DriverEnum, AtomicResult. from psi4 import core; from psi4.driver import constants, driver_nbody_multilevel, p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.task_base import BaseComputer, EnergyGradientHessianWfnReturn. logger = logging.getLogger(__name__). SubTaskComputers = Union[""AtomicComputer"", ""CompositeComputer"", ""FiniteDifferenceComputer""]; FragBasIndex = Tuple[Tuple[int], Tuple[int]]. [docs]def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:7360,validat,validator,7360,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,1,['validat'],['validator']
Security,"ult’]) from name_hint and/or; dashcoeff_supplement and/or user param_tweaks. Type; dict. fctldash¶; If dashparams for dashlevel corresponds to a defined,; named, untweaked “functional-dashlevel” set, then that; functional. Otherwise, empty string. Type; str. description¶; Tagline for dispersion dashlevel. Type; str. dashlevel_citation¶; Literature reference for dispersion dashlevel in general,; not necessarily for dashparams. Type; str. dashparams_citation¶; Literature reference for dispersion parameters, if dashparams; corresponds to a defined, named, untweaked “functional-dashlevel”; set with a citation. Otherwise, empty string. Type; str. dashcoeff_supplement¶; See description in qcengine.programs.empirical_dispersion_resources.from_arrays. Used; here to “bless” the dispersion definitions attached to; the procedures/dft/<rung>_functionals-defined dictionaries; as legit, non-custom, and of equal validity to; qcengine.programs.empirical_dispersion_resources.dashcoeff itself for purposes of; validating fctldash. Type; dict. engine¶; {‘libdisp’, ‘dftd3’, ‘nl’, ‘mp2d’, “dftd4”}; Compute engine for dispersion. One of Psi4’s internal libdisp; library, external Grimme or Beran projects, or nl. Type; str. disp¶; Only present for engine =libdisp. Psi4 class instance prepared; to compute dispersion. Type; Dispersion. ordered_params¶; Fixed-order list of relevant parameters for dashlevel. Matches; DISPERSION CORRECTION ENERGY ordering. Used for printing. Type; list. Parameters. name_hint (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.empiricaldispersion.html:1878,validat,validating,1878,psi4manual/1.5.0/api/psi4.driver.empiricaldispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.empiricaldispersion.html,5,['validat'],['validating']
Security,"ult’]) from name_hint and/or; dashcoeff_supplement and/or user param_tweaks. Type; dict. fctldash¶; If dashparams for dashlevel corresponds to a defined,; named, untweaked “functional-dashlevel” set, then that; functional. Otherwise, empty string. Type; str. description¶; Tagline for dispersion dashlevel. Type; str. dashlevel_citation¶; Literature reference for dispersion dashlevel in general,; not necessarily for dashparams. Type; str. dashparams_citation¶; Literature reference for dispersion parameters, if dashparams; corresponds to a defined, named, untweaked “functional-dashlevel”; set with a citation. Otherwise, empty string. Type; str. dashcoeff_supplement¶; See description in qcengine.programs.empirical_dispersion_resources.from_arrays. Used; here to “bless” the dispersion definitions attached to; the procedures/dft/<rung>_functionals-defined dictionaries; as legit, non-custom, and of equal validity to; qcengine.programs.empirical_dispersion_resources.dashcoeff itself for purposes of; validating fctldash. Type; dict. engine¶; {‘libdisp’, ‘dftd3’, ‘nl’, ‘mp2d’}; Compute engine for dispersion. One of Psi4’s internal libdisp; library, Grimme’s DFTD3 executable, or nl. Type; str. disp¶; Only present for engine =libdisp. Psi4 class instance prepared; to compute dispersion. Type; Dispersion. ordered_params¶; Fixed-order list of relevant parameters for dashlevel. Matches; DISPERSION CORRECTION ENERGY ordering. Used for printing. Type; list. Parameters. name_hint (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.empiricaldispersion.html:1864,validat,validating,1864,psi4manual/1.4.0/api/psi4.driver.empiricaldispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.empiricaldispersion.html,3,['validat'],['validating']
Security,"um chemistry method to evaluate (e.g., B3LYP, MP2, …). Validated by:. set_method. field molecule: Any [Required]¶; The molecule to use in the computation. field owner_group: Optional[str] = None¶; group in the chown sense. field priority: str = 1¶; The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}. field protocols: Union[AtomicResultProtocols, Dict[str, Any], None] = {'stdout': True}¶; Output modifications. field result: Any [Optional]¶; AtomicResult return. field result_id: Optional[str] = None¶; The optional ID for the computation. field tag: str = '*'¶; The tags to pass along to compute managers. compute(client=None)[source]¶; Run quantum chemistry. Parameters:; client (qcportal.client.FractalClient | None). get_results(client=None)[source]¶; Return results as Atomic-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None). Return type:; AtomicResult. plan()[source]¶; Form QCSchema input from member data. Return type:; AtomicInput. validator set_basis  »  psi4.driver.AtomicComputer.basis[source]¶. validator set_keywords  »  psi4.driver.AtomicComputer.keywords[source]¶. validator set_method  »  psi4.driver.AtomicComputer.method[source]¶. table of contents. AtomicComputer; AtomicComputer; AtomicComputer.basis; AtomicComputer.computed; AtomicComputer.driver; AtomicComputer.keywords; AtomicComputer.method; AtomicComputer.molecule; AtomicComputer.owner_group; AtomicComputer.priority; AtomicComputer.protocols; AtomicComputer.result; AtomicComputer.result_id; AtomicComputer.tag; AtomicComputer.compute(); AtomicComputer.get_results(); AtomicComputer.plan(); AtomicComputer.set_basis; AtomicComputer.set_keywords; AtomicComputer.set_method. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; AtomicComputer. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.AtomicComputer.html:6568,validat,validator,6568,psi4manual/master/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.AtomicComputer.html,3,['validat'],['validator']
Security,"umPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type. get(*args, **kwargs); Overloaded function. get_block(self, slice); Get a vector block. init(self, arg0); Reallocate the data of the Vector. load(self, psio, file); Load the vector from disk. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename, prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). print_out(self); Prints the vector to the output file. save(self, psio, file); Save the vector to disk. scale(self, sc); Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set_block(self, slice, block); Set a vector block. to_array([copy, dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. vector_dot(self, other); Take the dot product of two vectors. zero(self); Zeros the vector. Attributes Documentation. name¶; The name of the Vector. Used in printing. np¶; View with single irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. add(*args, **kwargs)¶; Overloaded function. add(self: psi4.core.Vector, m: int, val: float) -> None. Add to a single element value located at m. add(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Add to a single element value located at m in irrep h. array_interface(self: psi4.core.Vector) → list¶. axpby(self: psi4.core.Vector, a: float, b: float, other: psi4.core.Vector) → None¶; Adds to this vector scaled by b another vector scaled by a; self <- a * other + b * self. axpy(self: psi4.core.Vector, a: float, other: psi4.core.Vector) → None¶; Adds to this vector (unscaled) another vector scaled by a; self <- a * other + self. clone(self: psi4.core.Vector) → psi4.core.Vector¶; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html:1884,access,accessor,1884,psi4manual/1.8.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html,2,['access'],['accessor']
Security,"umPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type. get(*args, **kwargs); Overloaded function. get_block(self, slice); Get a vector block. init(self, arg0); Reallocate the data of the Vector. load(self, psio, file); Load the vector from disk. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename, prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). print_out(self); Prints the vector to the output file. save(self, psio, file); Save the vector to disk. scale(self, sc); Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set_block(self, slice, block); Set a vector block. to_array([copy, dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. vector_dot(self, other); Take the dot product of two vectors. zero(self); Zeros the vector. Attributes Documentation. name¶; The name of the Vector. Used in printing. np¶; View with single irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. add(*args, **kwargs)¶; Overloaded function. add(self: psi4.core.Vector, m: int, val: float) -> None. Add to a single element value located at m. add(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Add to a single element value located at m in irrep h. array_interface(self: psi4.core.Vector) → list¶. axpy(self: psi4.core.Vector, a: float, other: psi4.core.Vector) → None¶; Adds to this vector another vector scaled by a. clone(self: psi4.core.Vector) → psi4.core.Vector¶; Clone the vector. copy(self: psi4.core.Vector, arg0: psi4.core.ProtoVector) → None¶; Copy another vector into this. dim(self: psi4.core.Vector, h: int = 0) → int¶; Returns the dimensions of the vector per irrep ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Vector.html:1729,access,accessor,1729,psi4manual/1.7.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Vector.html,1,['access'],['accessor']
Security,"umes\n""); free_atom_volumes(wfn). oe.compute(). [docs]; def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]; def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to be set.; A string is taken as a unit-containing value (e.g., 30 mb), which is; case-insensitive.; execute; When False, interpret *inputval* without setting in Psi4 core.; quiet; When True, do not print to the output file. Returns; -------; int; Number of bytes of memory set. Raises; ------; ValidationError; When <500MiB or disallowed type or misformatted. Examples; --------. >>> # [1] Passing absolute number of bytes; >>> psi4.set_memory(600000000); >>> psi4.get_memory(); Out[1]: 600000000L. >>> # [2] Passing memory value as string with units; >>> psi4.set_memory('30 GB'); >>> psi4.get_memory(); Out[2]: 3000000000",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html:3507,Validat,ValidationError,3507,psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,2,['Validat'],['ValidationError']
Security,"un_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},. ""aqcc"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},; ""fno-aqcc"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},. ""cisd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; ""fno-cisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. some of these pre-trapped by select_* functions but others escape, incl. cepa variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_cepa`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:177928,Validat,ValidationError,177928,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"un_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:87976,Validat,ValidationError,87976,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"un_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:83438,Validat,ValidationError,83438,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"unc = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of Psi4 “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. Table Of Contents. Adding Methods to Driver; proc.py; Managed Methods. Previous topic; LibOptions: globals, locals, has_changed and all that; Next topic; BasisSet. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Programming: Using the Core Libraries ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/proc_py-1.html:6549,access,access,6549,psi4manual/1.0.0/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/proc_py-1.html,2,['access'],['access']
Security,"unction to convert a NumPy array to a Psi4 object. Examples; --------. >>> data = np.random.rand(20); >>> vector = array_to_matrix(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4); """""". # What type is it? MRO can help.; arr_type = self.__mro__[0]. # Irreped case; if isinstance(arr, (list, tuple)):; if (dim1 is not None) or (dim2 is not None):; raise ValidationError(""Array_to_Matrix: If passed input is list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == core.Matrix:; sdim1 = core.Dimension(irreps); sdim2 = core.Dimension(irreps). for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError (""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); view = _get_raw_views(ret)[0]; view[:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:4507,Validat,ValidationError,4507,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"unction to convert a NumPy array to a Psi4 object. Examples; --------. >>> data = np.random.rand(20); >>> vector = array_to_matrix(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4); """""". # What type is it? MRO can help.; arr_type = self.__mro__[0]. # Irreped case; if isinstance(arr, (list, tuple)):; if (dim1 is not None) or (dim2 is not None):; raise ValidationError(""Array_to_Matrix: If passed input is list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == core.Matrix:; sdim1 = core.Dimension(irreps); sdim2 = core.Dimension(irreps). for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html:3737,Validat,ValidationError,3737,psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,2,['Validat'],['ValidationError']
Security,"unction.""""""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(""""""CC property name %s not recognized"""""" % name.upper()). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cclambda(ccwfn); core.ccdensity(ccwfn). # Need ccresponse only for response-type props; if n_response > 0:; core.set_global_option('DERTYPE', 'RESPONSE'); core.cclambda(ccwfn); for prop in response:; core.set_global_option('PROPERTY', prop); core.ccresponse(ccwfn). # Excited-state transition properties; if n_excited > 0:; if name == 'eom-ccsd':; core.set_globa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:73555,Validat,ValidationError,73555,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"unction.""""""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); psi4.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); psi4.set_global_option('WFN', this_name); else:; raise ValidationError(""""""CC property name %s not recognized"""""" % name.upper()). # Need cchbar for everything; psi4.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; psi4.set_global_option('WFN', 'EOM_CCSD'); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cceom(ccwfn); elif name == 'eom-cc2':; psi4.set_global_option('WFN', 'EOM_CC2'); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cceom(ccwfn); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cclambda(ccwfn); psi4.ccdensity(ccwfn). # Need ccresponse only for response-type props; if n_response > 0:; psi4.set_global_option('DERTYPE', 'RESPONSE'); psi4.cclambda(ccwfn); for prop in response:; psi4.set_global_option('PROPERTY', prop); psi4.ccresponse(ccwfn). # Excited-state transition properties; if n_excited > 0:; if name == 'eom-ccsd':; psi4.set_globa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:60897,Validat,ValidationError,60897,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:48757,access,accesses,48757,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['access'],['accesses']
Security,"unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:52009,access,accesses,52009,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['access'],['accesses']
Security,"up(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). elif xyzC.match(text[2 + i]):. fileAtom = int(float(xyzC.match(text[2 + i]).group(1))); fileX = float(xyzC.match(text[2 + i]).group(2)); fileY = float(xyzC.match(text[2 + i]).group(3)); fileZ = float(xyzC.match(text[2 + i]).group(4)). # Check that the atomic number is valid; if not fileAtom in z2el:; raise ValidationError('Illegal atom symbol in geometry specification: %d' % (fileAtom)). # Add it to the molecule.; instance.add_atom(fileAtom, fileX, fileY, fileZ, z2el[fileAtom], z2mass[fileAtom], fileAtom). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. @classmethod; [docs] def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if availab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:5430,Validat,ValidationError,5430,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"up(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). elif xyzC.match(text[2 + i]):. fileAtom = int(float(xyzC.match(text[2 + i]).group(1))); fileX = float(xyzC.match(text[2 + i]).group(2)); fileY = float(xyzC.match(text[2 + i]).group(3)); fileZ = float(xyzC.match(text[2 + i]).group(4)). # Check that the atomic number is valid; if not fileAtom in z2el:; raise ValidationError('Illegal atom symbol in geometry specification: %d' % (fileAtom)). # Add it to the molecule.; instance.add_atom(fileAtom, fileX, fileY, fileZ, z2el[fileAtom], z2mass[fileAtom], fileAtom). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d.\n%s:%s"" %; (i + 3, xyzfilename, text[i + 2])); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3,; text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.PYinput_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.PYinput_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:8095,Validat,ValidationError,8095,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"up(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; z = qcel.periodictable.to_Z(fileAtom). # Add it to the molecule.; instance.add_atom(z, fileX, fileY, fileZ, fileAtom, qcel.periodictable.to_mass(fileAtom), z). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(; ""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.PYinput_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.PYinput_units_to_au = 1.0 / constants.bohr2angstroms. instance.update_geometry(); return instance. def save_string_xyz(self, save_ghosts=True, save_natom=False):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html:9099,Validat,ValidationError,9099,psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html,2,['Validat'],['ValidationError']
Security,"up(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; z = qcel.periodictable.to_Z(fileAtom). # Add it to the molecule.; instance.add_atom(z, fileX, fileY, fileZ, fileAtom, qcel.periodictable.to_mass(fileAtom), z). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(; ""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.PYinput_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.PYinput_units_to_au = 1.0 / qcel.constants.bohr2angstroms. instance.update_geometry(); return instance. def save_string_xyz(self, save_ghosts=True, save_natom=False):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:8914,Validat,ValidationError,8914,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,6,['Validat'],['ValidationError']
Security,"upply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH`. """"""; # Validate arguments; if self is None:; self = psi4.get_active_molecule(). dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:8374,Validat,ValidationError,8374,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"urce]¶; Detects fragments in unfragmented molecule using BFS algorithm.; Currently only used for the WebMO implementation of SAPT. Parameters:. molecule (molecule, optional) – The target molecule, if not the last molecule defined.; seed_atoms (Optional[List[List[int]]]) – List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]. Return type:; Molecule. Returns:. Molecule – fragmented molecule in; Cartesian, fixed-geom (no variable values), no dummy-atom format. Examples; >>> # [1] prepare unfragmented (and non-adjacent-atom) HHFF into (HF)_2 molecule ready for SAPT; >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. psi4.driver.inputparser.process_input(raw_input, print_level=1)[source]¶; Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python.; :rtype: str; Does a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user’s .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed raw_input. Parameters:. raw_input (str) – Input in a mixture of Python and PSIthon syntax.; print_level (int) – raw_input is printed to the output file unless print_level =0. Return type:; str. psi4.driver.frac.ip_fitting(name, omega_l=0.05, omega_r=2.5, omega_convergence=0.001, maxiter=20, **kwargs)[source]¶; Optimize DFT omega parameter for molecular system. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l (float) – Minimum omega to be considered during fitting.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/external_apis.html:2427,validat,validate,2427,psi4manual/1.9.x/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/external_apis.html,1,['validat'],['validate']
Security,"urce]¶; Detects fragments in unfragmented molecule using BFS algorithm.; Currently only used for the WebMO implementation of SAPT. Parameters:. molecule (molecule, optional) – The target molecule, if not the last molecule defined.; seed_atoms (Optional[List[List[int]]]) – List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]. Return type:; Molecule. Returns:. Molecule – fragmented molecule in; Cartesian, fixed-geom (no variable values), no dummy-atom format. Examples; >>> # [1] prepare unfragmented (and non-adjacent-atom) HHFF into (HF)_2 molecule ready for SAPT; >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. psi4.driver.inputparser.process_input(raw_input, print_level=1)[source]¶; Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python.; Does a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user’s .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed raw_input. Parameters:. raw_input (str) – Input in a mixture of Python and PSIthon syntax.; print_level (int) – raw_input is printed to the output file unless print_level =0. Return type:; str. psi4.driver.frac.ip_fitting(name, omega_l=0.05, omega_r=2.5, omega_convergence=0.001, maxiter=20, **kwargs)[source]¶; Optimize DFT omega parameter for molecular system. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l (float) – Minimum omega to be considered during fitting.; omega_r (fl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external_apis.html:2434,validat,validate,2434,psi4manual/master/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/master/external_apis.html,1,['validat'],['validate']
Security,"urce]¶; Reads binary files JOBARC and JAINDX and returns contents; of each record in reclabelarray. class Infile(mem, mol, mtd, der, opt)[source]¶. format_infile_string()[source]¶. harvest_output(outtext)[source]¶; Function to separate portions of a Psi4 output file outtext. muster_cdsgroup_options()[source]¶. muster_modelchem(name, dertype)[source]¶; Transform calculation method name and derivative level dertype; into options for cfour. While deliberately requested pieces,; generally CFOUR_DERIV_LEVEL and CFOUR_CALC_LEVEL,; are set to complain if contradicted (‘clobber’ set to True), other; ‘recommended’ settings, like CFOUR_CC_PROGRAM, can be; countermanded by keywords in input file (‘clobber’ set to False).; Occasionally, want these pieces to actually overcome keywords in; input file (‘superclobber’ set to True). psi4_list()[source]¶; Return an array of Psi4 methods with energies. Elemental masses (most common isotope), symbols, and atomic numbers from psi4.; File for accessory procedures in the chem module.; Credit for the libmints vector3 class to Justin M. Turney and; incremental improvements by other psi4 developers. add(v, u)[source]¶; Compute sum of vectors v and u. cross(v, u)[source]¶; Compute cross product of length 3 vectors v and u. determinant(mat)[source]¶; Given 3x3 matrix mat, compute the determinat. diagonalize3x3symmat(M)[source]¶; Given an real symmetric 3x3 matrix M, compute the eigenvalues. distance(v, u)[source]¶; Compute the distance between points defined by vectors v and u. dot(v, u)[source]¶; Compute dot product of vectors v and u. identity(m)[source]¶; Create identity matrix. matadd(matrix1, matrix2, fac1=1.0, fac2=1.0)[source]¶; Matrix addition. mscale(matrix, d)[source]¶; Return matrix scaled by scalar d. mult(matrix1, matrix2)[source]¶; Matrix multiplication. naivemult(v, u)[source]¶; Compute by-element multiplication of vectors v and u. norm(v)[source]¶; Compute the magnitude of vector v. normalize(v)[source]¶; Compute normalized vect",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:106855,access,accessory,106855,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['access'],['accessory']
Security,"urllib.parse import quote; from urllib.error import URLError; import xml.etree.ElementTree as ET; import time; import gzip; import re; import sys; import os; from p4util.exceptions import *. [docs]class PubChemObj(object):. def __init__(self, cid, mf, iupac):; self.url = 'http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi'; self.cid = cid; self.mf = mf; self.iupac = iupac; self.natom = 0; self.dataSDF = ''. def __str__(self):; return ""%17d %s\n"" % (self.cid, self.iupac). [docs] def getSDF(self):; """"""Function to return the SDF (structure-data file) of the PubChem object.""""""; if (len(self.dataSDF) == 0):; def extract_xml_keyval(xml, key):; """""" A useful helper function for parsing a single key from XML. """"""; try:; # Python 2.6 (ElementTree 1.2 API); matches = xml.getiterator(key); except:; # Python 2.7 (ElementTree 1.3 API); matches = list(xml.iter(key)); if len(matches) == 0:; return None; elif len(matches) == 1:; return matches[0].text; else:; print(matches); raise ValidationError(""""""PubChem: too many matches found %d"""""" % (len(matches))). url = ""http://pubchem.ncbi.nlm.nih.gov/pug/pug.cgi""; initial_request = """"""; <PCT-Data>; <PCT-Data_input>; <PCT-InputData>; <PCT-InputData_download>; <PCT-Download>; <PCT-Download_uids>; <PCT-QueryUids>; <PCT-QueryUids_ids>; <PCT-ID-List>; <PCT-ID-List_db>pccompound</PCT-ID-List_db>; <PCT-ID-List_uids>; <PCT-ID-List_uids_E>%d</PCT-ID-List_uids_E>; </PCT-ID-List_uids>; </PCT-ID-List>; </PCT-QueryUids_ids>; </PCT-QueryUids>; </PCT-Download_uids>; <PCT-Download_format value=""sdf""/>; <PCT-Download_use-3d value=""true""/>; <PCT-Download_n-3d-conformers>%d</PCT-Download_n-3d-conformers>; </PCT-Download>; </PCT-InputData_download>; </PCT-InputData>; </PCT-Data_input>; </PCT-Data>; """""" % (self.cid, 1). print(""\tPosting PubChem request for CID %d"" % self.cid); server_response = urlopen(url, initial_request).read(); xml = ET.fromstring(server_response); for attempt in range(4):; if attempt == 3:; raise ValidationError(""""""PubChem: timed out"""""")",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:2923,Validat,ValidationError,2923,psi4manual/1.0.0/_modules/pubchem.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html,1,['Validat'],['ValidationError']
Security,"urn cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_legacy_frequencies(cls):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.legacy_frequencies` (accessing c-side member data) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.legacy_frequencies(). def _core_wavefunction_set_frequencies(cls, val):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_frequencies` (accessing c-side member data) instead of `psi4.core.Wavefunction.frequency_analysis` (py-side member data) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_legacy_frequencies(val). core.Wavefunction.frequencies = _core_wavefunction_frequencies; core.Wavefunction.legacy_frequencies = _core_wavefunction_legacy_frequencies; core.Wavefunction.set_frequencies = _core_wavefunction_set_frequencies. def _core_wavefunction_X(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.X` instead of `psi4.core.Wavefunction.lagrangian` is deprecated, and as soon as 1.5 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.lagrangian(). core.Wavefunction.X = _core_wavefunction_X. ## Psi4 v1.3 Export Deprecations. def _core_get_gradient():; """"""; .. deprecated:: 1.2. """"""; warnings.warn(; ""Using `psi4.core.get_gradient` (only used internally for C++ optking; deprecated silently in 1.2) is deprecated, and as soon as 1.6 (or whenever Py",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:38497,access,accessing,38497,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,1,['access'],['accessing']
Security,"urn final. elif isinstance(valueLO, (core.Matrix, core.Vector)):. beta = valueHI.clone(); beta.subtract(valueLO); beta.scale(1 / (zHI**(-alpha) - zLO**(-alpha))); beta.name = 'Helgaker Corl (%s, %s) beta' % (zLO, zHI). value = valueHI.clone(); value.scale(zHI**alpha). tmp = valueLO.clone(); tmp.scale(zLO**alpha); value.subtract(tmp). value.scale(1 / (zHI**alpha - zLO**alpha)); value.name = 'Helgaker Corr (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Helgaker 2-point correlated extrapolation for """"""; """"""method: %s <==\n\n"""""" % (functionname.upper())); core.print_out("""""" LO-zeta (%s) Data\n"""""" % (str(zLO))); valueLO.print_out(); core.print_out("""""" HI-zeta (%s) Data\n"""""" % (str(zHI))); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % alpha); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). # value.add(valueSCF); return value. else:; raise ValidationError(""corl_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). def return_energy_components():; """"""Define some quantum chemical knowledge, namely what methods are subsumed in others."""""". # yapf: disable; VARH = {}; VARH['scf'] = {; 'scf': 'SCF TOTAL ENERGY'}; VARH['hf'] = {; 'hf': 'HF TOTAL ENERGY'}; VARH['mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['dlpno-mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'dlpno-mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2d'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2d': 'MP2D TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver_cbs.html:23217,Validat,ValidationError,23217,psi4manual/1.5.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"urn final. elif isinstance(valueLO, (core.Matrix, core.Vector)):. beta = valueHI.clone(); beta.subtract(valueLO); beta.scale(1 / (zHI**(-alpha) - zLO**(-alpha))); beta.name = 'Helgaker Corl (%s, %s) beta' % (zLO, zHI). value = valueHI.clone(); value.scale(zHI**alpha). tmp = valueLO.clone(); tmp.scale(zLO**alpha); value.subtract(tmp). value.scale(1 / (zHI**alpha - zLO**alpha)); value.name = 'Helgaker Corr (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Helgaker 2-point correlated extrapolation for """"""; """"""method: %s <==\n\n"""""" % (functionname.upper())); core.print_out("""""" LO-zeta (%s) Data\n"""""" % (str(zLO))); valueLO.print_out(); core.print_out("""""" HI-zeta (%s) Data\n"""""" % (str(zHI))); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % alpha); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). # value.add(valueSCF); return value. else:; raise ValidationError(""corl_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). def return_energy_components():; """"""Define some quantum chemical knowledge, namely what methods are subsumed in others."""""". # yapf: disable; VARH = {}; VARH['scf'] = {; 'scf': 'SCF TOTAL ENERGY'}; VARH['hf'] = {; 'hf': 'HF TOTAL ENERGY'}; VARH['mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2d'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2d': 'MP2D TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:23217,Validat,ValidationError,23217,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"urn final. elif isinstance(valueLO, (core.Matrix, core.Vector)):. beta = valueHI.clone(); beta.subtract(valueLO); beta.scale(1 / (zHI**(-alpha) - zLO**(-alpha))); beta.name = 'Helgaker Corl (%s, %s) beta' % (zLO, zHI). value = valueHI.clone(); value.scale(zHI**alpha). tmp = valueLO.clone(); tmp.scale(zLO**alpha); value.subtract(tmp). value.scale(1 / (zHI**alpha - zLO**alpha)); value.name = 'Helgaker Corr (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Helgaker 2-point correlated extrapolation for """"""; """"""method: %s <==\n\n"""""" % (functionname.upper())); core.print_out("""""" LO-zeta (%s) Data\n"""""" % (str(zLO))); valueLO.print_out(); core.print_out("""""" HI-zeta (%s) Data\n"""""" % (str(zHI))); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % alpha); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). # value.add(valueSCF); return value. else:; raise ValidationError(""corl_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). def return_energy_components():; # yapf: disable; VARH = {}; VARH['scf'] = {; 'scf': 'SCF TOTAL ENERGY'}; VARH['hf'] = {; 'hf': 'HF TOTAL ENERGY'}; VARH['mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY',; 'mp4': 'MP4 TOTAL ENERGY'}; VARH['omp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'omp2': 'OMP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:22995,Validat,ValidationError,22995,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"urn full. [docs]def reconcile_options2(full, partial):; """"""Function to take the full snapshot of the liboptions object; encoded in dictionary *full* and reconcile it with proposed options; value changes in *partial*. Overwrites *full* with *partial* if; option untouched, touches *full* if *full* and *partial* are in; agreement, balks if *full* and *partial* conflict. Returns *full*.; Note: this is surprisingly similar to reconcile_options except; that full is essentially empty and lacking in has_changed keys; so presence is enough to satisfy has_changed. consider merging; once mature. """"""; try:; for module, modopts in partial.items():; for kw, kwprop in modopts.items():; #if full[module][kw]['has_changed']:; if full[module][kw]:; if full[module][kw]['value'] != kwprop['value']:; if 'clobber' in kwprop and kwprop['clobber']:; if 'superclobber' in kwprop and kwprop['superclobber']:; # kw in full is touched, conflicts with value in partial,; # but value in partial is paramount, overwrite full with; # value in partial; full[module][kw]['value'] = kwprop['value']; full[module][kw]['has_changed'] = True; #print '@P4C4 Overwriting %s with %s' % (kw, kwprop['value']); else:; raise ValidationError(""""""; Option %s value `%s` set by options block incompatible with; value `%s` in memory/molecule/command/psi4options block."""""" %; (kw, full[module][kw]['value'], kwprop['value'])); else:; # kw in full is touched, conflicts with value in partial,; # but value in partial is recommended, not required, no change; pass; else:; # kw in full is touched, but in agreement with value in partial, no change; pass; else:; # If kw in full is absent, overwrite it with value in partial; full[module][kw]['value'] = kwprop['value']; full[module][kw]['has_changed'] = True; #print '@P4C4 Overwriting %s with %s' % (kw, kwprop['value']). except KeyError as e: # not expected but want to trap; raise ValidationError(""""""Unexpected KeyError reconciling keywords: %s."""""" % (repr(e))). return full. [docs]def con",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/options.html:7620,Validat,ValidationError,7620,psi4manual/1.0.0/_modules/qcdb/options.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/options.html,1,['Validat'],['ValidationError']
Security,"urn scf_xtpl_helgaker_3; else:; raise ValidationError(""Wrong number of basis sets supplied to scf_xtpl: %d"" % nbasis); elif xtpl_type == ""corl"":; if nbasis == 2:; return corl_xtpl_helgaker_2; else:; raise ValidationError(""Wrong number of basis sets supplied to corl_xtpl: %d"" % nbasis); else:; raise ValidationError(""Stage treatment must be 'corl' or 'scf', not '%s'"" % xtpl_type). def _validate_cbs_inputs(cbs_metadata, molecule):; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata : list; List of dicts containing CBS stage keywords.; molecule : qcdb.molecule or psi4.core.Molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for item in cbs_metadata:; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(""Stage {:d} doesn't have defined level of theory!"".format(cbs_metadata.index(item))); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(""Stage {:d} doesn't have defined basis sets!"".format(cbs_metadata.index(item))); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ""scf"", ""c4-scf""]:; scf = {}; if stage[""wfn""].startswith(""c4""):; scf[""wfn""] = ""c4-hf""; else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xtpl(len(scf[""basis""][1]), scf[""treatment""]); scf[""alpha""] = None; scf[""options""] = False; metadata.append(scf); # 2c) keep processing current stage; stage[""treatment""] ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:29469,Validat,ValidationError,29469,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"urn self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def set_basisset(self, name, role='BASIS'):; """"""Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. """"""; self.PYbasissets[role] = name. [docs] def basisset(self, role='BASIS'):; """"""Returns the basis name for the provided type.; * @param type Keyword from input file.; * @returns the value from input. """"""; try:; return self.PYbasissets[role]; except ValueError:; raise ValidationError('CoordEntry::basisset: Basisset not set for %s and type of %s' % \; (self.PYlabel, role)). [docs] def basissets(self):; """"""Returns basisset to atom map""""""; return self.PYbasissets. [docs] def set_shell(self, bshash, key='BASIS'):; """"""Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. """"""; self.PYshells[key] = bshash. [docs] def shell(self, key='BASIS'):; """"""Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. """"""; try:; return self.PYshells[key]; except (ValueError, KeyError):; raise ValidationError('CoordEntry::shells: Shells not set for %s and type of %s' % \; (self.PYlabel, key)). [docs] def shells(self):; """"""Returns shells sets to atom map""""""; return self.PYshells. [docs] def everything(self):; print('\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n Basissets = %s\n\n Shells = %s\n\n' %; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:10473,hash,hash,10473,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['hash'],['hash']
Security,"urney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major; This class extends qcdb.LibmintsMolecule and occasionally; psi4.core.Molecule itself. class qcelemental.datum.Datum(label, units, data, *, comment=None, doi=None, glossary=None, numeric=True)[source]¶; Facilitates the storage of quantum chemical results by labeling them with basic metadata. Parameters. label (str) – ; units (str) – ; data (Any) – ; comment (str) – ; doi (Optional[str]) – ; glossary (str) – ; numeric (bool) – . Return type; None. label¶; Official label for data, often qcvar. May contain spaces. Type; str. units¶; ASCII, LaTeX-like representation of units, without square brackets. Type; str. data¶; Value for label. Type; float or decimal.Decimal or numpy.ndarray. comment¶; Additional notes. Type; str. doi¶; Literature citation or definition DOI link. Type; str. glossary¶; Extended description or definition. Type; str. numeric¶; Whether data is numeric. Pass True to disable validating data as float/Decimal/np.ndarray. Type; bool. class qcelemental.models.types.Array[source]¶. qcelemental.molutil.B787(cgeom, rgeom, cuniq, runiq, do_plot=False, verbose=1, atoms_map=False, run_resorting=False, mols_align=False, run_to_completion=False, algorithm='hungarian_uno', uno_cutoff=0.001, run_mirror=False)[source]¶; Use Kabsch algorithm to find best alignment of geometry cgeom onto; rgeom while sampling atom mappings restricted by runiq and cuniq. Parameters. rgeom (ndarray) – (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom (ndarray) – (nat, 3) array of concern/changeable geometry. Assumed [a0] for RMSD; purposes. Must have same nat, units, and atom content as rgeom.; runiq (ndarray) – (nat,) array of str indicating which rows (atoms) in rgeom are shuffleable; without changing the molecule. Generally hashes of element symbol and; mass are used, but could be as simple as [‘C’, ‘H’, ‘H’, ‘D’, ‘H’] for; monodeuterated methane.; cu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external_apis-1.html:1956,validat,validating,1956,psi4manual/1.4.0/external_apis-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external_apis-1.html,5,['validat'],['validating']
Security,"urrent & prospective tag in psi4/psi4/metadata.py. Use your; decided-upon tag v1.1rc1 and a speculative next tag, say v1.1rc2,; and use 7 “z”s for the part you can’t predict. >>> vi psi4/metadata.py. >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 5d87b55..6cbc05e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,6 +1,6 @@; -__version__ = '1.1a1'; -__version_long = '1.1a1+007a9b6'; -__version_upcoming_annotated_v_tag = '1.1a2'; +__version__ = '1.1rc1'; +__version_long = '1.1rc1+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.1rc2'. >>> git add psi4/metadata.py. >>> git commit -m ""v1.1rc1"". OBSERVE undefined version state. >>> git describe --abbrev=7 --long --always HEAD; v1.1a1-418-g6100822. >>> git describe --abbrev=7 --long --dirty; v1.1a1-418-g6100822. >>> psi4/versioner.py; Undefining version for irreconcilable tags: 1.1a1 (computed) vs 1.1rc1 (recorded); undefined {master} 6100822 1.0.0.999 1.0 <-- undefined+6100822. Note 7-char git hash for the new commit, here “6100822”. ACT to bump tag in git, then bump git tag in code. Use the decided-upon tag v1.1rc1 and the observed hash “6100822” to; mint a new annotated tag, minding that “v”s are present here.; Use the observed hash to edit psi4/psi4/metadata.py and commit immediately. >>> git tag -a v1.1rc1 6100822 -m ""v1.1rc1"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 6cbc05e..fdc202e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,5 +1,5 @@; __version__ = '1.1rc1'; -__version_long = '1.1rc1+zzzzzzz'; +__version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> psi4/versioner.py; Amazing, this can't actually happen that git hash stored at git commit.; >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.1rc1"". OBSERVE current versioning state. Nothing to make note of, this is just a snapshot. >>> psi4/versioner.py; Defining development snapshot version: 1.1rc2.dev1+4e0596e (c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/manage_git.html:2220,hash,hash,2220,psi4manual/master/manage_git.html,https://psicode.org,https://psicode.org/psi4manual/master/manage_git.html,9,['hash'],['hash']
Security,"urrent user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psithoninput-1.html:1905,access,access,1905,psi4manual/1.3.2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psithoninput-1.html,2,['access'],['access']
Security,"used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; from typing import Dict, List, Union. import numpy as np; import qcengine as qcng; from qcelemental.models import AtomicInput. from psi4 import core. from .. import p4util; from ..p4util.exceptions import ValidationError. _engine_can_do = collections.OrderedDict([; # engine order establishes default for each disp; (""libdisp"", [""d1"", ""d2"", ""chg"", ""das2009"", ""das2010"",]),; (""s-dftd3"", [ ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ""d3zeroatm"", ""d3bjatm"", ""d3mzeroatm"", ""d3mbjatm"", ]),; (""dftd3"", [ ""d2"", ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ]),; (""nl"", [ ""nl"", ]),; (""mp2d"", [ ""dmp2"", ]),; (""dftd4"", [ ""d4bjeeqatm"", ]),; (""mctc-gcp"", [ ""3c"", ]),; (""gcp"", [ ""3c"", ]),; ]) # yapf: disable. def _capable_engines_for_disp()-> Dict[str, List[str]]:; """"""Invert _engine_can_do dictionary and check program detection. Returns a dictionary with keys all dispersion levels and values a list of all; capable engines, where the engine in the first element is available, if any are. """"""; try:; from qcengine.testing import _programs as _programs_qcng; except ModuleNotFoundError:; # _programs_qcng is up-to-date with current harnesses but it requires pytest present, so let's provide a workaround; from qc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:1394,Validat,ValidationError,1394,psi4manual/1.9.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,2,['Validat'],['ValidationError']
Security,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:5192,access,accessed,5192,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,4,['access'],['accessed']
Security,"user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc = PsiMod.get_option('DF_BASIS_CC'); #user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'); b_user_wfn = PsiMod.has_global_option_changed('WFN'); user_wfn = PsiMod.get_option('WFN'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:61890,Validat,ValidationError,61890,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"ut file; elif (opt_mode.lower() == 'sow'):; PsiMod.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec(banners). try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; optstash.restore(); return 0.0. if (opt_mode.lower() == 'r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:39695,Validat,ValidationError,39695,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"ut file; elif (opt_mode.lower() == 'sow'):; PsiMod.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec(banners). try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:31252,Validat,ValidationError,31252,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"ut('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; lenv['NO_STOP_MESSAGE'] = '1'. # Obtain the number of threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:111341,Validat,ValidationError,111341,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,5,['Validat'],['ValidationError']
Security,"ut(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, True). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:67371,Validat,ValidationError,67371,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"ut(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_act",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:69945,Validat,ValidationError,69945,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['Validat'],['ValidationError']
Security,"ut(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, True). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_me",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:62580,Validat,ValidationError,62580,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"ut, quantity, sownum, linkage, allvital=False):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); freagent.close(); return E. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta5] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Jul ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:7356,Validat,ValidationError,7356,psi4manual/4.0b5/_modules/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html,1,['Validat'],['ValidationError']
Security,"utation. Returns; attribute if available, None if not. import_ignorecase(module)[source]¶; Function to import module in any possible lettercase ; permutation. Returns module object if available, None if not. kwargs_lower(kwargs)[source]¶; Function to rebuild and return kwargs dictionary; with all keys made lowercase. Should be called by every; function that could be called directly by the user. driver¶. gradient(name, **kwargs)[source]¶; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. hessian(name, **kwargs)[source]¶; Function to compute force constants. Presently identical to frequency(). molden(filename)[source]¶; Function to write wavefunction information in molden; format to filename. parse_arbitrary_order(name)[source]¶; Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. parse_cotton_irreps(irrep)[source]¶; Function to return validated Cotton ordering index from string or integer; irreducible representation irrep. optproc¶; Module to provide mechanism to store and restore option states in driver. class OptionState(option, module=None)[source]¶; Class to store the state of a single option. If module given, the option; value and has_changed value is stored for global, local to module, and used by; module scopes; otherwise (used for BASIS keywords), only global scope is stored.; Class can store, print, and restore option values.; >>> OptionState('SCF_TYPE', 'SCF'). >>> print(OptionState('DF_BASIS_MP2')). restore()[source]¶. class OptionsState(*largs)[source]¶; Class to contain multiple OptionsState() objects.; Used in python driver functions to collect several options before altering; them, then restoring before function return.; >>> optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'REFERENCE']). >>> print(optstash). >>> optstash.restore(). restore()[source]¶. gaussian_n¶.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:18607,validat,validated,18607,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['validat'],['validated']
Security,"utation. Returns; attribute if available, None if not. import_ignorecase(module)[source]¶; Function to import module in any possible lettercase ; permutation. Returns module object if available, None if not. kwargs_lower(kwargs)[source]¶; Function to rebuild and return kwargs dictionary; with all keys made lowercase. Should be called by every; function that could be called directly by the user. driver¶. gradient(name, **kwargs)[source]¶; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. hessian(name, **kwargs)[source]¶; Function to compute force constants. Presently identical to frequency(). molden(filename)[source]¶; Function to write wavefunction information in molden; format to filename. parse_arbitrary_order(name)[source]¶; Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. parse_cotton_irreps(irrep)[source]¶; Function to return validated Cotton ordering index from string or integer; irreducible representation irrep. optproc¶; Module to provide mechanism to store and restore option states in driver. class OptionState(option, module=None)[source]¶; Class to store the state of a single option. If module given, the option; value and has_changed value is stored for global, local to module, and used by; module scopes; otherwise (used for BASIS keywords), only global scope is stored.; Class can store, print, and restore option values.; >>> OptionState('SCF_TYPE', 'SCF'). >>> print(OptionState('DF_BASIS_MP2')). restore()[source]¶. class OptionsState(*largs)[source]¶; Class to contain multiple OptionsState() objects.; Used in python driver functions to collect several options before altering; them, then restoring before function return.; >>> optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'REFERENCE']). >>> print(optstash). >>> optstash.restore(). restore()[source]¶. physconst¶; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:16489,validat,validated,16489,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['validat'],['validated']
Security,"utau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. def validate_and_fill_frame(extern, fix_com=None, fix_orientation=None, fix_symmetry=None):. if fix_com is True:; com = True; elif fix_com is False:; if extern:; raise ValidationError(""Invalid fix_com ({}) with extern ({})"".format(fix_com, extern)); else:; com = False; elif fix_com is None:; com = extern; else:; raise ValidationError(""Invalid fix_com: {}"".format(fix_com)). if fix_orientation is True:; orient = True; elif fix_orientation is False:; if extern:; raise ValidationError(""Invalid fix_orientation ({}) with extern ({})"".format(fix_orientation, extern)); else:; orient = False; elif fix_orientation is None:; orient = extern; else:; raise ValidationError(""Invalid fix_orientation: {}"".format(fix_orientation)). symm = None; if extern:; if fix_symmetry is None:; symm = ""c1""; elif fix_symmetry.lower() == ""c1"":; symm = ""c1""; else:; raise ValidationError(""Invalid (non-C1) fix_symmetry ({}) with extern ({})"".format(fix_symmetry, extern)); else:; if fix_symmetry is not None:; symm = fix_symmetry.lower(). molinit = {}; molinit[""fix_com""] = com; molinit[""fix_orientation""] = orient; if symm:; molinit[""fix_symmetry""] = symm. return molinit. def validate_and_fill_efp(fragment_files=None, hint_types=None, geom_hints=None):. if (; fragment_files is None; or hint_types is None; or geom_hints is None; or fragment_files == [None]; or hint_types == [None]; or geom_hints == [None]; or not (len(fragment_files) == len(hint_types) == len(geom_hints)); ):. raise ValidationError(; """"""Missing or inconsistent length among efp quantities: fragment_files ({}), hint_types ({}), and geom_hints ({})"""""".format(; frag",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:15606,Validat,ValidationError,15606,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"utfile_name()); pathfill = '' if os.path.isabs(core.outfile_name()) else current_directory + os.path.sep. # Handle threading; # OMP_NUM_THREADS from env is in lenv from above; # threads from psi4 -n (core.get_num_threads()) is ignored; # CFOUR_OMP_NUM_THREADS psi4 option takes precedence, handled below; if core.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS') == True:; lenv['OMP_NUM_THREADS'] = str(core.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen([cfour_executable], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); data = data.decode('utf-8'); if not data:; break; core.print_out(data); c4out += data; internal_p4c4_info['output'] = c4out. c4files = {}; core.print_out('\n'); for item in ['GRD', 'FCMFINAL', 'DIPOL']:; try:; with open(psioh.get_default_path() + cfour_tmpdir + '/' + item, 'r') as handle:; c4files[item] = handle.read(); core.print_out(' CFOUR scratch file %s has been read\n' % (item)); core.print_out('%s\n' % c4files[item]); internal_p4c4_info[item.lower()] = c4files[item]; except IOError:; pass; core.print_out('\n'). if molecule.name() == 'blank_molecule_psi4_yo':; qcdbmolecule = None; else:; molecule.update_geometry(); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.update_geometry(). # c4mol, if it exists, is dinky, just a clue to geometry of cfour results; psivar, c4grad, c4mol = qcdb.cfour.harvest(qcdbmolecule, c4out, **c4files). # Absorb results into psi4 data ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html:8448,Validat,ValidationError,8448,psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,2,['Validat'],['ValidationError']
Security,"util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, True). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:68195,Validat,ValidationError,68195,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"v in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:46574,Validat,ValidationError,46574,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmetrize cannot be called while cartesian constraints are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slightly broken.; molecule.symmetrize(core.get_option(""OPTKING"", ""CARTESIAN_SYM_TOLERANCE"")). if molecule.schoenflies_symbol() != initial_sym:; raise ValidationError(""Point group changed! (%s <-- %s) You should restart ""; ""using the last geometry in the output, after ""; ""carefully making sure all symmetry-dependent ""; ""input, such as DOCC, is correct."" % (current_sym, initial_sym)). kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # We'll currently ignore the possibility that the gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_data being wiped; G, wfn = gradient(lowername, return_wfn=True, molecule=molecule, **kwargs); thisenergy = core.variable('CURRENT ENERGY'); opt_object.E = thisenergy; opt_object.gX = G.np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.he",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:72901,Validat,ValidationError,72901,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['Validat'],['ValidationError']
Security,"v1 gets uploaded. May help to check versions and build versions against ltrtver in conda_build_config.yaml.; This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from “main”, not “dev”). Build Psi4conda set¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They can be built anywhere (Mac can be built on Linux) and get served from vergil (cdsgroup webserver). Need a conda env with constructor and cookiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and this gets regenerated each time. Clear out between runs.; python run.py; [Outdated] Watch out for py_ in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recipe and rebuild for all OS & Python combinations. Then run constructor again.; [Replaceme",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_release-1.html:11472,hash,hash,11472,psi4manual/1.4.0/manage_release-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_release-1.html,2,['hash'],['hash']
Security,"v[2] * u[1],; v[2] * u[0] - v[0] * u[2],; v[0] * u[1] - v[1] * u[0]]. [docs]def rotate(v, theta, axis):; """"""Rotate length 3 vector *v* about *axis* by *theta* radians.""""""; if len(v) != 3 or len(axis) != 3:; raise ValidationError('rotate() only defined for vectors of length 3\n'). unitaxis = normalize(copy.deepcopy(axis)); # split into parallel and perpendicular components along axis; parallel = scale(axis, dot(v, axis) / dot(axis, axis)); perpendicular = sub(v, parallel); # form unit vector perpendicular to parallel and perpendicular; third_axis = perp_unit(axis, perpendicular); third_axis = scale(third_axis, norm(perpendicular)). result = add(parallel, add(scale(perpendicular, math.cos(theta)), scale(third_axis, math.sin(theta)))); for item in range(len(result)):; if math.fabs(result[item]) < ZERO:; result[item] = 0.0; return result. [docs]def perp_unit(u, v):; """"""Compute unit vector perpendicular to length 3 vectors *u* and *v*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('perp_unit() only defined for vectors of length 3\n'). # try cross product; result = cross(u, v); resultdotresult = dot(result, result). if resultdotresult < 1.E-16:; # cross product is too small to normalize; # find the largest of this and v; dotprodt = dot(u, u); dotprodv = dot(v, v); if dotprodt < dotprodv:; d = copy.deepcopy(v); dotprodd = dotprodv; else:; d = copy.deepcopy(u); dotprodd = dotprodt. # see if d is big enough; if dotprodd < 1.e-16:; # choose an arbitrary vector, since the biggest vector is small; result = [1.0, 0.0, 0.0]; return result; else:; # choose a vector perpendicular to d; # choose it in one of the planes xy, xz, yz; # choose the plane to be that which contains the two largest components of d; absd = [math.fabs(d[0]), math.fabs(d[1]), math.fabs(d[2])]; if (absd[1] - absd[0]) > 1.0e-12:; #if absd[0] < absd[1]:; axis0 = 1; if (absd[2] - absd[0]) > 1.0e-12:; #if absd[0] < absd[2]:; axis1 = 2; else:; axis1 = 0; else:; axis0 = 0; if (absd[2] - absd[1]) > 1.0e-12:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html:3578,Validat,ValidationError,3578,psi4manual/1.0.0/_modules/qcdb/vecutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html,4,['Validat'],['ValidationError']
Security,"validate_MOM():; """"""Sanity-checks MOM control options. Raises; ------; ValidationError; If any of |scf__mom_start|, |scf__mom_occ| don't play well together. Returns; -------; bool; Whether excited-state MOM (not just the plain stabilizing MOM) is enabled during scf. """"""; enabled = (core.get_option('SCF', ""MOM_START"") != 0 and len(core.get_option('SCF', ""MOM_OCC"")) > 0); if enabled:; start = core.get_option('SCF', ""MOM_START""); if enabled < 0:; raise ValidationError('SCF MOM_START ({}) must be at least 1'.format(start)). return enabled. def _validate_soscf():; """"""Sanity-checks SOSCF control options. Raises; ------; ValidationError; If any of |scf__soscf|, |scf__soscf_start_convergence|,; |scf__soscf_min_iter|, |scf__soscf_max_iter| don't play well together. Returns; -------; bool; Whether SOSCF is enabled during scf. """"""; enabled = core.get_option('SCF', 'SOSCF'); if enabled:; start = core.get_option('SCF', 'SOSCF_START_CONVERGENCE'); if start < 0.0:; raise ValidationError('SCF SOSCF_START_CONVERGENCE ({}) must be positive'.format(start)). miniter = core.get_option('SCF', 'SOSCF_MIN_ITER'); if miniter < 1:; raise ValidationError('SCF SOSCF_MIN_ITER ({}) must be at least 1'.format(miniter)). maxiter = core.get_option('SCF', 'SOSCF_MAX_ITER'); if maxiter < miniter:; raise ValidationError(; 'SCF SOSCF_MAX_ITER ({}) must be at least SOSCF_MIN_ITER ({})'.format(maxiter, miniter)). conv = core.get_option('SCF', 'SOSCF_CONV'); if conv < 1.e-10:; raise ValidationError('SCF SOSCF_CONV ({}) must be achievable'.format(conv)). return enabled. def field_fn(xyz):; """"""Callback function for PylibEFP to compute electric field from electrons; in ab initio part for libefp polarization calculation. Parameters; ----------; xyz : list; (3 * npt, ) flat array of points at which to compute electric field. Returns; -------; list; (3 * npt, ) flat array of electric field at points in `xyz`. Notes; -----; Function signature defined by libefp, so function uses number of; basis functions and int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:25734,Validat,ValidationError,25734,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security,"value - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). optstash.restore(); return scf_wfn. def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_local_option('SCF', 'SCF_TYPE', 'DF'). core.set_local_option('SCF', 'DFT_FUNCTIONAL', name.upper()). user_ref = core.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). wfn = run_scf_gradient(name, **kwargs). optstash.restore(); return wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; core.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name in ['mp', 'mp2', '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:86068,Validat,ValidationError,86068,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"variable value %20.12f for variable %s\\n' % (core.variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; core.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; core.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); core.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); core.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:23634,Validat,ValidationError,23634,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int) → str¶; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]¶; Exports coordinate info into NumPy arrays. Parameters. dummy (bool) – Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool) – Whether or not to treat ghost atoms as dummies. Return type; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]¶; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with cur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html:36012,hash,hash,36012,psi4manual/1.4.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html,3,['hash'],['hash']
Security,"vate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in external_indices:; PsiMod.print_out('%-3d ' % (k)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). # Run the total molecule, if r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:5584,Validat,ValidationError,5584,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"vate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in external_indices:; PsiMod.print_out('%-3d ' % (k)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). # Run the total molecule, if required; energies_full = {}; energies_mon = {}; N = molecule.nf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:5640,Validat,ValidationError,5640,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"vec.close_io_files(True). def prepare_sapt_molecule(sapt_dimer, sapt_basis):; """"""; Prepares a dimer molecule for a SAPT computations. Returns the dimer, monomerA, and monomerB.; """""". # Shifting to C1 so we need to copy the active molecule; sapt_dimer = sapt_dimer.clone(); if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(); else:; sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e; sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True). nfrag = sapt_dimer.nfragments(). if nfrag == 3:; # Midbond case; if sapt_basis == 'monomer':; raise ValidationError(""SAPT basis cannot both be monomer centered and have midbond functions.""). midbond = sapt_dimer.extract_subsets(3); ztotal = 0; for n in range(midbond.natom()):; ztotal += midbond.Z(n). if ztotal > 0:; raise ValidationError(""SAPT third monomr must be a midbond function (all ghosts).""). ghosts = ([2, 3], [1, 3]); elif nfrag == 2:; # Classical dimer case; ghosts = (2, 1); else:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). if sapt_basis == 'dimer':; monomerA = sapt_dimer.extract_subsets(1, ghosts[0]); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, ghosts[1]); monomerB.set_name('monomerB'); elif sapt_basis == 'monomer':; monomerA = sapt_dimer.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2); monomerB.set_name('monomerB'); else:; raise ValidationError(""SAPT basis %s not recognized"" % sapt_basis). return (sapt_dimer, monomerA, monomerB). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.2.1;  · . PSI4. Module code. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html:7563,Validat,ValidationError,7563,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,3,['Validat'],['ValidationError']
Security,"vecs < minvecs:; raise ValidationError(; 'SCF DIIS_MAX_VECS ({}) must be at least DIIS_MIN_VECS ({})'.format(maxvecs, minvecs)). return enabled. def _validate_frac():; """"""Sanity-checks FRAC control options. Raises; ------; ValidationError; If any of |scf__frac_start| don't play well together. Returns; -------; bool; Whether FRAC is enabled during scf. """"""; enabled = (core.get_option('SCF', 'FRAC_START') != 0); if enabled:; if enabled < 0:; raise ValidationError('SCF FRAC_START ({}) must be at least 1'.format(enabled)). return enabled. def _validate_MOM():; """"""Sanity-checks MOM control options. Raises; ------; ValidationError; If any of |scf__mom_start|, |scf__mom_occ| don't play well together. Returns; -------; bool; Whether excited-state MOM (not just the plain stabilizing MOM) is enabled during scf. """"""; enabled = (core.get_option('SCF', ""MOM_START"") != 0 and len(core.get_option('SCF', ""MOM_OCC"")) > 0); if enabled:; start = core.get_option('SCF', ""MOM_START""); if enabled < 0:; raise ValidationError('SCF MOM_START ({}) must be at least 1'.format(start)). return enabled. def _validate_soscf():; """"""Sanity-checks SOSCF control options. Raises; ------; ValidationError; If any of |scf__soscf|, |scf__soscf_start_convergence|,; |scf__soscf_min_iter|, |scf__soscf_max_iter| don't play well together. Returns; -------; bool; Whether SOSCF is enabled during scf. """"""; enabled = core.get_option('SCF', 'SOSCF'); if enabled:; start = core.get_option('SCF', 'SOSCF_START_CONVERGENCE'); if start < 0.0:; raise ValidationError('SCF SOSCF_START_CONVERGENCE ({}) must be positive'.format(start)). miniter = core.get_option('SCF', 'SOSCF_MIN_ITER'); if miniter < 1:; raise ValidationError('SCF SOSCF_MIN_ITER ({}) must be at least 1'.format(miniter)). maxiter = core.get_option('SCF', 'SOSCF_MAX_ITER'); if maxiter < miniter:; raise ValidationError(; 'SCF SOSCF_MAX_ITER ({}) must be at least SOSCF_MIN_ITER ({})'.format(maxiter, miniter)). conv = core.get_option('SCF', 'SOSCF_CONV'); if conv < 1.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:25217,Validat,ValidationError,25217,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security,"vefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.get_variable('CURRENT ENERGY'), wfn); else:; return core.get_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Gradient: Cannot specify bsse_type for gradient yet.""). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Figure out lowername, dertype, and func; # If we have analytical gradients we want to pass to our wrappers, otherwise we want to run; # finite-diference energy or cbs energies; # TODO MP5/cc-pv[DT]Z behavior unkown due to ""levels""; user_dertype = kwargs.pop('dertype', None); if gradient_type == 'custom_function':; if user_dertype is None:; dertype = 0; core.print_out(""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""); else:; core.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:33633,Validat,ValidationError,33633,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"vefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. DIISEntry; docstring. DIISManager; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ExternalPotential; Stores external potential field, computes external potential matrix. FCHKWriter; Extracts information from a wavefunction object, and writes it to an FCHK file. FDDS_Dispersion; docstring. FISAPT; A Fragment-SAPT Wavefunction. FittedSlaterCorrelationFactor; docstring. FittingMetric; docstring. FragmentType; Fragment activation status. Functional; docstring. GaussianShell; Class containing information about basis functions. GaussianType; 0 if Cartesian, 1 if Pure. GeometryUnits; The units used to define the geometry. HF; docstring. IO; docstring. IOManager; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation. IntVector; Class handling vectors with integer values. IntegralFactory; Computes integrals. IntegralTransform; IntegralTransform transforms one- and two",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:12635,access,access,12635,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,2,['access'],['access']
Security,"vel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dft1-alt; DFT Functional Test. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dcft-grad3; Restricted DF-DCFT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradients. scf5; Test of all different algorithms and reference types for SCF, on singlet and tri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:5135,Access,Accesses,5135,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['Access'],['Accesses']
Security,"vel"": ""cepa(3)"", ""cepa_no_singles"": False,},; ""fno-cepa(3)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(3)"", ""cepa_no_singles"": False,},. ""acpf"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},; ""fno-acpf"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},. ""aqcc"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},; ""fno-aqcc"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},. ""cisd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; ""fno-cisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. some of these pre-trapped by select_* functions but others escape, incl. cepa variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_cepa`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:177636,Validat,ValidationError,177636,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"ver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; }; }; }. Fields:. basis (str); computed (bool); driver (qcelemental.models.common_models.DriverEnum); keywords (Dict[str, Any]); method (str); molecule (Any); result (Any); result_id (Optional[str]). Validators:. set_basis » basis; set_keywords » keywords; set_method » method. field basis: str [Required]¶; The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, …). Validated by:. set_basis. field computed: bool = False¶; Whether quantum chemistry has been run on this task. field driver: DriverEnum [Required]¶; The resulting type of computation: energy, gradient, hessian, properties.Note for finite difference that this should be the target driver, not the means driver. field keywords: Dict[str, Any] [Optional]¶; The keywords to use in the computation. Validated by:. set_keywords. field method: str [Required]¶; The quantum chemistry method to evaluate (e.g., B3LYP, MP2, …). Validated by:. set_method. field molecule: Any [Required]¶; The molecule to use in the computation. field result: Any [Optional]¶; AtomicResult return. field result_id: Optional[str] = None¶; The optional ID for the computation. compute(client=None)[source]¶; Run quantum chemistry. Parameters:; client (Optional[qcportal.client.FractalClient]) – . get_results(client=None)[source]¶; Return results as Atomic-flavored QCSchema. Return type:; AtomicResult. Parameters:; client (Optional[FractalClient]) – . plan()[source]¶; Form QCSchema input from member data. Return type:; AtomicInput. validator set_basis  »  psi4.driver.AtomicComputer.basis[source]¶. validator set_keywords  »  psi4.driver.AtomicComputer.keywords[source]¶. validator set_method  »  psi4.driver.AtomicComputer.method[source]¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; AtomicComputer. © Copyright 2007-2022, The Psi4 Project.; Last updated on ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.AtomicComputer.html:2702,Validat,Validated,2702,psi4manual/1.7.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.AtomicComputer.html,1,['Validat'],['Validated']
Security,"ver); pass; elif isinstance(mol, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); mol = Molecule(mol); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # Validate arguments; if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError(""""""Requested derivative level 'dertype' %s not valid for run_dftd3."""""" % (dertype)); else:; raise ValidationError(""""""Requested derivative level 'dertype' %s not valid for run_dftd3."""""" % (dertype)). if dashlvl is not None:; dashlvl = dashlvl.lower(); dashlvl = get_dispersion_aliases()[dashlvl] if dashlvl in get_dispersion_aliases() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())); else:; raise ValidationError(""""""Must specify a dashlvl""""""). if func is not None:; dftd3_params = dash_server(func, dashlvl); else:; dftd3_params = {}. if dashparam is not None:; dftd3_params.update(dashparam). # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Find out if running from Psi4 for scratch details and such; # try:; # import psi4; # except ImportError as err:; # isP4regime = False; # else:; # isP4regime = True",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html:5474,Validat,ValidationError,5474,psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"verters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on each side; expand_side = (np.max(poles) - np.min(poles)) / 5; x = np.linspace(np.min(poles) - expand_side, np.max(poles) + expand_side, npoints). # Validate lineshape; lineshape = lineshape.lower(); valid_lineshapes = [""gaussian"", ""lorentzian""]; if lineshape not in valid_lineshapes:; raise ValueError(f""Lineshape {lineshape} not among recognized ({valid_lineshapes})""). # Obtain lineshape function; shape = Gaussian(x, gammas[out_units]) if lineshape == ""gaussian"" else Lorentzian(x, gammas[out_units]). # Generate y axis, i.e. molar decadic absorption coefficient; prefactor = prefactor_opa() if kind == ""opa"" else prefactor_ecd(); transform_residue = (lambda x: x**2) if kind == ""opa"" else (lambda x: x); y = prefactor * x * np.sum([transform_residue(r) * shape.lineshape(p) for p, r in zip(poles, residues)], axis=0). # Generate sticks; sticks = prefactor * np.array([p * transform_residue(r) * shape.maximum(p) for p, r in zip(poles, residues)]). return {""convolution"": {""x"": x, ""y"": y}, ""sticks"": {""poles"": poles, ""residues"": sticks}}. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/spectrum.html:12082,Validat,Validate,12082,psi4manual/master/_modules/psi4/driver/p4util/spectrum.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/spectrum.html,1,['Validat'],['Validate']
Security,"verters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on each side; expand_side = (np.max(poles) - np.min(poles)) / 5; x = np.linspace(np.min(poles) - expand_side, np.max(poles) + expand_side, npoints). # Validate lineshape; lineshape = lineshape.lower(); valid_lineshapes = [""gaussian"", ""lorentzian""]; if lineshape not in valid_lineshapes:; raise ValueError(f""Lineshape {lineshape} not among recognized ({valid_lineshapes})""). # Obtain lineshape function; shape = Gaussian(x, gammas[out_units]) if lineshape == ""gaussian"" else Lorentzian(x, gammas[out_units]). # Generate y axis, i.e. molar decadic absorption coefficient; prefactor = prefactor_opa() if kind == ""opa"" else prefactor_ecd(); transform_residue = (lambda x: x**2) if kind == ""opa"" else (lambda x: x); y = prefactor * x * np.sum([transform_residue(r) * shape.lineshape(p) for p, r in zip(poles, residues)], axis=0). # Generate sticks; sticks = prefactor * np.array([p * transform_residue(r) * shape.maximum(p) for p, r in zip(poles, residues)]). return {""convolution"": {""x"": x, ""y"": y}, ""sticks"": {""poles"": poles, ""residues"": sticks}}. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.p4util.sp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:12055,Validat,Validate,12055,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,1,['Validat'],['Validate']
Security,"verters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on each side; expand_side = (np.max(poles) - np.min(poles)) / 5; x = np.linspace(np.min(poles) - expand_side, np.max(poles) + expand_side, npoints). # Validate lineshape; lineshape = lineshape.lower(); valid_lineshapes = [""gaussian"", ""lorentzian""]; if lineshape not in valid_lineshapes:; raise ValueError(f""Lineshape {lineshape} not among recognized ({valid_lineshapes})""). # Obtain lineshape function; shape = Gaussian(x, gammas[out_units]) if lineshape == ""gaussian"" else Lorentzian(x, gammas[out_units]). # Generate y axis, i.e. molar decadic absorption coefficient; prefactor = prefactor_opa() if kind == ""opa"" else prefactor_ecd(); transform_residue = (lambda x: x**2) if kind == ""opa"" else (lambda x: x); y = prefactor * x * np.sum([transform_residue(r) * shape.lineshape(p) for p, r in zip(poles, residues)], axis=0). # Generate sticks; sticks = prefactor * np.array([p * transform_residue(r) * shape.maximum(p) for p, r in zip(poles, residues)]). return {""convolution"": {""x"": x, ""y"": y}, ""sticks"": {""poles"": poles, ""residues"": sticks}}. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; psi4.driver.p4util.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html:12075,Validat,Validate,12075,psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,1,['Validat'],['Validate']
Security,"verters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on each side; expand_side = (np.max(poles) - np.min(poles)) / 5; x = np.linspace(np.min(poles) - expand_side, np.max(poles) + expand_side, npoints). # Validate lineshape; lineshape = lineshape.lower(); valid_lineshapes = [""gaussian"", ""lorentzian""]; if lineshape not in valid_lineshapes:; raise ValueError(f""Lineshape {lineshape} not among recognized ({valid_lineshapes})""). # Obtain lineshape function; shape = Gaussian(x, gammas[out_units]) if lineshape == ""gaussian"" else Lorentzian(x, gammas[out_units]). # Generate y axis, i.e. molar decadic absorption coefficient; prefactor = prefactor_opa() if kind == ""opa"" else prefactor_ecd(); transform_residue = (lambda x: x**2) if kind == ""opa"" else (lambda x: x); y = prefactor * x * np.sum([transform_residue(r) * shape.lineshape(p) for p, r in zip(poles, residues)], axis=0). # Generate sticks; sticks = prefactor * np.array([p * transform_residue(r) * shape.maximum(p) for p, r in zip(poles, residues)]). return {""convolution"": {""x"": x, ""y"": y}, ""sticks"": {""poles"": poles, ""residues"": sticks}}. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.p4util.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/spectrum.html:12075,Validat,Validate,12075,psi4manual/1.9.x/_modules/psi4/driver/p4util/spectrum.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/spectrum.html,1,['Validat'],['Validate']
